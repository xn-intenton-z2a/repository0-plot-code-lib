Intl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nResources for Developers, by DevelopersDocumenting web technologies, including CSS, HTML, and JavaScript, since 2005.Search MDNClear search inputSearchFeatured articlesBlogJavaScript Temporal is comingA new way to handle dates and times is being added to JavaScript. Let's take a look at Temporal, what problems it solves, the current state, and what you'll find in the new documentation about it on MDN.
CSSCSS anchor positioningThe CSS anchor positioning module defines features that allow you to tether elements together. Certain elements are defined as anchor elements; anchor-positioned elements can then have their size and position set based on the size and location of the anchor elements to which they are bound.
Web APIsUsing the View Transition APIThis article explains the theory behind how the View Transition API works, how to create view transitions and customize the transition animations, and how to manipulate active view transitions. This covers view transitions for both DOM state updates in a single-page app (SPA), and navigating between documents in a multi-page app (MPA).
JavaScriptTemporalThe Temporal object enables date and time management in various scenarios, including built-in time zone and calendar representation, wall-clock time conversions, arithmetics, formatting, and more. It is designed as a full replacement for the Date object.
Latest newsMDN 2024 content projectsdeveloper.mozilla.org4 months agoA new learning experience on MDNdeveloper.mozilla.org4 months agoIntroducing the new MDN Community pagedeveloper.mozilla.org6 months agoRecent contributions[zh-cn]: update the translation of CSS writing modesmdn/translated-content19 hours ago2025/03/22 時点の英語版に同期mdn/translated-content12 hours ago2025/04/10 時点の英語版に同期mdn/translated-content12 hours agoBump autocorrect-node from 2.13.3 to 2.14.0mdn/translated-content11 hours agoBump lefthook from 1.11.11 to 1.11.12mdn/translated-content11 hours agoUse proper ellipsis charactermdn/content9 hours agoBump cspell from 8.19.2 to 8.19.3mdn/content9 hours agoBump lefthook from 1.11.11 to 1.11.12mdn/content8 hours agoFix plaindate.compare return value explanationmdn/content7 hours agoAdd HTML attribute templatemdn/contentan hour agoContributor SpotlightYash Raj BhartiMDN resonates with my passion to build a consistent and open web, where developers can learn and grow.Get involved →\n\nResources for Developers, by DevelopersDocumenting web technologies, including CSS, HTML, and JavaScript, since 2005.Search MDNClear search inputSearchFeatured articlesBlogJavaScript Temporal is comingA new way to handle dates and times is being added to JavaScript. Let's take a look at Temporal, what problems it solves, the current state, and what you'll find in the new documentation about it on MDN.
CSSCSS anchor positioningThe CSS anchor positioning module defines features that allow you to tether elements together. Certain elements are defined as anchor elements; anchor-positioned elements can then have their size and position set based on the size and location of the anchor elements to which they are bound.
Web APIsUsing the View Transition APIThis article explains the theory behind how the View Transition API works, how to create view transitions and customize the transition animations, and how to manipulate active view transitions. This covers view transitions for both DOM state updates in a single-page app (SPA), and navigating between documents in a multi-page app (MPA).
JavaScriptTemporalThe Temporal object enables date and time management in various scenarios, including built-in time zone and calendar representation, wall-clock time conversions, arithmetics, formatting, and more. It is designed as a full replacement for the Date object.
Latest newsMDN 2024 content projectsdeveloper.mozilla.org4 months agoA new learning experience on MDNdeveloper.mozilla.org4 months agoIntroducing the new MDN Community pagedeveloper.mozilla.org6 months agoRecent contributions[zh-cn]: update the translation of CSS writing modesmdn/translated-content19 hours ago2025/03/22 時点の英語版に同期mdn/translated-content12 hours ago2025/04/10 時点の英語版に同期mdn/translated-content12 hours agoBump autocorrect-node from 2.13.3 to 2.14.0mdn/translated-content11 hours agoBump lefthook from 1.11.11 to 1.11.12mdn/translated-content11 hours agoUse proper ellipsis charactermdn/content9 hours agoBump cspell from 8.19.2 to 8.19.3mdn/content9 hours agoBump lefthook from 1.11.11 to 1.11.12mdn/content8 hours agoFix plaindate.compare return value explanationmdn/content7 hours agoAdd HTML attribute templatemdn/contentan hour agoContributor SpotlightYash Raj BhartiMDN resonates with my passion to build a consistent and open web, where developers can learn and grow.Get involved →\n\n\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

Guides
HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

Guides
HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

Guides
HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nCSS: Cascading Style SheetsCascading Style Sheets (CSS) is a stylesheet language used to describe the presentation of a document written in HTML or XML (including XML dialects such as SVG, MathML or XHTML). CSS describes how elements should be rendered on screen, on paper, in speech, or on other media.
CSS is among the core languages of the open web and is standardized across Web browsers according to W3C specifications. Previously, the development of various parts of CSS specification was done synchronously, which allowed the versioning of the latest recommendations. You might have heard about CSS1, CSS2.1, or even CSS3. There will never be a CSS3 or a CSS4; rather, everything is now just "CSS" with individual CSS modules having version numbers.
After CSS 2.1, the scope of the specification increased significantly and the progress on different CSS modules started to differ so much, that it became more effective to develop and release recommendations separately per module. Instead of versioning the CSS specification, W3C now periodically takes a snapshot of the latest stable state of the CSS specification and individual modules progress. CSS modules now have version numbers, or levels, such as CSS Color Module Level 5.Beginner's tutorials
Your first website: Styling the content

This article provides a brief tour of what CSS is and how to use it, aimed at people who are completely new to web development.

CSS styling basics

Our Learn web development section's CSS basics module teaches CSS fundamentals from the ground up.

CSS text styling

Here we look at fundamentals including setting font, boldness, italics, line and letter spacing, drop shadows, and other text features. We round off the module by looking at applying custom fonts to your page, and styling lists and links.

CSS layout

Now it's time to look at how to correctly lay out your boxes in relation to one another, and the browser viewport. This module looks at floats, positioning, other modern layout tools, and building responsive designs that will adapt to different devices, screen sizes, and resolutions.

ReferenceThe CSS reference is an exhaustive reference for seasoned Web developers, describing every property and concept of CSS, including:

The syntax and forms of the language
Specificity, inheritance, and the cascade
CSS selectors, including pseudo-elements, nesting, scoping and shadow parts
CSS at-rules, including media and container queries
CSS values and units module, including numeric data types, textual data types and functional notations
Box model and margin collapse
The containing block
Stacking and block-formatting contexts
Initial, computed, used, and actual values
CSS shorthand properties
CSS flexible box, multi-column and grid layout
Animation, transitions, and transforms
CookbookThe CSS layout cookbook aims to bring together recipes for common layout patterns, things you might need to implement in your sites. In addition to providing code you can use as a starting point in your projects, these recipes highlight the different ways layout specifications can be used and the choices you can make as a developer.Tools for CSS development
You can use the W3C CSS Validation Service to check if your CSS is valid. This is an invaluable debugging tool.
Firefox Developer Tools lets you view and edit a page's live CSS via the Inspector and Style Editor tools.
The Web Developer extension for Firefox lets you track and edit live CSS on watched sites.
Meta bugs
Firefox: Firefox bug 1323667
See also
Web languages to which CSS is often applied: HTML, SVG, MathML, XHTML, and XML.
Stack Overflow questions about CSS\n\nCSS: Cascading Style SheetsCascading Style Sheets (CSS) is a stylesheet language used to describe the presentation of a document written in HTML or XML (including XML dialects such as SVG, MathML or XHTML). CSS describes how elements should be rendered on screen, on paper, in speech, or on other media.
CSS is among the core languages of the open web and is standardized across Web browsers according to W3C specifications. Previously, the development of various parts of CSS specification was done synchronously, which allowed the versioning of the latest recommendations. You might have heard about CSS1, CSS2.1, or even CSS3. There will never be a CSS3 or a CSS4; rather, everything is now just "CSS" with individual CSS modules having version numbers.
After CSS 2.1, the scope of the specification increased significantly and the progress on different CSS modules started to differ so much, that it became more effective to develop and release recommendations separately per module. Instead of versioning the CSS specification, W3C now periodically takes a snapshot of the latest stable state of the CSS specification and individual modules progress. CSS modules now have version numbers, or levels, such as CSS Color Module Level 5.Beginner's tutorials
Your first website: Styling the content

This article provides a brief tour of what CSS is and how to use it, aimed at people who are completely new to web development.

CSS styling basics

Our Learn web development section's CSS basics module teaches CSS fundamentals from the ground up.

CSS text styling

Here we look at fundamentals including setting font, boldness, italics, line and letter spacing, drop shadows, and other text features. We round off the module by looking at applying custom fonts to your page, and styling lists and links.

CSS layout

Now it's time to look at how to correctly lay out your boxes in relation to one another, and the browser viewport. This module looks at floats, positioning, other modern layout tools, and building responsive designs that will adapt to different devices, screen sizes, and resolutions.

ReferenceThe CSS reference is an exhaustive reference for seasoned Web developers, describing every property and concept of CSS, including:

The syntax and forms of the language
Specificity, inheritance, and the cascade
CSS selectors, including pseudo-elements, nesting, scoping and shadow parts
CSS at-rules, including media and container queries
CSS values and units module, including numeric data types, textual data types and functional notations
Box model and margin collapse
The containing block
Stacking and block-formatting contexts
Initial, computed, used, and actual values
CSS shorthand properties
CSS flexible box, multi-column and grid layout
Animation, transitions, and transforms
CookbookThe CSS layout cookbook aims to bring together recipes for common layout patterns, things you might need to implement in your sites. In addition to providing code you can use as a starting point in your projects, these recipes highlight the different ways layout specifications can be used and the choices you can make as a developer.Tools for CSS development
You can use the W3C CSS Validation Service to check if your CSS is valid. This is an invaluable debugging tool.
Firefox Developer Tools lets you view and edit a page's live CSS via the Inspector and Style Editor tools.
The Web Developer extension for Firefox lets you track and edit live CSS on watched sites.
Meta bugs
Firefox: Firefox bug 1323667
See also
Web languages to which CSS is often applied: HTML, SVG, MathML, XHTML, and XML.
Stack Overflow questions about CSS
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 22, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nCSS: Cascading Style SheetsCascading Style Sheets (CSS) is a stylesheet language used to describe the presentation of a document written in HTML or XML (including XML dialects such as SVG, MathML or XHTML). CSS describes how elements should be rendered on screen, on paper, in speech, or on other media.
CSS is among the core languages of the open web and is standardized across Web browsers according to W3C specifications. Previously, the development of various parts of CSS specification was done synchronously, which allowed the versioning of the latest recommendations. You might have heard about CSS1, CSS2.1, or even CSS3. There will never be a CSS3 or a CSS4; rather, everything is now just "CSS" with individual CSS modules having version numbers.
After CSS 2.1, the scope of the specification increased significantly and the progress on different CSS modules started to differ so much, that it became more effective to develop and release recommendations separately per module. Instead of versioning the CSS specification, W3C now periodically takes a snapshot of the latest stable state of the CSS specification and individual modules progress. CSS modules now have version numbers, or levels, such as CSS Color Module Level 5.Beginner's tutorials
Your first website: Styling the content

This article provides a brief tour of what CSS is and how to use it, aimed at people who are completely new to web development.

CSS styling basics

Our Learn web development section's CSS basics module teaches CSS fundamentals from the ground up.

CSS text styling

Here we look at fundamentals including setting font, boldness, italics, line and letter spacing, drop shadows, and other text features. We round off the module by looking at applying custom fonts to your page, and styling lists and links.

CSS layout

Now it's time to look at how to correctly lay out your boxes in relation to one another, and the browser viewport. This module looks at floats, positioning, other modern layout tools, and building responsive designs that will adapt to different devices, screen sizes, and resolutions.

ReferenceThe CSS reference is an exhaustive reference for seasoned Web developers, describing every property and concept of CSS, including:

The syntax and forms of the language
Specificity, inheritance, and the cascade
CSS selectors, including pseudo-elements, nesting, scoping and shadow parts
CSS at-rules, including media and container queries
CSS values and units module, including numeric data types, textual data types and functional notations
Box model and margin collapse
The containing block
Stacking and block-formatting contexts
Initial, computed, used, and actual values
CSS shorthand properties
CSS flexible box, multi-column and grid layout
Animation, transitions, and transforms
CookbookThe CSS layout cookbook aims to bring together recipes for common layout patterns, things you might need to implement in your sites. In addition to providing code you can use as a starting point in your projects, these recipes highlight the different ways layout specifications can be used and the choices you can make as a developer.Tools for CSS development
You can use the W3C CSS Validation Service to check if your CSS is valid. This is an invaluable debugging tool.
Firefox Developer Tools lets you view and edit a page's live CSS via the Inspector and Style Editor tools.
The Web Developer extension for Firefox lets you track and edit live CSS on watched sites.
Meta bugs
Firefox: Firefox bug 1323667
See also
Web languages to which CSS is often applied: HTML, SVG, MathML, XHTML, and XML.
Stack Overflow questions about CSS
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 22, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJavaScriptJavaScript (JS) is a lightweight interpreted (or just-in-time compiled) programming language with first-class functions. While it is most well-known as the scripting language for Web pages, many non-browser environments also use it, such as Node.js, Apache CouchDB and Adobe Acrobat. JavaScript is a prototype-based, multi-paradigm, single-threaded, dynamic language, supporting object-oriented, imperative, and declarative (e.g., functional programming) styles.
JavaScript's dynamic capabilities include runtime object construction, variable parameter lists, function variables, dynamic script creation (via eval), object introspection (via for...in and Object utilities), and source-code recovery (JavaScript functions store their source text and can be retrieved through toString()).
This section is dedicated to the JavaScript language itself, and not the parts that are specific to Web pages or other host environments. For information about APIs that are specific to Web pages, please see Web APIs and DOM.
The standards for JavaScript are the ECMAScript Language Specification (ECMA-262) and the ECMAScript Internationalization API specification (ECMA-402). As soon as one browser implements a feature, we try to document it. This means that cases where some proposals for new ECMAScript features have already been implemented in browsers, documentation and examples in MDN articles may use some of those new features. Most of the time, this happens between the stages 3 and 4, and is usually before the spec is officially published.
Do not confuse JavaScript with the Java programming language — JavaScript is not "Interpreted Java". Both "Java" and "JavaScript" are trademarks or registered trademarks of Oracle in the U.S. and other countries. However, the two programming languages have very different syntax, semantics, and use.
JavaScript documentation of core language features (pure ECMAScript, for the most part) includes the following:

The JavaScript guide
The JavaScript reference

For more information about JavaScript specifications and related technologies, see JavaScript technologies overview.Beginner's tutorialsLearn how to program in JavaScript from the ground up with our beginner's tutorials.

Your first website: Adding interactivity

This article provides a brief tour of what JavaScript is and how to use it, aimed at people who are completely new to web development.

Dynamic scripting with JavaScript

Our Learn web development section's JavaScript module teaches all the JavaScript fundamentals from the ground up.

JavaScript frameworks and libraries

JavaScript frameworks are an essential part of modern front-end web development, providing developers with tried and tested tools for building scalable, interactive web applications. Many modern companies use frameworks as a standard part of their tooling, so many front-end development jobs now require framework experience. In this set of articles, we aim to give you a comfortable starting point to help you begin learning frameworks.

JavaScript guidesFundamental language guides
JavaScript Guide

A much more detailed guide to the JavaScript language, aimed at those with previous programming experience either in JavaScript or another language.

Intermediate
Advanced JavaScript objects

The object-oriented nature of JavaScript is important to understand if you want to go further with your knowledge of the language and write more efficient code, therefore we've provided this module to help you.

Asynchronous JavaScript

In this module, we take a look at asynchronous JavaScript, why it is important, and how it can be used to effectively handle potential blocking operations, such as fetching resources from a server.

Client-side web APIs

Explores what APIs are, and how to use some of the most common APIs you'll come across often in your development work.

JavaScript language overview

An overview of the basic syntax and semantics of JavaScript for those coming from other programming languages to get up to speed.

JavaScript data structures

Overview of available data structures in JavaScript.

Equality comparisons and sameness

JavaScript provides three different value comparison operations: strict equality using ===, loose equality using ==, and the Object.is() method.

Enumerability and ownership of properties

How different methods that visit a group of object properties one-by-one handle the enumerability and ownership of properties.

Closures

A closure is the combination of a function and the lexical environment within which that function was declared.

Advanced
Inheritance and the prototype chain

Explanation of the widely misunderstood and underestimated prototype-based inheritance.

Memory Management

Memory life cycle and garbage collection in JavaScript.

ReferenceBrowse the complete JavaScript reference documentation.

Standard objects

Get to know standard built-in objects: Array, Boolean, Error, Function, JSON, Math, Number, Object, RegExp, String, Map, Set, WeakMap, WeakSet, and others.

Expressions and operators

Learn more about the behavior of JavaScript's operators instanceof, typeof, new, this, the operator precedence, and more.

Statements and declarations

Learn how do-while, for-in, for-of, try-catch, let, var, const, if-else, switch, and more JavaScript statements and keywords work.

Functions

Learn how to work with JavaScript's functions to develop your applications.

Classes

JavaScript classes are the most appropriate way to do object-oriented programming.\n\nJavaScriptJavaScript (JS) is a lightweight interpreted (or just-in-time compiled) programming language with first-class functions. While it is most well-known as the scripting language for Web pages, many non-browser environments also use it, such as Node.js, Apache CouchDB and Adobe Acrobat. JavaScript is a prototype-based, multi-paradigm, single-threaded, dynamic language, supporting object-oriented, imperative, and declarative (e.g., functional programming) styles.
JavaScript's dynamic capabilities include runtime object construction, variable parameter lists, function variables, dynamic script creation (via eval), object introspection (via for...in and Object utilities), and source-code recovery (JavaScript functions store their source text and can be retrieved through toString()).
This section is dedicated to the JavaScript language itself, and not the parts that are specific to Web pages or other host environments. For information about APIs that are specific to Web pages, please see Web APIs and DOM.
The standards for JavaScript are the ECMAScript Language Specification (ECMA-262) and the ECMAScript Internationalization API specification (ECMA-402). As soon as one browser implements a feature, we try to document it. This means that cases where some proposals for new ECMAScript features have already been implemented in browsers, documentation and examples in MDN articles may use some of those new features. Most of the time, this happens between the stages 3 and 4, and is usually before the spec is officially published.
Do not confuse JavaScript with the Java programming language — JavaScript is not "Interpreted Java". Both "Java" and "JavaScript" are trademarks or registered trademarks of Oracle in the U.S. and other countries. However, the two programming languages have very different syntax, semantics, and use.
JavaScript documentation of core language features (pure ECMAScript, for the most part) includes the following:

The JavaScript guide
The JavaScript reference

For more information about JavaScript specifications and related technologies, see JavaScript technologies overview.Beginner's tutorialsLearn how to program in JavaScript from the ground up with our beginner's tutorials.

Your first website: Adding interactivity

This article provides a brief tour of what JavaScript is and how to use it, aimed at people who are completely new to web development.

Dynamic scripting with JavaScript

Our Learn web development section's JavaScript module teaches all the JavaScript fundamentals from the ground up.

JavaScript frameworks and libraries

JavaScript frameworks are an essential part of modern front-end web development, providing developers with tried and tested tools for building scalable, interactive web applications. Many modern companies use frameworks as a standard part of their tooling, so many front-end development jobs now require framework experience. In this set of articles, we aim to give you a comfortable starting point to help you begin learning frameworks.

JavaScript guidesFundamental language guides
JavaScript Guide

A much more detailed guide to the JavaScript language, aimed at those with previous programming experience either in JavaScript or another language.

Intermediate
Advanced JavaScript objects

The object-oriented nature of JavaScript is important to understand if you want to go further with your knowledge of the language and write more efficient code, therefore we've provided this module to help you.

Asynchronous JavaScript

In this module, we take a look at asynchronous JavaScript, why it is important, and how it can be used to effectively handle potential blocking operations, such as fetching resources from a server.

Client-side web APIs

Explores what APIs are, and how to use some of the most common APIs you'll come across often in your development work.

JavaScript language overview

An overview of the basic syntax and semantics of JavaScript for those coming from other programming languages to get up to speed.

JavaScript data structures

Overview of available data structures in JavaScript.

Equality comparisons and sameness

JavaScript provides three different value comparison operations: strict equality using ===, loose equality using ==, and the Object.is() method.

Enumerability and ownership of properties

How different methods that visit a group of object properties one-by-one handle the enumerability and ownership of properties.

Closures

A closure is the combination of a function and the lexical environment within which that function was declared.

Advanced
Inheritance and the prototype chain

Explanation of the widely misunderstood and underestimated prototype-based inheritance.

Memory Management

Memory life cycle and garbage collection in JavaScript.

ReferenceBrowse the complete JavaScript reference documentation.

Standard objects

Get to know standard built-in objects: Array, Boolean, Error, Function, JSON, Math, Number, Object, RegExp, String, Map, Set, WeakMap, WeakSet, and others.

Expressions and operators

Learn more about the behavior of JavaScript's operators instanceof, typeof, new, this, the operator precedence, and more.

Statements and declarations

Learn how do-while, for-in, for-of, try-catch, let, var, const, if-else, switch, and more JavaScript statements and keywords work.

Functions

Learn how to work with JavaScript's functions to develop your applications.

Classes

JavaScript classes are the most appropriate way to do object-oriented programming.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJavaScriptJavaScript (JS) is a lightweight interpreted (or just-in-time compiled) programming language with first-class functions. While it is most well-known as the scripting language for Web pages, many non-browser environments also use it, such as Node.js, Apache CouchDB and Adobe Acrobat. JavaScript is a prototype-based, multi-paradigm, single-threaded, dynamic language, supporting object-oriented, imperative, and declarative (e.g., functional programming) styles.
JavaScript's dynamic capabilities include runtime object construction, variable parameter lists, function variables, dynamic script creation (via eval), object introspection (via for...in and Object utilities), and source-code recovery (JavaScript functions store their source text and can be retrieved through toString()).
This section is dedicated to the JavaScript language itself, and not the parts that are specific to Web pages or other host environments. For information about APIs that are specific to Web pages, please see Web APIs and DOM.
The standards for JavaScript are the ECMAScript Language Specification (ECMA-262) and the ECMAScript Internationalization API specification (ECMA-402). As soon as one browser implements a feature, we try to document it. This means that cases where some proposals for new ECMAScript features have already been implemented in browsers, documentation and examples in MDN articles may use some of those new features. Most of the time, this happens between the stages 3 and 4, and is usually before the spec is officially published.
Do not confuse JavaScript with the Java programming language — JavaScript is not "Interpreted Java". Both "Java" and "JavaScript" are trademarks or registered trademarks of Oracle in the U.S. and other countries. However, the two programming languages have very different syntax, semantics, and use.
JavaScript documentation of core language features (pure ECMAScript, for the most part) includes the following:

The JavaScript guide
The JavaScript reference

For more information about JavaScript specifications and related technologies, see JavaScript technologies overview.Beginner's tutorialsLearn how to program in JavaScript from the ground up with our beginner's tutorials.

Your first website: Adding interactivity

This article provides a brief tour of what JavaScript is and how to use it, aimed at people who are completely new to web development.

Dynamic scripting with JavaScript

Our Learn web development section's JavaScript module teaches all the JavaScript fundamentals from the ground up.

JavaScript frameworks and libraries

JavaScript frameworks are an essential part of modern front-end web development, providing developers with tried and tested tools for building scalable, interactive web applications. Many modern companies use frameworks as a standard part of their tooling, so many front-end development jobs now require framework experience. In this set of articles, we aim to give you a comfortable starting point to help you begin learning frameworks.

JavaScript guidesFundamental language guides
JavaScript Guide

A much more detailed guide to the JavaScript language, aimed at those with previous programming experience either in JavaScript or another language.

Intermediate
Advanced JavaScript objects

The object-oriented nature of JavaScript is important to understand if you want to go further with your knowledge of the language and write more efficient code, therefore we've provided this module to help you.

Asynchronous JavaScript

In this module, we take a look at asynchronous JavaScript, why it is important, and how it can be used to effectively handle potential blocking operations, such as fetching resources from a server.

Client-side web APIs

Explores what APIs are, and how to use some of the most common APIs you'll come across often in your development work.

JavaScript language overview

An overview of the basic syntax and semantics of JavaScript for those coming from other programming languages to get up to speed.

JavaScript data structures

Overview of available data structures in JavaScript.

Equality comparisons and sameness

JavaScript provides three different value comparison operations: strict equality using ===, loose equality using ==, and the Object.is() method.

Enumerability and ownership of properties

How different methods that visit a group of object properties one-by-one handle the enumerability and ownership of properties.

Closures

A closure is the combination of a function and the lexical environment within which that function was declared.

Advanced
Inheritance and the prototype chain

Explanation of the widely misunderstood and underestimated prototype-based inheritance.

Memory Management

Memory life cycle and garbage collection in JavaScript.

ReferenceBrowse the complete JavaScript reference documentation.

Standard objects

Get to know standard built-in objects: Array, Boolean, Error, Function, JSON, Math, Number, Object, RegExp, String, Map, Set, WeakMap, WeakSet, and others.

Expressions and operators

Learn more about the behavior of JavaScript's operators instanceof, typeof, new, this, the operator precedence, and more.

Statements and declarations

Learn how do-while, for-in, for-of, try-catch, let, var, const, if-else, switch, and more JavaScript statements and keywords work.

Functions

Learn how to work with JavaScript's functions to develop your applications.

Classes

JavaScript classes are the most appropriate way to do object-oriented programming.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nHTTPHypertext Transfer Protocol (HTTP) is an application-layer protocol for transmitting hypermedia documents, such as HTML.
It was designed for communication between web browsers and web servers, but it can also be used for other purposes, such as machine-to-machine communication, programmatic access to APIs, and more.
HTTP follows a classical client-server model, with a client opening a connection to make a request, then waiting until it receives a response from the server.
HTTP is a stateless protocol, meaning that the server does not keep any session data between two requests, although the later addition of cookies adds state to some client-server interactions.Reference documentationThe HTTP reference documentation contains detailed information about headers, request methods, status responses, and lists relevant specifications and standards documents.

HTTP headers

Message headers are used to send metadata about a resource or a HTTP message, and to describe the behavior of the client or the server.

HTTP request methods

Request methods indicate the purpose of the request and what is expected if the request is successful.
The most common methods are GET and POST for retrieving and sending data to servers, respectively, but there are other methods which serve different purposes.

HTTP response status codes

Response status codes indicate the outcome of a specific HTTP request.
Responses are grouped in five classes: informational, successful, redirections, client errors, and server errors.

HTTP resources and specifications

This page lists relevant resources about HTTP since it was first specified in the early 1990s.


The following subsections are also notable:

CSP directives

The Content-Security-Policy (CSP) response header allows website administrators to specify which resources the user agent is allowed to load for a given page.
This section lists directives that can be used in a CSP header, with individual documentation pages that describe how the directives work and how to use them.

Permissions-Policy directives

The Permissions-Policy response header provides a mechanism to allow or deny the use of browser features in a document or within any <iframe> element in the document.
This section lists directives that can be used in a Permissions-Policy header, with individual documentation pages that describe how the directives work and how to use them.

HTTP guidesHTTP is an extensible protocol that relies on concepts like resources and Uniform Resource Identifiers (URIs), a basic message structure, and client-server communication model.
On top of these concepts, numerous extensions have been developed over the years that add functionality and updated semantics, including additional HTTP methods and headers.
The guides below are listed in order from general overviews to specialized, use-case-driven topics.
Beginners are encouraged to start with the foundational guides before exploring more focused articles.

Overview of HTTP

The basic features of HTTP, what it can do, its intended use in web architecture, and its position in the protocol stack.

Evolution of HTTP

HTTP was created in the early 1990s and has been extended several times.
This article goes through its history and describes HTTP/0.9, HTTP/1.0, HTTP/1.1, through HTTP/2 and HTTP/3, as well as novelties introduced over the years.

A typical HTTP session

Describes the flow of an HTTP session, from establishing a connection, sending a request, to receiving a response.

HTTP messages

HTTP messages transmitted as requests and responses have a defined structure.
This article describes this general structure, its purpose, and the different types of messages.

MIME types

Since HTTP/1.0, different types of content can be transmitted.
This article explains how this is accomplished using the Content-Type header and the MIME standard.
A shortlist of common types used by web developers can be found in Common MIME types.

Compression in HTTP

Browsers and servers compress their messages before sending them over the network to reduce the amount of data that needs to be transmitted, improving transfer speed and bandwidth utilization.

HTTP caching

Caching is a highly important mechanism for delivering fast experiences on the Web and for efficient use of resources.
This article describes different methods of caching and how to use HTTP headers to control them.

HTTP authentication

Authentication is a way to verify the identity of a client when making requests to a server.
It ensures that only authorized users or systems can access certain resources.

Using HTTP cookies

Although HTTP is a stateless protocol, a server can send a Set-Cookie header with the response.
The client then returns the cookie's value with every subsequent request to the server in the form of a Cookie request header.
This adds the ability to store and exchange a small amount of data which effectively adds state to some client-server interactions.

Redirections in HTTP

URL redirection, also known as URL forwarding, is a technique to give more than one URL address to a page, a form, a whole website, or a web application.
HTTP has a special kind of response, called a HTTP redirect, for this operation.

HTTP conditional requests

In conditional requests, the outcome of a request depends on the value of a validator in the request.
This method is used heavily in caching and use cases such as resuming a download, preventing lost updates when modifying a document on the server, and more.

HTTP range requests

A range request asks the server to send a specific part (or parts) of a resource back to a client instead of the full resource.
Range requests are useful for cases when a client knows they need only part of a large file, or for cases where an application allows the user to pause and resume a download.

Content negotiation

HTTP defines a set of message headers, starting with Accept as a way for a browser to announce the format, language, or encoding it prefers.
This article explains how this advertisement happens, how the server is expected to react, and how it chooses the most adequate response to a request.

Connection management in HTTP/1.x

HTTP/1.1 was the first version of HTTP to support persistent connections and pipelining.
This article explains both concepts, including the pros and cons of each.

Protocol upgrade mechanism

HTTP/1.1 provides a mechanism to upgrade an already-established connection to a different protocol using the Upgrade header.
A client can upgrade a connection from HTTP/1.1 to HTTP/2, or an HTTP(S) connection to a WebSocket (ws / wss).

Proxy servers and tunneling

A proxy can be on the user's local computer, or anywhere between the user's computer and a destination server on the Internet.
This page outlines some basics about proxies and introduces a few configuration options.

HTTP Client hints

Client Hints are a set of response headers that a server can use to proactively request information from a client about the device, network, user, and user-agent-specific preferences.
The server can then determine which resources to send, based on the information that the client chooses to provide.

Network Error Logging 
Experimental


Network Error Logging is a mechanism that can be configured via the NEL HTTP response header.
This experimental header allows websites and applications to opt-in to receive reports about failed (or even successful) network fetches from supporting browsers.

Browser detection using the user agent

It's very rarely a good idea to use user agent sniffing to detect a browser, but there are edge cases that require it.
This document will guide you in doing this as correctly as possible when this is necessary, with an emphasis on considerations to make before embarking on this route.

Security and privacy
Permissions Policy

Permissions Policy provides mechanisms for web developers to explicitly declare what functionality can and cannot be used on a website.
You define a set of "policies" that restrict what APIs the site's code can access or modify the browser's default behavior for certain features.

Cross-Origin Resource Sharing (CORS)

Cross-site HTTP requests are requests for resources from a different domain than that of the resource making the request.
Web pages today very commonly load cross-site resources, for example, a page 'Domain A' (http://domaina.example/) requests an image on 'Domain B' (http://domainb.foo/image.jpg) via the img element.
CORS allows web developers to control how their site reacts to cross-site requests.

Content Security Policy (CSP)

CSP allows website administrators to use the Content-Security-Policy response header to control which resources the client is allowed to load for a given page.
The CSP guide describes the overall Content Security Policy mechanism which helps detect and mitigate certain types of attacks, including Cross-Site Scripting (XSS) and data injection attacks.

Cross-Origin Resource Policy (CORP)

CORP lets websites and applications opt in to protection against specific requests from other origins (such as those issued with elements like <script> and <img>), to mitigate speculative side-channel attacks.

Mozilla web security guidelines

A collection of tips to help operational teams with creating secure web applications.

Related resources
URIs

Uniform Resource Identifiers (URIs) are used to describe and locate resources on the web and are an essential component in HTTP requests.

Configuring servers for Ogg media

This guide covers a few server configuration changes that may be necessary for your web server to correctly serve Ogg media files.
This information may also be useful if you encounter other media types your server isn't already configured to recognize.

Tools & resourcesHelpful tools and resources for understanding and debugging HTTP.

Firefox Developer Tools

Network monitor

HTTP Observatory

A project designed to help developers, system administrators, and security professionals configure their sites safely and securely.

RedBot

Tools to check your cache-related headers.

nghttp2

An HTTP/2 client, server and proxy implementation written in C with load test and benchmarking tools and an HPACK encoder and decoder.

curl

A command-line tool for transferring data specified with URL syntax.
Supports HTTP, HTTPS, WS, WSS, among many other protocols.

How Browsers Work (2011)

A very comprehensive article on browser internals and request flow through HTTP protocol.\n\nHTTPHypertext Transfer Protocol (HTTP) is an application-layer protocol for transmitting hypermedia documents, such as HTML.
It was designed for communication between web browsers and web servers, but it can also be used for other purposes, such as machine-to-machine communication, programmatic access to APIs, and more.
HTTP follows a classical client-server model, with a client opening a connection to make a request, then waiting until it receives a response from the server.
HTTP is a stateless protocol, meaning that the server does not keep any session data between two requests, although the later addition of cookies adds state to some client-server interactions.Reference documentationThe HTTP reference documentation contains detailed information about headers, request methods, status responses, and lists relevant specifications and standards documents.

HTTP headers

Message headers are used to send metadata about a resource or a HTTP message, and to describe the behavior of the client or the server.

HTTP request methods

Request methods indicate the purpose of the request and what is expected if the request is successful.
The most common methods are GET and POST for retrieving and sending data to servers, respectively, but there are other methods which serve different purposes.

HTTP response status codes

Response status codes indicate the outcome of a specific HTTP request.
Responses are grouped in five classes: informational, successful, redirections, client errors, and server errors.

HTTP resources and specifications

This page lists relevant resources about HTTP since it was first specified in the early 1990s.


The following subsections are also notable:

CSP directives

The Content-Security-Policy (CSP) response header allows website administrators to specify which resources the user agent is allowed to load for a given page.
This section lists directives that can be used in a CSP header, with individual documentation pages that describe how the directives work and how to use them.

Permissions-Policy directives

The Permissions-Policy response header provides a mechanism to allow or deny the use of browser features in a document or within any <iframe> element in the document.
This section lists directives that can be used in a Permissions-Policy header, with individual documentation pages that describe how the directives work and how to use them.

HTTP guidesHTTP is an extensible protocol that relies on concepts like resources and Uniform Resource Identifiers (URIs), a basic message structure, and client-server communication model.
On top of these concepts, numerous extensions have been developed over the years that add functionality and updated semantics, including additional HTTP methods and headers.
The guides below are listed in order from general overviews to specialized, use-case-driven topics.
Beginners are encouraged to start with the foundational guides before exploring more focused articles.

Overview of HTTP

The basic features of HTTP, what it can do, its intended use in web architecture, and its position in the protocol stack.

Evolution of HTTP

HTTP was created in the early 1990s and has been extended several times.
This article goes through its history and describes HTTP/0.9, HTTP/1.0, HTTP/1.1, through HTTP/2 and HTTP/3, as well as novelties introduced over the years.

A typical HTTP session

Describes the flow of an HTTP session, from establishing a connection, sending a request, to receiving a response.

HTTP messages

HTTP messages transmitted as requests and responses have a defined structure.
This article describes this general structure, its purpose, and the different types of messages.

MIME types

Since HTTP/1.0, different types of content can be transmitted.
This article explains how this is accomplished using the Content-Type header and the MIME standard.
A shortlist of common types used by web developers can be found in Common MIME types.

Compression in HTTP

Browsers and servers compress their messages before sending them over the network to reduce the amount of data that needs to be transmitted, improving transfer speed and bandwidth utilization.

HTTP caching

Caching is a highly important mechanism for delivering fast experiences on the Web and for efficient use of resources.
This article describes different methods of caching and how to use HTTP headers to control them.

HTTP authentication

Authentication is a way to verify the identity of a client when making requests to a server.
It ensures that only authorized users or systems can access certain resources.

Using HTTP cookies

Although HTTP is a stateless protocol, a server can send a Set-Cookie header with the response.
The client then returns the cookie's value with every subsequent request to the server in the form of a Cookie request header.
This adds the ability to store and exchange a small amount of data which effectively adds state to some client-server interactions.

Redirections in HTTP

URL redirection, also known as URL forwarding, is a technique to give more than one URL address to a page, a form, a whole website, or a web application.
HTTP has a special kind of response, called a HTTP redirect, for this operation.

HTTP conditional requests

In conditional requests, the outcome of a request depends on the value of a validator in the request.
This method is used heavily in caching and use cases such as resuming a download, preventing lost updates when modifying a document on the server, and more.

HTTP range requests

A range request asks the server to send a specific part (or parts) of a resource back to a client instead of the full resource.
Range requests are useful for cases when a client knows they need only part of a large file, or for cases where an application allows the user to pause and resume a download.

Content negotiation

HTTP defines a set of message headers, starting with Accept as a way for a browser to announce the format, language, or encoding it prefers.
This article explains how this advertisement happens, how the server is expected to react, and how it chooses the most adequate response to a request.

Connection management in HTTP/1.x

HTTP/1.1 was the first version of HTTP to support persistent connections and pipelining.
This article explains both concepts, including the pros and cons of each.

Protocol upgrade mechanism

HTTP/1.1 provides a mechanism to upgrade an already-established connection to a different protocol using the Upgrade header.
A client can upgrade a connection from HTTP/1.1 to HTTP/2, or an HTTP(S) connection to a WebSocket (ws / wss).

Proxy servers and tunneling

A proxy can be on the user's local computer, or anywhere between the user's computer and a destination server on the Internet.
This page outlines some basics about proxies and introduces a few configuration options.

HTTP Client hints

Client Hints are a set of response headers that a server can use to proactively request information from a client about the device, network, user, and user-agent-specific preferences.
The server can then determine which resources to send, based on the information that the client chooses to provide.

Network Error Logging 
Experimental


Network Error Logging is a mechanism that can be configured via the NEL HTTP response header.
This experimental header allows websites and applications to opt-in to receive reports about failed (or even successful) network fetches from supporting browsers.

Browser detection using the user agent

It's very rarely a good idea to use user agent sniffing to detect a browser, but there are edge cases that require it.
This document will guide you in doing this as correctly as possible when this is necessary, with an emphasis on considerations to make before embarking on this route.

Security and privacy
Permissions Policy

Permissions Policy provides mechanisms for web developers to explicitly declare what functionality can and cannot be used on a website.
You define a set of "policies" that restrict what APIs the site's code can access or modify the browser's default behavior for certain features.

Cross-Origin Resource Sharing (CORS)

Cross-site HTTP requests are requests for resources from a different domain than that of the resource making the request.
Web pages today very commonly load cross-site resources, for example, a page 'Domain A' (http://domaina.example/) requests an image on 'Domain B' (http://domainb.foo/image.jpg) via the img element.
CORS allows web developers to control how their site reacts to cross-site requests.

Content Security Policy (CSP)

CSP allows website administrators to use the Content-Security-Policy response header to control which resources the client is allowed to load for a given page.
The CSP guide describes the overall Content Security Policy mechanism which helps detect and mitigate certain types of attacks, including Cross-Site Scripting (XSS) and data injection attacks.

Cross-Origin Resource Policy (CORP)

CORP lets websites and applications opt in to protection against specific requests from other origins (such as those issued with elements like <script> and <img>), to mitigate speculative side-channel attacks.

Mozilla web security guidelines

A collection of tips to help operational teams with creating secure web applications.

Related resources
URIs

Uniform Resource Identifiers (URIs) are used to describe and locate resources on the web and are an essential component in HTTP requests.

Configuring servers for Ogg media

This guide covers a few server configuration changes that may be necessary for your web server to correctly serve Ogg media files.
This information may also be useful if you encounter other media types your server isn't already configured to recognize.

Tools & resourcesHelpful tools and resources for understanding and debugging HTTP.

Firefox Developer Tools

Network monitor

HTTP Observatory

A project designed to help developers, system administrators, and security professionals configure their sites safely and securely.

RedBot

Tools to check your cache-related headers.

nghttp2

An HTTP/2 client, server and proxy implementation written in C with load test and benchmarking tools and an HPACK encoder and decoder.

curl

A command-line tool for transferring data specified with URL syntax.
Supports HTTP, HTTPS, WS, WSS, among many other protocols.

How Browsers Work (2011)

A very comprehensive article on browser internals and request flow through HTTP protocol.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 14, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nHTTPHypertext Transfer Protocol (HTTP) is an application-layer protocol for transmitting hypermedia documents, such as HTML.
It was designed for communication between web browsers and web servers, but it can also be used for other purposes, such as machine-to-machine communication, programmatic access to APIs, and more.
HTTP follows a classical client-server model, with a client opening a connection to make a request, then waiting until it receives a response from the server.
HTTP is a stateless protocol, meaning that the server does not keep any session data between two requests, although the later addition of cookies adds state to some client-server interactions.Reference documentationThe HTTP reference documentation contains detailed information about headers, request methods, status responses, and lists relevant specifications and standards documents.

HTTP headers

Message headers are used to send metadata about a resource or a HTTP message, and to describe the behavior of the client or the server.

HTTP request methods

Request methods indicate the purpose of the request and what is expected if the request is successful.
The most common methods are GET and POST for retrieving and sending data to servers, respectively, but there are other methods which serve different purposes.

HTTP response status codes

Response status codes indicate the outcome of a specific HTTP request.
Responses are grouped in five classes: informational, successful, redirections, client errors, and server errors.

HTTP resources and specifications

This page lists relevant resources about HTTP since it was first specified in the early 1990s.


The following subsections are also notable:

CSP directives

The Content-Security-Policy (CSP) response header allows website administrators to specify which resources the user agent is allowed to load for a given page.
This section lists directives that can be used in a CSP header, with individual documentation pages that describe how the directives work and how to use them.

Permissions-Policy directives

The Permissions-Policy response header provides a mechanism to allow or deny the use of browser features in a document or within any <iframe> element in the document.
This section lists directives that can be used in a Permissions-Policy header, with individual documentation pages that describe how the directives work and how to use them.

HTTP guidesHTTP is an extensible protocol that relies on concepts like resources and Uniform Resource Identifiers (URIs), a basic message structure, and client-server communication model.
On top of these concepts, numerous extensions have been developed over the years that add functionality and updated semantics, including additional HTTP methods and headers.
The guides below are listed in order from general overviews to specialized, use-case-driven topics.
Beginners are encouraged to start with the foundational guides before exploring more focused articles.

Overview of HTTP

The basic features of HTTP, what it can do, its intended use in web architecture, and its position in the protocol stack.

Evolution of HTTP

HTTP was created in the early 1990s and has been extended several times.
This article goes through its history and describes HTTP/0.9, HTTP/1.0, HTTP/1.1, through HTTP/2 and HTTP/3, as well as novelties introduced over the years.

A typical HTTP session

Describes the flow of an HTTP session, from establishing a connection, sending a request, to receiving a response.

HTTP messages

HTTP messages transmitted as requests and responses have a defined structure.
This article describes this general structure, its purpose, and the different types of messages.

MIME types

Since HTTP/1.0, different types of content can be transmitted.
This article explains how this is accomplished using the Content-Type header and the MIME standard.
A shortlist of common types used by web developers can be found in Common MIME types.

Compression in HTTP

Browsers and servers compress their messages before sending them over the network to reduce the amount of data that needs to be transmitted, improving transfer speed and bandwidth utilization.

HTTP caching

Caching is a highly important mechanism for delivering fast experiences on the Web and for efficient use of resources.
This article describes different methods of caching and how to use HTTP headers to control them.

HTTP authentication

Authentication is a way to verify the identity of a client when making requests to a server.
It ensures that only authorized users or systems can access certain resources.

Using HTTP cookies

Although HTTP is a stateless protocol, a server can send a Set-Cookie header with the response.
The client then returns the cookie's value with every subsequent request to the server in the form of a Cookie request header.
This adds the ability to store and exchange a small amount of data which effectively adds state to some client-server interactions.

Redirections in HTTP

URL redirection, also known as URL forwarding, is a technique to give more than one URL address to a page, a form, a whole website, or a web application.
HTTP has a special kind of response, called a HTTP redirect, for this operation.

HTTP conditional requests

In conditional requests, the outcome of a request depends on the value of a validator in the request.
This method is used heavily in caching and use cases such as resuming a download, preventing lost updates when modifying a document on the server, and more.

HTTP range requests

A range request asks the server to send a specific part (or parts) of a resource back to a client instead of the full resource.
Range requests are useful for cases when a client knows they need only part of a large file, or for cases where an application allows the user to pause and resume a download.

Content negotiation

HTTP defines a set of message headers, starting with Accept as a way for a browser to announce the format, language, or encoding it prefers.
This article explains how this advertisement happens, how the server is expected to react, and how it chooses the most adequate response to a request.

Connection management in HTTP/1.x

HTTP/1.1 was the first version of HTTP to support persistent connections and pipelining.
This article explains both concepts, including the pros and cons of each.

Protocol upgrade mechanism

HTTP/1.1 provides a mechanism to upgrade an already-established connection to a different protocol using the Upgrade header.
A client can upgrade a connection from HTTP/1.1 to HTTP/2, or an HTTP(S) connection to a WebSocket (ws / wss).

Proxy servers and tunneling

A proxy can be on the user's local computer, or anywhere between the user's computer and a destination server on the Internet.
This page outlines some basics about proxies and introduces a few configuration options.

HTTP Client hints

Client Hints are a set of response headers that a server can use to proactively request information from a client about the device, network, user, and user-agent-specific preferences.
The server can then determine which resources to send, based on the information that the client chooses to provide.

Network Error Logging 
Experimental


Network Error Logging is a mechanism that can be configured via the NEL HTTP response header.
This experimental header allows websites and applications to opt-in to receive reports about failed (or even successful) network fetches from supporting browsers.

Browser detection using the user agent

It's very rarely a good idea to use user agent sniffing to detect a browser, but there are edge cases that require it.
This document will guide you in doing this as correctly as possible when this is necessary, with an emphasis on considerations to make before embarking on this route.

Security and privacy
Permissions Policy

Permissions Policy provides mechanisms for web developers to explicitly declare what functionality can and cannot be used on a website.
You define a set of "policies" that restrict what APIs the site's code can access or modify the browser's default behavior for certain features.

Cross-Origin Resource Sharing (CORS)

Cross-site HTTP requests are requests for resources from a different domain than that of the resource making the request.
Web pages today very commonly load cross-site resources, for example, a page 'Domain A' (http://domaina.example/) requests an image on 'Domain B' (http://domainb.foo/image.jpg) via the img element.
CORS allows web developers to control how their site reacts to cross-site requests.

Content Security Policy (CSP)

CSP allows website administrators to use the Content-Security-Policy response header to control which resources the client is allowed to load for a given page.
The CSP guide describes the overall Content Security Policy mechanism which helps detect and mitigate certain types of attacks, including Cross-Site Scripting (XSS) and data injection attacks.

Cross-Origin Resource Policy (CORP)

CORP lets websites and applications opt in to protection against specific requests from other origins (such as those issued with elements like <script> and <img>), to mitigate speculative side-channel attacks.

Mozilla web security guidelines

A collection of tips to help operational teams with creating secure web applications.

Related resources
URIs

Uniform Resource Identifiers (URIs) are used to describe and locate resources on the web and are an essential component in HTTP requests.

Configuring servers for Ogg media

This guide covers a few server configuration changes that may be necessary for your web server to correctly serve Ogg media files.
This information may also be useful if you encounter other media types your server isn't already configured to recognize.

Tools & resourcesHelpful tools and resources for understanding and debugging HTTP.

Firefox Developer Tools

Network monitor

HTTP Observatory

A project designed to help developers, system administrators, and security professionals configure their sites safely and securely.

RedBot

Tools to check your cache-related headers.

nghttp2

An HTTP/2 client, server and proxy implementation written in C with load test and benchmarking tools and an HPACK encoder and decoder.

curl

A command-line tool for transferring data specified with URL syntax.
Supports HTTP, HTTPS, WS, WSS, among many other protocols.

How Browsers Work (2011)

A very comprehensive article on browser internals and request flow through HTTP protocol.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 14, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nWeb APIsWhen writing code for the Web, there are a large number of Web APIs available. Below is a list of all the APIs and interfaces (object types) that you may be able to use while developing your Web app or site.
Web APIs are typically used with JavaScript, although this doesn't always have to be the case.SpecificationsThis is a list of all the APIs that are available.
AAttribution Reporting API
Experimental
Audio Output Devices API
Experimental
BBackground Fetch API
Experimental
Background Synchronization APIBackground Tasks APIBadging APIBarcode Detection API
Experimental
Battery Status APIBeacon APIWeb Bluetooth API
Experimental
Broadcast Channel APICCSS Custom Highlight APICSS Font Loading APICSS Painting API
Experimental
CSS Properties and Values APICSS Typed Object Model APICSS Object Model (CSSOM)Canvas APIChannel Messaging APIClipboard APICompression Streams APICompute Pressure API
Experimental
Console APIContact Picker API
Experimental
Content Index API
Experimental
Cookie Store APICredential Management APIDDocument Object Model (DOM)Device Memory APIDevice orientation eventsDevice Posture API
Experimental
Document Picture-in-Picture API
Experimental
EEditContext API
Experimental
Encoding APIEncrypted Media Extensions APIEyeDropper API
Experimental
FFederated Credential Management (FedCM) API
Experimental
Fenced Frame API
Experimental
Fetch APIFile APIFile System APIFile and Directory Entries APIForce Touch events
Non-standard
Fullscreen APIGGamepad APIGeolocation APIGeometry interfacesHThe HTML DOM APIHTML Drag and Drop APIHistory APIHoudini APIsIIdle Detection API
Experimental
MediaStream Image Capture APIIndexedDB APIInk API
Experimental
InputDeviceCapabilities API
Experimental
Insertable Streams for MediaStreamTrack APIIntersection Observer APIInvoker Commands APIJJS Self-Profiling API
Experimental
KKeyboard API
Experimental
LLaunch Handler API
Experimental
Local Font Access API
Experimental
MMedia Capabilities APIMedia Capture and Streams API (Media Stream)Media Session APIMedia Source API
Experimental
MediaStream Recording APINNavigation API
Experimental
Network Information APIPPage Visibility APIPayment Handler API
Experimental
Payment Request APIPerformance APIsWeb Periodic Background Synchronization API
Experimental
Permissions APIPicture-in-Picture APIPointer eventsPointer Lock APIPopover APIPresentation API
Experimental
Prioritized Task Scheduling APIPush APIRRemote Playback APIReporting APIResize Observer APISSVG APIScreen Capture APIScreen Orientation APIScreen Wake Lock APISelection APISensor APIsServer-sent eventsService Worker APIShared Storage API
Experimental
Speculation Rules API
Experimental
Storage APIStorage Access APIStreams APITTopics API
Experimental

Non-standard
Touch eventsTrusted Types APIUUI EventsURL APIURL Fragment Text DirectivesURL Pattern API
Experimental
User-Agent Client Hints API
Experimental
VVibration APIView Transition APIVirtualKeyboard API
Experimental
Visual Viewport APIWWeb Animations APIWeb Audio APIWeb Authentication APIWeb ComponentsWeb Crypto APIWeb Locks APIWeb MIDI APIWeb NFC API
Experimental
Notifications APIWeb Serial API
Experimental
Web Share APIWeb Speech APIWeb Storage APIWeb Workers APIWebCodecs APIWebGL: 2D and 3D graphics for the webWebGPU API
Experimental
WebHID API
Experimental
WebOTP APIWebRTC APIThe WebSocket API (WebSockets)WebTransport APIWebUSB API
Experimental
WebVR API
Non-standard

Deprecated
WebVTT APIWebXR Device API
Experimental
Window Controls Overlay API
Experimental
Window Management API
Experimental
XXMLHttpRequest APIffetchLater() API
Experimental
InterfacesThis is a list of all the interfaces (that is, types of objects) that are available.
AAbortControllerAbortSignalAbsoluteOrientationSensorAbstractRangeAccelerometer
Experimental
AesCbcParamsAesCtrParamsAesGcmParamsAesKeyGenParamsAmbientLightSensor
Experimental
AnalyserNodeANGLE_instanced_arraysAnimationAnimationEffectAnimationEventAnimationPlaybackEventAnimationTimelineAttrAudioBufferAudioBufferSourceNodeAudioContextAudioDataAudioDecoderAudioDestinationNodeAudioEncoderAudioListenerAudioNodeAudioParamAudioParamDescriptorAudioParamMapAudioProcessingEvent
Deprecated
AudioScheduledSourceNodeAudioSinkInfo
Experimental
AudioTrackAudioTrackListAudioWorkletAudioWorkletGlobalScopeAudioWorkletNodeAudioWorkletProcessorAuthenticatorAssertionResponseAuthenticatorAttestationResponseAuthenticatorResponseBBackgroundFetchEvent
Experimental
BackgroundFetchManager
Experimental
BackgroundFetchRecord
Experimental
BackgroundFetchRegistration
Experimental
BackgroundFetchUpdateUIEvent
Experimental
BarcodeDetector
Experimental
BarPropBaseAudioContextBatteryManagerBeforeInstallPromptEvent
Experimental

Non-standard
BeforeUnloadEventBiquadFilterNodeBlobBlobEventBluetooth
Experimental
BluetoothCharacteristicProperties
Experimental
BluetoothDevice
Experimental
BluetoothRemoteGATTCharacteristic
Experimental
BluetoothRemoteGATTDescriptor
Experimental
BluetoothRemoteGATTServer
Experimental
BluetoothRemoteGATTService
Experimental
BluetoothUUIDBroadcastChannelBrowserCaptureMediaStreamTrack
Experimental
ByteLengthQueuingStrategyCCacheCacheStorageCanMakePaymentEvent
Experimental
CanvasCaptureMediaStreamTrackCanvasGradientCanvasPatternCanvasRenderingContext2DCaptureController
Experimental
CaretPositionCDATASectionChannelMergerNodeChannelSplitterNodeChapterInformation
Experimental
CharacterBoundsUpdateEvent
Experimental
CharacterDataClientClientsClipboardClipboardEventClipboardItemCloseEventCloseWatcher
Experimental
CommandEventCommentCompositionEventCompressionStreamcconsoleCConstantSourceNodeContactAddress
Experimental
ContactsManager
Experimental
ContentIndex
Experimental
ContentIndexEvent
Experimental
ContentVisibilityAutoStateChangeEventConvolverNodeCookieChangeEventCookieStoreCookieStoreManagerCountQueuingStrategyCredentialCredentialsContainerCropTarget
Experimental
CryptoCryptoKeyCryptoKeyPairCSPViolationReportBodyCSSCSSAnimationCSSConditionRuleCSSContainerRuleCSSCounterStyleRuleCSSFontFaceRuleCSSFontFeatureValuesRuleCSSFontPaletteValuesRuleCSSGroupingRuleCSSImageValueCSSImportRuleCSSKeyframeRuleCSSKeyframesRuleCSSKeywordValueCSSLayerBlockRuleCSSLayerStatementRuleCSSMathInvertCSSMathMaxCSSMathMinCSSMathNegateCSSMathProductCSSMathSumCSSMathValueCSSMatrixComponentCSSMediaRuleCSSNamespaceRuleCSSNestedDeclarationsCSSNumericArrayCSSNumericValueCSSPageDescriptors
Experimental
CSSPageRuleCSSPerspectiveCSSPositionTryDescriptors
Experimental
CSSPositionTryRule
Experimental
CSSPositionValue
Non-standard

Deprecated
CSSPrimitiveValue
Deprecated
CSSPropertyRuleCSSPseudoElement
Experimental
CSSRotateCSSRuleCSSRuleListCSSScaleCSSScopeRuleCSSSkewCSSSkewXCSSSkewYCSSStartingStyleRuleCSSStyleDeclarationCSSStyleRuleCSSStyleSheetCSSStyleValueCSSSupportsRuleCSSTransformComponentCSSTransformValueCSSTransitionCSSTranslateCSSUnitValueCSSUnparsedValueCSSValue
Deprecated
CSSValueList
Deprecated
CSSVariableReferenceValueCustomElementRegistryCustomEventCustomStateSetDDataTransferDataTransferItemDataTransferItemListDecompressionStreamDedicatedWorkerGlobalScopeDeferredRequestInit
Experimental
DelayNodeDelegatedInkTrailPresenter
Experimental
DeprecationReportBody
Experimental
DeviceMotionEventDeviceMotionEventAccelerationDeviceMotionEventRotationRateDeviceOrientationEventDevicePosture
Experimental
DirectoryEntrySync
Non-standard

Deprecated
DirectoryReaderSync
Non-standard

Deprecated
DocumentDocumentFragmentDocumentPictureInPicture
Experimental
DocumentPictureInPictureEvent
Experimental
DocumentTimelineDocumentTypeDOMError
Deprecated
DOMExceptionDOMHighResTimeStampDOMImplementationDOMMatrixDOMMatrixReadOnlyDOMParserDOMPointDOMPointReadOnlyDOMQuadDOMRectDOMRectListDOMRectReadOnlyDOMStringListDOMStringMapDOMTokenListDragEventDynamicsCompressorNodeEEcdhKeyDeriveParamsEcdsaParamsEcKeyGenParamsEcKeyImportParamsEditContext
Experimental
ElementElementInternalsEncodedAudioChunkEncodedVideoChunkErrorEventEventEventCountsEventSourceEventTargetExtendableCookieChangeEventExtendableEventExtendableMessageEventEyeDropper
Experimental
FFeaturePolicy
Experimental
FederatedCredential
Experimental
FederatedCredentialInitFence
Experimental
FencedFrameConfig
Experimental
FetchEventFetchLaterResult
Experimental
FileFileEntrySync
Non-standard

Deprecated
FileListFileReaderFileReaderSyncFileSystemFileSystemChangeRecordFileSystemDirectoryEntryFileSystemDirectoryHandleFileSystemDirectoryReaderFileSystemEntryFileSystemFileEntryFileSystemFileHandleFileSystemHandleFileSystemObserver
Experimental

Non-standard
FileSystemSync
Non-standard

Deprecated
FileSystemSyncAccessHandleFileSystemWritableFileStreamFocusEventFontData
Experimental
FontFaceFontFaceSetFontFaceSetLoadEventFormDataFormDataEventFragmentDirectiveGGainNodeGamepadGamepadButtonGamepadEventGamepadHapticActuatorGamepadPose
Experimental
GeolocationGeolocationCoordinatesGeolocationPositionGeolocationPositionErrorGestureEvent
Non-standard
GPU
Experimental
GPUAdapter
Experimental
GPUAdapterInfo
Experimental
GPUBindGroup
Experimental
GPUBindGroupLayout
Experimental
GPUBuffer
Experimental
GPUCanvasContext
Experimental
GPUCommandBuffer
Experimental
GPUCommandEncoder
Experimental
GPUCompilationInfo
Experimental
GPUCompilationMessage
Experimental
GPUComputePassEncoder
Experimental
GPUComputePipeline
Experimental
GPUDevice
Experimental
GPUDeviceLostInfo
Experimental
GPUError
Experimental
GPUExternalTexture
Experimental
GPUInternalError
Experimental
GPUOutOfMemoryError
Experimental
GPUPipelineError
Experimental
GPUPipelineLayout
Experimental
GPUQuerySet
Experimental
GPUQueue
Experimental
GPURenderBundle
Experimental
GPURenderBundleEncoder
Experimental
GPURenderPassEncoder
Experimental
GPURenderPipeline
Experimental
GPUSampler
Experimental
GPUShaderModule
Experimental
GPUSupportedFeatures
Experimental
GPUSupportedLimits
Experimental
GPUTexture
Experimental
GPUTextureView
Experimental
GPUUncapturedErrorEvent
Experimental
GPUValidationError
Experimental
GravitySensorGyroscopeHHashChangeEventHeadersHID
Experimental
HIDConnectionEvent
Experimental
HIDDevice
Experimental
HIDInputReportEvent
Experimental
HighlightHighlightRegistryHistoryHkdfParamsHmacImportParamsHmacKeyGenParamsHMDVRDevice
Non-standard

Deprecated
HTMLAllCollectionHTMLAnchorElementHTMLAreaElementHTMLAudioElementHTMLBaseElementHTMLBodyElementHTMLBRElementHTMLButtonElementHTMLCanvasElementHTMLCollectionHTMLDataElementHTMLDataListElementHTMLDetailsElementHTMLDialogElementHTMLDivElementHTMLDListElementHTMLDocumentHTMLElementHTMLEmbedElementHTMLFencedFrameElement
Experimental
HTMLFieldSetElementHTMLFontElement
Deprecated
HTMLFormControlsCollectionHTMLFormElementHTMLFrameSetElement
Deprecated
HTMLHeadElementHTMLHeadingElementHTMLHRElementHTMLHtmlElementHTMLIFrameElementHTMLImageElementHTMLInputElementHTMLLabelElementHTMLLegendElementHTMLLIElementHTMLLinkElementHTMLMapElementHTMLMarqueeElement
Deprecated
HTMLMediaElementHTMLMenuElementHTMLMetaElementHTMLMeterElementHTMLModElementHTMLObjectElementHTMLOListElementHTMLOptGroupElementHTMLOptionElementHTMLOptionsCollectionHTMLOutputElementHTMLParagraphElementHTMLParamElement
Deprecated
HTMLPictureElementHTMLPreElementHTMLProgressElementHTMLQuoteElementHTMLScriptElementHTMLSelectedContentElementHTMLSelectElementHTMLSlotElementHTMLSourceElementHTMLSpanElementHTMLStyleElementHTMLTableCaptionElementHTMLTableCellElementHTMLTableColElementHTMLTableElementHTMLTableRowElementHTMLTableSectionElementHTMLTemplateElementHTMLTextAreaElementHTMLTimeElementHTMLTitleElementHTMLTrackElementHTMLUListElementHTMLUnknownElementHTMLVideoElementIIDBCursorIDBCursorWithValueIDBDatabaseIDBFactoryIDBIndexIDBKeyRangeIDBObjectStoreIDBOpenDBRequestIDBRequestIDBTransactionIDBVersionChangeEventIdentityCredential
Experimental
IdentityCredentialRequestOptionsIdentityProvider
Experimental
IdleDeadlineIdleDetector
Experimental
IIRFilterNodeImageBitmapImageBitmapRenderingContextImageCaptureImageDataImageDecoderImageTrackImageTrackListInk
Experimental
InputDeviceCapabilities
Experimental
InputDeviceInfoInputEventInstallEventIntersectionObserverIntersectionObserverEntryInterventionReportBody
Experimental
KKeyboard
Experimental
KeyboardEventKeyboardLayoutMap
Experimental
KeyframeEffectLLargestContentfulPaintLaunchParams
Experimental
LaunchQueue
Experimental
LayoutShift
Experimental
LayoutShiftAttribution
Experimental
LinearAccelerationSensorLocationLockLockManagerMMagnetometer
Experimental
MathMLElementMediaCapabilitiesMediaDeviceInfoMediaDevicesMediaElementAudioSourceNodeMediaEncryptedEventMediaErrorMediaKeyMessageEventMediaKeysMediaKeySessionMediaKeyStatusMapMediaKeySystemAccessMediaListMediaMetadataMediaQueryListMediaQueryListEventMediaRecorderMediaRecorderErrorEvent
Non-standard

Deprecated
MediaSessionMediaSourceMediaSourceHandleMediaStreamMediaStreamAudioDestinationNodeMediaStreamAudioSourceNodeMediaStreamEvent
Non-standard

Deprecated
MediaStreamTrackMediaStreamTrackAudioSourceNodeMediaStreamTrackEventMediaStreamTrackGenerator
Experimental

Non-standard
MediaStreamTrackProcessor
Experimental
MediaTrackConstraintsMediaTrackSettingsMediaTrackSupportedConstraintsMerchantValidationEvent
Deprecated
MessageChannelMessageEventMessagePortMetadata
Experimental

Non-standard
MIDIAccessMIDIConnectionEventMIDIInputMIDIInputMapMIDIMessageEventMIDIOutputMIDIOutputMapMIDIPortMimeType
Deprecated
MimeTypeArray
Deprecated
MouseEventMouseScrollEvent
Non-standard

Deprecated
MutationEvent
Non-standard

Deprecated
MutationObserverMutationRecordNNamedNodeMapNavigateEvent
Experimental
Navigation
Experimental
NavigationActivation
Experimental
NavigationCurrentEntryChangeEvent
Experimental
NavigationDestination
Experimental
NavigationHistoryEntry
Experimental
NavigationPreloadManagerNavigationTransition
Experimental
NavigatorNavigatorLoginNavigatorUAData
Experimental
NDEFMessage
Experimental
NDEFReader
Experimental
NDEFReadingEvent
Experimental
NDEFRecord
Experimental
NetworkInformationNodeNodeIteratorNodeListNotificationNotificationEventNotRestoredReasonDetails
Experimental
NotRestoredReasons
Experimental
OOES_draw_buffers_indexedOfflineAudioCompletionEventOfflineAudioContextOffscreenCanvasOffscreenCanvasRenderingContext2DOrientationSensorOscillatorNodeOTPCredential
Experimental
OverconstrainedErrorPPageRevealEventPageSwapEventPageTransitionEventPaintRenderingContext2DPaintSizePaintWorkletGlobalScope
Experimental
PannerNodePasswordCredential
Experimental
PasswordCredentialInitPath2DPaymentAddress
Non-standard

Deprecated
PaymentManager
Experimental
PaymentMethodChangeEventPaymentRequestPaymentRequestEvent
Experimental
PaymentRequestUpdateEventPaymentResponsePbkdf2ParamsPerformancePerformanceElementTiming
Experimental
PerformanceEntryPerformanceEventTimingPerformanceLongAnimationFrameTiming
Experimental
PerformanceLongTaskTiming
Experimental
PerformanceMarkPerformanceMeasurePerformanceNavigation
Deprecated
PerformanceNavigationTimingPerformanceObserverPerformanceObserverEntryListPerformancePaintTimingPerformanceResourceTimingPerformanceScriptTiming
Experimental
PerformanceServerTimingPerformanceTiming
Deprecated
PeriodicSyncEvent
Experimental
PeriodicSyncManager
Experimental
PeriodicWavePermissionsPermissionStatusPictureInPictureEventPictureInPictureWindowPlugin
Deprecated
PluginArray
Deprecated
Point
Non-standard

Deprecated
PointerEventPopStateEventPositionSensorVRDevice
Non-standard

Deprecated
Presentation
Experimental
PresentationAvailability
Experimental
PresentationConnection
Experimental
PresentationConnectionAvailableEvent
Experimental
PresentationConnectionCloseEvent
Experimental
PresentationConnectionList
Experimental
PresentationReceiver
Experimental
PresentationRequest
Experimental
PressureObserver
Experimental
PressureRecord
Experimental
ProcessingInstructionProfiler
Experimental
ProgressEventPromiseRejectionEventPublicKeyCredentialPublicKeyCredentialCreationOptionsPublicKeyCredentialRequestOptionsPushEventPushManagerPushMessageDataPushSubscriptionPushSubscriptionOptionsRRadioNodeListRangeReadableByteStreamControllerReadableStreamReadableStreamBYOBReaderReadableStreamBYOBRequestReadableStreamDefaultControllerReadableStreamDefaultReaderRelativeOrientationSensorRemotePlaybackReportReportBodyReportingObserverRequestRequestInitResizeObserverResizeObserverEntryResizeObserverSizeResponseRestrictionTarget
Experimental
RsaHashedImportParamsRsaHashedKeyGenParamsRsaOaepParamsRsaPssParamsRTCAudioSourceStatsRTCCertificateRTCCertificateStatsRTCCodecStatsRTCDataChannelRTCDataChannelEventRTCDataChannelStatsRTCDtlsTransportRTCDTMFSenderRTCDTMFToneChangeEventRTCEncodedAudioFrameRTCEncodedVideoFrameRTCErrorRTCErrorEventRTCIceCandidateRTCIceCandidatePairRTCIceCandidatePairStatsRTCIceCandidateStatsRTCIceParametersRTCIceTransportRTCIdentityAssertion
Experimental
RTCInboundRtpStreamStatsRTCOutboundRtpStreamStatsRTCPeerConnectionRTCPeerConnectionIceErrorEventRTCPeerConnectionIceEventRTCPeerConnectionStatsRTCRemoteInboundRtpStreamStatsRTCRemoteOutboundRtpStreamStatsRTCRtpReceiverRTCRtpScriptTransformRTCRtpScriptTransformerRTCRtpSenderRTCRtpTransceiverRTCSctpTransportRTCSessionDescriptionRTCStatsReportRTCTrackEventRTCTransformEventRTCTransportStatsRTCVideoSourceStatsSSchedulerScheduling
Experimental
ScreenScreenDetailed
Experimental
ScreenDetails
Experimental
ScreenOrientationScriptProcessorNode
Deprecated
ScrollTimeline
Experimental
SecurePaymentConfirmationRequestSecurityPolicyViolationEventSelectionSensorSensorErrorEventSerial
Experimental
SerialPort
Experimental
ServiceWorkerServiceWorkerContainerServiceWorkerGlobalScopeServiceWorkerRegistrationShadowRootSharedStorage
Experimental
SharedStorageOperation
Experimental
SharedStorageRunOperation
Experimental
SharedStorageSelectURLOperation
Experimental
SharedStorageWorklet
Experimental
SharedStorageWorkletGlobalScope
Experimental
SharedWorkerSharedWorkerGlobalScopeSnapEvent
Experimental
SourceBufferSourceBufferListSpeechGrammar
Non-standard

Deprecated
SpeechGrammarList
Experimental
SpeechRecognitionSpeechRecognitionAlternativeSpeechRecognitionErrorEventSpeechRecognitionEventSpeechRecognitionResultSpeechRecognitionResultListSpeechSynthesisSpeechSynthesisErrorEventSpeechSynthesisEventSpeechSynthesisUtteranceSpeechSynthesisVoiceStaticRangeStereoPannerNodeStorageStorageAccessHandleStorageEventStorageManagerStylePropertyMapStylePropertyMapReadOnlyStyleSheetStyleSheetListSubmitEventSubtleCryptoSVGAElementSVGAngleSVGAnimateColorElement
Deprecated
SVGAnimatedAngleSVGAnimatedBooleanSVGAnimatedEnumerationSVGAnimatedIntegerSVGAnimatedLengthSVGAnimatedLengthListSVGAnimatedNumberSVGAnimatedNumberListSVGAnimatedPreserveAspectRatioSVGAnimatedRectSVGAnimatedStringSVGAnimatedTransformListSVGAnimateElementSVGAnimateMotionElementSVGAnimateTransformElementSVGAnimationElementSVGCircleElementSVGClipPathElementSVGComponentTransferFunctionElementSVGDefsElementSVGDescElementSVGDiscardElement
Experimental
SVGElementSVGEllipseElementSVGFEBlendElementSVGFEColorMatrixElementSVGFEComponentTransferElementSVGFECompositeElementSVGFEConvolveMatrixElementSVGFEDiffuseLightingElementSVGFEDisplacementMapElementSVGFEDistantLightElementSVGFEDropShadowElementSVGFEFloodElementSVGFEFuncAElementSVGFEFuncBElementSVGFEFuncGElementSVGFEFuncRElementSVGFEGaussianBlurElementSVGFEImageElementSVGFEMergeElementSVGFEMergeNodeElementSVGFEMorphologyElementSVGFEOffsetElementSVGFEPointLightElementSVGFESpecularLightingElementSVGFESpotLightElementSVGFETileElementSVGFETurbulenceElementSVGFilterElementSVGForeignObjectElementSVGGElementSVGGeometryElementSVGGradientElementSVGGraphicsElementSVGImageElementSVGLengthSVGLengthListSVGLinearGradientElementSVGLineElementSVGMarkerElementSVGMaskElementSVGMetadataElementSVGMPathElementSVGNumberSVGNumberListSVGPathElementSVGPatternElementSVGPoint
Deprecated
SVGPointListSVGPolygonElementSVGPolylineElementSVGPreserveAspectRatioSVGRadialGradientElementSVGRectSVGRectElementSVGRenderingIntent
Deprecated
SVGScriptElementSVGSetElementSVGStopElementSVGStringListSVGStyleElementSVGSVGElementSVGSwitchElementSVGSymbolElementSVGTextContentElementSVGTextElementSVGTextPathElementSVGTextPositioningElementSVGTitleElementSVGTransformSVGTransformListSVGTSpanElementSVGUnitTypesSVGUseElementSVGViewElementSyncEventSyncManagerTTaskAttributionTiming
Experimental
TaskControllerTaskPriorityChangeEventTaskSignalTextTextDecoderTextDecoderStreamTextEncoderTextEncoderStreamTextEvent
Deprecated
TextFormat
Experimental
TextFormatUpdateEvent
Experimental
TextMetricsTextTrackTextTrackCueTextTrackCueListTextTrackListTextUpdateEvent
Experimental
TimeEventTimeRangesToggleEventTouchTouchEventTouchListTrackEventTransformStreamTransformStreamDefaultControllerTransitionEventTreeWalkerTrustedHTMLTrustedScriptTrustedScriptURLTrustedTypePolicyTrustedTypePolicyFactoryUUIEventURLURLPattern
Experimental
URLSearchParamsUSB
Experimental
USBAlternateInterface
Experimental
USBConfiguration
Experimental
USBConnectionEvent
Experimental
USBDevice
Experimental
USBEndpoint
Experimental
USBInterface
Experimental
USBInTransferResult
Experimental
USBIsochronousInTransferPacket
Experimental
USBIsochronousInTransferResult
Experimental
USBIsochronousOutTransferPacket
Experimental
USBIsochronousOutTransferResult
Experimental
USBOutTransferResult
Experimental
UserActivationVValidityStateVideoColorSpaceVideoDecoderVideoEncoderVideoFrameVideoPlaybackQualityVideoTrackVideoTrackGenerator
Experimental
VideoTrackListViewTimeline
Experimental
ViewTransitionVirtualKeyboard
Experimental
VisibilityStateEntry
Experimental
VisualViewportVRDisplay
Non-standard

Deprecated
VRDisplayCapabilities
Non-standard

Deprecated
VRDisplayEvent
Non-standard

Deprecated
VREyeParameters
Non-standard

Deprecated
VRFieldOfView
Non-standard

Deprecated
VRFrameData
Non-standard

Deprecated
VRLayerInit
Deprecated
VRPose
Non-standard

Deprecated
VRStageParameters
Non-standard

Deprecated
VTTCueVTTRegionWWakeLockWakeLockSentinelWaveShaperNodeWebGL2RenderingContextWebGLActiveInfoWebGLBufferWebGLContextEventWebGLFramebufferWebGLObject
Experimental
WebGLProgramWebGLQueryWebGLRenderbufferWebGLRenderingContextWebGLSamplerWebGLShaderWebGLShaderPrecisionFormatWebGLSyncWebGLTextureWebGLTransformFeedbackWebGLUniformLocationWebGLVertexArrayObjectWebSocketWebSocketStream
Experimental
WebTransportWebTransportBidirectionalStreamWebTransportDatagramDuplexStreamWebTransportErrorWebTransportReceiveStream
Experimental
WebTransportSendStream
Experimental
WGSLLanguageFeatures
Experimental
WheelEventWindowWindowClientWindowControlsOverlay
Experimental
WindowControlsOverlayGeometryChangeEvent
Experimental
WindowSharedStorage
Experimental
WorkerWorkerGlobalScopeWorkerLocationWorkerNavigatorWorkletWorkletGlobalScopeWorkletSharedStorage
Experimental
WritableStreamWritableStreamDefaultControllerWritableStreamDefaultWriterXXMLDocumentXMLHttpRequestXMLHttpRequestEventTargetXMLHttpRequestUploadXMLSerializerXPathEvaluatorXPathExpressionXPathResultXRAnchor
Experimental
XRAnchorSet
Experimental
XRBoundedReferenceSpace
Experimental
XRCompositionLayer
Experimental
XRCPUDepthInformation
Experimental
XRCubeLayer
Experimental
XRCylinderLayer
Experimental
XRDepthInformation
Experimental
XREquirectLayer
Experimental
XRFrame
Experimental
XRHandXRHitTestResult
Experimental
XRHitTestSource
Experimental
XRInputSourceXRInputSourceArray
Experimental
XRInputSourceEventXRInputSourcesChangeEventXRJointPoseXRJointSpaceXRLayer
Experimental
XRLayerEvent
Experimental
XRLightEstimate
Experimental
XRLightProbe
Experimental
XRMediaBinding
Experimental
XRPoseXRProjectionLayer
Experimental
XRQuadLayer
Experimental
XRRay
Experimental
XRReferenceSpaceXRReferenceSpaceEventXRRenderState
Experimental
XRRigidTransformXRSession
Experimental
XRSessionEventXRSpaceXRSubImage
Experimental
XRSystem
Experimental
XRTransientInputHitTestResult
Experimental
XRTransientInputHitTestSource
Experimental
XRView
Experimental
XRViewerPoseXRViewportXRWebGLBinding
Experimental
XRWebGLDepthInformation
Experimental
XRWebGLLayer
Experimental
XRWebGLSubImage
Experimental
XSLTProcessorSee also
Web API event reference\n\nWeb APIsWhen writing code for the Web, there are a large number of Web APIs available. Below is a list of all the APIs and interfaces (object types) that you may be able to use while developing your Web app or site.
Web APIs are typically used with JavaScript, although this doesn't always have to be the case.SpecificationsThis is a list of all the APIs that are available.
AAttribution Reporting API
Experimental
Audio Output Devices API
Experimental
BBackground Fetch API
Experimental
Background Synchronization APIBackground Tasks APIBadging APIBarcode Detection API
Experimental
Battery Status APIBeacon APIWeb Bluetooth API
Experimental
Broadcast Channel APICCSS Custom Highlight APICSS Font Loading APICSS Painting API
Experimental
CSS Properties and Values APICSS Typed Object Model APICSS Object Model (CSSOM)Canvas APIChannel Messaging APIClipboard APICompression Streams APICompute Pressure API
Experimental
Console APIContact Picker API
Experimental
Content Index API
Experimental
Cookie Store APICredential Management APIDDocument Object Model (DOM)Device Memory APIDevice orientation eventsDevice Posture API
Experimental
Document Picture-in-Picture API
Experimental
EEditContext API
Experimental
Encoding APIEncrypted Media Extensions APIEyeDropper API
Experimental
FFederated Credential Management (FedCM) API
Experimental
Fenced Frame API
Experimental
Fetch APIFile APIFile System APIFile and Directory Entries APIForce Touch events
Non-standard
Fullscreen APIGGamepad APIGeolocation APIGeometry interfacesHThe HTML DOM APIHTML Drag and Drop APIHistory APIHoudini APIsIIdle Detection API
Experimental
MediaStream Image Capture APIIndexedDB APIInk API
Experimental
InputDeviceCapabilities API
Experimental
Insertable Streams for MediaStreamTrack APIIntersection Observer APIInvoker Commands APIJJS Self-Profiling API
Experimental
KKeyboard API
Experimental
LLaunch Handler API
Experimental
Local Font Access API
Experimental
MMedia Capabilities APIMedia Capture and Streams API (Media Stream)Media Session APIMedia Source API
Experimental
MediaStream Recording APINNavigation API
Experimental
Network Information APIPPage Visibility APIPayment Handler API
Experimental
Payment Request APIPerformance APIsWeb Periodic Background Synchronization API
Experimental
Permissions APIPicture-in-Picture APIPointer eventsPointer Lock APIPopover APIPresentation API
Experimental
Prioritized Task Scheduling APIPush APIRRemote Playback APIReporting APIResize Observer APISSVG APIScreen Capture APIScreen Orientation APIScreen Wake Lock APISelection APISensor APIsServer-sent eventsService Worker APIShared Storage API
Experimental
Speculation Rules API
Experimental
Storage APIStorage Access APIStreams APITTopics API
Experimental

Non-standard
Touch eventsTrusted Types APIUUI EventsURL APIURL Fragment Text DirectivesURL Pattern API
Experimental
User-Agent Client Hints API
Experimental
VVibration APIView Transition APIVirtualKeyboard API
Experimental
Visual Viewport APIWWeb Animations APIWeb Audio APIWeb Authentication APIWeb ComponentsWeb Crypto APIWeb Locks APIWeb MIDI APIWeb NFC API
Experimental
Notifications APIWeb Serial API
Experimental
Web Share APIWeb Speech APIWeb Storage APIWeb Workers APIWebCodecs APIWebGL: 2D and 3D graphics for the webWebGPU API
Experimental
WebHID API
Experimental
WebOTP APIWebRTC APIThe WebSocket API (WebSockets)WebTransport APIWebUSB API
Experimental
WebVR API
Non-standard

Deprecated
WebVTT APIWebXR Device API
Experimental
Window Controls Overlay API
Experimental
Window Management API
Experimental
XXMLHttpRequest APIffetchLater() API
Experimental
InterfacesThis is a list of all the interfaces (that is, types of objects) that are available.
AAbortControllerAbortSignalAbsoluteOrientationSensorAbstractRangeAccelerometer
Experimental
AesCbcParamsAesCtrParamsAesGcmParamsAesKeyGenParamsAmbientLightSensor
Experimental
AnalyserNodeANGLE_instanced_arraysAnimationAnimationEffectAnimationEventAnimationPlaybackEventAnimationTimelineAttrAudioBufferAudioBufferSourceNodeAudioContextAudioDataAudioDecoderAudioDestinationNodeAudioEncoderAudioListenerAudioNodeAudioParamAudioParamDescriptorAudioParamMapAudioProcessingEvent
Deprecated
AudioScheduledSourceNodeAudioSinkInfo
Experimental
AudioTrackAudioTrackListAudioWorkletAudioWorkletGlobalScopeAudioWorkletNodeAudioWorkletProcessorAuthenticatorAssertionResponseAuthenticatorAttestationResponseAuthenticatorResponseBBackgroundFetchEvent
Experimental
BackgroundFetchManager
Experimental
BackgroundFetchRecord
Experimental
BackgroundFetchRegistration
Experimental
BackgroundFetchUpdateUIEvent
Experimental
BarcodeDetector
Experimental
BarPropBaseAudioContextBatteryManagerBeforeInstallPromptEvent
Experimental

Non-standard
BeforeUnloadEventBiquadFilterNodeBlobBlobEventBluetooth
Experimental
BluetoothCharacteristicProperties
Experimental
BluetoothDevice
Experimental
BluetoothRemoteGATTCharacteristic
Experimental
BluetoothRemoteGATTDescriptor
Experimental
BluetoothRemoteGATTServer
Experimental
BluetoothRemoteGATTService
Experimental
BluetoothUUIDBroadcastChannelBrowserCaptureMediaStreamTrack
Experimental
ByteLengthQueuingStrategyCCacheCacheStorageCanMakePaymentEvent
Experimental
CanvasCaptureMediaStreamTrackCanvasGradientCanvasPatternCanvasRenderingContext2DCaptureController
Experimental
CaretPositionCDATASectionChannelMergerNodeChannelSplitterNodeChapterInformation
Experimental
CharacterBoundsUpdateEvent
Experimental
CharacterDataClientClientsClipboardClipboardEventClipboardItemCloseEventCloseWatcher
Experimental
CommandEventCommentCompositionEventCompressionStreamcconsoleCConstantSourceNodeContactAddress
Experimental
ContactsManager
Experimental
ContentIndex
Experimental
ContentIndexEvent
Experimental
ContentVisibilityAutoStateChangeEventConvolverNodeCookieChangeEventCookieStoreCookieStoreManagerCountQueuingStrategyCredentialCredentialsContainerCropTarget
Experimental
CryptoCryptoKeyCryptoKeyPairCSPViolationReportBodyCSSCSSAnimationCSSConditionRuleCSSContainerRuleCSSCounterStyleRuleCSSFontFaceRuleCSSFontFeatureValuesRuleCSSFontPaletteValuesRuleCSSGroupingRuleCSSImageValueCSSImportRuleCSSKeyframeRuleCSSKeyframesRuleCSSKeywordValueCSSLayerBlockRuleCSSLayerStatementRuleCSSMathInvertCSSMathMaxCSSMathMinCSSMathNegateCSSMathProductCSSMathSumCSSMathValueCSSMatrixComponentCSSMediaRuleCSSNamespaceRuleCSSNestedDeclarationsCSSNumericArrayCSSNumericValueCSSPageDescriptors
Experimental
CSSPageRuleCSSPerspectiveCSSPositionTryDescriptors
Experimental
CSSPositionTryRule
Experimental
CSSPositionValue
Non-standard

Deprecated
CSSPrimitiveValue
Deprecated
CSSPropertyRuleCSSPseudoElement
Experimental
CSSRotateCSSRuleCSSRuleListCSSScaleCSSScopeRuleCSSSkewCSSSkewXCSSSkewYCSSStartingStyleRuleCSSStyleDeclarationCSSStyleRuleCSSStyleSheetCSSStyleValueCSSSupportsRuleCSSTransformComponentCSSTransformValueCSSTransitionCSSTranslateCSSUnitValueCSSUnparsedValueCSSValue
Deprecated
CSSValueList
Deprecated
CSSVariableReferenceValueCustomElementRegistryCustomEventCustomStateSetDDataTransferDataTransferItemDataTransferItemListDecompressionStreamDedicatedWorkerGlobalScopeDeferredRequestInit
Experimental
DelayNodeDelegatedInkTrailPresenter
Experimental
DeprecationReportBody
Experimental
DeviceMotionEventDeviceMotionEventAccelerationDeviceMotionEventRotationRateDeviceOrientationEventDevicePosture
Experimental
DirectoryEntrySync
Non-standard

Deprecated
DirectoryReaderSync
Non-standard

Deprecated
DocumentDocumentFragmentDocumentPictureInPicture
Experimental
DocumentPictureInPictureEvent
Experimental
DocumentTimelineDocumentTypeDOMError
Deprecated
DOMExceptionDOMHighResTimeStampDOMImplementationDOMMatrixDOMMatrixReadOnlyDOMParserDOMPointDOMPointReadOnlyDOMQuadDOMRectDOMRectListDOMRectReadOnlyDOMStringListDOMStringMapDOMTokenListDragEventDynamicsCompressorNodeEEcdhKeyDeriveParamsEcdsaParamsEcKeyGenParamsEcKeyImportParamsEditContext
Experimental
ElementElementInternalsEncodedAudioChunkEncodedVideoChunkErrorEventEventEventCountsEventSourceEventTargetExtendableCookieChangeEventExtendableEventExtendableMessageEventEyeDropper
Experimental
FFeaturePolicy
Experimental
FederatedCredential
Experimental
FederatedCredentialInitFence
Experimental
FencedFrameConfig
Experimental
FetchEventFetchLaterResult
Experimental
FileFileEntrySync
Non-standard

Deprecated
FileListFileReaderFileReaderSyncFileSystemFileSystemChangeRecordFileSystemDirectoryEntryFileSystemDirectoryHandleFileSystemDirectoryReaderFileSystemEntryFileSystemFileEntryFileSystemFileHandleFileSystemHandleFileSystemObserver
Experimental

Non-standard
FileSystemSync
Non-standard

Deprecated
FileSystemSyncAccessHandleFileSystemWritableFileStreamFocusEventFontData
Experimental
FontFaceFontFaceSetFontFaceSetLoadEventFormDataFormDataEventFragmentDirectiveGGainNodeGamepadGamepadButtonGamepadEventGamepadHapticActuatorGamepadPose
Experimental
GeolocationGeolocationCoordinatesGeolocationPositionGeolocationPositionErrorGestureEvent
Non-standard
GPU
Experimental
GPUAdapter
Experimental
GPUAdapterInfo
Experimental
GPUBindGroup
Experimental
GPUBindGroupLayout
Experimental
GPUBuffer
Experimental
GPUCanvasContext
Experimental
GPUCommandBuffer
Experimental
GPUCommandEncoder
Experimental
GPUCompilationInfo
Experimental
GPUCompilationMessage
Experimental
GPUComputePassEncoder
Experimental
GPUComputePipeline
Experimental
GPUDevice
Experimental
GPUDeviceLostInfo
Experimental
GPUError
Experimental
GPUExternalTexture
Experimental
GPUInternalError
Experimental
GPUOutOfMemoryError
Experimental
GPUPipelineError
Experimental
GPUPipelineLayout
Experimental
GPUQuerySet
Experimental
GPUQueue
Experimental
GPURenderBundle
Experimental
GPURenderBundleEncoder
Experimental
GPURenderPassEncoder
Experimental
GPURenderPipeline
Experimental
GPUSampler
Experimental
GPUShaderModule
Experimental
GPUSupportedFeatures
Experimental
GPUSupportedLimits
Experimental
GPUTexture
Experimental
GPUTextureView
Experimental
GPUUncapturedErrorEvent
Experimental
GPUValidationError
Experimental
GravitySensorGyroscopeHHashChangeEventHeadersHID
Experimental
HIDConnectionEvent
Experimental
HIDDevice
Experimental
HIDInputReportEvent
Experimental
HighlightHighlightRegistryHistoryHkdfParamsHmacImportParamsHmacKeyGenParamsHMDVRDevice
Non-standard

Deprecated
HTMLAllCollectionHTMLAnchorElementHTMLAreaElementHTMLAudioElementHTMLBaseElementHTMLBodyElementHTMLBRElementHTMLButtonElementHTMLCanvasElementHTMLCollectionHTMLDataElementHTMLDataListElementHTMLDetailsElementHTMLDialogElementHTMLDivElementHTMLDListElementHTMLDocumentHTMLElementHTMLEmbedElementHTMLFencedFrameElement
Experimental
HTMLFieldSetElementHTMLFontElement
Deprecated
HTMLFormControlsCollectionHTMLFormElementHTMLFrameSetElement
Deprecated
HTMLHeadElementHTMLHeadingElementHTMLHRElementHTMLHtmlElementHTMLIFrameElementHTMLImageElementHTMLInputElementHTMLLabelElementHTMLLegendElementHTMLLIElementHTMLLinkElementHTMLMapElementHTMLMarqueeElement
Deprecated
HTMLMediaElementHTMLMenuElementHTMLMetaElementHTMLMeterElementHTMLModElementHTMLObjectElementHTMLOListElementHTMLOptGroupElementHTMLOptionElementHTMLOptionsCollectionHTMLOutputElementHTMLParagraphElementHTMLParamElement
Deprecated
HTMLPictureElementHTMLPreElementHTMLProgressElementHTMLQuoteElementHTMLScriptElementHTMLSelectedContentElementHTMLSelectElementHTMLSlotElementHTMLSourceElementHTMLSpanElementHTMLStyleElementHTMLTableCaptionElementHTMLTableCellElementHTMLTableColElementHTMLTableElementHTMLTableRowElementHTMLTableSectionElementHTMLTemplateElementHTMLTextAreaElementHTMLTimeElementHTMLTitleElementHTMLTrackElementHTMLUListElementHTMLUnknownElementHTMLVideoElementIIDBCursorIDBCursorWithValueIDBDatabaseIDBFactoryIDBIndexIDBKeyRangeIDBObjectStoreIDBOpenDBRequestIDBRequestIDBTransactionIDBVersionChangeEventIdentityCredential
Experimental
IdentityCredentialRequestOptionsIdentityProvider
Experimental
IdleDeadlineIdleDetector
Experimental
IIRFilterNodeImageBitmapImageBitmapRenderingContextImageCaptureImageDataImageDecoderImageTrackImageTrackListInk
Experimental
InputDeviceCapabilities
Experimental
InputDeviceInfoInputEventInstallEventIntersectionObserverIntersectionObserverEntryInterventionReportBody
Experimental
KKeyboard
Experimental
KeyboardEventKeyboardLayoutMap
Experimental
KeyframeEffectLLargestContentfulPaintLaunchParams
Experimental
LaunchQueue
Experimental
LayoutShift
Experimental
LayoutShiftAttribution
Experimental
LinearAccelerationSensorLocationLockLockManagerMMagnetometer
Experimental
MathMLElementMediaCapabilitiesMediaDeviceInfoMediaDevicesMediaElementAudioSourceNodeMediaEncryptedEventMediaErrorMediaKeyMessageEventMediaKeysMediaKeySessionMediaKeyStatusMapMediaKeySystemAccessMediaListMediaMetadataMediaQueryListMediaQueryListEventMediaRecorderMediaRecorderErrorEvent
Non-standard

Deprecated
MediaSessionMediaSourceMediaSourceHandleMediaStreamMediaStreamAudioDestinationNodeMediaStreamAudioSourceNodeMediaStreamEvent
Non-standard

Deprecated
MediaStreamTrackMediaStreamTrackAudioSourceNodeMediaStreamTrackEventMediaStreamTrackGenerator
Experimental

Non-standard
MediaStreamTrackProcessor
Experimental
MediaTrackConstraintsMediaTrackSettingsMediaTrackSupportedConstraintsMerchantValidationEvent
Deprecated
MessageChannelMessageEventMessagePortMetadata
Experimental

Non-standard
MIDIAccessMIDIConnectionEventMIDIInputMIDIInputMapMIDIMessageEventMIDIOutputMIDIOutputMapMIDIPortMimeType
Deprecated
MimeTypeArray
Deprecated
MouseEventMouseScrollEvent
Non-standard

Deprecated
MutationEvent
Non-standard

Deprecated
MutationObserverMutationRecordNNamedNodeMapNavigateEvent
Experimental
Navigation
Experimental
NavigationActivation
Experimental
NavigationCurrentEntryChangeEvent
Experimental
NavigationDestination
Experimental
NavigationHistoryEntry
Experimental
NavigationPreloadManagerNavigationTransition
Experimental
NavigatorNavigatorLoginNavigatorUAData
Experimental
NDEFMessage
Experimental
NDEFReader
Experimental
NDEFReadingEvent
Experimental
NDEFRecord
Experimental
NetworkInformationNodeNodeIteratorNodeListNotificationNotificationEventNotRestoredReasonDetails
Experimental
NotRestoredReasons
Experimental
OOES_draw_buffers_indexedOfflineAudioCompletionEventOfflineAudioContextOffscreenCanvasOffscreenCanvasRenderingContext2DOrientationSensorOscillatorNodeOTPCredential
Experimental
OverconstrainedErrorPPageRevealEventPageSwapEventPageTransitionEventPaintRenderingContext2DPaintSizePaintWorkletGlobalScope
Experimental
PannerNodePasswordCredential
Experimental
PasswordCredentialInitPath2DPaymentAddress
Non-standard

Deprecated
PaymentManager
Experimental
PaymentMethodChangeEventPaymentRequestPaymentRequestEvent
Experimental
PaymentRequestUpdateEventPaymentResponsePbkdf2ParamsPerformancePerformanceElementTiming
Experimental
PerformanceEntryPerformanceEventTimingPerformanceLongAnimationFrameTiming
Experimental
PerformanceLongTaskTiming
Experimental
PerformanceMarkPerformanceMeasurePerformanceNavigation
Deprecated
PerformanceNavigationTimingPerformanceObserverPerformanceObserverEntryListPerformancePaintTimingPerformanceResourceTimingPerformanceScriptTiming
Experimental
PerformanceServerTimingPerformanceTiming
Deprecated
PeriodicSyncEvent
Experimental
PeriodicSyncManager
Experimental
PeriodicWavePermissionsPermissionStatusPictureInPictureEventPictureInPictureWindowPlugin
Deprecated
PluginArray
Deprecated
Point
Non-standard

Deprecated
PointerEventPopStateEventPositionSensorVRDevice
Non-standard

Deprecated
Presentation
Experimental
PresentationAvailability
Experimental
PresentationConnection
Experimental
PresentationConnectionAvailableEvent
Experimental
PresentationConnectionCloseEvent
Experimental
PresentationConnectionList
Experimental
PresentationReceiver
Experimental
PresentationRequest
Experimental
PressureObserver
Experimental
PressureRecord
Experimental
ProcessingInstructionProfiler
Experimental
ProgressEventPromiseRejectionEventPublicKeyCredentialPublicKeyCredentialCreationOptionsPublicKeyCredentialRequestOptionsPushEventPushManagerPushMessageDataPushSubscriptionPushSubscriptionOptionsRRadioNodeListRangeReadableByteStreamControllerReadableStreamReadableStreamBYOBReaderReadableStreamBYOBRequestReadableStreamDefaultControllerReadableStreamDefaultReaderRelativeOrientationSensorRemotePlaybackReportReportBodyReportingObserverRequestRequestInitResizeObserverResizeObserverEntryResizeObserverSizeResponseRestrictionTarget
Experimental
RsaHashedImportParamsRsaHashedKeyGenParamsRsaOaepParamsRsaPssParamsRTCAudioSourceStatsRTCCertificateRTCCertificateStatsRTCCodecStatsRTCDataChannelRTCDataChannelEventRTCDataChannelStatsRTCDtlsTransportRTCDTMFSenderRTCDTMFToneChangeEventRTCEncodedAudioFrameRTCEncodedVideoFrameRTCErrorRTCErrorEventRTCIceCandidateRTCIceCandidatePairRTCIceCandidatePairStatsRTCIceCandidateStatsRTCIceParametersRTCIceTransportRTCIdentityAssertion
Experimental
RTCInboundRtpStreamStatsRTCOutboundRtpStreamStatsRTCPeerConnectionRTCPeerConnectionIceErrorEventRTCPeerConnectionIceEventRTCPeerConnectionStatsRTCRemoteInboundRtpStreamStatsRTCRemoteOutboundRtpStreamStatsRTCRtpReceiverRTCRtpScriptTransformRTCRtpScriptTransformerRTCRtpSenderRTCRtpTransceiverRTCSctpTransportRTCSessionDescriptionRTCStatsReportRTCTrackEventRTCTransformEventRTCTransportStatsRTCVideoSourceStatsSSchedulerScheduling
Experimental
ScreenScreenDetailed
Experimental
ScreenDetails
Experimental
ScreenOrientationScriptProcessorNode
Deprecated
ScrollTimeline
Experimental
SecurePaymentConfirmationRequestSecurityPolicyViolationEventSelectionSensorSensorErrorEventSerial
Experimental
SerialPort
Experimental
ServiceWorkerServiceWorkerContainerServiceWorkerGlobalScopeServiceWorkerRegistrationShadowRootSharedStorage
Experimental
SharedStorageOperation
Experimental
SharedStorageRunOperation
Experimental
SharedStorageSelectURLOperation
Experimental
SharedStorageWorklet
Experimental
SharedStorageWorkletGlobalScope
Experimental
SharedWorkerSharedWorkerGlobalScopeSnapEvent
Experimental
SourceBufferSourceBufferListSpeechGrammar
Non-standard

Deprecated
SpeechGrammarList
Experimental
SpeechRecognitionSpeechRecognitionAlternativeSpeechRecognitionErrorEventSpeechRecognitionEventSpeechRecognitionResultSpeechRecognitionResultListSpeechSynthesisSpeechSynthesisErrorEventSpeechSynthesisEventSpeechSynthesisUtteranceSpeechSynthesisVoiceStaticRangeStereoPannerNodeStorageStorageAccessHandleStorageEventStorageManagerStylePropertyMapStylePropertyMapReadOnlyStyleSheetStyleSheetListSubmitEventSubtleCryptoSVGAElementSVGAngleSVGAnimateColorElement
Deprecated
SVGAnimatedAngleSVGAnimatedBooleanSVGAnimatedEnumerationSVGAnimatedIntegerSVGAnimatedLengthSVGAnimatedLengthListSVGAnimatedNumberSVGAnimatedNumberListSVGAnimatedPreserveAspectRatioSVGAnimatedRectSVGAnimatedStringSVGAnimatedTransformListSVGAnimateElementSVGAnimateMotionElementSVGAnimateTransformElementSVGAnimationElementSVGCircleElementSVGClipPathElementSVGComponentTransferFunctionElementSVGDefsElementSVGDescElementSVGDiscardElement
Experimental
SVGElementSVGEllipseElementSVGFEBlendElementSVGFEColorMatrixElementSVGFEComponentTransferElementSVGFECompositeElementSVGFEConvolveMatrixElementSVGFEDiffuseLightingElementSVGFEDisplacementMapElementSVGFEDistantLightElementSVGFEDropShadowElementSVGFEFloodElementSVGFEFuncAElementSVGFEFuncBElementSVGFEFuncGElementSVGFEFuncRElementSVGFEGaussianBlurElementSVGFEImageElementSVGFEMergeElementSVGFEMergeNodeElementSVGFEMorphologyElementSVGFEOffsetElementSVGFEPointLightElementSVGFESpecularLightingElementSVGFESpotLightElementSVGFETileElementSVGFETurbulenceElementSVGFilterElementSVGForeignObjectElementSVGGElementSVGGeometryElementSVGGradientElementSVGGraphicsElementSVGImageElementSVGLengthSVGLengthListSVGLinearGradientElementSVGLineElementSVGMarkerElementSVGMaskElementSVGMetadataElementSVGMPathElementSVGNumberSVGNumberListSVGPathElementSVGPatternElementSVGPoint
Deprecated
SVGPointListSVGPolygonElementSVGPolylineElementSVGPreserveAspectRatioSVGRadialGradientElementSVGRectSVGRectElementSVGRenderingIntent
Deprecated
SVGScriptElementSVGSetElementSVGStopElementSVGStringListSVGStyleElementSVGSVGElementSVGSwitchElementSVGSymbolElementSVGTextContentElementSVGTextElementSVGTextPathElementSVGTextPositioningElementSVGTitleElementSVGTransformSVGTransformListSVGTSpanElementSVGUnitTypesSVGUseElementSVGViewElementSyncEventSyncManagerTTaskAttributionTiming
Experimental
TaskControllerTaskPriorityChangeEventTaskSignalTextTextDecoderTextDecoderStreamTextEncoderTextEncoderStreamTextEvent
Deprecated
TextFormat
Experimental
TextFormatUpdateEvent
Experimental
TextMetricsTextTrackTextTrackCueTextTrackCueListTextTrackListTextUpdateEvent
Experimental
TimeEventTimeRangesToggleEventTouchTouchEventTouchListTrackEventTransformStreamTransformStreamDefaultControllerTransitionEventTreeWalkerTrustedHTMLTrustedScriptTrustedScriptURLTrustedTypePolicyTrustedTypePolicyFactoryUUIEventURLURLPattern
Experimental
URLSearchParamsUSB
Experimental
USBAlternateInterface
Experimental
USBConfiguration
Experimental
USBConnectionEvent
Experimental
USBDevice
Experimental
USBEndpoint
Experimental
USBInterface
Experimental
USBInTransferResult
Experimental
USBIsochronousInTransferPacket
Experimental
USBIsochronousInTransferResult
Experimental
USBIsochronousOutTransferPacket
Experimental
USBIsochronousOutTransferResult
Experimental
USBOutTransferResult
Experimental
UserActivationVValidityStateVideoColorSpaceVideoDecoderVideoEncoderVideoFrameVideoPlaybackQualityVideoTrackVideoTrackGenerator
Experimental
VideoTrackListViewTimeline
Experimental
ViewTransitionVirtualKeyboard
Experimental
VisibilityStateEntry
Experimental
VisualViewportVRDisplay
Non-standard

Deprecated
VRDisplayCapabilities
Non-standard

Deprecated
VRDisplayEvent
Non-standard

Deprecated
VREyeParameters
Non-standard

Deprecated
VRFieldOfView
Non-standard

Deprecated
VRFrameData
Non-standard

Deprecated
VRLayerInit
Deprecated
VRPose
Non-standard

Deprecated
VRStageParameters
Non-standard

Deprecated
VTTCueVTTRegionWWakeLockWakeLockSentinelWaveShaperNodeWebGL2RenderingContextWebGLActiveInfoWebGLBufferWebGLContextEventWebGLFramebufferWebGLObject
Experimental
WebGLProgramWebGLQueryWebGLRenderbufferWebGLRenderingContextWebGLSamplerWebGLShaderWebGLShaderPrecisionFormatWebGLSyncWebGLTextureWebGLTransformFeedbackWebGLUniformLocationWebGLVertexArrayObjectWebSocketWebSocketStream
Experimental
WebTransportWebTransportBidirectionalStreamWebTransportDatagramDuplexStreamWebTransportErrorWebTransportReceiveStream
Experimental
WebTransportSendStream
Experimental
WGSLLanguageFeatures
Experimental
WheelEventWindowWindowClientWindowControlsOverlay
Experimental
WindowControlsOverlayGeometryChangeEvent
Experimental
WindowSharedStorage
Experimental
WorkerWorkerGlobalScopeWorkerLocationWorkerNavigatorWorkletWorkletGlobalScopeWorkletSharedStorage
Experimental
WritableStreamWritableStreamDefaultControllerWritableStreamDefaultWriterXXMLDocumentXMLHttpRequestXMLHttpRequestEventTargetXMLHttpRequestUploadXMLSerializerXPathEvaluatorXPathExpressionXPathResultXRAnchor
Experimental
XRAnchorSet
Experimental
XRBoundedReferenceSpace
Experimental
XRCompositionLayer
Experimental
XRCPUDepthInformation
Experimental
XRCubeLayer
Experimental
XRCylinderLayer
Experimental
XRDepthInformation
Experimental
XREquirectLayer
Experimental
XRFrame
Experimental
XRHandXRHitTestResult
Experimental
XRHitTestSource
Experimental
XRInputSourceXRInputSourceArray
Experimental
XRInputSourceEventXRInputSourcesChangeEventXRJointPoseXRJointSpaceXRLayer
Experimental
XRLayerEvent
Experimental
XRLightEstimate
Experimental
XRLightProbe
Experimental
XRMediaBinding
Experimental
XRPoseXRProjectionLayer
Experimental
XRQuadLayer
Experimental
XRRay
Experimental
XRReferenceSpaceXRReferenceSpaceEventXRRenderState
Experimental
XRRigidTransformXRSession
Experimental
XRSessionEventXRSpaceXRSubImage
Experimental
XRSystem
Experimental
XRTransientInputHitTestResult
Experimental
XRTransientInputHitTestSource
Experimental
XRView
Experimental
XRViewerPoseXRViewportXRWebGLBinding
Experimental
XRWebGLDepthInformation
Experimental
XRWebGLLayer
Experimental
XRWebGLSubImage
Experimental
XSLTProcessorSee also
Web API event reference
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 20, 2023 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWeb APIsWhen writing code for the Web, there are a large number of Web APIs available. Below is a list of all the APIs and interfaces (object types) that you may be able to use while developing your Web app or site.
Web APIs are typically used with JavaScript, although this doesn't always have to be the case.SpecificationsThis is a list of all the APIs that are available.
AAttribution Reporting API
Experimental
Audio Output Devices API
Experimental
BBackground Fetch API
Experimental
Background Synchronization APIBackground Tasks APIBadging APIBarcode Detection API
Experimental
Battery Status APIBeacon APIWeb Bluetooth API
Experimental
Broadcast Channel APICCSS Custom Highlight APICSS Font Loading APICSS Painting API
Experimental
CSS Properties and Values APICSS Typed Object Model APICSS Object Model (CSSOM)Canvas APIChannel Messaging APIClipboard APICompression Streams APICompute Pressure API
Experimental
Console APIContact Picker API
Experimental
Content Index API
Experimental
Cookie Store APICredential Management APIDDocument Object Model (DOM)Device Memory APIDevice orientation eventsDevice Posture API
Experimental
Document Picture-in-Picture API
Experimental
EEditContext API
Experimental
Encoding APIEncrypted Media Extensions APIEyeDropper API
Experimental
FFederated Credential Management (FedCM) API
Experimental
Fenced Frame API
Experimental
Fetch APIFile APIFile System APIFile and Directory Entries APIForce Touch events
Non-standard
Fullscreen APIGGamepad APIGeolocation APIGeometry interfacesHThe HTML DOM APIHTML Drag and Drop APIHistory APIHoudini APIsIIdle Detection API
Experimental
MediaStream Image Capture APIIndexedDB APIInk API
Experimental
InputDeviceCapabilities API
Experimental
Insertable Streams for MediaStreamTrack APIIntersection Observer APIInvoker Commands APIJJS Self-Profiling API
Experimental
KKeyboard API
Experimental
LLaunch Handler API
Experimental
Local Font Access API
Experimental
MMedia Capabilities APIMedia Capture and Streams API (Media Stream)Media Session APIMedia Source API
Experimental
MediaStream Recording APINNavigation API
Experimental
Network Information APIPPage Visibility APIPayment Handler API
Experimental
Payment Request APIPerformance APIsWeb Periodic Background Synchronization API
Experimental
Permissions APIPicture-in-Picture APIPointer eventsPointer Lock APIPopover APIPresentation API
Experimental
Prioritized Task Scheduling APIPush APIRRemote Playback APIReporting APIResize Observer APISSVG APIScreen Capture APIScreen Orientation APIScreen Wake Lock APISelection APISensor APIsServer-sent eventsService Worker APIShared Storage API
Experimental
Speculation Rules API
Experimental
Storage APIStorage Access APIStreams APITTopics API
Experimental

Non-standard
Touch eventsTrusted Types APIUUI EventsURL APIURL Fragment Text DirectivesURL Pattern API
Experimental
User-Agent Client Hints API
Experimental
VVibration APIView Transition APIVirtualKeyboard API
Experimental
Visual Viewport APIWWeb Animations APIWeb Audio APIWeb Authentication APIWeb ComponentsWeb Crypto APIWeb Locks APIWeb MIDI APIWeb NFC API
Experimental
Notifications APIWeb Serial API
Experimental
Web Share APIWeb Speech APIWeb Storage APIWeb Workers APIWebCodecs APIWebGL: 2D and 3D graphics for the webWebGPU API
Experimental
WebHID API
Experimental
WebOTP APIWebRTC APIThe WebSocket API (WebSockets)WebTransport APIWebUSB API
Experimental
WebVR API
Non-standard

Deprecated
WebVTT APIWebXR Device API
Experimental
Window Controls Overlay API
Experimental
Window Management API
Experimental
XXMLHttpRequest APIffetchLater() API
Experimental
InterfacesThis is a list of all the interfaces (that is, types of objects) that are available.
AAbortControllerAbortSignalAbsoluteOrientationSensorAbstractRangeAccelerometer
Experimental
AesCbcParamsAesCtrParamsAesGcmParamsAesKeyGenParamsAmbientLightSensor
Experimental
AnalyserNodeANGLE_instanced_arraysAnimationAnimationEffectAnimationEventAnimationPlaybackEventAnimationTimelineAttrAudioBufferAudioBufferSourceNodeAudioContextAudioDataAudioDecoderAudioDestinationNodeAudioEncoderAudioListenerAudioNodeAudioParamAudioParamDescriptorAudioParamMapAudioProcessingEvent
Deprecated
AudioScheduledSourceNodeAudioSinkInfo
Experimental
AudioTrackAudioTrackListAudioWorkletAudioWorkletGlobalScopeAudioWorkletNodeAudioWorkletProcessorAuthenticatorAssertionResponseAuthenticatorAttestationResponseAuthenticatorResponseBBackgroundFetchEvent
Experimental
BackgroundFetchManager
Experimental
BackgroundFetchRecord
Experimental
BackgroundFetchRegistration
Experimental
BackgroundFetchUpdateUIEvent
Experimental
BarcodeDetector
Experimental
BarPropBaseAudioContextBatteryManagerBeforeInstallPromptEvent
Experimental

Non-standard
BeforeUnloadEventBiquadFilterNodeBlobBlobEventBluetooth
Experimental
BluetoothCharacteristicProperties
Experimental
BluetoothDevice
Experimental
BluetoothRemoteGATTCharacteristic
Experimental
BluetoothRemoteGATTDescriptor
Experimental
BluetoothRemoteGATTServer
Experimental
BluetoothRemoteGATTService
Experimental
BluetoothUUIDBroadcastChannelBrowserCaptureMediaStreamTrack
Experimental
ByteLengthQueuingStrategyCCacheCacheStorageCanMakePaymentEvent
Experimental
CanvasCaptureMediaStreamTrackCanvasGradientCanvasPatternCanvasRenderingContext2DCaptureController
Experimental
CaretPositionCDATASectionChannelMergerNodeChannelSplitterNodeChapterInformation
Experimental
CharacterBoundsUpdateEvent
Experimental
CharacterDataClientClientsClipboardClipboardEventClipboardItemCloseEventCloseWatcher
Experimental
CommandEventCommentCompositionEventCompressionStreamcconsoleCConstantSourceNodeContactAddress
Experimental
ContactsManager
Experimental
ContentIndex
Experimental
ContentIndexEvent
Experimental
ContentVisibilityAutoStateChangeEventConvolverNodeCookieChangeEventCookieStoreCookieStoreManagerCountQueuingStrategyCredentialCredentialsContainerCropTarget
Experimental
CryptoCryptoKeyCryptoKeyPairCSPViolationReportBodyCSSCSSAnimationCSSConditionRuleCSSContainerRuleCSSCounterStyleRuleCSSFontFaceRuleCSSFontFeatureValuesRuleCSSFontPaletteValuesRuleCSSGroupingRuleCSSImageValueCSSImportRuleCSSKeyframeRuleCSSKeyframesRuleCSSKeywordValueCSSLayerBlockRuleCSSLayerStatementRuleCSSMathInvertCSSMathMaxCSSMathMinCSSMathNegateCSSMathProductCSSMathSumCSSMathValueCSSMatrixComponentCSSMediaRuleCSSNamespaceRuleCSSNestedDeclarationsCSSNumericArrayCSSNumericValueCSSPageDescriptors
Experimental
CSSPageRuleCSSPerspectiveCSSPositionTryDescriptors
Experimental
CSSPositionTryRule
Experimental
CSSPositionValue
Non-standard

Deprecated
CSSPrimitiveValue
Deprecated
CSSPropertyRuleCSSPseudoElement
Experimental
CSSRotateCSSRuleCSSRuleListCSSScaleCSSScopeRuleCSSSkewCSSSkewXCSSSkewYCSSStartingStyleRuleCSSStyleDeclarationCSSStyleRuleCSSStyleSheetCSSStyleValueCSSSupportsRuleCSSTransformComponentCSSTransformValueCSSTransitionCSSTranslateCSSUnitValueCSSUnparsedValueCSSValue
Deprecated
CSSValueList
Deprecated
CSSVariableReferenceValueCustomElementRegistryCustomEventCustomStateSetDDataTransferDataTransferItemDataTransferItemListDecompressionStreamDedicatedWorkerGlobalScopeDeferredRequestInit
Experimental
DelayNodeDelegatedInkTrailPresenter
Experimental
DeprecationReportBody
Experimental
DeviceMotionEventDeviceMotionEventAccelerationDeviceMotionEventRotationRateDeviceOrientationEventDevicePosture
Experimental
DirectoryEntrySync
Non-standard

Deprecated
DirectoryReaderSync
Non-standard

Deprecated
DocumentDocumentFragmentDocumentPictureInPicture
Experimental
DocumentPictureInPictureEvent
Experimental
DocumentTimelineDocumentTypeDOMError
Deprecated
DOMExceptionDOMHighResTimeStampDOMImplementationDOMMatrixDOMMatrixReadOnlyDOMParserDOMPointDOMPointReadOnlyDOMQuadDOMRectDOMRectListDOMRectReadOnlyDOMStringListDOMStringMapDOMTokenListDragEventDynamicsCompressorNodeEEcdhKeyDeriveParamsEcdsaParamsEcKeyGenParamsEcKeyImportParamsEditContext
Experimental
ElementElementInternalsEncodedAudioChunkEncodedVideoChunkErrorEventEventEventCountsEventSourceEventTargetExtendableCookieChangeEventExtendableEventExtendableMessageEventEyeDropper
Experimental
FFeaturePolicy
Experimental
FederatedCredential
Experimental
FederatedCredentialInitFence
Experimental
FencedFrameConfig
Experimental
FetchEventFetchLaterResult
Experimental
FileFileEntrySync
Non-standard

Deprecated
FileListFileReaderFileReaderSyncFileSystemFileSystemChangeRecordFileSystemDirectoryEntryFileSystemDirectoryHandleFileSystemDirectoryReaderFileSystemEntryFileSystemFileEntryFileSystemFileHandleFileSystemHandleFileSystemObserver
Experimental

Non-standard
FileSystemSync
Non-standard

Deprecated
FileSystemSyncAccessHandleFileSystemWritableFileStreamFocusEventFontData
Experimental
FontFaceFontFaceSetFontFaceSetLoadEventFormDataFormDataEventFragmentDirectiveGGainNodeGamepadGamepadButtonGamepadEventGamepadHapticActuatorGamepadPose
Experimental
GeolocationGeolocationCoordinatesGeolocationPositionGeolocationPositionErrorGestureEvent
Non-standard
GPU
Experimental
GPUAdapter
Experimental
GPUAdapterInfo
Experimental
GPUBindGroup
Experimental
GPUBindGroupLayout
Experimental
GPUBuffer
Experimental
GPUCanvasContext
Experimental
GPUCommandBuffer
Experimental
GPUCommandEncoder
Experimental
GPUCompilationInfo
Experimental
GPUCompilationMessage
Experimental
GPUComputePassEncoder
Experimental
GPUComputePipeline
Experimental
GPUDevice
Experimental
GPUDeviceLostInfo
Experimental
GPUError
Experimental
GPUExternalTexture
Experimental
GPUInternalError
Experimental
GPUOutOfMemoryError
Experimental
GPUPipelineError
Experimental
GPUPipelineLayout
Experimental
GPUQuerySet
Experimental
GPUQueue
Experimental
GPURenderBundle
Experimental
GPURenderBundleEncoder
Experimental
GPURenderPassEncoder
Experimental
GPURenderPipeline
Experimental
GPUSampler
Experimental
GPUShaderModule
Experimental
GPUSupportedFeatures
Experimental
GPUSupportedLimits
Experimental
GPUTexture
Experimental
GPUTextureView
Experimental
GPUUncapturedErrorEvent
Experimental
GPUValidationError
Experimental
GravitySensorGyroscopeHHashChangeEventHeadersHID
Experimental
HIDConnectionEvent
Experimental
HIDDevice
Experimental
HIDInputReportEvent
Experimental
HighlightHighlightRegistryHistoryHkdfParamsHmacImportParamsHmacKeyGenParamsHMDVRDevice
Non-standard

Deprecated
HTMLAllCollectionHTMLAnchorElementHTMLAreaElementHTMLAudioElementHTMLBaseElementHTMLBodyElementHTMLBRElementHTMLButtonElementHTMLCanvasElementHTMLCollectionHTMLDataElementHTMLDataListElementHTMLDetailsElementHTMLDialogElementHTMLDivElementHTMLDListElementHTMLDocumentHTMLElementHTMLEmbedElementHTMLFencedFrameElement
Experimental
HTMLFieldSetElementHTMLFontElement
Deprecated
HTMLFormControlsCollectionHTMLFormElementHTMLFrameSetElement
Deprecated
HTMLHeadElementHTMLHeadingElementHTMLHRElementHTMLHtmlElementHTMLIFrameElementHTMLImageElementHTMLInputElementHTMLLabelElementHTMLLegendElementHTMLLIElementHTMLLinkElementHTMLMapElementHTMLMarqueeElement
Deprecated
HTMLMediaElementHTMLMenuElementHTMLMetaElementHTMLMeterElementHTMLModElementHTMLObjectElementHTMLOListElementHTMLOptGroupElementHTMLOptionElementHTMLOptionsCollectionHTMLOutputElementHTMLParagraphElementHTMLParamElement
Deprecated
HTMLPictureElementHTMLPreElementHTMLProgressElementHTMLQuoteElementHTMLScriptElementHTMLSelectedContentElementHTMLSelectElementHTMLSlotElementHTMLSourceElementHTMLSpanElementHTMLStyleElementHTMLTableCaptionElementHTMLTableCellElementHTMLTableColElementHTMLTableElementHTMLTableRowElementHTMLTableSectionElementHTMLTemplateElementHTMLTextAreaElementHTMLTimeElementHTMLTitleElementHTMLTrackElementHTMLUListElementHTMLUnknownElementHTMLVideoElementIIDBCursorIDBCursorWithValueIDBDatabaseIDBFactoryIDBIndexIDBKeyRangeIDBObjectStoreIDBOpenDBRequestIDBRequestIDBTransactionIDBVersionChangeEventIdentityCredential
Experimental
IdentityCredentialRequestOptionsIdentityProvider
Experimental
IdleDeadlineIdleDetector
Experimental
IIRFilterNodeImageBitmapImageBitmapRenderingContextImageCaptureImageDataImageDecoderImageTrackImageTrackListInk
Experimental
InputDeviceCapabilities
Experimental
InputDeviceInfoInputEventInstallEventIntersectionObserverIntersectionObserverEntryInterventionReportBody
Experimental
KKeyboard
Experimental
KeyboardEventKeyboardLayoutMap
Experimental
KeyframeEffectLLargestContentfulPaintLaunchParams
Experimental
LaunchQueue
Experimental
LayoutShift
Experimental
LayoutShiftAttribution
Experimental
LinearAccelerationSensorLocationLockLockManagerMMagnetometer
Experimental
MathMLElementMediaCapabilitiesMediaDeviceInfoMediaDevicesMediaElementAudioSourceNodeMediaEncryptedEventMediaErrorMediaKeyMessageEventMediaKeysMediaKeySessionMediaKeyStatusMapMediaKeySystemAccessMediaListMediaMetadataMediaQueryListMediaQueryListEventMediaRecorderMediaRecorderErrorEvent
Non-standard

Deprecated
MediaSessionMediaSourceMediaSourceHandleMediaStreamMediaStreamAudioDestinationNodeMediaStreamAudioSourceNodeMediaStreamEvent
Non-standard

Deprecated
MediaStreamTrackMediaStreamTrackAudioSourceNodeMediaStreamTrackEventMediaStreamTrackGenerator
Experimental

Non-standard
MediaStreamTrackProcessor
Experimental
MediaTrackConstraintsMediaTrackSettingsMediaTrackSupportedConstraintsMerchantValidationEvent
Deprecated
MessageChannelMessageEventMessagePortMetadata
Experimental

Non-standard
MIDIAccessMIDIConnectionEventMIDIInputMIDIInputMapMIDIMessageEventMIDIOutputMIDIOutputMapMIDIPortMimeType
Deprecated
MimeTypeArray
Deprecated
MouseEventMouseScrollEvent
Non-standard

Deprecated
MutationEvent
Non-standard

Deprecated
MutationObserverMutationRecordNNamedNodeMapNavigateEvent
Experimental
Navigation
Experimental
NavigationActivation
Experimental
NavigationCurrentEntryChangeEvent
Experimental
NavigationDestination
Experimental
NavigationHistoryEntry
Experimental
NavigationPreloadManagerNavigationTransition
Experimental
NavigatorNavigatorLoginNavigatorUAData
Experimental
NDEFMessage
Experimental
NDEFReader
Experimental
NDEFReadingEvent
Experimental
NDEFRecord
Experimental
NetworkInformationNodeNodeIteratorNodeListNotificationNotificationEventNotRestoredReasonDetails
Experimental
NotRestoredReasons
Experimental
OOES_draw_buffers_indexedOfflineAudioCompletionEventOfflineAudioContextOffscreenCanvasOffscreenCanvasRenderingContext2DOrientationSensorOscillatorNodeOTPCredential
Experimental
OverconstrainedErrorPPageRevealEventPageSwapEventPageTransitionEventPaintRenderingContext2DPaintSizePaintWorkletGlobalScope
Experimental
PannerNodePasswordCredential
Experimental
PasswordCredentialInitPath2DPaymentAddress
Non-standard

Deprecated
PaymentManager
Experimental
PaymentMethodChangeEventPaymentRequestPaymentRequestEvent
Experimental
PaymentRequestUpdateEventPaymentResponsePbkdf2ParamsPerformancePerformanceElementTiming
Experimental
PerformanceEntryPerformanceEventTimingPerformanceLongAnimationFrameTiming
Experimental
PerformanceLongTaskTiming
Experimental
PerformanceMarkPerformanceMeasurePerformanceNavigation
Deprecated
PerformanceNavigationTimingPerformanceObserverPerformanceObserverEntryListPerformancePaintTimingPerformanceResourceTimingPerformanceScriptTiming
Experimental
PerformanceServerTimingPerformanceTiming
Deprecated
PeriodicSyncEvent
Experimental
PeriodicSyncManager
Experimental
PeriodicWavePermissionsPermissionStatusPictureInPictureEventPictureInPictureWindowPlugin
Deprecated
PluginArray
Deprecated
Point
Non-standard

Deprecated
PointerEventPopStateEventPositionSensorVRDevice
Non-standard

Deprecated
Presentation
Experimental
PresentationAvailability
Experimental
PresentationConnection
Experimental
PresentationConnectionAvailableEvent
Experimental
PresentationConnectionCloseEvent
Experimental
PresentationConnectionList
Experimental
PresentationReceiver
Experimental
PresentationRequest
Experimental
PressureObserver
Experimental
PressureRecord
Experimental
ProcessingInstructionProfiler
Experimental
ProgressEventPromiseRejectionEventPublicKeyCredentialPublicKeyCredentialCreationOptionsPublicKeyCredentialRequestOptionsPushEventPushManagerPushMessageDataPushSubscriptionPushSubscriptionOptionsRRadioNodeListRangeReadableByteStreamControllerReadableStreamReadableStreamBYOBReaderReadableStreamBYOBRequestReadableStreamDefaultControllerReadableStreamDefaultReaderRelativeOrientationSensorRemotePlaybackReportReportBodyReportingObserverRequestRequestInitResizeObserverResizeObserverEntryResizeObserverSizeResponseRestrictionTarget
Experimental
RsaHashedImportParamsRsaHashedKeyGenParamsRsaOaepParamsRsaPssParamsRTCAudioSourceStatsRTCCertificateRTCCertificateStatsRTCCodecStatsRTCDataChannelRTCDataChannelEventRTCDataChannelStatsRTCDtlsTransportRTCDTMFSenderRTCDTMFToneChangeEventRTCEncodedAudioFrameRTCEncodedVideoFrameRTCErrorRTCErrorEventRTCIceCandidateRTCIceCandidatePairRTCIceCandidatePairStatsRTCIceCandidateStatsRTCIceParametersRTCIceTransportRTCIdentityAssertion
Experimental
RTCInboundRtpStreamStatsRTCOutboundRtpStreamStatsRTCPeerConnectionRTCPeerConnectionIceErrorEventRTCPeerConnectionIceEventRTCPeerConnectionStatsRTCRemoteInboundRtpStreamStatsRTCRemoteOutboundRtpStreamStatsRTCRtpReceiverRTCRtpScriptTransformRTCRtpScriptTransformerRTCRtpSenderRTCRtpTransceiverRTCSctpTransportRTCSessionDescriptionRTCStatsReportRTCTrackEventRTCTransformEventRTCTransportStatsRTCVideoSourceStatsSSchedulerScheduling
Experimental
ScreenScreenDetailed
Experimental
ScreenDetails
Experimental
ScreenOrientationScriptProcessorNode
Deprecated
ScrollTimeline
Experimental
SecurePaymentConfirmationRequestSecurityPolicyViolationEventSelectionSensorSensorErrorEventSerial
Experimental
SerialPort
Experimental
ServiceWorkerServiceWorkerContainerServiceWorkerGlobalScopeServiceWorkerRegistrationShadowRootSharedStorage
Experimental
SharedStorageOperation
Experimental
SharedStorageRunOperation
Experimental
SharedStorageSelectURLOperation
Experimental
SharedStorageWorklet
Experimental
SharedStorageWorkletGlobalScope
Experimental
SharedWorkerSharedWorkerGlobalScopeSnapEvent
Experimental
SourceBufferSourceBufferListSpeechGrammar
Non-standard

Deprecated
SpeechGrammarList
Experimental
SpeechRecognitionSpeechRecognitionAlternativeSpeechRecognitionErrorEventSpeechRecognitionEventSpeechRecognitionResultSpeechRecognitionResultListSpeechSynthesisSpeechSynthesisErrorEventSpeechSynthesisEventSpeechSynthesisUtteranceSpeechSynthesisVoiceStaticRangeStereoPannerNodeStorageStorageAccessHandleStorageEventStorageManagerStylePropertyMapStylePropertyMapReadOnlyStyleSheetStyleSheetListSubmitEventSubtleCryptoSVGAElementSVGAngleSVGAnimateColorElement
Deprecated
SVGAnimatedAngleSVGAnimatedBooleanSVGAnimatedEnumerationSVGAnimatedIntegerSVGAnimatedLengthSVGAnimatedLengthListSVGAnimatedNumberSVGAnimatedNumberListSVGAnimatedPreserveAspectRatioSVGAnimatedRectSVGAnimatedStringSVGAnimatedTransformListSVGAnimateElementSVGAnimateMotionElementSVGAnimateTransformElementSVGAnimationElementSVGCircleElementSVGClipPathElementSVGComponentTransferFunctionElementSVGDefsElementSVGDescElementSVGDiscardElement
Experimental
SVGElementSVGEllipseElementSVGFEBlendElementSVGFEColorMatrixElementSVGFEComponentTransferElementSVGFECompositeElementSVGFEConvolveMatrixElementSVGFEDiffuseLightingElementSVGFEDisplacementMapElementSVGFEDistantLightElementSVGFEDropShadowElementSVGFEFloodElementSVGFEFuncAElementSVGFEFuncBElementSVGFEFuncGElementSVGFEFuncRElementSVGFEGaussianBlurElementSVGFEImageElementSVGFEMergeElementSVGFEMergeNodeElementSVGFEMorphologyElementSVGFEOffsetElementSVGFEPointLightElementSVGFESpecularLightingElementSVGFESpotLightElementSVGFETileElementSVGFETurbulenceElementSVGFilterElementSVGForeignObjectElementSVGGElementSVGGeometryElementSVGGradientElementSVGGraphicsElementSVGImageElementSVGLengthSVGLengthListSVGLinearGradientElementSVGLineElementSVGMarkerElementSVGMaskElementSVGMetadataElementSVGMPathElementSVGNumberSVGNumberListSVGPathElementSVGPatternElementSVGPoint
Deprecated
SVGPointListSVGPolygonElementSVGPolylineElementSVGPreserveAspectRatioSVGRadialGradientElementSVGRectSVGRectElementSVGRenderingIntent
Deprecated
SVGScriptElementSVGSetElementSVGStopElementSVGStringListSVGStyleElementSVGSVGElementSVGSwitchElementSVGSymbolElementSVGTextContentElementSVGTextElementSVGTextPathElementSVGTextPositioningElementSVGTitleElementSVGTransformSVGTransformListSVGTSpanElementSVGUnitTypesSVGUseElementSVGViewElementSyncEventSyncManagerTTaskAttributionTiming
Experimental
TaskControllerTaskPriorityChangeEventTaskSignalTextTextDecoderTextDecoderStreamTextEncoderTextEncoderStreamTextEvent
Deprecated
TextFormat
Experimental
TextFormatUpdateEvent
Experimental
TextMetricsTextTrackTextTrackCueTextTrackCueListTextTrackListTextUpdateEvent
Experimental
TimeEventTimeRangesToggleEventTouchTouchEventTouchListTrackEventTransformStreamTransformStreamDefaultControllerTransitionEventTreeWalkerTrustedHTMLTrustedScriptTrustedScriptURLTrustedTypePolicyTrustedTypePolicyFactoryUUIEventURLURLPattern
Experimental
URLSearchParamsUSB
Experimental
USBAlternateInterface
Experimental
USBConfiguration
Experimental
USBConnectionEvent
Experimental
USBDevice
Experimental
USBEndpoint
Experimental
USBInterface
Experimental
USBInTransferResult
Experimental
USBIsochronousInTransferPacket
Experimental
USBIsochronousInTransferResult
Experimental
USBIsochronousOutTransferPacket
Experimental
USBIsochronousOutTransferResult
Experimental
USBOutTransferResult
Experimental
UserActivationVValidityStateVideoColorSpaceVideoDecoderVideoEncoderVideoFrameVideoPlaybackQualityVideoTrackVideoTrackGenerator
Experimental
VideoTrackListViewTimeline
Experimental
ViewTransitionVirtualKeyboard
Experimental
VisibilityStateEntry
Experimental
VisualViewportVRDisplay
Non-standard

Deprecated
VRDisplayCapabilities
Non-standard

Deprecated
VRDisplayEvent
Non-standard

Deprecated
VREyeParameters
Non-standard

Deprecated
VRFieldOfView
Non-standard

Deprecated
VRFrameData
Non-standard

Deprecated
VRLayerInit
Deprecated
VRPose
Non-standard

Deprecated
VRStageParameters
Non-standard

Deprecated
VTTCueVTTRegionWWakeLockWakeLockSentinelWaveShaperNodeWebGL2RenderingContextWebGLActiveInfoWebGLBufferWebGLContextEventWebGLFramebufferWebGLObject
Experimental
WebGLProgramWebGLQueryWebGLRenderbufferWebGLRenderingContextWebGLSamplerWebGLShaderWebGLShaderPrecisionFormatWebGLSyncWebGLTextureWebGLTransformFeedbackWebGLUniformLocationWebGLVertexArrayObjectWebSocketWebSocketStream
Experimental
WebTransportWebTransportBidirectionalStreamWebTransportDatagramDuplexStreamWebTransportErrorWebTransportReceiveStream
Experimental
WebTransportSendStream
Experimental
WGSLLanguageFeatures
Experimental
WheelEventWindowWindowClientWindowControlsOverlay
Experimental
WindowControlsOverlayGeometryChangeEvent
Experimental
WindowSharedStorage
Experimental
WorkerWorkerGlobalScopeWorkerLocationWorkerNavigatorWorkletWorkletGlobalScopeWorkletSharedStorage
Experimental
WritableStreamWritableStreamDefaultControllerWritableStreamDefaultWriterXXMLDocumentXMLHttpRequestXMLHttpRequestEventTargetXMLHttpRequestUploadXMLSerializerXPathEvaluatorXPathExpressionXPathResultXRAnchor
Experimental
XRAnchorSet
Experimental
XRBoundedReferenceSpace
Experimental
XRCompositionLayer
Experimental
XRCPUDepthInformation
Experimental
XRCubeLayer
Experimental
XRCylinderLayer
Experimental
XRDepthInformation
Experimental
XREquirectLayer
Experimental
XRFrame
Experimental
XRHandXRHitTestResult
Experimental
XRHitTestSource
Experimental
XRInputSourceXRInputSourceArray
Experimental
XRInputSourceEventXRInputSourcesChangeEventXRJointPoseXRJointSpaceXRLayer
Experimental
XRLayerEvent
Experimental
XRLightEstimate
Experimental
XRLightProbe
Experimental
XRMediaBinding
Experimental
XRPoseXRProjectionLayer
Experimental
XRQuadLayer
Experimental
XRRay
Experimental
XRReferenceSpaceXRReferenceSpaceEventXRRenderState
Experimental
XRRigidTransformXRSession
Experimental
XRSessionEventXRSpaceXRSubImage
Experimental
XRSystem
Experimental
XRTransientInputHitTestResult
Experimental
XRTransientInputHitTestSource
Experimental
XRView
Experimental
XRViewerPoseXRViewportXRWebGLBinding
Experimental
XRWebGLDepthInformation
Experimental
XRWebGLLayer
Experimental
XRWebGLSubImage
Experimental
XSLTProcessorSee also
Web API event reference
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 20, 2023 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nBrowser extensionsExtensions, or add-ons, can modify and enhance the capability of a browser. Extensions for Firefox are built using the WebExtensions API cross-browser technology.
The technology for extensions in Firefox is, to a large extent, compatible with the extension API supported by Chromium-based browsers (such as Google Chrome, Microsoft Edge, Opera, Vivaldi). In most cases, extensions written for Chromium-based browsers run in Firefox with just a few changes.Key resources
Guides

Whether you're just beginning or looking for more advanced advice, learn about how extensions work and use the WebExtensions API from our extensive range of tutorials and guides.

References

Get comprehensive details about the methods, properties, types, and events of the WebExtensions APIs and full details about the manifest keys.

Firefox workflow

Discover how to build and publish extensions for Firefox: get the lowdown on developer tools, publication and distribution, and porting on Extension Workshop.



Note:
If you have ideas or questions or need help, you can reach us on the community forum or in the Add-ons Room on Matrix.
Get startedDiscover what extensions can do before building your first extension. Learn about the anatomy of an extension and get an overview of the extension development and publication workflow, Firefox style. Explore a little deeper with a comprehensive selection of example extensions that you can run right in Firefox.ConceptsGet detailed information on the concept that underpin extensions from an overview of the JavaScript API, through content scripts, match patterns, working with files, internationalization, and content security policy, to more advanced subjects such as native messaging, using the devtools APIs, and native manifests.User interfaceDiscover all the user interface components you can use in your extensions, with coding examples and tips.How toFrom patterns you'll regularly use such as work with the Tabs API and adding a button to the toolbar to more advanced topics such as intercepting HTTP requests and working with contextual identities, you'll find a range of tutorials to get you started.Firefox workflowWhen you are ready to create your extension for Firefox or port your Chrome extension, head over to Extension Workshop. It has details on:

The Firefox workflow, such as temporarily installing extensions during development, debugging, request the right permissions, and more.
The web-ext developer tool.
Porting a Google Chrome extension, differences between desktop and Android, and more.
Publishing and distribution overview, promoting your extension, the extension lifecycle best practices, and more.
ReferenceJavaScript APIsGet comprehensive details about the methods, properties, types, and events for all the JavaScript APIs. There is also detailed information about the compatibility of each API with the major browsers. Most reference pages also include coding examples and links to the extension examples that use the API.Manifest keysGet full details about the manifest keys, including all their properties and settings.\n\nBrowser extensionsExtensions, or add-ons, can modify and enhance the capability of a browser. Extensions for Firefox are built using the WebExtensions API cross-browser technology.
The technology for extensions in Firefox is, to a large extent, compatible with the extension API supported by Chromium-based browsers (such as Google Chrome, Microsoft Edge, Opera, Vivaldi). In most cases, extensions written for Chromium-based browsers run in Firefox with just a few changes.Key resources
Guides

Whether you're just beginning or looking for more advanced advice, learn about how extensions work and use the WebExtensions API from our extensive range of tutorials and guides.

References

Get comprehensive details about the methods, properties, types, and events of the WebExtensions APIs and full details about the manifest keys.

Firefox workflow

Discover how to build and publish extensions for Firefox: get the lowdown on developer tools, publication and distribution, and porting on Extension Workshop.



Note:
If you have ideas or questions or need help, you can reach us on the community forum or in the Add-ons Room on Matrix.
Get startedDiscover what extensions can do before building your first extension. Learn about the anatomy of an extension and get an overview of the extension development and publication workflow, Firefox style. Explore a little deeper with a comprehensive selection of example extensions that you can run right in Firefox.ConceptsGet detailed information on the concept that underpin extensions from an overview of the JavaScript API, through content scripts, match patterns, working with files, internationalization, and content security policy, to more advanced subjects such as native messaging, using the devtools APIs, and native manifests.User interfaceDiscover all the user interface components you can use in your extensions, with coding examples and tips.How toFrom patterns you'll regularly use such as work with the Tabs API and adding a button to the toolbar to more advanced topics such as intercepting HTTP requests and working with contextual identities, you'll find a range of tutorials to get you started.Firefox workflowWhen you are ready to create your extension for Firefox or port your Chrome extension, head over to Extension Workshop. It has details on:

The Firefox workflow, such as temporarily installing extensions during development, debugging, request the right permissions, and more.
The web-ext developer tool.
Porting a Google Chrome extension, differences between desktop and Android, and more.
Publishing and distribution overview, promoting your extension, the extension lifecycle best practices, and more.
ReferenceJavaScript APIsGet comprehensive details about the methods, properties, types, and events for all the JavaScript APIs. There is also detailed information about the compatibility of each API with the major browsers. Most reference pages also include coding examples and links to the extension examples that use the API.Manifest keysGet full details about the manifest keys, including all their properties and settings.Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 22, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nBrowser extensionsExtensions, or add-ons, can modify and enhance the capability of a browser. Extensions for Firefox are built using the WebExtensions API cross-browser technology.
The technology for extensions in Firefox is, to a large extent, compatible with the extension API supported by Chromium-based browsers (such as Google Chrome, Microsoft Edge, Opera, Vivaldi). In most cases, extensions written for Chromium-based browsers run in Firefox with just a few changes.Key resources
Guides

Whether you're just beginning or looking for more advanced advice, learn about how extensions work and use the WebExtensions API from our extensive range of tutorials and guides.

References

Get comprehensive details about the methods, properties, types, and events of the WebExtensions APIs and full details about the manifest keys.

Firefox workflow

Discover how to build and publish extensions for Firefox: get the lowdown on developer tools, publication and distribution, and porting on Extension Workshop.



Note:
If you have ideas or questions or need help, you can reach us on the community forum or in the Add-ons Room on Matrix.
Get startedDiscover what extensions can do before building your first extension. Learn about the anatomy of an extension and get an overview of the extension development and publication workflow, Firefox style. Explore a little deeper with a comprehensive selection of example extensions that you can run right in Firefox.ConceptsGet detailed information on the concept that underpin extensions from an overview of the JavaScript API, through content scripts, match patterns, working with files, internationalization, and content security policy, to more advanced subjects such as native messaging, using the devtools APIs, and native manifests.User interfaceDiscover all the user interface components you can use in your extensions, with coding examples and tips.How toFrom patterns you'll regularly use such as work with the Tabs API and adding a button to the toolbar to more advanced topics such as intercepting HTTP requests and working with contextual identities, you'll find a range of tutorials to get you started.Firefox workflowWhen you are ready to create your extension for Firefox or port your Chrome extension, head over to Extension Workshop. It has details on:

The Firefox workflow, such as temporarily installing extensions during development, debugging, request the right permissions, and more.
The web-ext developer tool.
Porting a Google Chrome extension, differences between desktop and Android, and more.
Publishing and distribution overview, promoting your extension, the extension lifecycle best practices, and more.
ReferenceJavaScript APIsGet comprehensive details about the methods, properties, types, and events for all the JavaScript APIs. There is also detailed information about the compatibility of each API with the major browsers. Most reference pages also include coding examples and links to the extension examples that use the API.Manifest keysGet full details about the manifest keys, including all their properties and settings.Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 22, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nAccessibilityAccessibility (often abbreviated to A11y — as in, "a", then 11 characters, and then "y") in web development means enabling as many people as possible to use websites, even when those people's abilities are limited in some way.
For many people, technology makes things easier. For people with disabilities, technology makes things possible. Accessibility means developing content to be as accessible as possible, no matter an individual's physical and cognitive abilities and how they access the web.

The Web is fundamentally designed to work for all people, whatever their hardware, software, language, location, or ability.
When the Web meets this goal, it is accessible to people with a diverse range of hearing, movement, sight, and cognitive ability. 
– (W3C - Accessibility)
Accessibility guides
Accessibility information for web authors

This document lists guidelines and regulations, how-to's, and tools for checking and repairing accessibility problems with websites.

Personalization to help browse safely

This article discusses making web content accessible for those with vestibular disorders, and those who support them, by taking advantage of personalization and accessibility settings built into the operating systems.

Accessible web applications and widgets

Most JavaScript libraries offer a library of client-side widgets that mimic the behavior of familiar desktop interfaces.
While this results in a widget that looks like its desktop counterpart, there usually isn't enough semantic information in the markup to be usable by an assistive technology.
This document describes techniques to improve accessibility of such widgets.

Keyboard-navigable JavaScript widgets

Until now, web developers who wanted to make their styled <div> and <span> based widgets accessible have lacked proper techniques.
Keyboard accessibility is part of the minimum accessibility requirements, which a developer should be aware of.
This document describes techniques to make JavaScript widgets accessible with the keyboard.

Mobile accessibility checklist

This document provides a concise checklist of accessibility requirements for mobile app developers.

Understanding the Web Content Accessibility Guidelines (WCAG)

A set of articles that provide quick explanations to help you understand the steps that need to be taken to conform to the recommendations outlined in the Web Content Accessibility Guidelines (WCAG).

Cognitive accessibility

Cognitive accessibility covers accessibility considerations for people with cognition and learning disabilities.
This document introduces cognitive accessibility and improving accessibility of the web for people with cognitive and learning differences.

Accessibility and spatial patterns

This document describes visual patterns that can induce physical symptoms in people who have photosensitive epilepsy, vestibular disorders, or other perceptual issues.

Web Accessibility: Understanding Colors and Luminance

While understanding color, luminance, and saturation is important for design and readability for all sighted users, they are essential for those with reduced vision and color-deficient vision and those with specific neurological, cognitive, and other impairments.

Web accessibility for seizures and physical reactions

Some types of visual web content can induce seizures in people with certain brain disorders.
This article helps you understand the types of content that can be problematic and find tools and strategies to help you avoid them.

ARIA

This is a collection of articles to learn how to use Accessible Rich Internet Applications (ARIA) to make your HTML documents more accessible.

Tutorials for beginnersThe MDN Accessibility Learning Area contains modern, up-to-date tutorials covering the following accessibility essentials:

What is accessibility?

This article starts off the module with a good look at what accessibility actually is — this includes what groups of people we need to consider and why, what tools different people use to interact with the Web, and how we can make accessibility part of our web development workflow.

HTML: A good basis for accessibility

A great deal of web content can be made accessible just by making sure that the correct HTML elements are used for the correct purpose at all times. This article looks in detail at how HTML can be used to ensure maximum accessibility.

CSS and JavaScript accessibility best practices

CSS and JavaScript, when used properly, also have the potential to allow for accessible web experiences. They can significantly harm accessibility if misused. This article outlines some CSS and JavaScript best practices that should be considered to ensure that even complex content is as accessible as possible.

WAI-ARIA basics

Following on from the previous article, sometimes making complex UI controls that involve unsemantic HTML and dynamic JavaScript-updated content can be difficult. WAI-ARIA is a technology that can help with such problems by adding in further semantics that browsers and assistive technologies can recognize and let users know what is going on. Here we'll show how to use it at a basic level to improve accessibility.

Accessible multimedia

Another category of content that can create accessibility problems is multimedia — video, audio, and image content need to be given proper textual alternatives so that they can be understood by assistive technologies and their users. This article shows how.

Mobile accessibility

With web access on mobile devices being so popular and popular platforms such as iOS and Android having fully-fledged accessibility tools, it is important to consider the accessibility of your web content on these platforms. This article looks at mobile-specific accessibility considerations.

References
ARIA reference

Reference documentation for Accessible Rich Internet Applications (ARIA) attributes and roles.

See also
Developer guides
WAI Interest Group\n\nAccessibilityAccessibility (often abbreviated to A11y — as in, "a", then 11 characters, and then "y") in web development means enabling as many people as possible to use websites, even when those people's abilities are limited in some way.
For many people, technology makes things easier. For people with disabilities, technology makes things possible. Accessibility means developing content to be as accessible as possible, no matter an individual's physical and cognitive abilities and how they access the web.

The Web is fundamentally designed to work for all people, whatever their hardware, software, language, location, or ability.
When the Web meets this goal, it is accessible to people with a diverse range of hearing, movement, sight, and cognitive ability. 
– (W3C - Accessibility)
Accessibility guides
Accessibility information for web authors

This document lists guidelines and regulations, how-to's, and tools for checking and repairing accessibility problems with websites.

Personalization to help browse safely

This article discusses making web content accessible for those with vestibular disorders, and those who support them, by taking advantage of personalization and accessibility settings built into the operating systems.

Accessible web applications and widgets

Most JavaScript libraries offer a library of client-side widgets that mimic the behavior of familiar desktop interfaces.
While this results in a widget that looks like its desktop counterpart, there usually isn't enough semantic information in the markup to be usable by an assistive technology.
This document describes techniques to improve accessibility of such widgets.

Keyboard-navigable JavaScript widgets

Until now, web developers who wanted to make their styled <div> and <span> based widgets accessible have lacked proper techniques.
Keyboard accessibility is part of the minimum accessibility requirements, which a developer should be aware of.
This document describes techniques to make JavaScript widgets accessible with the keyboard.

Mobile accessibility checklist

This document provides a concise checklist of accessibility requirements for mobile app developers.

Understanding the Web Content Accessibility Guidelines (WCAG)

A set of articles that provide quick explanations to help you understand the steps that need to be taken to conform to the recommendations outlined in the Web Content Accessibility Guidelines (WCAG).

Cognitive accessibility

Cognitive accessibility covers accessibility considerations for people with cognition and learning disabilities.
This document introduces cognitive accessibility and improving accessibility of the web for people with cognitive and learning differences.

Accessibility and spatial patterns

This document describes visual patterns that can induce physical symptoms in people who have photosensitive epilepsy, vestibular disorders, or other perceptual issues.

Web Accessibility: Understanding Colors and Luminance

While understanding color, luminance, and saturation is important for design and readability for all sighted users, they are essential for those with reduced vision and color-deficient vision and those with specific neurological, cognitive, and other impairments.

Web accessibility for seizures and physical reactions

Some types of visual web content can induce seizures in people with certain brain disorders.
This article helps you understand the types of content that can be problematic and find tools and strategies to help you avoid them.

ARIA

This is a collection of articles to learn how to use Accessible Rich Internet Applications (ARIA) to make your HTML documents more accessible.

Tutorials for beginnersThe MDN Accessibility Learning Area contains modern, up-to-date tutorials covering the following accessibility essentials:

What is accessibility?

This article starts off the module with a good look at what accessibility actually is — this includes what groups of people we need to consider and why, what tools different people use to interact with the Web, and how we can make accessibility part of our web development workflow.

HTML: A good basis for accessibility

A great deal of web content can be made accessible just by making sure that the correct HTML elements are used for the correct purpose at all times. This article looks in detail at how HTML can be used to ensure maximum accessibility.

CSS and JavaScript accessibility best practices

CSS and JavaScript, when used properly, also have the potential to allow for accessible web experiences. They can significantly harm accessibility if misused. This article outlines some CSS and JavaScript best practices that should be considered to ensure that even complex content is as accessible as possible.

WAI-ARIA basics

Following on from the previous article, sometimes making complex UI controls that involve unsemantic HTML and dynamic JavaScript-updated content can be difficult. WAI-ARIA is a technology that can help with such problems by adding in further semantics that browsers and assistive technologies can recognize and let users know what is going on. Here we'll show how to use it at a basic level to improve accessibility.

Accessible multimedia

Another category of content that can create accessibility problems is multimedia — video, audio, and image content need to be given proper textual alternatives so that they can be understood by assistive technologies and their users. This article shows how.

Mobile accessibility

With web access on mobile devices being so popular and popular platforms such as iOS and Android having fully-fledged accessibility tools, it is important to consider the accessibility of your web content on these platforms. This article looks at mobile-specific accessibility considerations.

References
ARIA reference

Reference documentation for Accessible Rich Internet Applications (ARIA) attributes and roles.

See also
Developer guides
WAI Interest Group
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nAccessibilityAccessibility (often abbreviated to A11y — as in, "a", then 11 characters, and then "y") in web development means enabling as many people as possible to use websites, even when those people's abilities are limited in some way.
For many people, technology makes things easier. For people with disabilities, technology makes things possible. Accessibility means developing content to be as accessible as possible, no matter an individual's physical and cognitive abilities and how they access the web.

The Web is fundamentally designed to work for all people, whatever their hardware, software, language, location, or ability.
When the Web meets this goal, it is accessible to people with a diverse range of hearing, movement, sight, and cognitive ability. 
– (W3C - Accessibility)
Accessibility guides
Accessibility information for web authors

This document lists guidelines and regulations, how-to's, and tools for checking and repairing accessibility problems with websites.

Personalization to help browse safely

This article discusses making web content accessible for those with vestibular disorders, and those who support them, by taking advantage of personalization and accessibility settings built into the operating systems.

Accessible web applications and widgets

Most JavaScript libraries offer a library of client-side widgets that mimic the behavior of familiar desktop interfaces.
While this results in a widget that looks like its desktop counterpart, there usually isn't enough semantic information in the markup to be usable by an assistive technology.
This document describes techniques to improve accessibility of such widgets.

Keyboard-navigable JavaScript widgets

Until now, web developers who wanted to make their styled <div> and <span> based widgets accessible have lacked proper techniques.
Keyboard accessibility is part of the minimum accessibility requirements, which a developer should be aware of.
This document describes techniques to make JavaScript widgets accessible with the keyboard.

Mobile accessibility checklist

This document provides a concise checklist of accessibility requirements for mobile app developers.

Understanding the Web Content Accessibility Guidelines (WCAG)

A set of articles that provide quick explanations to help you understand the steps that need to be taken to conform to the recommendations outlined in the Web Content Accessibility Guidelines (WCAG).

Cognitive accessibility

Cognitive accessibility covers accessibility considerations for people with cognition and learning disabilities.
This document introduces cognitive accessibility and improving accessibility of the web for people with cognitive and learning differences.

Accessibility and spatial patterns

This document describes visual patterns that can induce physical symptoms in people who have photosensitive epilepsy, vestibular disorders, or other perceptual issues.

Web Accessibility: Understanding Colors and Luminance

While understanding color, luminance, and saturation is important for design and readability for all sighted users, they are essential for those with reduced vision and color-deficient vision and those with specific neurological, cognitive, and other impairments.

Web accessibility for seizures and physical reactions

Some types of visual web content can induce seizures in people with certain brain disorders.
This article helps you understand the types of content that can be problematic and find tools and strategies to help you avoid them.

ARIA

This is a collection of articles to learn how to use Accessible Rich Internet Applications (ARIA) to make your HTML documents more accessible.

Tutorials for beginnersThe MDN Accessibility Learning Area contains modern, up-to-date tutorials covering the following accessibility essentials:

What is accessibility?

This article starts off the module with a good look at what accessibility actually is — this includes what groups of people we need to consider and why, what tools different people use to interact with the Web, and how we can make accessibility part of our web development workflow.

HTML: A good basis for accessibility

A great deal of web content can be made accessible just by making sure that the correct HTML elements are used for the correct purpose at all times. This article looks in detail at how HTML can be used to ensure maximum accessibility.

CSS and JavaScript accessibility best practices

CSS and JavaScript, when used properly, also have the potential to allow for accessible web experiences. They can significantly harm accessibility if misused. This article outlines some CSS and JavaScript best practices that should be considered to ensure that even complex content is as accessible as possible.

WAI-ARIA basics

Following on from the previous article, sometimes making complex UI controls that involve unsemantic HTML and dynamic JavaScript-updated content can be difficult. WAI-ARIA is a technology that can help with such problems by adding in further semantics that browsers and assistive technologies can recognize and let users know what is going on. Here we'll show how to use it at a basic level to improve accessibility.

Accessible multimedia

Another category of content that can create accessibility problems is multimedia — video, audio, and image content need to be given proper textual alternatives so that they can be understood by assistive technologies and their users. This article shows how.

Mobile accessibility

With web access on mobile devices being so popular and popular platforms such as iOS and Android having fully-fledged accessibility tools, it is important to consider the accessibility of your web content on these platforms. This article looks at mobile-specific accessibility considerations.

References
ARIA reference

Reference documentation for Accessible Rich Internet Applications (ARIA) attributes and roles.

See also
Developer guides
WAI Interest Group
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nLearn web developmentThe essential skill set for new front-end developersWelcome to MDN Learning Web Development (also known as Learn). This resource provides a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer, along with challenges and further recommended resources.About Learn web development

Teaches the essential skills and knowledge every front-end developer needs for career success and industry relevance, as defined in the MDN Curriculum.


Created by the MDN community and refined with insights from students, educators, and developers from the broader web community.


Designed to take you from "beginner" to "comfortable" (not "beginner" to "expert"), giving you enough knowledge to use more advanced resources (such as the rest of MDN).



Note:
Last updated: December 2024 (see changelog).
Don't know where to get started?
Never coded before?

Our Getting started modules provide setup tutorials and essential concepts and background information for complete beginners. You should start here if you are a complete beginner (i.e., you've not installed a code editor or written any code yet).

Want to master the essentials?

Our Core modules provide a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer.

Beyond the basics?

Our Extension modules cover useful additional skills to learn as you start to expand your knowledge and develop specialisms. Go onto these after you finish our Core.

Working at a school?

Use our modules to guide your teaching, check out our Educators page for more ideas, or enroll your students in Scrimba's Frontend Developer Career PathMDN learning partner.

Getting our code examplesThe code examples you'll encounter in the Learning Area are all available on GitHub:

The easiest way to get them is to download a ZIP of the latest main code branch.
If you are familiar with Git and GitHub, you could also choose to clone the repository.
Contact usIf you want to get in touch with us about anything, use the communication channels. We'd love to hear from you about anything you think is wrong or missing on the site, requests for new learning topics, requests for help with items you don't understand, or any other questions or concerns.
If you're interested in helping develop/improve the content, take a look at how you can help and get in touch! We are more than happy to talk to you, whether you are a learner, teacher, experienced web developer, or someone else interested in helping to improve the learning experience.See also
The Frontend Developer Career Path MDN learning partner

Scrimba's Frontend Developer Career Path teaches all you need to know to be a competent front-end web developer, with fun interactive lessons and challenges, knowledgeable teachers, and a supportive community. Go from zero to landing your first front-end job! Many of the course components are available as standalone free versions.

Codecademy

A great interactive site for learning programming languages from scratch.

freeCodeCamp.org

Interactive site with tutorials and projects to learn web development.

Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.\n\nLearn web developmentThe essential skill set for new front-end developersWelcome to MDN Learning Web Development (also known as Learn). This resource provides a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer, along with challenges and further recommended resources.About Learn web development

Teaches the essential skills and knowledge every front-end developer needs for career success and industry relevance, as defined in the MDN Curriculum.


Created by the MDN community and refined with insights from students, educators, and developers from the broader web community.


Designed to take you from "beginner" to "comfortable" (not "beginner" to "expert"), giving you enough knowledge to use more advanced resources (such as the rest of MDN).



Note:
Last updated: December 2024 (see changelog).
Don't know where to get started?
Never coded before?

Our Getting started modules provide setup tutorials and essential concepts and background information for complete beginners. You should start here if you are a complete beginner (i.e., you've not installed a code editor or written any code yet).

Want to master the essentials?

Our Core modules provide a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer.

Beyond the basics?

Our Extension modules cover useful additional skills to learn as you start to expand your knowledge and develop specialisms. Go onto these after you finish our Core.

Working at a school?

Use our modules to guide your teaching, check out our Educators page for more ideas, or enroll your students in Scrimba's Frontend Developer Career PathMDN learning partner.

Getting our code examplesThe code examples you'll encounter in the Learning Area are all available on GitHub:

The easiest way to get them is to download a ZIP of the latest main code branch.
If you are familiar with Git and GitHub, you could also choose to clone the repository.
Contact usIf you want to get in touch with us about anything, use the communication channels. We'd love to hear from you about anything you think is wrong or missing on the site, requests for new learning topics, requests for help with items you don't understand, or any other questions or concerns.
If you're interested in helping develop/improve the content, take a look at how you can help and get in touch! We are more than happy to talk to you, whether you are a learner, teacher, experienced web developer, or someone else interested in helping to improve the learning experience.See also
The Frontend Developer Career Path MDN learning partner

Scrimba's Frontend Developer Career Path teaches all you need to know to be a competent front-end web developer, with fun interactive lessons and challenges, knowledgeable teachers, and a supportive community. Go from zero to landing your first front-end job! Many of the course components are available as standalone free versions.

Codecademy

A great interactive site for learning programming languages from scratch.

freeCodeCamp.org

Interactive site with tutorials and projects to learn web development.

Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 28, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nLearn web developmentThe essential skill set for new front-end developersWelcome to MDN Learning Web Development (also known as Learn). This resource provides a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer, along with challenges and further recommended resources.About Learn web development

Teaches the essential skills and knowledge every front-end developer needs for career success and industry relevance, as defined in the MDN Curriculum.


Created by the MDN community and refined with insights from students, educators, and developers from the broader web community.


Designed to take you from "beginner" to "comfortable" (not "beginner" to "expert"), giving you enough knowledge to use more advanced resources (such as the rest of MDN).



Note:
Last updated: December 2024 (see changelog).
Don't know where to get started?
Never coded before?

Our Getting started modules provide setup tutorials and essential concepts and background information for complete beginners. You should start here if you are a complete beginner (i.e., you've not installed a code editor or written any code yet).

Want to master the essentials?

Our Core modules provide a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer.

Beyond the basics?

Our Extension modules cover useful additional skills to learn as you start to expand your knowledge and develop specialisms. Go onto these after you finish our Core.

Working at a school?

Use our modules to guide your teaching, check out our Educators page for more ideas, or enroll your students in Scrimba's Frontend Developer Career PathMDN learning partner.

Getting our code examplesThe code examples you'll encounter in the Learning Area are all available on GitHub:

The easiest way to get them is to download a ZIP of the latest main code branch.
If you are familiar with Git and GitHub, you could also choose to clone the repository.
Contact usIf you want to get in touch with us about anything, use the communication channels. We'd love to hear from you about anything you think is wrong or missing on the site, requests for new learning topics, requests for help with items you don't understand, or any other questions or concerns.
If you're interested in helping develop/improve the content, take a look at how you can help and get in touch! We are more than happy to talk to you, whether you are a learner, teacher, experienced web developer, or someone else interested in helping to improve the learning experience.See also
The Frontend Developer Career Path MDN learning partner

Scrimba's Frontend Developer Career Path teaches all you need to know to be a competent front-end web developer, with fun interactive lessons and challenges, knowledgeable teachers, and a supportive community. Go from zero to landing your first front-end job! Many of the course components are available as standalone free versions.

Codecademy

A great interactive site for learning programming languages from scratch.

freeCodeCamp.org

Interactive site with tutorials and projects to learn web development.

Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 28, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nStructuring content with HTML Overview: Core learning modules Next  
HTML is the technology that defines the content and structure of any website. Written properly, it should also define the semantics (meaning) of the content in a machine-readable way, which is vital for accessibility, search engine optimization, and making use of the built-in features browsers provide for content to work optimally. This module covers the basics of the language, before looking at key areas such as document structure, links, lists, images, forms, and more.PrerequisitesBefore starting this module, you don't need any previous HTML knowledge, but you should have at least basic familiarity with using computers and using the web passively (i.e., just looking at it and consuming content). You should have a basic work environment set up (as detailed in Installing basic software), and understand how to create and manage files (as detailed in Dealing with files). Both are parts of our Getting started with the web complete beginner's module.

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
Basic HTML syntax

Covers the absolute basics of HTML, to get you started — we define elements, attributes, and other important terms, and show where they fit in the language. We also show how a typical HTML page is structured and how an HTML element is structured, and explain other important basic language features. Along the way, we'll play with some HTML to get you interested!

What's in the head? Web page metadata

The head of an HTML document is the part that is not displayed in the web browser when the page is loaded. It contains metadata information such as the page <title>, links to CSS (if you want to style your HTML content with CSS), links to custom favicons, and metadata (data about the HTML, such as who wrote it, and important keywords that describe the document).

Headings and paragraphs

One of HTML's main jobs is to give text structure so that a browser can display an HTML document the way its developer intends. This article explains how HTML can be used to provide fundamental page structure by defining headings and paragraphs.

Emphasis and importance

The previous article looked at why semantics are important in HTML, and focused on headings and paragraphs. This article continues on the theme of semantics, looking at HTML elements that apply emphasis and importance to text (parallel to italics and bold text in print media).

Lists

Lists are everywhere in life—from your shopping list to the list of directions you subconsciously follow to get to your house every day, to the lists of instructions you are following in these tutorials! It may not surprise you that HTML has a convenient set of elements that allows us to define different types of list. On the web, we have three types of lists: unordered, ordered, and description lists. This lesson shows you how to use the different types.

Structuring documents

In addition to defining individual parts of your page (such as "a paragraph" or "an image"), HTML also boasts a number of block level elements used to define areas of your website (such as "the header", "the navigation menu", "the main content column"). This article looks into how to plan a basic website structure, and write the HTML to represent this structure.

Advanced text features

There are many other elements in HTML for defining text semantics, which we didn't get to in the Emphasis and importance article. The elements described in this article are less known, but still useful to know about (and this is still not a complete list by any means). Here you'll learn about marking up quotations, computer code and other related text, subscript and superscript, contact information, and more.

Creating links

Links (also known as hyperlinks) are really important — they are what makes the Web a web. This article shows the syntax required to make a link, and discusses link best practices.

Marking up a letter Challenge

We all learn to write a letter sooner or later; it is also a useful example to test our text formatting skills. In this challenge, you'll have a letter to mark up as a test for your HTML text formatting skills, as well as hyperlinks and proper use of the HTML <head> element.

Structuring a page of content Challenge

Structuring a page of content ready for laying it out using CSS is a very important skill to master, so in this challenge you'll be tested on your ability to think about how a page might end up looking, and choose appropriate structural semantics to build a layout on top of.

HTML images

In the beginning, the web was just text, and it was really quite boring. Fortunately, it wasn't too long before the ability to embed images (and other more interesting types of content) inside web pages was added. In this article we'll look at how to use the <img> element in depth, including the basics, annotating it with captions using <figure>, and detailing how it relates to CSS background images.

HTML video and audio

Now that we are comfortable with adding simple images to a webpage, the next step is to start adding video and audio players to your HTML documents! In this article we'll look at doing just that with the <video> and <audio> elements; we'll then finish off by looking at how to add captions/subtitles to your videos.

Mozilla splash page Challenge

In this challenge, we'll test your knowledge of some of the techniques discussed in the last couple of lessons, getting you to add some images and video to a funky splash page all about Mozilla!

HTML table basics

This article gets you started with HTML tables, covering the very basics such as rows, cells, headings, making cells span multiple columns and rows, and how to group together all the cells in a column for styling purposes.

HTML table accessibility

In this article we look at more HTML table accessibility features such as captions/summaries, grouping your rows into table head, body and footer sections, and scoping columns and rows.

Structuring a planet data table Challenge

In this challenge, we provide you with some data on the planets in our solar system. Your job is to structure it into an accessible HTML table.

Forms and buttons in HTML

HTML forms and buttons are powerful tools for interacting with users — most commonly they are used for collecting data from users or allowing them to control a user interface. In this article we provide an introduction to the basics of forms and buttons.

Debugging HTML

Writing HTML is fine, but what if something goes wrong, and you can't work out where the error in the code is? This article will introduce you to some tools that can help you find and fix errors in HTML.

Test your skills: HTML

This page lists HTML tests you can try so you can verify if you've understood the content in this module.

Additional tutorialsThese tutorials are not part of the learning pathway, but they are interesting nonetheless — you should consider these as stretch goals, to optionally study when you are done with the main Core articles.

Including vector graphics in HTML

Vector graphics are very useful in many circumstances — they have small file sizes and are highly scalable, so they don't pixelate when zoomed in or blown up to a large size. In this article we'll show you how to include one in your webpage.

From object to iframe — general embedding technologies

Developers commonly think of embedding media such as images, video and audio into web pages. In this article we take somewhat of a sideways step, looking at some elements that allow you to embed a wide variety of content types into your webpages: the <iframe>, <embed> and <object> elements. <iframe>s are for embedding other web pages, and the other two allow you to embed external resources such as PDF files.

See also
Learn HTML and CSS, Scrimba MDN learning partner

Scrimba's Learn HTML and CSS course teaches you HTML and CSS through building and deploying five awesome projects, with fun interactive lessons and challenges taught by knowledgeable teachers.

Learn HTML, Codecademy

Another useful resource for learning HTML basics.

The basics of semantic HTML, Scrimba MDN learning partner

This interactive lesson provides a useful description of HTML, with particular emphasis on why the semantic aspect of it is important.


 Overview: Core learning modules Next\n\nStructuring content with HTML Overview: Core learning modules Next  
HTML is the technology that defines the content and structure of any website. Written properly, it should also define the semantics (meaning) of the content in a machine-readable way, which is vital for accessibility, search engine optimization, and making use of the built-in features browsers provide for content to work optimally. This module covers the basics of the language, before looking at key areas such as document structure, links, lists, images, forms, and more.PrerequisitesBefore starting this module, you don't need any previous HTML knowledge, but you should have at least basic familiarity with using computers and using the web passively (i.e., just looking at it and consuming content). You should have a basic work environment set up (as detailed in Installing basic software), and understand how to create and manage files (as detailed in Dealing with files). Both are parts of our Getting started with the web complete beginner's module.

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
Basic HTML syntax

Covers the absolute basics of HTML, to get you started — we define elements, attributes, and other important terms, and show where they fit in the language. We also show how a typical HTML page is structured and how an HTML element is structured, and explain other important basic language features. Along the way, we'll play with some HTML to get you interested!

What's in the head? Web page metadata

The head of an HTML document is the part that is not displayed in the web browser when the page is loaded. It contains metadata information such as the page <title>, links to CSS (if you want to style your HTML content with CSS), links to custom favicons, and metadata (data about the HTML, such as who wrote it, and important keywords that describe the document).

Headings and paragraphs

One of HTML's main jobs is to give text structure so that a browser can display an HTML document the way its developer intends. This article explains how HTML can be used to provide fundamental page structure by defining headings and paragraphs.

Emphasis and importance

The previous article looked at why semantics are important in HTML, and focused on headings and paragraphs. This article continues on the theme of semantics, looking at HTML elements that apply emphasis and importance to text (parallel to italics and bold text in print media).

Lists

Lists are everywhere in life—from your shopping list to the list of directions you subconsciously follow to get to your house every day, to the lists of instructions you are following in these tutorials! It may not surprise you that HTML has a convenient set of elements that allows us to define different types of list. On the web, we have three types of lists: unordered, ordered, and description lists. This lesson shows you how to use the different types.

Structuring documents

In addition to defining individual parts of your page (such as "a paragraph" or "an image"), HTML also boasts a number of block level elements used to define areas of your website (such as "the header", "the navigation menu", "the main content column"). This article looks into how to plan a basic website structure, and write the HTML to represent this structure.

Advanced text features

There are many other elements in HTML for defining text semantics, which we didn't get to in the Emphasis and importance article. The elements described in this article are less known, but still useful to know about (and this is still not a complete list by any means). Here you'll learn about marking up quotations, computer code and other related text, subscript and superscript, contact information, and more.

Creating links

Links (also known as hyperlinks) are really important — they are what makes the Web a web. This article shows the syntax required to make a link, and discusses link best practices.

Marking up a letter Challenge

We all learn to write a letter sooner or later; it is also a useful example to test our text formatting skills. In this challenge, you'll have a letter to mark up as a test for your HTML text formatting skills, as well as hyperlinks and proper use of the HTML <head> element.

Structuring a page of content Challenge

Structuring a page of content ready for laying it out using CSS is a very important skill to master, so in this challenge you'll be tested on your ability to think about how a page might end up looking, and choose appropriate structural semantics to build a layout on top of.

HTML images

In the beginning, the web was just text, and it was really quite boring. Fortunately, it wasn't too long before the ability to embed images (and other more interesting types of content) inside web pages was added. In this article we'll look at how to use the <img> element in depth, including the basics, annotating it with captions using <figure>, and detailing how it relates to CSS background images.

HTML video and audio

Now that we are comfortable with adding simple images to a webpage, the next step is to start adding video and audio players to your HTML documents! In this article we'll look at doing just that with the <video> and <audio> elements; we'll then finish off by looking at how to add captions/subtitles to your videos.

Mozilla splash page Challenge

In this challenge, we'll test your knowledge of some of the techniques discussed in the last couple of lessons, getting you to add some images and video to a funky splash page all about Mozilla!

HTML table basics

This article gets you started with HTML tables, covering the very basics such as rows, cells, headings, making cells span multiple columns and rows, and how to group together all the cells in a column for styling purposes.

HTML table accessibility

In this article we look at more HTML table accessibility features such as captions/summaries, grouping your rows into table head, body and footer sections, and scoping columns and rows.

Structuring a planet data table Challenge

In this challenge, we provide you with some data on the planets in our solar system. Your job is to structure it into an accessible HTML table.

Forms and buttons in HTML

HTML forms and buttons are powerful tools for interacting with users — most commonly they are used for collecting data from users or allowing them to control a user interface. In this article we provide an introduction to the basics of forms and buttons.

Debugging HTML

Writing HTML is fine, but what if something goes wrong, and you can't work out where the error in the code is? This article will introduce you to some tools that can help you find and fix errors in HTML.

Test your skills: HTML

This page lists HTML tests you can try so you can verify if you've understood the content in this module.

Additional tutorialsThese tutorials are not part of the learning pathway, but they are interesting nonetheless — you should consider these as stretch goals, to optionally study when you are done with the main Core articles.

Including vector graphics in HTML

Vector graphics are very useful in many circumstances — they have small file sizes and are highly scalable, so they don't pixelate when zoomed in or blown up to a large size. In this article we'll show you how to include one in your webpage.

From object to iframe — general embedding technologies

Developers commonly think of embedding media such as images, video and audio into web pages. In this article we take somewhat of a sideways step, looking at some elements that allow you to embed a wide variety of content types into your webpages: the <iframe>, <embed> and <object> elements. <iframe>s are for embedding other web pages, and the other two allow you to embed external resources such as PDF files.

See also
Learn HTML and CSS, Scrimba MDN learning partner

Scrimba's Learn HTML and CSS course teaches you HTML and CSS through building and deploying five awesome projects, with fun interactive lessons and challenges taught by knowledgeable teachers.

Learn HTML, Codecademy

Another useful resource for learning HTML basics.

The basics of semantic HTML, Scrimba MDN learning partner

This interactive lesson provides a useful description of HTML, with particular emphasis on why the semantic aspect of it is important.


 Overview: Core learning modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 18, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nStructuring content with HTML Overview: Core learning modules Next  
HTML is the technology that defines the content and structure of any website. Written properly, it should also define the semantics (meaning) of the content in a machine-readable way, which is vital for accessibility, search engine optimization, and making use of the built-in features browsers provide for content to work optimally. This module covers the basics of the language, before looking at key areas such as document structure, links, lists, images, forms, and more.PrerequisitesBefore starting this module, you don't need any previous HTML knowledge, but you should have at least basic familiarity with using computers and using the web passively (i.e., just looking at it and consuming content). You should have a basic work environment set up (as detailed in Installing basic software), and understand how to create and manage files (as detailed in Dealing with files). Both are parts of our Getting started with the web complete beginner's module.

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
Basic HTML syntax

Covers the absolute basics of HTML, to get you started — we define elements, attributes, and other important terms, and show where they fit in the language. We also show how a typical HTML page is structured and how an HTML element is structured, and explain other important basic language features. Along the way, we'll play with some HTML to get you interested!

What's in the head? Web page metadata

The head of an HTML document is the part that is not displayed in the web browser when the page is loaded. It contains metadata information such as the page <title>, links to CSS (if you want to style your HTML content with CSS), links to custom favicons, and metadata (data about the HTML, such as who wrote it, and important keywords that describe the document).

Headings and paragraphs

One of HTML's main jobs is to give text structure so that a browser can display an HTML document the way its developer intends. This article explains how HTML can be used to provide fundamental page structure by defining headings and paragraphs.

Emphasis and importance

The previous article looked at why semantics are important in HTML, and focused on headings and paragraphs. This article continues on the theme of semantics, looking at HTML elements that apply emphasis and importance to text (parallel to italics and bold text in print media).

Lists

Lists are everywhere in life—from your shopping list to the list of directions you subconsciously follow to get to your house every day, to the lists of instructions you are following in these tutorials! It may not surprise you that HTML has a convenient set of elements that allows us to define different types of list. On the web, we have three types of lists: unordered, ordered, and description lists. This lesson shows you how to use the different types.

Structuring documents

In addition to defining individual parts of your page (such as "a paragraph" or "an image"), HTML also boasts a number of block level elements used to define areas of your website (such as "the header", "the navigation menu", "the main content column"). This article looks into how to plan a basic website structure, and write the HTML to represent this structure.

Advanced text features

There are many other elements in HTML for defining text semantics, which we didn't get to in the Emphasis and importance article. The elements described in this article are less known, but still useful to know about (and this is still not a complete list by any means). Here you'll learn about marking up quotations, computer code and other related text, subscript and superscript, contact information, and more.

Creating links

Links (also known as hyperlinks) are really important — they are what makes the Web a web. This article shows the syntax required to make a link, and discusses link best practices.

Marking up a letter Challenge

We all learn to write a letter sooner or later; it is also a useful example to test our text formatting skills. In this challenge, you'll have a letter to mark up as a test for your HTML text formatting skills, as well as hyperlinks and proper use of the HTML <head> element.

Structuring a page of content Challenge

Structuring a page of content ready for laying it out using CSS is a very important skill to master, so in this challenge you'll be tested on your ability to think about how a page might end up looking, and choose appropriate structural semantics to build a layout on top of.

HTML images

In the beginning, the web was just text, and it was really quite boring. Fortunately, it wasn't too long before the ability to embed images (and other more interesting types of content) inside web pages was added. In this article we'll look at how to use the <img> element in depth, including the basics, annotating it with captions using <figure>, and detailing how it relates to CSS background images.

HTML video and audio

Now that we are comfortable with adding simple images to a webpage, the next step is to start adding video and audio players to your HTML documents! In this article we'll look at doing just that with the <video> and <audio> elements; we'll then finish off by looking at how to add captions/subtitles to your videos.

Mozilla splash page Challenge

In this challenge, we'll test your knowledge of some of the techniques discussed in the last couple of lessons, getting you to add some images and video to a funky splash page all about Mozilla!

HTML table basics

This article gets you started with HTML tables, covering the very basics such as rows, cells, headings, making cells span multiple columns and rows, and how to group together all the cells in a column for styling purposes.

HTML table accessibility

In this article we look at more HTML table accessibility features such as captions/summaries, grouping your rows into table head, body and footer sections, and scoping columns and rows.

Structuring a planet data table Challenge

In this challenge, we provide you with some data on the planets in our solar system. Your job is to structure it into an accessible HTML table.

Forms and buttons in HTML

HTML forms and buttons are powerful tools for interacting with users — most commonly they are used for collecting data from users or allowing them to control a user interface. In this article we provide an introduction to the basics of forms and buttons.

Debugging HTML

Writing HTML is fine, but what if something goes wrong, and you can't work out where the error in the code is? This article will introduce you to some tools that can help you find and fix errors in HTML.

Test your skills: HTML

This page lists HTML tests you can try so you can verify if you've understood the content in this module.

Additional tutorialsThese tutorials are not part of the learning pathway, but they are interesting nonetheless — you should consider these as stretch goals, to optionally study when you are done with the main Core articles.

Including vector graphics in HTML

Vector graphics are very useful in many circumstances — they have small file sizes and are highly scalable, so they don't pixelate when zoomed in or blown up to a large size. In this article we'll show you how to include one in your webpage.

From object to iframe — general embedding technologies

Developers commonly think of embedding media such as images, video and audio into web pages. In this article we take somewhat of a sideways step, looking at some elements that allow you to embed a wide variety of content types into your webpages: the <iframe>, <embed> and <object> elements. <iframe>s are for embedding other web pages, and the other two allow you to embed external resources such as PDF files.

See also
Learn HTML and CSS, Scrimba MDN learning partner

Scrimba's Learn HTML and CSS course teaches you HTML and CSS through building and deploying five awesome projects, with fun interactive lessons and challenges taught by knowledgeable teachers.

Learn HTML, Codecademy

Another useful resource for learning HTML basics.

The basics of semantic HTML, Scrimba MDN learning partner

This interactive lesson provides a useful description of HTML, with particular emphasis on why the semantic aspect of it is important.


 Overview: Core learning modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 18, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nCSS styling basics Overview: Core learning modules Next  
CSS (Cascading Style Sheets) is used to style and layout web pages — for example, to alter the font, color, size, and spacing of your content, split it into multiple columns, or add animations and other decorative features. This module provides all the CSS fundamentals you'll need for now, including syntax, features, and techniques.PrerequisitesBefore starting this module, you should have a basic work environment set up (as detailed in Installing basic software), and understand how to create and manage files (as detailed in Dealing with files). You should also be familiar with HTML (work through our Structuring content with HTML module if not).

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
What is CSS?

CSS allows you to create great-looking web pages, but how does it work under the hood? This article explains what CSS, what the basic syntax looks like, and how your browser applies CSS to HTML to style it.

Getting started with CSS

In this article, we will take a simple HTML document and apply CSS to it, learning some practical details of the language along the way. We will also review the CSS syntax features you've not looked at yet.

Styling a biography page Challenge

In this challenge you will style a simple bio page, testing you on some of the skills you learned in the last couple of lessons including writing selectors and text styling.

Basic CSS selectors

In this article we'll recap some selector fundamentals, including the basic type, class, and ID selectors.

Attribute selectors

As you know from your study of HTML, elements can have attributes that give further detail about the element being marked up. In CSS you can use attribute selectors to target elements with certain attributes. This lesson will show you how to use these very useful selectors.

Pseudo-classes and pseudo-elements

The next set of selectors we will look at are referred to as pseudo-classes and pseudo-elements. There are a large number of these, and they often serve quite specific purposes. Once you know how to use them, you can look through the different types to see if there is something which works for the task you are trying to achieve.

Combinators

The final selectors we will look at are called combinators. Combinators are used to combine other selectors in a way that allows us to select elements based on their location in the DOM relative to other elements (for example, child or sibling).

The box model

Everything in CSS has a box around it, and understanding these boxes is key to being able to create more complex layouts with CSS, or to align items with other items. In this lesson, we will take a look at the CSS Box model. You'll get an understanding of how it works and the terminology that relates to it.

Handling conflicts

The aim of this lesson is to develop your understanding of some of the most fundamental concepts of CSS — the cascade, specificity, and inheritance — which control how CSS is applied to HTML and how conflicts between style declarations are resolved.

Values and units

CSS rules contain declarations, which in turn are composed of properties and values. Each property used in CSS has a value type that describes what kind of values it is allowed to have. In this lesson, we will take a look at some of the most frequently used value types, what they are, and how they work.

Sizing items in CSS

Understanding how big the different features in your design will be is important. In this lesson we will summarize the various ways elements get a size via CSS and define a few terms about sizing that will help you in the future.

Backgrounds and borders

In this lesson, we will take a look at some of the creative things you can do with CSS backgrounds and borders. From adding gradients, background images, and rounded corners, backgrounds and borders are the answer to a lot of styling questions in CSS.

Overflowing content

Overflow is what happens when there is too much content to fit inside an element box. In this lesson, you will learn how to manage overflow using CSS.

Images, media, and form elements

In this lesson we will take a look at how certain special elements are treated in CSS. Images, other media, and form elements behave a little differently from regular boxes in terms of your ability to style them with CSS. Understanding what is and isn't possible can save some frustration, and this lesson will highlight some of the main things that you need to know.

Styling tables

Styling an HTML table isn't the most glamorous job in the world, but sometimes we all have to do it. This article explains how to make HTML tables look good, with some specific table styling techniques highlighted.

Debugging CSS

This article will give you guidance on how to go about debugging a CSS problem, and show you how the DevTools included in all modern browsers can help you to find out what is going on.

Challenge: Fundamental CSS comprehension Challenge

This challenge provides a number of related exercises that must be completed in order to create the final design — a business card/gamer card/social media profile.

Challenge: Creating fancy letterheaded paper Challenge

If you want to make the right impression, writing a letter on nice letterheaded paper can be a really good start. In this challenge you will create an online template to achieve such a look.

Challenge: A cool-looking box Challenge

In this challenge, you'll get some more practice in creating cool-looking boxes by trying to create an eye-catching box.

Additional tutorialsThese tutorials are not part of the learning pathway, but they are interesting nonetheless — you should consider these as stretch goals, to optionally study when you are done with the main Core articles.

Advanced styling effects

This article acts as a box of tricks, providing an introduction to some interesting advanced styling features such as box shadows, blend modes, and filters.

Cascade layers

This lesson aims to introduce you to cascade layers, a more advanced feature that builds on the fundamental concepts of the CSS cascade and CSS specificity.

Handling different text directions

In recent years, CSS has evolved in order to better support different directionality of content, including right-to-left but also top-to-bottom content (such as Japanese) — these different directionalities are called writing modes. As you progress in your study and begin to work with layout, an understanding of writing modes will be very helpful to you, therefore we will introduce them in this article.

Organizing CSS

As you start to work on larger stylesheets and big projects you will discover that maintaining a huge CSS file can be challenging. In this article we will take a brief look at some best practices for writing your CSS to make it easily maintainable, and some of the solutions you will find in use by others to help improve maintainability.

See also
Learn HTML and CSS, Scrimba MDN learning partner

Scrimba's Learn HTML and CSS course teaches you HTML and CSS through building and deploying five awesome projects, with fun interactive lessons and challenges taught by knowledgeable teachers.

Write your first lines of CSS!, Scrimba MDN learning partner

This interactive lesson provides a useful introduction to CSS syntax.


 Overview: Core learning modules Next\n\nCSS styling basics Overview: Core learning modules Next  
CSS (Cascading Style Sheets) is used to style and layout web pages — for example, to alter the font, color, size, and spacing of your content, split it into multiple columns, or add animations and other decorative features. This module provides all the CSS fundamentals you'll need for now, including syntax, features, and techniques.PrerequisitesBefore starting this module, you should have a basic work environment set up (as detailed in Installing basic software), and understand how to create and manage files (as detailed in Dealing with files). You should also be familiar with HTML (work through our Structuring content with HTML module if not).

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
What is CSS?

CSS allows you to create great-looking web pages, but how does it work under the hood? This article explains what CSS, what the basic syntax looks like, and how your browser applies CSS to HTML to style it.

Getting started with CSS

In this article, we will take a simple HTML document and apply CSS to it, learning some practical details of the language along the way. We will also review the CSS syntax features you've not looked at yet.

Styling a biography page Challenge

In this challenge you will style a simple bio page, testing you on some of the skills you learned in the last couple of lessons including writing selectors and text styling.

Basic CSS selectors

In this article we'll recap some selector fundamentals, including the basic type, class, and ID selectors.

Attribute selectors

As you know from your study of HTML, elements can have attributes that give further detail about the element being marked up. In CSS you can use attribute selectors to target elements with certain attributes. This lesson will show you how to use these very useful selectors.

Pseudo-classes and pseudo-elements

The next set of selectors we will look at are referred to as pseudo-classes and pseudo-elements. There are a large number of these, and they often serve quite specific purposes. Once you know how to use them, you can look through the different types to see if there is something which works for the task you are trying to achieve.

Combinators

The final selectors we will look at are called combinators. Combinators are used to combine other selectors in a way that allows us to select elements based on their location in the DOM relative to other elements (for example, child or sibling).

The box model

Everything in CSS has a box around it, and understanding these boxes is key to being able to create more complex layouts with CSS, or to align items with other items. In this lesson, we will take a look at the CSS Box model. You'll get an understanding of how it works and the terminology that relates to it.

Handling conflicts

The aim of this lesson is to develop your understanding of some of the most fundamental concepts of CSS — the cascade, specificity, and inheritance — which control how CSS is applied to HTML and how conflicts between style declarations are resolved.

Values and units

CSS rules contain declarations, which in turn are composed of properties and values. Each property used in CSS has a value type that describes what kind of values it is allowed to have. In this lesson, we will take a look at some of the most frequently used value types, what they are, and how they work.

Sizing items in CSS

Understanding how big the different features in your design will be is important. In this lesson we will summarize the various ways elements get a size via CSS and define a few terms about sizing that will help you in the future.

Backgrounds and borders

In this lesson, we will take a look at some of the creative things you can do with CSS backgrounds and borders. From adding gradients, background images, and rounded corners, backgrounds and borders are the answer to a lot of styling questions in CSS.

Overflowing content

Overflow is what happens when there is too much content to fit inside an element box. In this lesson, you will learn how to manage overflow using CSS.

Images, media, and form elements

In this lesson we will take a look at how certain special elements are treated in CSS. Images, other media, and form elements behave a little differently from regular boxes in terms of your ability to style them with CSS. Understanding what is and isn't possible can save some frustration, and this lesson will highlight some of the main things that you need to know.

Styling tables

Styling an HTML table isn't the most glamorous job in the world, but sometimes we all have to do it. This article explains how to make HTML tables look good, with some specific table styling techniques highlighted.

Debugging CSS

This article will give you guidance on how to go about debugging a CSS problem, and show you how the DevTools included in all modern browsers can help you to find out what is going on.

Challenge: Fundamental CSS comprehension Challenge

This challenge provides a number of related exercises that must be completed in order to create the final design — a business card/gamer card/social media profile.

Challenge: Creating fancy letterheaded paper Challenge

If you want to make the right impression, writing a letter on nice letterheaded paper can be a really good start. In this challenge you will create an online template to achieve such a look.

Challenge: A cool-looking box Challenge

In this challenge, you'll get some more practice in creating cool-looking boxes by trying to create an eye-catching box.

Additional tutorialsThese tutorials are not part of the learning pathway, but they are interesting nonetheless — you should consider these as stretch goals, to optionally study when you are done with the main Core articles.

Advanced styling effects

This article acts as a box of tricks, providing an introduction to some interesting advanced styling features such as box shadows, blend modes, and filters.

Cascade layers

This lesson aims to introduce you to cascade layers, a more advanced feature that builds on the fundamental concepts of the CSS cascade and CSS specificity.

Handling different text directions

In recent years, CSS has evolved in order to better support different directionality of content, including right-to-left but also top-to-bottom content (such as Japanese) — these different directionalities are called writing modes. As you progress in your study and begin to work with layout, an understanding of writing modes will be very helpful to you, therefore we will introduce them in this article.

Organizing CSS

As you start to work on larger stylesheets and big projects you will discover that maintaining a huge CSS file can be challenging. In this article we will take a brief look at some best practices for writing your CSS to make it easily maintainable, and some of the solutions you will find in use by others to help improve maintainability.

See also
Learn HTML and CSS, Scrimba MDN learning partner

Scrimba's Learn HTML and CSS course teaches you HTML and CSS through building and deploying five awesome projects, with fun interactive lessons and challenges taught by knowledgeable teachers.

Write your first lines of CSS!, Scrimba MDN learning partner

This interactive lesson provides a useful introduction to CSS syntax.


 Overview: Core learning modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 27, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nCSS styling basics Overview: Core learning modules Next  
CSS (Cascading Style Sheets) is used to style and layout web pages — for example, to alter the font, color, size, and spacing of your content, split it into multiple columns, or add animations and other decorative features. This module provides all the CSS fundamentals you'll need for now, including syntax, features, and techniques.PrerequisitesBefore starting this module, you should have a basic work environment set up (as detailed in Installing basic software), and understand how to create and manage files (as detailed in Dealing with files). You should also be familiar with HTML (work through our Structuring content with HTML module if not).

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
What is CSS?

CSS allows you to create great-looking web pages, but how does it work under the hood? This article explains what CSS, what the basic syntax looks like, and how your browser applies CSS to HTML to style it.

Getting started with CSS

In this article, we will take a simple HTML document and apply CSS to it, learning some practical details of the language along the way. We will also review the CSS syntax features you've not looked at yet.

Styling a biography page Challenge

In this challenge you will style a simple bio page, testing you on some of the skills you learned in the last couple of lessons including writing selectors and text styling.

Basic CSS selectors

In this article we'll recap some selector fundamentals, including the basic type, class, and ID selectors.

Attribute selectors

As you know from your study of HTML, elements can have attributes that give further detail about the element being marked up. In CSS you can use attribute selectors to target elements with certain attributes. This lesson will show you how to use these very useful selectors.

Pseudo-classes and pseudo-elements

The next set of selectors we will look at are referred to as pseudo-classes and pseudo-elements. There are a large number of these, and they often serve quite specific purposes. Once you know how to use them, you can look through the different types to see if there is something which works for the task you are trying to achieve.

Combinators

The final selectors we will look at are called combinators. Combinators are used to combine other selectors in a way that allows us to select elements based on their location in the DOM relative to other elements (for example, child or sibling).

The box model

Everything in CSS has a box around it, and understanding these boxes is key to being able to create more complex layouts with CSS, or to align items with other items. In this lesson, we will take a look at the CSS Box model. You'll get an understanding of how it works and the terminology that relates to it.

Handling conflicts

The aim of this lesson is to develop your understanding of some of the most fundamental concepts of CSS — the cascade, specificity, and inheritance — which control how CSS is applied to HTML and how conflicts between style declarations are resolved.

Values and units

CSS rules contain declarations, which in turn are composed of properties and values. Each property used in CSS has a value type that describes what kind of values it is allowed to have. In this lesson, we will take a look at some of the most frequently used value types, what they are, and how they work.

Sizing items in CSS

Understanding how big the different features in your design will be is important. In this lesson we will summarize the various ways elements get a size via CSS and define a few terms about sizing that will help you in the future.

Backgrounds and borders

In this lesson, we will take a look at some of the creative things you can do with CSS backgrounds and borders. From adding gradients, background images, and rounded corners, backgrounds and borders are the answer to a lot of styling questions in CSS.

Overflowing content

Overflow is what happens when there is too much content to fit inside an element box. In this lesson, you will learn how to manage overflow using CSS.

Images, media, and form elements

In this lesson we will take a look at how certain special elements are treated in CSS. Images, other media, and form elements behave a little differently from regular boxes in terms of your ability to style them with CSS. Understanding what is and isn't possible can save some frustration, and this lesson will highlight some of the main things that you need to know.

Styling tables

Styling an HTML table isn't the most glamorous job in the world, but sometimes we all have to do it. This article explains how to make HTML tables look good, with some specific table styling techniques highlighted.

Debugging CSS

This article will give you guidance on how to go about debugging a CSS problem, and show you how the DevTools included in all modern browsers can help you to find out what is going on.

Challenge: Fundamental CSS comprehension Challenge

This challenge provides a number of related exercises that must be completed in order to create the final design — a business card/gamer card/social media profile.

Challenge: Creating fancy letterheaded paper Challenge

If you want to make the right impression, writing a letter on nice letterheaded paper can be a really good start. In this challenge you will create an online template to achieve such a look.

Challenge: A cool-looking box Challenge

In this challenge, you'll get some more practice in creating cool-looking boxes by trying to create an eye-catching box.

Additional tutorialsThese tutorials are not part of the learning pathway, but they are interesting nonetheless — you should consider these as stretch goals, to optionally study when you are done with the main Core articles.

Advanced styling effects

This article acts as a box of tricks, providing an introduction to some interesting advanced styling features such as box shadows, blend modes, and filters.

Cascade layers

This lesson aims to introduce you to cascade layers, a more advanced feature that builds on the fundamental concepts of the CSS cascade and CSS specificity.

Handling different text directions

In recent years, CSS has evolved in order to better support different directionality of content, including right-to-left but also top-to-bottom content (such as Japanese) — these different directionalities are called writing modes. As you progress in your study and begin to work with layout, an understanding of writing modes will be very helpful to you, therefore we will introduce them in this article.

Organizing CSS

As you start to work on larger stylesheets and big projects you will discover that maintaining a huge CSS file can be challenging. In this article we will take a brief look at some best practices for writing your CSS to make it easily maintainable, and some of the solutions you will find in use by others to help improve maintainability.

See also
Learn HTML and CSS, Scrimba MDN learning partner

Scrimba's Learn HTML and CSS course teaches you HTML and CSS through building and deploying five awesome projects, with fun interactive lessons and challenges taught by knowledgeable teachers.

Write your first lines of CSS!, Scrimba MDN learning partner

This interactive lesson provides a useful introduction to CSS syntax.


 Overview: Core learning modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 27, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nDynamic scripting with JavaScript Overview: Core learning modules Next  
JavaScript is a huge topic, with so many different features, styles, and techniques to learn, and so many APIs and tools built on top of it. This module focuses mostly on the essentials of the core language, plus some key surrounding topics — learning these topics will give you a solid basis to work from.PrerequisitesBefore starting this module, you don't need any previous JavaScript knowledge, but you should have worked through the previous modules in the course. You should at least know HTML and the basic fundamentals of CSS.

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
What is JavaScript?

Welcome to the MDN beginner's JavaScript course! In this first article we will look at JavaScript from a high level, answering questions such as "what is it?", and "what is it doing?", and making sure you are comfortable with JavaScript's purpose.

A first splash into JavaScript

Now you've learned something about the theory of JavaScript, and what you can do with it, we are going to give you a crash course on the basic features of JavaScript via a completely practical tutorial. Here you'll build up a simple "Guess the number" game, step by step.

What went wrong? Troubleshooting JavaScript

When you built up the "Guess the number" game in the previous article, you may have found that it didn't work. Never fear — this article aims to save you from tearing your hair out over such problems by providing you with some simple tips on how to find and fix errors in JavaScript programs.

Storing the information you need — Variables

After reading the last couple of articles you should now know what JavaScript is, what it can do for you, how you use it alongside other web technologies, and what its main features look like from a high level. In this article, we will get down to the real basics, looking at how to work with the most basic building blocks of JavaScript — Variables.

Basic math in JavaScript — numbers and operators

At this point in the course, we discuss maths in JavaScript — how we can combine operators and other features to successfully manipulate numbers to do our bidding.

Handling text — strings in JavaScript

Next, we'll turn our attention to strings — this is what pieces of text are called in programming. In this article, we'll look at all the common things that you really ought to know about strings when learning JavaScript, such as creating strings, escaping quotes in strings, and joining them together.

Useful string methods

Now we've looked at the very basics of strings, let's move up a gear and start thinking about what useful operations we can do on strings with built-in methods, such as finding the length of a text string, joining and splitting strings, substituting one character in a string for another, and more.

Arrays

In this lesson we'll look at arrays — a neat way of storing a list of data items under a single variable name. Here we look at why this is useful, then explore how to create an array, retrieve, add, and remove items stored in an array, and more besides.

Challenge: Silly story generator Challenge

In this challenge, you'll be tasked with taking some of the knowledge you've picked up in this module's articles and applying it to creating a fun app that generates random silly stories. Have fun!

Making decisions in your code — conditionals

In any programming language, the code needs to make decisions and carry out actions accordingly depending on different inputs. For example, in a game, if the player's number of lives is 0, then it's game over. In a weather app, if it is being looked at in the morning, show a sunrise graphic; show stars and a moon if it is nighttime. In this article, we'll explore how so-called conditional statements work in JavaScript.

Looping code

Programming languages are very useful for rapidly completing repetitive tasks, from multiple basic calculations to just about any other situation where you've got a lot of similar items of work to complete. Here we'll look at the loop structures available in JavaScript that handle such needs.

Functions — reusable blocks of code

Another essential concept in coding is functions, which allow you to store a piece of code that does a single task inside a defined block, and then call that code whenever you need it using a single short command — rather than having to type out the same code multiple times. In this article we'll explore fundamental concepts behind functions such as basic syntax, how to invoke and define them, scope, and parameters.

Build your own function

With most of the essential theory dealt with in the previous article, this article provides practical experience. Here you will get some practice building your own, custom function. Along the way, we'll also explain some useful details of dealing with functions.

Function return values

There's one last essential concept about functions for us to discuss — return values. Some functions don't return a significant value, but others do. It's important to understand what their values are, how to use them in your code, and how to make functions return useful values. We'll cover all of these below.

Introduction to events

In this article, we discuss some important concepts surrounding events, and look at the fundamentals of how they work in browsers.

Event bubbling

This article introduces the concepts of event bubbling, event capture, and event delegation, which are all about what happens when you add a listener to an element that contains another element, and an event then happens to the contained element.

Challenge: Image gallery Challenge

Now that we've looked at the fundamental building blocks of JavaScript, we'll test your knowledge of loops, functions, conditionals and events by getting you to build a fairly common item you'll see on a lot of websites — a JavaScript-powered image gallery.

Object basics

In this article, we'll look at fundamental JavaScript object syntax, and revisit some JavaScript features that we've already seen earlier in the course, reiterating the fact that many of the features you've already dealt with are objects.

DOM scripting introduction

When writing web pages and apps, one of the most common things you'll want to do is change the document structure in some way. This is usually done by manipulating the Document Object Model (DOM) via a set of built-in browser APIs for controlling HTML and styling information. In this article we'll introduce you to DOM scripting.

Making network requests with JavaScript

Another very common task in modern websites and applications is making network requests to retrieve individual data items from the server to update sections of a webpage without having to load an entire new page. This seemingly small detail has had a huge impact on the performance and behavior of sites, so in this article, we'll explain the concept and look at technologies that make it possible.

Working with JSON

JavaScript Object Notation (JSON) is a standard text-based format for representing structured data based on JavaScript object syntax. It is commonly used for transmitting data in web applications (e.g., sending some data from the server to the client, so it can be displayed on a web page, or vice versa). You'll come across it quite often, so in this article, we give you all you need to work with JSON using JavaScript, including parsing JSON so you can access data within it, and creating JSON.

JavaScript debugging and error handling

In this lesson, we will return to the subject of debugging JavaScript (which we first looked at in What went wrong?). Here we will delve deeper into techniques for tracking down errors, but also look at how to code defensively and handle errors in your code, avoiding problems in the first place.

Test your skills: JavaScript

This page lists JavaScript tests you can try so you can verify if you've understood the content in this module.

See also
Scrimba: Learn JavaScript MDN learning partner

Scrimba's Learn JavaScript course teaches you JavaScript through solving 140+ interactive coding challenges, building projects including a game, a browser extension, and even a mobile app. Scrimba features fun interactive lessons taught by knowledgeable teachers.

Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.


 Overview: Core learning modules Next\n\nDynamic scripting with JavaScript Overview: Core learning modules Next  
JavaScript is a huge topic, with so many different features, styles, and techniques to learn, and so many APIs and tools built on top of it. This module focuses mostly on the essentials of the core language, plus some key surrounding topics — learning these topics will give you a solid basis to work from.PrerequisitesBefore starting this module, you don't need any previous JavaScript knowledge, but you should have worked through the previous modules in the course. You should at least know HTML and the basic fundamentals of CSS.

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
What is JavaScript?

Welcome to the MDN beginner's JavaScript course! In this first article we will look at JavaScript from a high level, answering questions such as "what is it?", and "what is it doing?", and making sure you are comfortable with JavaScript's purpose.

A first splash into JavaScript

Now you've learned something about the theory of JavaScript, and what you can do with it, we are going to give you a crash course on the basic features of JavaScript via a completely practical tutorial. Here you'll build up a simple "Guess the number" game, step by step.

What went wrong? Troubleshooting JavaScript

When you built up the "Guess the number" game in the previous article, you may have found that it didn't work. Never fear — this article aims to save you from tearing your hair out over such problems by providing you with some simple tips on how to find and fix errors in JavaScript programs.

Storing the information you need — Variables

After reading the last couple of articles you should now know what JavaScript is, what it can do for you, how you use it alongside other web technologies, and what its main features look like from a high level. In this article, we will get down to the real basics, looking at how to work with the most basic building blocks of JavaScript — Variables.

Basic math in JavaScript — numbers and operators

At this point in the course, we discuss maths in JavaScript — how we can combine operators and other features to successfully manipulate numbers to do our bidding.

Handling text — strings in JavaScript

Next, we'll turn our attention to strings — this is what pieces of text are called in programming. In this article, we'll look at all the common things that you really ought to know about strings when learning JavaScript, such as creating strings, escaping quotes in strings, and joining them together.

Useful string methods

Now we've looked at the very basics of strings, let's move up a gear and start thinking about what useful operations we can do on strings with built-in methods, such as finding the length of a text string, joining and splitting strings, substituting one character in a string for another, and more.

Arrays

In this lesson we'll look at arrays — a neat way of storing a list of data items under a single variable name. Here we look at why this is useful, then explore how to create an array, retrieve, add, and remove items stored in an array, and more besides.

Challenge: Silly story generator Challenge

In this challenge, you'll be tasked with taking some of the knowledge you've picked up in this module's articles and applying it to creating a fun app that generates random silly stories. Have fun!

Making decisions in your code — conditionals

In any programming language, the code needs to make decisions and carry out actions accordingly depending on different inputs. For example, in a game, if the player's number of lives is 0, then it's game over. In a weather app, if it is being looked at in the morning, show a sunrise graphic; show stars and a moon if it is nighttime. In this article, we'll explore how so-called conditional statements work in JavaScript.

Looping code

Programming languages are very useful for rapidly completing repetitive tasks, from multiple basic calculations to just about any other situation where you've got a lot of similar items of work to complete. Here we'll look at the loop structures available in JavaScript that handle such needs.

Functions — reusable blocks of code

Another essential concept in coding is functions, which allow you to store a piece of code that does a single task inside a defined block, and then call that code whenever you need it using a single short command — rather than having to type out the same code multiple times. In this article we'll explore fundamental concepts behind functions such as basic syntax, how to invoke and define them, scope, and parameters.

Build your own function

With most of the essential theory dealt with in the previous article, this article provides practical experience. Here you will get some practice building your own, custom function. Along the way, we'll also explain some useful details of dealing with functions.

Function return values

There's one last essential concept about functions for us to discuss — return values. Some functions don't return a significant value, but others do. It's important to understand what their values are, how to use them in your code, and how to make functions return useful values. We'll cover all of these below.

Introduction to events

In this article, we discuss some important concepts surrounding events, and look at the fundamentals of how they work in browsers.

Event bubbling

This article introduces the concepts of event bubbling, event capture, and event delegation, which are all about what happens when you add a listener to an element that contains another element, and an event then happens to the contained element.

Challenge: Image gallery Challenge

Now that we've looked at the fundamental building blocks of JavaScript, we'll test your knowledge of loops, functions, conditionals and events by getting you to build a fairly common item you'll see on a lot of websites — a JavaScript-powered image gallery.

Object basics

In this article, we'll look at fundamental JavaScript object syntax, and revisit some JavaScript features that we've already seen earlier in the course, reiterating the fact that many of the features you've already dealt with are objects.

DOM scripting introduction

When writing web pages and apps, one of the most common things you'll want to do is change the document structure in some way. This is usually done by manipulating the Document Object Model (DOM) via a set of built-in browser APIs for controlling HTML and styling information. In this article we'll introduce you to DOM scripting.

Making network requests with JavaScript

Another very common task in modern websites and applications is making network requests to retrieve individual data items from the server to update sections of a webpage without having to load an entire new page. This seemingly small detail has had a huge impact on the performance and behavior of sites, so in this article, we'll explain the concept and look at technologies that make it possible.

Working with JSON

JavaScript Object Notation (JSON) is a standard text-based format for representing structured data based on JavaScript object syntax. It is commonly used for transmitting data in web applications (e.g., sending some data from the server to the client, so it can be displayed on a web page, or vice versa). You'll come across it quite often, so in this article, we give you all you need to work with JSON using JavaScript, including parsing JSON so you can access data within it, and creating JSON.

JavaScript debugging and error handling

In this lesson, we will return to the subject of debugging JavaScript (which we first looked at in What went wrong?). Here we will delve deeper into techniques for tracking down errors, but also look at how to code defensively and handle errors in your code, avoiding problems in the first place.

Test your skills: JavaScript

This page lists JavaScript tests you can try so you can verify if you've understood the content in this module.

See also
Scrimba: Learn JavaScript MDN learning partner

Scrimba's Learn JavaScript course teaches you JavaScript through solving 140+ interactive coding challenges, building projects including a game, a browser extension, and even a mobile app. Scrimba features fun interactive lessons taught by knowledgeable teachers.

Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.


 Overview: Core learning modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 15, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nDynamic scripting with JavaScript Overview: Core learning modules Next  
JavaScript is a huge topic, with so many different features, styles, and techniques to learn, and so many APIs and tools built on top of it. This module focuses mostly on the essentials of the core language, plus some key surrounding topics — learning these topics will give you a solid basis to work from.PrerequisitesBefore starting this module, you don't need any previous JavaScript knowledge, but you should have worked through the previous modules in the course. You should at least know HTML and the basic fundamentals of CSS.

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
What is JavaScript?

Welcome to the MDN beginner's JavaScript course! In this first article we will look at JavaScript from a high level, answering questions such as "what is it?", and "what is it doing?", and making sure you are comfortable with JavaScript's purpose.

A first splash into JavaScript

Now you've learned something about the theory of JavaScript, and what you can do with it, we are going to give you a crash course on the basic features of JavaScript via a completely practical tutorial. Here you'll build up a simple "Guess the number" game, step by step.

What went wrong? Troubleshooting JavaScript

When you built up the "Guess the number" game in the previous article, you may have found that it didn't work. Never fear — this article aims to save you from tearing your hair out over such problems by providing you with some simple tips on how to find and fix errors in JavaScript programs.

Storing the information you need — Variables

After reading the last couple of articles you should now know what JavaScript is, what it can do for you, how you use it alongside other web technologies, and what its main features look like from a high level. In this article, we will get down to the real basics, looking at how to work with the most basic building blocks of JavaScript — Variables.

Basic math in JavaScript — numbers and operators

At this point in the course, we discuss maths in JavaScript — how we can combine operators and other features to successfully manipulate numbers to do our bidding.

Handling text — strings in JavaScript

Next, we'll turn our attention to strings — this is what pieces of text are called in programming. In this article, we'll look at all the common things that you really ought to know about strings when learning JavaScript, such as creating strings, escaping quotes in strings, and joining them together.

Useful string methods

Now we've looked at the very basics of strings, let's move up a gear and start thinking about what useful operations we can do on strings with built-in methods, such as finding the length of a text string, joining and splitting strings, substituting one character in a string for another, and more.

Arrays

In this lesson we'll look at arrays — a neat way of storing a list of data items under a single variable name. Here we look at why this is useful, then explore how to create an array, retrieve, add, and remove items stored in an array, and more besides.

Challenge: Silly story generator Challenge

In this challenge, you'll be tasked with taking some of the knowledge you've picked up in this module's articles and applying it to creating a fun app that generates random silly stories. Have fun!

Making decisions in your code — conditionals

In any programming language, the code needs to make decisions and carry out actions accordingly depending on different inputs. For example, in a game, if the player's number of lives is 0, then it's game over. In a weather app, if it is being looked at in the morning, show a sunrise graphic; show stars and a moon if it is nighttime. In this article, we'll explore how so-called conditional statements work in JavaScript.

Looping code

Programming languages are very useful for rapidly completing repetitive tasks, from multiple basic calculations to just about any other situation where you've got a lot of similar items of work to complete. Here we'll look at the loop structures available in JavaScript that handle such needs.

Functions — reusable blocks of code

Another essential concept in coding is functions, which allow you to store a piece of code that does a single task inside a defined block, and then call that code whenever you need it using a single short command — rather than having to type out the same code multiple times. In this article we'll explore fundamental concepts behind functions such as basic syntax, how to invoke and define them, scope, and parameters.

Build your own function

With most of the essential theory dealt with in the previous article, this article provides practical experience. Here you will get some practice building your own, custom function. Along the way, we'll also explain some useful details of dealing with functions.

Function return values

There's one last essential concept about functions for us to discuss — return values. Some functions don't return a significant value, but others do. It's important to understand what their values are, how to use them in your code, and how to make functions return useful values. We'll cover all of these below.

Introduction to events

In this article, we discuss some important concepts surrounding events, and look at the fundamentals of how they work in browsers.

Event bubbling

This article introduces the concepts of event bubbling, event capture, and event delegation, which are all about what happens when you add a listener to an element that contains another element, and an event then happens to the contained element.

Challenge: Image gallery Challenge

Now that we've looked at the fundamental building blocks of JavaScript, we'll test your knowledge of loops, functions, conditionals and events by getting you to build a fairly common item you'll see on a lot of websites — a JavaScript-powered image gallery.

Object basics

In this article, we'll look at fundamental JavaScript object syntax, and revisit some JavaScript features that we've already seen earlier in the course, reiterating the fact that many of the features you've already dealt with are objects.

DOM scripting introduction

When writing web pages and apps, one of the most common things you'll want to do is change the document structure in some way. This is usually done by manipulating the Document Object Model (DOM) via a set of built-in browser APIs for controlling HTML and styling information. In this article we'll introduce you to DOM scripting.

Making network requests with JavaScript

Another very common task in modern websites and applications is making network requests to retrieve individual data items from the server to update sections of a webpage without having to load an entire new page. This seemingly small detail has had a huge impact on the performance and behavior of sites, so in this article, we'll explain the concept and look at technologies that make it possible.

Working with JSON

JavaScript Object Notation (JSON) is a standard text-based format for representing structured data based on JavaScript object syntax. It is commonly used for transmitting data in web applications (e.g., sending some data from the server to the client, so it can be displayed on a web page, or vice versa). You'll come across it quite often, so in this article, we give you all you need to work with JSON using JavaScript, including parsing JSON so you can access data within it, and creating JSON.

JavaScript debugging and error handling

In this lesson, we will return to the subject of debugging JavaScript (which we first looked at in What went wrong?). Here we will delve deeper into techniques for tracking down errors, but also look at how to code defensively and handle errors in your code, avoiding problems in the first place.

Test your skills: JavaScript

This page lists JavaScript tests you can try so you can verify if you've understood the content in this module.

See also
Scrimba: Learn JavaScript MDN learning partner

Scrimba's Learn JavaScript course teaches you JavaScript through solving 140+ interactive coding challenges, building projects including a game, a browser extension, and even a mobile app. Scrimba features fun interactive lessons taught by knowledgeable teachers.

Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.


 Overview: Core learning modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 15, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nAccessibility on the web Overview: Core learning modules Next  
Access to web content such as public services, education, e-commerce sites, and entertainment is a human right. No one should be excluded based on disability, race, geography, or other human characteristics. This module discusses the best practices and techniques you should learn to make your websites as accessible as possible.PrerequisitesYou should be familiar with HTML, CSS, and JavaScript before starting this module.

Note:
If you are working on a computer/tablet/other devices where you don't have the ability to create your own files, you can try out most of the code examples in an online coding program such as JS Bin or Glitch.
Tutorials and challenges
What is accessibility?

This article starts off the module with a good look at what accessibility is — this includes what groups of people we need to consider and why, what tools different people use to interact with the web, and how we can make accessibility part of our web development workflow.

Accessibility tooling and assistive technology

Next we turn our attention to accessibility tooling, providing information on the kinds of tools you can use to help solve accessibility issues, and the assistive technologies used by people with disabilities as they browse the web. You'll be using these tools throughout subsequent articles.

HTML: A good basis for accessibility

A great deal of web content can be made accessible just by making sure the correct HTML elements are always used for the correct purpose. This article looks in detail at how HTML can be used to ensure maximum accessibility.

CSS and JavaScript accessibility best practices

CSS and JavaScript, when used properly, also have the potential to allow for accessible web experiences, but if misused they can significantly harm accessibility. This article outlines some CSS and JavaScript best practices that should be considered to ensure that even complex content is as accessible as possible.

WAI-ARIA basics

Following on from the previous article, sometimes making complex UI controls that involve unsemantic HTML and dynamic JavaScript-updated content can be difficult. WAI-ARIA is a technology that can help with such problems by adding in further semantics that browsers and assistive technologies can recognize and use to let users know what is going on. Here we'll show how to use it at a basic level to improve accessibility.

Accessible multimedia

Another category of content that can create accessibility problems is multimedia — video, audio, and image content need to be given proper textual alternatives, so they can be understood by assistive technologies and their users. This article shows how.

Mobile accessibility

With web access on mobile devices being so popular, and popular platforms such as iOS and Android having fully-fledged accessibility tools, it is important to consider the accessibility of your web content on these platforms. This article looks at mobile-specific accessibility considerations.

Accessibility troubleshooting Challenge

In this challenge, we present to you a simple site with several accessibility issues that you need to diagnose and fix.

See also
Start Building Accessible Web Applications Today

An excellent series of video tutorials by Marcy Sutton.

Deque University resources

Includes code examples, screen reader references, and other useful resources.

WebAIM resources

Includes guides, checklists, tools, and more.

Web Accessibility Evaluation Tools List

Includes a list of web accessibility evaluation tools.

Learn Accessible Web Design MDN learning partner

Scrimba's Learn Accessible Web Design course teaches you how to write accessible HTML by solving interactive coding challenges and fixing a real-world website.


 Overview: Core learning modules Next\n\nAccessibility on the web Overview: Core learning modules Next  
Access to web content such as public services, education, e-commerce sites, and entertainment is a human right. No one should be excluded based on disability, race, geography, or other human characteristics. This module discusses the best practices and techniques you should learn to make your websites as accessible as possible.PrerequisitesYou should be familiar with HTML, CSS, and JavaScript before starting this module.

Note:
If you are working on a computer/tablet/other devices where you don't have the ability to create your own files, you can try out most of the code examples in an online coding program such as JS Bin or Glitch.
Tutorials and challenges
What is accessibility?

This article starts off the module with a good look at what accessibility is — this includes what groups of people we need to consider and why, what tools different people use to interact with the web, and how we can make accessibility part of our web development workflow.

Accessibility tooling and assistive technology

Next we turn our attention to accessibility tooling, providing information on the kinds of tools you can use to help solve accessibility issues, and the assistive technologies used by people with disabilities as they browse the web. You'll be using these tools throughout subsequent articles.

HTML: A good basis for accessibility

A great deal of web content can be made accessible just by making sure the correct HTML elements are always used for the correct purpose. This article looks in detail at how HTML can be used to ensure maximum accessibility.

CSS and JavaScript accessibility best practices

CSS and JavaScript, when used properly, also have the potential to allow for accessible web experiences, but if misused they can significantly harm accessibility. This article outlines some CSS and JavaScript best practices that should be considered to ensure that even complex content is as accessible as possible.

WAI-ARIA basics

Following on from the previous article, sometimes making complex UI controls that involve unsemantic HTML and dynamic JavaScript-updated content can be difficult. WAI-ARIA is a technology that can help with such problems by adding in further semantics that browsers and assistive technologies can recognize and use to let users know what is going on. Here we'll show how to use it at a basic level to improve accessibility.

Accessible multimedia

Another category of content that can create accessibility problems is multimedia — video, audio, and image content need to be given proper textual alternatives, so they can be understood by assistive technologies and their users. This article shows how.

Mobile accessibility

With web access on mobile devices being so popular, and popular platforms such as iOS and Android having fully-fledged accessibility tools, it is important to consider the accessibility of your web content on these platforms. This article looks at mobile-specific accessibility considerations.

Accessibility troubleshooting Challenge

In this challenge, we present to you a simple site with several accessibility issues that you need to diagnose and fix.

See also
Start Building Accessible Web Applications Today

An excellent series of video tutorials by Marcy Sutton.

Deque University resources

Includes code examples, screen reader references, and other useful resources.

WebAIM resources

Includes guides, checklists, tools, and more.

Web Accessibility Evaluation Tools List

Includes a list of web accessibility evaluation tools.

Learn Accessible Web Design MDN learning partner

Scrimba's Learn Accessible Web Design course teaches you how to write accessible HTML by solving interactive coding challenges and fixing a real-world website.


 Overview: Core learning modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 15, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nAccessibility on the web Overview: Core learning modules Next  
Access to web content such as public services, education, e-commerce sites, and entertainment is a human right. No one should be excluded based on disability, race, geography, or other human characteristics. This module discusses the best practices and techniques you should learn to make your websites as accessible as possible.PrerequisitesYou should be familiar with HTML, CSS, and JavaScript before starting this module.

Note:
If you are working on a computer/tablet/other devices where you don't have the ability to create your own files, you can try out most of the code examples in an online coding program such as JS Bin or Glitch.
Tutorials and challenges
What is accessibility?

This article starts off the module with a good look at what accessibility is — this includes what groups of people we need to consider and why, what tools different people use to interact with the web, and how we can make accessibility part of our web development workflow.

Accessibility tooling and assistive technology

Next we turn our attention to accessibility tooling, providing information on the kinds of tools you can use to help solve accessibility issues, and the assistive technologies used by people with disabilities as they browse the web. You'll be using these tools throughout subsequent articles.

HTML: A good basis for accessibility

A great deal of web content can be made accessible just by making sure the correct HTML elements are always used for the correct purpose. This article looks in detail at how HTML can be used to ensure maximum accessibility.

CSS and JavaScript accessibility best practices

CSS and JavaScript, when used properly, also have the potential to allow for accessible web experiences, but if misused they can significantly harm accessibility. This article outlines some CSS and JavaScript best practices that should be considered to ensure that even complex content is as accessible as possible.

WAI-ARIA basics

Following on from the previous article, sometimes making complex UI controls that involve unsemantic HTML and dynamic JavaScript-updated content can be difficult. WAI-ARIA is a technology that can help with such problems by adding in further semantics that browsers and assistive technologies can recognize and use to let users know what is going on. Here we'll show how to use it at a basic level to improve accessibility.

Accessible multimedia

Another category of content that can create accessibility problems is multimedia — video, audio, and image content need to be given proper textual alternatives, so they can be understood by assistive technologies and their users. This article shows how.

Mobile accessibility

With web access on mobile devices being so popular, and popular platforms such as iOS and Android having fully-fledged accessibility tools, it is important to consider the accessibility of your web content on these platforms. This article looks at mobile-specific accessibility considerations.

Accessibility troubleshooting Challenge

In this challenge, we present to you a simple site with several accessibility issues that you need to diagnose and fix.

See also
Start Building Accessible Web Applications Today

An excellent series of video tutorials by Marcy Sutton.

Deque University resources

Includes code examples, screen reader references, and other useful resources.

WebAIM resources

Includes guides, checklists, tools, and more.

Web Accessibility Evaluation Tools List

Includes a list of web accessibility evaluation tools.

Learn Accessible Web Design MDN learning partner

Scrimba's Learn Accessible Web Design course teaches you how to write accessible HTML by solving interactive coding challenges and fixing a real-world website.


 Overview: Core learning modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 15, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nMore MDN. Your MDN.Support MDN and make it your own.Get startedWhat's includedGo ads freeEnjoy MDN ads-free with an MDN Plus subscription.Support MDN and enjoy a focused, ad-free experience alongside other features such as curated collections, custom web platform updates, offline access, and more. Subscribers to paid tiers of MDN Plus have the option to browse MDN without ads.Learn more →AI HelpGet real-time assistance and support.No need to scroll through page after page to find your answers. Introducing an AI assistant that can answer all your web development questions in real time. Powered by OpenAI GPT-4o and GPT-4o mini.Learn more →PlaygroundWrite,Test and Share your code.Your playground to learn and share your amazing work with the world. By simply logging in, you can now spread your creativity far and wide.Learn more →UpdatesCompatibility changes at a glance.Filter and sort updates that matter most to build your projectThe Web doesn't have a changelog, but MDN can help. You can personalize and filter compatibility changes based on browsers or the tech category you are interested in whether that is JavaScript, CSS, etc.Learn more →CollectionsBuild your perfect library. Or let us build it for you.No more haphazard hunting through the vast virtual library: unleash your inner curator and collect your favorite articles in one place for convenient consultation.Learn more →Loading available plans…* Do you need MDN Plus for your company? Let us know and we’ll get back to you when it becomes available.\n\nMore MDN. Your MDN.Support MDN and make it your own.Get startedWhat's includedGo ads freeEnjoy MDN ads-free with an MDN Plus subscription.Support MDN and enjoy a focused, ad-free experience alongside other features such as curated collections, custom web platform updates, offline access, and more. Subscribers to paid tiers of MDN Plus have the option to browse MDN without ads.Learn more →AI HelpGet real-time assistance and support.No need to scroll through page after page to find your answers. Introducing an AI assistant that can answer all your web development questions in real time. Powered by OpenAI GPT-4o and GPT-4o mini.Learn more →PlaygroundWrite,Test and Share your code.Your playground to learn and share your amazing work with the world. By simply logging in, you can now spread your creativity far and wide.Learn more →UpdatesCompatibility changes at a glance.Filter and sort updates that matter most to build your projectThe Web doesn't have a changelog, but MDN can help. You can personalize and filter compatibility changes based on browsers or the tech category you are interested in whether that is JavaScript, CSS, etc.Learn more →CollectionsBuild your perfect library. Or let us build it for you.No more haphazard hunting through the vast virtual library: unleash your inner curator and collect your favorite articles in one place for convenient consultation.Learn more →Loading available plans…* Do you need MDN Plus for your company? Let us know and we’ll get back to you when it becomes available.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOverview

More MDN. Your MDN. Get started.
This page is an overview of the MDN Plus documentation and related resources.

MDN Plus is a premium subscription service launched by Mozilla. The service
allows users to customize their MDN Web Docs experience through premium features
such as Collections, filtering Updates and MDN Offline.
Learn more about MDN Plus on our website or in this
blogpost.\n\nOverview

More MDN. Your MDN. Get started.
This page is an overview of the MDN Plus documentation and related resources.

MDN Plus is a premium subscription service launched by Mozilla. The service
allows users to customize their MDN Web Docs experience through premium features
such as Collections, filtering Updates and MDN Offline.
Learn more about MDN Plus on our website or in this
blogpost.\n\nOverview

More MDN. Your MDN. Get started.
This page is an overview of the MDN Plus documentation and related resources.

MDN Plus is a premium subscription service launched by Mozilla. The service
allows users to customize their MDN Web Docs experience through premium features
such as Collections, filtering Updates and MDN Offline.
Learn more about MDN Plus on our website or in this
blogpost.\n\n\n\nFrequently asked questionsWhat is MDN Plus?MDN Plus is a premium subscription service launched in March 2022 by Mozilla.
The service allows users to customize their MDN Web Docs experience through
premium features such as Updates,
Collections and
MDN Offline.Why are we working on premium features on MDN?The extensive research we have done in 2020 and 2021 showed us that MDN users
would appreciate a customized experience on MDN. We’ve got information on what
you would find useful and what you would be interested in. All the premium
features we propose today reflect that feedback. MDN Plus is an initial step
towards making the experience on the site more interactive and helpful for our
users.How much does MDN Plus cost?A three-tiered pricing model has been put in place in order to try and
accommodate our users’ needs as much as possible:

MDN Core - A free plan, for those ones who want to try out a limited version
of the premium features.
MDN Plus 5 - A $5/month or $50/year plan that offers unlimited access to the
premium features included in MDN Plus.
MDN Supporter 10 - A $10/month or $100/year plan for users who want to
support MDN with a higher amount. On top of the MDN Plus premium features, MDN
supporters will be able to contribute and shape the product moving forward, by
having early access to premium features and a direct feedback channel with the
MDN team.

Subscribing for a yearly plan activates a 20% discount for all the paid options.Can I upgrade/downgrade my plan?Currently, you can only upgrade your plan. For getting a downgrade, please
cancel your current subscription first and then activate the new one.What is happening with the existing MDN Web Docs?Nothing. We will continue to develop & maintain our web documentation that will
remain free and accessible for everyone. There will be no change there. Even
more, we believe that MDN Web Docs will benefit from MDN Plus, as we plan to
reinvest part of the gains from MDN Plus and improve our documentation as well
as the overall user experience on the website.Are we violating any OS license obligation by adding a paid product to MDN?MDN content is made available under a CC BY-SA 2.5 license. That license doesn't
preclude Mozilla (or other users of MDN content) from having a paid product. MDN
Plus adds premium features like updates and collections on top of the free
content. Regular users can still access and reuse MDN content under the Creative
Commons license.Where will the money from MDN Plus go?Since its beginning in 2005, MDN Web Docs has been a project hosted and provided
by Mozilla. Mozilla covers the cost of infrastructure, development and
maintenance of the MDN platform, including a team of engineers and its own team
of dedicated writers.
Mozilla wants MDN Plus to help ensure that MDN's open source content continues
to be supported into the future. MDN Plus has been built only with Mozilla
resources, and any revenue generated by MDN Plus will stay within Mozilla. We
are looking into ways to reinvest some of these additional funds into open
source projects contributing to MDN but it is still in the early stages.Does the launch of MDN Plus impact the relationship with partners like OWD?The existence of a new subscription model will not detract from MDN's current
free Web Docs offering in any way. The current experience of accessing web
documentation will not change for users who do not wish to sign up for a premium
subscription. Open Web Docs (OWD) and Mozilla will continue to work closely
together on MDN for the best possible web platform documentation for everyone.
For more information about how our organizations work together, please check
this article.What regions is MDN Plus available in?The free version of MDN Plus is available worldwide. Anyone can create an MDN
Plus account and try out a limited version of the premium features. As for the
paid plans, they are currently available as follows: in the United States,
Canada (since March 24th, 2022), Austria, Belgium, Finland, France, the United
Kingdom, Germany, Ireland, Italy, Malaysia, the Netherlands, New Zealand, Puerto
Rico, Sweden, Singapore, Switzerland, Spain (since April 28th, 2022), Estonia,
Greece, Latvia, Lithuania, Portugal, Slovakia and Slovenia (since June 15th,
2022). We are working on expanding this list even further.I have an idea for MDN Plus, who should I contact?In case you have an idea you would like to share about MDN Plus, you can add
your suggestions to our mdn-community
repo.
If a subscriber, you can also leave us feedback by accessing the ‘Feedback’
option in the user menu.\n\nFrequently asked questionsWhat is MDN Plus?MDN Plus is a premium subscription service launched in March 2022 by Mozilla.
The service allows users to customize their MDN Web Docs experience through
premium features such as Updates,
Collections and
MDN Offline.Why are we working on premium features on MDN?The extensive research we have done in 2020 and 2021 showed us that MDN users
would appreciate a customized experience on MDN. We’ve got information on what
you would find useful and what you would be interested in. All the premium
features we propose today reflect that feedback. MDN Plus is an initial step
towards making the experience on the site more interactive and helpful for our
users.How much does MDN Plus cost?A three-tiered pricing model has been put in place in order to try and
accommodate our users’ needs as much as possible:

MDN Core - A free plan, for those ones who want to try out a limited version
of the premium features.
MDN Plus 5 - A $5/month or $50/year plan that offers unlimited access to the
premium features included in MDN Plus.
MDN Supporter 10 - A $10/month or $100/year plan for users who want to
support MDN with a higher amount. On top of the MDN Plus premium features, MDN
supporters will be able to contribute and shape the product moving forward, by
having early access to premium features and a direct feedback channel with the
MDN team.

Subscribing for a yearly plan activates a 20% discount for all the paid options.Can I upgrade/downgrade my plan?Currently, you can only upgrade your plan. For getting a downgrade, please
cancel your current subscription first and then activate the new one.What is happening with the existing MDN Web Docs?Nothing. We will continue to develop & maintain our web documentation that will
remain free and accessible for everyone. There will be no change there. Even
more, we believe that MDN Web Docs will benefit from MDN Plus, as we plan to
reinvest part of the gains from MDN Plus and improve our documentation as well
as the overall user experience on the website.Are we violating any OS license obligation by adding a paid product to MDN?MDN content is made available under a CC BY-SA 2.5 license. That license doesn't
preclude Mozilla (or other users of MDN content) from having a paid product. MDN
Plus adds premium features like updates and collections on top of the free
content. Regular users can still access and reuse MDN content under the Creative
Commons license.Where will the money from MDN Plus go?Since its beginning in 2005, MDN Web Docs has been a project hosted and provided
by Mozilla. Mozilla covers the cost of infrastructure, development and
maintenance of the MDN platform, including a team of engineers and its own team
of dedicated writers.
Mozilla wants MDN Plus to help ensure that MDN's open source content continues
to be supported into the future. MDN Plus has been built only with Mozilla
resources, and any revenue generated by MDN Plus will stay within Mozilla. We
are looking into ways to reinvest some of these additional funds into open
source projects contributing to MDN but it is still in the early stages.Does the launch of MDN Plus impact the relationship with partners like OWD?The existence of a new subscription model will not detract from MDN's current
free Web Docs offering in any way. The current experience of accessing web
documentation will not change for users who do not wish to sign up for a premium
subscription. Open Web Docs (OWD) and Mozilla will continue to work closely
together on MDN for the best possible web platform documentation for everyone.
For more information about how our organizations work together, please check
this article.What regions is MDN Plus available in?The free version of MDN Plus is available worldwide. Anyone can create an MDN
Plus account and try out a limited version of the premium features. As for the
paid plans, they are currently available as follows: in the United States,
Canada (since March 24th, 2022), Austria, Belgium, Finland, France, the United
Kingdom, Germany, Ireland, Italy, Malaysia, the Netherlands, New Zealand, Puerto
Rico, Sweden, Singapore, Switzerland, Spain (since April 28th, 2022), Estonia,
Greece, Latvia, Lithuania, Portugal, Slovakia and Slovenia (since June 15th,
2022). We are working on expanding this list even further.I have an idea for MDN Plus, who should I contact?In case you have an idea you would like to share about MDN Plus, you can add
your suggestions to our mdn-community
repo.
If a subscriber, you can also leave us feedback by accessing the ‘Feedback’
option in the user menu.\n\nFrequently asked questionsWhat is MDN Plus?MDN Plus is a premium subscription service launched in March 2022 by Mozilla.
The service allows users to customize their MDN Web Docs experience through
premium features such as Updates,
Collections and
MDN Offline.Why are we working on premium features on MDN?The extensive research we have done in 2020 and 2021 showed us that MDN users
would appreciate a customized experience on MDN. We’ve got information on what
you would find useful and what you would be interested in. All the premium
features we propose today reflect that feedback. MDN Plus is an initial step
towards making the experience on the site more interactive and helpful for our
users.How much does MDN Plus cost?A three-tiered pricing model has been put in place in order to try and
accommodate our users’ needs as much as possible:

MDN Core - A free plan, for those ones who want to try out a limited version
of the premium features.
MDN Plus 5 - A $5/month or $50/year plan that offers unlimited access to the
premium features included in MDN Plus.
MDN Supporter 10 - A $10/month or $100/year plan for users who want to
support MDN with a higher amount. On top of the MDN Plus premium features, MDN
supporters will be able to contribute and shape the product moving forward, by
having early access to premium features and a direct feedback channel with the
MDN team.

Subscribing for a yearly plan activates a 20% discount for all the paid options.Can I upgrade/downgrade my plan?Currently, you can only upgrade your plan. For getting a downgrade, please
cancel your current subscription first and then activate the new one.What is happening with the existing MDN Web Docs?Nothing. We will continue to develop & maintain our web documentation that will
remain free and accessible for everyone. There will be no change there. Even
more, we believe that MDN Web Docs will benefit from MDN Plus, as we plan to
reinvest part of the gains from MDN Plus and improve our documentation as well
as the overall user experience on the website.Are we violating any OS license obligation by adding a paid product to MDN?MDN content is made available under a CC BY-SA 2.5 license. That license doesn't
preclude Mozilla (or other users of MDN content) from having a paid product. MDN
Plus adds premium features like updates and collections on top of the free
content. Regular users can still access and reuse MDN content under the Creative
Commons license.Where will the money from MDN Plus go?Since its beginning in 2005, MDN Web Docs has been a project hosted and provided
by Mozilla. Mozilla covers the cost of infrastructure, development and
maintenance of the MDN platform, including a team of engineers and its own team
of dedicated writers.
Mozilla wants MDN Plus to help ensure that MDN's open source content continues
to be supported into the future. MDN Plus has been built only with Mozilla
resources, and any revenue generated by MDN Plus will stay within Mozilla. We
are looking into ways to reinvest some of these additional funds into open
source projects contributing to MDN but it is still in the early stages.Does the launch of MDN Plus impact the relationship with partners like OWD?The existence of a new subscription model will not detract from MDN's current
free Web Docs offering in any way. The current experience of accessing web
documentation will not change for users who do not wish to sign up for a premium
subscription. Open Web Docs (OWD) and Mozilla will continue to work closely
together on MDN for the best possible web platform documentation for everyone.
For more information about how our organizations work together, please check
this article.What regions is MDN Plus available in?The free version of MDN Plus is available worldwide. Anyone can create an MDN
Plus account and try out a limited version of the premium features. As for the
paid plans, they are currently available as follows: in the United States,
Canada (since March 24th, 2022), Austria, Belgium, Finland, France, the United
Kingdom, Germany, Ireland, Italy, Malaysia, the Netherlands, New Zealand, Puerto
Rico, Sweden, Singapore, Switzerland, Spain (since April 28th, 2022), Estonia,
Greece, Latvia, Lithuania, Portugal, Slovakia and Slovenia (since June 15th,
2022). We are working on expanding this list even further.I have an idea for MDN Plus, who should I contact?In case you have an idea you would like to share about MDN Plus, you can add
your suggestions to our mdn-community
repo.
If a subscriber, you can also leave us feedback by accessing the ‘Feedback’
option in the user menu.\n\n\n\nMDN CurriculumThe essential skillset for new front-end developersThe MDN Curriculum provides a structured guide to the essential skills and practices for being a successful front-end developer, along with recommended learning resources.
Last updated: February 2024About the curriculum
Beginner's level
Self-paced
Free

Defines the essential skills and knowledge every front-end developer needs for career success and industry relevance.
Created by Mozilla and refined with insights from students, educators, and developers from the broader web community.
Includes learning resource recommendations covering every curriculum topic, helping you become job-ready.
Learn moreLearn our curriculum with Scrimba's interactive Frontend Developer Career Path.ModulesGetting started1. Soft skillsDevelop a great attitude towards learning, researching, and collaborating to enhance your chances of success.Best Practices2. Environment setupFamiliarize yourself with your development environment and the tools you'll use to build websites.ToolingLet's beginCore1. Web standardsUnderstand how the web works at a high level, and the process for creating web technologies.Web Standards & Semantics2. Semantic HTMLLearn the fundamentals of HTML, the language used to define and structure web content.Web Standards & Semantics3. CSS fundamentalsDive into the fundamentals of CSS, the language you'll use to style and layout websites.Styling4. CSS text stylingFocus on using CSS to style text and apply custom web fonts.Styling5. CSS layoutLearn modern techniques for creating flexible layouts that work on a wide variety of devices.Styling6. JavaScript fundamentalsFocus on the core JavaScript language and fundamental surrounding topics.Scripting7. AccessibilityUnderstand the need for universal access to web content and how to write accessible code.Best Practices8. Design for developersAppreciate basic design theory, how to speak design language, and what makes websites look good.Best Practices9. Version controlUnderstand why version control is necessary, and use GitHub to store code and collaborate with others.ToolingLet's beginExtensions1. Transform & animate CSSAdd animations to your toolbox to enhance user experience and perceived performance.Web Standards & Semantics2. Custom JS objectsCreate custom JavaScript objects to gain a deeper understanding of object-oriented programming.Scripting3. Web APIsStudy common WebAPIs in depth to appreciate how WebAPIs work in general.Scripting4. PerformanceExplore how to create performant, fast-loading websites and enhance perceived performance.Best Practices5. Security and privacyLearn how to protect data from unauthorized access and how to treat user data responsibly.Best Practices6. TestingExplore the need for testing, and learn how to implement common test types.Best Practices7. JavaScript frameworksStudy the features of popular JavaScript frameworks, and use them to implement common use cases.Tooling8. CSS toolingLook at popular CSS tooling and understand what code problems they can solve.Tooling9. Other tooling typesUnderstand the purpose and usage of other tooling types commonly found in a web project.ToolingLet's beginLearn the curriculum with Scrimba and become job readyScrimba's Frontend Developer Career Path teaches the MDN Curriculum Core with fun interactive lessons and challenges, knowledgeable teachers, and a supportive community. Go from zero to landing your first front-end job!Find out moreHow can youboost your employability with the MDNCurriculum?Learn about research collaboration and other essential soft skills.Balance between modern tooling and long-term best practices.Get access to high-quality recommended resources.Get guidance from trusted voices.Don't know where toget started? 

Starting out with coding?
Begin with our "Getting started" and "Core" modules to grasp the essential skills for web development.
Core modules


Beyond the basics?
Dive deeper with our "Extensions" modules to develop specialized skills.
Extensions modules


Seeking employment?
Our "Soft skills" module, part of "Getting started", offers crucial insights to help you land your job.
Getting started modules


Working at a school?
Use our modules to guide your teaching, or enroll your students in Scrimba's Frontend Path.
Frontend Path\n\nMDN CurriculumThe essential skillset for new front-end developersThe MDN Curriculum provides a structured guide to the essential skills and practices for being a successful front-end developer, along with recommended learning resources.
Last updated: February 2024About the curriculum
Beginner's level
Self-paced
Free

Defines the essential skills and knowledge every front-end developer needs for career success and industry relevance.
Created by Mozilla and refined with insights from students, educators, and developers from the broader web community.
Includes learning resource recommendations covering every curriculum topic, helping you become job-ready.
Learn moreLearn our curriculum with Scrimba's interactive Frontend Developer Career Path.ModulesGetting started1. Soft skillsDevelop a great attitude towards learning, researching, and collaborating to enhance your chances of success.Best Practices2. Environment setupFamiliarize yourself with your development environment and the tools you'll use to build websites.ToolingLet's beginCore1. Web standardsUnderstand how the web works at a high level, and the process for creating web technologies.Web Standards & Semantics2. Semantic HTMLLearn the fundamentals of HTML, the language used to define and structure web content.Web Standards & Semantics3. CSS fundamentalsDive into the fundamentals of CSS, the language you'll use to style and layout websites.Styling4. CSS text stylingFocus on using CSS to style text and apply custom web fonts.Styling5. CSS layoutLearn modern techniques for creating flexible layouts that work on a wide variety of devices.Styling6. JavaScript fundamentalsFocus on the core JavaScript language and fundamental surrounding topics.Scripting7. AccessibilityUnderstand the need for universal access to web content and how to write accessible code.Best Practices8. Design for developersAppreciate basic design theory, how to speak design language, and what makes websites look good.Best Practices9. Version controlUnderstand why version control is necessary, and use GitHub to store code and collaborate with others.ToolingLet's beginExtensions1. Transform & animate CSSAdd animations to your toolbox to enhance user experience and perceived performance.Web Standards & Semantics2. Custom JS objectsCreate custom JavaScript objects to gain a deeper understanding of object-oriented programming.Scripting3. Web APIsStudy common WebAPIs in depth to appreciate how WebAPIs work in general.Scripting4. PerformanceExplore how to create performant, fast-loading websites and enhance perceived performance.Best Practices5. Security and privacyLearn how to protect data from unauthorized access and how to treat user data responsibly.Best Practices6. TestingExplore the need for testing, and learn how to implement common test types.Best Practices7. JavaScript frameworksStudy the features of popular JavaScript frameworks, and use them to implement common use cases.Tooling8. CSS toolingLook at popular CSS tooling and understand what code problems they can solve.Tooling9. Other tooling typesUnderstand the purpose and usage of other tooling types commonly found in a web project.ToolingLet's beginLearn the curriculum with Scrimba and become job readyScrimba's Frontend Developer Career Path teaches the MDN Curriculum Core with fun interactive lessons and challenges, knowledgeable teachers, and a supportive community. Go from zero to landing your first front-end job!Find out moreHow can youboost your employability with the MDNCurriculum?Learn about research collaboration and other essential soft skills.Balance between modern tooling and long-term best practices.Get access to high-quality recommended resources.Get guidance from trusted voices.Don't know where toget started? 

Starting out with coding?
Begin with our "Getting started" and "Core" modules to grasp the essential skills for web development.
Core modules


Beyond the basics?
Dive deeper with our "Extensions" modules to develop specialized skills.
Extensions modules


Seeking employment?
Our "Soft skills" module, part of "Getting started", offers crucial insights to help you land your job.
Getting started modules


Working at a school?
Use our modules to guide your teaching, or enroll your students in Scrimba's Frontend Path.
Frontend Path\n\nMDN CurriculumThe essential skillset for new front-end developersThe MDN Curriculum provides a structured guide to the essential skills and practices for being a successful front-end developer, along with recommended learning resources.
Last updated: February 2024About the curriculum
Beginner's level
Self-paced
Free

Defines the essential skills and knowledge every front-end developer needs for career success and industry relevance.
Created by Mozilla and refined with insights from students, educators, and developers from the broader web community.
Includes learning resource recommendations covering every curriculum topic, helping you become job-ready.
Learn moreLearn our curriculum with Scrimba's interactive Frontend Developer Career Path.ModulesGetting started1. Soft skillsDevelop a great attitude towards learning, researching, and collaborating to enhance your chances of success.Best Practices2. Environment setupFamiliarize yourself with your development environment and the tools you'll use to build websites.ToolingLet's beginCore1. Web standardsUnderstand how the web works at a high level, and the process for creating web technologies.Web Standards & Semantics2. Semantic HTMLLearn the fundamentals of HTML, the language used to define and structure web content.Web Standards & Semantics3. CSS fundamentalsDive into the fundamentals of CSS, the language you'll use to style and layout websites.Styling4. CSS text stylingFocus on using CSS to style text and apply custom web fonts.Styling5. CSS layoutLearn modern techniques for creating flexible layouts that work on a wide variety of devices.Styling6. JavaScript fundamentalsFocus on the core JavaScript language and fundamental surrounding topics.Scripting7. AccessibilityUnderstand the need for universal access to web content and how to write accessible code.Best Practices8. Design for developersAppreciate basic design theory, how to speak design language, and what makes websites look good.Best Practices9. Version controlUnderstand why version control is necessary, and use GitHub to store code and collaborate with others.ToolingLet's beginExtensions1. Transform & animate CSSAdd animations to your toolbox to enhance user experience and perceived performance.Web Standards & Semantics2. Custom JS objectsCreate custom JavaScript objects to gain a deeper understanding of object-oriented programming.Scripting3. Web APIsStudy common WebAPIs in depth to appreciate how WebAPIs work in general.Scripting4. PerformanceExplore how to create performant, fast-loading websites and enhance perceived performance.Best Practices5. Security and privacyLearn how to protect data from unauthorized access and how to treat user data responsibly.Best Practices6. TestingExplore the need for testing, and learn how to implement common test types.Best Practices7. JavaScript frameworksStudy the features of popular JavaScript frameworks, and use them to implement common use cases.Tooling8. CSS toolingLook at popular CSS tooling and understand what code problems they can solve.Tooling9. Other tooling typesUnderstand the purpose and usage of other tooling types commonly found in a web project.ToolingLet's beginLearn the curriculum with Scrimba and become job readyScrimba's Frontend Developer Career Path teaches the MDN Curriculum Core with fun interactive lessons and challenges, knowledgeable teachers, and a supportive community. Go from zero to landing your first front-end job!Find out moreHow can youboost your employability with the MDNCurriculum?Learn about research collaboration and other essential soft skills.Balance between modern tooling and long-term best practices.Get access to high-quality recommended resources.Get guidance from trusted voices.Don't know where toget started? 

Starting out with coding?
Begin with our "Getting started" and "Core" modules to grasp the essential skills for web development.
Core modules


Beyond the basics?
Dive deeper with our "Extensions" modules to develop specialized skills.
Extensions modules


Seeking employment?
Our "Soft skills" module, part of "Getting started", offers crucial insights to help you land your job.
Getting started modules


Working at a school?
Use our modules to guide your teaching, or enroll your students in Scrimba's Frontend Path.
Frontend Path\n\n\n\nDefault styles for h1 elements are changingSimon PietersApril 11, 20254 minute readBrowsers are starting to roll out changes in default UA styles for nested section headings. This post describes the incoming changes, how to identify if it's an issue on your websites, and hints for conformant and better-structured pages.
Read more →Implications of Global Privacy ControlLola OdelolaMarch 15, 20255 minute readGlobal Privacy Control (GPC) is on the way to becoming a formal privacy standard with the recent publication of its first working draft. Let's take a look at what the implications are for developers and users.Read more →JavaScript Temporal is comingBrian SmithJanuary 24, 20255 minute readA new way to handle dates and times is being added to JavaScript. Let's take a look at Temporal, what problems it solves, the current state, and what you'll find in the new documentation about it on MDN.
Read more →Fix your website's Largest Contentful Paint by optimizing image loadingDebugBearJanuary 13, 202510 minute readLearn techniques to improve the Largest Contentful Paint metric, a part of Core Web Vitals, for your website.
SponsoredRead more →MDN 2024 content projectsVadim MakeevJanuary 8, 20259 minute readLet's have a look at MDN Web Docs content projects in 2024, with highlights of our top picks and recommended reading, and at what's next on MDN for 2025.
Read more →A new learning experience on MDNRuth JohnDecember 20, 20244 minute readThere's a new Learn Web Development section on MDN that merges the MDN Curriculum with the Learn section. Here's the background to these changes, what's new, and what you can expect to see in the future.
Read more →Countdown to the holidays with daily coding challengesSonal SoodDecember 1, 20242 minute readJoin JavaScriptmas this December for daily coding challenges designed to boost your skills and bring festive fun. Solve challenges on Scrimba, learn something new, and take part for a chance to win exciting prizes!
Read more →Monitoring and optimizing website performanceDebugBearNovember 11, 202412 minute readLearn about reading network request waterfalls, identifying common network performance issues, and optimizing page rendering.
SponsoredRead more →How to land your first developer jobPer BorgenNovember 1, 202411 minute readHere are six effective strategies for landing your first developer job. These are especially relevant if you're self-taught or breaking into the tech industry without a traditional CS degree.
SponsoredRead more →Introducing the new MDN Community pagePranshu KhannaOctober 15, 20245 minute readWe are thrilled to announce the new MDN community page that will be a hub to recognize our contributors and a place for contributors to get involved.
Read more →Fixing your website's JavaScript performanceDebugBearOctober 9, 20249 minute readLearn about lesser-known web performance bottlenecks connected to excessive JavaScript usage, like long tasks, large bundle sizes, and hydration issues.
SponsoredRead more →Get back to school! Supercharge your learning with MDN and ScrimbaHermina CondeiSeptember 12, 20242 minute readFor many of us, the holidays are over, and the time has come to focus.  Now is an ideal time to dive into learning web development, and you're in luck — MDN and Scrimba are offering a 30% discount on select courses for the next month!
Read more →Efficient data handling with the Streams APIVultrSeptember 6, 20246 minute readThis post demonstrates how to use the Streams API in a web application to fetch and transform text on the fly.  By processing the data as it arrives, this approach enhances performance, responsiveness, and resource efficiency.
SponsoredRead more →Locale-sensitive text segmentation in JavaScript with Intl.SegmenterBrian SmithSeptember 3, 20245 minute readLearn how to use Intl.Segmenter for locale-sensitive text segmentation in JavaScript to simplify localization, count words or sentences in different languages, and more.Read more →Optimize your workflow with Git stashGitLabAugust 28, 20248 minute readLearn how to use Git stash to break down large commits. Discover a better approach for saving work when switching branches.SponsoredRead more →How to debug mobile apps across devicesLambdaTestAugust 7, 20248 minute readThis post explores what mobile app debugging is, commonly used techniques, and how you can debug mobile apps on multiple devices.SponsoredRead more →Exclusive accordions using the HTML details elementBrian SmithAugust 5, 20243 minute readThe 'name' attribute of the HTML details element is gaining more support across browsers. Learn how this feature allows creating exclusive accordions without scripting widgets from scratch.Read more →Exploring the Broadcast Channel API for cross-tab communicationVultrJuly 12, 20244 minute readThis article explains how to use the Broadcast Channel API to build synchronized and interconnected web applications.SponsoredRead more →MDN partners with Scrimba to enhance web development learningHermina CondeiJuly 9, 20246 minute readWe have chosen Scrimba as a course partner for the MDN Curriculum. This blog post explores what the partnership means practically, and how we will provide an even better web education experience together.Read more →Introducing the MDN HTTP ObservatoryHermina CondeiJuly 2, 20247 minute readFirst released in 2016, the HTTP Observatory became popular in the web community with a combination of helpful security audits and educational material. Fast forward to 2024, and we are delighted to announce that Observatory's new home is MDN. Read on to find out more about what this entails, and give the HTTP Observatory a warm welcome!Read more →Static Site Generation (SSG) with Next.jsVultrJune 28, 20247 minute readThis guide explains how to use Static Site Generation in Next.js to build scalable and secure web applications with fast loading times and a focus on performance.SponsoredRead more →New JavaScript Set methodsBrian SmithJune 24, 20245 minute readNew JavaScript Set methods are landing across browsers. Learn about sets, how you can use these methods to compare different sets, create new sets with specific properties, and more.Read more →Securing APIs: Express rate limit and slow downVultrMay 28, 20246 minute readThis guide introduces you to rate limits and slow down mechanisms. Learn how to apply slow down and rate limit mechanisms in Express applications.SponsoredRead more →Using the Page Visibility APIBrian SmithMay 10, 20246 minute readThis post takes a look at what page visibility is, how you can use the Page Visibility API in your applications, and describes pitfalls to avoid if you build features around this functionality.Read more →A year of publishing the MDN BlogThe MDN TeamMay 3, 20245 minute readWe've been writing about web development and the web platform on the MDN Blog since May 2023. Here's our highlights and top posts along with our favorites.Read more →Setting up service workers on VultrVultrApril 23, 20246 minute readThis guide introduces you to service workers and their lifecycle. Learn how to deploy a project using service workers with HTTPS on Vultr.SponsoredRead more →Interop 2023: MDN updatesBrian SmithMarch 27, 20246 minute readInterop 2023 has successfully concluded, and the Interop 2024 project is now officially underway. Learn what Interop is, discover the updates from Interop 2023 now on MDN, and find out what's coming to the web next.Read more →Testing JavaScript with Jest on VultrVultrMarch 22, 20247 minute readThis guide introduces you to the common types of tests and the testing conventions. Learn how to test JavaScript with Jest on Vultr.SponsoredRead more →Creating color palettes with the CSS color-mix() functionMichelle BarkerMarch 8, 20247 minute readWorking with colors on the web just got more interesting! In this article, we’ll explore how to use the CSS color-mix() function to create variations in color palettes.Read more →Modernizing conventional test automation with TestGridTestGridFebruary 29, 202412 minute readThis post reflects on the conventional test automation methods using Selenium and Appium. Learn how you can use TestGrid's unified testing platform to enhance the conventional methods and also leverage the modern codeless testing techniques.SponsoredRead more →Lift-off: The MDN Curriculum launchHermina CondeiFebruary 27, 20246 minute readThe long-awaited MDN Curriculum is now live on MDN, providing a structured guide to the essential front-end development skills and best practices for industry newcomers. Learn all the key details in this article.Read more →Creating effective technical documentationDipika BhattacharyaFebruary 13, 20247 minute readThis article provides an overview of the core components required for creating effective technical documentation. Learn the best practices to make your documentation clear, consistent, and well-structured.Read more →Leveraging Bun on Vultr: A superior Node.js alternativeVultrJanuary 17, 20245 minute readThis guide explains Bun functionalities as a runtime package manager and a bundler. It also explains the benefits of built-in Bun APIs and how to use Bun's Vultr marketplace application.SponsoredRead more →Border images in CSS: A key focus area for Interop 2023Dipika BhattacharyaDecember 19, 202310 minute readAligning with Interop 2023's emphasis on cross-browser consistency, this post walks you through various `border-image` properties that you can control to create captivating web designs. Learn how to use custom graphics for enhancing the look of your websites that appear consistent across different browsers.Read more →Build AI-powered applications using OpenLLM and Vultr Cloud GPUVultrDecember 12, 20237 minute readLearn how to build AI-powered apps using OpenLLM and Vultr Cloud GPU. This guide shows how to generate API responses using a Large Language Model. It also covers instructions for setting up an Nginx server and implementing SSL security.SponsoredRead more →Saying goodbye to third-party cookies in 2024Chris MillsDecember 8, 20238 minute readThe tail end of 2023 welcomes positive news for web privacy, as Chrome announces it is to join Firefox and Safari in deprecating third-party cookies in 2024. Find out more details about these changes, and what they mean for web developers.Read more →Baseline's evolution on MDNVadim MakeevDecember 5, 20234 minute readToday we're updating the Baseline widgets and introducing a new one, along with the updated definition of Baseline.Read more →Developer essentials: JavaScript console methodsBrian SmithNovember 30, 20236 minute readThe JavaScript console is an essential tool for web development. Learn new and fun ways to use the console to display data and debug your code.Read more →Getting started with CSS container queriesMichelle BarkerNovember 16, 20238 minute readCSS container queries are a powerful new tool for our CSS layout toolbox. In this post we'll dive into the practicalities of building a layout with container queries.Read more →Deploying Node.js applications with PM2 on VultrVultrNovember 8, 20237 minute readLearn how to deploy a Node.js application on Vultr using PM2 to create persistent services. This guide shows how to efficiently use resources via PM2 cluster mode. It also covers Nginx server setup and SSL security.SponsoredRead more →VS Code: Tips and tricks for beginnersDipika BhattacharyaNovember 7, 20238 minute readDiscover essential tips and tricks for using Visual Studio Code (VS Code), a powerful IDE. Learn how to leverage its integrated editing features and Git support, and explore a few extensions.Read more →Coming Soon: MDN Observatory 2.0The MDN TeamOctober 25, 20232 minute readObservatory 2.0 is launching soon as part of the Mozilla Developer Network as the MDN Observatory with new security scoring standards and other exciting updates.Read more →Optimizing DevSecOps workflows with GitLab's conditional CI/CD pipelinesGitLabOctober 23, 20238 minute readThis guide explores the various types of CI/CD pipelines and helps you understand their specific use cases. Learn how to leverage rules to create highly efficient DevSecOps workflows.SponsoredRead more →Introduction to web sustainabilityMichelle BarkerOctober 11, 20238 minute readWhat can web designers and developers do to build a more sustainable web? This post explores the environmental impacts of web technologies and looks at some of the ways we can build greener websites.Read more →Migrating from GitHub to GitLab seamlessly: A step-by-step guideGitLabOctober 5, 20239 minute readThinking about making the move from GitHub to GitLab? This guide demystifies the migration process, addressing common concerns for DevSecOps teams that are looking to seamlessly transition between the two platforms. This post provides a step-by-step guided tutorial on how to migrate your data from GitHub into GitLab.SponsoredRead more →Announcing the MDN front-end developer curriculumThe MDN TeamAugust 14, 20235 minute readMDN has created a curriculum for aspiring front-end developers to build a rewarding and successful career. Take a look at the curriculum, who it's for, and the research it's based on.Read more →Creating custom easing effects in CSS animations using the linear() functionMichelle BarkerAugust 1, 202310 minute readThe new CSS linear() timing function enables custom easing in animations. Explore how linear() works compared with other timing functions used for easing, with practical examples.Read more →Securing your CDN: Why and how should you use SRITerence EdenJuly 21, 20234 minute readRelying on external resources for your website is always fraught with risks. Learn how to protect your website and its visitors by using SRI to secure third-party content.Read more →Scroll progress animations in CSSMichelle BarkerJuly 14, 20237 minute readScroll-driven animations are coming to CSS! In this post, we'll look at a few types of animations and learn how to link them to the scroll progress of a container.Read more →Reflections on AI Explain: A postmortemThe MDN TeamJuly 11, 202310 minute readWe recently launched a feature called AI Explain, but we have rolled this back for now. In this post, we look into the story behind AI Explain: its development, launch, and the reasons that led us to press the pause button.Read more →Developer essentials: How to search code using grepBrian SmithJuly 3, 20239 minute readgrep is a powerful tool for searching code from the terminal. This post will show you how to use grep and why it's an essential developer tool.Read more →Introducing AI Help (Beta): Your Companion for Web DevelopmentHermina CondeiJune 27, 20233 minute readWe're introducing an AI assistant powered by MDN and OpenAI GPT 3.5 to answer all your web development questions in real time.Read more →Learn how to use hue in CSS colors with HSLBrian SmithJune 26, 20237 minute readHues are a bright way to define colors in CSS. Learn about hues, color wheels, how to use color functions, and how you can create vibrant color palettes for your website using hue.Read more →Introducing the MDN Playground: Bring your code to life!Florian DiemingerJune 22, 20236 minute readMDN is launching a code Playground. Users can prototype ideas and expand all live samples into an interactive experience.Read more →MDN doc updates: CSS selectors & media queries, WebGPU & WebTransport APIs, Progressive web appsDipika BhattacharyaJune 13, 20236 minute readDiscover CSS :lang(), experimental media queries, manipulating graphics with WebGPU, client-server communication with WebTransport, ECMAScript module support, and more.Read more →How to draw any regular shape with just one JavaScript functionRuth JohnMay 26, 20234 minute readLearn how to use JavaScript to draw any regular shape to a HTML canvas with a single function, and how to modify it to draw multiple shapes.Read more →New reference pages on MDN for JavaScript regular expressionsBrian SmithMay 23, 20235 minute readSee the latest updates to the MDN reference pages about JavaScript regular expressions, including new sections on sub-features and browser compatibility information.Read more →Celebrating Global Accessibility Awareness DaySchalk NeethlingMay 18, 20236 minute readIn celebration of Global Accessibility Awareness Day in 2023, we share some tools and guidelines to help you make the web more accessible.Read more →Using HTML landmark roles to improve accessibilitySchalk NeethlingMay 15, 202311 minute readLearn what HTML landmark roles are, how they improve accessibility, and how you can include them on your website effectively.Read more →Introducing Baseline: a unified view of stable web featuresHermina CondeiMay 10, 20233 minute readMDN leads the way in implementing WebDX community group's efforts, delivering a clear and simple baseline for the web platform to developers.Read more →How :not() chains multiple selectorsDipika BhattacharyaMay 5, 20234 minute readLearn how the CSS `:not()` pseudo-class behaves when multiple selectors are passed as argument.Read more →New functions, gradients, and hues in CSS colors (Level 4)Brian SmithMay 3, 20239 minute readLearn what's new in CSS Colors Module Level 4, including color spaces, color functions, fancy gradients, and support for wide-gamut displays.Read more →Welcome to the MDN blogRuth JohnMay 3, 20232 minute readThe MDN blog publishes web development news, tutorials, and insights as an extension of MDN Web Docs, helping you discover, learn, and create for the web.Read more →\n\nBlog it betterDefault styles for h1 elements are changingSimon PietersApril 11, 20254 minute readBrowsers are starting to roll out changes in default UA styles for nested section headings. This post describes the incoming changes, how to identify if it's an issue on your websites, and hints for conformant and better-structured pages.
Read more →Implications of Global Privacy ControlLola OdelolaMarch 15, 20255 minute readGlobal Privacy Control (GPC) is on the way to becoming a formal privacy standard with the recent publication of its first working draft. Let's take a look at what the implications are for developers and users.Read more →JavaScript Temporal is comingBrian SmithJanuary 24, 20255 minute readA new way to handle dates and times is being added to JavaScript. Let's take a look at Temporal, what problems it solves, the current state, and what you'll find in the new documentation about it on MDN.
Read more →Fix your website's Largest Contentful Paint by optimizing image loadingDebugBearJanuary 13, 202510 minute readLearn techniques to improve the Largest Contentful Paint metric, a part of Core Web Vitals, for your website.
SponsoredRead more →MDN 2024 content projectsVadim MakeevJanuary 8, 20259 minute readLet's have a look at MDN Web Docs content projects in 2024, with highlights of our top picks and recommended reading, and at what's next on MDN for 2025.
Read more →A new learning experience on MDNRuth JohnDecember 20, 20244 minute readThere's a new Learn Web Development section on MDN that merges the MDN Curriculum with the Learn section. Here's the background to these changes, what's new, and what you can expect to see in the future.
Read more →Countdown to the holidays with daily coding challengesSonal SoodDecember 1, 20242 minute readJoin JavaScriptmas this December for daily coding challenges designed to boost your skills and bring festive fun. Solve challenges on Scrimba, learn something new, and take part for a chance to win exciting prizes!
Read more →Monitoring and optimizing website performanceDebugBearNovember 11, 202412 minute readLearn about reading network request waterfalls, identifying common network performance issues, and optimizing page rendering.
SponsoredRead more →How to land your first developer jobPer BorgenNovember 1, 202411 minute readHere are six effective strategies for landing your first developer job. These are especially relevant if you're self-taught or breaking into the tech industry without a traditional CS degree.
SponsoredRead more →Introducing the new MDN Community pagePranshu KhannaOctober 15, 20245 minute readWe are thrilled to announce the new MDN community page that will be a hub to recognize our contributors and a place for contributors to get involved.
Read more →Fixing your website's JavaScript performanceDebugBearOctober 9, 20249 minute readLearn about lesser-known web performance bottlenecks connected to excessive JavaScript usage, like long tasks, large bundle sizes, and hydration issues.
SponsoredRead more →Get back to school! Supercharge your learning with MDN and ScrimbaHermina CondeiSeptember 12, 20242 minute readFor many of us, the holidays are over, and the time has come to focus.  Now is an ideal time to dive into learning web development, and you're in luck — MDN and Scrimba are offering a 30% discount on select courses for the next month!
Read more →Efficient data handling with the Streams APIVultrSeptember 6, 20246 minute readThis post demonstrates how to use the Streams API in a web application to fetch and transform text on the fly.  By processing the data as it arrives, this approach enhances performance, responsiveness, and resource efficiency.
SponsoredRead more →Locale-sensitive text segmentation in JavaScript with Intl.SegmenterBrian SmithSeptember 3, 20245 minute readLearn how to use Intl.Segmenter for locale-sensitive text segmentation in JavaScript to simplify localization, count words or sentences in different languages, and more.Read more →Optimize your workflow with Git stashGitLabAugust 28, 20248 minute readLearn how to use Git stash to break down large commits. Discover a better approach for saving work when switching branches.SponsoredRead more →How to debug mobile apps across devicesLambdaTestAugust 7, 20248 minute readThis post explores what mobile app debugging is, commonly used techniques, and how you can debug mobile apps on multiple devices.SponsoredRead more →Exclusive accordions using the HTML details elementBrian SmithAugust 5, 20243 minute readThe 'name' attribute of the HTML details element is gaining more support across browsers. Learn how this feature allows creating exclusive accordions without scripting widgets from scratch.Read more →Exploring the Broadcast Channel API for cross-tab communicationVultrJuly 12, 20244 minute readThis article explains how to use the Broadcast Channel API to build synchronized and interconnected web applications.SponsoredRead more →MDN partners with Scrimba to enhance web development learningHermina CondeiJuly 9, 20246 minute readWe have chosen Scrimba as a course partner for the MDN Curriculum. This blog post explores what the partnership means practically, and how we will provide an even better web education experience together.Read more →Introducing the MDN HTTP ObservatoryHermina CondeiJuly 2, 20247 minute readFirst released in 2016, the HTTP Observatory became popular in the web community with a combination of helpful security audits and educational material. Fast forward to 2024, and we are delighted to announce that Observatory's new home is MDN. Read on to find out more about what this entails, and give the HTTP Observatory a warm welcome!Read more →Static Site Generation (SSG) with Next.jsVultrJune 28, 20247 minute readThis guide explains how to use Static Site Generation in Next.js to build scalable and secure web applications with fast loading times and a focus on performance.SponsoredRead more →New JavaScript Set methodsBrian SmithJune 24, 20245 minute readNew JavaScript Set methods are landing across browsers. Learn about sets, how you can use these methods to compare different sets, create new sets with specific properties, and more.Read more →Securing APIs: Express rate limit and slow downVultrMay 28, 20246 minute readThis guide introduces you to rate limits and slow down mechanisms. Learn how to apply slow down and rate limit mechanisms in Express applications.SponsoredRead more →Using the Page Visibility APIBrian SmithMay 10, 20246 minute readThis post takes a look at what page visibility is, how you can use the Page Visibility API in your applications, and describes pitfalls to avoid if you build features around this functionality.Read more →A year of publishing the MDN BlogThe MDN TeamMay 3, 20245 minute readWe've been writing about web development and the web platform on the MDN Blog since May 2023. Here's our highlights and top posts along with our favorites.Read more →Setting up service workers on VultrVultrApril 23, 20246 minute readThis guide introduces you to service workers and their lifecycle. Learn how to deploy a project using service workers with HTTPS on Vultr.SponsoredRead more →Interop 2023: MDN updatesBrian SmithMarch 27, 20246 minute readInterop 2023 has successfully concluded, and the Interop 2024 project is now officially underway. Learn what Interop is, discover the updates from Interop 2023 now on MDN, and find out what's coming to the web next.Read more →Testing JavaScript with Jest on VultrVultrMarch 22, 20247 minute readThis guide introduces you to the common types of tests and the testing conventions. Learn how to test JavaScript with Jest on Vultr.SponsoredRead more →Creating color palettes with the CSS color-mix() functionMichelle BarkerMarch 8, 20247 minute readWorking with colors on the web just got more interesting! In this article, we’ll explore how to use the CSS color-mix() function to create variations in color palettes.Read more →Modernizing conventional test automation with TestGridTestGridFebruary 29, 202412 minute readThis post reflects on the conventional test automation methods using Selenium and Appium. Learn how you can use TestGrid's unified testing platform to enhance the conventional methods and also leverage the modern codeless testing techniques.SponsoredRead more →Lift-off: The MDN Curriculum launchHermina CondeiFebruary 27, 20246 minute readThe long-awaited MDN Curriculum is now live on MDN, providing a structured guide to the essential front-end development skills and best practices for industry newcomers. Learn all the key details in this article.Read more →Creating effective technical documentationDipika BhattacharyaFebruary 13, 20247 minute readThis article provides an overview of the core components required for creating effective technical documentation. Learn the best practices to make your documentation clear, consistent, and well-structured.Read more →Leveraging Bun on Vultr: A superior Node.js alternativeVultrJanuary 17, 20245 minute readThis guide explains Bun functionalities as a runtime package manager and a bundler. It also explains the benefits of built-in Bun APIs and how to use Bun's Vultr marketplace application.SponsoredRead more →Border images in CSS: A key focus area for Interop 2023Dipika BhattacharyaDecember 19, 202310 minute readAligning with Interop 2023's emphasis on cross-browser consistency, this post walks you through various `border-image` properties that you can control to create captivating web designs. Learn how to use custom graphics for enhancing the look of your websites that appear consistent across different browsers.Read more →Build AI-powered applications using OpenLLM and Vultr Cloud GPUVultrDecember 12, 20237 minute readLearn how to build AI-powered apps using OpenLLM and Vultr Cloud GPU. This guide shows how to generate API responses using a Large Language Model. It also covers instructions for setting up an Nginx server and implementing SSL security.SponsoredRead more →Saying goodbye to third-party cookies in 2024Chris MillsDecember 8, 20238 minute readThe tail end of 2023 welcomes positive news for web privacy, as Chrome announces it is to join Firefox and Safari in deprecating third-party cookies in 2024. Find out more details about these changes, and what they mean for web developers.Read more →Baseline's evolution on MDNVadim MakeevDecember 5, 20234 minute readToday we're updating the Baseline widgets and introducing a new one, along with the updated definition of Baseline.Read more →Developer essentials: JavaScript console methodsBrian SmithNovember 30, 20236 minute readThe JavaScript console is an essential tool for web development. Learn new and fun ways to use the console to display data and debug your code.Read more →Getting started with CSS container queriesMichelle BarkerNovember 16, 20238 minute readCSS container queries are a powerful new tool for our CSS layout toolbox. In this post we'll dive into the practicalities of building a layout with container queries.Read more →Deploying Node.js applications with PM2 on VultrVultrNovember 8, 20237 minute readLearn how to deploy a Node.js application on Vultr using PM2 to create persistent services. This guide shows how to efficiently use resources via PM2 cluster mode. It also covers Nginx server setup and SSL security.SponsoredRead more →VS Code: Tips and tricks for beginnersDipika BhattacharyaNovember 7, 20238 minute readDiscover essential tips and tricks for using Visual Studio Code (VS Code), a powerful IDE. Learn how to leverage its integrated editing features and Git support, and explore a few extensions.Read more →Coming Soon: MDN Observatory 2.0The MDN TeamOctober 25, 20232 minute readObservatory 2.0 is launching soon as part of the Mozilla Developer Network as the MDN Observatory with new security scoring standards and other exciting updates.Read more →Optimizing DevSecOps workflows with GitLab's conditional CI/CD pipelinesGitLabOctober 23, 20238 minute readThis guide explores the various types of CI/CD pipelines and helps you understand their specific use cases. Learn how to leverage rules to create highly efficient DevSecOps workflows.SponsoredRead more →Introduction to web sustainabilityMichelle BarkerOctober 11, 20238 minute readWhat can web designers and developers do to build a more sustainable web? This post explores the environmental impacts of web technologies and looks at some of the ways we can build greener websites.Read more →Migrating from GitHub to GitLab seamlessly: A step-by-step guideGitLabOctober 5, 20239 minute readThinking about making the move from GitHub to GitLab? This guide demystifies the migration process, addressing common concerns for DevSecOps teams that are looking to seamlessly transition between the two platforms. This post provides a step-by-step guided tutorial on how to migrate your data from GitHub into GitLab.SponsoredRead more →Announcing the MDN front-end developer curriculumThe MDN TeamAugust 14, 20235 minute readMDN has created a curriculum for aspiring front-end developers to build a rewarding and successful career. Take a look at the curriculum, who it's for, and the research it's based on.Read more →Creating custom easing effects in CSS animations using the linear() functionMichelle BarkerAugust 1, 202310 minute readThe new CSS linear() timing function enables custom easing in animations. Explore how linear() works compared with other timing functions used for easing, with practical examples.Read more →Securing your CDN: Why and how should you use SRITerence EdenJuly 21, 20234 minute readRelying on external resources for your website is always fraught with risks. Learn how to protect your website and its visitors by using SRI to secure third-party content.Read more →Scroll progress animations in CSSMichelle BarkerJuly 14, 20237 minute readScroll-driven animations are coming to CSS! In this post, we'll look at a few types of animations and learn how to link them to the scroll progress of a container.Read more →Reflections on AI Explain: A postmortemThe MDN TeamJuly 11, 202310 minute readWe recently launched a feature called AI Explain, but we have rolled this back for now. In this post, we look into the story behind AI Explain: its development, launch, and the reasons that led us to press the pause button.Read more →Developer essentials: How to search code using grepBrian SmithJuly 3, 20239 minute readgrep is a powerful tool for searching code from the terminal. This post will show you how to use grep and why it's an essential developer tool.Read more →Introducing AI Help (Beta): Your Companion for Web DevelopmentHermina CondeiJune 27, 20233 minute readWe're introducing an AI assistant powered by MDN and OpenAI GPT 3.5 to answer all your web development questions in real time.Read more →Learn how to use hue in CSS colors with HSLBrian SmithJune 26, 20237 minute readHues are a bright way to define colors in CSS. Learn about hues, color wheels, how to use color functions, and how you can create vibrant color palettes for your website using hue.Read more →Introducing the MDN Playground: Bring your code to life!Florian DiemingerJune 22, 20236 minute readMDN is launching a code Playground. Users can prototype ideas and expand all live samples into an interactive experience.Read more →MDN doc updates: CSS selectors & media queries, WebGPU & WebTransport APIs, Progressive web appsDipika BhattacharyaJune 13, 20236 minute readDiscover CSS :lang(), experimental media queries, manipulating graphics with WebGPU, client-server communication with WebTransport, ECMAScript module support, and more.Read more →How to draw any regular shape with just one JavaScript functionRuth JohnMay 26, 20234 minute readLearn how to use JavaScript to draw any regular shape to a HTML canvas with a single function, and how to modify it to draw multiple shapes.Read more →New reference pages on MDN for JavaScript regular expressionsBrian SmithMay 23, 20235 minute readSee the latest updates to the MDN reference pages about JavaScript regular expressions, including new sections on sub-features and browser compatibility information.Read more →Celebrating Global Accessibility Awareness DaySchalk NeethlingMay 18, 20236 minute readIn celebration of Global Accessibility Awareness Day in 2023, we share some tools and guidelines to help you make the web more accessible.Read more →Using HTML landmark roles to improve accessibilitySchalk NeethlingMay 15, 202311 minute readLearn what HTML landmark roles are, how they improve accessibility, and how you can include them on your website effectively.Read more →Introducing Baseline: a unified view of stable web featuresHermina CondeiMay 10, 20233 minute readMDN leads the way in implementing WebDX community group's efforts, delivering a clear and simple baseline for the web platform to developers.Read more →How :not() chains multiple selectorsDipika BhattacharyaMay 5, 20234 minute readLearn how the CSS `:not()` pseudo-class behaves when multiple selectors are passed as argument.Read more →New functions, gradients, and hues in CSS colors (Level 4)Brian SmithMay 3, 20239 minute readLearn what's new in CSS Colors Module Level 4, including color spaces, color functions, fancy gradients, and support for wide-gamut displays.Read more →Welcome to the MDN blogRuth JohnMay 3, 20232 minute readThe MDN blog publishes web development news, tutorials, and insights as an extension of MDN Web Docs, helping you discover, learn, and create for the web.Read more →\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nJavaScript referenceThe JavaScript reference serves as a repository of facts about the JavaScript language. The entire language is described here in detail. As you write JavaScript code, you'll refer to these pages often (thus the title "JavaScript reference").
The JavaScript language is intended to be used within some larger environment, be it a browser, server-side scripts, or similar. For the most part, this reference attempts to be environment-agnostic and does not target a web browser environment.
If you are new to JavaScript, start with the guide. Once you have a firm grasp of the fundamentals, you can use the reference to get more details on individual objects and language constructs.Built-insJavaScript standard built-in objects, along with their methods and properties.Value properties
globalThis
Infinity
NaN
undefined
Function properties
eval()
isFinite()
isNaN()
parseFloat()
parseInt()
decodeURI()
decodeURIComponent()
encodeURI()
encodeURIComponent()
escape() 
Deprecated

unescape() 
Deprecated

Fundamental objects
Object
Function
Boolean
Symbol
Error objects
Error
AggregateError
EvalError
RangeError
ReferenceError
SyntaxError
TypeError
URIError
InternalError 
Non-standard

Numbers and dates
Number
BigInt
Math
Date
Temporal
Text processing
String
RegExp
Indexed collections
Array
Int8Array
Uint8Array
Uint8ClampedArray
Int16Array
Uint16Array
Int32Array
Uint32Array
BigInt64Array
BigUint64Array
Float16Array
Float32Array
Float64Array
Keyed collections
Map
Set
WeakMap
WeakSet
Structured data
ArrayBuffer
SharedArrayBuffer
DataView
Atomics
JSON
Managing memory
WeakRef
FinalizationRegistry
Control abstraction objects
Iterator
AsyncIterator
Promise
GeneratorFunction
AsyncGeneratorFunction
Generator
AsyncGenerator
AsyncFunction
Reflection
Reflect
Proxy
Internationalization
Intl
Intl.Collator
Intl.DateTimeFormat
Intl.DisplayNames
Intl.DurationFormat
Intl.ListFormat
Intl.Locale
Intl.NumberFormat
Intl.PluralRules
Intl.RelativeTimeFormat
Intl.Segmenter
StatementsJavaScript statements and declarationsControl flow
return
break
continue
throw
if...else
switch
try...catch
Declaring variables
var
let
const
Functions and classes
function
function*
async function
async function*
class
Iterations
do...while
for
for...in
for...of
for await...of
while
Others
Empty
Block
Expression statement
debugger
export
import
label
with 
Deprecated

Expressions and operatorsJavaScript expressions and operators.Primary expressions
this
Literals
[]
{}
function
class
function*
async function
async function*
/ab+c/i
`string`
( )
Left-hand-side expressions
Property accessors
?.
new
new.target
import.meta
super
import()
Increment and decrement
A++
A--
++A
--A
Unary operators
delete
void
typeof
+
-
~
!
await
Arithmetic operators
**
*
/
%
+ (Plus)
-
Relational operators
< (Less than)
> (Greater than)
<=
>=
instanceof
in
Equality operators
==
!=
===
!==
Bitwise shift operators
<<
>>
>>>
Binary bitwise operators
&
|
^
Binary logical operators
&&
||
??
Conditional (ternary) operator
(condition ? ifTrue : ifFalse)
Assignment operators
=
*=
/=
%=
+=
-=
<<=
>>=
>>>=
&=
^=
|=
**=
&&=
||=
??=
[a, b] = arr, { a, b } = obj
Yield operators
yield
yield*
Spread syntax
...obj
Comma operator
,
FunctionsJavaScript functions.

Arrow Functions
Default parameters
Rest parameters
arguments
Method definitions
getter
setter
ClassesJavaScript classes.

constructor
extends
Private properties
Public class fields
static
Static initialization blocks
Regular expressionsJavaScript regular expressions.

Backreference: \1, \2
Capturing group: (...)
Character class: [...], [^...]
Character class escape: \d, \D, \w, \W,  , \S
Character escape: \n, \u{...}
Disjunction: |
Input boundary assertion: ^, $
Literal character: a, b
Lookahead assertion: (?=...), (?!...)
Lookbehind assertion: (?<=...), (?<!...)
Modifier: (?ims-ims:...)
Named backreference: \k<name>
Named capturing group: (?<name>...)
Non-capturing group: (?:...)
Quantifier: *, +, ?, {n}, {n,}, {n,m}
Unicode character class escape: \p{...}, \P{...}
Wildcard: .
Word boundary assertion: \b, \B
Additional reference pages
Execution model
Lexical grammar
Data types and data structures
Iteration protocols
Trailing commas
Errors
Strict mode
Deprecated features\n\nJavaScript referenceThe JavaScript reference serves as a repository of facts about the JavaScript language. The entire language is described here in detail. As you write JavaScript code, you'll refer to these pages often (thus the title "JavaScript reference").
The JavaScript language is intended to be used within some larger environment, be it a browser, server-side scripts, or similar. For the most part, this reference attempts to be environment-agnostic and does not target a web browser environment.
If you are new to JavaScript, start with the guide. Once you have a firm grasp of the fundamentals, you can use the reference to get more details on individual objects and language constructs.Built-insJavaScript standard built-in objects, along with their methods and properties.Value properties
globalThis
Infinity
NaN
undefined
Function properties
eval()
isFinite()
isNaN()
parseFloat()
parseInt()
decodeURI()
decodeURIComponent()
encodeURI()
encodeURIComponent()
escape() 
Deprecated

unescape() 
Deprecated

Fundamental objects
Object
Function
Boolean
Symbol
Error objects
Error
AggregateError
EvalError
RangeError
ReferenceError
SyntaxError
TypeError
URIError
InternalError 
Non-standard

Numbers and dates
Number
BigInt
Math
Date
Temporal
Text processing
String
RegExp
Indexed collections
Array
Int8Array
Uint8Array
Uint8ClampedArray
Int16Array
Uint16Array
Int32Array
Uint32Array
BigInt64Array
BigUint64Array
Float16Array
Float32Array
Float64Array
Keyed collections
Map
Set
WeakMap
WeakSet
Structured data
ArrayBuffer
SharedArrayBuffer
DataView
Atomics
JSON
Managing memory
WeakRef
FinalizationRegistry
Control abstraction objects
Iterator
AsyncIterator
Promise
GeneratorFunction
AsyncGeneratorFunction
Generator
AsyncGenerator
AsyncFunction
Reflection
Reflect
Proxy
Internationalization
Intl
Intl.Collator
Intl.DateTimeFormat
Intl.DisplayNames
Intl.DurationFormat
Intl.ListFormat
Intl.Locale
Intl.NumberFormat
Intl.PluralRules
Intl.RelativeTimeFormat
Intl.Segmenter
StatementsJavaScript statements and declarationsControl flow
return
break
continue
throw
if...else
switch
try...catch
Declaring variables
var
let
const
Functions and classes
function
function*
async function
async function*
class
Iterations
do...while
for
for...in
for...of
for await...of
while
Others
Empty
Block
Expression statement
debugger
export
import
label
with 
Deprecated

Expressions and operatorsJavaScript expressions and operators.Primary expressions
this
Literals
[]
{}
function
class
function*
async function
async function*
/ab+c/i
`string`
( )
Left-hand-side expressions
Property accessors
?.
new
new.target
import.meta
super
import()
Increment and decrement
A++
A--
++A
--A
Unary operators
delete
void
typeof
+
-
~
!
await
Arithmetic operators
**
*
/
%
+ (Plus)
-
Relational operators
< (Less than)
> (Greater than)
<=
>=
instanceof
in
Equality operators
==
!=
===
!==
Bitwise shift operators
<<
>>
>>>
Binary bitwise operators
&
|
^
Binary logical operators
&&
||
??
Conditional (ternary) operator
(condition ? ifTrue : ifFalse)
Assignment operators
=
*=
/=
%=
+=
-=
<<=
>>=
>>>=
&=
^=
|=
**=
&&=
||=
??=
[a, b] = arr, { a, b } = obj
Yield operators
yield
yield*
Spread syntax
...obj
Comma operator
,
FunctionsJavaScript functions.

Arrow Functions
Default parameters
Rest parameters
arguments
Method definitions
getter
setter
ClassesJavaScript classes.

constructor
extends
Private properties
Public class fields
static
Static initialization blocks
Regular expressionsJavaScript regular expressions.

Backreference: \1, \2
Capturing group: (...)
Character class: [...], [^...]
Character class escape: \d, \D, \w, \W,  , \S
Character escape: \n, \u{...}
Disjunction: |
Input boundary assertion: ^, $
Literal character: a, b
Lookahead assertion: (?=...), (?!...)
Lookbehind assertion: (?<=...), (?<!...)
Modifier: (?ims-ims:...)
Named backreference: \k<name>
Named capturing group: (?<name>...)
Non-capturing group: (?:...)
Quantifier: *, +, ?, {n}, {n,}, {n,m}
Unicode character class escape: \p{...}, \P{...}
Wildcard: .
Word boundary assertion: \b, \B
Additional reference pages
Execution model
Lexical grammar
Data types and data structures
Iteration protocols
Trailing commas
Errors
Strict mode
Deprecated features
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 7, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJavaScript referenceThe JavaScript reference serves as a repository of facts about the JavaScript language. The entire language is described here in detail. As you write JavaScript code, you'll refer to these pages often (thus the title "JavaScript reference").
The JavaScript language is intended to be used within some larger environment, be it a browser, server-side scripts, or similar. For the most part, this reference attempts to be environment-agnostic and does not target a web browser environment.
If you are new to JavaScript, start with the guide. Once you have a firm grasp of the fundamentals, you can use the reference to get more details on individual objects and language constructs.Built-insJavaScript standard built-in objects, along with their methods and properties.Value properties
globalThis
Infinity
NaN
undefined
Function properties
eval()
isFinite()
isNaN()
parseFloat()
parseInt()
decodeURI()
decodeURIComponent()
encodeURI()
encodeURIComponent()
escape() 
Deprecated

unescape() 
Deprecated

Fundamental objects
Object
Function
Boolean
Symbol
Error objects
Error
AggregateError
EvalError
RangeError
ReferenceError
SyntaxError
TypeError
URIError
InternalError 
Non-standard

Numbers and dates
Number
BigInt
Math
Date
Temporal
Text processing
String
RegExp
Indexed collections
Array
Int8Array
Uint8Array
Uint8ClampedArray
Int16Array
Uint16Array
Int32Array
Uint32Array
BigInt64Array
BigUint64Array
Float16Array
Float32Array
Float64Array
Keyed collections
Map
Set
WeakMap
WeakSet
Structured data
ArrayBuffer
SharedArrayBuffer
DataView
Atomics
JSON
Managing memory
WeakRef
FinalizationRegistry
Control abstraction objects
Iterator
AsyncIterator
Promise
GeneratorFunction
AsyncGeneratorFunction
Generator
AsyncGenerator
AsyncFunction
Reflection
Reflect
Proxy
Internationalization
Intl
Intl.Collator
Intl.DateTimeFormat
Intl.DisplayNames
Intl.DurationFormat
Intl.ListFormat
Intl.Locale
Intl.NumberFormat
Intl.PluralRules
Intl.RelativeTimeFormat
Intl.Segmenter
StatementsJavaScript statements and declarationsControl flow
return
break
continue
throw
if...else
switch
try...catch
Declaring variables
var
let
const
Functions and classes
function
function*
async function
async function*
class
Iterations
do...while
for
for...in
for...of
for await...of
while
Others
Empty
Block
Expression statement
debugger
export
import
label
with 
Deprecated

Expressions and operatorsJavaScript expressions and operators.Primary expressions
this
Literals
[]
{}
function
class
function*
async function
async function*
/ab+c/i
`string`
( )
Left-hand-side expressions
Property accessors
?.
new
new.target
import.meta
super
import()
Increment and decrement
A++
A--
++A
--A
Unary operators
delete
void
typeof
+
-
~
!
await
Arithmetic operators
**
*
/
%
+ (Plus)
-
Relational operators
< (Less than)
> (Greater than)
<=
>=
instanceof
in
Equality operators
==
!=
===
!==
Bitwise shift operators
<<
>>
>>>
Binary bitwise operators
&
|
^
Binary logical operators
&&
||
??
Conditional (ternary) operator
(condition ? ifTrue : ifFalse)
Assignment operators
=
*=
/=
%=
+=
-=
<<=
>>=
>>>=
&=
^=
|=
**=
&&=
||=
??=
[a, b] = arr, { a, b } = obj
Yield operators
yield
yield*
Spread syntax
...obj
Comma operator
,
FunctionsJavaScript functions.

Arrow Functions
Default parameters
Rest parameters
arguments
Method definitions
getter
setter
ClassesJavaScript classes.

constructor
extends
Private properties
Public class fields
static
Static initialization blocks
Regular expressionsJavaScript regular expressions.

Backreference: \1, \2
Capturing group: (...)
Character class: [...], [^...]
Character class escape: \d, \D, \w, \W,  , \S
Character escape: \n, \u{...}
Disjunction: |
Input boundary assertion: ^, $
Literal character: a, b
Lookahead assertion: (?=...), (?!...)
Lookbehind assertion: (?<=...), (?<!...)
Modifier: (?ims-ims:...)
Named backreference: \k<name>
Named capturing group: (?<name>...)
Non-capturing group: (?:...)
Quantifier: *, +, ?, {n}, {n,}, {n,m}
Unicode character class escape: \p{...}, \P{...}
Wildcard: .
Word boundary assertion: \b, \B
Additional reference pages
Execution model
Lexical grammar
Data types and data structures
Iteration protocols
Trailing commas
Errors
Strict mode
Deprecated features
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 7, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nStandard built-in objectsThis chapter documents all of JavaScript's standard, built-in objects, including their methods and properties.
The term "global objects" (or standard built-in objects) here is not to be confused with the global object. Here, "global objects" refer to objects in the global scope.
The global object itself can be accessed using the this operator in the global scope. In fact, the global scope consists of the properties of the global object, including inherited properties, if any.
Other objects in the global scope are either created by the user script or provided by the host application. The host objects available in browser contexts are documented in the API reference.
For more information about the distinction between the DOM and core JavaScript, see JavaScript technologies overview.Standard objects by categoryValue propertiesThese global properties return a simple value. They have no properties or methods.

globalThis
Infinity
NaN
undefined
Function propertiesThese global functions—functions which are called globally, rather than on an object—directly return their results to the caller.

eval()
isFinite()
isNaN()
parseFloat()
parseInt()
decodeURI()
decodeURIComponent()
encodeURI()
encodeURIComponent()
escape() 
Deprecated

unescape() 
Deprecated

Fundamental objectsThese objects represent fundamental language constructs.

Object
Function
Boolean
Symbol
Error objectsError objects are a special type of fundamental object. They include the basic Error type, as well as several specialized error types.

Error
AggregateError
EvalError
RangeError
ReferenceError
SyntaxError
TypeError
URIError
InternalError 
Non-standard

Numbers and datesThese are the base objects representing numbers, dates, and mathematical calculations.

Number
BigInt
Math
Date
Temporal
Text processingThese objects represent strings and support manipulating them.

String
RegExp
Indexed collectionsThese objects represent collections of data which are ordered by an index value. This includes (typed) arrays and array-like constructs.

Array
TypedArray
Int8Array
Uint8Array
Uint8ClampedArray
Int16Array
Uint16Array
Int32Array
Uint32Array
BigInt64Array
BigUint64Array
Float16Array
Float32Array
Float64Array
Keyed collectionsThese objects represent collections which use keys. The iterable collections (Map and Set) contain elements which are easily iterated in the order of insertion.

Map
Set
WeakMap
WeakSet
Structured dataThese objects represent and interact with structured data buffers and data coded using JavaScript Object Notation (JSON).

ArrayBuffer
SharedArrayBuffer
DataView
Atomics
JSON
Managing memoryThese objects interact with the garbage collection mechanism.

WeakRef
FinalizationRegistry
Control abstraction objectsControl abstractions can help to structure code, especially async code (without using deeply nested callbacks, for example).

Iterator
AsyncIterator
Promise
GeneratorFunction
AsyncGeneratorFunction
Generator
AsyncGenerator
AsyncFunction
Reflection
Reflect
Proxy
InternationalizationAdditions to the ECMAScript core for language-sensitive functionalities.

Intl
Intl.Collator
Intl.DateTimeFormat
Intl.DisplayNames
Intl.DurationFormat
Intl.ListFormat
Intl.Locale
Intl.NumberFormat
Intl.PluralRules
Intl.RelativeTimeFormat
Intl.Segmenter\n\nStandard built-in objectsThis chapter documents all of JavaScript's standard, built-in objects, including their methods and properties.
The term "global objects" (or standard built-in objects) here is not to be confused with the global object. Here, "global objects" refer to objects in the global scope.
The global object itself can be accessed using the this operator in the global scope. In fact, the global scope consists of the properties of the global object, including inherited properties, if any.
Other objects in the global scope are either created by the user script or provided by the host application. The host objects available in browser contexts are documented in the API reference.
For more information about the distinction between the DOM and core JavaScript, see JavaScript technologies overview.Standard objects by categoryValue propertiesThese global properties return a simple value. They have no properties or methods.

globalThis
Infinity
NaN
undefined
Function propertiesThese global functions—functions which are called globally, rather than on an object—directly return their results to the caller.

eval()
isFinite()
isNaN()
parseFloat()
parseInt()
decodeURI()
decodeURIComponent()
encodeURI()
encodeURIComponent()
escape() 
Deprecated

unescape() 
Deprecated

Fundamental objectsThese objects represent fundamental language constructs.

Object
Function
Boolean
Symbol
Error objectsError objects are a special type of fundamental object. They include the basic Error type, as well as several specialized error types.

Error
AggregateError
EvalError
RangeError
ReferenceError
SyntaxError
TypeError
URIError
InternalError 
Non-standard

Numbers and datesThese are the base objects representing numbers, dates, and mathematical calculations.

Number
BigInt
Math
Date
Temporal
Text processingThese objects represent strings and support manipulating them.

String
RegExp
Indexed collectionsThese objects represent collections of data which are ordered by an index value. This includes (typed) arrays and array-like constructs.

Array
TypedArray
Int8Array
Uint8Array
Uint8ClampedArray
Int16Array
Uint16Array
Int32Array
Uint32Array
BigInt64Array
BigUint64Array
Float16Array
Float32Array
Float64Array
Keyed collectionsThese objects represent collections which use keys. The iterable collections (Map and Set) contain elements which are easily iterated in the order of insertion.

Map
Set
WeakMap
WeakSet
Structured dataThese objects represent and interact with structured data buffers and data coded using JavaScript Object Notation (JSON).

ArrayBuffer
SharedArrayBuffer
DataView
Atomics
JSON
Managing memoryThese objects interact with the garbage collection mechanism.

WeakRef
FinalizationRegistry
Control abstraction objectsControl abstractions can help to structure code, especially async code (without using deeply nested callbacks, for example).

Iterator
AsyncIterator
Promise
GeneratorFunction
AsyncGeneratorFunction
Generator
AsyncGenerator
AsyncFunction
Reflection
Reflect
Proxy
InternationalizationAdditions to the ECMAScript core for language-sensitive functionalities.

Intl
Intl.Collator
Intl.DateTimeFormat
Intl.DisplayNames
Intl.DurationFormat
Intl.ListFormat
Intl.Locale
Intl.NumberFormat
Intl.PluralRules
Intl.RelativeTimeFormat
Intl.Segmenter
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 12, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nStandard built-in objectsThis chapter documents all of JavaScript's standard, built-in objects, including their methods and properties.
The term "global objects" (or standard built-in objects) here is not to be confused with the global object. Here, "global objects" refer to objects in the global scope.
The global object itself can be accessed using the this operator in the global scope. In fact, the global scope consists of the properties of the global object, including inherited properties, if any.
Other objects in the global scope are either created by the user script or provided by the host application. The host objects available in browser contexts are documented in the API reference.
For more information about the distinction between the DOM and core JavaScript, see JavaScript technologies overview.Standard objects by categoryValue propertiesThese global properties return a simple value. They have no properties or methods.

globalThis
Infinity
NaN
undefined
Function propertiesThese global functions—functions which are called globally, rather than on an object—directly return their results to the caller.

eval()
isFinite()
isNaN()
parseFloat()
parseInt()
decodeURI()
decodeURIComponent()
encodeURI()
encodeURIComponent()
escape() 
Deprecated

unescape() 
Deprecated

Fundamental objectsThese objects represent fundamental language constructs.

Object
Function
Boolean
Symbol
Error objectsError objects are a special type of fundamental object. They include the basic Error type, as well as several specialized error types.

Error
AggregateError
EvalError
RangeError
ReferenceError
SyntaxError
TypeError
URIError
InternalError 
Non-standard

Numbers and datesThese are the base objects representing numbers, dates, and mathematical calculations.

Number
BigInt
Math
Date
Temporal
Text processingThese objects represent strings and support manipulating them.

String
RegExp
Indexed collectionsThese objects represent collections of data which are ordered by an index value. This includes (typed) arrays and array-like constructs.

Array
TypedArray
Int8Array
Uint8Array
Uint8ClampedArray
Int16Array
Uint16Array
Int32Array
Uint32Array
BigInt64Array
BigUint64Array
Float16Array
Float32Array
Float64Array
Keyed collectionsThese objects represent collections which use keys. The iterable collections (Map and Set) contain elements which are easily iterated in the order of insertion.

Map
Set
WeakMap
WeakSet
Structured dataThese objects represent and interact with structured data buffers and data coded using JavaScript Object Notation (JSON).

ArrayBuffer
SharedArrayBuffer
DataView
Atomics
JSON
Managing memoryThese objects interact with the garbage collection mechanism.

WeakRef
FinalizationRegistry
Control abstraction objectsControl abstractions can help to structure code, especially async code (without using deeply nested callbacks, for example).

Iterator
AsyncIterator
Promise
GeneratorFunction
AsyncGeneratorFunction
Generator
AsyncGenerator
AsyncFunction
Reflection
Reflect
Proxy
InternationalizationAdditions to the ECMAScript core for language-sensitive functionalities.

Intl
Intl.Collator
Intl.DateTimeFormat
Intl.DisplayNames
Intl.DurationFormat
Intl.ListFormat
Intl.Locale
Intl.NumberFormat
Intl.PluralRules
Intl.RelativeTimeFormat
Intl.Segmenter
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 12, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIntlBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl namespace object contains several constructors as well as functionality common to the internationalization constructors and other language sensitive functions. Collectively, they comprise the ECMAScript Internationalization API, which provides language sensitive string comparison, number formatting, date and time formatting, and more.DescriptionUnlike most global objects, Intl is not a constructor. You cannot use it with the new operator or invoke the Intl object as a function. All properties and methods of Intl are static (just like the Math object).
The internationalization constructors as well as several language sensitive methods of other constructors (listed under See also) use a common pattern for identifying locales and determining the one they will actually use: they all accept locales and options arguments, and negotiate the requested locale(s) against the locales they support using an algorithm specified in the options.localeMatcher property.locales argumentThe locales argument is used to determine the locale used in a given operation. The JavaScript implementation examines locales, and then computes a locale it understands that comes closest to satisfying the expressed preference. locales may be:

undefined (or omitted): The implementation's default locale will be used.
A locale: A locale identifier or an Intl.Locale object that wraps a locale identifier.
A list of locales: Any other value, that will be converted into an object and then treated as an array of locales.

In the latter two cases, the actual locale used is the best-supported locale determined by locale negotiation. If a locale identifier is not a string or an object, a TypeError is thrown. If a locale identifier is a string that's syntactically invalid, a RangeError is thrown. If a locale identifier is well-formed but the implementation doesn't recognize it, it is ignored and the next locale in the list is considered, eventually falling back to the system's locale. However, you shouldn't rely on a particular locale name being ignored, because the implementation may add data for any locale in the future. For example, new Intl.DateTimeFormat("default") uses the implementation's default locale only because "default" is syntactically valid but not recognized as any locale.
A locale identifier is a string that consists of:

A language subtag with 2–3 or 5–8 letters
A script subtag with 4 letters Optional
A region subtag with either 2 letters or 3 digits Optional
One or more variant subtags (all of which must be unique), each with either 5–8 alphanumerals or a digit followed by 3 alphanumerals Optional
One or more BCP 47 extension sequences Optional
A private-use extension sequence Optional

Each subtag and sequence are separated by hyphens. Locale identifiers are case-insensitive ASCII. However, it's conventional to use title case (the first letter is capitalized, successive letters are lower case) for script subtags, upper case for region subtags, and lower case for everything else. For example:

"hi": Hindi (language)
"de-AT": German (language) as used in Austria (region)
"zh-Hans-CN": Chinese (language) written in simplified characters (script) as used in China (region)
"en-emodeng": English (language) in the "Early modern English" dialect (variant)

Subtags identifying languages, scripts, regions (including countries), and (rarely used) variants are registered in the IANA Language Subtag Registry. This registry is periodically updated over time, and implementations may not always be up to date, so don't rely too much on subtags being universally supported.
BCP 47 extension sequences consist of a single digit or letter (other than "x") and one or more two- to eight-letter or digit subtags separated by hyphens. Only one sequence is permitted for each digit or letter: "de-a-foo-a-foo" is invalid. BCP 47 extension subtags are defined in the Unicode CLDR Project. Currently only two extensions have defined semantics:


The "u" (Unicode) extension can be used to request additional customization of Intl API objects. Examples:

"de-DE-u-co-phonebk": Use the phonebook variant of the German sort order, which interprets umlauted vowels as corresponding character pairs: ä → ae, ö → oe, ü → ue.
"th-TH-u-nu-thai": Use Thai digits (๐, ๑, ๒, ๓, ๔, ๕, ๖, ๗, ๘, ๙) in number formatting.
"ja-JP-u-ca-japanese": Use the Japanese calendar in date and time formatting, so that 2013 is expressed as the year 25 of the Heisei period, or 平成 25.
"en-GB-u-ca-islamic-umalqura": use British English with the Umm al-Qura (Hijri) calendar, where the Gregorian date 14 October, 2017 is the Hijri date 24 Muharram, 1439.



The "t" (transformed) extension indicates transformed content: for example, text that was translated from another locale. No Intl functionality currently considers the "t" extension. However, this extension sometimes contains a nested locale (with no extensions): for example, the transformed extension in "de-t-en" contains the locale identifier for English. If a nested locale is present, it must be a valid locale identifier. For example, because "en-emodeng-emodeng" is invalid (because it contains a duplicate emodeng variant subtag), "de-t-en-emodeng-emodeng" is also invalid.


Finally, a private-use extension sequence using the letter "x" may appear, followed by one or more one- to eight-letter or digit subtags separated by hyphens. This allows applications to encode information for their own private use, that will be ignored by all Intl operations.options argumentThe options argument must be an object with properties that vary between constructors and functions. If the options argument is not provided or is undefined, default values are used for all properties.
One property is supported by all language sensitive constructors and functions: The localeMatcher property, whose value must be a string "lookup" or "best fit" and which selects one of the locale matching algorithms described below.Locale identification and negotiationThe list of locales specified by the locales argument, after Unicode extensions have been removed from them, is interpreted as a prioritized request from the application. The runtime compares it against the locales it has available and picks the best one available. Two matching algorithms exist: the "lookup" matcher follows the Lookup algorithm specified in BCP 47; the "best fit" matcher lets the runtime provide a locale that's at least, but possibly more, suited for the request than the result of the Lookup algorithm. If the application doesn't provide a locales argument, or the runtime doesn't have a locale that matches the request, then the runtime's default locale is used. The matcher can be selected using a property of the options argument (see below).
If the selected locale identifier had a Unicode extension sequence, that extension is now used to customize the constructed object or the behavior of the function. Each constructor or function supports only a subset of the keys defined for the Unicode extension, and the supported values often depend on the locale identifier. For example, the "co" key (collation) is only supported by Intl.Collator, and its "phonebk" value is only supported for German.Static properties
Intl.Collator

Constructor for collators, which are objects that enable language-sensitive string comparison.

Intl.DateTimeFormat

Constructor for objects that enable language-sensitive date and time formatting.

Intl.DisplayNames

Constructor for objects that enable the consistent translation of language, region and script display names.

Intl.DurationFormat

Constructor for objects that enable locale-sensitive duration formatting.

Intl.ListFormat

Constructor for objects that enable language-sensitive list formatting.

Intl.Locale

Constructor for objects that represents a Unicode locale identifier.

Intl.NumberFormat

Constructor for objects that enable language-sensitive number formatting.

Intl.PluralRules

Constructor for objects that enable plural-sensitive formatting and language-specific rules for plurals.

Intl.RelativeTimeFormat

Constructor for objects that enable language-sensitive relative time formatting.

Intl.Segmenter

Constructor for objects that enable locale-sensitive text segmentation.

Intl[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl". This property is used in Object.prototype.toString().

Static methods
Intl.getCanonicalLocales()

Returns canonical locale names.

Intl.supportedValuesOf()

Returns a sorted array containing the supported unique calendar, collation, currency, numbering systems, or unit values supported by the implementation.

ExamplesFormatting dates and numbersYou can use Intl to format dates and numbers in a form that's conventional for a specific language and region:
jsconst count = 26254.39;
const date = new Date("2012-05-24");

function log(locale) {
  console.log(
    `${new Intl.DateTimeFormat(locale).format(date)} ${new Intl.NumberFormat(
      locale,
    ).format(count)}`,
  );
}

log("en-US"); // 5/24/2012 26,254.39

log("de-DE"); // 24.5.2012 26.254,39
Using the browser's preferred languageInstead of passing a hardcoded locale name to the Intl methods, you can use the user's preferred language provided by navigator.language:
jsconst date = new Date("2012-05-24");

const formattedDate = new Intl.DateTimeFormat(navigator.language).format(date);

Alternatively, the navigator.languages property provides a sorted list of the user's preferred languages. This list can be passed directly to the Intl constructors to implement preference-based fallback selection of locales. The locale negotiation process is used to pick the most appropriate locale available:
jsconst count = 26254.39;

const formattedCount = new Intl.NumberFormat(navigator.languages).format(count);
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # intl-objectBrowser compatibilitySee also
Keyboard.getLayoutMap()
navigator.language
navigator.languages
The ECMAScript Internationalization API by Norbert Lindenberg (2012)\n\nIntlBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl namespace object contains several constructors as well as functionality common to the internationalization constructors and other language sensitive functions. Collectively, they comprise the ECMAScript Internationalization API, which provides language sensitive string comparison, number formatting, date and time formatting, and more.DescriptionUnlike most global objects, Intl is not a constructor. You cannot use it with the new operator or invoke the Intl object as a function. All properties and methods of Intl are static (just like the Math object).
The internationalization constructors as well as several language sensitive methods of other constructors (listed under See also) use a common pattern for identifying locales and determining the one they will actually use: they all accept locales and options arguments, and negotiate the requested locale(s) against the locales they support using an algorithm specified in the options.localeMatcher property.locales argumentThe locales argument is used to determine the locale used in a given operation. The JavaScript implementation examines locales, and then computes a locale it understands that comes closest to satisfying the expressed preference. locales may be:

undefined (or omitted): The implementation's default locale will be used.
A locale: A locale identifier or an Intl.Locale object that wraps a locale identifier.
A list of locales: Any other value, that will be converted into an object and then treated as an array of locales.

In the latter two cases, the actual locale used is the best-supported locale determined by locale negotiation. If a locale identifier is not a string or an object, a TypeError is thrown. If a locale identifier is a string that's syntactically invalid, a RangeError is thrown. If a locale identifier is well-formed but the implementation doesn't recognize it, it is ignored and the next locale in the list is considered, eventually falling back to the system's locale. However, you shouldn't rely on a particular locale name being ignored, because the implementation may add data for any locale in the future. For example, new Intl.DateTimeFormat("default") uses the implementation's default locale only because "default" is syntactically valid but not recognized as any locale.
A locale identifier is a string that consists of:

A language subtag with 2–3 or 5–8 letters
A script subtag with 4 letters Optional
A region subtag with either 2 letters or 3 digits Optional
One or more variant subtags (all of which must be unique), each with either 5–8 alphanumerals or a digit followed by 3 alphanumerals Optional
One or more BCP 47 extension sequences Optional
A private-use extension sequence Optional

Each subtag and sequence are separated by hyphens. Locale identifiers are case-insensitive ASCII. However, it's conventional to use title case (the first letter is capitalized, successive letters are lower case) for script subtags, upper case for region subtags, and lower case for everything else. For example:

"hi": Hindi (language)
"de-AT": German (language) as used in Austria (region)
"zh-Hans-CN": Chinese (language) written in simplified characters (script) as used in China (region)
"en-emodeng": English (language) in the "Early modern English" dialect (variant)

Subtags identifying languages, scripts, regions (including countries), and (rarely used) variants are registered in the IANA Language Subtag Registry. This registry is periodically updated over time, and implementations may not always be up to date, so don't rely too much on subtags being universally supported.
BCP 47 extension sequences consist of a single digit or letter (other than "x") and one or more two- to eight-letter or digit subtags separated by hyphens. Only one sequence is permitted for each digit or letter: "de-a-foo-a-foo" is invalid. BCP 47 extension subtags are defined in the Unicode CLDR Project. Currently only two extensions have defined semantics:


The "u" (Unicode) extension can be used to request additional customization of Intl API objects. Examples:

"de-DE-u-co-phonebk": Use the phonebook variant of the German sort order, which interprets umlauted vowels as corresponding character pairs: ä → ae, ö → oe, ü → ue.
"th-TH-u-nu-thai": Use Thai digits (๐, ๑, ๒, ๓, ๔, ๕, ๖, ๗, ๘, ๙) in number formatting.
"ja-JP-u-ca-japanese": Use the Japanese calendar in date and time formatting, so that 2013 is expressed as the year 25 of the Heisei period, or 平成 25.
"en-GB-u-ca-islamic-umalqura": use British English with the Umm al-Qura (Hijri) calendar, where the Gregorian date 14 October, 2017 is the Hijri date 24 Muharram, 1439.



The "t" (transformed) extension indicates transformed content: for example, text that was translated from another locale. No Intl functionality currently considers the "t" extension. However, this extension sometimes contains a nested locale (with no extensions): for example, the transformed extension in "de-t-en" contains the locale identifier for English. If a nested locale is present, it must be a valid locale identifier. For example, because "en-emodeng-emodeng" is invalid (because it contains a duplicate emodeng variant subtag), "de-t-en-emodeng-emodeng" is also invalid.


Finally, a private-use extension sequence using the letter "x" may appear, followed by one or more one- to eight-letter or digit subtags separated by hyphens. This allows applications to encode information for their own private use, that will be ignored by all Intl operations.options argumentThe options argument must be an object with properties that vary between constructors and functions. If the options argument is not provided or is undefined, default values are used for all properties.
One property is supported by all language sensitive constructors and functions: The localeMatcher property, whose value must be a string "lookup" or "best fit" and which selects one of the locale matching algorithms described below.Locale identification and negotiationThe list of locales specified by the locales argument, after Unicode extensions have been removed from them, is interpreted as a prioritized request from the application. The runtime compares it against the locales it has available and picks the best one available. Two matching algorithms exist: the "lookup" matcher follows the Lookup algorithm specified in BCP 47; the "best fit" matcher lets the runtime provide a locale that's at least, but possibly more, suited for the request than the result of the Lookup algorithm. If the application doesn't provide a locales argument, or the runtime doesn't have a locale that matches the request, then the runtime's default locale is used. The matcher can be selected using a property of the options argument (see below).
If the selected locale identifier had a Unicode extension sequence, that extension is now used to customize the constructed object or the behavior of the function. Each constructor or function supports only a subset of the keys defined for the Unicode extension, and the supported values often depend on the locale identifier. For example, the "co" key (collation) is only supported by Intl.Collator, and its "phonebk" value is only supported for German.Static properties
Intl.Collator

Constructor for collators, which are objects that enable language-sensitive string comparison.

Intl.DateTimeFormat

Constructor for objects that enable language-sensitive date and time formatting.

Intl.DisplayNames

Constructor for objects that enable the consistent translation of language, region and script display names.

Intl.DurationFormat

Constructor for objects that enable locale-sensitive duration formatting.

Intl.ListFormat

Constructor for objects that enable language-sensitive list formatting.

Intl.Locale

Constructor for objects that represents a Unicode locale identifier.

Intl.NumberFormat

Constructor for objects that enable language-sensitive number formatting.

Intl.PluralRules

Constructor for objects that enable plural-sensitive formatting and language-specific rules for plurals.

Intl.RelativeTimeFormat

Constructor for objects that enable language-sensitive relative time formatting.

Intl.Segmenter

Constructor for objects that enable locale-sensitive text segmentation.

Intl[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl". This property is used in Object.prototype.toString().

Static methods
Intl.getCanonicalLocales()

Returns canonical locale names.

Intl.supportedValuesOf()

Returns a sorted array containing the supported unique calendar, collation, currency, numbering systems, or unit values supported by the implementation.

ExamplesFormatting dates and numbersYou can use Intl to format dates and numbers in a form that's conventional for a specific language and region:
jsconst count = 26254.39;
const date = new Date("2012-05-24");

function log(locale) {
  console.log(
    `${new Intl.DateTimeFormat(locale).format(date)} ${new Intl.NumberFormat(
      locale,
    ).format(count)}`,
  );
}

log("en-US"); // 5/24/2012 26,254.39

log("de-DE"); // 24.5.2012 26.254,39
Using the browser's preferred languageInstead of passing a hardcoded locale name to the Intl methods, you can use the user's preferred language provided by navigator.language:
jsconst date = new Date("2012-05-24");

const formattedDate = new Intl.DateTimeFormat(navigator.language).format(date);

Alternatively, the navigator.languages property provides a sorted list of the user's preferred languages. This list can be passed directly to the Intl constructors to implement preference-based fallback selection of locales. The locale negotiation process is used to pick the most appropriate locale available:
jsconst count = 26254.39;

const formattedCount = new Intl.NumberFormat(navigator.languages).format(count);
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # intl-objectBrowser compatibilitySee also
Keyboard.getLayoutMap()
navigator.language
navigator.languages
The ECMAScript Internationalization API by Norbert Lindenberg (2012)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIntlBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl namespace object contains several constructors as well as functionality common to the internationalization constructors and other language sensitive functions. Collectively, they comprise the ECMAScript Internationalization API, which provides language sensitive string comparison, number formatting, date and time formatting, and more.DescriptionUnlike most global objects, Intl is not a constructor. You cannot use it with the new operator or invoke the Intl object as a function. All properties and methods of Intl are static (just like the Math object).
The internationalization constructors as well as several language sensitive methods of other constructors (listed under See also) use a common pattern for identifying locales and determining the one they will actually use: they all accept locales and options arguments, and negotiate the requested locale(s) against the locales they support using an algorithm specified in the options.localeMatcher property.locales argumentThe locales argument is used to determine the locale used in a given operation. The JavaScript implementation examines locales, and then computes a locale it understands that comes closest to satisfying the expressed preference. locales may be:

undefined (or omitted): The implementation's default locale will be used.
A locale: A locale identifier or an Intl.Locale object that wraps a locale identifier.
A list of locales: Any other value, that will be converted into an object and then treated as an array of locales.

In the latter two cases, the actual locale used is the best-supported locale determined by locale negotiation. If a locale identifier is not a string or an object, a TypeError is thrown. If a locale identifier is a string that's syntactically invalid, a RangeError is thrown. If a locale identifier is well-formed but the implementation doesn't recognize it, it is ignored and the next locale in the list is considered, eventually falling back to the system's locale. However, you shouldn't rely on a particular locale name being ignored, because the implementation may add data for any locale in the future. For example, new Intl.DateTimeFormat("default") uses the implementation's default locale only because "default" is syntactically valid but not recognized as any locale.
A locale identifier is a string that consists of:

A language subtag with 2–3 or 5–8 letters
A script subtag with 4 letters Optional
A region subtag with either 2 letters or 3 digits Optional
One or more variant subtags (all of which must be unique), each with either 5–8 alphanumerals or a digit followed by 3 alphanumerals Optional
One or more BCP 47 extension sequences Optional
A private-use extension sequence Optional

Each subtag and sequence are separated by hyphens. Locale identifiers are case-insensitive ASCII. However, it's conventional to use title case (the first letter is capitalized, successive letters are lower case) for script subtags, upper case for region subtags, and lower case for everything else. For example:

"hi": Hindi (language)
"de-AT": German (language) as used in Austria (region)
"zh-Hans-CN": Chinese (language) written in simplified characters (script) as used in China (region)
"en-emodeng": English (language) in the "Early modern English" dialect (variant)

Subtags identifying languages, scripts, regions (including countries), and (rarely used) variants are registered in the IANA Language Subtag Registry. This registry is periodically updated over time, and implementations may not always be up to date, so don't rely too much on subtags being universally supported.
BCP 47 extension sequences consist of a single digit or letter (other than "x") and one or more two- to eight-letter or digit subtags separated by hyphens. Only one sequence is permitted for each digit or letter: "de-a-foo-a-foo" is invalid. BCP 47 extension subtags are defined in the Unicode CLDR Project. Currently only two extensions have defined semantics:


The "u" (Unicode) extension can be used to request additional customization of Intl API objects. Examples:

"de-DE-u-co-phonebk": Use the phonebook variant of the German sort order, which interprets umlauted vowels as corresponding character pairs: ä → ae, ö → oe, ü → ue.
"th-TH-u-nu-thai": Use Thai digits (๐, ๑, ๒, ๓, ๔, ๕, ๖, ๗, ๘, ๙) in number formatting.
"ja-JP-u-ca-japanese": Use the Japanese calendar in date and time formatting, so that 2013 is expressed as the year 25 of the Heisei period, or 平成 25.
"en-GB-u-ca-islamic-umalqura": use British English with the Umm al-Qura (Hijri) calendar, where the Gregorian date 14 October, 2017 is the Hijri date 24 Muharram, 1439.



The "t" (transformed) extension indicates transformed content: for example, text that was translated from another locale. No Intl functionality currently considers the "t" extension. However, this extension sometimes contains a nested locale (with no extensions): for example, the transformed extension in "de-t-en" contains the locale identifier for English. If a nested locale is present, it must be a valid locale identifier. For example, because "en-emodeng-emodeng" is invalid (because it contains a duplicate emodeng variant subtag), "de-t-en-emodeng-emodeng" is also invalid.


Finally, a private-use extension sequence using the letter "x" may appear, followed by one or more one- to eight-letter or digit subtags separated by hyphens. This allows applications to encode information for their own private use, that will be ignored by all Intl operations.options argumentThe options argument must be an object with properties that vary between constructors and functions. If the options argument is not provided or is undefined, default values are used for all properties.
One property is supported by all language sensitive constructors and functions: The localeMatcher property, whose value must be a string "lookup" or "best fit" and which selects one of the locale matching algorithms described below.Locale identification and negotiationThe list of locales specified by the locales argument, after Unicode extensions have been removed from them, is interpreted as a prioritized request from the application. The runtime compares it against the locales it has available and picks the best one available. Two matching algorithms exist: the "lookup" matcher follows the Lookup algorithm specified in BCP 47; the "best fit" matcher lets the runtime provide a locale that's at least, but possibly more, suited for the request than the result of the Lookup algorithm. If the application doesn't provide a locales argument, or the runtime doesn't have a locale that matches the request, then the runtime's default locale is used. The matcher can be selected using a property of the options argument (see below).
If the selected locale identifier had a Unicode extension sequence, that extension is now used to customize the constructed object or the behavior of the function. Each constructor or function supports only a subset of the keys defined for the Unicode extension, and the supported values often depend on the locale identifier. For example, the "co" key (collation) is only supported by Intl.Collator, and its "phonebk" value is only supported for German.Static properties
Intl.Collator

Constructor for collators, which are objects that enable language-sensitive string comparison.

Intl.DateTimeFormat

Constructor for objects that enable language-sensitive date and time formatting.

Intl.DisplayNames

Constructor for objects that enable the consistent translation of language, region and script display names.

Intl.DurationFormat

Constructor for objects that enable locale-sensitive duration formatting.

Intl.ListFormat

Constructor for objects that enable language-sensitive list formatting.

Intl.Locale

Constructor for objects that represents a Unicode locale identifier.

Intl.NumberFormat

Constructor for objects that enable language-sensitive number formatting.

Intl.PluralRules

Constructor for objects that enable plural-sensitive formatting and language-specific rules for plurals.

Intl.RelativeTimeFormat

Constructor for objects that enable language-sensitive relative time formatting.

Intl.Segmenter

Constructor for objects that enable locale-sensitive text segmentation.

Intl[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl". This property is used in Object.prototype.toString().

Static methods
Intl.getCanonicalLocales()

Returns canonical locale names.

Intl.supportedValuesOf()

Returns a sorted array containing the supported unique calendar, collation, currency, numbering systems, or unit values supported by the implementation.

ExamplesFormatting dates and numbersYou can use Intl to format dates and numbers in a form that's conventional for a specific language and region:
jsconst count = 26254.39;
const date = new Date("2012-05-24");

function log(locale) {
  console.log(
    `${new Intl.DateTimeFormat(locale).format(date)} ${new Intl.NumberFormat(
      locale,
    ).format(count)}`,
  );
}

log("en-US"); // 5/24/2012 26,254.39

log("de-DE"); // 24.5.2012 26.254,39
Using the browser's preferred languageInstead of passing a hardcoded locale name to the Intl methods, you can use the user's preferred language provided by navigator.language:
jsconst date = new Date("2012-05-24");

const formattedDate = new Intl.DateTimeFormat(navigator.language).format(date);

Alternatively, the navigator.languages property provides a sorted list of the user's preferred languages. This list can be passed directly to the Intl constructors to implement preference-based fallback selection of locales. The locale negotiation process is used to pick the most appropriate locale available:
jsconst count = 26254.39;

const formattedCount = new Intl.NumberFormat(navigator.languages).format(count);
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # intl-objectBrowser compatibilitySee also
Keyboard.getLayoutMap()
navigator.language
navigator.languages
The ECMAScript Internationalization API by Norbert Lindenberg (2012)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackDas Intl.NumberFormat-Objekt ermöglicht sprachabhängige Zahlenformatierung.Probieren Sie es aus
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Konstruktor
Intl.NumberFormat()

Erstellt ein neues NumberFormat-Objekt.

Statische Methoden
Intl.NumberFormat.supportedLocalesOf()

Gibt ein Array mit denjenigen der angegebenen Locales zurück, die unterstützt werden, ohne auf die Standard-Locale der Laufzeitumgebung zurückgreifen zu müssen.

InstanzeigenschaftenDiese Eigenschaften sind auf Intl.NumberFormat.prototype definiert und werden von allen Intl.NumberFormat-Instanzen geteilt.

Intl.NumberFormat.prototype.constructor

Die Konstruktorfunktion, die das Instanzobjekt erstellt hat. Für Intl.NumberFormat-Instanzen ist der ursprüngliche Wert der Intl.NumberFormat-Konstruktor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

Der ursprüngliche Wert der [Symbol.toStringTag]-Eigenschaft ist der String "Intl.NumberFormat". Diese Eigenschaft wird in Object.prototype.toString() verwendet.

Instanzmethoden
Intl.NumberFormat.prototype.format()

Getter-Funktion, die eine Zahl entsprechend der Locale und den Formatierungsoptionen dieses Intl.NumberFormat-Objekts formatiert.

Intl.NumberFormat.prototype.formatRange()

Getter-Funktion, die einen Bereich von Zahlen entsprechend der Locale und den Formatierungsoptionen des Intl.NumberFormat-Objekts formatiert, von dem die Methode aufgerufen wird.

Intl.NumberFormat.prototype.formatRangeToParts()

Gibt ein Array von Objekten zurück, das den Bereich der Zahlstrings in Teilen repräsentiert, die für benutzerdefinierte locale-abhängige Formatierung verwendet werden können.

Intl.NumberFormat.prototype.formatToParts()

Gibt ein Array von Objekten zurück, das den Zahlstring in Teilen repräsentiert, die für benutzerdefinierte locale-abhängige Formatierung verwendet werden können.

Intl.NumberFormat.prototype.resolvedOptions()

Gibt ein neues Objekt mit Eigenschaften zurück, die die Locale- und Kollationsoptionen widerspiegeln, die während der Initialisierung des Objekts berechnet wurden.

BeispieleGrundlegende VerwendungBei einfacher Verwendung ohne Angabe einer Locale wird ein formatierter String in der Standard-Locale und mit Standardoptionen zurückgegeben.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Verwendung von LocalesDieses Beispiel zeigt einige der Variationen in lokalisierten Zahlenformaten. Um das Format der Sprache zu erhalten, die in der Benutzeroberfläche Ihrer Anwendung verwendet wird, geben Sie diese Sprache (und eventuell einige Fallback-Sprachen) mit dem locales-Argument an:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Verwendung von OptionenDie Ergebnisse können mit dem options-Argument angepasst werden:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

Für eine vollständige Liste der Optionen, siehe die Seite Intl.NumberFormat() constructor.SpezifikationenSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser-KompatibilitätSiehe auch
Polyfill von Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackDas Intl.NumberFormat-Objekt ermöglicht sprachabhängige Zahlenformatierung.Probieren Sie es aus
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Konstruktor
Intl.NumberFormat()

Erstellt ein neues NumberFormat-Objekt.

Statische Methoden
Intl.NumberFormat.supportedLocalesOf()

Gibt ein Array mit denjenigen der angegebenen Locales zurück, die unterstützt werden, ohne auf die Standard-Locale der Laufzeitumgebung zurückgreifen zu müssen.

InstanzeigenschaftenDiese Eigenschaften sind auf Intl.NumberFormat.prototype definiert und werden von allen Intl.NumberFormat-Instanzen geteilt.

Intl.NumberFormat.prototype.constructor

Die Konstruktorfunktion, die das Instanzobjekt erstellt hat. Für Intl.NumberFormat-Instanzen ist der ursprüngliche Wert der Intl.NumberFormat-Konstruktor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

Der ursprüngliche Wert der [Symbol.toStringTag]-Eigenschaft ist der String "Intl.NumberFormat". Diese Eigenschaft wird in Object.prototype.toString() verwendet.

Instanzmethoden
Intl.NumberFormat.prototype.format()

Getter-Funktion, die eine Zahl entsprechend der Locale und den Formatierungsoptionen dieses Intl.NumberFormat-Objekts formatiert.

Intl.NumberFormat.prototype.formatRange()

Getter-Funktion, die einen Bereich von Zahlen entsprechend der Locale und den Formatierungsoptionen des Intl.NumberFormat-Objekts formatiert, von dem die Methode aufgerufen wird.

Intl.NumberFormat.prototype.formatRangeToParts()

Gibt ein Array von Objekten zurück, das den Bereich der Zahlstrings in Teilen repräsentiert, die für benutzerdefinierte locale-abhängige Formatierung verwendet werden können.

Intl.NumberFormat.prototype.formatToParts()

Gibt ein Array von Objekten zurück, das den Zahlstring in Teilen repräsentiert, die für benutzerdefinierte locale-abhängige Formatierung verwendet werden können.

Intl.NumberFormat.prototype.resolvedOptions()

Gibt ein neues Objekt mit Eigenschaften zurück, die die Locale- und Kollationsoptionen widerspiegeln, die während der Initialisierung des Objekts berechnet wurden.

BeispieleGrundlegende VerwendungBei einfacher Verwendung ohne Angabe einer Locale wird ein formatierter String in der Standard-Locale und mit Standardoptionen zurückgegeben.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Verwendung von LocalesDieses Beispiel zeigt einige der Variationen in lokalisierten Zahlenformaten. Um das Format der Sprache zu erhalten, die in der Benutzeroberfläche Ihrer Anwendung verwendet wird, geben Sie diese Sprache (und eventuell einige Fallback-Sprachen) mit dem locales-Argument an:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Verwendung von OptionenDie Ergebnisse können mit dem options-Argument angepasst werden:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

Für eine vollständige Liste der Optionen, siehe die Seite Intl.NumberFormat() constructor.SpezifikationenSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser-KompatibilitätSiehe auch
Polyfill von Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()
MDN-Feedback-BoxWar diese Übersetzung hilfreich?JaNeinDiese Seite wurde automatisch aus dem Englischen übersetzt.Übersetzung auf GitHub anzeigen • Fehler mit dieser Übersetzung melden\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackDas Intl.NumberFormat-Objekt ermöglicht sprachabhängige Zahlenformatierung.Probieren Sie es aus
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Konstruktor
Intl.NumberFormat()

Erstellt ein neues NumberFormat-Objekt.

Statische Methoden
Intl.NumberFormat.supportedLocalesOf()

Gibt ein Array mit denjenigen der angegebenen Locales zurück, die unterstützt werden, ohne auf die Standard-Locale der Laufzeitumgebung zurückgreifen zu müssen.

InstanzeigenschaftenDiese Eigenschaften sind auf Intl.NumberFormat.prototype definiert und werden von allen Intl.NumberFormat-Instanzen geteilt.

Intl.NumberFormat.prototype.constructor

Die Konstruktorfunktion, die das Instanzobjekt erstellt hat. Für Intl.NumberFormat-Instanzen ist der ursprüngliche Wert der Intl.NumberFormat-Konstruktor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

Der ursprüngliche Wert der [Symbol.toStringTag]-Eigenschaft ist der String "Intl.NumberFormat". Diese Eigenschaft wird in Object.prototype.toString() verwendet.

Instanzmethoden
Intl.NumberFormat.prototype.format()

Getter-Funktion, die eine Zahl entsprechend der Locale und den Formatierungsoptionen dieses Intl.NumberFormat-Objekts formatiert.

Intl.NumberFormat.prototype.formatRange()

Getter-Funktion, die einen Bereich von Zahlen entsprechend der Locale und den Formatierungsoptionen des Intl.NumberFormat-Objekts formatiert, von dem die Methode aufgerufen wird.

Intl.NumberFormat.prototype.formatRangeToParts()

Gibt ein Array von Objekten zurück, das den Bereich der Zahlstrings in Teilen repräsentiert, die für benutzerdefinierte locale-abhängige Formatierung verwendet werden können.

Intl.NumberFormat.prototype.formatToParts()

Gibt ein Array von Objekten zurück, das den Zahlstring in Teilen repräsentiert, die für benutzerdefinierte locale-abhängige Formatierung verwendet werden können.

Intl.NumberFormat.prototype.resolvedOptions()

Gibt ein neues Objekt mit Eigenschaften zurück, die die Locale- und Kollationsoptionen widerspiegeln, die während der Initialisierung des Objekts berechnet wurden.

BeispieleGrundlegende VerwendungBei einfacher Verwendung ohne Angabe einer Locale wird ein formatierter String in der Standard-Locale und mit Standardoptionen zurückgegeben.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Verwendung von LocalesDieses Beispiel zeigt einige der Variationen in lokalisierten Zahlenformaten. Um das Format der Sprache zu erhalten, die in der Benutzeroberfläche Ihrer Anwendung verwendet wird, geben Sie diese Sprache (und eventuell einige Fallback-Sprachen) mit dem locales-Argument an:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Verwendung von OptionenDie Ergebnisse können mit dem options-Argument angepasst werden:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

Für eine vollständige Liste der Optionen, siehe die Seite Intl.NumberFormat() constructor.SpezifikationenSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser-KompatibilitätSiehe auch
Polyfill von Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()
MDN-Feedback-BoxWar diese Übersetzung hilfreich?JaNeinDiese Seite wurde automatisch aus dem Englischen übersetzt.Übersetzung auf GitHub anzeigen • Fehler mit dieser Übersetzung melden\n\n\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackEl objecto Intl.NumberFormat habilita el formato numérico de acuerdo al lenguaje.Pruébalo
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Crea un nuevo objecto NumberFormat.

Métodos estaticos
Intl.NumberFormat.supportedLocalesOf()

Regresa un arreglo con idiomas soportados sin necesidad de recurrir a la configuración por defecto en el entorno de ejecución.

Métodos de instancia
Intl.NumberFormat.prototype.format()

Función de acceso que formatea un número de acuerdo al lenguaje y a las opciones de formato de este objeto Intl.NumberFormat.

Intl.NumberFormat.prototype.formatToParts()

Devuelve un Array de objetos que representan la cadena de números en partes que se pueden usar para el formato personalizado que reconoce la configuración regional.

Intl.NumberFormat.prototype.formatRange()

Función de acceso que formatea un rango de números de acuerdo a la configuración region y a las opciones de formato del objeto Intl.NumberFormat desde el que se llama al método.

Intl.NumberFormat.prototype.formatRangeToParts()

Devuelve un Array de objetos que representan el rango de cadenas de números en partes que se pueden usar para el formato personalizado que reconoce la configuración regional.

Intl.NumberFormat.prototype.resolvedOptions()

Devuelve un nuevo objeto con propiedades que reflejan la configuración regional y las opciones de intercalación calculadas durante la inicialización del objeto.

EjemploUso básicoEn el uso básico sin especificar una configuración regional, se devuelve una cadena formateada en la configuración regional predeterminada y con opciones predeterminadas.
jsvar number = 3500;

console.log(new Intl.NumberFormat().format(number));
// → '3,500' si está en la region de Estados Unidos
Utilizando la configuración regionalEste ejemplo muestra algunas de las variaciones en los formatos de números por región.
Para obtener el formato del idioma usado en la interfaz de usuario de tu aplicación, asegúrate de especificar dicho idioma (y de ser posible alternativas) utilizando el argumento locales:
jsvar number = 123456.789;

// En el alemán la coma se utiliza como separador decimal y el punto para los millares
console.log(new Intl.NumberFormat("de-DE").format(number));
// → 123.456,789

// En la mayoría de los países de lengua arábiga se utilizan también símbolos arábigos
console.log(new Intl.NumberFormat("ar-EG").format(number));
// → ١٢٣٤٥٦٫٧٨٩

// En la India se utilizan separadores millares/lakh/crore
console.log(new Intl.NumberFormat("en-IN").format(number));
// → 1,23,456.789

// La clave de extensión nu requiere un sistema de numeración, p.ej. el decimal chino
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// → 一二三,四五六.七八九

// Cuando se requiera un lenguaje que pudiera no ser soportado, como es el caso del Balinés
// se recomienda incluir un lenguaje alternativo, en éste caso Indonesio
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// → 123.456,789
Usando opcionesLos resultados se pueden personalizar usando el argumento opciones:
jsvar number = 123456.789;

// Se establece un formato de divisa
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// → 123.456,79 €

// El yen japonés no tiene ninguna unidad menor
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// → ￥123,457

// Limitamos a tres los dígitos significativos
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// → 1,23,000
Usando estilos y unidadesjsconsole.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// → 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// → 16 litros
Polyfillformatjs Intl.NumberFormat polyfillEspecificacionesSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsCompatibilidad con navegadoresVéase también
Intl\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackEl objecto Intl.NumberFormat habilita el formato numérico de acuerdo al lenguaje.Pruébalo
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Crea un nuevo objecto NumberFormat.

Métodos estaticos
Intl.NumberFormat.supportedLocalesOf()

Regresa un arreglo con idiomas soportados sin necesidad de recurrir a la configuración por defecto en el entorno de ejecución.

Métodos de instancia
Intl.NumberFormat.prototype.format()

Función de acceso que formatea un número de acuerdo al lenguaje y a las opciones de formato de este objeto Intl.NumberFormat.

Intl.NumberFormat.prototype.formatToParts()

Devuelve un Array de objetos que representan la cadena de números en partes que se pueden usar para el formato personalizado que reconoce la configuración regional.

Intl.NumberFormat.prototype.formatRange()

Función de acceso que formatea un rango de números de acuerdo a la configuración region y a las opciones de formato del objeto Intl.NumberFormat desde el que se llama al método.

Intl.NumberFormat.prototype.formatRangeToParts()

Devuelve un Array de objetos que representan el rango de cadenas de números en partes que se pueden usar para el formato personalizado que reconoce la configuración regional.

Intl.NumberFormat.prototype.resolvedOptions()

Devuelve un nuevo objeto con propiedades que reflejan la configuración regional y las opciones de intercalación calculadas durante la inicialización del objeto.

EjemploUso básicoEn el uso básico sin especificar una configuración regional, se devuelve una cadena formateada en la configuración regional predeterminada y con opciones predeterminadas.
jsvar number = 3500;

console.log(new Intl.NumberFormat().format(number));
// → '3,500' si está en la region de Estados Unidos
Utilizando la configuración regionalEste ejemplo muestra algunas de las variaciones en los formatos de números por región.
Para obtener el formato del idioma usado en la interfaz de usuario de tu aplicación, asegúrate de especificar dicho idioma (y de ser posible alternativas) utilizando el argumento locales:
jsvar number = 123456.789;

// En el alemán la coma se utiliza como separador decimal y el punto para los millares
console.log(new Intl.NumberFormat("de-DE").format(number));
// → 123.456,789

// En la mayoría de los países de lengua arábiga se utilizan también símbolos arábigos
console.log(new Intl.NumberFormat("ar-EG").format(number));
// → ١٢٣٤٥٦٫٧٨٩

// En la India se utilizan separadores millares/lakh/crore
console.log(new Intl.NumberFormat("en-IN").format(number));
// → 1,23,456.789

// La clave de extensión nu requiere un sistema de numeración, p.ej. el decimal chino
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// → 一二三,四五六.七八九

// Cuando se requiera un lenguaje que pudiera no ser soportado, como es el caso del Balinés
// se recomienda incluir un lenguaje alternativo, en éste caso Indonesio
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// → 123.456,789
Usando opcionesLos resultados se pueden personalizar usando el argumento opciones:
jsvar number = 123456.789;

// Se establece un formato de divisa
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// → 123.456,79 €

// El yen japonés no tiene ninguna unidad menor
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// → ￥123,457

// Limitamos a tres los dígitos significativos
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// → 1,23,000
Usando estilos y unidadesjsconsole.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// → 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// → 16 litros
Polyfillformatjs Intl.NumberFormat polyfillEspecificacionesSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsCompatibilidad con navegadoresVéase también
Intl
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 11 abr 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackEl objecto Intl.NumberFormat habilita el formato numérico de acuerdo al lenguaje.Pruébalo
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Crea un nuevo objecto NumberFormat.

Métodos estaticos
Intl.NumberFormat.supportedLocalesOf()

Regresa un arreglo con idiomas soportados sin necesidad de recurrir a la configuración por defecto en el entorno de ejecución.

Métodos de instancia
Intl.NumberFormat.prototype.format()

Función de acceso que formatea un número de acuerdo al lenguaje y a las opciones de formato de este objeto Intl.NumberFormat.

Intl.NumberFormat.prototype.formatToParts()

Devuelve un Array de objetos que representan la cadena de números en partes que se pueden usar para el formato personalizado que reconoce la configuración regional.

Intl.NumberFormat.prototype.formatRange()

Función de acceso que formatea un rango de números de acuerdo a la configuración region y a las opciones de formato del objeto Intl.NumberFormat desde el que se llama al método.

Intl.NumberFormat.prototype.formatRangeToParts()

Devuelve un Array de objetos que representan el rango de cadenas de números en partes que se pueden usar para el formato personalizado que reconoce la configuración regional.

Intl.NumberFormat.prototype.resolvedOptions()

Devuelve un nuevo objeto con propiedades que reflejan la configuración regional y las opciones de intercalación calculadas durante la inicialización del objeto.

EjemploUso básicoEn el uso básico sin especificar una configuración regional, se devuelve una cadena formateada en la configuración regional predeterminada y con opciones predeterminadas.
jsvar number = 3500;

console.log(new Intl.NumberFormat().format(number));
// → '3,500' si está en la region de Estados Unidos
Utilizando la configuración regionalEste ejemplo muestra algunas de las variaciones en los formatos de números por región.
Para obtener el formato del idioma usado en la interfaz de usuario de tu aplicación, asegúrate de especificar dicho idioma (y de ser posible alternativas) utilizando el argumento locales:
jsvar number = 123456.789;

// En el alemán la coma se utiliza como separador decimal y el punto para los millares
console.log(new Intl.NumberFormat("de-DE").format(number));
// → 123.456,789

// En la mayoría de los países de lengua arábiga se utilizan también símbolos arábigos
console.log(new Intl.NumberFormat("ar-EG").format(number));
// → ١٢٣٤٥٦٫٧٨٩

// En la India se utilizan separadores millares/lakh/crore
console.log(new Intl.NumberFormat("en-IN").format(number));
// → 1,23,456.789

// La clave de extensión nu requiere un sistema de numeración, p.ej. el decimal chino
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// → 一二三,四五六.七八九

// Cuando se requiera un lenguaje que pudiera no ser soportado, como es el caso del Balinés
// se recomienda incluir un lenguaje alternativo, en éste caso Indonesio
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// → 123.456,789
Usando opcionesLos resultados se pueden personalizar usando el argumento opciones:
jsvar number = 123456.789;

// Se establece un formato de divisa
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// → 123.456,79 €

// El yen japonés no tiene ninguna unidad menor
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// → ￥123,457

// Limitamos a tres los dígitos significativos
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// → 1,23,000
Usando estilos y unidadesjsconsole.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// → 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// → 16 litros
Polyfillformatjs Intl.NumberFormat polyfillEspecificacionesSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsCompatibilidad con navegadoresVéase también
Intl
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 11 abr 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackL'objet Intl.NumberFormat permet de formater des nombres en fonction de la locale.Exemple interactif
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructeur
Intl.NumberFormat()

Crée un nouvel objet NumberFormat.

Méthodes statiques
Intl.NumberFormat.supportedLocalesOf()

Renvoie un tableau qui contient les locales, parmi celles fournies en arguments, qui sont prises en charge sans avoir à recourir à la locale par défaut de l'environnement d'exécution.

Méthodes des instances
Intl.NumberFormat.prototype.format()

Un accesseur qui formate un nombre en fonction des options de locale et de formatage fournies par l'objet Intl.NumberFormat courant.

Intl.NumberFormat.prototype.formatToParts()

Renvoie un tableau d'objets représentant les fragments de la chaîne de caractères représentant le nombre et qui peuvent être utilisés pour un formatage spécifique en fonction de la locale.

Intl.NumberFormat.prototype.formatRange()

Un accesseur qui formate un intervalle de nombres en fonction des options de locale et de formatage fournies par l'objet Intl.NumberFormat courant.

Intl.NumberFormat.prototype.formatRangeToParts()

Renvoie un tableau d'objets représentant les fragments de la chaîne de caractères représentant l'intervalle numérique et qui peuvent être utilisés pour un formatage spécifique en fonction de la locale.

Intl.NumberFormat.prototype.resolvedOptions()

Renvoie un nouvel objet dont les propriétés reflètent les options de locale et de collation calculées à l'initialisation de l'objet.

ExemplesUtilisation simpleSans indiquer de locale ou d'options, le résultat sera une chaîne de caractères avec la locale et les options par défaut :
jsvar nombre = 3500;

console.log(new Intl.NumberFormat().format(nombre));
// → "3 500" pour la locale fr
Utiliser localesCet exemple illustre les variations possibles des formats numériques localisés. Si vous souhaitez que votre application utilise le format de la locale de l'utilisateur, assurez vous de l'indiquer via l'argument locales (voire avec d'autres locales de secours) :
jsvar nombre = 123456.789;

// L'allemand utilise la virgule comme séparateur décimal
// et un point pour indiquer les milliers
console.log(new Intl.NumberFormat("de-DE").format(nombre));
// → 123.456,789

// Dans la plupart des pays arabophones, on utilise les
// chiffres arabo-hindîs
console.log(new Intl.NumberFormat("ar-EG").format(nombre));
// → ١٢٣٤٥٦٫٧٨٩

// L'indien utilise des séparateurs pour les milliers,
//les lakhs et les crores
console.log(new Intl.NumberFormat("en-IN").format(nombre));
// → 1,23,456.789

// La clé d'extension nu indique une l'utilisation d'un système numérique
// par exemple le système chinois
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(nombre));
// → 一二三,四五六.七八九

// Lorsqu'une locale n'est pas supportée (par exemple le balinais)
// on peut inclure une locale de secours (ici l'indonésien)
console.log(new Intl.NumberFormat(["ban", "id"]).format(nombre));
// → 123.456,789
Utiliser optionsLes résultats fournis peuvent être paramétrés grâce à l'argument options :
jsvar nombre = 123456.789;

// on affiche une devise avec le style "currency"
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    nombre,
  ),
);
// → 123.456,79 €

// Le yen japonais n'a pas de centimes
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    nombre,
  ),
);
// → ￥123,457

// On se limite ici à trois chiffres significatifs
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    nombre,
  ),
);
// → 1,23,000
Utiliser les options style et unitjsconsole.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// → 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// → 16 litres
SpécificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsCompatibilité des navigateursVoir aussi
Intl
Une prothèse d'émulation pour Intl.ListFormat avec la bibliothèque FormatJS\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackL'objet Intl.NumberFormat permet de formater des nombres en fonction de la locale.Exemple interactif
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructeur
Intl.NumberFormat()

Crée un nouvel objet NumberFormat.

Méthodes statiques
Intl.NumberFormat.supportedLocalesOf()

Renvoie un tableau qui contient les locales, parmi celles fournies en arguments, qui sont prises en charge sans avoir à recourir à la locale par défaut de l'environnement d'exécution.

Méthodes des instances
Intl.NumberFormat.prototype.format()

Un accesseur qui formate un nombre en fonction des options de locale et de formatage fournies par l'objet Intl.NumberFormat courant.

Intl.NumberFormat.prototype.formatToParts()

Renvoie un tableau d'objets représentant les fragments de la chaîne de caractères représentant le nombre et qui peuvent être utilisés pour un formatage spécifique en fonction de la locale.

Intl.NumberFormat.prototype.formatRange()

Un accesseur qui formate un intervalle de nombres en fonction des options de locale et de formatage fournies par l'objet Intl.NumberFormat courant.

Intl.NumberFormat.prototype.formatRangeToParts()

Renvoie un tableau d'objets représentant les fragments de la chaîne de caractères représentant l'intervalle numérique et qui peuvent être utilisés pour un formatage spécifique en fonction de la locale.

Intl.NumberFormat.prototype.resolvedOptions()

Renvoie un nouvel objet dont les propriétés reflètent les options de locale et de collation calculées à l'initialisation de l'objet.

ExemplesUtilisation simpleSans indiquer de locale ou d'options, le résultat sera une chaîne de caractères avec la locale et les options par défaut :
jsvar nombre = 3500;

console.log(new Intl.NumberFormat().format(nombre));
// → "3 500" pour la locale fr
Utiliser localesCet exemple illustre les variations possibles des formats numériques localisés. Si vous souhaitez que votre application utilise le format de la locale de l'utilisateur, assurez vous de l'indiquer via l'argument locales (voire avec d'autres locales de secours) :
jsvar nombre = 123456.789;

// L'allemand utilise la virgule comme séparateur décimal
// et un point pour indiquer les milliers
console.log(new Intl.NumberFormat("de-DE").format(nombre));
// → 123.456,789

// Dans la plupart des pays arabophones, on utilise les
// chiffres arabo-hindîs
console.log(new Intl.NumberFormat("ar-EG").format(nombre));
// → ١٢٣٤٥٦٫٧٨٩

// L'indien utilise des séparateurs pour les milliers,
//les lakhs et les crores
console.log(new Intl.NumberFormat("en-IN").format(nombre));
// → 1,23,456.789

// La clé d'extension nu indique une l'utilisation d'un système numérique
// par exemple le système chinois
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(nombre));
// → 一二三,四五六.七八九

// Lorsqu'une locale n'est pas supportée (par exemple le balinais)
// on peut inclure une locale de secours (ici l'indonésien)
console.log(new Intl.NumberFormat(["ban", "id"]).format(nombre));
// → 123.456,789
Utiliser optionsLes résultats fournis peuvent être paramétrés grâce à l'argument options :
jsvar nombre = 123456.789;

// on affiche une devise avec le style "currency"
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    nombre,
  ),
);
// → 123.456,79 €

// Le yen japonais n'a pas de centimes
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    nombre,
  ),
);
// → ￥123,457

// On se limite ici à trois chiffres significatifs
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    nombre,
  ),
);
// → 1,23,000
Utiliser les options style et unitjsconsole.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// → 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// → 16 litres
SpécificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsCompatibilité des navigateursVoir aussi
Intl
Une prothèse d'émulation pour Intl.ListFormat avec la bibliothèque FormatJS
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 17 févr. 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackL'objet Intl.NumberFormat permet de formater des nombres en fonction de la locale.Exemple interactif
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructeur
Intl.NumberFormat()

Crée un nouvel objet NumberFormat.

Méthodes statiques
Intl.NumberFormat.supportedLocalesOf()

Renvoie un tableau qui contient les locales, parmi celles fournies en arguments, qui sont prises en charge sans avoir à recourir à la locale par défaut de l'environnement d'exécution.

Méthodes des instances
Intl.NumberFormat.prototype.format()

Un accesseur qui formate un nombre en fonction des options de locale et de formatage fournies par l'objet Intl.NumberFormat courant.

Intl.NumberFormat.prototype.formatToParts()

Renvoie un tableau d'objets représentant les fragments de la chaîne de caractères représentant le nombre et qui peuvent être utilisés pour un formatage spécifique en fonction de la locale.

Intl.NumberFormat.prototype.formatRange()

Un accesseur qui formate un intervalle de nombres en fonction des options de locale et de formatage fournies par l'objet Intl.NumberFormat courant.

Intl.NumberFormat.prototype.formatRangeToParts()

Renvoie un tableau d'objets représentant les fragments de la chaîne de caractères représentant l'intervalle numérique et qui peuvent être utilisés pour un formatage spécifique en fonction de la locale.

Intl.NumberFormat.prototype.resolvedOptions()

Renvoie un nouvel objet dont les propriétés reflètent les options de locale et de collation calculées à l'initialisation de l'objet.

ExemplesUtilisation simpleSans indiquer de locale ou d'options, le résultat sera une chaîne de caractères avec la locale et les options par défaut :
jsvar nombre = 3500;

console.log(new Intl.NumberFormat().format(nombre));
// → "3 500" pour la locale fr
Utiliser localesCet exemple illustre les variations possibles des formats numériques localisés. Si vous souhaitez que votre application utilise le format de la locale de l'utilisateur, assurez vous de l'indiquer via l'argument locales (voire avec d'autres locales de secours) :
jsvar nombre = 123456.789;

// L'allemand utilise la virgule comme séparateur décimal
// et un point pour indiquer les milliers
console.log(new Intl.NumberFormat("de-DE").format(nombre));
// → 123.456,789

// Dans la plupart des pays arabophones, on utilise les
// chiffres arabo-hindîs
console.log(new Intl.NumberFormat("ar-EG").format(nombre));
// → ١٢٣٤٥٦٫٧٨٩

// L'indien utilise des séparateurs pour les milliers,
//les lakhs et les crores
console.log(new Intl.NumberFormat("en-IN").format(nombre));
// → 1,23,456.789

// La clé d'extension nu indique une l'utilisation d'un système numérique
// par exemple le système chinois
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(nombre));
// → 一二三,四五六.七八九

// Lorsqu'une locale n'est pas supportée (par exemple le balinais)
// on peut inclure une locale de secours (ici l'indonésien)
console.log(new Intl.NumberFormat(["ban", "id"]).format(nombre));
// → 123.456,789
Utiliser optionsLes résultats fournis peuvent être paramétrés grâce à l'argument options :
jsvar nombre = 123456.789;

// on affiche une devise avec le style "currency"
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    nombre,
  ),
);
// → 123.456,79 €

// Le yen japonais n'a pas de centimes
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    nombre,
  ),
);
// → ￥123,457

// On se limite ici à trois chiffres significatifs
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    nombre,
  ),
);
// → 1,23,000
Utiliser les options style et unitjsconsole.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// → 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// → 16 litres
SpécificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsCompatibilité des navigateursVoir aussi
Intl
Une prothèse d'émulation pour Intl.ListFormat avec la bibliothèque FormatJS
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 17 févr. 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackIntl.NumberFormat オブジェクトは、言語に依存した数値書式を可能にするオブジェクトのコンストラクターです。試してみましょう
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
コンストラクター
Intl.NumberFormat()

新しい NumberFormat オブジェクトを生成します。

静的メソッド
Intl.NumberFormat.supportedLocalesOf()

提供されたロケールのうち、実行時の既定のロケールにフォールバックせずにサポートされるものを配列に納めて返します。

インスタンスメソッド
Intl.NumberFormat.prototype.format

ゲッター関数で、ロケールに応じて、この NumberFormat オブジェクトのオプションを持つ数値を書式化する関数を返します。

Intl.NumberFormat.prototype.formatToParts()

オブジェクトの Array を返し、これは専用のロケールを意識した書式で使用することができる部品内の数値文字列を表します。

Intl.NumberFormat.prototype.resolvedOptions()

ロケールを反映しているプロパティとオブジェクトの初期化中に計算された照合オプションをもった新しいオブジェクトを返します。

例基本的な使用ロケールを指定しない基本的な使い方では、既定のロケールとオプションで書式化された文字列が返されます。
jsvar number = 3500;

console.log(new Intl.NumberFormat().format(number));
// → '3,500' 英語(U.S.)ロケールの場合
locales の使用この例では、地域による数値書式の違いをいくつか紹介します。アプリケーションのユーザーインターフェイスで使われた言語書式を得るには、言語 (およびフォールバック言語) を locales 引数により指定してください。
jsvar number = 123456.789;

// ドイツではカンマを小数、ピリオドを千単位の区切りに用います
console.log(new Intl.NumberFormat("de-DE").format(number));
// → 123.456,789

// ほとんどのアラビア語圏ではアラビア数字を用います
console.log(new Intl.NumberFormat("ar-EG").format(number));
// → ١٢٣٤٥٦٫٧٨٩

// インドでは thousands/lakh/crore 区切りが用いられます
console.log(new Intl.NumberFormat("en-IN").format(number));
// → 1,23,456.789

// nu 拡張キーにより漢数字などの番号方式が使えます
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// → 一二三,四五六.七八九

// バリ語のようにサポートされないかもしれない言語を用いる場合は
// フォールバック言語を含めます。次の例ではインドネシア語です。
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// → 123.456,789
options の使用options引数を使うと結果をカスタマイズできます。
jsvar number = 123456.789;

// 通貨フォーマットを用います
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// → 123.456,79 €

// 日本円には小数点以下がありません
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// → ￥123,457

// 有効数字を3桁に狭めます
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// → 1,23,000
style と unit の使用jsconsole.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "mile-per-hour",
  }).format(50),
);
// → 50 mi/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// → 16 litres
仕様書SpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsブラウザーの互換性関連情報
Intl\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackIntl.NumberFormat オブジェクトは、言語に依存した数値書式を可能にするオブジェクトのコンストラクターです。試してみましょう
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
コンストラクター
Intl.NumberFormat()

新しい NumberFormat オブジェクトを生成します。

静的メソッド
Intl.NumberFormat.supportedLocalesOf()

提供されたロケールのうち、実行時の既定のロケールにフォールバックせずにサポートされるものを配列に納めて返します。

インスタンスメソッド
Intl.NumberFormat.prototype.format

ゲッター関数で、ロケールに応じて、この NumberFormat オブジェクトのオプションを持つ数値を書式化する関数を返します。

Intl.NumberFormat.prototype.formatToParts()

オブジェクトの Array を返し、これは専用のロケールを意識した書式で使用することができる部品内の数値文字列を表します。

Intl.NumberFormat.prototype.resolvedOptions()

ロケールを反映しているプロパティとオブジェクトの初期化中に計算された照合オプションをもった新しいオブジェクトを返します。

例基本的な使用ロケールを指定しない基本的な使い方では、既定のロケールとオプションで書式化された文字列が返されます。
jsvar number = 3500;

console.log(new Intl.NumberFormat().format(number));
// → '3,500' 英語(U.S.)ロケールの場合
locales の使用この例では、地域による数値書式の違いをいくつか紹介します。アプリケーションのユーザーインターフェイスで使われた言語書式を得るには、言語 (およびフォールバック言語) を locales 引数により指定してください。
jsvar number = 123456.789;

// ドイツではカンマを小数、ピリオドを千単位の区切りに用います
console.log(new Intl.NumberFormat("de-DE").format(number));
// → 123.456,789

// ほとんどのアラビア語圏ではアラビア数字を用います
console.log(new Intl.NumberFormat("ar-EG").format(number));
// → ١٢٣٤٥٦٫٧٨٩

// インドでは thousands/lakh/crore 区切りが用いられます
console.log(new Intl.NumberFormat("en-IN").format(number));
// → 1,23,456.789

// nu 拡張キーにより漢数字などの番号方式が使えます
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// → 一二三,四五六.七八九

// バリ語のようにサポートされないかもしれない言語を用いる場合は
// フォールバック言語を含めます。次の例ではインドネシア語です。
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// → 123.456,789
options の使用options引数を使うと結果をカスタマイズできます。
jsvar number = 123456.789;

// 通貨フォーマットを用います
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// → 123.456,79 €

// 日本円には小数点以下がありません
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// → ￥123,457

// 有効数字を3桁に狭めます
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// → 1,23,000
style と unit の使用jsconsole.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "mile-per-hour",
  }).format(50),
);
// → 50 mi/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// → 16 litres
仕様書SpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsブラウザーの互換性関連情報
Intl
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025年2月27日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackIntl.NumberFormat オブジェクトは、言語に依存した数値書式を可能にするオブジェクトのコンストラクターです。試してみましょう
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
コンストラクター
Intl.NumberFormat()

新しい NumberFormat オブジェクトを生成します。

静的メソッド
Intl.NumberFormat.supportedLocalesOf()

提供されたロケールのうち、実行時の既定のロケールにフォールバックせずにサポートされるものを配列に納めて返します。

インスタンスメソッド
Intl.NumberFormat.prototype.format

ゲッター関数で、ロケールに応じて、この NumberFormat オブジェクトのオプションを持つ数値を書式化する関数を返します。

Intl.NumberFormat.prototype.formatToParts()

オブジェクトの Array を返し、これは専用のロケールを意識した書式で使用することができる部品内の数値文字列を表します。

Intl.NumberFormat.prototype.resolvedOptions()

ロケールを反映しているプロパティとオブジェクトの初期化中に計算された照合オプションをもった新しいオブジェクトを返します。

例基本的な使用ロケールを指定しない基本的な使い方では、既定のロケールとオプションで書式化された文字列が返されます。
jsvar number = 3500;

console.log(new Intl.NumberFormat().format(number));
// → '3,500' 英語(U.S.)ロケールの場合
locales の使用この例では、地域による数値書式の違いをいくつか紹介します。アプリケーションのユーザーインターフェイスで使われた言語書式を得るには、言語 (およびフォールバック言語) を locales 引数により指定してください。
jsvar number = 123456.789;

// ドイツではカンマを小数、ピリオドを千単位の区切りに用います
console.log(new Intl.NumberFormat("de-DE").format(number));
// → 123.456,789

// ほとんどのアラビア語圏ではアラビア数字を用います
console.log(new Intl.NumberFormat("ar-EG").format(number));
// → ١٢٣٤٥٦٫٧٨٩

// インドでは thousands/lakh/crore 区切りが用いられます
console.log(new Intl.NumberFormat("en-IN").format(number));
// → 1,23,456.789

// nu 拡張キーにより漢数字などの番号方式が使えます
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// → 一二三,四五六.七八九

// バリ語のようにサポートされないかもしれない言語を用いる場合は
// フォールバック言語を含めます。次の例ではインドネシア語です。
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// → 123.456,789
options の使用options引数を使うと結果をカスタマイズできます。
jsvar number = 123456.789;

// 通貨フォーマットを用います
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// → 123.456,79 €

// 日本円には小数点以下がありません
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// → ￥123,457

// 有効数字を3桁に狭めます
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// → 1,23,000
style と unit の使用jsconsole.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "mile-per-hour",
  }).format(50),
);
// → 50 mi/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// → 16 litres
仕様書SpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsブラウザーの互換性関連情報
Intl
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025年2月27日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackIntl.NumberFormat 은 언어에 맞는 숫자 서식을 지원하는 객체의 생성자입니다.시도해 보기
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
생성자
Intl.NumberFormat()

새로운 NumberFormat 객체를 생성합니다.

정적 메서드
Intl.NumberFormat.supportedLocalesOf()

주어진 로케일 목록 중, 런타임이 지원하는 항목을 배열로 반환합니다.

인스턴스 속성아래 속성은 Intl.NumberFormat.prototype에 정의되어 있으며 모든 Intl.NumberFormat이 이 속성을 공유됩니다.

Intl.NumberFormat.prototype.constructor

인스턴스 객체를 생성한 생성자 함수입니다. Intl.NumberFormat 인스턴스의 경우, 초기 값은 Intl.NumberFormat 생성자입니다.

Intl.NumberFormat.prototype[@@toStringTag]

@@toStringTag 속성의 초기값인 문자열 "Intl.NumberFormat"입니다. 이 속성은 Object.prototype.toString()에서 사용합니다.

인스턴스 메서드
Intl.NumberFormat.prototype.format()
-: 이 Intl.NumberFormat 객체의 로케일과 형식 옵션에 따라 숫자를 형식화하는 접근자 함수입니다.
Intl.NumberFormat.prototype.formatRange()

: 메서드가 호출된 이 Intl.NumberFormat 객체의 로케일과 형식 옵션에 따라 범위를 형식화하는 접근자 함수입니다.


Intl.NumberFormat.prototype.formatRangeToParts()

: 사용자 지정 로케일 인식 형식 지정에 사용할 수 있는 숫자 문자열의 범위를 부분적으로 나타내는 객체의 Array를 반환합니다.


Intl.NumberFormat.prototype.formatToParts()

: 사용자 지정 로케일 인식 형식 지정에 사용할 수 있는 숫자 문자열을 부분적으로 나타내는 객체의 Array를 반환합니다.


Intl.NumberFormat.prototype.resolvedOptions()

: 객체를 초기화하는 동안 계산된 로케일 및 데이터 정렬 옵션을 반영하는 속성이 포함된 새 객체를 반환합니다.


예제기본적인 사용 방법로케일을 지정하지 않고 사용하면 기본 로케일 및 기본 옵션 서식을 적용한 문자열을 반환합니다.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// → 한국 로케일의 경우 '3,500' 표시
locales 사용하기다음 예제는 지역화된 숫자 서식의 예시를 보입니다. 어플리케이션의 사용자 인터페이스 언어에 맞는 서식을 적용하려면 locales 매개변수로 적절한 언어(와, 필요한 경우 대체 언어)를 제공하는걸 잊지 마세요.
jsconst number = 123456.789;

// 독일은 소수점 구분자로 쉼표를 사용하고 천 단위 구분자로 마침표를 사용
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// 대부분의 아랍어 사용 국가에서는 실제 아라비아 숫자를 사용
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// 인도는 천, 라크(십만), 크로르(천만) 단위에 구분자 사용
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// nu 확장 키로 기수법 지정 (아래 예시는 중국식 숫자 표기)
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// 발리어와 같이 지원되지 않을 수도 있는 언어를 지정할 때는
// 다음과 같이 대체 언어를 지정할 수 있음. 아래의 경우 대체 언어는 인도어
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
options 사용options 매개변수를 지정해 결과를 원하는 형태로 바꿀 수 있습니다.
jsconst number = 123456.789;

// 통화 서식
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// 한국 원화는 보조 통화 단위를 사용하지 않음
console.log(
  new Intl.NumberFormat("ko-KR", { style: "currency", currency: "KRW" }).format(
    number,
  ),
);
// ₩123,457

// 유효숫자를 세 개로 제한
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// 단위에 따라 형식 지정
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres
명세SpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objects브라우저 호환성같이 보기
Intl
A polyfill of Intl.NumberFormat in FormatJS\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackIntl.NumberFormat 은 언어에 맞는 숫자 서식을 지원하는 객체의 생성자입니다.시도해 보기
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
생성자
Intl.NumberFormat()

새로운 NumberFormat 객체를 생성합니다.

정적 메서드
Intl.NumberFormat.supportedLocalesOf()

주어진 로케일 목록 중, 런타임이 지원하는 항목을 배열로 반환합니다.

인스턴스 속성아래 속성은 Intl.NumberFormat.prototype에 정의되어 있으며 모든 Intl.NumberFormat이 이 속성을 공유됩니다.

Intl.NumberFormat.prototype.constructor

인스턴스 객체를 생성한 생성자 함수입니다. Intl.NumberFormat 인스턴스의 경우, 초기 값은 Intl.NumberFormat 생성자입니다.

Intl.NumberFormat.prototype[@@toStringTag]

@@toStringTag 속성의 초기값인 문자열 "Intl.NumberFormat"입니다. 이 속성은 Object.prototype.toString()에서 사용합니다.

인스턴스 메서드
Intl.NumberFormat.prototype.format()
-: 이 Intl.NumberFormat 객체의 로케일과 형식 옵션에 따라 숫자를 형식화하는 접근자 함수입니다.
Intl.NumberFormat.prototype.formatRange()

: 메서드가 호출된 이 Intl.NumberFormat 객체의 로케일과 형식 옵션에 따라 범위를 형식화하는 접근자 함수입니다.


Intl.NumberFormat.prototype.formatRangeToParts()

: 사용자 지정 로케일 인식 형식 지정에 사용할 수 있는 숫자 문자열의 범위를 부분적으로 나타내는 객체의 Array를 반환합니다.


Intl.NumberFormat.prototype.formatToParts()

: 사용자 지정 로케일 인식 형식 지정에 사용할 수 있는 숫자 문자열을 부분적으로 나타내는 객체의 Array를 반환합니다.


Intl.NumberFormat.prototype.resolvedOptions()

: 객체를 초기화하는 동안 계산된 로케일 및 데이터 정렬 옵션을 반영하는 속성이 포함된 새 객체를 반환합니다.


예제기본적인 사용 방법로케일을 지정하지 않고 사용하면 기본 로케일 및 기본 옵션 서식을 적용한 문자열을 반환합니다.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// → 한국 로케일의 경우 '3,500' 표시
locales 사용하기다음 예제는 지역화된 숫자 서식의 예시를 보입니다. 어플리케이션의 사용자 인터페이스 언어에 맞는 서식을 적용하려면 locales 매개변수로 적절한 언어(와, 필요한 경우 대체 언어)를 제공하는걸 잊지 마세요.
jsconst number = 123456.789;

// 독일은 소수점 구분자로 쉼표를 사용하고 천 단위 구분자로 마침표를 사용
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// 대부분의 아랍어 사용 국가에서는 실제 아라비아 숫자를 사용
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// 인도는 천, 라크(십만), 크로르(천만) 단위에 구분자 사용
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// nu 확장 키로 기수법 지정 (아래 예시는 중국식 숫자 표기)
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// 발리어와 같이 지원되지 않을 수도 있는 언어를 지정할 때는
// 다음과 같이 대체 언어를 지정할 수 있음. 아래의 경우 대체 언어는 인도어
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
options 사용options 매개변수를 지정해 결과를 원하는 형태로 바꿀 수 있습니다.
jsconst number = 123456.789;

// 통화 서식
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// 한국 원화는 보조 통화 단위를 사용하지 않음
console.log(
  new Intl.NumberFormat("ko-KR", { style: "currency", currency: "KRW" }).format(
    number,
  ),
);
// ₩123,457

// 유효숫자를 세 개로 제한
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// 단위에 따라 형식 지정
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres
명세SpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objects브라우저 호환성같이 보기
Intl
A polyfill of Intl.NumberFormat in FormatJS
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025년 2월 11일 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackIntl.NumberFormat 은 언어에 맞는 숫자 서식을 지원하는 객체의 생성자입니다.시도해 보기
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
생성자
Intl.NumberFormat()

새로운 NumberFormat 객체를 생성합니다.

정적 메서드
Intl.NumberFormat.supportedLocalesOf()

주어진 로케일 목록 중, 런타임이 지원하는 항목을 배열로 반환합니다.

인스턴스 속성아래 속성은 Intl.NumberFormat.prototype에 정의되어 있으며 모든 Intl.NumberFormat이 이 속성을 공유됩니다.

Intl.NumberFormat.prototype.constructor

인스턴스 객체를 생성한 생성자 함수입니다. Intl.NumberFormat 인스턴스의 경우, 초기 값은 Intl.NumberFormat 생성자입니다.

Intl.NumberFormat.prototype[@@toStringTag]

@@toStringTag 속성의 초기값인 문자열 "Intl.NumberFormat"입니다. 이 속성은 Object.prototype.toString()에서 사용합니다.

인스턴스 메서드
Intl.NumberFormat.prototype.format()
-: 이 Intl.NumberFormat 객체의 로케일과 형식 옵션에 따라 숫자를 형식화하는 접근자 함수입니다.
Intl.NumberFormat.prototype.formatRange()

: 메서드가 호출된 이 Intl.NumberFormat 객체의 로케일과 형식 옵션에 따라 범위를 형식화하는 접근자 함수입니다.


Intl.NumberFormat.prototype.formatRangeToParts()

: 사용자 지정 로케일 인식 형식 지정에 사용할 수 있는 숫자 문자열의 범위를 부분적으로 나타내는 객체의 Array를 반환합니다.


Intl.NumberFormat.prototype.formatToParts()

: 사용자 지정 로케일 인식 형식 지정에 사용할 수 있는 숫자 문자열을 부분적으로 나타내는 객체의 Array를 반환합니다.


Intl.NumberFormat.prototype.resolvedOptions()

: 객체를 초기화하는 동안 계산된 로케일 및 데이터 정렬 옵션을 반영하는 속성이 포함된 새 객체를 반환합니다.


예제기본적인 사용 방법로케일을 지정하지 않고 사용하면 기본 로케일 및 기본 옵션 서식을 적용한 문자열을 반환합니다.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// → 한국 로케일의 경우 '3,500' 표시
locales 사용하기다음 예제는 지역화된 숫자 서식의 예시를 보입니다. 어플리케이션의 사용자 인터페이스 언어에 맞는 서식을 적용하려면 locales 매개변수로 적절한 언어(와, 필요한 경우 대체 언어)를 제공하는걸 잊지 마세요.
jsconst number = 123456.789;

// 독일은 소수점 구분자로 쉼표를 사용하고 천 단위 구분자로 마침표를 사용
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// 대부분의 아랍어 사용 국가에서는 실제 아라비아 숫자를 사용
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// 인도는 천, 라크(십만), 크로르(천만) 단위에 구분자 사용
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// nu 확장 키로 기수법 지정 (아래 예시는 중국식 숫자 표기)
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// 발리어와 같이 지원되지 않을 수도 있는 언어를 지정할 때는
// 다음과 같이 대체 언어를 지정할 수 있음. 아래의 경우 대체 언어는 인도어
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
options 사용options 매개변수를 지정해 결과를 원하는 형태로 바꿀 수 있습니다.
jsconst number = 123456.789;

// 통화 서식
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// 한국 원화는 보조 통화 단위를 사용하지 않음
console.log(
  new Intl.NumberFormat("ko-KR", { style: "currency", currency: "KRW" }).format(
    number,
  ),
);
// ₩123,457

// 유효숫자를 세 개로 제한
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// 단위에 따라 형식 지정
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres
명세SpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objects브라우저 호환성같이 보기
Intl
A polyfill of Intl.NumberFormat in FormatJS
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025년 2월 11일 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback
O objeto Intl.NumberFormat é um construtor para objetos que habilita formatação de número sensível a linguagem.Experimente
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Sintaxenew Intl.NumberFormat([locales[, options]])
Intl.NumberFormat.call(this[, locales[, options]])
Parâmetros
locales

Opcional. Uma string com uma tag de linguagem BCP 47 ou uma matriz delas. Para a forma geral e interpretação do argumento locales, veja Intl page. A seguinte chave extendida Unicode é permitida:

nu

O sistema de numeração que será usado. Os valores permitidos são: "arab", "arabext", "bali", "beng", "deva", "fullwide", "gujr", "guru", "hanidec", "khmr", "knda", "laoo", "latn", "limb", "mlym", "mong", "mymr", "orya", "tamldec", "telu", "thai", "tibt".



options

Opcional. Um objeto com alguns ou todas as seguintes propriedades:

localeMatcher

O algoritmo de comparação de localização para utilizar. Os valores permitidos são "lookup" e "best fit"; o padrão é "best fit". Para mais informações sobre esta opção, veja Intl page.

style

O estilo do formato a ser utilizado. Os valores permitidos são "decimal" para formato de número simples, "currency" para formato monetário e "percent" para formato percentual; o padrão é "decimal".

currency

A moeda para usar na formatação monetária. Os valores permitidos são os códigos de moedas da ISO 4217, como "USD" para dólar estadunidense, "EUR" para euro, ou "CNY" para RMB chinês — veja a Lista de códigos de moedas e fundos atuais. Não há valor padrão; se o style for "currency", a propriedade currency deverá ser informada.

currencyDisplay

Como será mostrada a moeda na formatação monetária. Os valores permitidos são "symbol" para usar um símbolo de moeda localizado como €, "code" para usar o código de moeda ISO, "name" para usar o nome da moeda localizado como "dollar"; o padrão é "symbol".

useGrouping

Se usar separadores de agrupamento, como separadores de milhares ou milhares/cem mil/dez milhões. Os valores permitidos são true e false; o padrão é true.


As próximas propriedades se dividem em dois grupos: minimumIntegerDigits, minimumFractionDigits, e maximumFractionDigits no primeiro grupo, minimumSignificantDigits and maximumSignificantDigits em outro. Se pelo menos uma propriedade do segundo grupo for informado, então o primeiro grupo é ignorado.

minimumIntegerDigits

A quantidade mínima de dígitos inteiros para utilizar. É possível usar valores de 1 a 21; o padrão é 1.

minimumFractionDigits

A quantidade mínima de dígitos fracionados para utilizar. É possível usar valores de 0 a 20; o padrão para formatos de números simples e percentuais é 0; o padrão para formatos monetários é a menor unidade de dígitos fornecidos pela lista de códigos de moedas ISO 4217 (2 se a lista não fornecer a informação).

maximumFractionDigits

O número máximo de dígitos fracionados para utilizar. É possível usar valores de 0 a 20; o padrão para a formatação de número simples é o maior entre minimumFractionDigits e 3; o padrão para formatos monetários é o maior número de dígitos entre minimumFractionDigits e o fornecido pela lista de códigos de moedas ISO 4217 (2 se a lista não fornecer a informação); o padrão para a formatação percentual é o maior número entre minimumFractionDigits e 0.

minimumSignificantDigits

A quantidade mínima de dígitos significantes para usar. Os valores permitidos são de 1 a 21; o padrão é 1.

maximumSignificantDigits

A quantidade máxima de dígitos significantes para usar. Os valores permitidos são de 1 a 21; o padrão é minimumSignificantDigits.



DescriçãoPropriedades
Intl.NumberFormat.prototype

Pertime a inclusão de propriedades a todos os objetos.

Métodos
Intl.NumberFormat.supportedLocalesOf()

Retorna uma matriz contendo as localizações fornecidas que são suportadas sem retornar a localização padrão em tempo de execução.

Instâncias NumberFormatPropriedadesAs instâncias de NumberFormat herdam as seguntes propriedades de seu protótipo:
MethodsAs instâncias de NumberFormat herdam os seguintes métodos de seu protótipo:
ExemplosUso básicoNo uso básico sem a especificação de uma localização, o método retornará uma string formatada com a localização e as opções padrão.
jsvar numero = 3500;

console.log(new Intl.NumberFormat().format(numero));
// → '3,500' se a localização for U.S. English
Usando localesEste exemplo mostra algumas variações de formatos de números localizados. A fim de obter o formato da linguagem utilizada na interface do usuário da sua aplicação, tenha certeza de especificar a língua (e possivelmente algumas línguas reservas) usando o argumento locales:
jsvar numero = 123456.789;

// O alemão usa vírgula como separador de decimal e ponto para milhares
console.log(new Intl.NumberFormat("de-DE").format(numero));
// → 123.456,789

// O árabe usa dígitos reais árabes em muitos países que falam árabe
console.log(new Intl.NumberFormat("ar-EG").format(numero));
// → ١٢٣٤٥٦٫٧٨٩

// A Índia usa separadores de milhares/cem mil/dez milhões
console.log(new Intl.NumberFormat("en-IN").format(numero));
// → 1,23,456.789

// A chave de extensão nu requer um sistema de numeração, ex. decimal chinês
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(numero));
// → 一二三,四五六.七八九

// Quando informada uma língua sem suporte, como balinês,
// inclua uma língua reseva, neste caso indonésio
console.log(new Intl.NumberFormat(["ban", "id"]).format(numero));
// → 123.456,789
Usando optionsOs resultados podem ser personalizados usando o argumento options:
jsvar numero = 123456.789;

// informando um formato de moeda
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    numero,
  ),
);
// → 123.456,79 €

// o yen japonês não tem uma unidade menor
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    numero,
  ),
);
// → ￥123,457

// limitando a três dígitos significativos
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    numero,
  ),
);
// → 1,23,000
EspecificaçõesSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsCompatibilidade com navegadoresVeja também\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback
O objeto Intl.NumberFormat é um construtor para objetos que habilita formatação de número sensível a linguagem.Experimente
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Sintaxenew Intl.NumberFormat([locales[, options]])
Intl.NumberFormat.call(this[, locales[, options]])
Parâmetros
locales

Opcional. Uma string com uma tag de linguagem BCP 47 ou uma matriz delas. Para a forma geral e interpretação do argumento locales, veja Intl page. A seguinte chave extendida Unicode é permitida:

nu

O sistema de numeração que será usado. Os valores permitidos são: "arab", "arabext", "bali", "beng", "deva", "fullwide", "gujr", "guru", "hanidec", "khmr", "knda", "laoo", "latn", "limb", "mlym", "mong", "mymr", "orya", "tamldec", "telu", "thai", "tibt".



options

Opcional. Um objeto com alguns ou todas as seguintes propriedades:

localeMatcher

O algoritmo de comparação de localização para utilizar. Os valores permitidos são "lookup" e "best fit"; o padrão é "best fit". Para mais informações sobre esta opção, veja Intl page.

style

O estilo do formato a ser utilizado. Os valores permitidos são "decimal" para formato de número simples, "currency" para formato monetário e "percent" para formato percentual; o padrão é "decimal".

currency

A moeda para usar na formatação monetária. Os valores permitidos são os códigos de moedas da ISO 4217, como "USD" para dólar estadunidense, "EUR" para euro, ou "CNY" para RMB chinês — veja a Lista de códigos de moedas e fundos atuais. Não há valor padrão; se o style for "currency", a propriedade currency deverá ser informada.

currencyDisplay

Como será mostrada a moeda na formatação monetária. Os valores permitidos são "symbol" para usar um símbolo de moeda localizado como €, "code" para usar o código de moeda ISO, "name" para usar o nome da moeda localizado como "dollar"; o padrão é "symbol".

useGrouping

Se usar separadores de agrupamento, como separadores de milhares ou milhares/cem mil/dez milhões. Os valores permitidos são true e false; o padrão é true.


As próximas propriedades se dividem em dois grupos: minimumIntegerDigits, minimumFractionDigits, e maximumFractionDigits no primeiro grupo, minimumSignificantDigits and maximumSignificantDigits em outro. Se pelo menos uma propriedade do segundo grupo for informado, então o primeiro grupo é ignorado.

minimumIntegerDigits

A quantidade mínima de dígitos inteiros para utilizar. É possível usar valores de 1 a 21; o padrão é 1.

minimumFractionDigits

A quantidade mínima de dígitos fracionados para utilizar. É possível usar valores de 0 a 20; o padrão para formatos de números simples e percentuais é 0; o padrão para formatos monetários é a menor unidade de dígitos fornecidos pela lista de códigos de moedas ISO 4217 (2 se a lista não fornecer a informação).

maximumFractionDigits

O número máximo de dígitos fracionados para utilizar. É possível usar valores de 0 a 20; o padrão para a formatação de número simples é o maior entre minimumFractionDigits e 3; o padrão para formatos monetários é o maior número de dígitos entre minimumFractionDigits e o fornecido pela lista de códigos de moedas ISO 4217 (2 se a lista não fornecer a informação); o padrão para a formatação percentual é o maior número entre minimumFractionDigits e 0.

minimumSignificantDigits

A quantidade mínima de dígitos significantes para usar. Os valores permitidos são de 1 a 21; o padrão é 1.

maximumSignificantDigits

A quantidade máxima de dígitos significantes para usar. Os valores permitidos são de 1 a 21; o padrão é minimumSignificantDigits.



DescriçãoPropriedades
Intl.NumberFormat.prototype

Pertime a inclusão de propriedades a todos os objetos.

Métodos
Intl.NumberFormat.supportedLocalesOf()

Retorna uma matriz contendo as localizações fornecidas que são suportadas sem retornar a localização padrão em tempo de execução.

Instâncias NumberFormatPropriedadesAs instâncias de NumberFormat herdam as seguntes propriedades de seu protótipo:
MethodsAs instâncias de NumberFormat herdam os seguintes métodos de seu protótipo:
ExemplosUso básicoNo uso básico sem a especificação de uma localização, o método retornará uma string formatada com a localização e as opções padrão.
jsvar numero = 3500;

console.log(new Intl.NumberFormat().format(numero));
// → '3,500' se a localização for U.S. English
Usando localesEste exemplo mostra algumas variações de formatos de números localizados. A fim de obter o formato da linguagem utilizada na interface do usuário da sua aplicação, tenha certeza de especificar a língua (e possivelmente algumas línguas reservas) usando o argumento locales:
jsvar numero = 123456.789;

// O alemão usa vírgula como separador de decimal e ponto para milhares
console.log(new Intl.NumberFormat("de-DE").format(numero));
// → 123.456,789

// O árabe usa dígitos reais árabes em muitos países que falam árabe
console.log(new Intl.NumberFormat("ar-EG").format(numero));
// → ١٢٣٤٥٦٫٧٨٩

// A Índia usa separadores de milhares/cem mil/dez milhões
console.log(new Intl.NumberFormat("en-IN").format(numero));
// → 1,23,456.789

// A chave de extensão nu requer um sistema de numeração, ex. decimal chinês
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(numero));
// → 一二三,四五六.七八九

// Quando informada uma língua sem suporte, como balinês,
// inclua uma língua reseva, neste caso indonésio
console.log(new Intl.NumberFormat(["ban", "id"]).format(numero));
// → 123.456,789
Usando optionsOs resultados podem ser personalizados usando o argumento options:
jsvar numero = 123456.789;

// informando um formato de moeda
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    numero,
  ),
);
// → 123.456,79 €

// o yen japonês não tem uma unidade menor
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    numero,
  ),
);
// → ￥123,457

// limitando a três dígitos significativos
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    numero,
  ),
);
// → 1,23,000
EspecificaçõesSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsCompatibilidade com navegadoresVeja tambémHelp improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 17 de abr. de 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback
O objeto Intl.NumberFormat é um construtor para objetos que habilita formatação de número sensível a linguagem.Experimente
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Sintaxenew Intl.NumberFormat([locales[, options]])
Intl.NumberFormat.call(this[, locales[, options]])
Parâmetros
locales

Opcional. Uma string com uma tag de linguagem BCP 47 ou uma matriz delas. Para a forma geral e interpretação do argumento locales, veja Intl page. A seguinte chave extendida Unicode é permitida:

nu

O sistema de numeração que será usado. Os valores permitidos são: "arab", "arabext", "bali", "beng", "deva", "fullwide", "gujr", "guru", "hanidec", "khmr", "knda", "laoo", "latn", "limb", "mlym", "mong", "mymr", "orya", "tamldec", "telu", "thai", "tibt".



options

Opcional. Um objeto com alguns ou todas as seguintes propriedades:

localeMatcher

O algoritmo de comparação de localização para utilizar. Os valores permitidos são "lookup" e "best fit"; o padrão é "best fit". Para mais informações sobre esta opção, veja Intl page.

style

O estilo do formato a ser utilizado. Os valores permitidos são "decimal" para formato de número simples, "currency" para formato monetário e "percent" para formato percentual; o padrão é "decimal".

currency

A moeda para usar na formatação monetária. Os valores permitidos são os códigos de moedas da ISO 4217, como "USD" para dólar estadunidense, "EUR" para euro, ou "CNY" para RMB chinês — veja a Lista de códigos de moedas e fundos atuais. Não há valor padrão; se o style for "currency", a propriedade currency deverá ser informada.

currencyDisplay

Como será mostrada a moeda na formatação monetária. Os valores permitidos são "symbol" para usar um símbolo de moeda localizado como €, "code" para usar o código de moeda ISO, "name" para usar o nome da moeda localizado como "dollar"; o padrão é "symbol".

useGrouping

Se usar separadores de agrupamento, como separadores de milhares ou milhares/cem mil/dez milhões. Os valores permitidos são true e false; o padrão é true.


As próximas propriedades se dividem em dois grupos: minimumIntegerDigits, minimumFractionDigits, e maximumFractionDigits no primeiro grupo, minimumSignificantDigits and maximumSignificantDigits em outro. Se pelo menos uma propriedade do segundo grupo for informado, então o primeiro grupo é ignorado.

minimumIntegerDigits

A quantidade mínima de dígitos inteiros para utilizar. É possível usar valores de 1 a 21; o padrão é 1.

minimumFractionDigits

A quantidade mínima de dígitos fracionados para utilizar. É possível usar valores de 0 a 20; o padrão para formatos de números simples e percentuais é 0; o padrão para formatos monetários é a menor unidade de dígitos fornecidos pela lista de códigos de moedas ISO 4217 (2 se a lista não fornecer a informação).

maximumFractionDigits

O número máximo de dígitos fracionados para utilizar. É possível usar valores de 0 a 20; o padrão para a formatação de número simples é o maior entre minimumFractionDigits e 3; o padrão para formatos monetários é o maior número de dígitos entre minimumFractionDigits e o fornecido pela lista de códigos de moedas ISO 4217 (2 se a lista não fornecer a informação); o padrão para a formatação percentual é o maior número entre minimumFractionDigits e 0.

minimumSignificantDigits

A quantidade mínima de dígitos significantes para usar. Os valores permitidos são de 1 a 21; o padrão é 1.

maximumSignificantDigits

A quantidade máxima de dígitos significantes para usar. Os valores permitidos são de 1 a 21; o padrão é minimumSignificantDigits.



DescriçãoPropriedades
Intl.NumberFormat.prototype

Pertime a inclusão de propriedades a todos os objetos.

Métodos
Intl.NumberFormat.supportedLocalesOf()

Retorna uma matriz contendo as localizações fornecidas que são suportadas sem retornar a localização padrão em tempo de execução.

Instâncias NumberFormatPropriedadesAs instâncias de NumberFormat herdam as seguntes propriedades de seu protótipo:
MethodsAs instâncias de NumberFormat herdam os seguintes métodos de seu protótipo:
ExemplosUso básicoNo uso básico sem a especificação de uma localização, o método retornará uma string formatada com a localização e as opções padrão.
jsvar numero = 3500;

console.log(new Intl.NumberFormat().format(numero));
// → '3,500' se a localização for U.S. English
Usando localesEste exemplo mostra algumas variações de formatos de números localizados. A fim de obter o formato da linguagem utilizada na interface do usuário da sua aplicação, tenha certeza de especificar a língua (e possivelmente algumas línguas reservas) usando o argumento locales:
jsvar numero = 123456.789;

// O alemão usa vírgula como separador de decimal e ponto para milhares
console.log(new Intl.NumberFormat("de-DE").format(numero));
// → 123.456,789

// O árabe usa dígitos reais árabes em muitos países que falam árabe
console.log(new Intl.NumberFormat("ar-EG").format(numero));
// → ١٢٣٤٥٦٫٧٨٩

// A Índia usa separadores de milhares/cem mil/dez milhões
console.log(new Intl.NumberFormat("en-IN").format(numero));
// → 1,23,456.789

// A chave de extensão nu requer um sistema de numeração, ex. decimal chinês
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(numero));
// → 一二三,四五六.七八九

// Quando informada uma língua sem suporte, como balinês,
// inclua uma língua reseva, neste caso indonésio
console.log(new Intl.NumberFormat(["ban", "id"]).format(numero));
// → 123.456,789
Usando optionsOs resultados podem ser personalizados usando o argumento options:
jsvar numero = 123456.789;

// informando um formato de moeda
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    numero,
  ),
);
// → 123.456,79 €

// o yen japonês não tem uma unidade menor
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    numero,
  ),
);
// → ￥123,457

// limitando a três dígitos significativos
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    numero,
  ),
);
// → 1,23,000
EspecificaçõesSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsCompatibilidade com navegadoresVeja tambémHelp improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 17 de abr. de 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackОбъект Intl.NumberFormat предоставляет возможности форматирования чисел в соответствии с языковыми правилами.Интерактивный пример
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Создаёт новый объект NumberFormat.

Статические методы
Intl.NumberFormat.supportedLocalesOf()

Возвращает массив, содержащий локали, которые поддерживаются без необходимости возврата к локали по умолчанию.

Свойства экземпляраЭти свойства определены в Intl.NumberFormat.prototype и есть у всех экземпляров Intl.NumberFormat.

Intl.NumberFormat.prototype.constructor

Функция-конструктор, создающая экземпляр объекта. Для экземпляров Intl.NumberFormat начальным значением является конструктор Intl.NumberFormat.

Intl.NumberFormat.prototype[@@toStringTag]

Начальным значением свойства @@toStringTag является строка "Intl.NumberFormat". Это свойство используется в Object.prototype.toString().

Методы экземпляра
Intl.NumberFormat.prototype.format()

Функция-геттер, которая форматирует число в соответствии с локалью и настройками форматирования этого объекта Intl.NumberFormat.

Intl.NumberFormat.prototype.formatRange()

Функция-геттер, которая форматирует диапазон чисел в соответствии с локалью и настройками форматирования объекта Intl.NumberFormat, метод которого был вызван.

Intl.NumberFormat.prototype.formatRangeToParts()

Возвращает массив объектов, представляющих диапазон числовых строк по частям, которые можно использовать для пользовательского форматирования с учетом локали.

Intl.NumberFormat.prototype.formatToParts()

Возвращает массив объектов, представляющих части числа, которые могут быть использованы для пользовательского форматирования с учётом локали.

Intl.NumberFormat.prototype.resolvedOptions()

Возвращает новый объект со свойствами, представляющими локаль и настройки форматирования, определённые во время инициализации объекта.

ПримерыИспользование NumberFormatПри использовании без указания локали возвращается строка, отформатированная в соответствии с локалью и настройками по умолчанию.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' в локали US English
Использование параметра localesЭтот пример показывает некоторые локализованные форматы чисел. Для получения формата языка, используемого в пользовательском интерфейсе вашего приложения, убедитесь, что вы указали этот язык (и, возможно, несколько запасных языков) используя параметр locales:
jsconst number = 123456.789;

// В Германии в качестве разделителя целой и дробной части используется запятая, а в качестве разделителя разрядов - точка
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// В России в качестве разделителя целой и дробной части используется запятая, а в качестве разделителя разрядов - пробел
console.log(new Intl.NumberFormat("ru-RU").format(number));
// 123 456,789

// В большинстве арабоязычных стран используют настоящие арабские цифры
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// В Индии используют разделители для тысяч/лакх/крор
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// Ключ расширения nu запрашивает систему нумерации, например, китайскую десятичную
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// Если запрашиваемый язык может не поддерживаться, например
// балийский, откатываемся на запасной язык, в данном случае индонезийский
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Использование параметра optionsРезультат может быть настроен с помощью параметра options:
jsconst number = 123456.789;

// Запрашиваем формат валюты
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

console.log(
  new Intl.NumberFormat("ru-RU", { style: "currency", currency: "RUB" }).format(
    number,
  ),
);
// 123 456,79 руб.

// Японская йена не использует младшие единицы
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// Ограничиваем до трёх значащих цифр
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Форматирование с единицами измерения
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

Полный список настроек смотрите на странице Intl.NumberFormat() constructor.СпецификацииSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsСовместимость с браузерамиСмотрите также
Полифил Intl.NumberFormat в FormatJS
Intl\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackОбъект Intl.NumberFormat предоставляет возможности форматирования чисел в соответствии с языковыми правилами.Интерактивный пример
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Создаёт новый объект NumberFormat.

Статические методы
Intl.NumberFormat.supportedLocalesOf()

Возвращает массив, содержащий локали, которые поддерживаются без необходимости возврата к локали по умолчанию.

Свойства экземпляраЭти свойства определены в Intl.NumberFormat.prototype и есть у всех экземпляров Intl.NumberFormat.

Intl.NumberFormat.prototype.constructor

Функция-конструктор, создающая экземпляр объекта. Для экземпляров Intl.NumberFormat начальным значением является конструктор Intl.NumberFormat.

Intl.NumberFormat.prototype[@@toStringTag]

Начальным значением свойства @@toStringTag является строка "Intl.NumberFormat". Это свойство используется в Object.prototype.toString().

Методы экземпляра
Intl.NumberFormat.prototype.format()

Функция-геттер, которая форматирует число в соответствии с локалью и настройками форматирования этого объекта Intl.NumberFormat.

Intl.NumberFormat.prototype.formatRange()

Функция-геттер, которая форматирует диапазон чисел в соответствии с локалью и настройками форматирования объекта Intl.NumberFormat, метод которого был вызван.

Intl.NumberFormat.prototype.formatRangeToParts()

Возвращает массив объектов, представляющих диапазон числовых строк по частям, которые можно использовать для пользовательского форматирования с учетом локали.

Intl.NumberFormat.prototype.formatToParts()

Возвращает массив объектов, представляющих части числа, которые могут быть использованы для пользовательского форматирования с учётом локали.

Intl.NumberFormat.prototype.resolvedOptions()

Возвращает новый объект со свойствами, представляющими локаль и настройки форматирования, определённые во время инициализации объекта.

ПримерыИспользование NumberFormatПри использовании без указания локали возвращается строка, отформатированная в соответствии с локалью и настройками по умолчанию.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' в локали US English
Использование параметра localesЭтот пример показывает некоторые локализованные форматы чисел. Для получения формата языка, используемого в пользовательском интерфейсе вашего приложения, убедитесь, что вы указали этот язык (и, возможно, несколько запасных языков) используя параметр locales:
jsconst number = 123456.789;

// В Германии в качестве разделителя целой и дробной части используется запятая, а в качестве разделителя разрядов - точка
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// В России в качестве разделителя целой и дробной части используется запятая, а в качестве разделителя разрядов - пробел
console.log(new Intl.NumberFormat("ru-RU").format(number));
// 123 456,789

// В большинстве арабоязычных стран используют настоящие арабские цифры
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// В Индии используют разделители для тысяч/лакх/крор
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// Ключ расширения nu запрашивает систему нумерации, например, китайскую десятичную
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// Если запрашиваемый язык может не поддерживаться, например
// балийский, откатываемся на запасной язык, в данном случае индонезийский
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Использование параметра optionsРезультат может быть настроен с помощью параметра options:
jsconst number = 123456.789;

// Запрашиваем формат валюты
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

console.log(
  new Intl.NumberFormat("ru-RU", { style: "currency", currency: "RUB" }).format(
    number,
  ),
);
// 123 456,79 руб.

// Японская йена не использует младшие единицы
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// Ограничиваем до трёх значащих цифр
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Форматирование с единицами измерения
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

Полный список настроек смотрите на странице Intl.NumberFormat() constructor.СпецификацииSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsСовместимость с браузерамиСмотрите также
Полифил Intl.NumberFormat в FormatJS
Intl
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 17 февр. 2025 г. by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackОбъект Intl.NumberFormat предоставляет возможности форматирования чисел в соответствии с языковыми правилами.Интерактивный пример
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Создаёт новый объект NumberFormat.

Статические методы
Intl.NumberFormat.supportedLocalesOf()

Возвращает массив, содержащий локали, которые поддерживаются без необходимости возврата к локали по умолчанию.

Свойства экземпляраЭти свойства определены в Intl.NumberFormat.prototype и есть у всех экземпляров Intl.NumberFormat.

Intl.NumberFormat.prototype.constructor

Функция-конструктор, создающая экземпляр объекта. Для экземпляров Intl.NumberFormat начальным значением является конструктор Intl.NumberFormat.

Intl.NumberFormat.prototype[@@toStringTag]

Начальным значением свойства @@toStringTag является строка "Intl.NumberFormat". Это свойство используется в Object.prototype.toString().

Методы экземпляра
Intl.NumberFormat.prototype.format()

Функция-геттер, которая форматирует число в соответствии с локалью и настройками форматирования этого объекта Intl.NumberFormat.

Intl.NumberFormat.prototype.formatRange()

Функция-геттер, которая форматирует диапазон чисел в соответствии с локалью и настройками форматирования объекта Intl.NumberFormat, метод которого был вызван.

Intl.NumberFormat.prototype.formatRangeToParts()

Возвращает массив объектов, представляющих диапазон числовых строк по частям, которые можно использовать для пользовательского форматирования с учетом локали.

Intl.NumberFormat.prototype.formatToParts()

Возвращает массив объектов, представляющих части числа, которые могут быть использованы для пользовательского форматирования с учётом локали.

Intl.NumberFormat.prototype.resolvedOptions()

Возвращает новый объект со свойствами, представляющими локаль и настройки форматирования, определённые во время инициализации объекта.

ПримерыИспользование NumberFormatПри использовании без указания локали возвращается строка, отформатированная в соответствии с локалью и настройками по умолчанию.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' в локали US English
Использование параметра localesЭтот пример показывает некоторые локализованные форматы чисел. Для получения формата языка, используемого в пользовательском интерфейсе вашего приложения, убедитесь, что вы указали этот язык (и, возможно, несколько запасных языков) используя параметр locales:
jsconst number = 123456.789;

// В Германии в качестве разделителя целой и дробной части используется запятая, а в качестве разделителя разрядов - точка
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// В России в качестве разделителя целой и дробной части используется запятая, а в качестве разделителя разрядов - пробел
console.log(new Intl.NumberFormat("ru-RU").format(number));
// 123 456,789

// В большинстве арабоязычных стран используют настоящие арабские цифры
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// В Индии используют разделители для тысяч/лакх/крор
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// Ключ расширения nu запрашивает систему нумерации, например, китайскую десятичную
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// Если запрашиваемый язык может не поддерживаться, например
// балийский, откатываемся на запасной язык, в данном случае индонезийский
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Использование параметра optionsРезультат может быть настроен с помощью параметра options:
jsconst number = 123456.789;

// Запрашиваем формат валюты
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

console.log(
  new Intl.NumberFormat("ru-RU", { style: "currency", currency: "RUB" }).format(
    number,
  ),
);
// 123 456,79 руб.

// Японская йена не использует младшие единицы
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// Ограничиваем до трёх значащих цифр
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Форматирование с единицами измерения
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

Полный список настроек смотрите на странице Intl.NumberFormat() constructor.СпецификацииSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsСовместимость с браузерамиСмотрите также
Полифил Intl.NumberFormat в FormatJS
Intl
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 17 февр. 2025 г. by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackIntl.NumberFormat 对象能使数字在特定的语言环境下格式化。尝试一下
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
构造函数
Intl.NumberFormat()

创建一个新的 NumberFormat 对象。

静态方法
Intl.NumberFormat.supportedLocalesOf()

返回一个数组，其包含着那些被提供的受支持的区域（locale），而运行时的默认的区域不会出现在该数组。

实例方法
Intl.NumberFormat.prototype.format()

getter 函数，根据此 Intl.NumberFormat 对象的区域设置和格式化选项格式化数字。

Intl.NumberFormat.prototype.formatToParts()

返回一个对象数组，其中表示的是数字字符串的各个部分，可以用于自定义本地化格式。

Intl.NumberFormat.prototype.formatRange()

getter 函数，根据调用该方法的 Intl.NumberFormat 对象的区域设置和格式化选项格式化一个数字的范围。

Intl.NumberFormat.prototype.formatRangeToParts()

返回一个对象数组，其中表示的是数字范围的字符串的各个部分，可以用于自定义本地化格式。

Intl.NumberFormat.prototype.resolvedOptions()

返回一个新对象，其属性能够反映相应对象在初始化时计算所得的区域和格式化选项。

示例基础用例在不指定区域设置的基本用例中，返回默认区域和默认选项中的格式化字符串。
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// 如果在美式英语区域 → '3,500'
使用 locales此示例展示了本地数字格式化的一些变化。为了得到用户应用接口使用的语言格式，请确保使用 locales 参数指定该语言（可能还有一些备选语言）：
jsconst number = 123456.789;

// 德语使用逗号（,）作为小数点，使用句号（.）作为千位分隔符
console.log(new Intl.NumberFormat("de-DE").format(number));
// → 123.456,789

// 大多数阿拉伯语国家使用阿拉伯语数字
console.log(new Intl.NumberFormat("ar-EG").format(number));
// → ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// → 1,23,456.789

// 通过编号系统中的 nu 扩展键请求，例如：中文十进制数字
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// → 一二三,四五六.七八九

//当请求的语言不被支持，例如巴里，包含一个回滚语言印尼，这时候就会使用印尼语
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// → 123.456,789
使用 options可以使用 options 参数自定义结果：
jsconst number = 123456.789;

// 要求货币格式
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// 日元不使用小数位
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// 限制三位有效数字
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// 带有单位的格式化
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

有关详尽的选项列表，参见 Intl.NumberFormat() 构造函数页面。规范SpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objects浏览器兼容性参见
Intl
FormatJS 中 Intl.NumberFormat 的 polyfill\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackIntl.NumberFormat 对象能使数字在特定的语言环境下格式化。尝试一下
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
构造函数
Intl.NumberFormat()

创建一个新的 NumberFormat 对象。

静态方法
Intl.NumberFormat.supportedLocalesOf()

返回一个数组，其包含着那些被提供的受支持的区域（locale），而运行时的默认的区域不会出现在该数组。

实例方法
Intl.NumberFormat.prototype.format()

getter 函数，根据此 Intl.NumberFormat 对象的区域设置和格式化选项格式化数字。

Intl.NumberFormat.prototype.formatToParts()

返回一个对象数组，其中表示的是数字字符串的各个部分，可以用于自定义本地化格式。

Intl.NumberFormat.prototype.formatRange()

getter 函数，根据调用该方法的 Intl.NumberFormat 对象的区域设置和格式化选项格式化一个数字的范围。

Intl.NumberFormat.prototype.formatRangeToParts()

返回一个对象数组，其中表示的是数字范围的字符串的各个部分，可以用于自定义本地化格式。

Intl.NumberFormat.prototype.resolvedOptions()

返回一个新对象，其属性能够反映相应对象在初始化时计算所得的区域和格式化选项。

示例基础用例在不指定区域设置的基本用例中，返回默认区域和默认选项中的格式化字符串。
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// 如果在美式英语区域 → '3,500'
使用 locales此示例展示了本地数字格式化的一些变化。为了得到用户应用接口使用的语言格式，请确保使用 locales 参数指定该语言（可能还有一些备选语言）：
jsconst number = 123456.789;

// 德语使用逗号（,）作为小数点，使用句号（.）作为千位分隔符
console.log(new Intl.NumberFormat("de-DE").format(number));
// → 123.456,789

// 大多数阿拉伯语国家使用阿拉伯语数字
console.log(new Intl.NumberFormat("ar-EG").format(number));
// → ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// → 1,23,456.789

// 通过编号系统中的 nu 扩展键请求，例如：中文十进制数字
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// → 一二三,四五六.七八九

//当请求的语言不被支持，例如巴里，包含一个回滚语言印尼，这时候就会使用印尼语
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// → 123.456,789
使用 options可以使用 options 参数自定义结果：
jsconst number = 123456.789;

// 要求货币格式
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// 日元不使用小数位
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// 限制三位有效数字
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// 带有单位的格式化
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

有关详尽的选项列表，参见 Intl.NumberFormat() 构造函数页面。规范SpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objects浏览器兼容性参见
Intl
FormatJS 中 Intl.NumberFormat 的 polyfill
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025年2月12日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackIntl.NumberFormat 对象能使数字在特定的语言环境下格式化。尝试一下
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
构造函数
Intl.NumberFormat()

创建一个新的 NumberFormat 对象。

静态方法
Intl.NumberFormat.supportedLocalesOf()

返回一个数组，其包含着那些被提供的受支持的区域（locale），而运行时的默认的区域不会出现在该数组。

实例方法
Intl.NumberFormat.prototype.format()

getter 函数，根据此 Intl.NumberFormat 对象的区域设置和格式化选项格式化数字。

Intl.NumberFormat.prototype.formatToParts()

返回一个对象数组，其中表示的是数字字符串的各个部分，可以用于自定义本地化格式。

Intl.NumberFormat.prototype.formatRange()

getter 函数，根据调用该方法的 Intl.NumberFormat 对象的区域设置和格式化选项格式化一个数字的范围。

Intl.NumberFormat.prototype.formatRangeToParts()

返回一个对象数组，其中表示的是数字范围的字符串的各个部分，可以用于自定义本地化格式。

Intl.NumberFormat.prototype.resolvedOptions()

返回一个新对象，其属性能够反映相应对象在初始化时计算所得的区域和格式化选项。

示例基础用例在不指定区域设置的基本用例中，返回默认区域和默认选项中的格式化字符串。
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// 如果在美式英语区域 → '3,500'
使用 locales此示例展示了本地数字格式化的一些变化。为了得到用户应用接口使用的语言格式，请确保使用 locales 参数指定该语言（可能还有一些备选语言）：
jsconst number = 123456.789;

// 德语使用逗号（,）作为小数点，使用句号（.）作为千位分隔符
console.log(new Intl.NumberFormat("de-DE").format(number));
// → 123.456,789

// 大多数阿拉伯语国家使用阿拉伯语数字
console.log(new Intl.NumberFormat("ar-EG").format(number));
// → ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// → 1,23,456.789

// 通过编号系统中的 nu 扩展键请求，例如：中文十进制数字
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// → 一二三,四五六.七八九

//当请求的语言不被支持，例如巴里，包含一个回滚语言印尼，这时候就会使用印尼语
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// → 123.456,789
使用 options可以使用 options 参数自定义结果：
jsconst number = 123456.789;

// 要求货币格式
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// 日元不使用小数位
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// 限制三位有效数字
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// 带有单位的格式化
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

有关详尽的选项列表，参见 Intl.NumberFormat() 构造函数页面。规范SpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objects浏览器兼容性参见
Intl
FormatJS 中 Intl.NumberFormat 的 polyfill
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025年2月12日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIntl.NumberFormat() constructorBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat() constructor creates Intl.NumberFormat objects.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Syntaxjsnew Intl.NumberFormat()
new Intl.NumberFormat(locales)
new Intl.NumberFormat(locales, options)

Intl.NumberFormat()
Intl.NumberFormat(locales)
Intl.NumberFormat(locales, options)


Note: Intl.NumberFormat() can be called with or without new. Both create a new Intl.NumberFormat instance. However, there's a special behavior when it's called without new and the this value is another Intl.NumberFormat instance; see Return value.
Parameters
locales Optional

A string with a BCP 47 language tag or an Intl.Locale instance, or an array of such locale identifiers. The runtime's default locale is used when undefined is passed or when none of the specified locale identifiers is supported. For the general form and interpretation of the locales argument, see the parameter description on the Intl main page.
The following Unicode extension key is allowed:

nu

See numberingSystem.


This key can also be set with options (as listed below). When both are set, the options property takes precedence.

options Optional

An object. For ease of reading, the property list is broken into sections based on their purposes, including locale options, style options, digit options, and other options.


Locale options

localeMatcher

The locale matching algorithm to use. Possible values are "lookup" and "best fit"; the default is "best fit".
For information about this option, see Locale identification and negotiation.

numberingSystem

The numbering system to use for number formatting, such as "arab", "hans", "mathsans", and so on. For a list of supported numbering system types, see Intl.supportedValuesOf(). This option can also be set through the nu Unicode extension key; if both are provided, this options property takes precedence.


Style options
Depending on the style used, some of them may be ignored, and others may be required:

style

The formatting style to use.

"decimal" (default)

For plain number formatting.

"currency"

For currency formatting.

"percent"

For percent formatting.

"unit"

For unit formatting.



currency

The currency to use in currency formatting. Possible values are the ISO 4217 currency codes, such as "USD" for the US dollar, "EUR" for the euro, or "CNY" for the Chinese RMB — see Intl.supportedValuesOf(). There is no default value; if the style is "currency", the currency property must be provided. It is normalized to uppercase.

currencyDisplay

How to display the currency in currency formatting.

"code"

Use the ISO currency code.

"symbol" (default)

Use a localized currency symbol such as €.

"narrowSymbol"

Use a narrow format symbol ("$100" rather than "US$100").

"name"

Use a localized currency name such as "dollar".



currencySign

In many locales, accounting format means to wrap the number with parentheses instead of appending a minus sign. Possible values are "standard" and "accounting"; the default is "standard".

unit

The unit to use in unit formatting, Possible values are listed in Intl.supportedValuesOf(). Pairs of simple units can be concatenated with "-per-" to make a compound unit. There is no default value; if the style is "unit", the unit property must be provided.

unitDisplay

The unit formatting style to use in unit formatting. Possible values are:

"short" (default)

E.g., 16 l.

"narrow"

E.g., 16l.

"long"

E.g., 16 litres.




Digit options
The following properties are also supported by Intl.PluralRules.

minimumIntegerDigits

The minimum number of integer digits to use. A value with a smaller number of integer digits than this number will be left-padded with zeros (to the specified length) when formatted. Possible values are from 1 to 21; the default is 1.

minimumFractionDigits

The minimum number of fraction digits to use. Possible values are from 0 to 100; the default for plain number and percent formatting is 0; the default for currency formatting is the number of minor unit digits provided by the ISO 4217 currency code list (2 if the list doesn't provide that information). See SignificantDigits/FractionDigits default values for when this default gets applied.

maximumFractionDigits

The maximum number of fraction digits to use. Possible values are from 0 to 100; the default for plain number formatting is the larger of minimumFractionDigits and 3; the default for currency formatting is the larger of minimumFractionDigits and the number of minor unit digits provided by the ISO 4217 currency code list (2 if the list doesn't provide that information); the default for percent formatting is the larger of minimumFractionDigits and 0. See SignificantDigits/FractionDigits default values for when this default gets applied.

minimumSignificantDigits

The minimum number of significant digits to use. Possible values are from 1 to 21; the default is 1. See SignificantDigits/FractionDigits default values for when this default gets applied.

maximumSignificantDigits

The maximum number of significant digits to use. Possible values are from 1 to 21; the default is 21. See SignificantDigits/FractionDigits default values for when this default gets applied.

roundingPriority

Specify how rounding conflicts will be resolved if both "FractionDigits" (minimumFractionDigits/maximumFractionDigits) and "SignificantDigits" (minimumSignificantDigits/maximumSignificantDigits) are specified.
Possible values are:

"auto" (default)

The result from the significant digits property is used.

"morePrecision"

The result from the property that results in more precision is used.

"lessPrecision"

The result from the property that results in less precision is used.


The value "auto" is normalized to "morePrecision" if notation is "compact" and none of the four "FractionDigits"/"SignificantDigits" options are set.
Note that for values other than auto the result with more precision is calculated from the maximumSignificantDigits and maximumFractionDigits (minimum fractional and significant digit settings are ignored).

roundingIncrement

Indicates the increment at which rounding should take place relative to the calculated rounding magnitude. Possible values are 1, 2, 5, 10, 20, 25, 50, 100, 200, 250, 500, 1000, 2000, 2500, and 5000; the default is 1. It cannot be mixed with significant-digits rounding or any setting of roundingPriority other than auto.

roundingMode

How decimals should be rounded. Possible values are:

"ceil"

Round toward +∞. Positive values round up. Negative values round "more positive".

"floor"

Round toward -∞. Positive values round down. Negative values round "more negative".

"expand"

Round away from 0. The magnitude of the value is always increased by rounding. Positive values round up. Negative values round "more negative".

"trunc"

Round toward 0. This magnitude of the value is always reduced by rounding. Positive values round down. Negative values round "less negative".

"halfCeil"

Ties toward +∞. Values above the half-increment round like "ceil" (towards +∞), and below like "floor" (towards -∞). On the half-increment, values round like "ceil".

"halfFloor"

Ties toward -∞. Values above the half-increment round like "ceil" (towards +∞), and below like "floor" (towards -∞). On the half-increment, values round like "floor".

"halfExpand" (default)

Ties away from 0. Values above the half-increment round like "expand" (away from zero), and below like "trunc" (towards 0). On the half-increment, values round like "expand".

"halfTrunc"

Ties toward 0. Values above the half-increment round like "expand" (away from zero), and below like "trunc" (towards 0). On the half-increment, values round like "trunc".

"halfEven"

Ties towards the nearest even integer. Values above the half-increment round like "expand" (away from zero), and below like "trunc" (towards 0). On the half-increment values round towards the nearest even digit.


These options reflect the ICU user guide, where "expand" and "trunc" map to ICU "UP" and "DOWN", respectively.
The rounding modes example below demonstrates how each mode works.

trailingZeroDisplay

The strategy for displaying trailing zeros on whole numbers. Possible values are:

"auto" (default)

Keep trailing zeros according to minimumFractionDigits and minimumSignificantDigits.

"stripIfInteger"

Remove the fraction digits if they are all zero. This is the same as "auto" if any of the fraction digits is non-zero.




SignificantDigits/FractionDigits default values
For the four options above (the FractionDigits and SignificantDigits options), we mentioned their defaults; however, these defaults are not unconditionally applied. They are only applied when the property is actually going to be used, which depends on the roundingPriority and notation settings. Specifically:

If roundingPriority is not "auto", then all four options apply.
If roundingPriority is "auto" and at least one SignificantDigits option is set, then the SignificantDigits options apply and the FractionDigits options are ignored.
If roundingPriority is "auto", and either at least one FractionDigits option is set or notation is not "compact", then the FractionDigits options apply and the SignificantDigits options are ignored.
If roundingPriority is "auto", notation is "compact", and none of the four options are set, then they are set to { minimumFractionDigits: 0, maximumFractionDigits: 0, minimumSignificantDigits: 1, maximumSignificantDigits: 2 }, regardless of the defaults mentioned above, and roundingPriority is set to "morePrecision".

Other options

notation

The formatting that should be displayed for the number. Possible values are:

"standard" (default)

Plain number formatting.

"scientific"

Return the order-of-magnitude for formatted number.

"engineering"

Return the exponent of ten when divisible by three.

"compact"

String representing exponent; defaults to using the "short" form.



compactDisplay

Only used when notation is "compact". Possible values are "short" and "long"; the default is "short".

useGrouping

Whether to use grouping separators, such as thousands separators or thousand/lakh/crore separators.

"always"

Display grouping separators even if the locale prefers otherwise.

"auto"

Display grouping separators based on the locale preference, which may also be dependent on the currency.

"min2"

Display grouping separators when there are at least 2 digits in a group.

true

Same as "always".

false

Display no grouping separators.


The default is "min2" if notation is "compact", and "auto" otherwise. The string values "true" and "false" are accepted, but are always converted to the default value.

signDisplay

When to display the sign for the number. Possible values are:

"auto" (default)

Sign display for negative numbers only, including negative zero.

"always"

Always display sign.

"exceptZero"

Sign display for positive and negative numbers, but not zero.

"negative"

Sign display for negative numbers only, excluding negative zero.

"never"

Never display sign.



Return valueA new Intl.NumberFormat object.

Note:
The text below describes behavior that is marked by the specification as "optional". It may not work in all environments. Check the browser compatibility table.

Normally, Intl.NumberFormat() can be called with or without new, and a new Intl.NumberFormat instance is returned in both cases. However, if the this value is an object that is instanceof Intl.NumberFormat (doesn't necessarily mean it's created via new Intl.NumberFormat; just that it has Intl.NumberFormat.prototype in its prototype chain), then the value of this is returned instead, with the newly created Intl.NumberFormat object hidden in a [Symbol(IntlLegacyConstructedSymbol)] property (a unique symbol that's reused between instances).
jsconst formatter = Intl.NumberFormat.call(
  { __proto__: Intl.NumberFormat.prototype },
  "en-US",
  { notation: "scientific" },
);
console.log(Object.getOwnPropertyDescriptors(formatter));
// {
//   [Symbol(IntlLegacyConstructedSymbol)]: {
//     value: NumberFormat [Intl.NumberFormat] {},
//     writable: false,
//     enumerable: false,
//     configurable: false
//   }
// }

Note that there's only one actual Intl.NumberFormat instance here: the one hidden in [Symbol(IntlLegacyConstructedSymbol)]. Calling the format() and resolvedOptions() methods on formatter would correctly use the options stored in that instance, but calling all other methods (e.g., formatRange()) would fail with "TypeError: formatRange method called on incompatible Object", because those methods don't consult the hidden instance's options.
This behavior, called ChainNumberFormat, does not happen when Intl.NumberFormat() is called without new but with this set to anything else that's not an instanceof Intl.NumberFormat. If you call it directly as Intl.NumberFormat(), the this value is Intl, and a new Intl.NumberFormat instance is created normally.Exceptions
RangeError

Thrown in one of the following cases:

A property that takes enumerated values (such as style, units, currency, and so on) is set to an invalid value.
Both maximumFractionDigits and minimumFractionDigits are set, and they are set to different values.
Note that depending on various formatting options, these properties can have default values.
It is therefore possible to get this error even if you only set one of the properties.


TypeError

Thrown if the options.style property is set to "unit" or "currency", and no value has been set for the corresponding property options.unit or options.currency.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst amount = 3500;

console.log(new Intl.NumberFormat().format(amount));
// '3,500' if in US English locale
Decimal and percent formattingjsconst amount = 3500;

new Intl.NumberFormat("en-US", {
  style: "decimal",
}).format(amount); // '3,500'
new Intl.NumberFormat("en-US", {
  style: "percent",
}).format(amount); // '350,000%'
Unit formattingIf the style is 'unit', a unit property must be provided.
Optionally, unitDisplay controls the unit formatting.
jsconst amount = 3500;

new Intl.NumberFormat("en-US", {
  style: "unit",
  unit: "liter",
}).format(amount); // '3,500 L'

new Intl.NumberFormat("en-US", {
  style: "unit",
  unit: "liter",
  unitDisplay: "long",
}).format(amount); // '3,500 liters'
Currency formattingIf the style is 'currency', a currency property
must be provided. Optionally, currencyDisplay and
currencySign control the unit formatting.
jsconst amount = -3500;
new Intl.NumberFormat("en-US", {
  style: "currency",
  currency: "USD",
}).format(amount); // '-$3,500.00'

new Intl.NumberFormat("bn", {
  style: "currency",
  currency: "USD",
  currencyDisplay: "name",
}).format(amount); // '-3,500.00 US dollars'

new Intl.NumberFormat("bn", {
  style: "currency",
  currency: "USD",
  currencySign: "accounting",
}).format(amount); // '($3,500.00)'
Scientific, engineering or compact notationsScientific and compact notation are represented by the notation option and can be formatted like this:
jsnew Intl.NumberFormat("en-US", {
  notation: "scientific",
}).format(987654321);
// 9.877E8

new Intl.NumberFormat("pt-PT", {
  notation: "scientific",
}).format(987654321);
// 9,877E8

new Intl.NumberFormat("en-GB", {
  notation: "engineering",
}).format(987654321);
// 987.654E6

new Intl.NumberFormat("de", {
  notation: "engineering",
}).format(987654321);
// 987,654E6

new Intl.NumberFormat("zh-CN", {
  notation: "compact",
}).format(987654321);
// 9.9亿

new Intl.NumberFormat("fr", {
  notation: "compact",
  compactDisplay: "long",
}).format(987654321);
// 988 millions

new Intl.NumberFormat("en-GB", {
  notation: "compact",
  compactDisplay: "short",
}).format(987654321);
// 988M
Displaying signsDisplay a sign for positive and negative numbers, but not zero:
jsnew Intl.NumberFormat("en-US", {
  style: "percent",
  signDisplay: "exceptZero",
}).format(0.55);
// '+55%'

Note that when the currency sign is "accounting", parentheses might be used instead of a minus sign:
jsnew Intl.NumberFormat("bn", {
  style: "currency",
  currency: "USD",
  currencySign: "accounting",
  signDisplay: "always",
}).format(-3500);
// '($3,500.00)'
FractionDigits, SignificantDigits and IntegerDigitsYou can specify the minimum or maximum number of fractional, integer or significant digits to display when formatting a number.

Note:
If both significant and fractional digit limits are specified, then the actual formatting depends on the roundingPriority.

Using FractionDigits and IntegerDigits
The integer and fraction digit properties indicate the number of digits to display before and after the decimal point, respectively.
If the value to display has fewer integer digits than specified, it will be left-padded with zeros to the expected number.
If it has fewer fractional digits, it will be right-padded with zeros.
Both cases are shown below:
js// Formatting adds zeros to display minimum integers and fractions
console.log(
  new Intl.NumberFormat("en", {
    minimumIntegerDigits: 3,
    minimumFractionDigits: 4,
  }).format(4.33),
);
// "004.3300"

If a value has more fractional digits than the specified maximum number, it will be rounded.
The way that it is rounded depends on the roundingMode property (more details are provided in the rounding modes section).
Below the value is rounded from five fractional digits (4.33145) to two (4.33):
js// Display value shortened to maximum number of digits
console.log(
  new Intl.NumberFormat("en", {
    maximumFractionDigits: 2,
  }).format(4.33145),
);
// "4.33"

The minimum fractional digits have no effect if the value already has more than 2 fractional digits:
js// Minimum fractions have no effect if value is higher precision.
console.log(
  new Intl.NumberFormat("en", {
    minimumFractionDigits: 2,
  }).format(4.33145),
);
// "4.331"


Warning:
Watch out for default values as they may affect formatting even if not specified in your code.
The default maximum digit value is 3 for plain values, 2 for currency, and may have different values for other predefined types.

The formatted value above is rounded to 3 digits, even though we didn't specify the maximum digits!
This is because a default value of maximumFractionDigits is set when we specify minimumFractionDigits, and visa versa. The default values of maximumFractionDigits and minimumFractionDigits are 3 and 0, respectively.
You can use resolvedOptions() to inspect the formatter.
jsconsole.log(
  new Intl.NumberFormat("en", {
    maximumFractionDigits: 2,
  }).resolvedOptions(),
);
// {
//   …
//   minimumIntegerDigits: 1,
//   minimumFractionDigits: 0,
//   maximumFractionDigits: 2,
//   …
// }

console.log(
  new Intl.NumberFormat("en", {
    minimumFractionDigits: 2,
  }).resolvedOptions(),
);
// {
//   …
//   minimumIntegerDigits: 1,
//   minimumFractionDigits: 2,
//   maximumFractionDigits: 3,
//   …
// }

Using SignificantDigits
The number of significant digits is the total number of digits including both integer and fractional parts.
The maximumSignificantDigits is used to indicate the total number of digits from the original value to display.
The examples below show how this works.
Note in particular the last case: only the first digit is retained and the others are discarded/set to zero.
js// Display 5 significant digits
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 5,
  }).format(54.33145),
);
// "54.331"

// Max 2 significant digits
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(54.33145),
);
// "54"

// Max 1 significant digits
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 1,
  }).format(54.33145),
);
// "50"

The minimumSignificantDigits ensures that at least the specified number of digits are displayed, adding zeros to the end of the value if needed.
js// Minimum 10 significant digits
console.log(
  new Intl.NumberFormat("en", {
    minimumSignificantDigits: 10,
  }).format(54.33145),
);
// "54.33145000"


Warning:
Watch out for default values as they may affect formatting.
If only one SignificantDigits property is used, then its counterpart will automatically be applied with the default value.
The default maximum and minimum significant digit values are 21 and 1, respectively.

Specifying significant and fractional digits at the same time
The fraction digits (minimumFractionDigits/maximumFractionDigits) and significant digits (minimumSignificantDigits/maximumSignificantDigits) are both ways of controlling how many fractional and leading digits should be formatted.
If both are used at the same time, it is possible for them to conflict.
These conflicts are resolved using the roundingPriority property.
By default, this has a value of "auto", which means that if either minimumSignificantDigits or maximumSignificantDigits is specified, the fractional and integer digit properties will be ignored.
For example, the code below formats the value of 4.33145 with maximumFractionDigits: 3, and then maximumSignificantDigits: 2, and then both.
The value with both is the one set with maximumSignificantDigits.
jsconsole.log(
  new Intl.NumberFormat("en", {
    maximumFractionDigits: 3,
  }).format(4.33145),
);
// "4.331"
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(4.33145),
);
// "4.3"
console.log(
  new Intl.NumberFormat("en", {
    maximumFractionDigits: 3,
    maximumSignificantDigits: 2,
  }).format(4.33145),
);
// "4.3"

Using resolvedOptions() to inspect the formatter, we can see that the returned object does not include maximumFractionDigits when maximumSignificantDigits or minimumSignificantDigits are specified.
jsconsole.log(
  new Intl.NumberFormat("en", {
    maximumFractionDigits: 3,
    maximumSignificantDigits: 2,
  }).resolvedOptions(),
);
// {
//   …
//   minimumIntegerDigits: 1,
//   minimumSignificantDigits: 1,
//   maximumSignificantDigits: 2,
//   …
// }
console.log(
  new Intl.NumberFormat("en", {
    maximumFractionDigits: 3,
    minimumSignificantDigits: 2,
  }).resolvedOptions(),
);
// {
//   …
//   minimumIntegerDigits: 1,
//   minimumSignificantDigits: 2,
//   maximumSignificantDigits: 21,
//   …
// }

In addition to "auto", you can resolve conflicts by specifying roundingPriority as "morePrecision" or "lessPrecision".
The formatter calculates the precision using the values of maximumSignificantDigits and maximumFractionDigits.
The code below shows the format being selected for the three different rounding priorities:
jsconst maxFracNF = new Intl.NumberFormat("en", {
  maximumFractionDigits: 3,
});
console.log(`maximumFractionDigits:3 - ${maxFracNF.format(1.23456)}`);
// "maximumFractionDigits:2 - 1.235"

const maxSigNS = new Intl.NumberFormat("en", {
  maximumSignificantDigits: 3,
});
console.log(`maximumSignificantDigits:3 - ${maxSigNS.format(1.23456)}`);
// "maximumSignificantDigits:3 - 1.23"

const bothAuto = new Intl.NumberFormat("en", {
  maximumSignificantDigits: 3,
  maximumFractionDigits: 3,
});
console.log(`auto - ${bothAuto.format(1.23456)}`);
// "auto - 1.23"

const bothLess = new Intl.NumberFormat("en", {
  roundingPriority: "lessPrecision",
  maximumSignificantDigits: 3,
  maximumFractionDigits: 3,
});
console.log(`lessPrecision - ${bothLess.format(1.23456)}`);
// "lessPrecision - 1.23"

const bothMore = new Intl.NumberFormat("en", {
  roundingPriority: "morePrecision",
  maximumSignificantDigits: 3,
  maximumFractionDigits: 3,
});
console.log(`morePrecision - ${bothMore.format(1.23456)}`);
// "morePrecision - 1.235"

Note that the algorithm can behave in an unintuitive way if a minimum value is specified without a maximum value.
The example below formats the value 1 specifying minimumFractionDigits: 2 (formatting to 1.00) and minimumSignificantDigits: 2 (formatting to 1.0).
Since 1.00 has more digits than 1.0, this should be the result when prioritizing morePrecision, but in fact the opposite is true:
jsconst bothLess = new Intl.NumberFormat("en", {
  roundingPriority: "lessPrecision",
  minimumFractionDigits: 2,
  minimumSignificantDigits: 2,
});
console.log(`lessPrecision - ${bothLess.format(1)}`);
// "lessPrecision - 1.00"

const bothMore = new Intl.NumberFormat("en", {
  roundingPriority: "morePrecision",
  minimumFractionDigits: 2,
  minimumSignificantDigits: 2,
});
console.log(`morePrecision - ${bothMore.format(1)}`);
// "morePrecision - 1.0"

The reason for this is that only the "maximum precision" values are used for the calculation, and the default value of maximumSignificantDigits is much higher than maximumFractionDigits.

Note:
The working group have proposed a modification of the algorithm where the formatter should evaluate the result of using the specified fractional and significant digits independently (taking account of both minimum and maximum values).
It will then select the option that displays more fractional digits if morePrecision is set, and fewer if lessPrecision is set.
This will result in more intuitive behavior for this case.
Rounding modesIf a value has more fractional digits than allowed by the constructor options, the formatted value will be rounded to the specified number of fractional digits.
The way in which the value is rounded depends on the roundingMode property.
Number formatters use halfExpand rounding by default, which rounds values "away from zero" at the half-increment (in other words, the magnitude of the value is rounded up).
For a positive number, if the fractional digits to be removed are closer to the next increment (or on the half way point) then the remaining fractional digits will be rounded up, otherwise they are rounded down.
This is shown below: 2.23 rounded to two significant digits is truncated to 2.2 because 2.23 is less than the half increment 2.25, while values of 2.25 and greater are rounded up to 2.3:
js// Value below half-increment: round down.
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(2.23),
);
// "2.2"

// Value on or above half-increment: round up.
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(2.25),
);
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(2.28),
);
// "2.3"
// "2.3"

A negative number on or below the half-increment point is also rounded away from zero (becomes more negative):
js// Value below half-increment: round down.
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(-2.23),
);
// "-2.2"

// Value on or above half-increment: round up.
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(-2.25),
);
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(-2.28),
);
// "-2.3"
// "-2.3"

The table below show the effect of different rounding modes for positive and negative values that are on and around the half-increment.



rounding mode
2.23
2.25
2.28
-2.23
-2.25
-2.28




ceil
2.3
2.3
2.3
-2.2
-2.2
-2.2


floor
2.2
2.2
2.2
-2.3
-2.3
-2.3


expand
2.3
2.3
2.3
-2.3
-2.3
-2.3


trunc
2.2
2.2
2.2
-2.2
-2.2
-2.2


halfCeil
2.2
2.3
2.3
-2.2
-2.2
-2.3


halfFloor
2.2
2.2
2.3
-2.2
-2.3
-2.3


halfExpand
2.2
2.3
2.3
-2.2
-2.3
-2.3


halfTrunc
2.2
2.2
2.3
-2.2
-2.2
-2.3


halfEven
2.2
2.2
2.3
-2.2
-2.2
-2.3



When using halfEven, its behavior also depends on the parity (odd or even) of the last digit of the rounded number. For example, the behavior of halfEven in the table above is the same as halfTrunc, because the magnitudes of all numbers are between a smaller "even" number (2.2) and a larger "odd" number (2.3). If the numbers are between ±2.3 and ±2.4, halfEven will behave like halfExpand instead. This behavior avoids consistently under- or over-estimating half-increments in a large data sample.Using roundingIncrementSometimes we want to round the remaining fractional digits to some other increment than the next integer.
For example, currencies for which the smallest coin is 5 cents might want to round the value to increments of 5, reflecting amounts that can actually be paid in cash.
This kind of rounding can be achieved with the roundingIncrement property.
For example, if maximumFractionDigits is 2 and roundingIncrement is 5, then the number is rounded to the nearest 0.05:
jsconst nf = new Intl.NumberFormat("en-US", {
  style: "currency",
  currency: "USD",
  maximumFractionDigits: 2,
  roundingIncrement: 5,
});

console.log(nf.format(11.29)); // "$11.30"
console.log(nf.format(11.25)); // "$11.25"
console.log(nf.format(11.22)); // "$11.20"

This particular pattern is referred to as "nickel rounding", where nickel is the colloquial name for a USA 5 cent coin.
To round to the nearest 10 cents ("dime rounding"), you could change roundingIncrement to 10.
jsconst nf = new Intl.NumberFormat("en-US", {
  style: "currency",
  currency: "USD",
  maximumFractionDigits: 2,
  roundingIncrement: 10,
});

console.log(nf.format(11.29)); // "$11.30"
console.log(nf.format(11.25)); // "$11.30"
console.log(nf.format(11.22)); // "$11.20"

You can also use roundingMode to change the rounding algorithm.
The example below shows how halfCeil rounding can be used to round the value "less positive" below the half-rounding increment and "more positive" if above or on the half-increment.
The incremented digit is "0.05" so the half-increment is at .025 (below, this is shown at 11.225).
jsconst nf = new Intl.NumberFormat("en-US", {
  style: "currency",
  currency: "USD",
  maximumFractionDigits: 2,
  roundingIncrement: 5,
  roundingMode: "halfCeil",
});

console.log(nf.format(11.21)); // "$11.20"
console.log(nf.format(11.22)); // "$11.20"
console.log(nf.format(11.224)); // "$11.20"
console.log(nf.format(11.225)); // "$11.25"
console.log(nf.format(11.23)); // "$11.25"

If you need to change the number of digits, remember that minimumFractionDigits and maximumFractionDigits must both be set to the same value, or a RangeError is thrown.
roundingIncrement cannot be mixed with significant-digits rounding or any setting of roundingPriority other than auto.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # sec-intl-numberformat-constructorBrowser compatibilitySee also
Intl.NumberFormat
Intl.supportedValuesOf()
Intl\n\nIntl.NumberFormat() constructorBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat() constructor creates Intl.NumberFormat objects.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Syntaxjsnew Intl.NumberFormat()
new Intl.NumberFormat(locales)
new Intl.NumberFormat(locales, options)

Intl.NumberFormat()
Intl.NumberFormat(locales)
Intl.NumberFormat(locales, options)


Note: Intl.NumberFormat() can be called with or without new. Both create a new Intl.NumberFormat instance. However, there's a special behavior when it's called without new and the this value is another Intl.NumberFormat instance; see Return value.
Parameters
locales Optional

A string with a BCP 47 language tag or an Intl.Locale instance, or an array of such locale identifiers. The runtime's default locale is used when undefined is passed or when none of the specified locale identifiers is supported. For the general form and interpretation of the locales argument, see the parameter description on the Intl main page.
The following Unicode extension key is allowed:

nu

See numberingSystem.


This key can also be set with options (as listed below). When both are set, the options property takes precedence.

options Optional

An object. For ease of reading, the property list is broken into sections based on their purposes, including locale options, style options, digit options, and other options.


Locale options

localeMatcher

The locale matching algorithm to use. Possible values are "lookup" and "best fit"; the default is "best fit".
For information about this option, see Locale identification and negotiation.

numberingSystem

The numbering system to use for number formatting, such as "arab", "hans", "mathsans", and so on. For a list of supported numbering system types, see Intl.supportedValuesOf(). This option can also be set through the nu Unicode extension key; if both are provided, this options property takes precedence.


Style options
Depending on the style used, some of them may be ignored, and others may be required:

style

The formatting style to use.

"decimal" (default)

For plain number formatting.

"currency"

For currency formatting.

"percent"

For percent formatting.

"unit"

For unit formatting.



currency

The currency to use in currency formatting. Possible values are the ISO 4217 currency codes, such as "USD" for the US dollar, "EUR" for the euro, or "CNY" for the Chinese RMB — see Intl.supportedValuesOf(). There is no default value; if the style is "currency", the currency property must be provided. It is normalized to uppercase.

currencyDisplay

How to display the currency in currency formatting.

"code"

Use the ISO currency code.

"symbol" (default)

Use a localized currency symbol such as €.

"narrowSymbol"

Use a narrow format symbol ("$100" rather than "US$100").

"name"

Use a localized currency name such as "dollar".



currencySign

In many locales, accounting format means to wrap the number with parentheses instead of appending a minus sign. Possible values are "standard" and "accounting"; the default is "standard".

unit

The unit to use in unit formatting, Possible values are listed in Intl.supportedValuesOf(). Pairs of simple units can be concatenated with "-per-" to make a compound unit. There is no default value; if the style is "unit", the unit property must be provided.

unitDisplay

The unit formatting style to use in unit formatting. Possible values are:

"short" (default)

E.g., 16 l.

"narrow"

E.g., 16l.

"long"

E.g., 16 litres.




Digit options
The following properties are also supported by Intl.PluralRules.

minimumIntegerDigits

The minimum number of integer digits to use. A value with a smaller number of integer digits than this number will be left-padded with zeros (to the specified length) when formatted. Possible values are from 1 to 21; the default is 1.

minimumFractionDigits

The minimum number of fraction digits to use. Possible values are from 0 to 100; the default for plain number and percent formatting is 0; the default for currency formatting is the number of minor unit digits provided by the ISO 4217 currency code list (2 if the list doesn't provide that information). See SignificantDigits/FractionDigits default values for when this default gets applied.

maximumFractionDigits

The maximum number of fraction digits to use. Possible values are from 0 to 100; the default for plain number formatting is the larger of minimumFractionDigits and 3; the default for currency formatting is the larger of minimumFractionDigits and the number of minor unit digits provided by the ISO 4217 currency code list (2 if the list doesn't provide that information); the default for percent formatting is the larger of minimumFractionDigits and 0. See SignificantDigits/FractionDigits default values for when this default gets applied.

minimumSignificantDigits

The minimum number of significant digits to use. Possible values are from 1 to 21; the default is 1. See SignificantDigits/FractionDigits default values for when this default gets applied.

maximumSignificantDigits

The maximum number of significant digits to use. Possible values are from 1 to 21; the default is 21. See SignificantDigits/FractionDigits default values for when this default gets applied.

roundingPriority

Specify how rounding conflicts will be resolved if both "FractionDigits" (minimumFractionDigits/maximumFractionDigits) and "SignificantDigits" (minimumSignificantDigits/maximumSignificantDigits) are specified.
Possible values are:

"auto" (default)

The result from the significant digits property is used.

"morePrecision"

The result from the property that results in more precision is used.

"lessPrecision"

The result from the property that results in less precision is used.


The value "auto" is normalized to "morePrecision" if notation is "compact" and none of the four "FractionDigits"/"SignificantDigits" options are set.
Note that for values other than auto the result with more precision is calculated from the maximumSignificantDigits and maximumFractionDigits (minimum fractional and significant digit settings are ignored).

roundingIncrement

Indicates the increment at which rounding should take place relative to the calculated rounding magnitude. Possible values are 1, 2, 5, 10, 20, 25, 50, 100, 200, 250, 500, 1000, 2000, 2500, and 5000; the default is 1. It cannot be mixed with significant-digits rounding or any setting of roundingPriority other than auto.

roundingMode

How decimals should be rounded. Possible values are:

"ceil"

Round toward +∞. Positive values round up. Negative values round "more positive".

"floor"

Round toward -∞. Positive values round down. Negative values round "more negative".

"expand"

Round away from 0. The magnitude of the value is always increased by rounding. Positive values round up. Negative values round "more negative".

"trunc"

Round toward 0. This magnitude of the value is always reduced by rounding. Positive values round down. Negative values round "less negative".

"halfCeil"

Ties toward +∞. Values above the half-increment round like "ceil" (towards +∞), and below like "floor" (towards -∞). On the half-increment, values round like "ceil".

"halfFloor"

Ties toward -∞. Values above the half-increment round like "ceil" (towards +∞), and below like "floor" (towards -∞). On the half-increment, values round like "floor".

"halfExpand" (default)

Ties away from 0. Values above the half-increment round like "expand" (away from zero), and below like "trunc" (towards 0). On the half-increment, values round like "expand".

"halfTrunc"

Ties toward 0. Values above the half-increment round like "expand" (away from zero), and below like "trunc" (towards 0). On the half-increment, values round like "trunc".

"halfEven"

Ties towards the nearest even integer. Values above the half-increment round like "expand" (away from zero), and below like "trunc" (towards 0). On the half-increment values round towards the nearest even digit.


These options reflect the ICU user guide, where "expand" and "trunc" map to ICU "UP" and "DOWN", respectively.
The rounding modes example below demonstrates how each mode works.

trailingZeroDisplay

The strategy for displaying trailing zeros on whole numbers. Possible values are:

"auto" (default)

Keep trailing zeros according to minimumFractionDigits and minimumSignificantDigits.

"stripIfInteger"

Remove the fraction digits if they are all zero. This is the same as "auto" if any of the fraction digits is non-zero.




SignificantDigits/FractionDigits default values
For the four options above (the FractionDigits and SignificantDigits options), we mentioned their defaults; however, these defaults are not unconditionally applied. They are only applied when the property is actually going to be used, which depends on the roundingPriority and notation settings. Specifically:

If roundingPriority is not "auto", then all four options apply.
If roundingPriority is "auto" and at least one SignificantDigits option is set, then the SignificantDigits options apply and the FractionDigits options are ignored.
If roundingPriority is "auto", and either at least one FractionDigits option is set or notation is not "compact", then the FractionDigits options apply and the SignificantDigits options are ignored.
If roundingPriority is "auto", notation is "compact", and none of the four options are set, then they are set to { minimumFractionDigits: 0, maximumFractionDigits: 0, minimumSignificantDigits: 1, maximumSignificantDigits: 2 }, regardless of the defaults mentioned above, and roundingPriority is set to "morePrecision".

Other options

notation

The formatting that should be displayed for the number. Possible values are:

"standard" (default)

Plain number formatting.

"scientific"

Return the order-of-magnitude for formatted number.

"engineering"

Return the exponent of ten when divisible by three.

"compact"

String representing exponent; defaults to using the "short" form.



compactDisplay

Only used when notation is "compact". Possible values are "short" and "long"; the default is "short".

useGrouping

Whether to use grouping separators, such as thousands separators or thousand/lakh/crore separators.

"always"

Display grouping separators even if the locale prefers otherwise.

"auto"

Display grouping separators based on the locale preference, which may also be dependent on the currency.

"min2"

Display grouping separators when there are at least 2 digits in a group.

true

Same as "always".

false

Display no grouping separators.


The default is "min2" if notation is "compact", and "auto" otherwise. The string values "true" and "false" are accepted, but are always converted to the default value.

signDisplay

When to display the sign for the number. Possible values are:

"auto" (default)

Sign display for negative numbers only, including negative zero.

"always"

Always display sign.

"exceptZero"

Sign display for positive and negative numbers, but not zero.

"negative"

Sign display for negative numbers only, excluding negative zero.

"never"

Never display sign.



Return valueA new Intl.NumberFormat object.

Note:
The text below describes behavior that is marked by the specification as "optional". It may not work in all environments. Check the browser compatibility table.

Normally, Intl.NumberFormat() can be called with or without new, and a new Intl.NumberFormat instance is returned in both cases. However, if the this value is an object that is instanceof Intl.NumberFormat (doesn't necessarily mean it's created via new Intl.NumberFormat; just that it has Intl.NumberFormat.prototype in its prototype chain), then the value of this is returned instead, with the newly created Intl.NumberFormat object hidden in a [Symbol(IntlLegacyConstructedSymbol)] property (a unique symbol that's reused between instances).
jsconst formatter = Intl.NumberFormat.call(
  { __proto__: Intl.NumberFormat.prototype },
  "en-US",
  { notation: "scientific" },
);
console.log(Object.getOwnPropertyDescriptors(formatter));
// {
//   [Symbol(IntlLegacyConstructedSymbol)]: {
//     value: NumberFormat [Intl.NumberFormat] {},
//     writable: false,
//     enumerable: false,
//     configurable: false
//   }
// }

Note that there's only one actual Intl.NumberFormat instance here: the one hidden in [Symbol(IntlLegacyConstructedSymbol)]. Calling the format() and resolvedOptions() methods on formatter would correctly use the options stored in that instance, but calling all other methods (e.g., formatRange()) would fail with "TypeError: formatRange method called on incompatible Object", because those methods don't consult the hidden instance's options.
This behavior, called ChainNumberFormat, does not happen when Intl.NumberFormat() is called without new but with this set to anything else that's not an instanceof Intl.NumberFormat. If you call it directly as Intl.NumberFormat(), the this value is Intl, and a new Intl.NumberFormat instance is created normally.Exceptions
RangeError

Thrown in one of the following cases:

A property that takes enumerated values (such as style, units, currency, and so on) is set to an invalid value.
Both maximumFractionDigits and minimumFractionDigits are set, and they are set to different values.
Note that depending on various formatting options, these properties can have default values.
It is therefore possible to get this error even if you only set one of the properties.


TypeError

Thrown if the options.style property is set to "unit" or "currency", and no value has been set for the corresponding property options.unit or options.currency.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst amount = 3500;

console.log(new Intl.NumberFormat().format(amount));
// '3,500' if in US English locale
Decimal and percent formattingjsconst amount = 3500;

new Intl.NumberFormat("en-US", {
  style: "decimal",
}).format(amount); // '3,500'
new Intl.NumberFormat("en-US", {
  style: "percent",
}).format(amount); // '350,000%'
Unit formattingIf the style is 'unit', a unit property must be provided.
Optionally, unitDisplay controls the unit formatting.
jsconst amount = 3500;

new Intl.NumberFormat("en-US", {
  style: "unit",
  unit: "liter",
}).format(amount); // '3,500 L'

new Intl.NumberFormat("en-US", {
  style: "unit",
  unit: "liter",
  unitDisplay: "long",
}).format(amount); // '3,500 liters'
Currency formattingIf the style is 'currency', a currency property
must be provided. Optionally, currencyDisplay and
currencySign control the unit formatting.
jsconst amount = -3500;
new Intl.NumberFormat("en-US", {
  style: "currency",
  currency: "USD",
}).format(amount); // '-$3,500.00'

new Intl.NumberFormat("bn", {
  style: "currency",
  currency: "USD",
  currencyDisplay: "name",
}).format(amount); // '-3,500.00 US dollars'

new Intl.NumberFormat("bn", {
  style: "currency",
  currency: "USD",
  currencySign: "accounting",
}).format(amount); // '($3,500.00)'
Scientific, engineering or compact notationsScientific and compact notation are represented by the notation option and can be formatted like this:
jsnew Intl.NumberFormat("en-US", {
  notation: "scientific",
}).format(987654321);
// 9.877E8

new Intl.NumberFormat("pt-PT", {
  notation: "scientific",
}).format(987654321);
// 9,877E8

new Intl.NumberFormat("en-GB", {
  notation: "engineering",
}).format(987654321);
// 987.654E6

new Intl.NumberFormat("de", {
  notation: "engineering",
}).format(987654321);
// 987,654E6

new Intl.NumberFormat("zh-CN", {
  notation: "compact",
}).format(987654321);
// 9.9亿

new Intl.NumberFormat("fr", {
  notation: "compact",
  compactDisplay: "long",
}).format(987654321);
// 988 millions

new Intl.NumberFormat("en-GB", {
  notation: "compact",
  compactDisplay: "short",
}).format(987654321);
// 988M
Displaying signsDisplay a sign for positive and negative numbers, but not zero:
jsnew Intl.NumberFormat("en-US", {
  style: "percent",
  signDisplay: "exceptZero",
}).format(0.55);
// '+55%'

Note that when the currency sign is "accounting", parentheses might be used instead of a minus sign:
jsnew Intl.NumberFormat("bn", {
  style: "currency",
  currency: "USD",
  currencySign: "accounting",
  signDisplay: "always",
}).format(-3500);
// '($3,500.00)'
FractionDigits, SignificantDigits and IntegerDigitsYou can specify the minimum or maximum number of fractional, integer or significant digits to display when formatting a number.

Note:
If both significant and fractional digit limits are specified, then the actual formatting depends on the roundingPriority.

Using FractionDigits and IntegerDigits
The integer and fraction digit properties indicate the number of digits to display before and after the decimal point, respectively.
If the value to display has fewer integer digits than specified, it will be left-padded with zeros to the expected number.
If it has fewer fractional digits, it will be right-padded with zeros.
Both cases are shown below:
js// Formatting adds zeros to display minimum integers and fractions
console.log(
  new Intl.NumberFormat("en", {
    minimumIntegerDigits: 3,
    minimumFractionDigits: 4,
  }).format(4.33),
);
// "004.3300"

If a value has more fractional digits than the specified maximum number, it will be rounded.
The way that it is rounded depends on the roundingMode property (more details are provided in the rounding modes section).
Below the value is rounded from five fractional digits (4.33145) to two (4.33):
js// Display value shortened to maximum number of digits
console.log(
  new Intl.NumberFormat("en", {
    maximumFractionDigits: 2,
  }).format(4.33145),
);
// "4.33"

The minimum fractional digits have no effect if the value already has more than 2 fractional digits:
js// Minimum fractions have no effect if value is higher precision.
console.log(
  new Intl.NumberFormat("en", {
    minimumFractionDigits: 2,
  }).format(4.33145),
);
// "4.331"


Warning:
Watch out for default values as they may affect formatting even if not specified in your code.
The default maximum digit value is 3 for plain values, 2 for currency, and may have different values for other predefined types.

The formatted value above is rounded to 3 digits, even though we didn't specify the maximum digits!
This is because a default value of maximumFractionDigits is set when we specify minimumFractionDigits, and visa versa. The default values of maximumFractionDigits and minimumFractionDigits are 3 and 0, respectively.
You can use resolvedOptions() to inspect the formatter.
jsconsole.log(
  new Intl.NumberFormat("en", {
    maximumFractionDigits: 2,
  }).resolvedOptions(),
);
// {
//   …
//   minimumIntegerDigits: 1,
//   minimumFractionDigits: 0,
//   maximumFractionDigits: 2,
//   …
// }

console.log(
  new Intl.NumberFormat("en", {
    minimumFractionDigits: 2,
  }).resolvedOptions(),
);
// {
//   …
//   minimumIntegerDigits: 1,
//   minimumFractionDigits: 2,
//   maximumFractionDigits: 3,
//   …
// }

Using SignificantDigits
The number of significant digits is the total number of digits including both integer and fractional parts.
The maximumSignificantDigits is used to indicate the total number of digits from the original value to display.
The examples below show how this works.
Note in particular the last case: only the first digit is retained and the others are discarded/set to zero.
js// Display 5 significant digits
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 5,
  }).format(54.33145),
);
// "54.331"

// Max 2 significant digits
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(54.33145),
);
// "54"

// Max 1 significant digits
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 1,
  }).format(54.33145),
);
// "50"

The minimumSignificantDigits ensures that at least the specified number of digits are displayed, adding zeros to the end of the value if needed.
js// Minimum 10 significant digits
console.log(
  new Intl.NumberFormat("en", {
    minimumSignificantDigits: 10,
  }).format(54.33145),
);
// "54.33145000"


Warning:
Watch out for default values as they may affect formatting.
If only one SignificantDigits property is used, then its counterpart will automatically be applied with the default value.
The default maximum and minimum significant digit values are 21 and 1, respectively.

Specifying significant and fractional digits at the same time
The fraction digits (minimumFractionDigits/maximumFractionDigits) and significant digits (minimumSignificantDigits/maximumSignificantDigits) are both ways of controlling how many fractional and leading digits should be formatted.
If both are used at the same time, it is possible for them to conflict.
These conflicts are resolved using the roundingPriority property.
By default, this has a value of "auto", which means that if either minimumSignificantDigits or maximumSignificantDigits is specified, the fractional and integer digit properties will be ignored.
For example, the code below formats the value of 4.33145 with maximumFractionDigits: 3, and then maximumSignificantDigits: 2, and then both.
The value with both is the one set with maximumSignificantDigits.
jsconsole.log(
  new Intl.NumberFormat("en", {
    maximumFractionDigits: 3,
  }).format(4.33145),
);
// "4.331"
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(4.33145),
);
// "4.3"
console.log(
  new Intl.NumberFormat("en", {
    maximumFractionDigits: 3,
    maximumSignificantDigits: 2,
  }).format(4.33145),
);
// "4.3"

Using resolvedOptions() to inspect the formatter, we can see that the returned object does not include maximumFractionDigits when maximumSignificantDigits or minimumSignificantDigits are specified.
jsconsole.log(
  new Intl.NumberFormat("en", {
    maximumFractionDigits: 3,
    maximumSignificantDigits: 2,
  }).resolvedOptions(),
);
// {
//   …
//   minimumIntegerDigits: 1,
//   minimumSignificantDigits: 1,
//   maximumSignificantDigits: 2,
//   …
// }
console.log(
  new Intl.NumberFormat("en", {
    maximumFractionDigits: 3,
    minimumSignificantDigits: 2,
  }).resolvedOptions(),
);
// {
//   …
//   minimumIntegerDigits: 1,
//   minimumSignificantDigits: 2,
//   maximumSignificantDigits: 21,
//   …
// }

In addition to "auto", you can resolve conflicts by specifying roundingPriority as "morePrecision" or "lessPrecision".
The formatter calculates the precision using the values of maximumSignificantDigits and maximumFractionDigits.
The code below shows the format being selected for the three different rounding priorities:
jsconst maxFracNF = new Intl.NumberFormat("en", {
  maximumFractionDigits: 3,
});
console.log(`maximumFractionDigits:3 - ${maxFracNF.format(1.23456)}`);
// "maximumFractionDigits:2 - 1.235"

const maxSigNS = new Intl.NumberFormat("en", {
  maximumSignificantDigits: 3,
});
console.log(`maximumSignificantDigits:3 - ${maxSigNS.format(1.23456)}`);
// "maximumSignificantDigits:3 - 1.23"

const bothAuto = new Intl.NumberFormat("en", {
  maximumSignificantDigits: 3,
  maximumFractionDigits: 3,
});
console.log(`auto - ${bothAuto.format(1.23456)}`);
// "auto - 1.23"

const bothLess = new Intl.NumberFormat("en", {
  roundingPriority: "lessPrecision",
  maximumSignificantDigits: 3,
  maximumFractionDigits: 3,
});
console.log(`lessPrecision - ${bothLess.format(1.23456)}`);
// "lessPrecision - 1.23"

const bothMore = new Intl.NumberFormat("en", {
  roundingPriority: "morePrecision",
  maximumSignificantDigits: 3,
  maximumFractionDigits: 3,
});
console.log(`morePrecision - ${bothMore.format(1.23456)}`);
// "morePrecision - 1.235"

Note that the algorithm can behave in an unintuitive way if a minimum value is specified without a maximum value.
The example below formats the value 1 specifying minimumFractionDigits: 2 (formatting to 1.00) and minimumSignificantDigits: 2 (formatting to 1.0).
Since 1.00 has more digits than 1.0, this should be the result when prioritizing morePrecision, but in fact the opposite is true:
jsconst bothLess = new Intl.NumberFormat("en", {
  roundingPriority: "lessPrecision",
  minimumFractionDigits: 2,
  minimumSignificantDigits: 2,
});
console.log(`lessPrecision - ${bothLess.format(1)}`);
// "lessPrecision - 1.00"

const bothMore = new Intl.NumberFormat("en", {
  roundingPriority: "morePrecision",
  minimumFractionDigits: 2,
  minimumSignificantDigits: 2,
});
console.log(`morePrecision - ${bothMore.format(1)}`);
// "morePrecision - 1.0"

The reason for this is that only the "maximum precision" values are used for the calculation, and the default value of maximumSignificantDigits is much higher than maximumFractionDigits.

Note:
The working group have proposed a modification of the algorithm where the formatter should evaluate the result of using the specified fractional and significant digits independently (taking account of both minimum and maximum values).
It will then select the option that displays more fractional digits if morePrecision is set, and fewer if lessPrecision is set.
This will result in more intuitive behavior for this case.
Rounding modesIf a value has more fractional digits than allowed by the constructor options, the formatted value will be rounded to the specified number of fractional digits.
The way in which the value is rounded depends on the roundingMode property.
Number formatters use halfExpand rounding by default, which rounds values "away from zero" at the half-increment (in other words, the magnitude of the value is rounded up).
For a positive number, if the fractional digits to be removed are closer to the next increment (or on the half way point) then the remaining fractional digits will be rounded up, otherwise they are rounded down.
This is shown below: 2.23 rounded to two significant digits is truncated to 2.2 because 2.23 is less than the half increment 2.25, while values of 2.25 and greater are rounded up to 2.3:
js// Value below half-increment: round down.
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(2.23),
);
// "2.2"

// Value on or above half-increment: round up.
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(2.25),
);
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(2.28),
);
// "2.3"
// "2.3"

A negative number on or below the half-increment point is also rounded away from zero (becomes more negative):
js// Value below half-increment: round down.
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(-2.23),
);
// "-2.2"

// Value on or above half-increment: round up.
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(-2.25),
);
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(-2.28),
);
// "-2.3"
// "-2.3"

The table below show the effect of different rounding modes for positive and negative values that are on and around the half-increment.



rounding mode
2.23
2.25
2.28
-2.23
-2.25
-2.28




ceil
2.3
2.3
2.3
-2.2
-2.2
-2.2


floor
2.2
2.2
2.2
-2.3
-2.3
-2.3


expand
2.3
2.3
2.3
-2.3
-2.3
-2.3


trunc
2.2
2.2
2.2
-2.2
-2.2
-2.2


halfCeil
2.2
2.3
2.3
-2.2
-2.2
-2.3


halfFloor
2.2
2.2
2.3
-2.2
-2.3
-2.3


halfExpand
2.2
2.3
2.3
-2.2
-2.3
-2.3


halfTrunc
2.2
2.2
2.3
-2.2
-2.2
-2.3


halfEven
2.2
2.2
2.3
-2.2
-2.2
-2.3



When using halfEven, its behavior also depends on the parity (odd or even) of the last digit of the rounded number. For example, the behavior of halfEven in the table above is the same as halfTrunc, because the magnitudes of all numbers are between a smaller "even" number (2.2) and a larger "odd" number (2.3). If the numbers are between ±2.3 and ±2.4, halfEven will behave like halfExpand instead. This behavior avoids consistently under- or over-estimating half-increments in a large data sample.Using roundingIncrementSometimes we want to round the remaining fractional digits to some other increment than the next integer.
For example, currencies for which the smallest coin is 5 cents might want to round the value to increments of 5, reflecting amounts that can actually be paid in cash.
This kind of rounding can be achieved with the roundingIncrement property.
For example, if maximumFractionDigits is 2 and roundingIncrement is 5, then the number is rounded to the nearest 0.05:
jsconst nf = new Intl.NumberFormat("en-US", {
  style: "currency",
  currency: "USD",
  maximumFractionDigits: 2,
  roundingIncrement: 5,
});

console.log(nf.format(11.29)); // "$11.30"
console.log(nf.format(11.25)); // "$11.25"
console.log(nf.format(11.22)); // "$11.20"

This particular pattern is referred to as "nickel rounding", where nickel is the colloquial name for a USA 5 cent coin.
To round to the nearest 10 cents ("dime rounding"), you could change roundingIncrement to 10.
jsconst nf = new Intl.NumberFormat("en-US", {
  style: "currency",
  currency: "USD",
  maximumFractionDigits: 2,
  roundingIncrement: 10,
});

console.log(nf.format(11.29)); // "$11.30"
console.log(nf.format(11.25)); // "$11.30"
console.log(nf.format(11.22)); // "$11.20"

You can also use roundingMode to change the rounding algorithm.
The example below shows how halfCeil rounding can be used to round the value "less positive" below the half-rounding increment and "more positive" if above or on the half-increment.
The incremented digit is "0.05" so the half-increment is at .025 (below, this is shown at 11.225).
jsconst nf = new Intl.NumberFormat("en-US", {
  style: "currency",
  currency: "USD",
  maximumFractionDigits: 2,
  roundingIncrement: 5,
  roundingMode: "halfCeil",
});

console.log(nf.format(11.21)); // "$11.20"
console.log(nf.format(11.22)); // "$11.20"
console.log(nf.format(11.224)); // "$11.20"
console.log(nf.format(11.225)); // "$11.25"
console.log(nf.format(11.23)); // "$11.25"

If you need to change the number of digits, remember that minimumFractionDigits and maximumFractionDigits must both be set to the same value, or a RangeError is thrown.
roundingIncrement cannot be mixed with significant-digits rounding or any setting of roundingPriority other than auto.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # sec-intl-numberformat-constructorBrowser compatibilitySee also
Intl.NumberFormat
Intl.supportedValuesOf()
Intl
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 4, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIntl.NumberFormat() constructorBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat() constructor creates Intl.NumberFormat objects.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Syntaxjsnew Intl.NumberFormat()
new Intl.NumberFormat(locales)
new Intl.NumberFormat(locales, options)

Intl.NumberFormat()
Intl.NumberFormat(locales)
Intl.NumberFormat(locales, options)


Note: Intl.NumberFormat() can be called with or without new. Both create a new Intl.NumberFormat instance. However, there's a special behavior when it's called without new and the this value is another Intl.NumberFormat instance; see Return value.
Parameters
locales Optional

A string with a BCP 47 language tag or an Intl.Locale instance, or an array of such locale identifiers. The runtime's default locale is used when undefined is passed or when none of the specified locale identifiers is supported. For the general form and interpretation of the locales argument, see the parameter description on the Intl main page.
The following Unicode extension key is allowed:

nu

See numberingSystem.


This key can also be set with options (as listed below). When both are set, the options property takes precedence.

options Optional

An object. For ease of reading, the property list is broken into sections based on their purposes, including locale options, style options, digit options, and other options.


Locale options

localeMatcher

The locale matching algorithm to use. Possible values are "lookup" and "best fit"; the default is "best fit".
For information about this option, see Locale identification and negotiation.

numberingSystem

The numbering system to use for number formatting, such as "arab", "hans", "mathsans", and so on. For a list of supported numbering system types, see Intl.supportedValuesOf(). This option can also be set through the nu Unicode extension key; if both are provided, this options property takes precedence.


Style options
Depending on the style used, some of them may be ignored, and others may be required:

style

The formatting style to use.

"decimal" (default)

For plain number formatting.

"currency"

For currency formatting.

"percent"

For percent formatting.

"unit"

For unit formatting.



currency

The currency to use in currency formatting. Possible values are the ISO 4217 currency codes, such as "USD" for the US dollar, "EUR" for the euro, or "CNY" for the Chinese RMB — see Intl.supportedValuesOf(). There is no default value; if the style is "currency", the currency property must be provided. It is normalized to uppercase.

currencyDisplay

How to display the currency in currency formatting.

"code"

Use the ISO currency code.

"symbol" (default)

Use a localized currency symbol such as €.

"narrowSymbol"

Use a narrow format symbol ("$100" rather than "US$100").

"name"

Use a localized currency name such as "dollar".



currencySign

In many locales, accounting format means to wrap the number with parentheses instead of appending a minus sign. Possible values are "standard" and "accounting"; the default is "standard".

unit

The unit to use in unit formatting, Possible values are listed in Intl.supportedValuesOf(). Pairs of simple units can be concatenated with "-per-" to make a compound unit. There is no default value; if the style is "unit", the unit property must be provided.

unitDisplay

The unit formatting style to use in unit formatting. Possible values are:

"short" (default)

E.g., 16 l.

"narrow"

E.g., 16l.

"long"

E.g., 16 litres.




Digit options
The following properties are also supported by Intl.PluralRules.

minimumIntegerDigits

The minimum number of integer digits to use. A value with a smaller number of integer digits than this number will be left-padded with zeros (to the specified length) when formatted. Possible values are from 1 to 21; the default is 1.

minimumFractionDigits

The minimum number of fraction digits to use. Possible values are from 0 to 100; the default for plain number and percent formatting is 0; the default for currency formatting is the number of minor unit digits provided by the ISO 4217 currency code list (2 if the list doesn't provide that information). See SignificantDigits/FractionDigits default values for when this default gets applied.

maximumFractionDigits

The maximum number of fraction digits to use. Possible values are from 0 to 100; the default for plain number formatting is the larger of minimumFractionDigits and 3; the default for currency formatting is the larger of minimumFractionDigits and the number of minor unit digits provided by the ISO 4217 currency code list (2 if the list doesn't provide that information); the default for percent formatting is the larger of minimumFractionDigits and 0. See SignificantDigits/FractionDigits default values for when this default gets applied.

minimumSignificantDigits

The minimum number of significant digits to use. Possible values are from 1 to 21; the default is 1. See SignificantDigits/FractionDigits default values for when this default gets applied.

maximumSignificantDigits

The maximum number of significant digits to use. Possible values are from 1 to 21; the default is 21. See SignificantDigits/FractionDigits default values for when this default gets applied.

roundingPriority

Specify how rounding conflicts will be resolved if both "FractionDigits" (minimumFractionDigits/maximumFractionDigits) and "SignificantDigits" (minimumSignificantDigits/maximumSignificantDigits) are specified.
Possible values are:

"auto" (default)

The result from the significant digits property is used.

"morePrecision"

The result from the property that results in more precision is used.

"lessPrecision"

The result from the property that results in less precision is used.


The value "auto" is normalized to "morePrecision" if notation is "compact" and none of the four "FractionDigits"/"SignificantDigits" options are set.
Note that for values other than auto the result with more precision is calculated from the maximumSignificantDigits and maximumFractionDigits (minimum fractional and significant digit settings are ignored).

roundingIncrement

Indicates the increment at which rounding should take place relative to the calculated rounding magnitude. Possible values are 1, 2, 5, 10, 20, 25, 50, 100, 200, 250, 500, 1000, 2000, 2500, and 5000; the default is 1. It cannot be mixed with significant-digits rounding or any setting of roundingPriority other than auto.

roundingMode

How decimals should be rounded. Possible values are:

"ceil"

Round toward +∞. Positive values round up. Negative values round "more positive".

"floor"

Round toward -∞. Positive values round down. Negative values round "more negative".

"expand"

Round away from 0. The magnitude of the value is always increased by rounding. Positive values round up. Negative values round "more negative".

"trunc"

Round toward 0. This magnitude of the value is always reduced by rounding. Positive values round down. Negative values round "less negative".

"halfCeil"

Ties toward +∞. Values above the half-increment round like "ceil" (towards +∞), and below like "floor" (towards -∞). On the half-increment, values round like "ceil".

"halfFloor"

Ties toward -∞. Values above the half-increment round like "ceil" (towards +∞), and below like "floor" (towards -∞). On the half-increment, values round like "floor".

"halfExpand" (default)

Ties away from 0. Values above the half-increment round like "expand" (away from zero), and below like "trunc" (towards 0). On the half-increment, values round like "expand".

"halfTrunc"

Ties toward 0. Values above the half-increment round like "expand" (away from zero), and below like "trunc" (towards 0). On the half-increment, values round like "trunc".

"halfEven"

Ties towards the nearest even integer. Values above the half-increment round like "expand" (away from zero), and below like "trunc" (towards 0). On the half-increment values round towards the nearest even digit.


These options reflect the ICU user guide, where "expand" and "trunc" map to ICU "UP" and "DOWN", respectively.
The rounding modes example below demonstrates how each mode works.

trailingZeroDisplay

The strategy for displaying trailing zeros on whole numbers. Possible values are:

"auto" (default)

Keep trailing zeros according to minimumFractionDigits and minimumSignificantDigits.

"stripIfInteger"

Remove the fraction digits if they are all zero. This is the same as "auto" if any of the fraction digits is non-zero.




SignificantDigits/FractionDigits default values
For the four options above (the FractionDigits and SignificantDigits options), we mentioned their defaults; however, these defaults are not unconditionally applied. They are only applied when the property is actually going to be used, which depends on the roundingPriority and notation settings. Specifically:

If roundingPriority is not "auto", then all four options apply.
If roundingPriority is "auto" and at least one SignificantDigits option is set, then the SignificantDigits options apply and the FractionDigits options are ignored.
If roundingPriority is "auto", and either at least one FractionDigits option is set or notation is not "compact", then the FractionDigits options apply and the SignificantDigits options are ignored.
If roundingPriority is "auto", notation is "compact", and none of the four options are set, then they are set to { minimumFractionDigits: 0, maximumFractionDigits: 0, minimumSignificantDigits: 1, maximumSignificantDigits: 2 }, regardless of the defaults mentioned above, and roundingPriority is set to "morePrecision".

Other options

notation

The formatting that should be displayed for the number. Possible values are:

"standard" (default)

Plain number formatting.

"scientific"

Return the order-of-magnitude for formatted number.

"engineering"

Return the exponent of ten when divisible by three.

"compact"

String representing exponent; defaults to using the "short" form.



compactDisplay

Only used when notation is "compact". Possible values are "short" and "long"; the default is "short".

useGrouping

Whether to use grouping separators, such as thousands separators or thousand/lakh/crore separators.

"always"

Display grouping separators even if the locale prefers otherwise.

"auto"

Display grouping separators based on the locale preference, which may also be dependent on the currency.

"min2"

Display grouping separators when there are at least 2 digits in a group.

true

Same as "always".

false

Display no grouping separators.


The default is "min2" if notation is "compact", and "auto" otherwise. The string values "true" and "false" are accepted, but are always converted to the default value.

signDisplay

When to display the sign for the number. Possible values are:

"auto" (default)

Sign display for negative numbers only, including negative zero.

"always"

Always display sign.

"exceptZero"

Sign display for positive and negative numbers, but not zero.

"negative"

Sign display for negative numbers only, excluding negative zero.

"never"

Never display sign.



Return valueA new Intl.NumberFormat object.

Note:
The text below describes behavior that is marked by the specification as "optional". It may not work in all environments. Check the browser compatibility table.

Normally, Intl.NumberFormat() can be called with or without new, and a new Intl.NumberFormat instance is returned in both cases. However, if the this value is an object that is instanceof Intl.NumberFormat (doesn't necessarily mean it's created via new Intl.NumberFormat; just that it has Intl.NumberFormat.prototype in its prototype chain), then the value of this is returned instead, with the newly created Intl.NumberFormat object hidden in a [Symbol(IntlLegacyConstructedSymbol)] property (a unique symbol that's reused between instances).
jsconst formatter = Intl.NumberFormat.call(
  { __proto__: Intl.NumberFormat.prototype },
  "en-US",
  { notation: "scientific" },
);
console.log(Object.getOwnPropertyDescriptors(formatter));
// {
//   [Symbol(IntlLegacyConstructedSymbol)]: {
//     value: NumberFormat [Intl.NumberFormat] {},
//     writable: false,
//     enumerable: false,
//     configurable: false
//   }
// }

Note that there's only one actual Intl.NumberFormat instance here: the one hidden in [Symbol(IntlLegacyConstructedSymbol)]. Calling the format() and resolvedOptions() methods on formatter would correctly use the options stored in that instance, but calling all other methods (e.g., formatRange()) would fail with "TypeError: formatRange method called on incompatible Object", because those methods don't consult the hidden instance's options.
This behavior, called ChainNumberFormat, does not happen when Intl.NumberFormat() is called without new but with this set to anything else that's not an instanceof Intl.NumberFormat. If you call it directly as Intl.NumberFormat(), the this value is Intl, and a new Intl.NumberFormat instance is created normally.Exceptions
RangeError

Thrown in one of the following cases:

A property that takes enumerated values (such as style, units, currency, and so on) is set to an invalid value.
Both maximumFractionDigits and minimumFractionDigits are set, and they are set to different values.
Note that depending on various formatting options, these properties can have default values.
It is therefore possible to get this error even if you only set one of the properties.


TypeError

Thrown if the options.style property is set to "unit" or "currency", and no value has been set for the corresponding property options.unit or options.currency.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst amount = 3500;

console.log(new Intl.NumberFormat().format(amount));
// '3,500' if in US English locale
Decimal and percent formattingjsconst amount = 3500;

new Intl.NumberFormat("en-US", {
  style: "decimal",
}).format(amount); // '3,500'
new Intl.NumberFormat("en-US", {
  style: "percent",
}).format(amount); // '350,000%'
Unit formattingIf the style is 'unit', a unit property must be provided.
Optionally, unitDisplay controls the unit formatting.
jsconst amount = 3500;

new Intl.NumberFormat("en-US", {
  style: "unit",
  unit: "liter",
}).format(amount); // '3,500 L'

new Intl.NumberFormat("en-US", {
  style: "unit",
  unit: "liter",
  unitDisplay: "long",
}).format(amount); // '3,500 liters'
Currency formattingIf the style is 'currency', a currency property
must be provided. Optionally, currencyDisplay and
currencySign control the unit formatting.
jsconst amount = -3500;
new Intl.NumberFormat("en-US", {
  style: "currency",
  currency: "USD",
}).format(amount); // '-$3,500.00'

new Intl.NumberFormat("bn", {
  style: "currency",
  currency: "USD",
  currencyDisplay: "name",
}).format(amount); // '-3,500.00 US dollars'

new Intl.NumberFormat("bn", {
  style: "currency",
  currency: "USD",
  currencySign: "accounting",
}).format(amount); // '($3,500.00)'
Scientific, engineering or compact notationsScientific and compact notation are represented by the notation option and can be formatted like this:
jsnew Intl.NumberFormat("en-US", {
  notation: "scientific",
}).format(987654321);
// 9.877E8

new Intl.NumberFormat("pt-PT", {
  notation: "scientific",
}).format(987654321);
// 9,877E8

new Intl.NumberFormat("en-GB", {
  notation: "engineering",
}).format(987654321);
// 987.654E6

new Intl.NumberFormat("de", {
  notation: "engineering",
}).format(987654321);
// 987,654E6

new Intl.NumberFormat("zh-CN", {
  notation: "compact",
}).format(987654321);
// 9.9亿

new Intl.NumberFormat("fr", {
  notation: "compact",
  compactDisplay: "long",
}).format(987654321);
// 988 millions

new Intl.NumberFormat("en-GB", {
  notation: "compact",
  compactDisplay: "short",
}).format(987654321);
// 988M
Displaying signsDisplay a sign for positive and negative numbers, but not zero:
jsnew Intl.NumberFormat("en-US", {
  style: "percent",
  signDisplay: "exceptZero",
}).format(0.55);
// '+55%'

Note that when the currency sign is "accounting", parentheses might be used instead of a minus sign:
jsnew Intl.NumberFormat("bn", {
  style: "currency",
  currency: "USD",
  currencySign: "accounting",
  signDisplay: "always",
}).format(-3500);
// '($3,500.00)'
FractionDigits, SignificantDigits and IntegerDigitsYou can specify the minimum or maximum number of fractional, integer or significant digits to display when formatting a number.

Note:
If both significant and fractional digit limits are specified, then the actual formatting depends on the roundingPriority.

Using FractionDigits and IntegerDigits
The integer and fraction digit properties indicate the number of digits to display before and after the decimal point, respectively.
If the value to display has fewer integer digits than specified, it will be left-padded with zeros to the expected number.
If it has fewer fractional digits, it will be right-padded with zeros.
Both cases are shown below:
js// Formatting adds zeros to display minimum integers and fractions
console.log(
  new Intl.NumberFormat("en", {
    minimumIntegerDigits: 3,
    minimumFractionDigits: 4,
  }).format(4.33),
);
// "004.3300"

If a value has more fractional digits than the specified maximum number, it will be rounded.
The way that it is rounded depends on the roundingMode property (more details are provided in the rounding modes section).
Below the value is rounded from five fractional digits (4.33145) to two (4.33):
js// Display value shortened to maximum number of digits
console.log(
  new Intl.NumberFormat("en", {
    maximumFractionDigits: 2,
  }).format(4.33145),
);
// "4.33"

The minimum fractional digits have no effect if the value already has more than 2 fractional digits:
js// Minimum fractions have no effect if value is higher precision.
console.log(
  new Intl.NumberFormat("en", {
    minimumFractionDigits: 2,
  }).format(4.33145),
);
// "4.331"


Warning:
Watch out for default values as they may affect formatting even if not specified in your code.
The default maximum digit value is 3 for plain values, 2 for currency, and may have different values for other predefined types.

The formatted value above is rounded to 3 digits, even though we didn't specify the maximum digits!
This is because a default value of maximumFractionDigits is set when we specify minimumFractionDigits, and visa versa. The default values of maximumFractionDigits and minimumFractionDigits are 3 and 0, respectively.
You can use resolvedOptions() to inspect the formatter.
jsconsole.log(
  new Intl.NumberFormat("en", {
    maximumFractionDigits: 2,
  }).resolvedOptions(),
);
// {
//   …
//   minimumIntegerDigits: 1,
//   minimumFractionDigits: 0,
//   maximumFractionDigits: 2,
//   …
// }

console.log(
  new Intl.NumberFormat("en", {
    minimumFractionDigits: 2,
  }).resolvedOptions(),
);
// {
//   …
//   minimumIntegerDigits: 1,
//   minimumFractionDigits: 2,
//   maximumFractionDigits: 3,
//   …
// }

Using SignificantDigits
The number of significant digits is the total number of digits including both integer and fractional parts.
The maximumSignificantDigits is used to indicate the total number of digits from the original value to display.
The examples below show how this works.
Note in particular the last case: only the first digit is retained and the others are discarded/set to zero.
js// Display 5 significant digits
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 5,
  }).format(54.33145),
);
// "54.331"

// Max 2 significant digits
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(54.33145),
);
// "54"

// Max 1 significant digits
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 1,
  }).format(54.33145),
);
// "50"

The minimumSignificantDigits ensures that at least the specified number of digits are displayed, adding zeros to the end of the value if needed.
js// Minimum 10 significant digits
console.log(
  new Intl.NumberFormat("en", {
    minimumSignificantDigits: 10,
  }).format(54.33145),
);
// "54.33145000"


Warning:
Watch out for default values as they may affect formatting.
If only one SignificantDigits property is used, then its counterpart will automatically be applied with the default value.
The default maximum and minimum significant digit values are 21 and 1, respectively.

Specifying significant and fractional digits at the same time
The fraction digits (minimumFractionDigits/maximumFractionDigits) and significant digits (minimumSignificantDigits/maximumSignificantDigits) are both ways of controlling how many fractional and leading digits should be formatted.
If both are used at the same time, it is possible for them to conflict.
These conflicts are resolved using the roundingPriority property.
By default, this has a value of "auto", which means that if either minimumSignificantDigits or maximumSignificantDigits is specified, the fractional and integer digit properties will be ignored.
For example, the code below formats the value of 4.33145 with maximumFractionDigits: 3, and then maximumSignificantDigits: 2, and then both.
The value with both is the one set with maximumSignificantDigits.
jsconsole.log(
  new Intl.NumberFormat("en", {
    maximumFractionDigits: 3,
  }).format(4.33145),
);
// "4.331"
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(4.33145),
);
// "4.3"
console.log(
  new Intl.NumberFormat("en", {
    maximumFractionDigits: 3,
    maximumSignificantDigits: 2,
  }).format(4.33145),
);
// "4.3"

Using resolvedOptions() to inspect the formatter, we can see that the returned object does not include maximumFractionDigits when maximumSignificantDigits or minimumSignificantDigits are specified.
jsconsole.log(
  new Intl.NumberFormat("en", {
    maximumFractionDigits: 3,
    maximumSignificantDigits: 2,
  }).resolvedOptions(),
);
// {
//   …
//   minimumIntegerDigits: 1,
//   minimumSignificantDigits: 1,
//   maximumSignificantDigits: 2,
//   …
// }
console.log(
  new Intl.NumberFormat("en", {
    maximumFractionDigits: 3,
    minimumSignificantDigits: 2,
  }).resolvedOptions(),
);
// {
//   …
//   minimumIntegerDigits: 1,
//   minimumSignificantDigits: 2,
//   maximumSignificantDigits: 21,
//   …
// }

In addition to "auto", you can resolve conflicts by specifying roundingPriority as "morePrecision" or "lessPrecision".
The formatter calculates the precision using the values of maximumSignificantDigits and maximumFractionDigits.
The code below shows the format being selected for the three different rounding priorities:
jsconst maxFracNF = new Intl.NumberFormat("en", {
  maximumFractionDigits: 3,
});
console.log(`maximumFractionDigits:3 - ${maxFracNF.format(1.23456)}`);
// "maximumFractionDigits:2 - 1.235"

const maxSigNS = new Intl.NumberFormat("en", {
  maximumSignificantDigits: 3,
});
console.log(`maximumSignificantDigits:3 - ${maxSigNS.format(1.23456)}`);
// "maximumSignificantDigits:3 - 1.23"

const bothAuto = new Intl.NumberFormat("en", {
  maximumSignificantDigits: 3,
  maximumFractionDigits: 3,
});
console.log(`auto - ${bothAuto.format(1.23456)}`);
// "auto - 1.23"

const bothLess = new Intl.NumberFormat("en", {
  roundingPriority: "lessPrecision",
  maximumSignificantDigits: 3,
  maximumFractionDigits: 3,
});
console.log(`lessPrecision - ${bothLess.format(1.23456)}`);
// "lessPrecision - 1.23"

const bothMore = new Intl.NumberFormat("en", {
  roundingPriority: "morePrecision",
  maximumSignificantDigits: 3,
  maximumFractionDigits: 3,
});
console.log(`morePrecision - ${bothMore.format(1.23456)}`);
// "morePrecision - 1.235"

Note that the algorithm can behave in an unintuitive way if a minimum value is specified without a maximum value.
The example below formats the value 1 specifying minimumFractionDigits: 2 (formatting to 1.00) and minimumSignificantDigits: 2 (formatting to 1.0).
Since 1.00 has more digits than 1.0, this should be the result when prioritizing morePrecision, but in fact the opposite is true:
jsconst bothLess = new Intl.NumberFormat("en", {
  roundingPriority: "lessPrecision",
  minimumFractionDigits: 2,
  minimumSignificantDigits: 2,
});
console.log(`lessPrecision - ${bothLess.format(1)}`);
// "lessPrecision - 1.00"

const bothMore = new Intl.NumberFormat("en", {
  roundingPriority: "morePrecision",
  minimumFractionDigits: 2,
  minimumSignificantDigits: 2,
});
console.log(`morePrecision - ${bothMore.format(1)}`);
// "morePrecision - 1.0"

The reason for this is that only the "maximum precision" values are used for the calculation, and the default value of maximumSignificantDigits is much higher than maximumFractionDigits.

Note:
The working group have proposed a modification of the algorithm where the formatter should evaluate the result of using the specified fractional and significant digits independently (taking account of both minimum and maximum values).
It will then select the option that displays more fractional digits if morePrecision is set, and fewer if lessPrecision is set.
This will result in more intuitive behavior for this case.
Rounding modesIf a value has more fractional digits than allowed by the constructor options, the formatted value will be rounded to the specified number of fractional digits.
The way in which the value is rounded depends on the roundingMode property.
Number formatters use halfExpand rounding by default, which rounds values "away from zero" at the half-increment (in other words, the magnitude of the value is rounded up).
For a positive number, if the fractional digits to be removed are closer to the next increment (or on the half way point) then the remaining fractional digits will be rounded up, otherwise they are rounded down.
This is shown below: 2.23 rounded to two significant digits is truncated to 2.2 because 2.23 is less than the half increment 2.25, while values of 2.25 and greater are rounded up to 2.3:
js// Value below half-increment: round down.
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(2.23),
);
// "2.2"

// Value on or above half-increment: round up.
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(2.25),
);
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(2.28),
);
// "2.3"
// "2.3"

A negative number on or below the half-increment point is also rounded away from zero (becomes more negative):
js// Value below half-increment: round down.
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(-2.23),
);
// "-2.2"

// Value on or above half-increment: round up.
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(-2.25),
);
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(-2.28),
);
// "-2.3"
// "-2.3"

The table below show the effect of different rounding modes for positive and negative values that are on and around the half-increment.



rounding mode
2.23
2.25
2.28
-2.23
-2.25
-2.28




ceil
2.3
2.3
2.3
-2.2
-2.2
-2.2


floor
2.2
2.2
2.2
-2.3
-2.3
-2.3


expand
2.3
2.3
2.3
-2.3
-2.3
-2.3


trunc
2.2
2.2
2.2
-2.2
-2.2
-2.2


halfCeil
2.2
2.3
2.3
-2.2
-2.2
-2.3


halfFloor
2.2
2.2
2.3
-2.2
-2.3
-2.3


halfExpand
2.2
2.3
2.3
-2.2
-2.3
-2.3


halfTrunc
2.2
2.2
2.3
-2.2
-2.2
-2.3


halfEven
2.2
2.2
2.3
-2.2
-2.2
-2.3



When using halfEven, its behavior also depends on the parity (odd or even) of the last digit of the rounded number. For example, the behavior of halfEven in the table above is the same as halfTrunc, because the magnitudes of all numbers are between a smaller "even" number (2.2) and a larger "odd" number (2.3). If the numbers are between ±2.3 and ±2.4, halfEven will behave like halfExpand instead. This behavior avoids consistently under- or over-estimating half-increments in a large data sample.Using roundingIncrementSometimes we want to round the remaining fractional digits to some other increment than the next integer.
For example, currencies for which the smallest coin is 5 cents might want to round the value to increments of 5, reflecting amounts that can actually be paid in cash.
This kind of rounding can be achieved with the roundingIncrement property.
For example, if maximumFractionDigits is 2 and roundingIncrement is 5, then the number is rounded to the nearest 0.05:
jsconst nf = new Intl.NumberFormat("en-US", {
  style: "currency",
  currency: "USD",
  maximumFractionDigits: 2,
  roundingIncrement: 5,
});

console.log(nf.format(11.29)); // "$11.30"
console.log(nf.format(11.25)); // "$11.25"
console.log(nf.format(11.22)); // "$11.20"

This particular pattern is referred to as "nickel rounding", where nickel is the colloquial name for a USA 5 cent coin.
To round to the nearest 10 cents ("dime rounding"), you could change roundingIncrement to 10.
jsconst nf = new Intl.NumberFormat("en-US", {
  style: "currency",
  currency: "USD",
  maximumFractionDigits: 2,
  roundingIncrement: 10,
});

console.log(nf.format(11.29)); // "$11.30"
console.log(nf.format(11.25)); // "$11.30"
console.log(nf.format(11.22)); // "$11.20"

You can also use roundingMode to change the rounding algorithm.
The example below shows how halfCeil rounding can be used to round the value "less positive" below the half-rounding increment and "more positive" if above or on the half-increment.
The incremented digit is "0.05" so the half-increment is at .025 (below, this is shown at 11.225).
jsconst nf = new Intl.NumberFormat("en-US", {
  style: "currency",
  currency: "USD",
  maximumFractionDigits: 2,
  roundingIncrement: 5,
  roundingMode: "halfCeil",
});

console.log(nf.format(11.21)); // "$11.20"
console.log(nf.format(11.22)); // "$11.20"
console.log(nf.format(11.224)); // "$11.20"
console.log(nf.format(11.225)); // "$11.25"
console.log(nf.format(11.23)); // "$11.25"

If you need to change the number of digits, remember that minimumFractionDigits and maximumFractionDigits must both be set to the same value, or a RangeError is thrown.
roundingIncrement cannot be mixed with significant-digits rounding or any setting of roundingPriority other than auto.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # sec-intl-numberformat-constructorBrowser compatibilitySee also
Intl.NumberFormat
Intl.supportedValuesOf()
Intl
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 4, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIntl.NumberFormat.supportedLocalesOf()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat.supportedLocalesOf() static method returns an array containing those of the provided locales that are supported in number formatting without having to fall back to the runtime's default locale.Try it
const locales1 = ["ban", "id-u-co-pinyin", "de-ID"];
const options1 = { localeMatcher: "lookup" };

console.log(Intl.NumberFormat.supportedLocalesOf(locales1, options1));
// Expected output: Array ["id-u-co-pinyin", "de-ID"]
// (Note: the exact output may be browser-dependent)
SyntaxjsIntl.NumberFormat.supportedLocalesOf(locales)
Intl.NumberFormat.supportedLocalesOf(locales, options)
Parameters
locales

A string with a BCP 47 language tag, or an array of such strings. For the general form and interpretation of the locales argument, see the parameter description on the Intl main page.

options Optional

An object that may have the following property:

localeMatcher

The locale matching algorithm to use. Possible values are "lookup" and "best fit"; the default is "best fit". For information about this option, see the Intl page.



Return valueAn array of strings representing a subset of the given locale tags that are supported in number formatting without having to fall back to the runtime's default locale.ExamplesUsing supportedLocalesOf()Assuming a runtime that supports Indonesian and German but not Balinese in number formatting, supportedLocalesOf returns the Indonesian and German language tags unchanged, even though pinyin collation is neither relevant to number formatting nor used with Indonesian, and a specialized German for Indonesia is unlikely to be supported. Note the specification of the "lookup" algorithm here — a "best fit" matcher might decide that Indonesian is an adequate match for Balinese since most Balinese speakers also understand Indonesian, and therefore return the Balinese language tag as well.
jsconst locales = ["ban", "id-u-co-pinyin", "de-ID"];
const options = { localeMatcher: "lookup" };
console.log(Intl.NumberFormat.supportedLocalesOf(locales, options));
// ["id-u-co-pinyin", "de-ID"]
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # sec-intl.numberformat.supportedlocalesofBrowser compatibilitySee also
Intl.NumberFormat\n\nIntl.NumberFormat.supportedLocalesOf()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat.supportedLocalesOf() static method returns an array containing those of the provided locales that are supported in number formatting without having to fall back to the runtime's default locale.Try it
const locales1 = ["ban", "id-u-co-pinyin", "de-ID"];
const options1 = { localeMatcher: "lookup" };

console.log(Intl.NumberFormat.supportedLocalesOf(locales1, options1));
// Expected output: Array ["id-u-co-pinyin", "de-ID"]
// (Note: the exact output may be browser-dependent)
SyntaxjsIntl.NumberFormat.supportedLocalesOf(locales)
Intl.NumberFormat.supportedLocalesOf(locales, options)
Parameters
locales

A string with a BCP 47 language tag, or an array of such strings. For the general form and interpretation of the locales argument, see the parameter description on the Intl main page.

options Optional

An object that may have the following property:

localeMatcher

The locale matching algorithm to use. Possible values are "lookup" and "best fit"; the default is "best fit". For information about this option, see the Intl page.



Return valueAn array of strings representing a subset of the given locale tags that are supported in number formatting without having to fall back to the runtime's default locale.ExamplesUsing supportedLocalesOf()Assuming a runtime that supports Indonesian and German but not Balinese in number formatting, supportedLocalesOf returns the Indonesian and German language tags unchanged, even though pinyin collation is neither relevant to number formatting nor used with Indonesian, and a specialized German for Indonesia is unlikely to be supported. Note the specification of the "lookup" algorithm here — a "best fit" matcher might decide that Indonesian is an adequate match for Balinese since most Balinese speakers also understand Indonesian, and therefore return the Balinese language tag as well.
jsconst locales = ["ban", "id-u-co-pinyin", "de-ID"];
const options = { localeMatcher: "lookup" };
console.log(Intl.NumberFormat.supportedLocalesOf(locales, options));
// ["id-u-co-pinyin", "de-ID"]
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # sec-intl.numberformat.supportedlocalesofBrowser compatibilitySee also
Intl.NumberFormat
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIntl.NumberFormat.supportedLocalesOf()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat.supportedLocalesOf() static method returns an array containing those of the provided locales that are supported in number formatting without having to fall back to the runtime's default locale.Try it
const locales1 = ["ban", "id-u-co-pinyin", "de-ID"];
const options1 = { localeMatcher: "lookup" };

console.log(Intl.NumberFormat.supportedLocalesOf(locales1, options1));
// Expected output: Array ["id-u-co-pinyin", "de-ID"]
// (Note: the exact output may be browser-dependent)
SyntaxjsIntl.NumberFormat.supportedLocalesOf(locales)
Intl.NumberFormat.supportedLocalesOf(locales, options)
Parameters
locales

A string with a BCP 47 language tag, or an array of such strings. For the general form and interpretation of the locales argument, see the parameter description on the Intl main page.

options Optional

An object that may have the following property:

localeMatcher

The locale matching algorithm to use. Possible values are "lookup" and "best fit"; the default is "best fit". For information about this option, see the Intl page.



Return valueAn array of strings representing a subset of the given locale tags that are supported in number formatting without having to fall back to the runtime's default locale.ExamplesUsing supportedLocalesOf()Assuming a runtime that supports Indonesian and German but not Balinese in number formatting, supportedLocalesOf returns the Indonesian and German language tags unchanged, even though pinyin collation is neither relevant to number formatting nor used with Indonesian, and a specialized German for Indonesia is unlikely to be supported. Note the specification of the "lookup" algorithm here — a "best fit" matcher might decide that Indonesian is an adequate match for Balinese since most Balinese speakers also understand Indonesian, and therefore return the Balinese language tag as well.
jsconst locales = ["ban", "id-u-co-pinyin", "de-ID"];
const options = { localeMatcher: "lookup" };
console.log(Intl.NumberFormat.supportedLocalesOf(locales, options));
// ["id-u-co-pinyin", "de-ID"]
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # sec-intl.numberformat.supportedlocalesofBrowser compatibilitySee also
Intl.NumberFormat
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIntl.NumberFormat.prototype.format()Baseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe format() method of Intl.NumberFormat instances formats a number according to the locale and formatting options of this Intl.NumberFormat object.Try it
const amount = 654321.987;

const options1 = { style: "currency", currency: "RUB" };
const numberFormat1 = new Intl.NumberFormat("ru-RU", options1);

console.log(numberFormat1.format(amount));
// Expected output: "654 321,99 ₽"

const options2 = { style: "currency", currency: "USD" };
const numberFormat2 = new Intl.NumberFormat("en-US", options2);

console.log(numberFormat2.format(amount));
// Expected output: "$654,321.99"
Syntaxjsformat(number)
Parameters
number

A Number, BigInt, or string, to format. Strings are parsed in the same way as in number conversion, except that format() will use the exact value that the string represents, avoiding loss of precision during implicitly conversion to a number.



Note:
Older versions of the specification parsed strings as a Number.
Check the compatibility table for your browser.
Return valueA string representing the given number formatted according to the locale and formatting options of this Intl.NumberFormat object.

Note:
Most of the time, the formatting returned by format() is consistent. However, the output may vary between implementations, even within the same locale — output variations are by design and allowed by the specification. It may also not be what you expect. For example, the string may use non-breaking spaces or be surrounded by bidirectional control characters. You should not compare the results of format() to hardcoded constants.
DescriptionNumber values in JavaScript suffer from loss of precision if they are too big or too small, making the text representation inaccurate.
If you are performing calculations with integers larger than Number.MAX_SAFE_INTEGER you should use a BigInt instead, which will format correctly:
jsnew Intl.NumberFormat("en-US").format(1234567891234567891); // 1,234,567,891,234,568,000
new Intl.NumberFormat("en-US").format(1234567891234567891n); // 1,234,567,891,234,567,891

You can also pass through very large strings to be formatted as an arbitrary-precision decimal string (if you're performing calculations on the data you will still need to work with BigInt):
jsnew Intl.NumberFormat("en-US").format("1234567891234567891"); // 1,234,567,891,234,567,891
ExamplesUsing formatUse the format getter function for formatting a single currency value.
The code below shows how to format the roubles currency for a Russian locale:
jsconst options = { style: "currency", currency: "RUB" };
const numberFormat = new Intl.NumberFormat("ru-RU", options);
console.log(numberFormat.format(654321.987));
// "654 321,99 ₽"
Using format with mapUse the format getter function for formatting all numbers in an array.
Note that the function is bound to the Intl.NumberFormat from which it was obtained, so it can be passed directly to Array.prototype.map.
This is considered a historical artefact, as part of a convention which is no longer followed for new features, but is preserved to maintain compatibility with existing programs.
jsconst a = [123456.789, 987654.321, 456789.123];
const numberFormat = new Intl.NumberFormat("es-ES");
const formatted = a.map((n) => numberFormat.format(n));
console.log(formatted.join("; "));
// "123.456,789; 987.654,321; 456.789,123"
Using format with a stringUsing a string we can specify numbers that are larger than Number.MAX_SAFE_INTEGER without losing precision.
jsconst numberFormat = new Intl.NumberFormat("en-US");

// Here the value is converted to a Number
console.log(numberFormat.format(987654321987654321));
// 987,654,321,987,654,300

// Here we use a string and don't lose precision
console.log(numberFormat.format("987654321987654321"));
// 987,654,321,987,654,321

We can also use the general "E" exponent syntax for decimal strings: #.#E#.
The code below creates a BigInt, coerces it to a string with the suffix E-6, and then formats it.
jsconst numberFormat = new Intl.NumberFormat("en-US");
const bigNum = 1000000000000000110000n;
console.log(numberFormat.format(bigNum));
// "1,000,000,000,000,000,110,000"

// Format as a string using the `E` syntax:
console.log(numberFormat.format(`${bigNum}E-6`));
// "1,000,000,000,000,000.11"
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # sec-intl.numberformat.prototype.formatBrowser compatibilitySee also
Intl.NumberFormat
Number.prototype.toLocaleString()\n\nIntl.NumberFormat.prototype.format()Baseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe format() method of Intl.NumberFormat instances formats a number according to the locale and formatting options of this Intl.NumberFormat object.Try it
const amount = 654321.987;

const options1 = { style: "currency", currency: "RUB" };
const numberFormat1 = new Intl.NumberFormat("ru-RU", options1);

console.log(numberFormat1.format(amount));
// Expected output: "654 321,99 ₽"

const options2 = { style: "currency", currency: "USD" };
const numberFormat2 = new Intl.NumberFormat("en-US", options2);

console.log(numberFormat2.format(amount));
// Expected output: "$654,321.99"
Syntaxjsformat(number)
Parameters
number

A Number, BigInt, or string, to format. Strings are parsed in the same way as in number conversion, except that format() will use the exact value that the string represents, avoiding loss of precision during implicitly conversion to a number.



Note:
Older versions of the specification parsed strings as a Number.
Check the compatibility table for your browser.
Return valueA string representing the given number formatted according to the locale and formatting options of this Intl.NumberFormat object.

Note:
Most of the time, the formatting returned by format() is consistent. However, the output may vary between implementations, even within the same locale — output variations are by design and allowed by the specification. It may also not be what you expect. For example, the string may use non-breaking spaces or be surrounded by bidirectional control characters. You should not compare the results of format() to hardcoded constants.
DescriptionNumber values in JavaScript suffer from loss of precision if they are too big or too small, making the text representation inaccurate.
If you are performing calculations with integers larger than Number.MAX_SAFE_INTEGER you should use a BigInt instead, which will format correctly:
jsnew Intl.NumberFormat("en-US").format(1234567891234567891); // 1,234,567,891,234,568,000
new Intl.NumberFormat("en-US").format(1234567891234567891n); // 1,234,567,891,234,567,891

You can also pass through very large strings to be formatted as an arbitrary-precision decimal string (if you're performing calculations on the data you will still need to work with BigInt):
jsnew Intl.NumberFormat("en-US").format("1234567891234567891"); // 1,234,567,891,234,567,891
ExamplesUsing formatUse the format getter function for formatting a single currency value.
The code below shows how to format the roubles currency for a Russian locale:
jsconst options = { style: "currency", currency: "RUB" };
const numberFormat = new Intl.NumberFormat("ru-RU", options);
console.log(numberFormat.format(654321.987));
// "654 321,99 ₽"
Using format with mapUse the format getter function for formatting all numbers in an array.
Note that the function is bound to the Intl.NumberFormat from which it was obtained, so it can be passed directly to Array.prototype.map.
This is considered a historical artefact, as part of a convention which is no longer followed for new features, but is preserved to maintain compatibility with existing programs.
jsconst a = [123456.789, 987654.321, 456789.123];
const numberFormat = new Intl.NumberFormat("es-ES");
const formatted = a.map((n) => numberFormat.format(n));
console.log(formatted.join("; "));
// "123.456,789; 987.654,321; 456.789,123"
Using format with a stringUsing a string we can specify numbers that are larger than Number.MAX_SAFE_INTEGER without losing precision.
jsconst numberFormat = new Intl.NumberFormat("en-US");

// Here the value is converted to a Number
console.log(numberFormat.format(987654321987654321));
// 987,654,321,987,654,300

// Here we use a string and don't lose precision
console.log(numberFormat.format("987654321987654321"));
// 987,654,321,987,654,321

We can also use the general "E" exponent syntax for decimal strings: #.#E#.
The code below creates a BigInt, coerces it to a string with the suffix E-6, and then formats it.
jsconst numberFormat = new Intl.NumberFormat("en-US");
const bigNum = 1000000000000000110000n;
console.log(numberFormat.format(bigNum));
// "1,000,000,000,000,000,110,000"

// Format as a string using the `E` syntax:
console.log(numberFormat.format(`${bigNum}E-6`));
// "1,000,000,000,000,000.11"
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # sec-intl.numberformat.prototype.formatBrowser compatibilitySee also
Intl.NumberFormat
Number.prototype.toLocaleString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIntl.NumberFormat.prototype.format()Baseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe format() method of Intl.NumberFormat instances formats a number according to the locale and formatting options of this Intl.NumberFormat object.Try it
const amount = 654321.987;

const options1 = { style: "currency", currency: "RUB" };
const numberFormat1 = new Intl.NumberFormat("ru-RU", options1);

console.log(numberFormat1.format(amount));
// Expected output: "654 321,99 ₽"

const options2 = { style: "currency", currency: "USD" };
const numberFormat2 = new Intl.NumberFormat("en-US", options2);

console.log(numberFormat2.format(amount));
// Expected output: "$654,321.99"
Syntaxjsformat(number)
Parameters
number

A Number, BigInt, or string, to format. Strings are parsed in the same way as in number conversion, except that format() will use the exact value that the string represents, avoiding loss of precision during implicitly conversion to a number.



Note:
Older versions of the specification parsed strings as a Number.
Check the compatibility table for your browser.
Return valueA string representing the given number formatted according to the locale and formatting options of this Intl.NumberFormat object.

Note:
Most of the time, the formatting returned by format() is consistent. However, the output may vary between implementations, even within the same locale — output variations are by design and allowed by the specification. It may also not be what you expect. For example, the string may use non-breaking spaces or be surrounded by bidirectional control characters. You should not compare the results of format() to hardcoded constants.
DescriptionNumber values in JavaScript suffer from loss of precision if they are too big or too small, making the text representation inaccurate.
If you are performing calculations with integers larger than Number.MAX_SAFE_INTEGER you should use a BigInt instead, which will format correctly:
jsnew Intl.NumberFormat("en-US").format(1234567891234567891); // 1,234,567,891,234,568,000
new Intl.NumberFormat("en-US").format(1234567891234567891n); // 1,234,567,891,234,567,891

You can also pass through very large strings to be formatted as an arbitrary-precision decimal string (if you're performing calculations on the data you will still need to work with BigInt):
jsnew Intl.NumberFormat("en-US").format("1234567891234567891"); // 1,234,567,891,234,567,891
ExamplesUsing formatUse the format getter function for formatting a single currency value.
The code below shows how to format the roubles currency for a Russian locale:
jsconst options = { style: "currency", currency: "RUB" };
const numberFormat = new Intl.NumberFormat("ru-RU", options);
console.log(numberFormat.format(654321.987));
// "654 321,99 ₽"
Using format with mapUse the format getter function for formatting all numbers in an array.
Note that the function is bound to the Intl.NumberFormat from which it was obtained, so it can be passed directly to Array.prototype.map.
This is considered a historical artefact, as part of a convention which is no longer followed for new features, but is preserved to maintain compatibility with existing programs.
jsconst a = [123456.789, 987654.321, 456789.123];
const numberFormat = new Intl.NumberFormat("es-ES");
const formatted = a.map((n) => numberFormat.format(n));
console.log(formatted.join("; "));
// "123.456,789; 987.654,321; 456.789,123"
Using format with a stringUsing a string we can specify numbers that are larger than Number.MAX_SAFE_INTEGER without losing precision.
jsconst numberFormat = new Intl.NumberFormat("en-US");

// Here the value is converted to a Number
console.log(numberFormat.format(987654321987654321));
// 987,654,321,987,654,300

// Here we use a string and don't lose precision
console.log(numberFormat.format("987654321987654321"));
// 987,654,321,987,654,321

We can also use the general "E" exponent syntax for decimal strings: #.#E#.
The code below creates a BigInt, coerces it to a string with the suffix E-6, and then formats it.
jsconst numberFormat = new Intl.NumberFormat("en-US");
const bigNum = 1000000000000000110000n;
console.log(numberFormat.format(bigNum));
// "1,000,000,000,000,000,110,000"

// Format as a string using the `E` syntax:
console.log(numberFormat.format(`${bigNum}E-6`));
// "1,000,000,000,000,000.11"
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # sec-intl.numberformat.prototype.formatBrowser compatibilitySee also
Intl.NumberFormat
Number.prototype.toLocaleString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIntl.NumberFormat.prototype.formatRange()The formatRange() method of Intl.NumberFormat instances formats a range of numbers according to the locale and formatting options of this Intl.NumberFormat object.SyntaxjsformatRange(startRange, endRange)
Parameters
startRange

A Number, BigInt, or string, to format. Strings are parsed in the same way as in number conversion, except that formatRange() will use the exact value that the string represents, avoiding loss of precision during implicitly conversion to a number.

endRange

A Number, BigInt, or string, to format.

Return valueA string representing the given range of numbers formatted according to the locale and formatting options of this Intl.NumberFormat object.Exceptions
RangeError

Thrown if either startRange or endRange is NaN or an inconvertible string.

TypeError

Thrown if either startRange or endRange is undefined.

DescriptionThe formatRange getter function formats a range of numbers into a string according to the locale and formatting options of this Intl.NumberFormat object from which it is called.ExamplesUsing formatRangeUse the formatRange getter function for formatting a range of currency values:
jsconst nf = new Intl.NumberFormat("en-US", {
  style: "currency",
  currency: "USD",
  maximumFractionDigits: 0,
});

console.log(nf.formatRange(3, 5)); // "$3 – $5"

// Note: the "approximately equals" symbol is added if
// startRange and endRange round to the same values.
console.log(nf.formatRange(2.9, 3.1)); // "~$3"

jsconst nf = new Intl.NumberFormat("es-ES", {
  style: "currency",
  currency: "EUR",
  maximumFractionDigits: 0,
});

console.log(nf.formatRange(3, 5)); // "3-5 €"
console.log(nf.formatRange(2.9, 3.1)); // "~3 €"
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # sec-intl.numberformat.prototype.formatrangeBrowser compatibilitySee also
Intl.NumberFormat
Number.prototype.toLocaleString()\n\nIntl.NumberFormat.prototype.formatRange()The formatRange() method of Intl.NumberFormat instances formats a range of numbers according to the locale and formatting options of this Intl.NumberFormat object.SyntaxjsformatRange(startRange, endRange)
Parameters
startRange

A Number, BigInt, or string, to format. Strings are parsed in the same way as in number conversion, except that formatRange() will use the exact value that the string represents, avoiding loss of precision during implicitly conversion to a number.

endRange

A Number, BigInt, or string, to format.

Return valueA string representing the given range of numbers formatted according to the locale and formatting options of this Intl.NumberFormat object.Exceptions
RangeError

Thrown if either startRange or endRange is NaN or an inconvertible string.

TypeError

Thrown if either startRange or endRange is undefined.

DescriptionThe formatRange getter function formats a range of numbers into a string according to the locale and formatting options of this Intl.NumberFormat object from which it is called.ExamplesUsing formatRangeUse the formatRange getter function for formatting a range of currency values:
jsconst nf = new Intl.NumberFormat("en-US", {
  style: "currency",
  currency: "USD",
  maximumFractionDigits: 0,
});

console.log(nf.formatRange(3, 5)); // "$3 – $5"

// Note: the "approximately equals" symbol is added if
// startRange and endRange round to the same values.
console.log(nf.formatRange(2.9, 3.1)); // "~$3"

jsconst nf = new Intl.NumberFormat("es-ES", {
  style: "currency",
  currency: "EUR",
  maximumFractionDigits: 0,
});

console.log(nf.formatRange(3, 5)); // "3-5 €"
console.log(nf.formatRange(2.9, 3.1)); // "~3 €"
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # sec-intl.numberformat.prototype.formatrangeBrowser compatibilitySee also
Intl.NumberFormat
Number.prototype.toLocaleString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Nov 16, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIntl.NumberFormat.prototype.formatRange()The formatRange() method of Intl.NumberFormat instances formats a range of numbers according to the locale and formatting options of this Intl.NumberFormat object.SyntaxjsformatRange(startRange, endRange)
Parameters
startRange

A Number, BigInt, or string, to format. Strings are parsed in the same way as in number conversion, except that formatRange() will use the exact value that the string represents, avoiding loss of precision during implicitly conversion to a number.

endRange

A Number, BigInt, or string, to format.

Return valueA string representing the given range of numbers formatted according to the locale and formatting options of this Intl.NumberFormat object.Exceptions
RangeError

Thrown if either startRange or endRange is NaN or an inconvertible string.

TypeError

Thrown if either startRange or endRange is undefined.

DescriptionThe formatRange getter function formats a range of numbers into a string according to the locale and formatting options of this Intl.NumberFormat object from which it is called.ExamplesUsing formatRangeUse the formatRange getter function for formatting a range of currency values:
jsconst nf = new Intl.NumberFormat("en-US", {
  style: "currency",
  currency: "USD",
  maximumFractionDigits: 0,
});

console.log(nf.formatRange(3, 5)); // "$3 – $5"

// Note: the "approximately equals" symbol is added if
// startRange and endRange round to the same values.
console.log(nf.formatRange(2.9, 3.1)); // "~$3"

jsconst nf = new Intl.NumberFormat("es-ES", {
  style: "currency",
  currency: "EUR",
  maximumFractionDigits: 0,
});

console.log(nf.formatRange(3, 5)); // "3-5 €"
console.log(nf.formatRange(2.9, 3.1)); // "~3 €"
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # sec-intl.numberformat.prototype.formatrangeBrowser compatibilitySee also
Intl.NumberFormat
Number.prototype.toLocaleString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Nov 16, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIntl.NumberFormat.prototype.formatRangeToParts()The formatRangeToParts() method of Intl.NumberFormat instances returns an Array of objects containing the locale-specific tokens from which it is possible to build custom strings while preserving the locale-specific parts. This makes it possible to provide locale-aware custom formatting ranges of number strings.SyntaxjsformatRangeToParts(startRange, endRange)
Parameters
startRange

A Number, BigInt, or string, to format. Strings are parsed in the same way as in number conversion, except that formatRangeToParts() will use the exact value that the string represents, avoiding loss of precision during implicitly conversion to a number.

endRange

A Number, BigInt, or string, to format.

Return valueAn Array of objects containing the formatted range in parts. Each object has three properties, type, value, and source, each containing a string. The string concatenation of value, in the order provided, will result in the same string as formatRange(). The type may have the same values as formatToParts(). The source can be one of the following:

startRange

The token is a part of the start number.

endRange

The token is a part of the end number.

shared

The token is shared between the start and end; for example, the currency symbol. All literals that are part of the range pattern itself, such as the "–" separator, are also marked as shared.


If the start and end numbers are equivalent, then the output has the same list of tokens as calling formatToParts() on the start number, with all tokens marked as source: "shared".Exceptions
RangeError

Thrown if either startRange or endRange is NaN or an inconvertible string.

TypeError

Thrown if either startRange or endRange is undefined.

ExamplesUsing formatRangeToParts()The formatRange() method outputs localized, opaque strings that cannot be manipulated directly:
jsconst startRange = 3500;
const endRange = 9500;

const formatter = new Intl.NumberFormat("de-DE", {
  style: "currency",
  currency: "EUR",
});

console.log(formatter.formatRange(startRange, endRange));
// "3.500,00–9.500,00 €"

However, in many user interfaces you may want to customize the formatting of this string, or interleave it with other texts. The formatRangeToParts() method produces the same information in parts:
jsconsole.log(formatter.formatRangeToParts(startRange, endRange));

// return value:
[
  { type: "integer", value: "3", source: "startRange" },
  { type: "group", value: ".", source: "startRange" },
  { type: "integer", value: "500", source: "startRange" },
  { type: "decimal", value: ",", source: "startRange" },
  { type: "fraction", value: "00", source: "startRange" },
  { type: "literal", value: "–", source: "shared" },
  { type: "integer", value: "9", source: "endRange" },
  { type: "group", value: ".", source: "endRange" },
  { type: "integer", value: "500", source: "endRange" },
  { type: "decimal", value: ",", source: "endRange" },
  { type: "fraction", value: "00", source: "endRange" },
  { type: "literal", value: " ", source: "shared" },
  { type: "currency", value: "€", source: "shared" },
];
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # sec-intl.numberformat.prototype.formatrangetopartsBrowser compatibilitySee also
Intl.NumberFormat
Intl.NumberFormat.prototype.format()\n\nIntl.NumberFormat.prototype.formatRangeToParts()The formatRangeToParts() method of Intl.NumberFormat instances returns an Array of objects containing the locale-specific tokens from which it is possible to build custom strings while preserving the locale-specific parts. This makes it possible to provide locale-aware custom formatting ranges of number strings.SyntaxjsformatRangeToParts(startRange, endRange)
Parameters
startRange

A Number, BigInt, or string, to format. Strings are parsed in the same way as in number conversion, except that formatRangeToParts() will use the exact value that the string represents, avoiding loss of precision during implicitly conversion to a number.

endRange

A Number, BigInt, or string, to format.

Return valueAn Array of objects containing the formatted range in parts. Each object has three properties, type, value, and source, each containing a string. The string concatenation of value, in the order provided, will result in the same string as formatRange(). The type may have the same values as formatToParts(). The source can be one of the following:

startRange

The token is a part of the start number.

endRange

The token is a part of the end number.

shared

The token is shared between the start and end; for example, the currency symbol. All literals that are part of the range pattern itself, such as the "–" separator, are also marked as shared.


If the start and end numbers are equivalent, then the output has the same list of tokens as calling formatToParts() on the start number, with all tokens marked as source: "shared".Exceptions
RangeError

Thrown if either startRange or endRange is NaN or an inconvertible string.

TypeError

Thrown if either startRange or endRange is undefined.

ExamplesUsing formatRangeToParts()The formatRange() method outputs localized, opaque strings that cannot be manipulated directly:
jsconst startRange = 3500;
const endRange = 9500;

const formatter = new Intl.NumberFormat("de-DE", {
  style: "currency",
  currency: "EUR",
});

console.log(formatter.formatRange(startRange, endRange));
// "3.500,00–9.500,00 €"

However, in many user interfaces you may want to customize the formatting of this string, or interleave it with other texts. The formatRangeToParts() method produces the same information in parts:
jsconsole.log(formatter.formatRangeToParts(startRange, endRange));

// return value:
[
  { type: "integer", value: "3", source: "startRange" },
  { type: "group", value: ".", source: "startRange" },
  { type: "integer", value: "500", source: "startRange" },
  { type: "decimal", value: ",", source: "startRange" },
  { type: "fraction", value: "00", source: "startRange" },
  { type: "literal", value: "–", source: "shared" },
  { type: "integer", value: "9", source: "endRange" },
  { type: "group", value: ".", source: "endRange" },
  { type: "integer", value: "500", source: "endRange" },
  { type: "decimal", value: ",", source: "endRange" },
  { type: "fraction", value: "00", source: "endRange" },
  { type: "literal", value: " ", source: "shared" },
  { type: "currency", value: "€", source: "shared" },
];
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # sec-intl.numberformat.prototype.formatrangetopartsBrowser compatibilitySee also
Intl.NumberFormat
Intl.NumberFormat.prototype.format()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jan 16, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIntl.NumberFormat.prototype.formatRangeToParts()The formatRangeToParts() method of Intl.NumberFormat instances returns an Array of objects containing the locale-specific tokens from which it is possible to build custom strings while preserving the locale-specific parts. This makes it possible to provide locale-aware custom formatting ranges of number strings.SyntaxjsformatRangeToParts(startRange, endRange)
Parameters
startRange

A Number, BigInt, or string, to format. Strings are parsed in the same way as in number conversion, except that formatRangeToParts() will use the exact value that the string represents, avoiding loss of precision during implicitly conversion to a number.

endRange

A Number, BigInt, or string, to format.

Return valueAn Array of objects containing the formatted range in parts. Each object has three properties, type, value, and source, each containing a string. The string concatenation of value, in the order provided, will result in the same string as formatRange(). The type may have the same values as formatToParts(). The source can be one of the following:

startRange

The token is a part of the start number.

endRange

The token is a part of the end number.

shared

The token is shared between the start and end; for example, the currency symbol. All literals that are part of the range pattern itself, such as the "–" separator, are also marked as shared.


If the start and end numbers are equivalent, then the output has the same list of tokens as calling formatToParts() on the start number, with all tokens marked as source: "shared".Exceptions
RangeError

Thrown if either startRange or endRange is NaN or an inconvertible string.

TypeError

Thrown if either startRange or endRange is undefined.

ExamplesUsing formatRangeToParts()The formatRange() method outputs localized, opaque strings that cannot be manipulated directly:
jsconst startRange = 3500;
const endRange = 9500;

const formatter = new Intl.NumberFormat("de-DE", {
  style: "currency",
  currency: "EUR",
});

console.log(formatter.formatRange(startRange, endRange));
// "3.500,00–9.500,00 €"

However, in many user interfaces you may want to customize the formatting of this string, or interleave it with other texts. The formatRangeToParts() method produces the same information in parts:
jsconsole.log(formatter.formatRangeToParts(startRange, endRange));

// return value:
[
  { type: "integer", value: "3", source: "startRange" },
  { type: "group", value: ".", source: "startRange" },
  { type: "integer", value: "500", source: "startRange" },
  { type: "decimal", value: ",", source: "startRange" },
  { type: "fraction", value: "00", source: "startRange" },
  { type: "literal", value: "–", source: "shared" },
  { type: "integer", value: "9", source: "endRange" },
  { type: "group", value: ".", source: "endRange" },
  { type: "integer", value: "500", source: "endRange" },
  { type: "decimal", value: ",", source: "endRange" },
  { type: "fraction", value: "00", source: "endRange" },
  { type: "literal", value: " ", source: "shared" },
  { type: "currency", value: "€", source: "shared" },
];
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # sec-intl.numberformat.prototype.formatrangetopartsBrowser compatibilitySee also
Intl.NumberFormat
Intl.NumberFormat.prototype.format()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jan 16, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIntl.NumberFormat.prototype.formatToParts()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.Learn moreSee full compatibilityReport feedbackThe formatToParts() method of Intl.NumberFormat instances returns an array of objects representing each part of the formatted string that would be returned by format(). It is useful for building custom strings from the locale-specific tokens.Try it
const amount = 654321.987;
const options = { style: "currency", currency: "USD" };
const numberFormat = new Intl.NumberFormat("en-US", options);

const parts = numberFormat.formatToParts(amount);
const partValues = parts.map((p) => p.value);

console.log(partValues);
// Expected output: "["$", "654", ",", "321", ".", "99"]"
SyntaxjsformatToParts(number)
Parameters
number

A Number, BigInt, or string, to format. Strings are parsed in the same way as in number conversion, except that formatToParts() will use the exact value that the string represents, avoiding loss of precision during implicitly conversion to a number.

Return valueAn Array of objects containing the formatted number in parts. Each object has two properties, type and value, each containing a string. The string concatenation of value, in the order provided, will result in the same string as format(). The type may be one of the following:

literal

Any string that's a part of the format pattern; for example " ". Note that common tokens like the decimal separator or the plus/minus signs have their own token types.

integer

The integral part of the number, or a segment of it if using grouping (controlled by options.useGrouping).

group

The group separator string, such as ",". Only present when using grouping (controlled by options.useGrouping).

decimal

The decimal separator string, such as ".". Only present when fraction is present.

fraction

The fractional part of the number.

compact

The compact exponent, such as "M" or "thousands". Only present when options.notation is "compact". The form ("short" or "long") can be controlled via options.compactDisplay.

exponentSeparator

The exponent separator, such as "E". Only present when options.notation is "scientific" or "engineering".

exponentMinusSign

The exponent minus sign string, such as "-". Only present when options.notation is "scientific" or "engineering" and the exponent is negative.

exponentInteger

The exponent's integer value. Only present when options.notation is "scientific" or "engineering".

nan

A string representing NaN, such as "NaN". This is the sole token representing the number itself when the number is NaN.

infinity

A string representing Infinity or -Infinity, such as "∞". This is the sole token representing the number itself when the number is Infinity or -Infinity.

plusSign

The plus sign, such as "+".

minusSign

The minus sign, such as "-".

percentSign

The percent sign, such as "%". Only present when options.style is "percent".

unit

The unit string, such as "l" or "litres". Only present when options.style is "unit". The form ("short", "narrow", or "long") can be controlled via options.unitDisplay.

currency

The currency string, such as "$", "€", "Dollar", or "Euro". Only present when options.style is "currency". The form ("code", "symbol", "narrowSymbol", or "name") can be controlled via options.currencyDisplay.

unknown

Reserved for any token that's not recognized as one of the above; should be rarely encountered.

ExamplesUsing formatToParts()The format() method outputs localized, opaque strings that cannot be manipulated directly:
jsconst number = 3500;

const formatter = new Intl.NumberFormat("de-DE", {
  style: "currency",
  currency: "EUR",
});

formatter.format(number);
// "3.500,00 €"

However, in many user interfaces you may want to customize the formatting of this string, or interleave it with other texts. The formatToParts() method produces the same information in parts:
jsformatter.formatToParts(number);

// return value:
[
  { type: "integer", value: "3" },
  { type: "group", value: "." },
  { type: "integer", value: "500" },
  { type: "decimal", value: "," },
  { type: "fraction", value: "00" },
  { type: "literal", value: " " },
  { type: "currency", value: "€" },
];

Now the information is available separately and it can be formatted and concatenated again in a customized way. For example by using Array.prototype.map(), arrow functions, a switch statement, template literals, and Array.prototype.join(), to insert additional markup for certain components.
jsconst numberString = formatter
  .formatToParts(number)
  .map(({ type, value }) => {
    switch (type) {
      case "currency":
        return `<strong>${value}</strong>`;
      default:
        return value;
    }
  })
  .join("");

console.log(numberString);
// "3.500,00 <strong>€</strong>"
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # sec-intl.numberformat.prototype.formattopartsBrowser compatibilitySee also
Intl.NumberFormat
Intl.NumberFormat.prototype.format()\n\nIntl.NumberFormat.prototype.formatToParts()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.Learn moreSee full compatibilityReport feedbackThe formatToParts() method of Intl.NumberFormat instances returns an array of objects representing each part of the formatted string that would be returned by format(). It is useful for building custom strings from the locale-specific tokens.Try it
const amount = 654321.987;
const options = { style: "currency", currency: "USD" };
const numberFormat = new Intl.NumberFormat("en-US", options);

const parts = numberFormat.formatToParts(amount);
const partValues = parts.map((p) => p.value);

console.log(partValues);
// Expected output: "["$", "654", ",", "321", ".", "99"]"
SyntaxjsformatToParts(number)
Parameters
number

A Number, BigInt, or string, to format. Strings are parsed in the same way as in number conversion, except that formatToParts() will use the exact value that the string represents, avoiding loss of precision during implicitly conversion to a number.

Return valueAn Array of objects containing the formatted number in parts. Each object has two properties, type and value, each containing a string. The string concatenation of value, in the order provided, will result in the same string as format(). The type may be one of the following:

literal

Any string that's a part of the format pattern; for example " ". Note that common tokens like the decimal separator or the plus/minus signs have their own token types.

integer

The integral part of the number, or a segment of it if using grouping (controlled by options.useGrouping).

group

The group separator string, such as ",". Only present when using grouping (controlled by options.useGrouping).

decimal

The decimal separator string, such as ".". Only present when fraction is present.

fraction

The fractional part of the number.

compact

The compact exponent, such as "M" or "thousands". Only present when options.notation is "compact". The form ("short" or "long") can be controlled via options.compactDisplay.

exponentSeparator

The exponent separator, such as "E". Only present when options.notation is "scientific" or "engineering".

exponentMinusSign

The exponent minus sign string, such as "-". Only present when options.notation is "scientific" or "engineering" and the exponent is negative.

exponentInteger

The exponent's integer value. Only present when options.notation is "scientific" or "engineering".

nan

A string representing NaN, such as "NaN". This is the sole token representing the number itself when the number is NaN.

infinity

A string representing Infinity or -Infinity, such as "∞". This is the sole token representing the number itself when the number is Infinity or -Infinity.

plusSign

The plus sign, such as "+".

minusSign

The minus sign, such as "-".

percentSign

The percent sign, such as "%". Only present when options.style is "percent".

unit

The unit string, such as "l" or "litres". Only present when options.style is "unit". The form ("short", "narrow", or "long") can be controlled via options.unitDisplay.

currency

The currency string, such as "$", "€", "Dollar", or "Euro". Only present when options.style is "currency". The form ("code", "symbol", "narrowSymbol", or "name") can be controlled via options.currencyDisplay.

unknown

Reserved for any token that's not recognized as one of the above; should be rarely encountered.

ExamplesUsing formatToParts()The format() method outputs localized, opaque strings that cannot be manipulated directly:
jsconst number = 3500;

const formatter = new Intl.NumberFormat("de-DE", {
  style: "currency",
  currency: "EUR",
});

formatter.format(number);
// "3.500,00 €"

However, in many user interfaces you may want to customize the formatting of this string, or interleave it with other texts. The formatToParts() method produces the same information in parts:
jsformatter.formatToParts(number);

// return value:
[
  { type: "integer", value: "3" },
  { type: "group", value: "." },
  { type: "integer", value: "500" },
  { type: "decimal", value: "," },
  { type: "fraction", value: "00" },
  { type: "literal", value: " " },
  { type: "currency", value: "€" },
];

Now the information is available separately and it can be formatted and concatenated again in a customized way. For example by using Array.prototype.map(), arrow functions, a switch statement, template literals, and Array.prototype.join(), to insert additional markup for certain components.
jsconst numberString = formatter
  .formatToParts(number)
  .map(({ type, value }) => {
    switch (type) {
      case "currency":
        return `<strong>${value}</strong>`;
      default:
        return value;
    }
  })
  .join("");

console.log(numberString);
// "3.500,00 <strong>€</strong>"
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # sec-intl.numberformat.prototype.formattopartsBrowser compatibilitySee also
Intl.NumberFormat
Intl.NumberFormat.prototype.format()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIntl.NumberFormat.prototype.formatToParts()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.Learn moreSee full compatibilityReport feedbackThe formatToParts() method of Intl.NumberFormat instances returns an array of objects representing each part of the formatted string that would be returned by format(). It is useful for building custom strings from the locale-specific tokens.Try it
const amount = 654321.987;
const options = { style: "currency", currency: "USD" };
const numberFormat = new Intl.NumberFormat("en-US", options);

const parts = numberFormat.formatToParts(amount);
const partValues = parts.map((p) => p.value);

console.log(partValues);
// Expected output: "["$", "654", ",", "321", ".", "99"]"
SyntaxjsformatToParts(number)
Parameters
number

A Number, BigInt, or string, to format. Strings are parsed in the same way as in number conversion, except that formatToParts() will use the exact value that the string represents, avoiding loss of precision during implicitly conversion to a number.

Return valueAn Array of objects containing the formatted number in parts. Each object has two properties, type and value, each containing a string. The string concatenation of value, in the order provided, will result in the same string as format(). The type may be one of the following:

literal

Any string that's a part of the format pattern; for example " ". Note that common tokens like the decimal separator or the plus/minus signs have their own token types.

integer

The integral part of the number, or a segment of it if using grouping (controlled by options.useGrouping).

group

The group separator string, such as ",". Only present when using grouping (controlled by options.useGrouping).

decimal

The decimal separator string, such as ".". Only present when fraction is present.

fraction

The fractional part of the number.

compact

The compact exponent, such as "M" or "thousands". Only present when options.notation is "compact". The form ("short" or "long") can be controlled via options.compactDisplay.

exponentSeparator

The exponent separator, such as "E". Only present when options.notation is "scientific" or "engineering".

exponentMinusSign

The exponent minus sign string, such as "-". Only present when options.notation is "scientific" or "engineering" and the exponent is negative.

exponentInteger

The exponent's integer value. Only present when options.notation is "scientific" or "engineering".

nan

A string representing NaN, such as "NaN". This is the sole token representing the number itself when the number is NaN.

infinity

A string representing Infinity or -Infinity, such as "∞". This is the sole token representing the number itself when the number is Infinity or -Infinity.

plusSign

The plus sign, such as "+".

minusSign

The minus sign, such as "-".

percentSign

The percent sign, such as "%". Only present when options.style is "percent".

unit

The unit string, such as "l" or "litres". Only present when options.style is "unit". The form ("short", "narrow", or "long") can be controlled via options.unitDisplay.

currency

The currency string, such as "$", "€", "Dollar", or "Euro". Only present when options.style is "currency". The form ("code", "symbol", "narrowSymbol", or "name") can be controlled via options.currencyDisplay.

unknown

Reserved for any token that's not recognized as one of the above; should be rarely encountered.

ExamplesUsing formatToParts()The format() method outputs localized, opaque strings that cannot be manipulated directly:
jsconst number = 3500;

const formatter = new Intl.NumberFormat("de-DE", {
  style: "currency",
  currency: "EUR",
});

formatter.format(number);
// "3.500,00 €"

However, in many user interfaces you may want to customize the formatting of this string, or interleave it with other texts. The formatToParts() method produces the same information in parts:
jsformatter.formatToParts(number);

// return value:
[
  { type: "integer", value: "3" },
  { type: "group", value: "." },
  { type: "integer", value: "500" },
  { type: "decimal", value: "," },
  { type: "fraction", value: "00" },
  { type: "literal", value: " " },
  { type: "currency", value: "€" },
];

Now the information is available separately and it can be formatted and concatenated again in a customized way. For example by using Array.prototype.map(), arrow functions, a switch statement, template literals, and Array.prototype.join(), to insert additional markup for certain components.
jsconst numberString = formatter
  .formatToParts(number)
  .map(({ type, value }) => {
    switch (type) {
      case "currency":
        return `<strong>${value}</strong>`;
      default:
        return value;
    }
  })
  .join("");

console.log(numberString);
// "3.500,00 <strong>€</strong>"
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # sec-intl.numberformat.prototype.formattopartsBrowser compatibilitySee also
Intl.NumberFormat
Intl.NumberFormat.prototype.format()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIntl.NumberFormat.prototype.resolvedOptions()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.Learn moreSee full compatibilityReport feedbackThe resolvedOptions() method of Intl.NumberFormat instances returns a new object with properties reflecting the options computed during initialization of this NumberFormat object.Try it
const numberFormat1 = new Intl.NumberFormat("de-DE");
const options1 = numberFormat1.resolvedOptions();

console.log(options1.locale);
// Expected output (Firefox / Safari): "de-DE"
// Expected output (Chrome): "de"

console.log(options1.numberingSystem);
// Expected output: "latn"

console.log(options1.style);
// Expected output: "decimal"
SyntaxjsresolvedOptions()
ParametersNone.Return valueA new object with properties reflecting the options computed during the initialization of this NumberFormat object. The object has the following properties, in the order they are listed:

locale

The BCP 47 language tag for the locale actually used, determined by the locale negotiation process. Only the nu Unicode extension key, if requested, may be included in the output.

numberingSystem

The value provided for this property in the options argument, or using the Unicode extension key "nu", with default filled in as needed. It is a supported numbering system for this locale. The default is locale dependent.

style

The value provided for this property in the options argument, with default filled in as needed. It is either "decimal", "percent", "currency", or "unit". The default is "decimal".

currency Optional

The value provided for this property in the options argument. It is only present if style is "currency". It is an ISO 4217 currency code; see Intl.supportedValuesOf(). It is required if style is "currency" so there is no default.

currencyDisplay Optional

The value provided for this property in the options argument, with default filled in as needed. It is only present if style is "currency". It is either "code", "symbol", "narrowSymbol", or "name". The default is "symbol".

currencySign Optional

The value provided for this property in the options argument, with default filled in as needed. It is only present if style is "currency". It is either "standard" or "accounting". The default is "standard".

unit Optional

The value provided for this property in the options argument. It is only present if style is "unit". It is a sanctioned unit identifier from the full CLDR list. It is required if style is "unit" so there is no default.

unitDisplay Optional

The value provided for this property in the options argument, with default filled in as needed. It is only present if style is "unit". It is either "short", "narrow", or "long". The default is "short".

minimumIntegerDigits

The value provided for this property in the options argument, with default filled in as needed. It is an integer between 1 and 21. The default is 1.

minimumFractionDigits, maximumFractionDigits Optional

The value provided for these properties in the options argument, with defaults filled in as needed. They are only present if necessary; see digit options. It is an integer between 0 and 100.

minimumSignificantDigits, maximumSignificantDigits Optional

The value provided for these properties in the options argument, with defaults filled in as needed. They are only present if necessary; see digit options. It is an integer between 1 and 21.

useGrouping

The value provided for this property in the options argument, with default filled in as needed, and with some values normalized. It is either "always", "auto", "min2", or the boolean false. The default is "min2" if notation is "compact", and "auto" otherwise.

notation

The value provided for this property in the options argument, with default filled in as needed. It is either "standard", "scientific", "engineering", or "compact". The default is "standard".

compactDisplay Optional

The value provided for this property in the options argument, with default filled in as needed. It is only present if notation is "compact". It is either "short" or "long". The default is "short".

signDisplay

The value provided for this property in the options argument, with default filled in as needed. It is either "auto", "always", "exceptZero", "negative", or "never". The default is "auto".

roundingIncrement

The value provided for this property in the options argument, with default filled in as needed. It is one of 1, 2, 5, 10, 20, 25, 50, 100, 200, 250, 500, 1000, 2000, 2500, and 5000. The default is 1.

roundingMode

The value provided for this property in the options argument, with default filled in as needed. It is one of "ceil", "floor", "expand", "trunc", "halfCeil", "halfFloor", "halfExpand", "halfTrunc", and "halfEven". The default is "halfExpand".

roundingPriority

The value provided for this property in the options argument, with default filled in as needed. It is either "auto", "morePrecision", or "lessPrecision". The default is "auto".

trailingZeroDisplay

The value provided for this property in the options argument, with default filled in as needed. It is either "auto" or "stripIfInteger". The default is "auto".

ExamplesUsing the resolvedOptions methodjs// Create a NumberFormat
const de = new Intl.NumberFormat("de-DE", {
  style: "currency",
  currency: "USD",
  maximumFractionDigits: 2,
  roundingIncrement: 5,
  roundingMode: "halfCeil",
});

// Resolve the options
const usedOptions = de.resolvedOptions();
console.log(usedOptions.locale); // "de-DE"
console.log(usedOptions.numberingSystem); // "latn"
console.log(usedOptions.compactDisplay); // undefined ("notation" not set to "compact")
console.log(usedOptions.currency); // "USD"
console.log(usedOptions.currencyDisplay); // "symbol"
console.log(usedOptions.currencySign); // "standard"
console.log(usedOptions.minimumIntegerDigits); // 1
console.log(usedOptions.minimumFractionDigits); // 2
console.log(usedOptions.maximumFractionDigits); // 2
console.log(usedOptions.minimumSignificantDigits); // undefined (maximumFractionDigits is set)
console.log(usedOptions.maximumSignificantDigits); // undefined (maximumFractionDigits is set)
console.log(usedOptions.notation); // "standard"
console.log(usedOptions.roundingIncrement); // 5
console.log(usedOptions.roundingMode); // halfCeil
console.log(usedOptions.roundingPriority); // auto
console.log(usedOptions.signDisplay); // "auto"
console.log(usedOptions.style); // "currency"
console.log(usedOptions.trailingZeroDisplay); // auto
console.log(usedOptions.useGrouping); // auto
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # sec-intl.numberformat.prototype.resolvedoptionsBrowser compatibilitySee also
Intl.NumberFormat\n\nIntl.NumberFormat.prototype.resolvedOptions()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.Learn moreSee full compatibilityReport feedbackThe resolvedOptions() method of Intl.NumberFormat instances returns a new object with properties reflecting the options computed during initialization of this NumberFormat object.Try it
const numberFormat1 = new Intl.NumberFormat("de-DE");
const options1 = numberFormat1.resolvedOptions();

console.log(options1.locale);
// Expected output (Firefox / Safari): "de-DE"
// Expected output (Chrome): "de"

console.log(options1.numberingSystem);
// Expected output: "latn"

console.log(options1.style);
// Expected output: "decimal"
SyntaxjsresolvedOptions()
ParametersNone.Return valueA new object with properties reflecting the options computed during the initialization of this NumberFormat object. The object has the following properties, in the order they are listed:

locale

The BCP 47 language tag for the locale actually used, determined by the locale negotiation process. Only the nu Unicode extension key, if requested, may be included in the output.

numberingSystem

The value provided for this property in the options argument, or using the Unicode extension key "nu", with default filled in as needed. It is a supported numbering system for this locale. The default is locale dependent.

style

The value provided for this property in the options argument, with default filled in as needed. It is either "decimal", "percent", "currency", or "unit". The default is "decimal".

currency Optional

The value provided for this property in the options argument. It is only present if style is "currency". It is an ISO 4217 currency code; see Intl.supportedValuesOf(). It is required if style is "currency" so there is no default.

currencyDisplay Optional

The value provided for this property in the options argument, with default filled in as needed. It is only present if style is "currency". It is either "code", "symbol", "narrowSymbol", or "name". The default is "symbol".

currencySign Optional

The value provided for this property in the options argument, with default filled in as needed. It is only present if style is "currency". It is either "standard" or "accounting". The default is "standard".

unit Optional

The value provided for this property in the options argument. It is only present if style is "unit". It is a sanctioned unit identifier from the full CLDR list. It is required if style is "unit" so there is no default.

unitDisplay Optional

The value provided for this property in the options argument, with default filled in as needed. It is only present if style is "unit". It is either "short", "narrow", or "long". The default is "short".

minimumIntegerDigits

The value provided for this property in the options argument, with default filled in as needed. It is an integer between 1 and 21. The default is 1.

minimumFractionDigits, maximumFractionDigits Optional

The value provided for these properties in the options argument, with defaults filled in as needed. They are only present if necessary; see digit options. It is an integer between 0 and 100.

minimumSignificantDigits, maximumSignificantDigits Optional

The value provided for these properties in the options argument, with defaults filled in as needed. They are only present if necessary; see digit options. It is an integer between 1 and 21.

useGrouping

The value provided for this property in the options argument, with default filled in as needed, and with some values normalized. It is either "always", "auto", "min2", or the boolean false. The default is "min2" if notation is "compact", and "auto" otherwise.

notation

The value provided for this property in the options argument, with default filled in as needed. It is either "standard", "scientific", "engineering", or "compact". The default is "standard".

compactDisplay Optional

The value provided for this property in the options argument, with default filled in as needed. It is only present if notation is "compact". It is either "short" or "long". The default is "short".

signDisplay

The value provided for this property in the options argument, with default filled in as needed. It is either "auto", "always", "exceptZero", "negative", or "never". The default is "auto".

roundingIncrement

The value provided for this property in the options argument, with default filled in as needed. It is one of 1, 2, 5, 10, 20, 25, 50, 100, 200, 250, 500, 1000, 2000, 2500, and 5000. The default is 1.

roundingMode

The value provided for this property in the options argument, with default filled in as needed. It is one of "ceil", "floor", "expand", "trunc", "halfCeil", "halfFloor", "halfExpand", "halfTrunc", and "halfEven". The default is "halfExpand".

roundingPriority

The value provided for this property in the options argument, with default filled in as needed. It is either "auto", "morePrecision", or "lessPrecision". The default is "auto".

trailingZeroDisplay

The value provided for this property in the options argument, with default filled in as needed. It is either "auto" or "stripIfInteger". The default is "auto".

ExamplesUsing the resolvedOptions methodjs// Create a NumberFormat
const de = new Intl.NumberFormat("de-DE", {
  style: "currency",
  currency: "USD",
  maximumFractionDigits: 2,
  roundingIncrement: 5,
  roundingMode: "halfCeil",
});

// Resolve the options
const usedOptions = de.resolvedOptions();
console.log(usedOptions.locale); // "de-DE"
console.log(usedOptions.numberingSystem); // "latn"
console.log(usedOptions.compactDisplay); // undefined ("notation" not set to "compact")
console.log(usedOptions.currency); // "USD"
console.log(usedOptions.currencyDisplay); // "symbol"
console.log(usedOptions.currencySign); // "standard"
console.log(usedOptions.minimumIntegerDigits); // 1
console.log(usedOptions.minimumFractionDigits); // 2
console.log(usedOptions.maximumFractionDigits); // 2
console.log(usedOptions.minimumSignificantDigits); // undefined (maximumFractionDigits is set)
console.log(usedOptions.maximumSignificantDigits); // undefined (maximumFractionDigits is set)
console.log(usedOptions.notation); // "standard"
console.log(usedOptions.roundingIncrement); // 5
console.log(usedOptions.roundingMode); // halfCeil
console.log(usedOptions.roundingPriority); // auto
console.log(usedOptions.signDisplay); // "auto"
console.log(usedOptions.style); // "currency"
console.log(usedOptions.trailingZeroDisplay); // auto
console.log(usedOptions.useGrouping); // auto
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # sec-intl.numberformat.prototype.resolvedoptionsBrowser compatibilitySee also
Intl.NumberFormat
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIntl.NumberFormat.prototype.resolvedOptions()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.Learn moreSee full compatibilityReport feedbackThe resolvedOptions() method of Intl.NumberFormat instances returns a new object with properties reflecting the options computed during initialization of this NumberFormat object.Try it
const numberFormat1 = new Intl.NumberFormat("de-DE");
const options1 = numberFormat1.resolvedOptions();

console.log(options1.locale);
// Expected output (Firefox / Safari): "de-DE"
// Expected output (Chrome): "de"

console.log(options1.numberingSystem);
// Expected output: "latn"

console.log(options1.style);
// Expected output: "decimal"
SyntaxjsresolvedOptions()
ParametersNone.Return valueA new object with properties reflecting the options computed during the initialization of this NumberFormat object. The object has the following properties, in the order they are listed:

locale

The BCP 47 language tag for the locale actually used, determined by the locale negotiation process. Only the nu Unicode extension key, if requested, may be included in the output.

numberingSystem

The value provided for this property in the options argument, or using the Unicode extension key "nu", with default filled in as needed. It is a supported numbering system for this locale. The default is locale dependent.

style

The value provided for this property in the options argument, with default filled in as needed. It is either "decimal", "percent", "currency", or "unit". The default is "decimal".

currency Optional

The value provided for this property in the options argument. It is only present if style is "currency". It is an ISO 4217 currency code; see Intl.supportedValuesOf(). It is required if style is "currency" so there is no default.

currencyDisplay Optional

The value provided for this property in the options argument, with default filled in as needed. It is only present if style is "currency". It is either "code", "symbol", "narrowSymbol", or "name". The default is "symbol".

currencySign Optional

The value provided for this property in the options argument, with default filled in as needed. It is only present if style is "currency". It is either "standard" or "accounting". The default is "standard".

unit Optional

The value provided for this property in the options argument. It is only present if style is "unit". It is a sanctioned unit identifier from the full CLDR list. It is required if style is "unit" so there is no default.

unitDisplay Optional

The value provided for this property in the options argument, with default filled in as needed. It is only present if style is "unit". It is either "short", "narrow", or "long". The default is "short".

minimumIntegerDigits

The value provided for this property in the options argument, with default filled in as needed. It is an integer between 1 and 21. The default is 1.

minimumFractionDigits, maximumFractionDigits Optional

The value provided for these properties in the options argument, with defaults filled in as needed. They are only present if necessary; see digit options. It is an integer between 0 and 100.

minimumSignificantDigits, maximumSignificantDigits Optional

The value provided for these properties in the options argument, with defaults filled in as needed. They are only present if necessary; see digit options. It is an integer between 1 and 21.

useGrouping

The value provided for this property in the options argument, with default filled in as needed, and with some values normalized. It is either "always", "auto", "min2", or the boolean false. The default is "min2" if notation is "compact", and "auto" otherwise.

notation

The value provided for this property in the options argument, with default filled in as needed. It is either "standard", "scientific", "engineering", or "compact". The default is "standard".

compactDisplay Optional

The value provided for this property in the options argument, with default filled in as needed. It is only present if notation is "compact". It is either "short" or "long". The default is "short".

signDisplay

The value provided for this property in the options argument, with default filled in as needed. It is either "auto", "always", "exceptZero", "negative", or "never". The default is "auto".

roundingIncrement

The value provided for this property in the options argument, with default filled in as needed. It is one of 1, 2, 5, 10, 20, 25, 50, 100, 200, 250, 500, 1000, 2000, 2500, and 5000. The default is 1.

roundingMode

The value provided for this property in the options argument, with default filled in as needed. It is one of "ceil", "floor", "expand", "trunc", "halfCeil", "halfFloor", "halfExpand", "halfTrunc", and "halfEven". The default is "halfExpand".

roundingPriority

The value provided for this property in the options argument, with default filled in as needed. It is either "auto", "morePrecision", or "lessPrecision". The default is "auto".

trailingZeroDisplay

The value provided for this property in the options argument, with default filled in as needed. It is either "auto" or "stripIfInteger". The default is "auto".

ExamplesUsing the resolvedOptions methodjs// Create a NumberFormat
const de = new Intl.NumberFormat("de-DE", {
  style: "currency",
  currency: "USD",
  maximumFractionDigits: 2,
  roundingIncrement: 5,
  roundingMode: "halfCeil",
});

// Resolve the options
const usedOptions = de.resolvedOptions();
console.log(usedOptions.locale); // "de-DE"
console.log(usedOptions.numberingSystem); // "latn"
console.log(usedOptions.compactDisplay); // undefined ("notation" not set to "compact")
console.log(usedOptions.currency); // "USD"
console.log(usedOptions.currencyDisplay); // "symbol"
console.log(usedOptions.currencySign); // "standard"
console.log(usedOptions.minimumIntegerDigits); // 1
console.log(usedOptions.minimumFractionDigits); // 2
console.log(usedOptions.maximumFractionDigits); // 2
console.log(usedOptions.minimumSignificantDigits); // undefined (maximumFractionDigits is set)
console.log(usedOptions.maximumSignificantDigits); // undefined (maximumFractionDigits is set)
console.log(usedOptions.notation); // "standard"
console.log(usedOptions.roundingIncrement); // 5
console.log(usedOptions.roundingMode); // halfCeil
console.log(usedOptions.roundingPriority); // auto
console.log(usedOptions.signDisplay); // "auto"
console.log(usedOptions.style); // "currency"
console.log(usedOptions.trailingZeroDisplay); // auto
console.log(usedOptions.useGrouping); // auto
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # sec-intl.numberformat.prototype.resolvedoptionsBrowser compatibilitySee also
Intl.NumberFormat
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nObjectBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Object type represents one of JavaScript's data types. It is used to store various keyed collections and more complex entities. Objects can be created using the Object() constructor or the object initializer / literal syntax.DescriptionNearly all objects in JavaScript are instances of Object; a typical object inherits properties (including methods) from Object.prototype, although these properties may be shadowed (a.k.a. overridden). The only objects that don't inherit from Object.prototype are those with null prototype, or descended from other null prototype objects.
Changes to the Object.prototype object are seen by all objects through prototype chaining, unless the properties and methods subject to those changes are overridden further along the prototype chain. This provides a very powerful although potentially dangerous mechanism to override or extend object behavior. To make it more secure, Object.prototype is the only object in the core JavaScript language that has immutable prototype — the prototype of Object.prototype is always null and not changeable.Object prototype propertiesYou should avoid calling any of the Object.prototype methods directly from the instance, especially those that are not intended to be polymorphic (i.e., only its initial behavior makes sense and no descending object could override it in a meaningful way). All objects descending from Object.prototype may define a custom own property that has the same name, but with entirely different semantics from what you expect. Furthermore, these properties are not inherited by null-prototype objects. All modern JavaScript utilities for working with objects are static. More specifically:

valueOf(), toString(), and toLocaleString() exist to be polymorphic and you should expect the object to define its own implementation with sensible behaviors, so you can call them as instance methods. However, valueOf() and toString() are usually implicitly called through type conversion and you don't need to call them yourself in your code.
__defineGetter__(), __defineSetter__(), __lookupGetter__(), and __lookupSetter__() are deprecated and should not be used. Use the static alternatives Object.defineProperty() and Object.getOwnPropertyDescriptor() instead.
The __proto__ property is deprecated and should not be used. The Object.getPrototypeOf() and Object.setPrototypeOf() alternatives are static methods.
The propertyIsEnumerable() and hasOwnProperty() methods can be replaced with the Object.getOwnPropertyDescriptor() and Object.hasOwn() static methods, respectively.
The isPrototypeOf() method can usually be replaced with instanceof, if you are checking the prototype property of a constructor.

In case where a semantically equivalent static method doesn't exist, or if you really want to use the Object.prototype method, you should directly call() the Object.prototype method on your target object instead, to prevent the object from having an overriding property that produces unexpected results.
jsconst obj = {
  foo: 1,
  // You should not define such a method on your own object,
  // but you may not be able to prevent it from happening if
  // you are receiving the object from external input
  propertyIsEnumerable() {
    return false;
  },
};

obj.propertyIsEnumerable("foo"); // false; unexpected result
Object.prototype.propertyIsEnumerable.call(obj, "foo"); // true; expected result
Deleting a property from an objectThere isn't any method in an Object itself to delete its own properties (such as Map.prototype.delete()). To do so, one must use the delete operator.null-prototype objectsAlmost all objects in JavaScript ultimately inherit from Object.prototype (see inheritance and the prototype chain). However, you may create null-prototype objects using Object.create(null) or the object initializer syntax with __proto__: null (note: the __proto__ key in object literals is different from the deprecated Object.prototype.__proto__ property). You can also change the prototype of an existing object to null by calling Object.setPrototypeOf(obj, null).
jsconst obj = Object.create(null);
const obj2 = { __proto__: null };

An object with a null prototype can behave in unexpected ways, because it doesn't inherit any object methods from Object.prototype. This is especially true when debugging, since common object-property converting/detecting utility functions may generate errors, or lose information (especially if using silent error-traps that ignore errors).
For example, the lack of Object.prototype.toString() often makes debugging intractable:
jsconst normalObj = {}; // create a normal object
const nullProtoObj = Object.create(null); // create an object with "null" prototype

console.log(`normalObj is: ${normalObj}`); // shows "normalObj is: [object Object]"
console.log(`nullProtoObj is: ${nullProtoObj}`); // throws error: Cannot convert object to primitive value

alert(normalObj); // shows [object Object]
alert(nullProtoObj); // throws error: Cannot convert object to primitive value

Other methods will fail as well.
jsnormalObj.valueOf(); // shows {}
nullProtoObj.valueOf(); // throws error: nullProtoObj.valueOf is not a function

normalObj.hasOwnProperty("p"); // shows "true"
nullProtoObj.hasOwnProperty("p"); // throws error: nullProtoObj.hasOwnProperty is not a function

normalObj.constructor; // shows "Object() { [native code] }"
nullProtoObj.constructor; // shows "undefined"

We can add the toString method back to the null-prototype object by assigning it one:
jsnullProtoObj.toString = Object.prototype.toString; // since new object lacks toString, add the original generic one back

console.log(nullProtoObj.toString()); // shows "[object Object]"
console.log(`nullProtoObj is: ${nullProtoObj}`); // shows "nullProtoObj is: [object Object]"

Unlike normal objects, in which toString() is on the object's prototype, the toString() method here is an own property of nullProtoObj. This is because nullProtoObj has no (null) prototype.
You can also revert a null-prototype object back to an ordinary object using Object.setPrototypeOf(nullProtoObj, Object.prototype).
In practice, objects with null prototype are usually used as a cheap substitute for maps. The presence of Object.prototype properties will cause some bugs:
jsconst ages = { alice: 18, bob: 27 };

function hasPerson(name) {
  return name in ages;
}

function getAge(name) {
  return ages[name];
}

hasPerson("hasOwnProperty"); // true
getAge("toString"); // [Function: toString]

Using a null-prototype object removes this hazard without introducing too much complexity to the hasPerson and getAge functions:
jsconst ages = Object.create(null, {
  alice: { value: 18, enumerable: true },
  bob: { value: 27, enumerable: true },
});

hasPerson("hasOwnProperty"); // false
getAge("toString"); // undefined

In such case, the addition of any method should be done cautiously, as they can be confused with the other key-value pairs stored as data.
Making your object not inherit from Object.prototype also prevents prototype pollution attacks. If a malicious script adds a property to Object.prototype, it will be accessible on every object in your program, except objects that have null prototype.
jsconst user = {};

// A malicious script:
Object.prototype.authenticated = true;

// Unexpectedly allowing unauthenticated user to pass through
if (user.authenticated) {
  // access confidential data
}

JavaScript also has built-in APIs that produce null-prototype objects, especially those that use objects as ad hoc key-value collections. For example:

The return value of Object.groupBy()
The groups and indices.groups properties of the result of RegExp.prototype.exec()
Array.prototype[Symbol.unscopables] (all [Symbol.unscopables] objects should have null-prototype)
import.meta
Module namespace objects, obtained through import * as ns from "module"; or import()

The term "null-prototype object" often also includes any object without Object.prototype in its prototype chain. Such objects can be created with extends null when using classes.Object coercionMany built-in operations that expect objects first coerce their arguments to objects. The operation can be summarized as follows:

Objects are returned as-is.
undefined and null throw a TypeError.
Number, String, Boolean, Symbol, BigInt primitives are wrapped into their corresponding object wrappers.

There are two ways to achieve nearly the same effect in JavaScript.

Object.prototype.valueOf(): Object.prototype.valueOf.call(x) does exactly the object coercion steps explained above to convert x.
The Object() function: Object(x) uses the same algorithm to convert x, except that undefined and null don't throw a TypeError, but return a plain object.

Places that use object coercion include:

The object parameter of for...in loops.
The this value of Array methods.
Parameters of Object methods such as Object.keys().
Auto-boxing when a property is accessed on a primitive value, since primitives do not have properties.
The this value when calling a non-strict function. Primitives are boxed while null and undefined are replaced with the global object.

Unlike conversion to primitives, the object coercion process itself is not observable in any way, since it doesn't invoke custom code like toString or valueOf methods.Constructor
Object()

Turns the input into an object.

Static methods
Object.assign()

Copies the values of all enumerable own properties from one or more source objects to a target object.

Object.create()

Creates a new object with the specified prototype object and properties.

Object.defineProperties()

Adds the named properties described by the given descriptors to an object.

Object.defineProperty()

Adds the named property described by a given descriptor to an object.

Object.entries()

Returns an array containing all of the [key, value] pairs of a given object's own enumerable string properties.

Object.freeze()

Freezes an object. Other code cannot delete or change its properties.

Object.fromEntries()

Returns a new object from an iterable of [key, value] pairs. (This is the reverse of Object.entries).

Object.getOwnPropertyDescriptor()

Returns a property descriptor for a named property on an object.

Object.getOwnPropertyDescriptors()

Returns an object containing all own property descriptors for an object.

Object.getOwnPropertyNames()

Returns an array containing the names of all of the given object's own enumerable and non-enumerable properties.

Object.getOwnPropertySymbols()

Returns an array of all symbol properties found directly upon a given object.

Object.getPrototypeOf()

Returns the prototype (internal [[Prototype]] property) of the specified object.

Object.groupBy()

Groups the elements of a given iterable according to the string values returned by a provided callback function. The returned object has separate properties for each group, containing arrays with the elements in the group.

Object.hasOwn()

Returns true if the specified object has the indicated property as its own property, or false if the property is inherited or does not exist.

Object.is()

Compares if two values are the same value. Equates all NaN values (which differs from both IsLooselyEqual used by == and IsStrictlyEqual used by ===).

Object.isExtensible()

Determines if extending of an object is allowed.

Object.isFrozen()

Determines if an object was frozen.

Object.isSealed()

Determines if an object is sealed.

Object.keys()

Returns an array containing the names of all of the given object's own enumerable string properties.

Object.preventExtensions()

Prevents any extensions of an object.

Object.seal()

Prevents other code from deleting properties of an object.

Object.setPrototypeOf()

Sets the object's prototype (its internal [[Prototype]] property).

Object.values()

Returns an array containing the values that correspond to all of a given object's own enumerable string properties.

Instance propertiesThese properties are defined on Object.prototype and shared by all Object instances.

Object.prototype.__proto__ 
Deprecated


Points to the object which was used as prototype when the object was instantiated.

Object.prototype.constructor

The constructor function that created the instance object. For plain Object instances, the initial value is the Object constructor. Instances of other constructors each inherit the constructor property from their respective Constructor.prototype object.

Instance methods
Object.prototype.__defineGetter__() 
Deprecated


Associates a function with a property that, when accessed, executes that function and returns its return value.

Object.prototype.__defineSetter__() 
Deprecated


Associates a function with a property that, when set, executes that function which modifies the property.

Object.prototype.__lookupGetter__() 
Deprecated


Returns the function bound as a getter to the specified property.

Object.prototype.__lookupSetter__() 
Deprecated


Returns the function bound as a setter to the specified property.

Object.prototype.hasOwnProperty()

Returns a boolean indicating whether an object contains the specified property as a direct property of that object and not inherited through the prototype chain.

Object.prototype.isPrototypeOf()

Returns a boolean indicating whether the object this method is called upon is in the prototype chain of the specified object.

Object.prototype.propertyIsEnumerable()

Returns a boolean indicating whether the specified property is the object's enumerable own property.

Object.prototype.toLocaleString()

Calls toString().

Object.prototype.toString()

Returns a string representation of the object.

Object.prototype.valueOf()

Returns the primitive value of the specified object.

ExamplesConstructing empty objectsThe following example creates empty objects using the new keyword with different arguments:
jsconst o1 = new Object();
const o2 = new Object(undefined);
const o3 = new Object(null);
Using Object() constructor to turn primitives into an Object of their respective typeYou can use the Object() constructor to create an object wrapper of a primitive value.
The following examples create variables o1 and o2 which are objects storing Boolean and BigInt values:
js// Equivalent to const o1 = new Boolean(true)
const o1 = new Object(true);

// No equivalent because BigInt() can't be called as a constructor,
// and calling it as a regular function won't create an object
const o2 = new Object(1n);
Object prototypesWhen altering the behavior of existing Object.prototype methods, consider injecting code by wrapping your extension before or after the existing logic. For example, this (untested) code will pre-conditionally execute custom logic before the built-in logic or someone else's extension is executed.
When modifying prototypes with hooks, pass this and the arguments (the call state) to the current behavior by calling apply() on the function. This pattern can be used for any prototype, such as Node.prototype, Function.prototype, etc.
jsconst current = Object.prototype.valueOf;

// Since my property "-prop-value" is cross-cutting and isn't always
// on the same prototype chain, I want to modify Object.prototype:
Object.prototype.valueOf = function (...args) {
  if (Object.hasOwn(this, "-prop-value")) {
    return this["-prop-value"];
  } else {
    // It doesn't look like one of my objects, so let's fall back on
    // the default behavior by reproducing the current behavior as best we can.
    // The apply behaves like "super" in some other languages.
    // Even though valueOf() doesn't take arguments, some other hook may.
    return current.apply(this, args);
  }
};


Warning:
Modifying the prototype property of any built-in constructor is considered a bad practice and risks forward compatibility.

You can read more about prototypes in Inheritance and the prototype chain.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object-objectsBrowser compatibilitySee also
Object initializer\n\nObjectBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Object type represents one of JavaScript's data types. It is used to store various keyed collections and more complex entities. Objects can be created using the Object() constructor or the object initializer / literal syntax.DescriptionNearly all objects in JavaScript are instances of Object; a typical object inherits properties (including methods) from Object.prototype, although these properties may be shadowed (a.k.a. overridden). The only objects that don't inherit from Object.prototype are those with null prototype, or descended from other null prototype objects.
Changes to the Object.prototype object are seen by all objects through prototype chaining, unless the properties and methods subject to those changes are overridden further along the prototype chain. This provides a very powerful although potentially dangerous mechanism to override or extend object behavior. To make it more secure, Object.prototype is the only object in the core JavaScript language that has immutable prototype — the prototype of Object.prototype is always null and not changeable.Object prototype propertiesYou should avoid calling any of the Object.prototype methods directly from the instance, especially those that are not intended to be polymorphic (i.e., only its initial behavior makes sense and no descending object could override it in a meaningful way). All objects descending from Object.prototype may define a custom own property that has the same name, but with entirely different semantics from what you expect. Furthermore, these properties are not inherited by null-prototype objects. All modern JavaScript utilities for working with objects are static. More specifically:

valueOf(), toString(), and toLocaleString() exist to be polymorphic and you should expect the object to define its own implementation with sensible behaviors, so you can call them as instance methods. However, valueOf() and toString() are usually implicitly called through type conversion and you don't need to call them yourself in your code.
__defineGetter__(), __defineSetter__(), __lookupGetter__(), and __lookupSetter__() are deprecated and should not be used. Use the static alternatives Object.defineProperty() and Object.getOwnPropertyDescriptor() instead.
The __proto__ property is deprecated and should not be used. The Object.getPrototypeOf() and Object.setPrototypeOf() alternatives are static methods.
The propertyIsEnumerable() and hasOwnProperty() methods can be replaced with the Object.getOwnPropertyDescriptor() and Object.hasOwn() static methods, respectively.
The isPrototypeOf() method can usually be replaced with instanceof, if you are checking the prototype property of a constructor.

In case where a semantically equivalent static method doesn't exist, or if you really want to use the Object.prototype method, you should directly call() the Object.prototype method on your target object instead, to prevent the object from having an overriding property that produces unexpected results.
jsconst obj = {
  foo: 1,
  // You should not define such a method on your own object,
  // but you may not be able to prevent it from happening if
  // you are receiving the object from external input
  propertyIsEnumerable() {
    return false;
  },
};

obj.propertyIsEnumerable("foo"); // false; unexpected result
Object.prototype.propertyIsEnumerable.call(obj, "foo"); // true; expected result
Deleting a property from an objectThere isn't any method in an Object itself to delete its own properties (such as Map.prototype.delete()). To do so, one must use the delete operator.null-prototype objectsAlmost all objects in JavaScript ultimately inherit from Object.prototype (see inheritance and the prototype chain). However, you may create null-prototype objects using Object.create(null) or the object initializer syntax with __proto__: null (note: the __proto__ key in object literals is different from the deprecated Object.prototype.__proto__ property). You can also change the prototype of an existing object to null by calling Object.setPrototypeOf(obj, null).
jsconst obj = Object.create(null);
const obj2 = { __proto__: null };

An object with a null prototype can behave in unexpected ways, because it doesn't inherit any object methods from Object.prototype. This is especially true when debugging, since common object-property converting/detecting utility functions may generate errors, or lose information (especially if using silent error-traps that ignore errors).
For example, the lack of Object.prototype.toString() often makes debugging intractable:
jsconst normalObj = {}; // create a normal object
const nullProtoObj = Object.create(null); // create an object with "null" prototype

console.log(`normalObj is: ${normalObj}`); // shows "normalObj is: [object Object]"
console.log(`nullProtoObj is: ${nullProtoObj}`); // throws error: Cannot convert object to primitive value

alert(normalObj); // shows [object Object]
alert(nullProtoObj); // throws error: Cannot convert object to primitive value

Other methods will fail as well.
jsnormalObj.valueOf(); // shows {}
nullProtoObj.valueOf(); // throws error: nullProtoObj.valueOf is not a function

normalObj.hasOwnProperty("p"); // shows "true"
nullProtoObj.hasOwnProperty("p"); // throws error: nullProtoObj.hasOwnProperty is not a function

normalObj.constructor; // shows "Object() { [native code] }"
nullProtoObj.constructor; // shows "undefined"

We can add the toString method back to the null-prototype object by assigning it one:
jsnullProtoObj.toString = Object.prototype.toString; // since new object lacks toString, add the original generic one back

console.log(nullProtoObj.toString()); // shows "[object Object]"
console.log(`nullProtoObj is: ${nullProtoObj}`); // shows "nullProtoObj is: [object Object]"

Unlike normal objects, in which toString() is on the object's prototype, the toString() method here is an own property of nullProtoObj. This is because nullProtoObj has no (null) prototype.
You can also revert a null-prototype object back to an ordinary object using Object.setPrototypeOf(nullProtoObj, Object.prototype).
In practice, objects with null prototype are usually used as a cheap substitute for maps. The presence of Object.prototype properties will cause some bugs:
jsconst ages = { alice: 18, bob: 27 };

function hasPerson(name) {
  return name in ages;
}

function getAge(name) {
  return ages[name];
}

hasPerson("hasOwnProperty"); // true
getAge("toString"); // [Function: toString]

Using a null-prototype object removes this hazard without introducing too much complexity to the hasPerson and getAge functions:
jsconst ages = Object.create(null, {
  alice: { value: 18, enumerable: true },
  bob: { value: 27, enumerable: true },
});

hasPerson("hasOwnProperty"); // false
getAge("toString"); // undefined

In such case, the addition of any method should be done cautiously, as they can be confused with the other key-value pairs stored as data.
Making your object not inherit from Object.prototype also prevents prototype pollution attacks. If a malicious script adds a property to Object.prototype, it will be accessible on every object in your program, except objects that have null prototype.
jsconst user = {};

// A malicious script:
Object.prototype.authenticated = true;

// Unexpectedly allowing unauthenticated user to pass through
if (user.authenticated) {
  // access confidential data
}

JavaScript also has built-in APIs that produce null-prototype objects, especially those that use objects as ad hoc key-value collections. For example:

The return value of Object.groupBy()
The groups and indices.groups properties of the result of RegExp.prototype.exec()
Array.prototype[Symbol.unscopables] (all [Symbol.unscopables] objects should have null-prototype)
import.meta
Module namespace objects, obtained through import * as ns from "module"; or import()

The term "null-prototype object" often also includes any object without Object.prototype in its prototype chain. Such objects can be created with extends null when using classes.Object coercionMany built-in operations that expect objects first coerce their arguments to objects. The operation can be summarized as follows:

Objects are returned as-is.
undefined and null throw a TypeError.
Number, String, Boolean, Symbol, BigInt primitives are wrapped into their corresponding object wrappers.

There are two ways to achieve nearly the same effect in JavaScript.

Object.prototype.valueOf(): Object.prototype.valueOf.call(x) does exactly the object coercion steps explained above to convert x.
The Object() function: Object(x) uses the same algorithm to convert x, except that undefined and null don't throw a TypeError, but return a plain object.

Places that use object coercion include:

The object parameter of for...in loops.
The this value of Array methods.
Parameters of Object methods such as Object.keys().
Auto-boxing when a property is accessed on a primitive value, since primitives do not have properties.
The this value when calling a non-strict function. Primitives are boxed while null and undefined are replaced with the global object.

Unlike conversion to primitives, the object coercion process itself is not observable in any way, since it doesn't invoke custom code like toString or valueOf methods.Constructor
Object()

Turns the input into an object.

Static methods
Object.assign()

Copies the values of all enumerable own properties from one or more source objects to a target object.

Object.create()

Creates a new object with the specified prototype object and properties.

Object.defineProperties()

Adds the named properties described by the given descriptors to an object.

Object.defineProperty()

Adds the named property described by a given descriptor to an object.

Object.entries()

Returns an array containing all of the [key, value] pairs of a given object's own enumerable string properties.

Object.freeze()

Freezes an object. Other code cannot delete or change its properties.

Object.fromEntries()

Returns a new object from an iterable of [key, value] pairs. (This is the reverse of Object.entries).

Object.getOwnPropertyDescriptor()

Returns a property descriptor for a named property on an object.

Object.getOwnPropertyDescriptors()

Returns an object containing all own property descriptors for an object.

Object.getOwnPropertyNames()

Returns an array containing the names of all of the given object's own enumerable and non-enumerable properties.

Object.getOwnPropertySymbols()

Returns an array of all symbol properties found directly upon a given object.

Object.getPrototypeOf()

Returns the prototype (internal [[Prototype]] property) of the specified object.

Object.groupBy()

Groups the elements of a given iterable according to the string values returned by a provided callback function. The returned object has separate properties for each group, containing arrays with the elements in the group.

Object.hasOwn()

Returns true if the specified object has the indicated property as its own property, or false if the property is inherited or does not exist.

Object.is()

Compares if two values are the same value. Equates all NaN values (which differs from both IsLooselyEqual used by == and IsStrictlyEqual used by ===).

Object.isExtensible()

Determines if extending of an object is allowed.

Object.isFrozen()

Determines if an object was frozen.

Object.isSealed()

Determines if an object is sealed.

Object.keys()

Returns an array containing the names of all of the given object's own enumerable string properties.

Object.preventExtensions()

Prevents any extensions of an object.

Object.seal()

Prevents other code from deleting properties of an object.

Object.setPrototypeOf()

Sets the object's prototype (its internal [[Prototype]] property).

Object.values()

Returns an array containing the values that correspond to all of a given object's own enumerable string properties.

Instance propertiesThese properties are defined on Object.prototype and shared by all Object instances.

Object.prototype.__proto__ 
Deprecated


Points to the object which was used as prototype when the object was instantiated.

Object.prototype.constructor

The constructor function that created the instance object. For plain Object instances, the initial value is the Object constructor. Instances of other constructors each inherit the constructor property from their respective Constructor.prototype object.

Instance methods
Object.prototype.__defineGetter__() 
Deprecated


Associates a function with a property that, when accessed, executes that function and returns its return value.

Object.prototype.__defineSetter__() 
Deprecated


Associates a function with a property that, when set, executes that function which modifies the property.

Object.prototype.__lookupGetter__() 
Deprecated


Returns the function bound as a getter to the specified property.

Object.prototype.__lookupSetter__() 
Deprecated


Returns the function bound as a setter to the specified property.

Object.prototype.hasOwnProperty()

Returns a boolean indicating whether an object contains the specified property as a direct property of that object and not inherited through the prototype chain.

Object.prototype.isPrototypeOf()

Returns a boolean indicating whether the object this method is called upon is in the prototype chain of the specified object.

Object.prototype.propertyIsEnumerable()

Returns a boolean indicating whether the specified property is the object's enumerable own property.

Object.prototype.toLocaleString()

Calls toString().

Object.prototype.toString()

Returns a string representation of the object.

Object.prototype.valueOf()

Returns the primitive value of the specified object.

ExamplesConstructing empty objectsThe following example creates empty objects using the new keyword with different arguments:
jsconst o1 = new Object();
const o2 = new Object(undefined);
const o3 = new Object(null);
Using Object() constructor to turn primitives into an Object of their respective typeYou can use the Object() constructor to create an object wrapper of a primitive value.
The following examples create variables o1 and o2 which are objects storing Boolean and BigInt values:
js// Equivalent to const o1 = new Boolean(true)
const o1 = new Object(true);

// No equivalent because BigInt() can't be called as a constructor,
// and calling it as a regular function won't create an object
const o2 = new Object(1n);
Object prototypesWhen altering the behavior of existing Object.prototype methods, consider injecting code by wrapping your extension before or after the existing logic. For example, this (untested) code will pre-conditionally execute custom logic before the built-in logic or someone else's extension is executed.
When modifying prototypes with hooks, pass this and the arguments (the call state) to the current behavior by calling apply() on the function. This pattern can be used for any prototype, such as Node.prototype, Function.prototype, etc.
jsconst current = Object.prototype.valueOf;

// Since my property "-prop-value" is cross-cutting and isn't always
// on the same prototype chain, I want to modify Object.prototype:
Object.prototype.valueOf = function (...args) {
  if (Object.hasOwn(this, "-prop-value")) {
    return this["-prop-value"];
  } else {
    // It doesn't look like one of my objects, so let's fall back on
    // the default behavior by reproducing the current behavior as best we can.
    // The apply behaves like "super" in some other languages.
    // Even though valueOf() doesn't take arguments, some other hook may.
    return current.apply(this, args);
  }
};


Warning:
Modifying the prototype property of any built-in constructor is considered a bad practice and risks forward compatibility.

You can read more about prototypes in Inheritance and the prototype chain.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object-objectsBrowser compatibilitySee also
Object initializer
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nObjectBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Object type represents one of JavaScript's data types. It is used to store various keyed collections and more complex entities. Objects can be created using the Object() constructor or the object initializer / literal syntax.DescriptionNearly all objects in JavaScript are instances of Object; a typical object inherits properties (including methods) from Object.prototype, although these properties may be shadowed (a.k.a. overridden). The only objects that don't inherit from Object.prototype are those with null prototype, or descended from other null prototype objects.
Changes to the Object.prototype object are seen by all objects through prototype chaining, unless the properties and methods subject to those changes are overridden further along the prototype chain. This provides a very powerful although potentially dangerous mechanism to override or extend object behavior. To make it more secure, Object.prototype is the only object in the core JavaScript language that has immutable prototype — the prototype of Object.prototype is always null and not changeable.Object prototype propertiesYou should avoid calling any of the Object.prototype methods directly from the instance, especially those that are not intended to be polymorphic (i.e., only its initial behavior makes sense and no descending object could override it in a meaningful way). All objects descending from Object.prototype may define a custom own property that has the same name, but with entirely different semantics from what you expect. Furthermore, these properties are not inherited by null-prototype objects. All modern JavaScript utilities for working with objects are static. More specifically:

valueOf(), toString(), and toLocaleString() exist to be polymorphic and you should expect the object to define its own implementation with sensible behaviors, so you can call them as instance methods. However, valueOf() and toString() are usually implicitly called through type conversion and you don't need to call them yourself in your code.
__defineGetter__(), __defineSetter__(), __lookupGetter__(), and __lookupSetter__() are deprecated and should not be used. Use the static alternatives Object.defineProperty() and Object.getOwnPropertyDescriptor() instead.
The __proto__ property is deprecated and should not be used. The Object.getPrototypeOf() and Object.setPrototypeOf() alternatives are static methods.
The propertyIsEnumerable() and hasOwnProperty() methods can be replaced with the Object.getOwnPropertyDescriptor() and Object.hasOwn() static methods, respectively.
The isPrototypeOf() method can usually be replaced with instanceof, if you are checking the prototype property of a constructor.

In case where a semantically equivalent static method doesn't exist, or if you really want to use the Object.prototype method, you should directly call() the Object.prototype method on your target object instead, to prevent the object from having an overriding property that produces unexpected results.
jsconst obj = {
  foo: 1,
  // You should not define such a method on your own object,
  // but you may not be able to prevent it from happening if
  // you are receiving the object from external input
  propertyIsEnumerable() {
    return false;
  },
};

obj.propertyIsEnumerable("foo"); // false; unexpected result
Object.prototype.propertyIsEnumerable.call(obj, "foo"); // true; expected result
Deleting a property from an objectThere isn't any method in an Object itself to delete its own properties (such as Map.prototype.delete()). To do so, one must use the delete operator.null-prototype objectsAlmost all objects in JavaScript ultimately inherit from Object.prototype (see inheritance and the prototype chain). However, you may create null-prototype objects using Object.create(null) or the object initializer syntax with __proto__: null (note: the __proto__ key in object literals is different from the deprecated Object.prototype.__proto__ property). You can also change the prototype of an existing object to null by calling Object.setPrototypeOf(obj, null).
jsconst obj = Object.create(null);
const obj2 = { __proto__: null };

An object with a null prototype can behave in unexpected ways, because it doesn't inherit any object methods from Object.prototype. This is especially true when debugging, since common object-property converting/detecting utility functions may generate errors, or lose information (especially if using silent error-traps that ignore errors).
For example, the lack of Object.prototype.toString() often makes debugging intractable:
jsconst normalObj = {}; // create a normal object
const nullProtoObj = Object.create(null); // create an object with "null" prototype

console.log(`normalObj is: ${normalObj}`); // shows "normalObj is: [object Object]"
console.log(`nullProtoObj is: ${nullProtoObj}`); // throws error: Cannot convert object to primitive value

alert(normalObj); // shows [object Object]
alert(nullProtoObj); // throws error: Cannot convert object to primitive value

Other methods will fail as well.
jsnormalObj.valueOf(); // shows {}
nullProtoObj.valueOf(); // throws error: nullProtoObj.valueOf is not a function

normalObj.hasOwnProperty("p"); // shows "true"
nullProtoObj.hasOwnProperty("p"); // throws error: nullProtoObj.hasOwnProperty is not a function

normalObj.constructor; // shows "Object() { [native code] }"
nullProtoObj.constructor; // shows "undefined"

We can add the toString method back to the null-prototype object by assigning it one:
jsnullProtoObj.toString = Object.prototype.toString; // since new object lacks toString, add the original generic one back

console.log(nullProtoObj.toString()); // shows "[object Object]"
console.log(`nullProtoObj is: ${nullProtoObj}`); // shows "nullProtoObj is: [object Object]"

Unlike normal objects, in which toString() is on the object's prototype, the toString() method here is an own property of nullProtoObj. This is because nullProtoObj has no (null) prototype.
You can also revert a null-prototype object back to an ordinary object using Object.setPrototypeOf(nullProtoObj, Object.prototype).
In practice, objects with null prototype are usually used as a cheap substitute for maps. The presence of Object.prototype properties will cause some bugs:
jsconst ages = { alice: 18, bob: 27 };

function hasPerson(name) {
  return name in ages;
}

function getAge(name) {
  return ages[name];
}

hasPerson("hasOwnProperty"); // true
getAge("toString"); // [Function: toString]

Using a null-prototype object removes this hazard without introducing too much complexity to the hasPerson and getAge functions:
jsconst ages = Object.create(null, {
  alice: { value: 18, enumerable: true },
  bob: { value: 27, enumerable: true },
});

hasPerson("hasOwnProperty"); // false
getAge("toString"); // undefined

In such case, the addition of any method should be done cautiously, as they can be confused with the other key-value pairs stored as data.
Making your object not inherit from Object.prototype also prevents prototype pollution attacks. If a malicious script adds a property to Object.prototype, it will be accessible on every object in your program, except objects that have null prototype.
jsconst user = {};

// A malicious script:
Object.prototype.authenticated = true;

// Unexpectedly allowing unauthenticated user to pass through
if (user.authenticated) {
  // access confidential data
}

JavaScript also has built-in APIs that produce null-prototype objects, especially those that use objects as ad hoc key-value collections. For example:

The return value of Object.groupBy()
The groups and indices.groups properties of the result of RegExp.prototype.exec()
Array.prototype[Symbol.unscopables] (all [Symbol.unscopables] objects should have null-prototype)
import.meta
Module namespace objects, obtained through import * as ns from "module"; or import()

The term "null-prototype object" often also includes any object without Object.prototype in its prototype chain. Such objects can be created with extends null when using classes.Object coercionMany built-in operations that expect objects first coerce their arguments to objects. The operation can be summarized as follows:

Objects are returned as-is.
undefined and null throw a TypeError.
Number, String, Boolean, Symbol, BigInt primitives are wrapped into their corresponding object wrappers.

There are two ways to achieve nearly the same effect in JavaScript.

Object.prototype.valueOf(): Object.prototype.valueOf.call(x) does exactly the object coercion steps explained above to convert x.
The Object() function: Object(x) uses the same algorithm to convert x, except that undefined and null don't throw a TypeError, but return a plain object.

Places that use object coercion include:

The object parameter of for...in loops.
The this value of Array methods.
Parameters of Object methods such as Object.keys().
Auto-boxing when a property is accessed on a primitive value, since primitives do not have properties.
The this value when calling a non-strict function. Primitives are boxed while null and undefined are replaced with the global object.

Unlike conversion to primitives, the object coercion process itself is not observable in any way, since it doesn't invoke custom code like toString or valueOf methods.Constructor
Object()

Turns the input into an object.

Static methods
Object.assign()

Copies the values of all enumerable own properties from one or more source objects to a target object.

Object.create()

Creates a new object with the specified prototype object and properties.

Object.defineProperties()

Adds the named properties described by the given descriptors to an object.

Object.defineProperty()

Adds the named property described by a given descriptor to an object.

Object.entries()

Returns an array containing all of the [key, value] pairs of a given object's own enumerable string properties.

Object.freeze()

Freezes an object. Other code cannot delete or change its properties.

Object.fromEntries()

Returns a new object from an iterable of [key, value] pairs. (This is the reverse of Object.entries).

Object.getOwnPropertyDescriptor()

Returns a property descriptor for a named property on an object.

Object.getOwnPropertyDescriptors()

Returns an object containing all own property descriptors for an object.

Object.getOwnPropertyNames()

Returns an array containing the names of all of the given object's own enumerable and non-enumerable properties.

Object.getOwnPropertySymbols()

Returns an array of all symbol properties found directly upon a given object.

Object.getPrototypeOf()

Returns the prototype (internal [[Prototype]] property) of the specified object.

Object.groupBy()

Groups the elements of a given iterable according to the string values returned by a provided callback function. The returned object has separate properties for each group, containing arrays with the elements in the group.

Object.hasOwn()

Returns true if the specified object has the indicated property as its own property, or false if the property is inherited or does not exist.

Object.is()

Compares if two values are the same value. Equates all NaN values (which differs from both IsLooselyEqual used by == and IsStrictlyEqual used by ===).

Object.isExtensible()

Determines if extending of an object is allowed.

Object.isFrozen()

Determines if an object was frozen.

Object.isSealed()

Determines if an object is sealed.

Object.keys()

Returns an array containing the names of all of the given object's own enumerable string properties.

Object.preventExtensions()

Prevents any extensions of an object.

Object.seal()

Prevents other code from deleting properties of an object.

Object.setPrototypeOf()

Sets the object's prototype (its internal [[Prototype]] property).

Object.values()

Returns an array containing the values that correspond to all of a given object's own enumerable string properties.

Instance propertiesThese properties are defined on Object.prototype and shared by all Object instances.

Object.prototype.__proto__ 
Deprecated


Points to the object which was used as prototype when the object was instantiated.

Object.prototype.constructor

The constructor function that created the instance object. For plain Object instances, the initial value is the Object constructor. Instances of other constructors each inherit the constructor property from their respective Constructor.prototype object.

Instance methods
Object.prototype.__defineGetter__() 
Deprecated


Associates a function with a property that, when accessed, executes that function and returns its return value.

Object.prototype.__defineSetter__() 
Deprecated


Associates a function with a property that, when set, executes that function which modifies the property.

Object.prototype.__lookupGetter__() 
Deprecated


Returns the function bound as a getter to the specified property.

Object.prototype.__lookupSetter__() 
Deprecated


Returns the function bound as a setter to the specified property.

Object.prototype.hasOwnProperty()

Returns a boolean indicating whether an object contains the specified property as a direct property of that object and not inherited through the prototype chain.

Object.prototype.isPrototypeOf()

Returns a boolean indicating whether the object this method is called upon is in the prototype chain of the specified object.

Object.prototype.propertyIsEnumerable()

Returns a boolean indicating whether the specified property is the object's enumerable own property.

Object.prototype.toLocaleString()

Calls toString().

Object.prototype.toString()

Returns a string representation of the object.

Object.prototype.valueOf()

Returns the primitive value of the specified object.

ExamplesConstructing empty objectsThe following example creates empty objects using the new keyword with different arguments:
jsconst o1 = new Object();
const o2 = new Object(undefined);
const o3 = new Object(null);
Using Object() constructor to turn primitives into an Object of their respective typeYou can use the Object() constructor to create an object wrapper of a primitive value.
The following examples create variables o1 and o2 which are objects storing Boolean and BigInt values:
js// Equivalent to const o1 = new Boolean(true)
const o1 = new Object(true);

// No equivalent because BigInt() can't be called as a constructor,
// and calling it as a regular function won't create an object
const o2 = new Object(1n);
Object prototypesWhen altering the behavior of existing Object.prototype methods, consider injecting code by wrapping your extension before or after the existing logic. For example, this (untested) code will pre-conditionally execute custom logic before the built-in logic or someone else's extension is executed.
When modifying prototypes with hooks, pass this and the arguments (the call state) to the current behavior by calling apply() on the function. This pattern can be used for any prototype, such as Node.prototype, Function.prototype, etc.
jsconst current = Object.prototype.valueOf;

// Since my property "-prop-value" is cross-cutting and isn't always
// on the same prototype chain, I want to modify Object.prototype:
Object.prototype.valueOf = function (...args) {
  if (Object.hasOwn(this, "-prop-value")) {
    return this["-prop-value"];
  } else {
    // It doesn't look like one of my objects, so let's fall back on
    // the default behavior by reproducing the current behavior as best we can.
    // The apply behaves like "super" in some other languages.
    // Even though valueOf() doesn't take arguments, some other hook may.
    return current.apply(this, args);
  }
};


Warning:
Modifying the prototype property of any built-in constructor is considered a bad practice and risks forward compatibility.

You can read more about prototypes in Inheritance and the prototype chain.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object-objectsBrowser compatibilitySee also
Object initializer
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nFunction.prototype.apply()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe apply() method of Function instances calls this function with a given this value, and arguments provided as an array (or an array-like object).Try it
const numbers = [5, 6, 2, 3, 7];

const max = Math.max.apply(null, numbers);

console.log(max);
// Expected output: 7

const min = Math.min.apply(null, numbers);

console.log(min);
// Expected output: 2
Syntaxjsapply(thisArg)
apply(thisArg, argsArray)
Parameters
thisArg

The value of this provided for the call to func. If the function is not in strict mode, null and undefined will be replaced with the global object, and primitive values will be converted to objects.

argsArray Optional

An array-like object, specifying the arguments with which func should be called, or null or undefined if no arguments should be provided to the function.

Return valueThe result of calling the function with the specified this value and arguments.Description
Note:
This function is almost identical to call(), except that the function arguments are passed to call() individually as a list, while for apply() they are combined in one object, typically an array — for example, func.call(this, "eat", "bananas") vs. func.apply(this, ["eat", "bananas"]).

Normally, when calling a function, the value of this inside the function is the object that the function was accessed on. With apply(), you can assign an arbitrary value as this when calling an existing function, without first attaching the function to the object as a property. This allows you to use methods of one object as generic utility functions.
You can also use any kind of object which is array-like as the second parameter. In practice, this means that it needs to have a length property, and integer ("index") properties in the range (0..length - 1). For example, you could use a NodeList, or a custom object like { 'length': 2, '0': 'eat', '1': 'bananas' }. You can also use arguments, for example:
jsfunction wrapper() {
  return anotherFn.apply(null, arguments);
}

With the rest parameters and parameter spread syntax, this can be rewritten as:
jsfunction wrapper(...args) {
  return anotherFn(...args);
}

In general, fn.apply(null, args) is equivalent to fn(...args) with the parameter spread syntax, except args is expected to be an array-like object in the former case with apply(), and an iterable object in the latter case with spread syntax.

Warning:
Do not use apply() to chain constructors (for example, to implement inheritance). This invokes the constructor function as a plain function, which means new.target is undefined, and classes throw an error because they can't be called without new. Use Reflect.construct() or extends instead.
ExamplesUsing apply() to append an array to anotherYou can use Array.prototype.push() to append an element to an array. Because push() accepts a variable number of arguments, you can also push multiple elements at once. But if you pass an array to push(), it will actually add that array as a single element, instead of adding the elements individually, ending up with an array inside an array. On the other hand, Array.prototype.concat() does have the desired behavior in this case, but it does not append to the existing array — it creates and returns a new array.
In this case, you can use apply to implicitly "spread" an array as a series of arguments.
jsconst array = ["a", "b"];
const elements = [0, 1, 2];
array.push.apply(array, elements);
console.info(array); // ["a", "b", 0, 1, 2]

The same effect can be achieved with the spread syntax.
jsconst array = ["a", "b"];
const elements = [0, 1, 2];
array.push(...elements);
console.info(array); // ["a", "b", 0, 1, 2]
Using apply() and built-in functionsClever usage of apply() allows you to use built-in functions for some tasks that would probably otherwise require manually looping over a collection (or using the spread syntax).
For example, we can use Math.max() and Math.min() to find out the maximum and minimum value in an array.
js// min/max number in an array
const numbers = [5, 6, 2, 3, 7];

// using Math.min/Math.max apply
let max = Math.max.apply(null, numbers);
// This about equal to Math.max(numbers[0], …)
// or Math.max(5, 6, …)

let min = Math.min.apply(null, numbers);

// vs. loop based algorithm
max = -Infinity;
min = +Infinity;

for (let i = 0; i < numbers.length; i++) {
  if (numbers[i] > max) {
    max = numbers[i];
  }
  if (numbers[i] < min) {
    min = numbers[i];
  }
}

But beware: by using apply() (or the spread syntax) with an arbitrarily long arguments list, you run the risk of exceeding the JavaScript engine's argument length limit.
The consequences of calling a function with too many arguments (that is, more than tens of thousands of arguments) is unspecified and varies across engines. (The JavaScriptCore engine has a hard-coded argument limit of 65536.) Most engines throw an exception; but there's no normative specification preventing other behaviors, such as arbitrarily limiting the number of arguments actually passed to the applied function. To illustrate this latter case: if such an engine had a limit of four arguments (actual limits are of course significantly higher), it would be as if the arguments 5, 6, 2, 3 had been passed to apply in the examples above, rather than the full array.
If your value array might grow into the tens of thousands, use a hybrid strategy: apply your function to chunks of the array at a time:
jsfunction minOfArray(arr) {
  let min = Infinity;
  const QUANTUM = 32768;

  for (let i = 0; i < arr.length; i += QUANTUM) {
    const subMin = Math.min.apply(
      null,
      arr.slice(i, Math.min(i + QUANTUM, arr.length)),
    );
    min = Math.min(subMin, min);
  }

  return min;
}

const min = minOfArray([5, 6, 2, 3, 7]);
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-function.prototype.applyBrowser compatibilitySee also
arguments
Function.prototype.bind()
Function.prototype.call()
Reflect.apply()
Functions
Spread syntax (...)\n\nFunction.prototype.apply()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe apply() method of Function instances calls this function with a given this value, and arguments provided as an array (or an array-like object).Try it
const numbers = [5, 6, 2, 3, 7];

const max = Math.max.apply(null, numbers);

console.log(max);
// Expected output: 7

const min = Math.min.apply(null, numbers);

console.log(min);
// Expected output: 2
Syntaxjsapply(thisArg)
apply(thisArg, argsArray)
Parameters
thisArg

The value of this provided for the call to func. If the function is not in strict mode, null and undefined will be replaced with the global object, and primitive values will be converted to objects.

argsArray Optional

An array-like object, specifying the arguments with which func should be called, or null or undefined if no arguments should be provided to the function.

Return valueThe result of calling the function with the specified this value and arguments.Description
Note:
This function is almost identical to call(), except that the function arguments are passed to call() individually as a list, while for apply() they are combined in one object, typically an array — for example, func.call(this, "eat", "bananas") vs. func.apply(this, ["eat", "bananas"]).

Normally, when calling a function, the value of this inside the function is the object that the function was accessed on. With apply(), you can assign an arbitrary value as this when calling an existing function, without first attaching the function to the object as a property. This allows you to use methods of one object as generic utility functions.
You can also use any kind of object which is array-like as the second parameter. In practice, this means that it needs to have a length property, and integer ("index") properties in the range (0..length - 1). For example, you could use a NodeList, or a custom object like { 'length': 2, '0': 'eat', '1': 'bananas' }. You can also use arguments, for example:
jsfunction wrapper() {
  return anotherFn.apply(null, arguments);
}

With the rest parameters and parameter spread syntax, this can be rewritten as:
jsfunction wrapper(...args) {
  return anotherFn(...args);
}

In general, fn.apply(null, args) is equivalent to fn(...args) with the parameter spread syntax, except args is expected to be an array-like object in the former case with apply(), and an iterable object in the latter case with spread syntax.

Warning:
Do not use apply() to chain constructors (for example, to implement inheritance). This invokes the constructor function as a plain function, which means new.target is undefined, and classes throw an error because they can't be called without new. Use Reflect.construct() or extends instead.
ExamplesUsing apply() to append an array to anotherYou can use Array.prototype.push() to append an element to an array. Because push() accepts a variable number of arguments, you can also push multiple elements at once. But if you pass an array to push(), it will actually add that array as a single element, instead of adding the elements individually, ending up with an array inside an array. On the other hand, Array.prototype.concat() does have the desired behavior in this case, but it does not append to the existing array — it creates and returns a new array.
In this case, you can use apply to implicitly "spread" an array as a series of arguments.
jsconst array = ["a", "b"];
const elements = [0, 1, 2];
array.push.apply(array, elements);
console.info(array); // ["a", "b", 0, 1, 2]

The same effect can be achieved with the spread syntax.
jsconst array = ["a", "b"];
const elements = [0, 1, 2];
array.push(...elements);
console.info(array); // ["a", "b", 0, 1, 2]
Using apply() and built-in functionsClever usage of apply() allows you to use built-in functions for some tasks that would probably otherwise require manually looping over a collection (or using the spread syntax).
For example, we can use Math.max() and Math.min() to find out the maximum and minimum value in an array.
js// min/max number in an array
const numbers = [5, 6, 2, 3, 7];

// using Math.min/Math.max apply
let max = Math.max.apply(null, numbers);
// This about equal to Math.max(numbers[0], …)
// or Math.max(5, 6, …)

let min = Math.min.apply(null, numbers);

// vs. loop based algorithm
max = -Infinity;
min = +Infinity;

for (let i = 0; i < numbers.length; i++) {
  if (numbers[i] > max) {
    max = numbers[i];
  }
  if (numbers[i] < min) {
    min = numbers[i];
  }
}

But beware: by using apply() (or the spread syntax) with an arbitrarily long arguments list, you run the risk of exceeding the JavaScript engine's argument length limit.
The consequences of calling a function with too many arguments (that is, more than tens of thousands of arguments) is unspecified and varies across engines. (The JavaScriptCore engine has a hard-coded argument limit of 65536.) Most engines throw an exception; but there's no normative specification preventing other behaviors, such as arbitrarily limiting the number of arguments actually passed to the applied function. To illustrate this latter case: if such an engine had a limit of four arguments (actual limits are of course significantly higher), it would be as if the arguments 5, 6, 2, 3 had been passed to apply in the examples above, rather than the full array.
If your value array might grow into the tens of thousands, use a hybrid strategy: apply your function to chunks of the array at a time:
jsfunction minOfArray(arr) {
  let min = Infinity;
  const QUANTUM = 32768;

  for (let i = 0; i < arr.length; i += QUANTUM) {
    const subMin = Math.min.apply(
      null,
      arr.slice(i, Math.min(i + QUANTUM, arr.length)),
    );
    min = Math.min(subMin, min);
  }

  return min;
}

const min = minOfArray([5, 6, 2, 3, 7]);
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-function.prototype.applyBrowser compatibilitySee also
arguments
Function.prototype.bind()
Function.prototype.call()
Reflect.apply()
Functions
Spread syntax (...)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nFunction.prototype.apply()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe apply() method of Function instances calls this function with a given this value, and arguments provided as an array (or an array-like object).Try it
const numbers = [5, 6, 2, 3, 7];

const max = Math.max.apply(null, numbers);

console.log(max);
// Expected output: 7

const min = Math.min.apply(null, numbers);

console.log(min);
// Expected output: 2
Syntaxjsapply(thisArg)
apply(thisArg, argsArray)
Parameters
thisArg

The value of this provided for the call to func. If the function is not in strict mode, null and undefined will be replaced with the global object, and primitive values will be converted to objects.

argsArray Optional

An array-like object, specifying the arguments with which func should be called, or null or undefined if no arguments should be provided to the function.

Return valueThe result of calling the function with the specified this value and arguments.Description
Note:
This function is almost identical to call(), except that the function arguments are passed to call() individually as a list, while for apply() they are combined in one object, typically an array — for example, func.call(this, "eat", "bananas") vs. func.apply(this, ["eat", "bananas"]).

Normally, when calling a function, the value of this inside the function is the object that the function was accessed on. With apply(), you can assign an arbitrary value as this when calling an existing function, without first attaching the function to the object as a property. This allows you to use methods of one object as generic utility functions.
You can also use any kind of object which is array-like as the second parameter. In practice, this means that it needs to have a length property, and integer ("index") properties in the range (0..length - 1). For example, you could use a NodeList, or a custom object like { 'length': 2, '0': 'eat', '1': 'bananas' }. You can also use arguments, for example:
jsfunction wrapper() {
  return anotherFn.apply(null, arguments);
}

With the rest parameters and parameter spread syntax, this can be rewritten as:
jsfunction wrapper(...args) {
  return anotherFn(...args);
}

In general, fn.apply(null, args) is equivalent to fn(...args) with the parameter spread syntax, except args is expected to be an array-like object in the former case with apply(), and an iterable object in the latter case with spread syntax.

Warning:
Do not use apply() to chain constructors (for example, to implement inheritance). This invokes the constructor function as a plain function, which means new.target is undefined, and classes throw an error because they can't be called without new. Use Reflect.construct() or extends instead.
ExamplesUsing apply() to append an array to anotherYou can use Array.prototype.push() to append an element to an array. Because push() accepts a variable number of arguments, you can also push multiple elements at once. But if you pass an array to push(), it will actually add that array as a single element, instead of adding the elements individually, ending up with an array inside an array. On the other hand, Array.prototype.concat() does have the desired behavior in this case, but it does not append to the existing array — it creates and returns a new array.
In this case, you can use apply to implicitly "spread" an array as a series of arguments.
jsconst array = ["a", "b"];
const elements = [0, 1, 2];
array.push.apply(array, elements);
console.info(array); // ["a", "b", 0, 1, 2]

The same effect can be achieved with the spread syntax.
jsconst array = ["a", "b"];
const elements = [0, 1, 2];
array.push(...elements);
console.info(array); // ["a", "b", 0, 1, 2]
Using apply() and built-in functionsClever usage of apply() allows you to use built-in functions for some tasks that would probably otherwise require manually looping over a collection (or using the spread syntax).
For example, we can use Math.max() and Math.min() to find out the maximum and minimum value in an array.
js// min/max number in an array
const numbers = [5, 6, 2, 3, 7];

// using Math.min/Math.max apply
let max = Math.max.apply(null, numbers);
// This about equal to Math.max(numbers[0], …)
// or Math.max(5, 6, …)

let min = Math.min.apply(null, numbers);

// vs. loop based algorithm
max = -Infinity;
min = +Infinity;

for (let i = 0; i < numbers.length; i++) {
  if (numbers[i] > max) {
    max = numbers[i];
  }
  if (numbers[i] < min) {
    min = numbers[i];
  }
}

But beware: by using apply() (or the spread syntax) with an arbitrarily long arguments list, you run the risk of exceeding the JavaScript engine's argument length limit.
The consequences of calling a function with too many arguments (that is, more than tens of thousands of arguments) is unspecified and varies across engines. (The JavaScriptCore engine has a hard-coded argument limit of 65536.) Most engines throw an exception; but there's no normative specification preventing other behaviors, such as arbitrarily limiting the number of arguments actually passed to the applied function. To illustrate this latter case: if such an engine had a limit of four arguments (actual limits are of course significantly higher), it would be as if the arguments 5, 6, 2, 3 had been passed to apply in the examples above, rather than the full array.
If your value array might grow into the tens of thousands, use a hybrid strategy: apply your function to chunks of the array at a time:
jsfunction minOfArray(arr) {
  let min = Infinity;
  const QUANTUM = 32768;

  for (let i = 0; i < arr.length; i += QUANTUM) {
    const subMin = Math.min.apply(
      null,
      arr.slice(i, Math.min(i + QUANTUM, arr.length)),
    );
    min = Math.min(subMin, min);
  }

  return min;
}

const min = minOfArray([5, 6, 2, 3, 7]);
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-function.prototype.applyBrowser compatibilitySee also
arguments
Function.prototype.bind()
Function.prototype.call()
Reflect.apply()
Functions
Spread syntax (...)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nFunction.prototype.bind()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe bind() method of Function instances creates a new function that, when called, calls this function with its this keyword set to the provided value, and a given sequence of arguments preceding any provided when the new function is called.Try it
const module = {
  x: 42,
  getX: function () {
    return this.x;
  },
};

const unboundGetX = module.getX;
console.log(unboundGetX()); // The function gets invoked at the global scope
// Expected output: undefined

const boundGetX = unboundGetX.bind(module);
console.log(boundGetX());
// Expected output: 42
Syntaxjsbind(thisArg)
bind(thisArg, arg1)
bind(thisArg, arg1, arg2)
bind(thisArg, arg1, arg2, /* …, */ argN)
Parameters
thisArg

The value to be passed as the this parameter to the target function func when the bound function is called. If the function is not in strict mode, null and undefined will be replaced with the global object, and primitive values will be converted to objects. The value is ignored if the bound function is constructed using the new operator.

arg1, …, argN Optional

Arguments to prepend to arguments provided to the bound function when invoking func.

Return valueA copy of the given function with the specified this value, and initial arguments (if provided).DescriptionThe bind() function creates a new bound function. Calling the bound function generally results in the execution of the function it wraps, which is also called the target function. The bound function will store the parameters passed — which include the value of this and the first few arguments — as its internal state. These values are stored in advance, instead of being passed at call time. You can generally see const boundFn = fn.bind(thisArg, arg1, arg2) as being equivalent to const boundFn = (...restArgs) => fn.call(thisArg, arg1, arg2, ...restArgs) for the effect when it's called (but not when boundFn is constructed).
A bound function can be further bound by calling boundFn.bind(thisArg, /* more args */), which creates another bound function boundFn2. The newly bound thisArg value is ignored, because the target function of boundFn2, which is boundFn, already has a bound this. When boundFn2 is called, it would call boundFn, which in turn calls fn. The arguments that fn ultimately receives are, in order: the arguments bound by boundFn, arguments bound by boundFn2, and the arguments received by boundFn2.
js"use strict"; // prevent `this` from being boxed into the wrapper object

function log(...args) {
  console.log(this, ...args);
}
const boundLog = log.bind("this value", 1, 2);
const boundLog2 = boundLog.bind("new this value", 3, 4);
boundLog2(5, 6); // "this value", 1, 2, 3, 4, 5, 6

A bound function may also be constructed using the new operator if its target function is constructable. Doing so acts as though the target function had instead been constructed. The prepended arguments are provided to the target function as usual, while the provided this value is ignored (because construction prepares its own this, as seen by the parameters of Reflect.construct). If the bound function is directly constructed, new.target will be the target function instead. (That is, the bound function is transparent to new.target.)
jsclass Base {
  constructor(...args) {
    console.log(new.target === Base);
    console.log(args);
  }
}

const BoundBase = Base.bind(null, 1, 2);

new BoundBase(3, 4); // true, [1, 2, 3, 4]

However, because a bound function does not have the prototype property, it cannot be used as a base class for extends.
jsclass Derived extends class {}.bind(null) {}
// TypeError: Class extends value does not have valid prototype property undefined

When using a bound function as the right-hand side of instanceof, instanceof would reach for the target function (which is stored internally in the bound function) and read its prototype instead.
jsclass Base {}
const BoundBase = Base.bind(null, 1, 2);
console.log(new Base() instanceof BoundBase); // true

The bound function has the following properties:

length

The length of the target function minus the number of arguments being bound (not counting the thisArg parameter), with 0 being the minimum value.

name

The name of the target function plus a "bound " prefix.


The bound function also inherits the prototype chain of the target function. However, it doesn't have other own properties of the target function (such as static properties if the target function is a class).ExamplesCreating a bound functionThe most common use of bind() is to make a function that, no matter how it is called, is called with a particular this value.
A common mistake for new JavaScript programmers is to extract a method from an object, then to later call that function and expect it to use the original object as its this (e.g., by using the method in callback-based code).
Without special care, however, the original object is usually lost. Creating a bound function from the function, using the original object, neatly solves this problem:
js// Top-level 'this' is bound to 'globalThis' in scripts.
this.x = 9;
const module = {
  x: 81,
  getX() {
    return this.x;
  },
};

// The 'this' parameter of 'getX' is bound to 'module'.
console.log(module.getX()); // 81

const retrieveX = module.getX;
// The 'this' parameter of 'retrieveX' is bound to 'globalThis' in non-strict mode.
console.log(retrieveX()); // 9

// Create a new function 'boundGetX' with the 'this' parameter bound to 'module'.
const boundGetX = retrieveX.bind(module);
console.log(boundGetX()); // 81


Note:
If you run this example in strict mode, the this parameter of retrieveX will be bound to undefined instead of globalThis, causing the retrieveX() call to fail.
If you run this example in an ECMAScript module, top-level this will be bound to undefined instead of globalThis, causing the this.x = 9 assignment to fail.
If you run this example in a Node CommonJS module, top-level this will be bound to module.exports instead of globalThis. However, the this parameter of retrieveX will still be bound to globalThis in non-strict mode and to undefined in strict mode. Therefore, in non-strict mode (the default), the retrieveX() call will return undefined because this.x = 9 is writing to a different object (module.exports) from what getX is reading from (globalThis).

In fact, some built-in "methods" are also getters that return bound functions — one notable example being Intl.NumberFormat.prototype.format(), which, when accessed, returns a bound function that you can directly pass as a callback.Partially applied functionsAnother use of bind() is to make a function with pre-specified initial arguments.
These arguments (if any) follow the provided this value and are then inserted at the start of the arguments passed to the target function, followed by whatever arguments are passed to the bound function at the time it is called.
jsfunction list(...args) {
  return args;
}

function addArguments(arg1, arg2) {
  return arg1 + arg2;
}

console.log(list(1, 2, 3)); // [1, 2, 3]

console.log(addArguments(1, 2)); // 3

// Create a function with a preset leading argument
const leadingThirtySevenList = list.bind(null, 37);

// Create a function with a preset first argument.
const addThirtySeven = addArguments.bind(null, 37);

console.log(leadingThirtySevenList()); // [37]
console.log(leadingThirtySevenList(1, 2, 3)); // [37, 1, 2, 3]
console.log(addThirtySeven(5)); // 42
console.log(addThirtySeven(5, 10)); // 42
// (the last argument 10 is ignored)
With setTimeout()By default, within setTimeout(), the this keyword will be set to globalThis, which is window in browsers. When working with class methods that require this to refer to class instances, you may explicitly bind this to the callback function, in order to maintain the instance.
jsclass LateBloomer {
  constructor() {
    this.petalCount = Math.floor(Math.random() * 12) + 1;
  }
  bloom() {
    // Declare bloom after a delay of 1 second
    setTimeout(this.declare.bind(this), 1000);
  }
  declare() {
    console.log(`I am a beautiful flower with ${this.petalCount} petals!`);
  }
}

const flower = new LateBloomer();
flower.bloom();
// After 1 second, calls 'flower.declare()'

You can also use arrow functions for this purpose.
jsclass LateBloomer {
  bloom() {
    // Declare bloom after a delay of 1 second
    setTimeout(() => this.declare(), 1000);
  }
}
Bound functions used as constructorsBound functions are automatically suitable for use with the new operator to construct new instances created by the target function. When a bound function is used to construct a value, the provided this is ignored. However, provided arguments are still prepended to the constructor call.
jsfunction Point(x, y) {
  this.x = x;
  this.y = y;
}

Point.prototype.toString = function () {
  return `${this.x},${this.y}`;
};

const p = new Point(1, 2);
p.toString();
// '1,2'

// The thisArg's value doesn't matter because it's ignored
const YAxisPoint = Point.bind(null, 0 /*x*/);

const axisPoint = new YAxisPoint(5);
axisPoint.toString(); // '0,5'

axisPoint instanceof Point; // true
axisPoint instanceof YAxisPoint; // true
new YAxisPoint(17, 42) instanceof Point; // true

Note that you need not do anything special to create a bound function for use with new. new.target, instanceof, this etc. all work as expected, as if the constructor was never bound. The only difference is that it can no longer be used for extends.
The corollary is that you need not do anything special to create a bound function to be called plainly, even if you would rather require the bound function to only be called using new. If you call it without new, the bound this is suddenly not ignored.
jsconst emptyObj = {};
const YAxisPoint = Point.bind(emptyObj, 0 /*x*/);

// Can still be called as a normal function
// (although usually this is undesirable)
YAxisPoint(13);

// The modifications to `this` is now observable from the outside
console.log(emptyObj); // { x: 0, y: 13 }

If you wish to restrict a bound function to only be callable with new, or only be callable without new, the target function must enforce that restriction, such as by checking new.target !== undefined or using a class instead.Binding classesUsing bind() on classes preserves most of the class's semantics, except that all static own properties of the current class are lost. However, because the prototype chain is preserved, you can still access static properties inherited from the parent class.
jsclass Base {
  static baseProp = "base";
}

class Derived extends Base {
  static derivedProp = "derived";
}

const BoundDerived = Derived.bind(null);
console.log(BoundDerived.baseProp); // "base"
console.log(BoundDerived.derivedProp); // undefined
console.log(new BoundDerived() instanceof Derived); // true
Transforming methods to utility functionsbind() is also helpful in cases where you want to transform a method which requires a specific this value to a plain utility function that accepts the previous this parameter as a normal parameter. This is similar to how general-purpose utility functions work: instead of calling array.map(callback), you use map(array, callback), which allows you to use map with array-like objects that are not arrays (for example, arguments) without mutating Object.prototype.
Take Array.prototype.slice(), for example, which you want to use for converting an array-like object to a real array. You could create a shortcut like this:
jsconst slice = Array.prototype.slice;

// …

slice.call(arguments);

Note that you can't save slice.call and call it as a plain function, because the call() method also reads its this value, which is the function it should call. In this case, you can use bind() to bind the value of this for call(). In the following piece of code, slice() is a bound version of Function.prototype.call(), with the this value bound to Array.prototype.slice(). This means that additional call() calls can be eliminated:
js// Same as "slice" in the previous example
const unboundSlice = Array.prototype.slice;
const slice = Function.prototype.call.bind(unboundSlice);

// …

slice(arguments);
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-function.prototype.bindBrowser compatibilitySee also
Polyfill of Function.prototype.bind in core-js
Function.prototype.apply()
Function.prototype.call()
Functions\n\nFunction.prototype.bind()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe bind() method of Function instances creates a new function that, when called, calls this function with its this keyword set to the provided value, and a given sequence of arguments preceding any provided when the new function is called.Try it
const module = {
  x: 42,
  getX: function () {
    return this.x;
  },
};

const unboundGetX = module.getX;
console.log(unboundGetX()); // The function gets invoked at the global scope
// Expected output: undefined

const boundGetX = unboundGetX.bind(module);
console.log(boundGetX());
// Expected output: 42
Syntaxjsbind(thisArg)
bind(thisArg, arg1)
bind(thisArg, arg1, arg2)
bind(thisArg, arg1, arg2, /* …, */ argN)
Parameters
thisArg

The value to be passed as the this parameter to the target function func when the bound function is called. If the function is not in strict mode, null and undefined will be replaced with the global object, and primitive values will be converted to objects. The value is ignored if the bound function is constructed using the new operator.

arg1, …, argN Optional

Arguments to prepend to arguments provided to the bound function when invoking func.

Return valueA copy of the given function with the specified this value, and initial arguments (if provided).DescriptionThe bind() function creates a new bound function. Calling the bound function generally results in the execution of the function it wraps, which is also called the target function. The bound function will store the parameters passed — which include the value of this and the first few arguments — as its internal state. These values are stored in advance, instead of being passed at call time. You can generally see const boundFn = fn.bind(thisArg, arg1, arg2) as being equivalent to const boundFn = (...restArgs) => fn.call(thisArg, arg1, arg2, ...restArgs) for the effect when it's called (but not when boundFn is constructed).
A bound function can be further bound by calling boundFn.bind(thisArg, /* more args */), which creates another bound function boundFn2. The newly bound thisArg value is ignored, because the target function of boundFn2, which is boundFn, already has a bound this. When boundFn2 is called, it would call boundFn, which in turn calls fn. The arguments that fn ultimately receives are, in order: the arguments bound by boundFn, arguments bound by boundFn2, and the arguments received by boundFn2.
js"use strict"; // prevent `this` from being boxed into the wrapper object

function log(...args) {
  console.log(this, ...args);
}
const boundLog = log.bind("this value", 1, 2);
const boundLog2 = boundLog.bind("new this value", 3, 4);
boundLog2(5, 6); // "this value", 1, 2, 3, 4, 5, 6

A bound function may also be constructed using the new operator if its target function is constructable. Doing so acts as though the target function had instead been constructed. The prepended arguments are provided to the target function as usual, while the provided this value is ignored (because construction prepares its own this, as seen by the parameters of Reflect.construct). If the bound function is directly constructed, new.target will be the target function instead. (That is, the bound function is transparent to new.target.)
jsclass Base {
  constructor(...args) {
    console.log(new.target === Base);
    console.log(args);
  }
}

const BoundBase = Base.bind(null, 1, 2);

new BoundBase(3, 4); // true, [1, 2, 3, 4]

However, because a bound function does not have the prototype property, it cannot be used as a base class for extends.
jsclass Derived extends class {}.bind(null) {}
// TypeError: Class extends value does not have valid prototype property undefined

When using a bound function as the right-hand side of instanceof, instanceof would reach for the target function (which is stored internally in the bound function) and read its prototype instead.
jsclass Base {}
const BoundBase = Base.bind(null, 1, 2);
console.log(new Base() instanceof BoundBase); // true

The bound function has the following properties:

length

The length of the target function minus the number of arguments being bound (not counting the thisArg parameter), with 0 being the minimum value.

name

The name of the target function plus a "bound " prefix.


The bound function also inherits the prototype chain of the target function. However, it doesn't have other own properties of the target function (such as static properties if the target function is a class).ExamplesCreating a bound functionThe most common use of bind() is to make a function that, no matter how it is called, is called with a particular this value.
A common mistake for new JavaScript programmers is to extract a method from an object, then to later call that function and expect it to use the original object as its this (e.g., by using the method in callback-based code).
Without special care, however, the original object is usually lost. Creating a bound function from the function, using the original object, neatly solves this problem:
js// Top-level 'this' is bound to 'globalThis' in scripts.
this.x = 9;
const module = {
  x: 81,
  getX() {
    return this.x;
  },
};

// The 'this' parameter of 'getX' is bound to 'module'.
console.log(module.getX()); // 81

const retrieveX = module.getX;
// The 'this' parameter of 'retrieveX' is bound to 'globalThis' in non-strict mode.
console.log(retrieveX()); // 9

// Create a new function 'boundGetX' with the 'this' parameter bound to 'module'.
const boundGetX = retrieveX.bind(module);
console.log(boundGetX()); // 81


Note:
If you run this example in strict mode, the this parameter of retrieveX will be bound to undefined instead of globalThis, causing the retrieveX() call to fail.
If you run this example in an ECMAScript module, top-level this will be bound to undefined instead of globalThis, causing the this.x = 9 assignment to fail.
If you run this example in a Node CommonJS module, top-level this will be bound to module.exports instead of globalThis. However, the this parameter of retrieveX will still be bound to globalThis in non-strict mode and to undefined in strict mode. Therefore, in non-strict mode (the default), the retrieveX() call will return undefined because this.x = 9 is writing to a different object (module.exports) from what getX is reading from (globalThis).

In fact, some built-in "methods" are also getters that return bound functions — one notable example being Intl.NumberFormat.prototype.format(), which, when accessed, returns a bound function that you can directly pass as a callback.Partially applied functionsAnother use of bind() is to make a function with pre-specified initial arguments.
These arguments (if any) follow the provided this value and are then inserted at the start of the arguments passed to the target function, followed by whatever arguments are passed to the bound function at the time it is called.
jsfunction list(...args) {
  return args;
}

function addArguments(arg1, arg2) {
  return arg1 + arg2;
}

console.log(list(1, 2, 3)); // [1, 2, 3]

console.log(addArguments(1, 2)); // 3

// Create a function with a preset leading argument
const leadingThirtySevenList = list.bind(null, 37);

// Create a function with a preset first argument.
const addThirtySeven = addArguments.bind(null, 37);

console.log(leadingThirtySevenList()); // [37]
console.log(leadingThirtySevenList(1, 2, 3)); // [37, 1, 2, 3]
console.log(addThirtySeven(5)); // 42
console.log(addThirtySeven(5, 10)); // 42
// (the last argument 10 is ignored)
With setTimeout()By default, within setTimeout(), the this keyword will be set to globalThis, which is window in browsers. When working with class methods that require this to refer to class instances, you may explicitly bind this to the callback function, in order to maintain the instance.
jsclass LateBloomer {
  constructor() {
    this.petalCount = Math.floor(Math.random() * 12) + 1;
  }
  bloom() {
    // Declare bloom after a delay of 1 second
    setTimeout(this.declare.bind(this), 1000);
  }
  declare() {
    console.log(`I am a beautiful flower with ${this.petalCount} petals!`);
  }
}

const flower = new LateBloomer();
flower.bloom();
// After 1 second, calls 'flower.declare()'

You can also use arrow functions for this purpose.
jsclass LateBloomer {
  bloom() {
    // Declare bloom after a delay of 1 second
    setTimeout(() => this.declare(), 1000);
  }
}
Bound functions used as constructorsBound functions are automatically suitable for use with the new operator to construct new instances created by the target function. When a bound function is used to construct a value, the provided this is ignored. However, provided arguments are still prepended to the constructor call.
jsfunction Point(x, y) {
  this.x = x;
  this.y = y;
}

Point.prototype.toString = function () {
  return `${this.x},${this.y}`;
};

const p = new Point(1, 2);
p.toString();
// '1,2'

// The thisArg's value doesn't matter because it's ignored
const YAxisPoint = Point.bind(null, 0 /*x*/);

const axisPoint = new YAxisPoint(5);
axisPoint.toString(); // '0,5'

axisPoint instanceof Point; // true
axisPoint instanceof YAxisPoint; // true
new YAxisPoint(17, 42) instanceof Point; // true

Note that you need not do anything special to create a bound function for use with new. new.target, instanceof, this etc. all work as expected, as if the constructor was never bound. The only difference is that it can no longer be used for extends.
The corollary is that you need not do anything special to create a bound function to be called plainly, even if you would rather require the bound function to only be called using new. If you call it without new, the bound this is suddenly not ignored.
jsconst emptyObj = {};
const YAxisPoint = Point.bind(emptyObj, 0 /*x*/);

// Can still be called as a normal function
// (although usually this is undesirable)
YAxisPoint(13);

// The modifications to `this` is now observable from the outside
console.log(emptyObj); // { x: 0, y: 13 }

If you wish to restrict a bound function to only be callable with new, or only be callable without new, the target function must enforce that restriction, such as by checking new.target !== undefined or using a class instead.Binding classesUsing bind() on classes preserves most of the class's semantics, except that all static own properties of the current class are lost. However, because the prototype chain is preserved, you can still access static properties inherited from the parent class.
jsclass Base {
  static baseProp = "base";
}

class Derived extends Base {
  static derivedProp = "derived";
}

const BoundDerived = Derived.bind(null);
console.log(BoundDerived.baseProp); // "base"
console.log(BoundDerived.derivedProp); // undefined
console.log(new BoundDerived() instanceof Derived); // true
Transforming methods to utility functionsbind() is also helpful in cases where you want to transform a method which requires a specific this value to a plain utility function that accepts the previous this parameter as a normal parameter. This is similar to how general-purpose utility functions work: instead of calling array.map(callback), you use map(array, callback), which allows you to use map with array-like objects that are not arrays (for example, arguments) without mutating Object.prototype.
Take Array.prototype.slice(), for example, which you want to use for converting an array-like object to a real array. You could create a shortcut like this:
jsconst slice = Array.prototype.slice;

// …

slice.call(arguments);

Note that you can't save slice.call and call it as a plain function, because the call() method also reads its this value, which is the function it should call. In this case, you can use bind() to bind the value of this for call(). In the following piece of code, slice() is a bound version of Function.prototype.call(), with the this value bound to Array.prototype.slice(). This means that additional call() calls can be eliminated:
js// Same as "slice" in the previous example
const unboundSlice = Array.prototype.slice;
const slice = Function.prototype.call.bind(unboundSlice);

// …

slice(arguments);
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-function.prototype.bindBrowser compatibilitySee also
Polyfill of Function.prototype.bind in core-js
Function.prototype.apply()
Function.prototype.call()
Functions
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 28, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nFunction.prototype.bind()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe bind() method of Function instances creates a new function that, when called, calls this function with its this keyword set to the provided value, and a given sequence of arguments preceding any provided when the new function is called.Try it
const module = {
  x: 42,
  getX: function () {
    return this.x;
  },
};

const unboundGetX = module.getX;
console.log(unboundGetX()); // The function gets invoked at the global scope
// Expected output: undefined

const boundGetX = unboundGetX.bind(module);
console.log(boundGetX());
// Expected output: 42
Syntaxjsbind(thisArg)
bind(thisArg, arg1)
bind(thisArg, arg1, arg2)
bind(thisArg, arg1, arg2, /* …, */ argN)
Parameters
thisArg

The value to be passed as the this parameter to the target function func when the bound function is called. If the function is not in strict mode, null and undefined will be replaced with the global object, and primitive values will be converted to objects. The value is ignored if the bound function is constructed using the new operator.

arg1, …, argN Optional

Arguments to prepend to arguments provided to the bound function when invoking func.

Return valueA copy of the given function with the specified this value, and initial arguments (if provided).DescriptionThe bind() function creates a new bound function. Calling the bound function generally results in the execution of the function it wraps, which is also called the target function. The bound function will store the parameters passed — which include the value of this and the first few arguments — as its internal state. These values are stored in advance, instead of being passed at call time. You can generally see const boundFn = fn.bind(thisArg, arg1, arg2) as being equivalent to const boundFn = (...restArgs) => fn.call(thisArg, arg1, arg2, ...restArgs) for the effect when it's called (but not when boundFn is constructed).
A bound function can be further bound by calling boundFn.bind(thisArg, /* more args */), which creates another bound function boundFn2. The newly bound thisArg value is ignored, because the target function of boundFn2, which is boundFn, already has a bound this. When boundFn2 is called, it would call boundFn, which in turn calls fn. The arguments that fn ultimately receives are, in order: the arguments bound by boundFn, arguments bound by boundFn2, and the arguments received by boundFn2.
js"use strict"; // prevent `this` from being boxed into the wrapper object

function log(...args) {
  console.log(this, ...args);
}
const boundLog = log.bind("this value", 1, 2);
const boundLog2 = boundLog.bind("new this value", 3, 4);
boundLog2(5, 6); // "this value", 1, 2, 3, 4, 5, 6

A bound function may also be constructed using the new operator if its target function is constructable. Doing so acts as though the target function had instead been constructed. The prepended arguments are provided to the target function as usual, while the provided this value is ignored (because construction prepares its own this, as seen by the parameters of Reflect.construct). If the bound function is directly constructed, new.target will be the target function instead. (That is, the bound function is transparent to new.target.)
jsclass Base {
  constructor(...args) {
    console.log(new.target === Base);
    console.log(args);
  }
}

const BoundBase = Base.bind(null, 1, 2);

new BoundBase(3, 4); // true, [1, 2, 3, 4]

However, because a bound function does not have the prototype property, it cannot be used as a base class for extends.
jsclass Derived extends class {}.bind(null) {}
// TypeError: Class extends value does not have valid prototype property undefined

When using a bound function as the right-hand side of instanceof, instanceof would reach for the target function (which is stored internally in the bound function) and read its prototype instead.
jsclass Base {}
const BoundBase = Base.bind(null, 1, 2);
console.log(new Base() instanceof BoundBase); // true

The bound function has the following properties:

length

The length of the target function minus the number of arguments being bound (not counting the thisArg parameter), with 0 being the minimum value.

name

The name of the target function plus a "bound " prefix.


The bound function also inherits the prototype chain of the target function. However, it doesn't have other own properties of the target function (such as static properties if the target function is a class).ExamplesCreating a bound functionThe most common use of bind() is to make a function that, no matter how it is called, is called with a particular this value.
A common mistake for new JavaScript programmers is to extract a method from an object, then to later call that function and expect it to use the original object as its this (e.g., by using the method in callback-based code).
Without special care, however, the original object is usually lost. Creating a bound function from the function, using the original object, neatly solves this problem:
js// Top-level 'this' is bound to 'globalThis' in scripts.
this.x = 9;
const module = {
  x: 81,
  getX() {
    return this.x;
  },
};

// The 'this' parameter of 'getX' is bound to 'module'.
console.log(module.getX()); // 81

const retrieveX = module.getX;
// The 'this' parameter of 'retrieveX' is bound to 'globalThis' in non-strict mode.
console.log(retrieveX()); // 9

// Create a new function 'boundGetX' with the 'this' parameter bound to 'module'.
const boundGetX = retrieveX.bind(module);
console.log(boundGetX()); // 81


Note:
If you run this example in strict mode, the this parameter of retrieveX will be bound to undefined instead of globalThis, causing the retrieveX() call to fail.
If you run this example in an ECMAScript module, top-level this will be bound to undefined instead of globalThis, causing the this.x = 9 assignment to fail.
If you run this example in a Node CommonJS module, top-level this will be bound to module.exports instead of globalThis. However, the this parameter of retrieveX will still be bound to globalThis in non-strict mode and to undefined in strict mode. Therefore, in non-strict mode (the default), the retrieveX() call will return undefined because this.x = 9 is writing to a different object (module.exports) from what getX is reading from (globalThis).

In fact, some built-in "methods" are also getters that return bound functions — one notable example being Intl.NumberFormat.prototype.format(), which, when accessed, returns a bound function that you can directly pass as a callback.Partially applied functionsAnother use of bind() is to make a function with pre-specified initial arguments.
These arguments (if any) follow the provided this value and are then inserted at the start of the arguments passed to the target function, followed by whatever arguments are passed to the bound function at the time it is called.
jsfunction list(...args) {
  return args;
}

function addArguments(arg1, arg2) {
  return arg1 + arg2;
}

console.log(list(1, 2, 3)); // [1, 2, 3]

console.log(addArguments(1, 2)); // 3

// Create a function with a preset leading argument
const leadingThirtySevenList = list.bind(null, 37);

// Create a function with a preset first argument.
const addThirtySeven = addArguments.bind(null, 37);

console.log(leadingThirtySevenList()); // [37]
console.log(leadingThirtySevenList(1, 2, 3)); // [37, 1, 2, 3]
console.log(addThirtySeven(5)); // 42
console.log(addThirtySeven(5, 10)); // 42
// (the last argument 10 is ignored)
With setTimeout()By default, within setTimeout(), the this keyword will be set to globalThis, which is window in browsers. When working with class methods that require this to refer to class instances, you may explicitly bind this to the callback function, in order to maintain the instance.
jsclass LateBloomer {
  constructor() {
    this.petalCount = Math.floor(Math.random() * 12) + 1;
  }
  bloom() {
    // Declare bloom after a delay of 1 second
    setTimeout(this.declare.bind(this), 1000);
  }
  declare() {
    console.log(`I am a beautiful flower with ${this.petalCount} petals!`);
  }
}

const flower = new LateBloomer();
flower.bloom();
// After 1 second, calls 'flower.declare()'

You can also use arrow functions for this purpose.
jsclass LateBloomer {
  bloom() {
    // Declare bloom after a delay of 1 second
    setTimeout(() => this.declare(), 1000);
  }
}
Bound functions used as constructorsBound functions are automatically suitable for use with the new operator to construct new instances created by the target function. When a bound function is used to construct a value, the provided this is ignored. However, provided arguments are still prepended to the constructor call.
jsfunction Point(x, y) {
  this.x = x;
  this.y = y;
}

Point.prototype.toString = function () {
  return `${this.x},${this.y}`;
};

const p = new Point(1, 2);
p.toString();
// '1,2'

// The thisArg's value doesn't matter because it's ignored
const YAxisPoint = Point.bind(null, 0 /*x*/);

const axisPoint = new YAxisPoint(5);
axisPoint.toString(); // '0,5'

axisPoint instanceof Point; // true
axisPoint instanceof YAxisPoint; // true
new YAxisPoint(17, 42) instanceof Point; // true

Note that you need not do anything special to create a bound function for use with new. new.target, instanceof, this etc. all work as expected, as if the constructor was never bound. The only difference is that it can no longer be used for extends.
The corollary is that you need not do anything special to create a bound function to be called plainly, even if you would rather require the bound function to only be called using new. If you call it without new, the bound this is suddenly not ignored.
jsconst emptyObj = {};
const YAxisPoint = Point.bind(emptyObj, 0 /*x*/);

// Can still be called as a normal function
// (although usually this is undesirable)
YAxisPoint(13);

// The modifications to `this` is now observable from the outside
console.log(emptyObj); // { x: 0, y: 13 }

If you wish to restrict a bound function to only be callable with new, or only be callable without new, the target function must enforce that restriction, such as by checking new.target !== undefined or using a class instead.Binding classesUsing bind() on classes preserves most of the class's semantics, except that all static own properties of the current class are lost. However, because the prototype chain is preserved, you can still access static properties inherited from the parent class.
jsclass Base {
  static baseProp = "base";
}

class Derived extends Base {
  static derivedProp = "derived";
}

const BoundDerived = Derived.bind(null);
console.log(BoundDerived.baseProp); // "base"
console.log(BoundDerived.derivedProp); // undefined
console.log(new BoundDerived() instanceof Derived); // true
Transforming methods to utility functionsbind() is also helpful in cases where you want to transform a method which requires a specific this value to a plain utility function that accepts the previous this parameter as a normal parameter. This is similar to how general-purpose utility functions work: instead of calling array.map(callback), you use map(array, callback), which allows you to use map with array-like objects that are not arrays (for example, arguments) without mutating Object.prototype.
Take Array.prototype.slice(), for example, which you want to use for converting an array-like object to a real array. You could create a shortcut like this:
jsconst slice = Array.prototype.slice;

// …

slice.call(arguments);

Note that you can't save slice.call and call it as a plain function, because the call() method also reads its this value, which is the function it should call. In this case, you can use bind() to bind the value of this for call(). In the following piece of code, slice() is a bound version of Function.prototype.call(), with the this value bound to Array.prototype.slice(). This means that additional call() calls can be eliminated:
js// Same as "slice" in the previous example
const unboundSlice = Array.prototype.slice;
const slice = Function.prototype.call.bind(unboundSlice);

// …

slice(arguments);
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-function.prototype.bindBrowser compatibilitySee also
Polyfill of Function.prototype.bind in core-js
Function.prototype.apply()
Function.prototype.call()
Functions
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 28, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nFunction.prototype.call()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe call() method of Function instances calls this function with a given this value and arguments provided individually.Try it
function Product(name, price) {
  this.name = name;
  this.price = price;
}

function Food(name, price) {
  Product.call(this, name, price);
  this.category = "food";
}

console.log(new Food("cheese", 5).name);
// Expected output: "cheese"
Syntaxjscall(thisArg)
call(thisArg, arg1)
call(thisArg, arg1, arg2)
call(thisArg, arg1, arg2, /* …, */ argN)
Parameters
thisArg

The value to use as this when calling func. If the function is not in strict mode, null and undefined will be replaced with the global object, and primitive values will be converted to objects.

arg1, …, argN Optional

Arguments for the function.

Return valueThe result of calling the function with the specified this value and arguments.Description
Note:
This function is almost identical to apply(), except that the function arguments are passed to call() individually as a list, while for apply() they are combined in one object, typically an array — for example, func.call(this, "eat", "bananas") vs. func.apply(this, ["eat", "bananas"]).

Normally, when calling a function, the value of this inside the function is the object that the function was accessed on. With call(), you can assign an arbitrary value as this when calling an existing function, without first attaching the function to the object as a property. This allows you to use methods of one object as generic utility functions.

Warning:
Do not use call() to chain constructors (for example, to implement inheritance). This invokes the constructor function as a plain function, which means new.target is undefined, and classes throw an error because they can't be called without new. Use Reflect.construct() or extends instead.
ExamplesUsing call() to invoke a function and specifying the this valueIn the example below, when we call greet, the value of this will be bound to object obj, even when greet is not a method of obj.
jsfunction greet() {
  console.log(this.animal, "typically sleep between", this.sleepDuration);
}

const obj = {
  animal: "cats",
  sleepDuration: "12 and 16 hours",
};

greet.call(obj); // cats typically sleep between 12 and 16 hours
Using call() to invoke a function without specifying the first argumentIf the first thisArg parameter is omitted, it defaults to undefined. In non-strict mode, the this value is then substituted with globalThis (which is akin to the global object).
jsglobalThis.globProp = "foo";

function display() {
  console.log(`globProp value is ${this.globProp}`);
}

display.call(); // Logs "globProp value is foo"

In strict mode, the value of this is not substituted, so it stays as undefined.
js"use strict";

globalThis.globProp = "foo";

function display() {
  console.log(`globProp value is ${this.globProp}`);
}

display.call(); // throws TypeError: Cannot read the property of 'globProp' of undefined
Transforming methods to utility functionscall() is almost equivalent to a normal function call, except that this is passed as a normal parameter instead of as the value that the function was accessed on. This is similar to how general-purpose utility functions work: instead of calling array.map(callback), you use map(array, callback), which allows you to use map with array-like objects that are not arrays (for example, arguments) without mutating Object.prototype.
Take Array.prototype.slice(), for example, which you want to use for converting an array-like object to a real array. You could create a shortcut like this:
jsconst slice = Array.prototype.slice;

// …

slice.call(arguments);

Note that you can't save slice.call and call it as a plain function, because the call() method also reads its this value, which is the function it should call. In this case, you can use bind() to bind the value of this for call(). In the following piece of code, slice() is a bound version of Function.prototype.call(), with the this value bound to Array.prototype.slice(). This means that additional call() calls can be eliminated:
js// Same as "slice" in the previous example
const unboundSlice = Array.prototype.slice;
const slice = Function.prototype.call.bind(unboundSlice);

// …

slice(arguments);
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-function.prototype.callBrowser compatibilitySee also
Function.prototype.bind()
Function.prototype.apply()
Reflect.apply()
Spread syntax (...)
Introduction to Object-Oriented JavaScript\n\nFunction.prototype.call()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe call() method of Function instances calls this function with a given this value and arguments provided individually.Try it
function Product(name, price) {
  this.name = name;
  this.price = price;
}

function Food(name, price) {
  Product.call(this, name, price);
  this.category = "food";
}

console.log(new Food("cheese", 5).name);
// Expected output: "cheese"
Syntaxjscall(thisArg)
call(thisArg, arg1)
call(thisArg, arg1, arg2)
call(thisArg, arg1, arg2, /* …, */ argN)
Parameters
thisArg

The value to use as this when calling func. If the function is not in strict mode, null and undefined will be replaced with the global object, and primitive values will be converted to objects.

arg1, …, argN Optional

Arguments for the function.

Return valueThe result of calling the function with the specified this value and arguments.Description
Note:
This function is almost identical to apply(), except that the function arguments are passed to call() individually as a list, while for apply() they are combined in one object, typically an array — for example, func.call(this, "eat", "bananas") vs. func.apply(this, ["eat", "bananas"]).

Normally, when calling a function, the value of this inside the function is the object that the function was accessed on. With call(), you can assign an arbitrary value as this when calling an existing function, without first attaching the function to the object as a property. This allows you to use methods of one object as generic utility functions.

Warning:
Do not use call() to chain constructors (for example, to implement inheritance). This invokes the constructor function as a plain function, which means new.target is undefined, and classes throw an error because they can't be called without new. Use Reflect.construct() or extends instead.
ExamplesUsing call() to invoke a function and specifying the this valueIn the example below, when we call greet, the value of this will be bound to object obj, even when greet is not a method of obj.
jsfunction greet() {
  console.log(this.animal, "typically sleep between", this.sleepDuration);
}

const obj = {
  animal: "cats",
  sleepDuration: "12 and 16 hours",
};

greet.call(obj); // cats typically sleep between 12 and 16 hours
Using call() to invoke a function without specifying the first argumentIf the first thisArg parameter is omitted, it defaults to undefined. In non-strict mode, the this value is then substituted with globalThis (which is akin to the global object).
jsglobalThis.globProp = "foo";

function display() {
  console.log(`globProp value is ${this.globProp}`);
}

display.call(); // Logs "globProp value is foo"

In strict mode, the value of this is not substituted, so it stays as undefined.
js"use strict";

globalThis.globProp = "foo";

function display() {
  console.log(`globProp value is ${this.globProp}`);
}

display.call(); // throws TypeError: Cannot read the property of 'globProp' of undefined
Transforming methods to utility functionscall() is almost equivalent to a normal function call, except that this is passed as a normal parameter instead of as the value that the function was accessed on. This is similar to how general-purpose utility functions work: instead of calling array.map(callback), you use map(array, callback), which allows you to use map with array-like objects that are not arrays (for example, arguments) without mutating Object.prototype.
Take Array.prototype.slice(), for example, which you want to use for converting an array-like object to a real array. You could create a shortcut like this:
jsconst slice = Array.prototype.slice;

// …

slice.call(arguments);

Note that you can't save slice.call and call it as a plain function, because the call() method also reads its this value, which is the function it should call. In this case, you can use bind() to bind the value of this for call(). In the following piece of code, slice() is a bound version of Function.prototype.call(), with the this value bound to Array.prototype.slice(). This means that additional call() calls can be eliminated:
js// Same as "slice" in the previous example
const unboundSlice = Array.prototype.slice;
const slice = Function.prototype.call.bind(unboundSlice);

// …

slice(arguments);
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-function.prototype.callBrowser compatibilitySee also
Function.prototype.bind()
Function.prototype.apply()
Reflect.apply()
Spread syntax (...)
Introduction to Object-Oriented JavaScript
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 28, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nFunction.prototype.call()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe call() method of Function instances calls this function with a given this value and arguments provided individually.Try it
function Product(name, price) {
  this.name = name;
  this.price = price;
}

function Food(name, price) {
  Product.call(this, name, price);
  this.category = "food";
}

console.log(new Food("cheese", 5).name);
// Expected output: "cheese"
Syntaxjscall(thisArg)
call(thisArg, arg1)
call(thisArg, arg1, arg2)
call(thisArg, arg1, arg2, /* …, */ argN)
Parameters
thisArg

The value to use as this when calling func. If the function is not in strict mode, null and undefined will be replaced with the global object, and primitive values will be converted to objects.

arg1, …, argN Optional

Arguments for the function.

Return valueThe result of calling the function with the specified this value and arguments.Description
Note:
This function is almost identical to apply(), except that the function arguments are passed to call() individually as a list, while for apply() they are combined in one object, typically an array — for example, func.call(this, "eat", "bananas") vs. func.apply(this, ["eat", "bananas"]).

Normally, when calling a function, the value of this inside the function is the object that the function was accessed on. With call(), you can assign an arbitrary value as this when calling an existing function, without first attaching the function to the object as a property. This allows you to use methods of one object as generic utility functions.

Warning:
Do not use call() to chain constructors (for example, to implement inheritance). This invokes the constructor function as a plain function, which means new.target is undefined, and classes throw an error because they can't be called without new. Use Reflect.construct() or extends instead.
ExamplesUsing call() to invoke a function and specifying the this valueIn the example below, when we call greet, the value of this will be bound to object obj, even when greet is not a method of obj.
jsfunction greet() {
  console.log(this.animal, "typically sleep between", this.sleepDuration);
}

const obj = {
  animal: "cats",
  sleepDuration: "12 and 16 hours",
};

greet.call(obj); // cats typically sleep between 12 and 16 hours
Using call() to invoke a function without specifying the first argumentIf the first thisArg parameter is omitted, it defaults to undefined. In non-strict mode, the this value is then substituted with globalThis (which is akin to the global object).
jsglobalThis.globProp = "foo";

function display() {
  console.log(`globProp value is ${this.globProp}`);
}

display.call(); // Logs "globProp value is foo"

In strict mode, the value of this is not substituted, so it stays as undefined.
js"use strict";

globalThis.globProp = "foo";

function display() {
  console.log(`globProp value is ${this.globProp}`);
}

display.call(); // throws TypeError: Cannot read the property of 'globProp' of undefined
Transforming methods to utility functionscall() is almost equivalent to a normal function call, except that this is passed as a normal parameter instead of as the value that the function was accessed on. This is similar to how general-purpose utility functions work: instead of calling array.map(callback), you use map(array, callback), which allows you to use map with array-like objects that are not arrays (for example, arguments) without mutating Object.prototype.
Take Array.prototype.slice(), for example, which you want to use for converting an array-like object to a real array. You could create a shortcut like this:
jsconst slice = Array.prototype.slice;

// …

slice.call(arguments);

Note that you can't save slice.call and call it as a plain function, because the call() method also reads its this value, which is the function it should call. In this case, you can use bind() to bind the value of this for call(). In the following piece of code, slice() is a bound version of Function.prototype.call(), with the this value bound to Array.prototype.slice(). This means that additional call() calls can be eliminated:
js// Same as "slice" in the previous example
const unboundSlice = Array.prototype.slice;
const slice = Function.prototype.call.bind(unboundSlice);

// …

slice(arguments);
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-function.prototype.callBrowser compatibilitySee also
Function.prototype.bind()
Function.prototype.apply()
Reflect.apply()
Spread syntax (...)
Introduction to Object-Oriented JavaScript
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 28, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nFunction.prototype.toString()Baseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe toString() method of Function instances returns a string representing the source code of this function.Try it
function sum(a, b) {
  return a + b;
}

console.log(sum.toString());
// Expected output: "function sum(a, b) {
//                     return a + b;
//                   }"

console.log(Math.abs.toString());
// Expected output: "function abs() { [native code] }"
SyntaxjstoString()
ParametersNone.Return valueA string representing the source code of the function.DescriptionThe Function object overrides the toString() method
inherited from Object; it does not inherit
Object.prototype.toString. For user-defined Function
objects, the toString method returns a string containing the source text
segment which was used to define the function.
JavaScript calls the toString method automatically when a
Function is to be represented as a text value, e.g., when a function is
concatenated with a string.
The toString() method will throw a TypeError exception
("Function.prototype.toString called on incompatible object"), if its
this value object is not a Function object.
jsFunction.prototype.toString.call("foo"); // throws TypeError

If the toString() method is called on built-in function objects, a
function created by Function.prototype.bind(), or
other non-JavaScript functions, then toString() returns a
native function string which looks like
function someName() { [native code] }

For intrinsic object methods and functions, someName is the initial name of the function; otherwise its content may be implementation-defined, but will always be in property name syntax, like [1 + 1], someName, or 1.

Note:
This means using eval() on native function strings is a guaranteed syntax error.

If the toString() method is called on a function created by the Function constructor, toString() returns the source code of a synthesized function declaration named "anonymous" using the provided parameters and function body. For example, Function("a", "b", "return a + b").toString() will return:
function anonymous(a,b
) {
return a + b
}

Since ES2018, the spec requires the return value of toString() to be the exact same source code as it was declared, including any whitespace and/or comments — or, if the host doesn't have the source code available for some reason, requires returning a native function string. Support for this revised behavior can be found in the compatibility table.ExamplesComparing actual source code and toString resultsjsfunction test(fn) {
  console.log(fn.toString());
}

function f() {}
class A {
  a() {}
}
function* g() {}

test(f); // "function f() {}"
test(A); // "class A { a() {} }"
test(g); // "function* g() {}"
test((a) => a); // "(a) => a"
test({ a() {} }.a); // "a() {}"
test({ *a() {} }.a); // "*a() {}"
test({ [0]() {} }[0]); // "[0]() {}"
test(Object.getOwnPropertyDescriptor({ get a() {} }, "a").get); // "get a() {}"
test(Object.getOwnPropertyDescriptor({ set a(x) {} }, "a").set); // "set a(x) {}"
test(Function.prototype.toString); // "function toString() { [native code] }"
test(function f() {}.bind(0)); // "function () { [native code] }"
test(Function("a", "b")); // function anonymous(a\n) {\nb\n}

Note that after the Function.prototype.toString() revision, when toString() is called, implementations are never allowed to synthesize a function's source that is not a native function string. The method always returns the exact source code used to create the function — including the getter and setter examples above. The Function constructor itself has the capability of synthesizing the source code for the function (and is therefore a form of implicit eval()).Getting source text of a functionIt is possible to get the source text of a function by coercing it to a string — for example, by wrapping it in a template literal:
jsfunction foo() {
  return "bar";
}
console.log(`${foo}`);
// function foo() {
//   return "bar";
// }

This source text is exact, including any interspersed comments (which won't be stored by the engine's internal representation otherwise).
jsfunction foo /* a comment */() {
  return "bar";
}
console.log(foo.toString());
// function foo /* a comment */() {
//   return "bar";
// }
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-function.prototype.tostringBrowser compatibilitySee also
Object.prototype.toString()\n\nFunction.prototype.toString()Baseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe toString() method of Function instances returns a string representing the source code of this function.Try it
function sum(a, b) {
  return a + b;
}

console.log(sum.toString());
// Expected output: "function sum(a, b) {
//                     return a + b;
//                   }"

console.log(Math.abs.toString());
// Expected output: "function abs() { [native code] }"
SyntaxjstoString()
ParametersNone.Return valueA string representing the source code of the function.DescriptionThe Function object overrides the toString() method
inherited from Object; it does not inherit
Object.prototype.toString. For user-defined Function
objects, the toString method returns a string containing the source text
segment which was used to define the function.
JavaScript calls the toString method automatically when a
Function is to be represented as a text value, e.g., when a function is
concatenated with a string.
The toString() method will throw a TypeError exception
("Function.prototype.toString called on incompatible object"), if its
this value object is not a Function object.
jsFunction.prototype.toString.call("foo"); // throws TypeError

If the toString() method is called on built-in function objects, a
function created by Function.prototype.bind(), or
other non-JavaScript functions, then toString() returns a
native function string which looks like
function someName() { [native code] }

For intrinsic object methods and functions, someName is the initial name of the function; otherwise its content may be implementation-defined, but will always be in property name syntax, like [1 + 1], someName, or 1.

Note:
This means using eval() on native function strings is a guaranteed syntax error.

If the toString() method is called on a function created by the Function constructor, toString() returns the source code of a synthesized function declaration named "anonymous" using the provided parameters and function body. For example, Function("a", "b", "return a + b").toString() will return:
function anonymous(a,b
) {
return a + b
}

Since ES2018, the spec requires the return value of toString() to be the exact same source code as it was declared, including any whitespace and/or comments — or, if the host doesn't have the source code available for some reason, requires returning a native function string. Support for this revised behavior can be found in the compatibility table.ExamplesComparing actual source code and toString resultsjsfunction test(fn) {
  console.log(fn.toString());
}

function f() {}
class A {
  a() {}
}
function* g() {}

test(f); // "function f() {}"
test(A); // "class A { a() {} }"
test(g); // "function* g() {}"
test((a) => a); // "(a) => a"
test({ a() {} }.a); // "a() {}"
test({ *a() {} }.a); // "*a() {}"
test({ [0]() {} }[0]); // "[0]() {}"
test(Object.getOwnPropertyDescriptor({ get a() {} }, "a").get); // "get a() {}"
test(Object.getOwnPropertyDescriptor({ set a(x) {} }, "a").set); // "set a(x) {}"
test(Function.prototype.toString); // "function toString() { [native code] }"
test(function f() {}.bind(0)); // "function () { [native code] }"
test(Function("a", "b")); // function anonymous(a\n) {\nb\n}

Note that after the Function.prototype.toString() revision, when toString() is called, implementations are never allowed to synthesize a function's source that is not a native function string. The method always returns the exact source code used to create the function — including the getter and setter examples above. The Function constructor itself has the capability of synthesizing the source code for the function (and is therefore a form of implicit eval()).Getting source text of a functionIt is possible to get the source text of a function by coercing it to a string — for example, by wrapping it in a template literal:
jsfunction foo() {
  return "bar";
}
console.log(`${foo}`);
// function foo() {
//   return "bar";
// }

This source text is exact, including any interspersed comments (which won't be stored by the engine's internal representation otherwise).
jsfunction foo /* a comment */() {
  return "bar";
}
console.log(foo.toString());
// function foo /* a comment */() {
//   return "bar";
// }
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-function.prototype.tostringBrowser compatibilitySee also
Object.prototype.toString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nFunction.prototype.toString()Baseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe toString() method of Function instances returns a string representing the source code of this function.Try it
function sum(a, b) {
  return a + b;
}

console.log(sum.toString());
// Expected output: "function sum(a, b) {
//                     return a + b;
//                   }"

console.log(Math.abs.toString());
// Expected output: "function abs() { [native code] }"
SyntaxjstoString()
ParametersNone.Return valueA string representing the source code of the function.DescriptionThe Function object overrides the toString() method
inherited from Object; it does not inherit
Object.prototype.toString. For user-defined Function
objects, the toString method returns a string containing the source text
segment which was used to define the function.
JavaScript calls the toString method automatically when a
Function is to be represented as a text value, e.g., when a function is
concatenated with a string.
The toString() method will throw a TypeError exception
("Function.prototype.toString called on incompatible object"), if its
this value object is not a Function object.
jsFunction.prototype.toString.call("foo"); // throws TypeError

If the toString() method is called on built-in function objects, a
function created by Function.prototype.bind(), or
other non-JavaScript functions, then toString() returns a
native function string which looks like
function someName() { [native code] }

For intrinsic object methods and functions, someName is the initial name of the function; otherwise its content may be implementation-defined, but will always be in property name syntax, like [1 + 1], someName, or 1.

Note:
This means using eval() on native function strings is a guaranteed syntax error.

If the toString() method is called on a function created by the Function constructor, toString() returns the source code of a synthesized function declaration named "anonymous" using the provided parameters and function body. For example, Function("a", "b", "return a + b").toString() will return:
function anonymous(a,b
) {
return a + b
}

Since ES2018, the spec requires the return value of toString() to be the exact same source code as it was declared, including any whitespace and/or comments — or, if the host doesn't have the source code available for some reason, requires returning a native function string. Support for this revised behavior can be found in the compatibility table.ExamplesComparing actual source code and toString resultsjsfunction test(fn) {
  console.log(fn.toString());
}

function f() {}
class A {
  a() {}
}
function* g() {}

test(f); // "function f() {}"
test(A); // "class A { a() {} }"
test(g); // "function* g() {}"
test((a) => a); // "(a) => a"
test({ a() {} }.a); // "a() {}"
test({ *a() {} }.a); // "*a() {}"
test({ [0]() {} }[0]); // "[0]() {}"
test(Object.getOwnPropertyDescriptor({ get a() {} }, "a").get); // "get a() {}"
test(Object.getOwnPropertyDescriptor({ set a(x) {} }, "a").set); // "set a(x) {}"
test(Function.prototype.toString); // "function toString() { [native code] }"
test(function f() {}.bind(0)); // "function () { [native code] }"
test(Function("a", "b")); // function anonymous(a\n) {\nb\n}

Note that after the Function.prototype.toString() revision, when toString() is called, implementations are never allowed to synthesize a function's source that is not a native function string. The method always returns the exact source code used to create the function — including the getter and setter examples above. The Function constructor itself has the capability of synthesizing the source code for the function (and is therefore a form of implicit eval()).Getting source text of a functionIt is possible to get the source text of a function by coercing it to a string — for example, by wrapping it in a template literal:
jsfunction foo() {
  return "bar";
}
console.log(`${foo}`);
// function foo() {
//   return "bar";
// }

This source text is exact, including any interspersed comments (which won't be stored by the engine's internal representation otherwise).
jsfunction foo /* a comment */() {
  return "bar";
}
console.log(foo.toString());
// function foo /* a comment */() {
//   return "bar";
// }
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-function.prototype.tostringBrowser compatibilitySee also
Object.prototype.toString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nFunction.prototype[Symbol.hasInstance]()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe [Symbol.hasInstance]() method of Function instances specifies the default procedure for determining if a constructor function recognizes an object as one of the constructor's instances. It is called by the instanceof operator.Syntaxjsfunc[Symbol.hasInstance](value)
Parameters
value

The object to test. Primitive values always return false.

Return valuetrue if func.prototype is in the prototype chain of value; otherwise, false. Always returns false if value is not an object or this is not a function. If this is a bound function, returns the result of a instanceof test on value and the underlying target function.Exceptions
TypeError

Thrown if this is not a bound function and this.prototype is not an object.

DescriptionThe instanceof operator calls the [Symbol.hasInstance]() method of the right-hand side whenever such a method exists. Because all functions inherit from Function.prototype by default, they would all have the [Symbol.hasInstance]() method, so most of the time, the Function.prototype[Symbol.hasInstance]() method specifies the behavior of instanceof when the right-hand side is a function. This method implements the default behavior of the instanceof operator (the same algorithm when constructor has no [Symbol.hasInstance]() method).
Unlike most methods, the Function.prototype[Symbol.hasInstance]() property is non-configurable and non-writable. This is a security feature to prevent the underlying target function of a bound function from being obtainable. See this Stack Overflow answer for an example.ExamplesReverting to default instanceof behaviorYou would rarely need to call this method directly. Instead, this method is called by the instanceof operator. You should expect the two results to usually be equivalent.
jsclass Foo {}
const foo = new Foo();
console.log(foo instanceof Foo === Foo[Symbol.hasInstance](foo)); // true

You may want to use this method if you want to invoke the default instanceof behavior, but you don't know if a constructor has a overridden [Symbol.hasInstance]() method.
jsclass Foo {
  static [Symbol.hasInstance](value) {
    // A custom implementation
    return false;
  }
}

const foo = new Foo();
console.log(foo instanceof Foo); // false
console.log(Function.prototype[Symbol.hasInstance].call(Foo, foo)); // true
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-function.prototype-%symbol.hasinstance%Browser compatibilitySee also
instanceof
Symbol.hasInstance\n\nFunction.prototype[Symbol.hasInstance]()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe [Symbol.hasInstance]() method of Function instances specifies the default procedure for determining if a constructor function recognizes an object as one of the constructor's instances. It is called by the instanceof operator.Syntaxjsfunc[Symbol.hasInstance](value)
Parameters
value

The object to test. Primitive values always return false.

Return valuetrue if func.prototype is in the prototype chain of value; otherwise, false. Always returns false if value is not an object or this is not a function. If this is a bound function, returns the result of a instanceof test on value and the underlying target function.Exceptions
TypeError

Thrown if this is not a bound function and this.prototype is not an object.

DescriptionThe instanceof operator calls the [Symbol.hasInstance]() method of the right-hand side whenever such a method exists. Because all functions inherit from Function.prototype by default, they would all have the [Symbol.hasInstance]() method, so most of the time, the Function.prototype[Symbol.hasInstance]() method specifies the behavior of instanceof when the right-hand side is a function. This method implements the default behavior of the instanceof operator (the same algorithm when constructor has no [Symbol.hasInstance]() method).
Unlike most methods, the Function.prototype[Symbol.hasInstance]() property is non-configurable and non-writable. This is a security feature to prevent the underlying target function of a bound function from being obtainable. See this Stack Overflow answer for an example.ExamplesReverting to default instanceof behaviorYou would rarely need to call this method directly. Instead, this method is called by the instanceof operator. You should expect the two results to usually be equivalent.
jsclass Foo {}
const foo = new Foo();
console.log(foo instanceof Foo === Foo[Symbol.hasInstance](foo)); // true

You may want to use this method if you want to invoke the default instanceof behavior, but you don't know if a constructor has a overridden [Symbol.hasInstance]() method.
jsclass Foo {
  static [Symbol.hasInstance](value) {
    // A custom implementation
    return false;
  }
}

const foo = new Foo();
console.log(foo instanceof Foo); // false
console.log(Function.prototype[Symbol.hasInstance].call(Foo, foo)); // true
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-function.prototype-%symbol.hasinstance%Browser compatibilitySee also
instanceof
Symbol.hasInstance
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Nov 22, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nFunction.prototype[Symbol.hasInstance]()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe [Symbol.hasInstance]() method of Function instances specifies the default procedure for determining if a constructor function recognizes an object as one of the constructor's instances. It is called by the instanceof operator.Syntaxjsfunc[Symbol.hasInstance](value)
Parameters
value

The object to test. Primitive values always return false.

Return valuetrue if func.prototype is in the prototype chain of value; otherwise, false. Always returns false if value is not an object or this is not a function. If this is a bound function, returns the result of a instanceof test on value and the underlying target function.Exceptions
TypeError

Thrown if this is not a bound function and this.prototype is not an object.

DescriptionThe instanceof operator calls the [Symbol.hasInstance]() method of the right-hand side whenever such a method exists. Because all functions inherit from Function.prototype by default, they would all have the [Symbol.hasInstance]() method, so most of the time, the Function.prototype[Symbol.hasInstance]() method specifies the behavior of instanceof when the right-hand side is a function. This method implements the default behavior of the instanceof operator (the same algorithm when constructor has no [Symbol.hasInstance]() method).
Unlike most methods, the Function.prototype[Symbol.hasInstance]() property is non-configurable and non-writable. This is a security feature to prevent the underlying target function of a bound function from being obtainable. See this Stack Overflow answer for an example.ExamplesReverting to default instanceof behaviorYou would rarely need to call this method directly. Instead, this method is called by the instanceof operator. You should expect the two results to usually be equivalent.
jsclass Foo {}
const foo = new Foo();
console.log(foo instanceof Foo === Foo[Symbol.hasInstance](foo)); // true

You may want to use this method if you want to invoke the default instanceof behavior, but you don't know if a constructor has a overridden [Symbol.hasInstance]() method.
jsclass Foo {
  static [Symbol.hasInstance](value) {
    // A custom implementation
    return false;
  }
}

const foo = new Foo();
console.log(foo instanceof Foo); // false
console.log(Function.prototype[Symbol.hasInstance].call(Foo, foo)); // true
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-function.prototype-%symbol.hasinstance%Browser compatibilitySee also
instanceof
Symbol.hasInstance
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Nov 22, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nFunction: displayName 
Non-standard: This feature is non-standard and is not on a standards track. Do not use it on production sites facing the Web: it will not work for every user. There may also be large incompatibilities between implementations and the behavior may change in the future.
The optional displayName property of a Function instance specifies the display name of the function.ValueThe displayName property is not initially present on any function — it's added by the code authors. For the purpose of display, it should be a string.DescriptionThe displayName property, if present, may be preferred by consoles and profilers over the name property to be displayed as the name of a function.
Among browsers, only the Firefox console utilizes this property. React devtools also use the displayName property when displaying the component tree.
Firefox does some basic attempts to decode the displayName that's possibly generated by the anonymous JavaScript functions naming convention algorithm. The following patterns are detected:

If displayName ends with a sequence of alphanumeric characters, _, and $, the longest such suffix is displayed.
If displayName ends with a sequence of []-enclosed characters, that sequence is displayed without the square brackets.
If displayName ends with a sequence of alphanumeric characters and _ followed by some /, ., or <, the sequence is returned without the trailing /, ., or < characters.
If displayName ends with a sequence of alphanumeric characters and _ followed by (^), the sequence is displayed without the (^).

If none of the above patterns match, the entire displayName is displayed.ExamplesSetting a displayNameBy entering the following in a Firefox console, it should display as something like function MyFunction():
jsconst a = function () {};
a.displayName = "MyFunction";

a; // function MyFunction()
Changing displayName dynamicallyYou can dynamically change the displayName of a function:
jsconst object = {
  // anonymous
  someMethod: function someMethod(value) {
    someMethod.displayName = `someMethod (${value})`;
  },
};

console.log(object.someMethod.displayName); // undefined

object.someMethod("123");
console.log(object.someMethod.displayName); // "someMethod (123)"
Cleaning of displayNameFirefox devtools would clean up a few common patterns in the displayName property before displaying it.
jsfunction foo() {}

function testName(name) {
  foo.displayName = name;
  console.log(foo);
}

testName("$foo$"); // function $foo$()
testName("foo bar"); // function bar()
testName("Foo.prototype.add"); // function add()
testName("foo ."); // function foo .()
testName("foo <"); // function foo <()
testName("foo?"); // function foo?()
testName("foo()"); // function foo()()

testName("[...]"); // function ...()
testName("foo<"); // function foo()
testName("foo..."); // function foo()
testName("foo(^)"); // function foo()
SpecificationsNot part of any standard.Browser compatibilitySee also
Function.prototype.name\n\nFunction: displayName 
Non-standard: This feature is non-standard and is not on a standards track. Do not use it on production sites facing the Web: it will not work for every user. There may also be large incompatibilities between implementations and the behavior may change in the future.
The optional displayName property of a Function instance specifies the display name of the function.ValueThe displayName property is not initially present on any function — it's added by the code authors. For the purpose of display, it should be a string.DescriptionThe displayName property, if present, may be preferred by consoles and profilers over the name property to be displayed as the name of a function.
Among browsers, only the Firefox console utilizes this property. React devtools also use the displayName property when displaying the component tree.
Firefox does some basic attempts to decode the displayName that's possibly generated by the anonymous JavaScript functions naming convention algorithm. The following patterns are detected:

If displayName ends with a sequence of alphanumeric characters, _, and $, the longest such suffix is displayed.
If displayName ends with a sequence of []-enclosed characters, that sequence is displayed without the square brackets.
If displayName ends with a sequence of alphanumeric characters and _ followed by some /, ., or <, the sequence is returned without the trailing /, ., or < characters.
If displayName ends with a sequence of alphanumeric characters and _ followed by (^), the sequence is displayed without the (^).

If none of the above patterns match, the entire displayName is displayed.ExamplesSetting a displayNameBy entering the following in a Firefox console, it should display as something like function MyFunction():
jsconst a = function () {};
a.displayName = "MyFunction";

a; // function MyFunction()
Changing displayName dynamicallyYou can dynamically change the displayName of a function:
jsconst object = {
  // anonymous
  someMethod: function someMethod(value) {
    someMethod.displayName = `someMethod (${value})`;
  },
};

console.log(object.someMethod.displayName); // undefined

object.someMethod("123");
console.log(object.someMethod.displayName); // "someMethod (123)"
Cleaning of displayNameFirefox devtools would clean up a few common patterns in the displayName property before displaying it.
jsfunction foo() {}

function testName(name) {
  foo.displayName = name;
  console.log(foo);
}

testName("$foo$"); // function $foo$()
testName("foo bar"); // function bar()
testName("Foo.prototype.add"); // function add()
testName("foo ."); // function foo .()
testName("foo <"); // function foo <()
testName("foo?"); // function foo?()
testName("foo()"); // function foo()()

testName("[...]"); // function ...()
testName("foo<"); // function foo()
testName("foo..."); // function foo()
testName("foo(^)"); // function foo()
SpecificationsNot part of any standard.Browser compatibilitySee also
Function.prototype.name
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jul 30, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nFunction: displayName 
Non-standard: This feature is non-standard and is not on a standards track. Do not use it on production sites facing the Web: it will not work for every user. There may also be large incompatibilities between implementations and the behavior may change in the future.
The optional displayName property of a Function instance specifies the display name of the function.ValueThe displayName property is not initially present on any function — it's added by the code authors. For the purpose of display, it should be a string.DescriptionThe displayName property, if present, may be preferred by consoles and profilers over the name property to be displayed as the name of a function.
Among browsers, only the Firefox console utilizes this property. React devtools also use the displayName property when displaying the component tree.
Firefox does some basic attempts to decode the displayName that's possibly generated by the anonymous JavaScript functions naming convention algorithm. The following patterns are detected:

If displayName ends with a sequence of alphanumeric characters, _, and $, the longest such suffix is displayed.
If displayName ends with a sequence of []-enclosed characters, that sequence is displayed without the square brackets.
If displayName ends with a sequence of alphanumeric characters and _ followed by some /, ., or <, the sequence is returned without the trailing /, ., or < characters.
If displayName ends with a sequence of alphanumeric characters and _ followed by (^), the sequence is displayed without the (^).

If none of the above patterns match, the entire displayName is displayed.ExamplesSetting a displayNameBy entering the following in a Firefox console, it should display as something like function MyFunction():
jsconst a = function () {};
a.displayName = "MyFunction";

a; // function MyFunction()
Changing displayName dynamicallyYou can dynamically change the displayName of a function:
jsconst object = {
  // anonymous
  someMethod: function someMethod(value) {
    someMethod.displayName = `someMethod (${value})`;
  },
};

console.log(object.someMethod.displayName); // undefined

object.someMethod("123");
console.log(object.someMethod.displayName); // "someMethod (123)"
Cleaning of displayNameFirefox devtools would clean up a few common patterns in the displayName property before displaying it.
jsfunction foo() {}

function testName(name) {
  foo.displayName = name;
  console.log(foo);
}

testName("$foo$"); // function $foo$()
testName("foo bar"); // function bar()
testName("Foo.prototype.add"); // function add()
testName("foo ."); // function foo .()
testName("foo <"); // function foo <()
testName("foo?"); // function foo?()
testName("foo()"); // function foo()()

testName("[...]"); // function ...()
testName("foo<"); // function foo()
testName("foo..."); // function foo()
testName("foo(^)"); // function foo()
SpecificationsNot part of any standard.Browser compatibilitySee also
Function.prototype.name
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jul 30, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nFunction: lengthBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe length data property of a Function instance indicates the number of parameters expected by the function.Try it
function func1() {}

function func2(a, b) {}

console.log(func1.length);
// Expected output: 0

console.log(func2.length);
// Expected output: 2
ValueA number.
Property attributes of Function: lengthWritablenoEnumerablenoConfigurableyesDescriptionA Function object's length property indicates how many arguments the function expects, i.e., the number of formal parameters:

Only parameters before the first one with a default value are counted.
A destructuring pattern counts as a single parameter.
The rest parameter is excluded.

By contrast, arguments.length is local to a function and provides the number of arguments actually passed to the function.
The Function constructor is itself a Function object. Its length data property has a value of 1.
Due to historical reasons, Function.prototype is a callable itself. The length property of Function.prototype has a value of 0.ExamplesUsing function lengthjsconsole.log(Function.length); // 1

console.log((() => {}).length); // 0
console.log(((a) => {}).length); // 1
console.log(((a, b) => {}).length); // 2 etc.

console.log(((...args) => {}).length);
// 0, rest parameter is not counted

console.log(((a, b = 1, c) => {}).length);
// 1, only parameters before the first one with
// a default value are counted

console.log((({ a, b }, [c, d]) => {}).length);
// 2, destructuring patterns each count as
// a single parameter
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-function-instances-lengthBrowser compatibilitySee also
Function\n\nFunction: lengthBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe length data property of a Function instance indicates the number of parameters expected by the function.Try it
function func1() {}

function func2(a, b) {}

console.log(func1.length);
// Expected output: 0

console.log(func2.length);
// Expected output: 2
ValueA number.
Property attributes of Function: lengthWritablenoEnumerablenoConfigurableyesDescriptionA Function object's length property indicates how many arguments the function expects, i.e., the number of formal parameters:

Only parameters before the first one with a default value are counted.
A destructuring pattern counts as a single parameter.
The rest parameter is excluded.

By contrast, arguments.length is local to a function and provides the number of arguments actually passed to the function.
The Function constructor is itself a Function object. Its length data property has a value of 1.
Due to historical reasons, Function.prototype is a callable itself. The length property of Function.prototype has a value of 0.ExamplesUsing function lengthjsconsole.log(Function.length); // 1

console.log((() => {}).length); // 0
console.log(((a) => {}).length); // 1
console.log(((a, b) => {}).length); // 2 etc.

console.log(((...args) => {}).length);
// 0, rest parameter is not counted

console.log(((a, b = 1, c) => {}).length);
// 1, only parameters before the first one with
// a default value are counted

console.log((({ a, b }, [c, d]) => {}).length);
// 2, destructuring patterns each count as
// a single parameter
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-function-instances-lengthBrowser compatibilitySee also
Function
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nFunction: lengthBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe length data property of a Function instance indicates the number of parameters expected by the function.Try it
function func1() {}

function func2(a, b) {}

console.log(func1.length);
// Expected output: 0

console.log(func2.length);
// Expected output: 2
ValueA number.
Property attributes of Function: lengthWritablenoEnumerablenoConfigurableyesDescriptionA Function object's length property indicates how many arguments the function expects, i.e., the number of formal parameters:

Only parameters before the first one with a default value are counted.
A destructuring pattern counts as a single parameter.
The rest parameter is excluded.

By contrast, arguments.length is local to a function and provides the number of arguments actually passed to the function.
The Function constructor is itself a Function object. Its length data property has a value of 1.
Due to historical reasons, Function.prototype is a callable itself. The length property of Function.prototype has a value of 0.ExamplesUsing function lengthjsconsole.log(Function.length); // 1

console.log((() => {}).length); // 0
console.log(((a) => {}).length); // 1
console.log(((a, b) => {}).length); // 2 etc.

console.log(((...args) => {}).length);
// 0, rest parameter is not counted

console.log(((a, b = 1, c) => {}).length);
// 1, only parameters before the first one with
// a default value are counted

console.log((({ a, b }, [c, d]) => {}).length);
// 2, destructuring patterns each count as
// a single parameter
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-function-instances-lengthBrowser compatibilitySee also
Function
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nFunction: nameBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe name data property of a Function instance indicates the function's name as specified when it was created, or it may be either anonymous or '' (an empty string) for functions created anonymously.Try it
const func1 = function () {};

const object = {
  func2: function () {},
};

console.log(func1.name);
// Expected output: "func1"

console.log(object.func2.name);
// Expected output: "func2"
ValueA string.
Property attributes of Function: nameWritablenoEnumerablenoConfigurableyes

Note:
In non-standard, pre-ES2015 implementations the configurable attribute was false as well.
DescriptionThe function's name property can be used to identify the function in debugging tools or error messages. It has no semantic significance to the language itself.
The name property is read-only and cannot be changed by the assignment operator:
jsfunction someFunction() {}

someFunction.name = "otherFunction";
console.log(someFunction.name); // someFunction

To change it, use Object.defineProperty().
The name property is typically inferred from how the function is defined. In the following sections, we will describe the various ways in which it can be inferred.Function declarationThe name property returns the name of a function declaration.
jsfunction doSomething() {}
doSomething.name; // "doSomething"
Default-exported function declarationAn export default declaration exports the function as a declaration instead of an expression. If the declaration is anonymous, the name is "default".
js// -- someModule.js --
export default function () {}

// -- main.js --
import someModule from "./someModule.js";

someModule.name; // "default"
Function constructorFunctions created with the Function() constructor have name "anonymous".
jsnew Function().name; // "anonymous"
Function expressionIf the function expression is named, that name is used as the name property.
jsconst someFunction = function someFunctionName() {};
someFunction.name; // "someFunctionName"

Anonymous function expressions created using the keyword function or arrow functions would have "" (an empty string) as their name.
js(function () {}).name; // ""
(() => {}).name; // ""

However, such cases are rare — usually, in order to refer to the expression elsewhere, the function expression is attached to an identifier when it's created (such as in a variable declaration). In such cases, the name can be inferred, as the following few subsections demonstrate.
One practical case where the name cannot be inferred is a function returned from another function:
jsfunction getFoo() {
  return () => {};
}
getFoo().name; // ""
Variable declaration and methodVariables and methods can infer the name of an anonymous function from its syntactic position.
jsconst f = function () {};
const object = {
  someMethod: function () {},
};

console.log(f.name); // "f"
console.log(object.someMethod.name); // "someMethod"

The same applies to assignment:
jslet f;
f = () => {};
f.name; // "f"
Initializer and default valueFunctions in initializers (default values) of destructuring, default parameters, class fields, etc., will inherit the name of the bound identifier as their name.
jsconst [f = () => {}] = [];
f.name; // "f"

const { someMethod: m = () => {} } = {};
m.name; // "m"

function foo(f = () => {}) {
  console.log(f.name);
}
foo(); // "f"

class Foo {
  static someMethod = () => {};
}
Foo.someMethod.name; // someMethod
Shorthand methodjsconst o = {
  foo() {},
};
o.foo.name; // "foo";
Bound functionFunction.prototype.bind() produces a function whose name is "bound " plus the function name.
jsfunction foo() {}
foo.bind({}).name; // "bound foo"
Getter and setterWhen using get and set accessor properties, "get" or "set" will appear in the function name.
jsconst o = {
  get foo() {},
  set foo(x) {},
};

const descriptor = Object.getOwnPropertyDescriptor(o, "foo");
descriptor.get.name; // "get foo"
descriptor.set.name; // "set foo";
ClassA class's name follows the same algorithm as function declarations and expressions.
jsclass Foo {}
Foo.name; // "Foo"


Warning:
JavaScript will set the function's name property only if a function does not have an own property called name. However, classes' static members will be set as own properties of the class constructor function, and thus prevent the built-in name from being applied. See an example below.
Symbol as function nameIf a Symbol is used a function name and the symbol has a description, the method's name is the description in square brackets.
jsconst sym1 = Symbol("foo");
const sym2 = Symbol();

const o = {
  [sym1]() {},
  [sym2]() {},
};

o[sym1].name; // "[foo]"
o[sym2].name; // "[]"
Private propertyPrivate fields and private methods have the hash (#) as part of their names.
jsclass Foo {
  #field = () => {};
  #method() {}
  getNames() {
    console.log(this.#field.name);
    console.log(this.#method.name);
  }
}

new Foo().getNames();
// "#field"
// "#method"
ExamplesTelling the constructor name of an objectYou can use obj.constructor.name to check the "class" of an object.
jsfunction Foo() {} // Or: class Foo {}

const fooInstance = new Foo();
console.log(fooInstance.constructor.name); // "Foo"

However, because static members will become own properties of the class, we can't obtain the class name for virtually any class with a static method property name():
jsclass Foo {
  constructor() {}
  static name() {}
}

With a static name() method Foo.name no longer holds the actual class name but a reference to the name() function object. Trying to obtain the class of fooInstance via fooInstance.constructor.name won't give us the class name at all, but instead a reference to the static class method. Example:
jsconst fooInstance = new Foo();
console.log(fooInstance.constructor.name); // ƒ name() {}

Due to the existence of static fields, name may not be a function either.
jsclass Foo {
  static name = 123;
}
console.log(new Foo().constructor.name); // 123

If a class has a static property called name, it will also become writable. The built-in definition in the absence of a custom static definition is read-only:
jsFoo.name = "Hello";
console.log(Foo.name); // "Hello" if class Foo has a static "name" property, but "Foo" if not.

Therefore you may not rely on the built-in name property to always hold a class's name.JavaScript compressors and minifiers
Warning:
Be careful when using the name property with source-code transformations, such as those carried out by JavaScript compressors (minifiers) or obfuscators. These tools are often used as part of a JavaScript build pipeline to reduce the size of a program prior to deploying it to production. Such transformations often change a function's name at build time.

Source code such as:
jsfunction Foo() {}
const foo = new Foo();

if (foo.constructor.name === "Foo") {
  console.log("'foo' is an instance of 'Foo'");
} else {
  console.log("Oops!");
}

may be compressed to:
jsfunction a() {}
const b = new a();
if (b.constructor.name === "Foo") {
  console.log("'foo' is an instance of 'Foo'");
} else {
  console.log("Oops!");
}

In the uncompressed version, the program runs into the truthy branch and logs "'foo' is an instance of 'Foo'" — whereas, in the compressed version it behaves differently, and runs into the else branch. If you rely on the name property, like in the example above, make sure your build pipeline doesn't change function names, or don't assume a function has a particular name.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-function-instances-nameBrowser compatibilitySee also
Polyfill for Function: name in core-js
es-shims polyfill of Function.prototype.name
Function\n\nFunction: nameBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe name data property of a Function instance indicates the function's name as specified when it was created, or it may be either anonymous or '' (an empty string) for functions created anonymously.Try it
const func1 = function () {};

const object = {
  func2: function () {},
};

console.log(func1.name);
// Expected output: "func1"

console.log(object.func2.name);
// Expected output: "func2"
ValueA string.
Property attributes of Function: nameWritablenoEnumerablenoConfigurableyes

Note:
In non-standard, pre-ES2015 implementations the configurable attribute was false as well.
DescriptionThe function's name property can be used to identify the function in debugging tools or error messages. It has no semantic significance to the language itself.
The name property is read-only and cannot be changed by the assignment operator:
jsfunction someFunction() {}

someFunction.name = "otherFunction";
console.log(someFunction.name); // someFunction

To change it, use Object.defineProperty().
The name property is typically inferred from how the function is defined. In the following sections, we will describe the various ways in which it can be inferred.Function declarationThe name property returns the name of a function declaration.
jsfunction doSomething() {}
doSomething.name; // "doSomething"
Default-exported function declarationAn export default declaration exports the function as a declaration instead of an expression. If the declaration is anonymous, the name is "default".
js// -- someModule.js --
export default function () {}

// -- main.js --
import someModule from "./someModule.js";

someModule.name; // "default"
Function constructorFunctions created with the Function() constructor have name "anonymous".
jsnew Function().name; // "anonymous"
Function expressionIf the function expression is named, that name is used as the name property.
jsconst someFunction = function someFunctionName() {};
someFunction.name; // "someFunctionName"

Anonymous function expressions created using the keyword function or arrow functions would have "" (an empty string) as their name.
js(function () {}).name; // ""
(() => {}).name; // ""

However, such cases are rare — usually, in order to refer to the expression elsewhere, the function expression is attached to an identifier when it's created (such as in a variable declaration). In such cases, the name can be inferred, as the following few subsections demonstrate.
One practical case where the name cannot be inferred is a function returned from another function:
jsfunction getFoo() {
  return () => {};
}
getFoo().name; // ""
Variable declaration and methodVariables and methods can infer the name of an anonymous function from its syntactic position.
jsconst f = function () {};
const object = {
  someMethod: function () {},
};

console.log(f.name); // "f"
console.log(object.someMethod.name); // "someMethod"

The same applies to assignment:
jslet f;
f = () => {};
f.name; // "f"
Initializer and default valueFunctions in initializers (default values) of destructuring, default parameters, class fields, etc., will inherit the name of the bound identifier as their name.
jsconst [f = () => {}] = [];
f.name; // "f"

const { someMethod: m = () => {} } = {};
m.name; // "m"

function foo(f = () => {}) {
  console.log(f.name);
}
foo(); // "f"

class Foo {
  static someMethod = () => {};
}
Foo.someMethod.name; // someMethod
Shorthand methodjsconst o = {
  foo() {},
};
o.foo.name; // "foo";
Bound functionFunction.prototype.bind() produces a function whose name is "bound " plus the function name.
jsfunction foo() {}
foo.bind({}).name; // "bound foo"
Getter and setterWhen using get and set accessor properties, "get" or "set" will appear in the function name.
jsconst o = {
  get foo() {},
  set foo(x) {},
};

const descriptor = Object.getOwnPropertyDescriptor(o, "foo");
descriptor.get.name; // "get foo"
descriptor.set.name; // "set foo";
ClassA class's name follows the same algorithm as function declarations and expressions.
jsclass Foo {}
Foo.name; // "Foo"


Warning:
JavaScript will set the function's name property only if a function does not have an own property called name. However, classes' static members will be set as own properties of the class constructor function, and thus prevent the built-in name from being applied. See an example below.
Symbol as function nameIf a Symbol is used a function name and the symbol has a description, the method's name is the description in square brackets.
jsconst sym1 = Symbol("foo");
const sym2 = Symbol();

const o = {
  [sym1]() {},
  [sym2]() {},
};

o[sym1].name; // "[foo]"
o[sym2].name; // "[]"
Private propertyPrivate fields and private methods have the hash (#) as part of their names.
jsclass Foo {
  #field = () => {};
  #method() {}
  getNames() {
    console.log(this.#field.name);
    console.log(this.#method.name);
  }
}

new Foo().getNames();
// "#field"
// "#method"
ExamplesTelling the constructor name of an objectYou can use obj.constructor.name to check the "class" of an object.
jsfunction Foo() {} // Or: class Foo {}

const fooInstance = new Foo();
console.log(fooInstance.constructor.name); // "Foo"

However, because static members will become own properties of the class, we can't obtain the class name for virtually any class with a static method property name():
jsclass Foo {
  constructor() {}
  static name() {}
}

With a static name() method Foo.name no longer holds the actual class name but a reference to the name() function object. Trying to obtain the class of fooInstance via fooInstance.constructor.name won't give us the class name at all, but instead a reference to the static class method. Example:
jsconst fooInstance = new Foo();
console.log(fooInstance.constructor.name); // ƒ name() {}

Due to the existence of static fields, name may not be a function either.
jsclass Foo {
  static name = 123;
}
console.log(new Foo().constructor.name); // 123

If a class has a static property called name, it will also become writable. The built-in definition in the absence of a custom static definition is read-only:
jsFoo.name = "Hello";
console.log(Foo.name); // "Hello" if class Foo has a static "name" property, but "Foo" if not.

Therefore you may not rely on the built-in name property to always hold a class's name.JavaScript compressors and minifiers
Warning:
Be careful when using the name property with source-code transformations, such as those carried out by JavaScript compressors (minifiers) or obfuscators. These tools are often used as part of a JavaScript build pipeline to reduce the size of a program prior to deploying it to production. Such transformations often change a function's name at build time.

Source code such as:
jsfunction Foo() {}
const foo = new Foo();

if (foo.constructor.name === "Foo") {
  console.log("'foo' is an instance of 'Foo'");
} else {
  console.log("Oops!");
}

may be compressed to:
jsfunction a() {}
const b = new a();
if (b.constructor.name === "Foo") {
  console.log("'foo' is an instance of 'Foo'");
} else {
  console.log("Oops!");
}

In the uncompressed version, the program runs into the truthy branch and logs "'foo' is an instance of 'Foo'" — whereas, in the compressed version it behaves differently, and runs into the else branch. If you rely on the name property, like in the example above, make sure your build pipeline doesn't change function names, or don't assume a function has a particular name.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-function-instances-nameBrowser compatibilitySee also
Polyfill for Function: name in core-js
es-shims polyfill of Function.prototype.name
Function
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nFunction: nameBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe name data property of a Function instance indicates the function's name as specified when it was created, or it may be either anonymous or '' (an empty string) for functions created anonymously.Try it
const func1 = function () {};

const object = {
  func2: function () {},
};

console.log(func1.name);
// Expected output: "func1"

console.log(object.func2.name);
// Expected output: "func2"
ValueA string.
Property attributes of Function: nameWritablenoEnumerablenoConfigurableyes

Note:
In non-standard, pre-ES2015 implementations the configurable attribute was false as well.
DescriptionThe function's name property can be used to identify the function in debugging tools or error messages. It has no semantic significance to the language itself.
The name property is read-only and cannot be changed by the assignment operator:
jsfunction someFunction() {}

someFunction.name = "otherFunction";
console.log(someFunction.name); // someFunction

To change it, use Object.defineProperty().
The name property is typically inferred from how the function is defined. In the following sections, we will describe the various ways in which it can be inferred.Function declarationThe name property returns the name of a function declaration.
jsfunction doSomething() {}
doSomething.name; // "doSomething"
Default-exported function declarationAn export default declaration exports the function as a declaration instead of an expression. If the declaration is anonymous, the name is "default".
js// -- someModule.js --
export default function () {}

// -- main.js --
import someModule from "./someModule.js";

someModule.name; // "default"
Function constructorFunctions created with the Function() constructor have name "anonymous".
jsnew Function().name; // "anonymous"
Function expressionIf the function expression is named, that name is used as the name property.
jsconst someFunction = function someFunctionName() {};
someFunction.name; // "someFunctionName"

Anonymous function expressions created using the keyword function or arrow functions would have "" (an empty string) as their name.
js(function () {}).name; // ""
(() => {}).name; // ""

However, such cases are rare — usually, in order to refer to the expression elsewhere, the function expression is attached to an identifier when it's created (such as in a variable declaration). In such cases, the name can be inferred, as the following few subsections demonstrate.
One practical case where the name cannot be inferred is a function returned from another function:
jsfunction getFoo() {
  return () => {};
}
getFoo().name; // ""
Variable declaration and methodVariables and methods can infer the name of an anonymous function from its syntactic position.
jsconst f = function () {};
const object = {
  someMethod: function () {},
};

console.log(f.name); // "f"
console.log(object.someMethod.name); // "someMethod"

The same applies to assignment:
jslet f;
f = () => {};
f.name; // "f"
Initializer and default valueFunctions in initializers (default values) of destructuring, default parameters, class fields, etc., will inherit the name of the bound identifier as their name.
jsconst [f = () => {}] = [];
f.name; // "f"

const { someMethod: m = () => {} } = {};
m.name; // "m"

function foo(f = () => {}) {
  console.log(f.name);
}
foo(); // "f"

class Foo {
  static someMethod = () => {};
}
Foo.someMethod.name; // someMethod
Shorthand methodjsconst o = {
  foo() {},
};
o.foo.name; // "foo";
Bound functionFunction.prototype.bind() produces a function whose name is "bound " plus the function name.
jsfunction foo() {}
foo.bind({}).name; // "bound foo"
Getter and setterWhen using get and set accessor properties, "get" or "set" will appear in the function name.
jsconst o = {
  get foo() {},
  set foo(x) {},
};

const descriptor = Object.getOwnPropertyDescriptor(o, "foo");
descriptor.get.name; // "get foo"
descriptor.set.name; // "set foo";
ClassA class's name follows the same algorithm as function declarations and expressions.
jsclass Foo {}
Foo.name; // "Foo"


Warning:
JavaScript will set the function's name property only if a function does not have an own property called name. However, classes' static members will be set as own properties of the class constructor function, and thus prevent the built-in name from being applied. See an example below.
Symbol as function nameIf a Symbol is used a function name and the symbol has a description, the method's name is the description in square brackets.
jsconst sym1 = Symbol("foo");
const sym2 = Symbol();

const o = {
  [sym1]() {},
  [sym2]() {},
};

o[sym1].name; // "[foo]"
o[sym2].name; // "[]"
Private propertyPrivate fields and private methods have the hash (#) as part of their names.
jsclass Foo {
  #field = () => {};
  #method() {}
  getNames() {
    console.log(this.#field.name);
    console.log(this.#method.name);
  }
}

new Foo().getNames();
// "#field"
// "#method"
ExamplesTelling the constructor name of an objectYou can use obj.constructor.name to check the "class" of an object.
jsfunction Foo() {} // Or: class Foo {}

const fooInstance = new Foo();
console.log(fooInstance.constructor.name); // "Foo"

However, because static members will become own properties of the class, we can't obtain the class name for virtually any class with a static method property name():
jsclass Foo {
  constructor() {}
  static name() {}
}

With a static name() method Foo.name no longer holds the actual class name but a reference to the name() function object. Trying to obtain the class of fooInstance via fooInstance.constructor.name won't give us the class name at all, but instead a reference to the static class method. Example:
jsconst fooInstance = new Foo();
console.log(fooInstance.constructor.name); // ƒ name() {}

Due to the existence of static fields, name may not be a function either.
jsclass Foo {
  static name = 123;
}
console.log(new Foo().constructor.name); // 123

If a class has a static property called name, it will also become writable. The built-in definition in the absence of a custom static definition is read-only:
jsFoo.name = "Hello";
console.log(Foo.name); // "Hello" if class Foo has a static "name" property, but "Foo" if not.

Therefore you may not rely on the built-in name property to always hold a class's name.JavaScript compressors and minifiers
Warning:
Be careful when using the name property with source-code transformations, such as those carried out by JavaScript compressors (minifiers) or obfuscators. These tools are often used as part of a JavaScript build pipeline to reduce the size of a program prior to deploying it to production. Such transformations often change a function's name at build time.

Source code such as:
jsfunction Foo() {}
const foo = new Foo();

if (foo.constructor.name === "Foo") {
  console.log("'foo' is an instance of 'Foo'");
} else {
  console.log("Oops!");
}

may be compressed to:
jsfunction a() {}
const b = new a();
if (b.constructor.name === "Foo") {
  console.log("'foo' is an instance of 'Foo'");
} else {
  console.log("Oops!");
}

In the uncompressed version, the program runs into the truthy branch and logs "'foo' is an instance of 'Foo'" — whereas, in the compressed version it behaves differently, and runs into the else branch. If you rely on the name property, like in the example above, make sure your build pipeline doesn't change function names, or don't assume a function has a particular name.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-function-instances-nameBrowser compatibilitySee also
Polyfill for Function: name in core-js
es-shims polyfill of Function.prototype.name
Function
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nFunction: prototypeThe prototype data property of a Function instance is used when the function is used as a constructor with the new operator. It will become the new object's prototype.

Note:
Not all Function objects have the prototype property — see description.
ValueAn object.
Property attributes of Function: prototypeWritableyesEnumerablenoConfigurableno

Note: Classes are a type of function, so most of the description here applies to the prototype property of classes too. The only salient difference is that the prototype property of a class is not writable.
DescriptionWhen a function is called with new, the constructor's prototype property will become the resulting object's prototype.
jsfunction Ctor() {}
const inst = new Ctor();
console.log(Object.getPrototypeOf(inst) === Ctor.prototype); // true

You can read Inheritance and the prototype chain for more information about the interactions between a constructor function's prototype property and the resulting object's prototype.
A function having a prototype property is not sufficient for it to be eligible as a constructor. Generator functions have a prototype property, but cannot be called with new:
jsasync function* asyncGeneratorFunction() {}
function* generatorFunction() {}

Instead, generator functions' prototype property is used when they are called without new. The prototype property will become the returned Generator object's prototype.
In addition, some functions may have a prototype but throw unconditionally when called with new. For example, the Symbol() and BigInt() functions throw when called with new, because Symbol.prototype and BigInt.prototype are only intended to provide methods for the primitive values, but the wrapper objects should not be directly constructed.
The following functions do not have prototype, and are therefore ineligible as constructors, even if a prototype property is later manually assigned:
jsconst method = { foo() {} }.foo;
const arrowFunction = () => {};
async function asyncFunction() {}

The following are valid constructors that have prototype:
jsclass Class {}
function fn() {}

A bound function does not have a prototype property, but may be constructable. When it's constructed, the target function is constructed instead, and if the target function is constructable, it would return a normal instance.
jsconst boundFunction = function () {}.bind(null);

A function's prototype property, by default, is a plain object with one property: constructor, which is a reference to the function itself. The constructor property is writable, non-enumerable, and configurable.
If the prototype of a function is reassigned with something other than an Object, when the function is called with new, the returned object's prototype would be Object.prototype instead. (In other words, new ignores the prototype property and constructs a plain object.)
jsfunction Ctor() {}
Ctor.prototype = 3;
console.log(Object.getPrototypeOf(new Ctor()) === Object.prototype); // true
ExamplesChanging the prototype of all instances by mutating the prototype propertyjsfunction Ctor() {}
const p1 = new Ctor();
const p2 = new Ctor();
Ctor.prototype.prop = 1;
console.log(p1.prop); // 1
console.log(p2.prop); // 1
Adding a non-method property to a class's prototype propertyClass fields add properties to each instance. Class methods declare function properties on the prototype. However, there's no way to add a non-function property to the prototype. In case you want to share static data between all instances (for example, Error.prototype.name is the same between all error instances), you can manually assign it on the prototype of a class.
jsclass Dog {
  constructor(name) {
    this.name = name;
  }
}

Dog.prototype.species = "dog";

console.log(new Dog("Jack").species); // "dog"

This can be made more ergonomic using static initialization blocks, which are called when the class is initialized.
jsclass Dog {
  static {
    Dog.prototype.species = "dog";
  }
  constructor(name) {
    this.name = name;
  }
}

console.log(new Dog("Jack").species); // "dog"
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-function-instances-prototypeSee also
Function
Inheritance and the prototype chain\n\nFunction: prototypeThe prototype data property of a Function instance is used when the function is used as a constructor with the new operator. It will become the new object's prototype.

Note:
Not all Function objects have the prototype property — see description.
ValueAn object.
Property attributes of Function: prototypeWritableyesEnumerablenoConfigurableno

Note: Classes are a type of function, so most of the description here applies to the prototype property of classes too. The only salient difference is that the prototype property of a class is not writable.
DescriptionWhen a function is called with new, the constructor's prototype property will become the resulting object's prototype.
jsfunction Ctor() {}
const inst = new Ctor();
console.log(Object.getPrototypeOf(inst) === Ctor.prototype); // true

You can read Inheritance and the prototype chain for more information about the interactions between a constructor function's prototype property and the resulting object's prototype.
A function having a prototype property is not sufficient for it to be eligible as a constructor. Generator functions have a prototype property, but cannot be called with new:
jsasync function* asyncGeneratorFunction() {}
function* generatorFunction() {}

Instead, generator functions' prototype property is used when they are called without new. The prototype property will become the returned Generator object's prototype.
In addition, some functions may have a prototype but throw unconditionally when called with new. For example, the Symbol() and BigInt() functions throw when called with new, because Symbol.prototype and BigInt.prototype are only intended to provide methods for the primitive values, but the wrapper objects should not be directly constructed.
The following functions do not have prototype, and are therefore ineligible as constructors, even if a prototype property is later manually assigned:
jsconst method = { foo() {} }.foo;
const arrowFunction = () => {};
async function asyncFunction() {}

The following are valid constructors that have prototype:
jsclass Class {}
function fn() {}

A bound function does not have a prototype property, but may be constructable. When it's constructed, the target function is constructed instead, and if the target function is constructable, it would return a normal instance.
jsconst boundFunction = function () {}.bind(null);

A function's prototype property, by default, is a plain object with one property: constructor, which is a reference to the function itself. The constructor property is writable, non-enumerable, and configurable.
If the prototype of a function is reassigned with something other than an Object, when the function is called with new, the returned object's prototype would be Object.prototype instead. (In other words, new ignores the prototype property and constructs a plain object.)
jsfunction Ctor() {}
Ctor.prototype = 3;
console.log(Object.getPrototypeOf(new Ctor()) === Object.prototype); // true
ExamplesChanging the prototype of all instances by mutating the prototype propertyjsfunction Ctor() {}
const p1 = new Ctor();
const p2 = new Ctor();
Ctor.prototype.prop = 1;
console.log(p1.prop); // 1
console.log(p2.prop); // 1
Adding a non-method property to a class's prototype propertyClass fields add properties to each instance. Class methods declare function properties on the prototype. However, there's no way to add a non-function property to the prototype. In case you want to share static data between all instances (for example, Error.prototype.name is the same between all error instances), you can manually assign it on the prototype of a class.
jsclass Dog {
  constructor(name) {
    this.name = name;
  }
}

Dog.prototype.species = "dog";

console.log(new Dog("Jack").species); // "dog"

This can be made more ergonomic using static initialization blocks, which are called when the class is initialized.
jsclass Dog {
  static {
    Dog.prototype.species = "dog";
  }
  constructor(name) {
    this.name = name;
  }
}

console.log(new Dog("Jack").species); // "dog"
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-function-instances-prototypeSee also
Function
Inheritance and the prototype chain
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nFunction: prototypeThe prototype data property of a Function instance is used when the function is used as a constructor with the new operator. It will become the new object's prototype.

Note:
Not all Function objects have the prototype property — see description.
ValueAn object.
Property attributes of Function: prototypeWritableyesEnumerablenoConfigurableno

Note: Classes are a type of function, so most of the description here applies to the prototype property of classes too. The only salient difference is that the prototype property of a class is not writable.
DescriptionWhen a function is called with new, the constructor's prototype property will become the resulting object's prototype.
jsfunction Ctor() {}
const inst = new Ctor();
console.log(Object.getPrototypeOf(inst) === Ctor.prototype); // true

You can read Inheritance and the prototype chain for more information about the interactions between a constructor function's prototype property and the resulting object's prototype.
A function having a prototype property is not sufficient for it to be eligible as a constructor. Generator functions have a prototype property, but cannot be called with new:
jsasync function* asyncGeneratorFunction() {}
function* generatorFunction() {}

Instead, generator functions' prototype property is used when they are called without new. The prototype property will become the returned Generator object's prototype.
In addition, some functions may have a prototype but throw unconditionally when called with new. For example, the Symbol() and BigInt() functions throw when called with new, because Symbol.prototype and BigInt.prototype are only intended to provide methods for the primitive values, but the wrapper objects should not be directly constructed.
The following functions do not have prototype, and are therefore ineligible as constructors, even if a prototype property is later manually assigned:
jsconst method = { foo() {} }.foo;
const arrowFunction = () => {};
async function asyncFunction() {}

The following are valid constructors that have prototype:
jsclass Class {}
function fn() {}

A bound function does not have a prototype property, but may be constructable. When it's constructed, the target function is constructed instead, and if the target function is constructable, it would return a normal instance.
jsconst boundFunction = function () {}.bind(null);

A function's prototype property, by default, is a plain object with one property: constructor, which is a reference to the function itself. The constructor property is writable, non-enumerable, and configurable.
If the prototype of a function is reassigned with something other than an Object, when the function is called with new, the returned object's prototype would be Object.prototype instead. (In other words, new ignores the prototype property and constructs a plain object.)
jsfunction Ctor() {}
Ctor.prototype = 3;
console.log(Object.getPrototypeOf(new Ctor()) === Object.prototype); // true
ExamplesChanging the prototype of all instances by mutating the prototype propertyjsfunction Ctor() {}
const p1 = new Ctor();
const p2 = new Ctor();
Ctor.prototype.prop = 1;
console.log(p1.prop); // 1
console.log(p2.prop); // 1
Adding a non-method property to a class's prototype propertyClass fields add properties to each instance. Class methods declare function properties on the prototype. However, there's no way to add a non-function property to the prototype. In case you want to share static data between all instances (for example, Error.prototype.name is the same between all error instances), you can manually assign it on the prototype of a class.
jsclass Dog {
  constructor(name) {
    this.name = name;
  }
}

Dog.prototype.species = "dog";

console.log(new Dog("Jack").species); // "dog"

This can be made more ergonomic using static initialization blocks, which are called when the class is initialized.
jsclass Dog {
  static {
    Dog.prototype.species = "dog";
  }
  constructor(name) {
    this.name = name;
  }
}

console.log(new Dog("Jack").species); // "dog"
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-function-instances-prototypeSee also
Function
Inheritance and the prototype chain
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nFunction.prototype.argumentsDeprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time.
Non-standard: This feature is non-standard and is not on a standards track. Do not use it on production sites facing the Web: it will not work for every user. There may also be large incompatibilities between implementations and the behavior may change in the future.

Note:
The arguments property of Function objects is deprecated. The recommended way to access the arguments object is to refer to the variable arguments available within functions.

The arguments accessor property of Function instances returns the arguments passed to this function. For strict, arrow, async, and generator functions, accessing the arguments property throws a TypeError.DescriptionThe value of arguments is an array-like object corresponding to the arguments passed to a function.
In the case of recursion, i.e., if function f appears several times on the call stack, the value of f.arguments represents the arguments corresponding to the most recent invocation of the function.
The value of the arguments property is normally null if there is no outstanding invocation of the function in progress (that is, the function has been called but has not yet returned).
Note that the only behavior specified by the ECMAScript specification is that Function.prototype has an initial arguments accessor that unconditionally throws a TypeError for any get or set request (known as a "poison pill accessor"), and that implementations are not allowed to change this semantic for any function except non-strict plain functions. The actual behavior of the arguments property, if it's anything other than throwing an error, is implementation-defined. For example, Chrome defines it as an own data property, while Firefox and Safari extend the initial poison-pill Function.prototype.arguments accessor to specially handle this values that are non-strict functions.
js(function f() {
  if (Object.hasOwn(f, "arguments")) {
    console.log(
      "arguments is an own property with descriptor",
      Object.getOwnPropertyDescriptor(f, "arguments"),
    );
  } else {
    console.log(
      "f doesn't have an own property named arguments. Trying to get f.[[Prototype]].arguments",
    );
    console.log(
      Object.getOwnPropertyDescriptor(
        Object.getPrototypeOf(f),
        "arguments",
      ).get.call(f),
    );
  }
})();

// In Chrome:
// arguments is an own property with descriptor {value: Arguments(0), writable: false, enumerable: false, configurable: false}

// In Firefox:
// f doesn't have an own property named arguments. Trying to get f.[[Prototype]].arguments
// Arguments { … }
ExamplesUsing the arguments propertyjsfunction f(n) {
  g(n - 1);
}

function g(n) {
  console.log(`before: ${g.arguments[0]}`);
  if (n > 0) {
    f(n);
  }
  console.log(`after: ${g.arguments[0]}`);
}

f(2);

console.log(`returned: ${g.arguments}`);

// Logs:
// before: 1
// before: 0
// after: 0
// after: 1
// returned: null
SpecificationsNot part of any standard.Browser compatibilitySee also
arguments
Functions\n\nFunction.prototype.argumentsDeprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time.
Non-standard: This feature is non-standard and is not on a standards track. Do not use it on production sites facing the Web: it will not work for every user. There may also be large incompatibilities between implementations and the behavior may change in the future.

Note:
The arguments property of Function objects is deprecated. The recommended way to access the arguments object is to refer to the variable arguments available within functions.

The arguments accessor property of Function instances returns the arguments passed to this function. For strict, arrow, async, and generator functions, accessing the arguments property throws a TypeError.DescriptionThe value of arguments is an array-like object corresponding to the arguments passed to a function.
In the case of recursion, i.e., if function f appears several times on the call stack, the value of f.arguments represents the arguments corresponding to the most recent invocation of the function.
The value of the arguments property is normally null if there is no outstanding invocation of the function in progress (that is, the function has been called but has not yet returned).
Note that the only behavior specified by the ECMAScript specification is that Function.prototype has an initial arguments accessor that unconditionally throws a TypeError for any get or set request (known as a "poison pill accessor"), and that implementations are not allowed to change this semantic for any function except non-strict plain functions. The actual behavior of the arguments property, if it's anything other than throwing an error, is implementation-defined. For example, Chrome defines it as an own data property, while Firefox and Safari extend the initial poison-pill Function.prototype.arguments accessor to specially handle this values that are non-strict functions.
js(function f() {
  if (Object.hasOwn(f, "arguments")) {
    console.log(
      "arguments is an own property with descriptor",
      Object.getOwnPropertyDescriptor(f, "arguments"),
    );
  } else {
    console.log(
      "f doesn't have an own property named arguments. Trying to get f.[[Prototype]].arguments",
    );
    console.log(
      Object.getOwnPropertyDescriptor(
        Object.getPrototypeOf(f),
        "arguments",
      ).get.call(f),
    );
  }
})();

// In Chrome:
// arguments is an own property with descriptor {value: Arguments(0), writable: false, enumerable: false, configurable: false}

// In Firefox:
// f doesn't have an own property named arguments. Trying to get f.[[Prototype]].arguments
// Arguments { … }
ExamplesUsing the arguments propertyjsfunction f(n) {
  g(n - 1);
}

function g(n) {
  console.log(`before: ${g.arguments[0]}`);
  if (n > 0) {
    f(n);
  }
  console.log(`after: ${g.arguments[0]}`);
}

f(2);

console.log(`returned: ${g.arguments}`);

// Logs:
// before: 1
// before: 0
// after: 0
// after: 1
// returned: null
SpecificationsNot part of any standard.Browser compatibilitySee also
arguments
Functions
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nFunction.prototype.argumentsDeprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time.
Non-standard: This feature is non-standard and is not on a standards track. Do not use it on production sites facing the Web: it will not work for every user. There may also be large incompatibilities between implementations and the behavior may change in the future.

Note:
The arguments property of Function objects is deprecated. The recommended way to access the arguments object is to refer to the variable arguments available within functions.

The arguments accessor property of Function instances returns the arguments passed to this function. For strict, arrow, async, and generator functions, accessing the arguments property throws a TypeError.DescriptionThe value of arguments is an array-like object corresponding to the arguments passed to a function.
In the case of recursion, i.e., if function f appears several times on the call stack, the value of f.arguments represents the arguments corresponding to the most recent invocation of the function.
The value of the arguments property is normally null if there is no outstanding invocation of the function in progress (that is, the function has been called but has not yet returned).
Note that the only behavior specified by the ECMAScript specification is that Function.prototype has an initial arguments accessor that unconditionally throws a TypeError for any get or set request (known as a "poison pill accessor"), and that implementations are not allowed to change this semantic for any function except non-strict plain functions. The actual behavior of the arguments property, if it's anything other than throwing an error, is implementation-defined. For example, Chrome defines it as an own data property, while Firefox and Safari extend the initial poison-pill Function.prototype.arguments accessor to specially handle this values that are non-strict functions.
js(function f() {
  if (Object.hasOwn(f, "arguments")) {
    console.log(
      "arguments is an own property with descriptor",
      Object.getOwnPropertyDescriptor(f, "arguments"),
    );
  } else {
    console.log(
      "f doesn't have an own property named arguments. Trying to get f.[[Prototype]].arguments",
    );
    console.log(
      Object.getOwnPropertyDescriptor(
        Object.getPrototypeOf(f),
        "arguments",
      ).get.call(f),
    );
  }
})();

// In Chrome:
// arguments is an own property with descriptor {value: Arguments(0), writable: false, enumerable: false, configurable: false}

// In Firefox:
// f doesn't have an own property named arguments. Trying to get f.[[Prototype]].arguments
// Arguments { … }
ExamplesUsing the arguments propertyjsfunction f(n) {
  g(n - 1);
}

function g(n) {
  console.log(`before: ${g.arguments[0]}`);
  if (n > 0) {
    f(n);
  }
  console.log(`after: ${g.arguments[0]}`);
}

f(2);

console.log(`returned: ${g.arguments}`);

// Logs:
// before: 1
// before: 0
// after: 0
// after: 1
// returned: null
SpecificationsNot part of any standard.Browser compatibilitySee also
arguments
Functions
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nFunction.prototype.callerNon-standard: This feature is non-standard and is not on a standards track. Do not use it on production sites facing the Web: it will not work for every user. There may also be large incompatibilities between implementations and the behavior may change in the future.
Deprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time.

Note:
In strict mode, accessing caller of a function throws an error — the API is removed with no replacement. This is to prevent code from being able to "walk the stack", which both poses security risks and severely limits the possibility of optimizations like inlining and tail-call optimization. For more explanation, you can read the rationale for the deprecation of arguments.callee.

The caller accessor property of Function instances returns the function that invoked this function. For strict, arrow, async, and generator functions, accessing the caller property throws a TypeError.DescriptionIf the function f was invoked by the top-level code, the value of f.caller is null; otherwise it's the function that called f. If the function that called f is a strict mode function, the value of f.caller is also null.
Note that the only behavior specified by the ECMAScript specification is that Function.prototype has an initial caller accessor that unconditionally throws a TypeError for any get or set request (known as a "poison pill accessor"), and that implementations are not allowed to change this semantic for any function except non-strict plain functions, in which case it must not have the value of a strict mode function. The actual behavior of the caller property, if it's anything other than throwing an error, is implementation-defined. For example, Chrome defines it as an own data property, while Firefox and Safari extend the initial poison-pill Function.prototype.caller accessor to specially handle this values that are non-strict functions.
js(function f() {
  if (Object.hasOwn(f, "caller")) {
    console.log(
      "caller is an own property with descriptor",
      Object.getOwnPropertyDescriptor(f, "caller"),
    );
  } else {
    console.log(
      "f doesn't have an own property named caller. Trying to get f.[[Prototype]].caller",
    );
    console.log(
      Object.getOwnPropertyDescriptor(
        Object.getPrototypeOf(f),
        "caller",
      ).get.call(f),
    );
  }
})();

// In Chrome:
// caller is an own property with descriptor {value: null, writable: false, enumerable: false, configurable: false}

// In Firefox:
// f doesn't have an own property named caller. Trying to get f.[[Prototype]].caller
// null

This property replaces the obsolete arguments.caller property of the arguments object.
The special property __caller__, which returned the activation object of the caller thus allowing to reconstruct the stack, was removed for security reasons.ExamplesChecking the value of a function's caller propertyThe following code checks the value a function's caller property.
jsfunction myFunc() {
  if (myFunc.caller === null) {
    return "The function was called from the top!";
  } else {
    return `This function's caller was ${myFunc.caller}`;
  }
}
Reconstructing the stack and recursionNote that in case of recursion, you can't reconstruct the call stack using this property. Consider:
jsfunction f(n) {
  g(n - 1);
}
function g(n) {
  if (n > 0) {
    f(n);
  } else {
    stop();
  }
}
f(2);

At the moment stop() is called the call stack will be:
f(2) -> g(1) -> f(1) -> g(0) -> stop()

The following is true:
jsstop.caller === g && f.caller === g && g.caller === f;

so if you tried to get the stack trace in the stop() function like this:
jslet f = stop;
let stack = "Stack trace:";
while (f) {
  stack += `\n${f.name}`;
  f = f.caller;
}

the loop would never stop.Strict mode callerIf the caller is a strict mode function, the value of caller is null.
jsfunction callerFunc() {
  calleeFunc();
}

function strictCallerFunc() {
  "use strict";
  calleeFunc();
}

function calleeFunc() {
  console.log(calleeFunc.caller);
}

(function () {
  callerFunc();
})();
// Logs [Function: callerFunc]

(function () {
  strictCallerFunc();
})();
// Logs null
SpecificationsNot part of any standard.Browser compatibilitySee also
Function.prototype.name
arguments\n\nFunction.prototype.callerNon-standard: This feature is non-standard and is not on a standards track. Do not use it on production sites facing the Web: it will not work for every user. There may also be large incompatibilities between implementations and the behavior may change in the future.
Deprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time.

Note:
In strict mode, accessing caller of a function throws an error — the API is removed with no replacement. This is to prevent code from being able to "walk the stack", which both poses security risks and severely limits the possibility of optimizations like inlining and tail-call optimization. For more explanation, you can read the rationale for the deprecation of arguments.callee.

The caller accessor property of Function instances returns the function that invoked this function. For strict, arrow, async, and generator functions, accessing the caller property throws a TypeError.DescriptionIf the function f was invoked by the top-level code, the value of f.caller is null; otherwise it's the function that called f. If the function that called f is a strict mode function, the value of f.caller is also null.
Note that the only behavior specified by the ECMAScript specification is that Function.prototype has an initial caller accessor that unconditionally throws a TypeError for any get or set request (known as a "poison pill accessor"), and that implementations are not allowed to change this semantic for any function except non-strict plain functions, in which case it must not have the value of a strict mode function. The actual behavior of the caller property, if it's anything other than throwing an error, is implementation-defined. For example, Chrome defines it as an own data property, while Firefox and Safari extend the initial poison-pill Function.prototype.caller accessor to specially handle this values that are non-strict functions.
js(function f() {
  if (Object.hasOwn(f, "caller")) {
    console.log(
      "caller is an own property with descriptor",
      Object.getOwnPropertyDescriptor(f, "caller"),
    );
  } else {
    console.log(
      "f doesn't have an own property named caller. Trying to get f.[[Prototype]].caller",
    );
    console.log(
      Object.getOwnPropertyDescriptor(
        Object.getPrototypeOf(f),
        "caller",
      ).get.call(f),
    );
  }
})();

// In Chrome:
// caller is an own property with descriptor {value: null, writable: false, enumerable: false, configurable: false}

// In Firefox:
// f doesn't have an own property named caller. Trying to get f.[[Prototype]].caller
// null

This property replaces the obsolete arguments.caller property of the arguments object.
The special property __caller__, which returned the activation object of the caller thus allowing to reconstruct the stack, was removed for security reasons.ExamplesChecking the value of a function's caller propertyThe following code checks the value a function's caller property.
jsfunction myFunc() {
  if (myFunc.caller === null) {
    return "The function was called from the top!";
  } else {
    return `This function's caller was ${myFunc.caller}`;
  }
}
Reconstructing the stack and recursionNote that in case of recursion, you can't reconstruct the call stack using this property. Consider:
jsfunction f(n) {
  g(n - 1);
}
function g(n) {
  if (n > 0) {
    f(n);
  } else {
    stop();
  }
}
f(2);

At the moment stop() is called the call stack will be:
f(2) -> g(1) -> f(1) -> g(0) -> stop()

The following is true:
jsstop.caller === g && f.caller === g && g.caller === f;

so if you tried to get the stack trace in the stop() function like this:
jslet f = stop;
let stack = "Stack trace:";
while (f) {
  stack += `\n${f.name}`;
  f = f.caller;
}

the loop would never stop.Strict mode callerIf the caller is a strict mode function, the value of caller is null.
jsfunction callerFunc() {
  calleeFunc();
}

function strictCallerFunc() {
  "use strict";
  calleeFunc();
}

function calleeFunc() {
  console.log(calleeFunc.caller);
}

(function () {
  callerFunc();
})();
// Logs [Function: callerFunc]

(function () {
  strictCallerFunc();
})();
// Logs null
SpecificationsNot part of any standard.Browser compatibilitySee also
Function.prototype.name
arguments
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jul 25, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nFunction.prototype.callerNon-standard: This feature is non-standard and is not on a standards track. Do not use it on production sites facing the Web: it will not work for every user. There may also be large incompatibilities between implementations and the behavior may change in the future.
Deprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time.

Note:
In strict mode, accessing caller of a function throws an error — the API is removed with no replacement. This is to prevent code from being able to "walk the stack", which both poses security risks and severely limits the possibility of optimizations like inlining and tail-call optimization. For more explanation, you can read the rationale for the deprecation of arguments.callee.

The caller accessor property of Function instances returns the function that invoked this function. For strict, arrow, async, and generator functions, accessing the caller property throws a TypeError.DescriptionIf the function f was invoked by the top-level code, the value of f.caller is null; otherwise it's the function that called f. If the function that called f is a strict mode function, the value of f.caller is also null.
Note that the only behavior specified by the ECMAScript specification is that Function.prototype has an initial caller accessor that unconditionally throws a TypeError for any get or set request (known as a "poison pill accessor"), and that implementations are not allowed to change this semantic for any function except non-strict plain functions, in which case it must not have the value of a strict mode function. The actual behavior of the caller property, if it's anything other than throwing an error, is implementation-defined. For example, Chrome defines it as an own data property, while Firefox and Safari extend the initial poison-pill Function.prototype.caller accessor to specially handle this values that are non-strict functions.
js(function f() {
  if (Object.hasOwn(f, "caller")) {
    console.log(
      "caller is an own property with descriptor",
      Object.getOwnPropertyDescriptor(f, "caller"),
    );
  } else {
    console.log(
      "f doesn't have an own property named caller. Trying to get f.[[Prototype]].caller",
    );
    console.log(
      Object.getOwnPropertyDescriptor(
        Object.getPrototypeOf(f),
        "caller",
      ).get.call(f),
    );
  }
})();

// In Chrome:
// caller is an own property with descriptor {value: null, writable: false, enumerable: false, configurable: false}

// In Firefox:
// f doesn't have an own property named caller. Trying to get f.[[Prototype]].caller
// null

This property replaces the obsolete arguments.caller property of the arguments object.
The special property __caller__, which returned the activation object of the caller thus allowing to reconstruct the stack, was removed for security reasons.ExamplesChecking the value of a function's caller propertyThe following code checks the value a function's caller property.
jsfunction myFunc() {
  if (myFunc.caller === null) {
    return "The function was called from the top!";
  } else {
    return `This function's caller was ${myFunc.caller}`;
  }
}
Reconstructing the stack and recursionNote that in case of recursion, you can't reconstruct the call stack using this property. Consider:
jsfunction f(n) {
  g(n - 1);
}
function g(n) {
  if (n > 0) {
    f(n);
  } else {
    stop();
  }
}
f(2);

At the moment stop() is called the call stack will be:
f(2) -> g(1) -> f(1) -> g(0) -> stop()

The following is true:
jsstop.caller === g && f.caller === g && g.caller === f;

so if you tried to get the stack trace in the stop() function like this:
jslet f = stop;
let stack = "Stack trace:";
while (f) {
  stack += `\n${f.name}`;
  f = f.caller;
}

the loop would never stop.Strict mode callerIf the caller is a strict mode function, the value of caller is null.
jsfunction callerFunc() {
  calleeFunc();
}

function strictCallerFunc() {
  "use strict";
  calleeFunc();
}

function calleeFunc() {
  console.log(calleeFunc.caller);
}

(function () {
  callerFunc();
})();
// Logs [Function: callerFunc]

(function () {
  strictCallerFunc();
})();
// Logs null
SpecificationsNot part of any standard.Browser compatibilitySee also
Function.prototype.name
arguments
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jul 25, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nObject.prototype.__defineGetter__()Deprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time.

Note:
This feature is deprecated in favor of defining getters using the object initializer syntax or the Object.defineProperty() API. This method's behavior is only specified for web compatibility, and is not required to be implemented in any platform. It may not work everywhere.

The __defineGetter__() method of Object instances binds an object's property to a function to be called when that property is looked up.Syntaxjs__defineGetter__(prop, func)
Parameters
prop

A string containing the name of the property that the getter func is bound to.

func

A function to be bound to a lookup of the specified property.

Return valueNone (undefined).Exceptions
TypeError

Thrown if func is not a function.

DescriptionAll objects that inherit from Object.prototype (that is, all except null-prototype objects) inherit the __defineGetter__() method. This method allows a getter to be defined on a pre-existing object. This is equivalent to Object.defineProperty(obj, prop, { get: func, configurable: true, enumerable: true }), which means the property is enumerable and configurable, and any existing setter, if present, is preserved.
__defineGetter__() is defined in the spec as "normative optional", which means no implementation is required to implement this. However, all major browsers implement it, and due to its continued usage, it's unlikely to be removed. If a browser implements __defineGetter__(), it also needs to implement the __lookupGetter__(), __lookupSetter__(), and __defineSetter__() methods.ExamplesUsing __defineGetter__()jsconst o = {};
o.__defineGetter__("gimmeFive", function () {
  return 5;
});
console.log(o.gimmeFive); // 5
Defining a getter property in standard waysYou can use the get syntax to define a getter when the object is first initialized.
jsconst o = {
  get gimmeFive() {
    return 5;
  },
};
console.log(o.gimmeFive); // 5

You may also use Object.defineProperty() to define a getter on an object after it's been created. Compared to __defineGetter__(), this method allows you to control the getter's enumerability and configurability, as well as defining symbol properties. The Object.defineProperty() method also works with null-prototype objects, which don't inherit from Object.prototype and therefore don't have the __defineGetter__() method.
jsconst o = {};
Object.defineProperty(o, "gimmeFive", {
  get() {
    return 5;
  },
  configurable: true,
  enumerable: true,
});
console.log(o.gimmeFive); // 5
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object.prototype.__defineGetter__Browser compatibilitySee also
Polyfill of Object.prototype.__defineGetter__ in core-js
Object.prototype.__defineSetter__()
get
Object.defineProperty()
Object.prototype.__lookupGetter__()
Object.prototype.__lookupSetter__()
JS Guide: Defining Getters and Setters
Firefox bug 647423\n\nObject.prototype.__defineGetter__()Deprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time.

Note:
This feature is deprecated in favor of defining getters using the object initializer syntax or the Object.defineProperty() API. This method's behavior is only specified for web compatibility, and is not required to be implemented in any platform. It may not work everywhere.

The __defineGetter__() method of Object instances binds an object's property to a function to be called when that property is looked up.Syntaxjs__defineGetter__(prop, func)
Parameters
prop

A string containing the name of the property that the getter func is bound to.

func

A function to be bound to a lookup of the specified property.

Return valueNone (undefined).Exceptions
TypeError

Thrown if func is not a function.

DescriptionAll objects that inherit from Object.prototype (that is, all except null-prototype objects) inherit the __defineGetter__() method. This method allows a getter to be defined on a pre-existing object. This is equivalent to Object.defineProperty(obj, prop, { get: func, configurable: true, enumerable: true }), which means the property is enumerable and configurable, and any existing setter, if present, is preserved.
__defineGetter__() is defined in the spec as "normative optional", which means no implementation is required to implement this. However, all major browsers implement it, and due to its continued usage, it's unlikely to be removed. If a browser implements __defineGetter__(), it also needs to implement the __lookupGetter__(), __lookupSetter__(), and __defineSetter__() methods.ExamplesUsing __defineGetter__()jsconst o = {};
o.__defineGetter__("gimmeFive", function () {
  return 5;
});
console.log(o.gimmeFive); // 5
Defining a getter property in standard waysYou can use the get syntax to define a getter when the object is first initialized.
jsconst o = {
  get gimmeFive() {
    return 5;
  },
};
console.log(o.gimmeFive); // 5

You may also use Object.defineProperty() to define a getter on an object after it's been created. Compared to __defineGetter__(), this method allows you to control the getter's enumerability and configurability, as well as defining symbol properties. The Object.defineProperty() method also works with null-prototype objects, which don't inherit from Object.prototype and therefore don't have the __defineGetter__() method.
jsconst o = {};
Object.defineProperty(o, "gimmeFive", {
  get() {
    return 5;
  },
  configurable: true,
  enumerable: true,
});
console.log(o.gimmeFive); // 5
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object.prototype.__defineGetter__Browser compatibilitySee also
Polyfill of Object.prototype.__defineGetter__ in core-js
Object.prototype.__defineSetter__()
get
Object.defineProperty()
Object.prototype.__lookupGetter__()
Object.prototype.__lookupSetter__()
JS Guide: Defining Getters and Setters
Firefox bug 647423
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jul 25, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nObject.prototype.__defineGetter__()Deprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time.

Note:
This feature is deprecated in favor of defining getters using the object initializer syntax or the Object.defineProperty() API. This method's behavior is only specified for web compatibility, and is not required to be implemented in any platform. It may not work everywhere.

The __defineGetter__() method of Object instances binds an object's property to a function to be called when that property is looked up.Syntaxjs__defineGetter__(prop, func)
Parameters
prop

A string containing the name of the property that the getter func is bound to.

func

A function to be bound to a lookup of the specified property.

Return valueNone (undefined).Exceptions
TypeError

Thrown if func is not a function.

DescriptionAll objects that inherit from Object.prototype (that is, all except null-prototype objects) inherit the __defineGetter__() method. This method allows a getter to be defined on a pre-existing object. This is equivalent to Object.defineProperty(obj, prop, { get: func, configurable: true, enumerable: true }), which means the property is enumerable and configurable, and any existing setter, if present, is preserved.
__defineGetter__() is defined in the spec as "normative optional", which means no implementation is required to implement this. However, all major browsers implement it, and due to its continued usage, it's unlikely to be removed. If a browser implements __defineGetter__(), it also needs to implement the __lookupGetter__(), __lookupSetter__(), and __defineSetter__() methods.ExamplesUsing __defineGetter__()jsconst o = {};
o.__defineGetter__("gimmeFive", function () {
  return 5;
});
console.log(o.gimmeFive); // 5
Defining a getter property in standard waysYou can use the get syntax to define a getter when the object is first initialized.
jsconst o = {
  get gimmeFive() {
    return 5;
  },
};
console.log(o.gimmeFive); // 5

You may also use Object.defineProperty() to define a getter on an object after it's been created. Compared to __defineGetter__(), this method allows you to control the getter's enumerability and configurability, as well as defining symbol properties. The Object.defineProperty() method also works with null-prototype objects, which don't inherit from Object.prototype and therefore don't have the __defineGetter__() method.
jsconst o = {};
Object.defineProperty(o, "gimmeFive", {
  get() {
    return 5;
  },
  configurable: true,
  enumerable: true,
});
console.log(o.gimmeFive); // 5
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object.prototype.__defineGetter__Browser compatibilitySee also
Polyfill of Object.prototype.__defineGetter__ in core-js
Object.prototype.__defineSetter__()
get
Object.defineProperty()
Object.prototype.__lookupGetter__()
Object.prototype.__lookupSetter__()
JS Guide: Defining Getters and Setters
Firefox bug 647423
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jul 25, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nObject.prototype.__defineSetter__()Deprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time.

Note:
This feature is deprecated in favor of defining setters using the object initializer syntax or the Object.defineProperty() API. This method's behavior is only specified for web compatibility, and is not required to be implemented in any platform. It may not work everywhere.

The __defineSetter__() method of Object instances binds an object's property to a function to be called when an attempt is made to set that property.Syntaxjs__defineSetter__(prop, func)
Parameters
prop

A string containing the name of the property that the setter func is bound to.

func

A function to be called when there is an attempt to set the specified property. This function receives the following parameter:

val

The value attempted to be assigned to prop.



Return valueNone (undefined).Exceptions
TypeError

Thrown if func is not a function.

DescriptionAll objects that inherit from Object.prototype (that is, all except null-prototype objects) inherit the __defineSetter__() method. This method allows a setter to be defined on a pre-existing object. This is equivalent to Object.defineProperty(obj, prop, { set: func, configurable: true, enumerable: true }), which means the property is enumerable and configurable, and any existing getter, if present, is preserved.
__defineSetter__() is defined in the spec as "normative optional", which means no implementation is required to implement this. However, all major browsers implement it, and due to its continued usage, it's unlikely to be removed. If a browser implements __defineSetter__(), it also needs to implement the __lookupGetter__(), __lookupSetter__(), and __defineGetter__() methods.ExamplesUsing __defineSetter__()jsconst o = {};
o.__defineSetter__("value", function (val) {
  this.anotherValue = val;
});
o.value = 5;
console.log(o.value); // undefined
console.log(o.anotherValue); // 5
Defining a setter property in standard waysYou can use the set syntax to define a setter when the object is first initialized.
jsconst o = {
  set value(val) {
    this.anotherValue = val;
  },
};
o.value = 5;
console.log(o.value); // undefined
console.log(o.anotherValue); // 5

You may also use Object.defineProperty() to define a setter on an object after it's been created. Compared to __defineSetter__(), this method allows you to control the setter's enumerability and configurability, as well as defining symbol properties. The Object.defineProperty() method also works with null-prototype objects, which don't inherit from Object.prototype and therefore don't have the __defineSetter__() method.
jsconst o = {};
Object.defineProperty(o, "value", {
  set(val) {
    this.anotherValue = val;
  },
  configurable: true,
  enumerable: true,
});
o.value = 5;
console.log(o.value); // undefined
console.log(o.anotherValue); // 5
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object.prototype.__defineSetter__Browser compatibilitySee also
Polyfill of Object.prototype.__defineSetter__ in core-js
Object.prototype.__defineGetter__()
set
Object.defineProperty()
Object.prototype.__lookupGetter__()
Object.prototype.__lookupSetter__()
JS Guide: Defining Getters and Setters
Firefox bug 647423\n\nObject.prototype.__defineSetter__()Deprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time.

Note:
This feature is deprecated in favor of defining setters using the object initializer syntax or the Object.defineProperty() API. This method's behavior is only specified for web compatibility, and is not required to be implemented in any platform. It may not work everywhere.

The __defineSetter__() method of Object instances binds an object's property to a function to be called when an attempt is made to set that property.Syntaxjs__defineSetter__(prop, func)
Parameters
prop

A string containing the name of the property that the setter func is bound to.

func

A function to be called when there is an attempt to set the specified property. This function receives the following parameter:

val

The value attempted to be assigned to prop.



Return valueNone (undefined).Exceptions
TypeError

Thrown if func is not a function.

DescriptionAll objects that inherit from Object.prototype (that is, all except null-prototype objects) inherit the __defineSetter__() method. This method allows a setter to be defined on a pre-existing object. This is equivalent to Object.defineProperty(obj, prop, { set: func, configurable: true, enumerable: true }), which means the property is enumerable and configurable, and any existing getter, if present, is preserved.
__defineSetter__() is defined in the spec as "normative optional", which means no implementation is required to implement this. However, all major browsers implement it, and due to its continued usage, it's unlikely to be removed. If a browser implements __defineSetter__(), it also needs to implement the __lookupGetter__(), __lookupSetter__(), and __defineGetter__() methods.ExamplesUsing __defineSetter__()jsconst o = {};
o.__defineSetter__("value", function (val) {
  this.anotherValue = val;
});
o.value = 5;
console.log(o.value); // undefined
console.log(o.anotherValue); // 5
Defining a setter property in standard waysYou can use the set syntax to define a setter when the object is first initialized.
jsconst o = {
  set value(val) {
    this.anotherValue = val;
  },
};
o.value = 5;
console.log(o.value); // undefined
console.log(o.anotherValue); // 5

You may also use Object.defineProperty() to define a setter on an object after it's been created. Compared to __defineSetter__(), this method allows you to control the setter's enumerability and configurability, as well as defining symbol properties. The Object.defineProperty() method also works with null-prototype objects, which don't inherit from Object.prototype and therefore don't have the __defineSetter__() method.
jsconst o = {};
Object.defineProperty(o, "value", {
  set(val) {
    this.anotherValue = val;
  },
  configurable: true,
  enumerable: true,
});
o.value = 5;
console.log(o.value); // undefined
console.log(o.anotherValue); // 5
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object.prototype.__defineSetter__Browser compatibilitySee also
Polyfill of Object.prototype.__defineSetter__ in core-js
Object.prototype.__defineGetter__()
set
Object.defineProperty()
Object.prototype.__lookupGetter__()
Object.prototype.__lookupSetter__()
JS Guide: Defining Getters and Setters
Firefox bug 647423
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jul 25, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nObject.prototype.__defineSetter__()Deprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time.

Note:
This feature is deprecated in favor of defining setters using the object initializer syntax or the Object.defineProperty() API. This method's behavior is only specified for web compatibility, and is not required to be implemented in any platform. It may not work everywhere.

The __defineSetter__() method of Object instances binds an object's property to a function to be called when an attempt is made to set that property.Syntaxjs__defineSetter__(prop, func)
Parameters
prop

A string containing the name of the property that the setter func is bound to.

func

A function to be called when there is an attempt to set the specified property. This function receives the following parameter:

val

The value attempted to be assigned to prop.



Return valueNone (undefined).Exceptions
TypeError

Thrown if func is not a function.

DescriptionAll objects that inherit from Object.prototype (that is, all except null-prototype objects) inherit the __defineSetter__() method. This method allows a setter to be defined on a pre-existing object. This is equivalent to Object.defineProperty(obj, prop, { set: func, configurable: true, enumerable: true }), which means the property is enumerable and configurable, and any existing getter, if present, is preserved.
__defineSetter__() is defined in the spec as "normative optional", which means no implementation is required to implement this. However, all major browsers implement it, and due to its continued usage, it's unlikely to be removed. If a browser implements __defineSetter__(), it also needs to implement the __lookupGetter__(), __lookupSetter__(), and __defineGetter__() methods.ExamplesUsing __defineSetter__()jsconst o = {};
o.__defineSetter__("value", function (val) {
  this.anotherValue = val;
});
o.value = 5;
console.log(o.value); // undefined
console.log(o.anotherValue); // 5
Defining a setter property in standard waysYou can use the set syntax to define a setter when the object is first initialized.
jsconst o = {
  set value(val) {
    this.anotherValue = val;
  },
};
o.value = 5;
console.log(o.value); // undefined
console.log(o.anotherValue); // 5

You may also use Object.defineProperty() to define a setter on an object after it's been created. Compared to __defineSetter__(), this method allows you to control the setter's enumerability and configurability, as well as defining symbol properties. The Object.defineProperty() method also works with null-prototype objects, which don't inherit from Object.prototype and therefore don't have the __defineSetter__() method.
jsconst o = {};
Object.defineProperty(o, "value", {
  set(val) {
    this.anotherValue = val;
  },
  configurable: true,
  enumerable: true,
});
o.value = 5;
console.log(o.value); // undefined
console.log(o.anotherValue); // 5
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object.prototype.__defineSetter__Browser compatibilitySee also
Polyfill of Object.prototype.__defineSetter__ in core-js
Object.prototype.__defineGetter__()
set
Object.defineProperty()
Object.prototype.__lookupGetter__()
Object.prototype.__lookupSetter__()
JS Guide: Defining Getters and Setters
Firefox bug 647423
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jul 25, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nObject.prototype.__lookupGetter__() 
Deprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time.

Note:
This feature is deprecated in favor of the Object.getOwnPropertyDescriptor() API. This method's behavior is only specified for web compatibility, and is not required to be implemented in any platform. It may not work everywhere.

The __lookupGetter__() method of Object instances returns the function bound as a getter to the specified property.Syntaxjs__lookupGetter__(prop)
Parameters
prop

A string containing the name of the property whose getter should be returned.

Return valueThe function bound as a getter to the specified property. Returns undefined if no such property is found, or the property is a data property.DescriptionAll objects that inherit from Object.prototype (that is, all except null-prototype objects) inherit the __lookupGetter__() method. If a getter has been defined for an object's property, it's not possible to reference the getter function through that property, because that property refers to the return value of that function. __lookupGetter__() can be used to obtain a reference to the getter function.
__lookupGetter__() walks up the prototype chain to find the specified property. If any object along the prototype chain has the specified own property, the get attribute of the property descriptor for that property is returned. If that property is a data property, undefined is returned. If the property is not found along the entire prototype chain, undefined is also returned.
__lookupGetter__() is defined in the spec as "normative optional", which means no implementation is required to implement this. However, all major browsers implement it, and due to its continued usage, it's unlikely to be removed. If a browser implements __lookupGetter__(), it also needs to implement the __lookupSetter__(), __defineGetter__(), and __defineSetter__() methods.ExamplesUsing __lookupGetter__()jsconst obj = {
  get foo() {
    return Math.random() > 0.5 ? "foo" : "bar";
  },
};

obj.__lookupGetter__("foo");
// [Function: get foo]
Looking up a property's getter in the standard wayYou should use the Object.getOwnPropertyDescriptor() API to look up a property's getter. Compared to __lookupGetter__(), this method allows looking up symbol properties. The Object.getOwnPropertyDescriptor() method also works with null-prototype objects, which don't inherit from Object.prototype and therefore don't have the __lookupGetter__() method. If __lookupGetter__()'s behavior of walking up the prototype chain is important, you may implement it yourself with Object.getPrototypeOf().
jsconst obj = {
  get foo() {
    return Math.random() > 0.5 ? "foo" : "bar";
  },
};

Object.getOwnPropertyDescriptor(obj, "foo").get;
// [Function: get foo]

jsconst obj2 = {
  __proto__: {
    get foo() {
      return Math.random() > 0.5 ? "foo" : "bar";
    },
  },
};

function findGetter(obj, prop) {
  while (obj) {
    const desc = Object.getOwnPropertyDescriptor(obj, prop);
    if (desc) {
      return desc.get;
    }
    obj = Object.getPrototypeOf(obj);
  }
}

console.log(findGetter(obj2, "foo")); // [Function: get foo]
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object.prototype.__lookupGetter__Browser compatibilitySee also
Polyfill of Object.prototype.__lookupGetter__ in core-js
Object.prototype.__lookupSetter__()
get
Object.getOwnPropertyDescriptor()
Object.prototype.__defineGetter__()
Object.prototype.__defineSetter__()
JS Guide: Defining Getters and Setters\n\nObject.prototype.__lookupGetter__() 
Deprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time.

Note:
This feature is deprecated in favor of the Object.getOwnPropertyDescriptor() API. This method's behavior is only specified for web compatibility, and is not required to be implemented in any platform. It may not work everywhere.

The __lookupGetter__() method of Object instances returns the function bound as a getter to the specified property.Syntaxjs__lookupGetter__(prop)
Parameters
prop

A string containing the name of the property whose getter should be returned.

Return valueThe function bound as a getter to the specified property. Returns undefined if no such property is found, or the property is a data property.DescriptionAll objects that inherit from Object.prototype (that is, all except null-prototype objects) inherit the __lookupGetter__() method. If a getter has been defined for an object's property, it's not possible to reference the getter function through that property, because that property refers to the return value of that function. __lookupGetter__() can be used to obtain a reference to the getter function.
__lookupGetter__() walks up the prototype chain to find the specified property. If any object along the prototype chain has the specified own property, the get attribute of the property descriptor for that property is returned. If that property is a data property, undefined is returned. If the property is not found along the entire prototype chain, undefined is also returned.
__lookupGetter__() is defined in the spec as "normative optional", which means no implementation is required to implement this. However, all major browsers implement it, and due to its continued usage, it's unlikely to be removed. If a browser implements __lookupGetter__(), it also needs to implement the __lookupSetter__(), __defineGetter__(), and __defineSetter__() methods.ExamplesUsing __lookupGetter__()jsconst obj = {
  get foo() {
    return Math.random() > 0.5 ? "foo" : "bar";
  },
};

obj.__lookupGetter__("foo");
// [Function: get foo]
Looking up a property's getter in the standard wayYou should use the Object.getOwnPropertyDescriptor() API to look up a property's getter. Compared to __lookupGetter__(), this method allows looking up symbol properties. The Object.getOwnPropertyDescriptor() method also works with null-prototype objects, which don't inherit from Object.prototype and therefore don't have the __lookupGetter__() method. If __lookupGetter__()'s behavior of walking up the prototype chain is important, you may implement it yourself with Object.getPrototypeOf().
jsconst obj = {
  get foo() {
    return Math.random() > 0.5 ? "foo" : "bar";
  },
};

Object.getOwnPropertyDescriptor(obj, "foo").get;
// [Function: get foo]

jsconst obj2 = {
  __proto__: {
    get foo() {
      return Math.random() > 0.5 ? "foo" : "bar";
    },
  },
};

function findGetter(obj, prop) {
  while (obj) {
    const desc = Object.getOwnPropertyDescriptor(obj, prop);
    if (desc) {
      return desc.get;
    }
    obj = Object.getPrototypeOf(obj);
  }
}

console.log(findGetter(obj2, "foo")); // [Function: get foo]
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object.prototype.__lookupGetter__Browser compatibilitySee also
Polyfill of Object.prototype.__lookupGetter__ in core-js
Object.prototype.__lookupSetter__()
get
Object.getOwnPropertyDescriptor()
Object.prototype.__defineGetter__()
Object.prototype.__defineSetter__()
JS Guide: Defining Getters and Setters
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nObject.prototype.__lookupGetter__() 
Deprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time.

Note:
This feature is deprecated in favor of the Object.getOwnPropertyDescriptor() API. This method's behavior is only specified for web compatibility, and is not required to be implemented in any platform. It may not work everywhere.

The __lookupGetter__() method of Object instances returns the function bound as a getter to the specified property.Syntaxjs__lookupGetter__(prop)
Parameters
prop

A string containing the name of the property whose getter should be returned.

Return valueThe function bound as a getter to the specified property. Returns undefined if no such property is found, or the property is a data property.DescriptionAll objects that inherit from Object.prototype (that is, all except null-prototype objects) inherit the __lookupGetter__() method. If a getter has been defined for an object's property, it's not possible to reference the getter function through that property, because that property refers to the return value of that function. __lookupGetter__() can be used to obtain a reference to the getter function.
__lookupGetter__() walks up the prototype chain to find the specified property. If any object along the prototype chain has the specified own property, the get attribute of the property descriptor for that property is returned. If that property is a data property, undefined is returned. If the property is not found along the entire prototype chain, undefined is also returned.
__lookupGetter__() is defined in the spec as "normative optional", which means no implementation is required to implement this. However, all major browsers implement it, and due to its continued usage, it's unlikely to be removed. If a browser implements __lookupGetter__(), it also needs to implement the __lookupSetter__(), __defineGetter__(), and __defineSetter__() methods.ExamplesUsing __lookupGetter__()jsconst obj = {
  get foo() {
    return Math.random() > 0.5 ? "foo" : "bar";
  },
};

obj.__lookupGetter__("foo");
// [Function: get foo]
Looking up a property's getter in the standard wayYou should use the Object.getOwnPropertyDescriptor() API to look up a property's getter. Compared to __lookupGetter__(), this method allows looking up symbol properties. The Object.getOwnPropertyDescriptor() method also works with null-prototype objects, which don't inherit from Object.prototype and therefore don't have the __lookupGetter__() method. If __lookupGetter__()'s behavior of walking up the prototype chain is important, you may implement it yourself with Object.getPrototypeOf().
jsconst obj = {
  get foo() {
    return Math.random() > 0.5 ? "foo" : "bar";
  },
};

Object.getOwnPropertyDescriptor(obj, "foo").get;
// [Function: get foo]

jsconst obj2 = {
  __proto__: {
    get foo() {
      return Math.random() > 0.5 ? "foo" : "bar";
    },
  },
};

function findGetter(obj, prop) {
  while (obj) {
    const desc = Object.getOwnPropertyDescriptor(obj, prop);
    if (desc) {
      return desc.get;
    }
    obj = Object.getPrototypeOf(obj);
  }
}

console.log(findGetter(obj2, "foo")); // [Function: get foo]
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object.prototype.__lookupGetter__Browser compatibilitySee also
Polyfill of Object.prototype.__lookupGetter__ in core-js
Object.prototype.__lookupSetter__()
get
Object.getOwnPropertyDescriptor()
Object.prototype.__defineGetter__()
Object.prototype.__defineSetter__()
JS Guide: Defining Getters and Setters
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nObject.prototype.__lookupSetter__() 
Deprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time.

Note:
This feature is deprecated in favor of the Object.getOwnPropertyDescriptor() API. This method's behavior is only specified for web compatibility, and is not required to be implemented in any platform. It may not work everywhere.

The __lookupSetter__() method of Object instances returns the function bound as a setter to the specified property.Syntaxjs__lookupSetter__(prop)
Parameters
prop

A string containing the name of the property whose setter should be returned.

Return valueThe function bound as a setter to the specified property. Returns undefined if no such property is found, or the property is a data property.DescriptionAll objects that inherit from Object.prototype (that is, all except null-prototype objects) inherit the __lookupSetter__() method. If a setter has been defined for an object's property, it's not possible to reference the setter function through that property, because that property only calls the function when it's being set. __lookupSetter__() can be used to obtain a reference to the setter function.
__lookupSetter__() walks up the prototype chain to find the specified property. If any object along the prototype chain has the specified own property, the set attribute of the property descriptor for that property is returned. If that property is a data property, undefined is returned. If the property is not found along the entire prototype chain, undefined is also returned.
__lookupSetter__() is defined in the spec as "normative optional", which means no implementation is required to implement this. However, all major browsers implement it, and due to its continued usage, it's unlikely to be removed. If a browser implements __lookupSetter__(), it also needs to implement the __lookupGetter__(), __defineGetter__(), and __defineSetter__() methods.ExamplesUsing __lookupSetter__()jsconst obj = {
  set foo(value) {
    this.bar = value;
  },
};

obj.__lookupSetter__("foo");
// [Function: set foo]
Looking up a property's setter in the standard wayYou should use the Object.getOwnPropertyDescriptor() API to look up a property's setter. Compared to __lookupSetter__(), this method allows looking up symbol properties. The Object.getOwnPropertyDescriptor() method also works with null-prototype objects, which don't inherit from Object.prototype and therefore don't have the __lookupSetter__() method. If __lookupSetter__()'s behavior of walking up the prototype chain is important, you may implement it yourself with Object.getPrototypeOf().
jsconst obj = {
  set foo(value) {
    this.bar = value;
  },
};

Object.getOwnPropertyDescriptor(obj, "foo").set;
// [Function: set foo]

jsconst obj2 = {
  __proto__: {
    set foo(value) {
      this.bar = value;
    },
  },
};

function findSetter(obj, prop) {
  while (obj) {
    const desc = Object.getOwnPropertyDescriptor(obj, prop);
    if (desc) {
      return desc.set;
    }
    obj = Object.getPrototypeOf(obj);
  }
}

console.log(findSetter(obj2, "foo")); // [Function: set foo]
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object.prototype.__lookupSetter__Browser compatibilitySee also
Polyfill of Object.prototype.__lookupSetter__ in core-js
Object.prototype.__lookupGetter__()
set
Object.getOwnPropertyDescriptor()
Object.prototype.__defineGetter__()
Object.prototype.__defineSetter__()
JS Guide: Defining Getters and Setters\n\nObject.prototype.__lookupSetter__() 
Deprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time.

Note:
This feature is deprecated in favor of the Object.getOwnPropertyDescriptor() API. This method's behavior is only specified for web compatibility, and is not required to be implemented in any platform. It may not work everywhere.

The __lookupSetter__() method of Object instances returns the function bound as a setter to the specified property.Syntaxjs__lookupSetter__(prop)
Parameters
prop

A string containing the name of the property whose setter should be returned.

Return valueThe function bound as a setter to the specified property. Returns undefined if no such property is found, or the property is a data property.DescriptionAll objects that inherit from Object.prototype (that is, all except null-prototype objects) inherit the __lookupSetter__() method. If a setter has been defined for an object's property, it's not possible to reference the setter function through that property, because that property only calls the function when it's being set. __lookupSetter__() can be used to obtain a reference to the setter function.
__lookupSetter__() walks up the prototype chain to find the specified property. If any object along the prototype chain has the specified own property, the set attribute of the property descriptor for that property is returned. If that property is a data property, undefined is returned. If the property is not found along the entire prototype chain, undefined is also returned.
__lookupSetter__() is defined in the spec as "normative optional", which means no implementation is required to implement this. However, all major browsers implement it, and due to its continued usage, it's unlikely to be removed. If a browser implements __lookupSetter__(), it also needs to implement the __lookupGetter__(), __defineGetter__(), and __defineSetter__() methods.ExamplesUsing __lookupSetter__()jsconst obj = {
  set foo(value) {
    this.bar = value;
  },
};

obj.__lookupSetter__("foo");
// [Function: set foo]
Looking up a property's setter in the standard wayYou should use the Object.getOwnPropertyDescriptor() API to look up a property's setter. Compared to __lookupSetter__(), this method allows looking up symbol properties. The Object.getOwnPropertyDescriptor() method also works with null-prototype objects, which don't inherit from Object.prototype and therefore don't have the __lookupSetter__() method. If __lookupSetter__()'s behavior of walking up the prototype chain is important, you may implement it yourself with Object.getPrototypeOf().
jsconst obj = {
  set foo(value) {
    this.bar = value;
  },
};

Object.getOwnPropertyDescriptor(obj, "foo").set;
// [Function: set foo]

jsconst obj2 = {
  __proto__: {
    set foo(value) {
      this.bar = value;
    },
  },
};

function findSetter(obj, prop) {
  while (obj) {
    const desc = Object.getOwnPropertyDescriptor(obj, prop);
    if (desc) {
      return desc.set;
    }
    obj = Object.getPrototypeOf(obj);
  }
}

console.log(findSetter(obj2, "foo")); // [Function: set foo]
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object.prototype.__lookupSetter__Browser compatibilitySee also
Polyfill of Object.prototype.__lookupSetter__ in core-js
Object.prototype.__lookupGetter__()
set
Object.getOwnPropertyDescriptor()
Object.prototype.__defineGetter__()
Object.prototype.__defineSetter__()
JS Guide: Defining Getters and Setters
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nObject.prototype.__lookupSetter__() 
Deprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time.

Note:
This feature is deprecated in favor of the Object.getOwnPropertyDescriptor() API. This method's behavior is only specified for web compatibility, and is not required to be implemented in any platform. It may not work everywhere.

The __lookupSetter__() method of Object instances returns the function bound as a setter to the specified property.Syntaxjs__lookupSetter__(prop)
Parameters
prop

A string containing the name of the property whose setter should be returned.

Return valueThe function bound as a setter to the specified property. Returns undefined if no such property is found, or the property is a data property.DescriptionAll objects that inherit from Object.prototype (that is, all except null-prototype objects) inherit the __lookupSetter__() method. If a setter has been defined for an object's property, it's not possible to reference the setter function through that property, because that property only calls the function when it's being set. __lookupSetter__() can be used to obtain a reference to the setter function.
__lookupSetter__() walks up the prototype chain to find the specified property. If any object along the prototype chain has the specified own property, the set attribute of the property descriptor for that property is returned. If that property is a data property, undefined is returned. If the property is not found along the entire prototype chain, undefined is also returned.
__lookupSetter__() is defined in the spec as "normative optional", which means no implementation is required to implement this. However, all major browsers implement it, and due to its continued usage, it's unlikely to be removed. If a browser implements __lookupSetter__(), it also needs to implement the __lookupGetter__(), __defineGetter__(), and __defineSetter__() methods.ExamplesUsing __lookupSetter__()jsconst obj = {
  set foo(value) {
    this.bar = value;
  },
};

obj.__lookupSetter__("foo");
// [Function: set foo]
Looking up a property's setter in the standard wayYou should use the Object.getOwnPropertyDescriptor() API to look up a property's setter. Compared to __lookupSetter__(), this method allows looking up symbol properties. The Object.getOwnPropertyDescriptor() method also works with null-prototype objects, which don't inherit from Object.prototype and therefore don't have the __lookupSetter__() method. If __lookupSetter__()'s behavior of walking up the prototype chain is important, you may implement it yourself with Object.getPrototypeOf().
jsconst obj = {
  set foo(value) {
    this.bar = value;
  },
};

Object.getOwnPropertyDescriptor(obj, "foo").set;
// [Function: set foo]

jsconst obj2 = {
  __proto__: {
    set foo(value) {
      this.bar = value;
    },
  },
};

function findSetter(obj, prop) {
  while (obj) {
    const desc = Object.getOwnPropertyDescriptor(obj, prop);
    if (desc) {
      return desc.set;
    }
    obj = Object.getPrototypeOf(obj);
  }
}

console.log(findSetter(obj2, "foo")); // [Function: set foo]
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object.prototype.__lookupSetter__Browser compatibilitySee also
Polyfill of Object.prototype.__lookupSetter__ in core-js
Object.prototype.__lookupGetter__()
set
Object.getOwnPropertyDescriptor()
Object.prototype.__defineGetter__()
Object.prototype.__defineSetter__()
JS Guide: Defining Getters and Setters
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nObject.prototype.hasOwnProperty()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe hasOwnProperty() method of Object instances returns a boolean indicating whether this
object has the specified property as its own property (as opposed to inheriting
it).

Note: Object.hasOwn() is recommended over
hasOwnProperty(), in browsers where it is supported.
Try it
const object1 = {};
object1.property1 = 42;

console.log(object1.hasOwnProperty("property1"));
// Expected output: true

console.log(object1.hasOwnProperty("toString"));
// Expected output: false

console.log(object1.hasOwnProperty("hasOwnProperty"));
// Expected output: false
SyntaxjshasOwnProperty(prop)
Parameters
prop

The String name or Symbol of the property to test.

Return valueReturns true if the object has the specified property as own property; false
otherwise.DescriptionThe hasOwnProperty() method returns true if the specified property is a
direct property of the object — even if the value is null or undefined. The
method returns false if the property is inherited, or has not been declared at
all. Unlike the in operator, this
method does not check for the specified property in the object's prototype
chain.
The method can be called on most JavaScript objects, because most objects
descend from Object, and hence inherit its methods. For
example Array is an Object, so you can
use hasOwnProperty() method to check whether an index exists:
jsconst fruits = ["Apple", "Banana", "Watermelon", "Orange"];
fruits.hasOwnProperty(3); // true ('Orange')
fruits.hasOwnProperty(4); // false - not defined

The method will not be available in objects where it is reimplemented, or on
null-prototype objects (as these don't inherit from
Object.prototype). Examples for these cases are given below.ExamplesUsing hasOwnProperty to test for an own property's existenceThe following code shows how to determine whether the example object contains a property named prop.
jsconst example = {};
example.hasOwnProperty("prop"); // false

example.prop = "exists";
example.hasOwnProperty("prop"); // true - 'prop' has been defined

example.prop = null;
example.hasOwnProperty("prop"); // true - own property exists with value of null

example.prop = undefined;
example.hasOwnProperty("prop"); // true - own property exists with value of undefined
Direct vs. inherited propertiesThe following example differentiates between direct properties and properties inherited through the prototype chain:
jsconst example = {};
example.prop = "exists";

// `hasOwnProperty` will only return true for direct properties:
example.hasOwnProperty("prop"); // true
example.hasOwnProperty("toString"); // false
example.hasOwnProperty("hasOwnProperty"); // false

// The `in` operator will return true for direct or inherited properties:
"prop" in example; // true
"toString" in example; // true
"hasOwnProperty" in example; // true
Iterating over the properties of an objectThe following example shows how to iterate over the enumerable properties of an
object without executing on inherited properties.
jsconst buz = {
  fog: "stack",
};

for (const name in buz) {
  if (buz.hasOwnProperty(name)) {
    console.log(`this is fog (${name}) for sure. Value: ${buz[name]}`);
  } else {
    console.log(name); // toString or something else
  }
}

Note that the for...in loop
only iterates enumerable items: the absence of non-enumerable properties emitted
from the loop does not imply that hasOwnProperty itself is confined strictly
to enumerable items. You can iterate over non-enumerable properties with
Object.getOwnPropertyNames().Using hasOwnProperty as a property nameJavaScript does not protect the property name hasOwnProperty; an object that
has a property with this name may return incorrect results:
jsconst foo = {
  hasOwnProperty() {
    return false;
  },
  bar: "Here be dragons",
};

foo.hasOwnProperty("bar"); // re-implementation always returns false

The recommended way to overcome this problem is to instead use
Object.hasOwn() (in browsers that support it). Other
alternatives include using an external hasOwnProperty:
jsconst foo = { bar: "Here be dragons" };

// Use Object.hasOwn() method - recommended
Object.hasOwn(foo, "bar"); // true

// Use the hasOwnProperty property from the Object prototype
Object.prototype.hasOwnProperty.call(foo, "bar"); // true

// Use another Object's hasOwnProperty
// and call it with 'this' set to foo
({}).hasOwnProperty.call(foo, "bar"); // true

Note that in the first two cases there are no newly created objects.Objects created with Object.create(null)null-prototype objects do not
inherit from Object.prototype, making hasOwnProperty() inaccessible.
jsconst foo = Object.create(null);
foo.prop = "exists";
foo.hasOwnProperty("prop"); // Uncaught TypeError: foo.hasOwnProperty is not a function

The solutions in this case are the same as for the previous section: use
Object.hasOwn() by preference, otherwise use an
external object's hasOwnProperty().SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object.prototype.hasownpropertyBrowser compatibilitySee also
Object.hasOwn()
Enumerability and ownership of properties
Object.getOwnPropertyNames()
for...in
in
Inheritance and the prototype chain\n\nObject.prototype.hasOwnProperty()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe hasOwnProperty() method of Object instances returns a boolean indicating whether this
object has the specified property as its own property (as opposed to inheriting
it).

Note: Object.hasOwn() is recommended over
hasOwnProperty(), in browsers where it is supported.
Try it
const object1 = {};
object1.property1 = 42;

console.log(object1.hasOwnProperty("property1"));
// Expected output: true

console.log(object1.hasOwnProperty("toString"));
// Expected output: false

console.log(object1.hasOwnProperty("hasOwnProperty"));
// Expected output: false
SyntaxjshasOwnProperty(prop)
Parameters
prop

The String name or Symbol of the property to test.

Return valueReturns true if the object has the specified property as own property; false
otherwise.DescriptionThe hasOwnProperty() method returns true if the specified property is a
direct property of the object — even if the value is null or undefined. The
method returns false if the property is inherited, or has not been declared at
all. Unlike the in operator, this
method does not check for the specified property in the object's prototype
chain.
The method can be called on most JavaScript objects, because most objects
descend from Object, and hence inherit its methods. For
example Array is an Object, so you can
use hasOwnProperty() method to check whether an index exists:
jsconst fruits = ["Apple", "Banana", "Watermelon", "Orange"];
fruits.hasOwnProperty(3); // true ('Orange')
fruits.hasOwnProperty(4); // false - not defined

The method will not be available in objects where it is reimplemented, or on
null-prototype objects (as these don't inherit from
Object.prototype). Examples for these cases are given below.ExamplesUsing hasOwnProperty to test for an own property's existenceThe following code shows how to determine whether the example object contains a property named prop.
jsconst example = {};
example.hasOwnProperty("prop"); // false

example.prop = "exists";
example.hasOwnProperty("prop"); // true - 'prop' has been defined

example.prop = null;
example.hasOwnProperty("prop"); // true - own property exists with value of null

example.prop = undefined;
example.hasOwnProperty("prop"); // true - own property exists with value of undefined
Direct vs. inherited propertiesThe following example differentiates between direct properties and properties inherited through the prototype chain:
jsconst example = {};
example.prop = "exists";

// `hasOwnProperty` will only return true for direct properties:
example.hasOwnProperty("prop"); // true
example.hasOwnProperty("toString"); // false
example.hasOwnProperty("hasOwnProperty"); // false

// The `in` operator will return true for direct or inherited properties:
"prop" in example; // true
"toString" in example; // true
"hasOwnProperty" in example; // true
Iterating over the properties of an objectThe following example shows how to iterate over the enumerable properties of an
object without executing on inherited properties.
jsconst buz = {
  fog: "stack",
};

for (const name in buz) {
  if (buz.hasOwnProperty(name)) {
    console.log(`this is fog (${name}) for sure. Value: ${buz[name]}`);
  } else {
    console.log(name); // toString or something else
  }
}

Note that the for...in loop
only iterates enumerable items: the absence of non-enumerable properties emitted
from the loop does not imply that hasOwnProperty itself is confined strictly
to enumerable items. You can iterate over non-enumerable properties with
Object.getOwnPropertyNames().Using hasOwnProperty as a property nameJavaScript does not protect the property name hasOwnProperty; an object that
has a property with this name may return incorrect results:
jsconst foo = {
  hasOwnProperty() {
    return false;
  },
  bar: "Here be dragons",
};

foo.hasOwnProperty("bar"); // re-implementation always returns false

The recommended way to overcome this problem is to instead use
Object.hasOwn() (in browsers that support it). Other
alternatives include using an external hasOwnProperty:
jsconst foo = { bar: "Here be dragons" };

// Use Object.hasOwn() method - recommended
Object.hasOwn(foo, "bar"); // true

// Use the hasOwnProperty property from the Object prototype
Object.prototype.hasOwnProperty.call(foo, "bar"); // true

// Use another Object's hasOwnProperty
// and call it with 'this' set to foo
({}).hasOwnProperty.call(foo, "bar"); // true

Note that in the first two cases there are no newly created objects.Objects created with Object.create(null)null-prototype objects do not
inherit from Object.prototype, making hasOwnProperty() inaccessible.
jsconst foo = Object.create(null);
foo.prop = "exists";
foo.hasOwnProperty("prop"); // Uncaught TypeError: foo.hasOwnProperty is not a function

The solutions in this case are the same as for the previous section: use
Object.hasOwn() by preference, otherwise use an
external object's hasOwnProperty().SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object.prototype.hasownpropertyBrowser compatibilitySee also
Object.hasOwn()
Enumerability and ownership of properties
Object.getOwnPropertyNames()
for...in
in
Inheritance and the prototype chain
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nObject.prototype.hasOwnProperty()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe hasOwnProperty() method of Object instances returns a boolean indicating whether this
object has the specified property as its own property (as opposed to inheriting
it).

Note: Object.hasOwn() is recommended over
hasOwnProperty(), in browsers where it is supported.
Try it
const object1 = {};
object1.property1 = 42;

console.log(object1.hasOwnProperty("property1"));
// Expected output: true

console.log(object1.hasOwnProperty("toString"));
// Expected output: false

console.log(object1.hasOwnProperty("hasOwnProperty"));
// Expected output: false
SyntaxjshasOwnProperty(prop)
Parameters
prop

The String name or Symbol of the property to test.

Return valueReturns true if the object has the specified property as own property; false
otherwise.DescriptionThe hasOwnProperty() method returns true if the specified property is a
direct property of the object — even if the value is null or undefined. The
method returns false if the property is inherited, or has not been declared at
all. Unlike the in operator, this
method does not check for the specified property in the object's prototype
chain.
The method can be called on most JavaScript objects, because most objects
descend from Object, and hence inherit its methods. For
example Array is an Object, so you can
use hasOwnProperty() method to check whether an index exists:
jsconst fruits = ["Apple", "Banana", "Watermelon", "Orange"];
fruits.hasOwnProperty(3); // true ('Orange')
fruits.hasOwnProperty(4); // false - not defined

The method will not be available in objects where it is reimplemented, or on
null-prototype objects (as these don't inherit from
Object.prototype). Examples for these cases are given below.ExamplesUsing hasOwnProperty to test for an own property's existenceThe following code shows how to determine whether the example object contains a property named prop.
jsconst example = {};
example.hasOwnProperty("prop"); // false

example.prop = "exists";
example.hasOwnProperty("prop"); // true - 'prop' has been defined

example.prop = null;
example.hasOwnProperty("prop"); // true - own property exists with value of null

example.prop = undefined;
example.hasOwnProperty("prop"); // true - own property exists with value of undefined
Direct vs. inherited propertiesThe following example differentiates between direct properties and properties inherited through the prototype chain:
jsconst example = {};
example.prop = "exists";

// `hasOwnProperty` will only return true for direct properties:
example.hasOwnProperty("prop"); // true
example.hasOwnProperty("toString"); // false
example.hasOwnProperty("hasOwnProperty"); // false

// The `in` operator will return true for direct or inherited properties:
"prop" in example; // true
"toString" in example; // true
"hasOwnProperty" in example; // true
Iterating over the properties of an objectThe following example shows how to iterate over the enumerable properties of an
object without executing on inherited properties.
jsconst buz = {
  fog: "stack",
};

for (const name in buz) {
  if (buz.hasOwnProperty(name)) {
    console.log(`this is fog (${name}) for sure. Value: ${buz[name]}`);
  } else {
    console.log(name); // toString or something else
  }
}

Note that the for...in loop
only iterates enumerable items: the absence of non-enumerable properties emitted
from the loop does not imply that hasOwnProperty itself is confined strictly
to enumerable items. You can iterate over non-enumerable properties with
Object.getOwnPropertyNames().Using hasOwnProperty as a property nameJavaScript does not protect the property name hasOwnProperty; an object that
has a property with this name may return incorrect results:
jsconst foo = {
  hasOwnProperty() {
    return false;
  },
  bar: "Here be dragons",
};

foo.hasOwnProperty("bar"); // re-implementation always returns false

The recommended way to overcome this problem is to instead use
Object.hasOwn() (in browsers that support it). Other
alternatives include using an external hasOwnProperty:
jsconst foo = { bar: "Here be dragons" };

// Use Object.hasOwn() method - recommended
Object.hasOwn(foo, "bar"); // true

// Use the hasOwnProperty property from the Object prototype
Object.prototype.hasOwnProperty.call(foo, "bar"); // true

// Use another Object's hasOwnProperty
// and call it with 'this' set to foo
({}).hasOwnProperty.call(foo, "bar"); // true

Note that in the first two cases there are no newly created objects.Objects created with Object.create(null)null-prototype objects do not
inherit from Object.prototype, making hasOwnProperty() inaccessible.
jsconst foo = Object.create(null);
foo.prop = "exists";
foo.hasOwnProperty("prop"); // Uncaught TypeError: foo.hasOwnProperty is not a function

The solutions in this case are the same as for the previous section: use
Object.hasOwn() by preference, otherwise use an
external object's hasOwnProperty().SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object.prototype.hasownpropertyBrowser compatibilitySee also
Object.hasOwn()
Enumerability and ownership of properties
Object.getOwnPropertyNames()
for...in
in
Inheritance and the prototype chain
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nObject.prototype.isPrototypeOf()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe isPrototypeOf() method of Object instances checks if this object exists in another object's prototype chain.

Note: isPrototypeOf() differs from the instanceof operator. In the expression object instanceof AFunction, object's prototype chain is checked against AFunction.prototype, not against AFunction itself.
Try it
function Foo() {}
function Bar() {}

Bar.prototype = Object.create(Foo.prototype);

const bar = new Bar();

console.log(Foo.prototype.isPrototypeOf(bar));
// Expected output: true
console.log(Bar.prototype.isPrototypeOf(bar));
// Expected output: true
SyntaxjsisPrototypeOf(object)
Parameters
object

The object whose prototype chain will be searched.

Return valueA boolean indicating whether the calling object (this) lies in the prototype chain of object. Directly returns false when object is not an object (i.e., a primitive).Exceptions
TypeError

Thrown if this is null or undefined (because it can't be converted to an object).

DescriptionAll objects that inherit from Object.prototype (that is, all except null-prototype objects) inherit the isPrototypeOf() method. This method allows you to check whether or not the object exists within another object's prototype chain. If the object passed as the parameter is not an object (i.e., a primitive), the method directly returns false. Otherwise, the this value is converted to an object, and the prototype chain of object is searched for the this value, until the end of the chain is reached or the this value is found.ExamplesUsing isPrototypeOf()This example demonstrates that Baz.prototype, Bar.prototype, Foo.prototype and Object.prototype exist in the prototype chain for object baz:
jsclass Foo {}
class Bar extends Foo {}
class Baz extends Bar {}

const foo = new Foo();
const bar = new Bar();
const baz = new Baz();

// prototype chains:
// foo: Foo --> Object
// bar: Bar --> Foo --> Object
// baz: Baz --> Bar --> Foo --> Object
console.log(Baz.prototype.isPrototypeOf(baz)); // true
console.log(Baz.prototype.isPrototypeOf(bar)); // false
console.log(Baz.prototype.isPrototypeOf(foo)); // false
console.log(Bar.prototype.isPrototypeOf(baz)); // true
console.log(Bar.prototype.isPrototypeOf(foo)); // false
console.log(Foo.prototype.isPrototypeOf(baz)); // true
console.log(Foo.prototype.isPrototypeOf(bar)); // true
console.log(Object.prototype.isPrototypeOf(baz)); // true

The isPrototypeOf() method — along with the instanceof operator — comes in particularly handy if you have code that can only function when dealing with objects descended from a specific prototype chain; e.g., to guarantee that certain methods or properties will be present on that object.
For example, to execute some code that's only safe to run if a baz object has Foo.prototype in its prototype chain, you can do this:
jsif (Foo.prototype.isPrototypeOf(baz)) {
  // do something safe
}

However, Foo.prototype existing in baz's prototype chain doesn't imply baz was created using Foo as its constructor. For example, baz could be directly assigned with Foo.prototype as its prototype. In this case, if your code reads private fields of Foo from baz, it would still fail:
jsclass Foo {
  #value = "foo";
  static getValue(x) {
    return x.#value;
  }
}

const baz = { __proto__: Foo.prototype };

if (Foo.prototype.isPrototypeOf(baz)) {
  console.log(Foo.getValue(baz)); // TypeError: Cannot read private member #value from an object whose class did not declare it
}

The same applies to instanceof. If you need to read private fields in a secure way, offer a branded check method using in instead.
jsclass Foo {
  #value = "foo";
  static getValue(x) {
    return x.#value;
  }
  static isFoo(x) {
    return #value in x;
  }
}

const baz = { __proto__: Foo.prototype };

if (Foo.isFoo(baz)) {
  // Doesn't run, because baz is not a Foo
  console.log(Foo.getValue(baz));
}
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object.prototype.isprototypeofBrowser compatibilitySee also
instanceof
Object.getPrototypeOf()
Object.setPrototypeOf()
Inheritance and the prototype chain\n\nObject.prototype.isPrototypeOf()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe isPrototypeOf() method of Object instances checks if this object exists in another object's prototype chain.

Note: isPrototypeOf() differs from the instanceof operator. In the expression object instanceof AFunction, object's prototype chain is checked against AFunction.prototype, not against AFunction itself.
Try it
function Foo() {}
function Bar() {}

Bar.prototype = Object.create(Foo.prototype);

const bar = new Bar();

console.log(Foo.prototype.isPrototypeOf(bar));
// Expected output: true
console.log(Bar.prototype.isPrototypeOf(bar));
// Expected output: true
SyntaxjsisPrototypeOf(object)
Parameters
object

The object whose prototype chain will be searched.

Return valueA boolean indicating whether the calling object (this) lies in the prototype chain of object. Directly returns false when object is not an object (i.e., a primitive).Exceptions
TypeError

Thrown if this is null or undefined (because it can't be converted to an object).

DescriptionAll objects that inherit from Object.prototype (that is, all except null-prototype objects) inherit the isPrototypeOf() method. This method allows you to check whether or not the object exists within another object's prototype chain. If the object passed as the parameter is not an object (i.e., a primitive), the method directly returns false. Otherwise, the this value is converted to an object, and the prototype chain of object is searched for the this value, until the end of the chain is reached or the this value is found.ExamplesUsing isPrototypeOf()This example demonstrates that Baz.prototype, Bar.prototype, Foo.prototype and Object.prototype exist in the prototype chain for object baz:
jsclass Foo {}
class Bar extends Foo {}
class Baz extends Bar {}

const foo = new Foo();
const bar = new Bar();
const baz = new Baz();

// prototype chains:
// foo: Foo --> Object
// bar: Bar --> Foo --> Object
// baz: Baz --> Bar --> Foo --> Object
console.log(Baz.prototype.isPrototypeOf(baz)); // true
console.log(Baz.prototype.isPrototypeOf(bar)); // false
console.log(Baz.prototype.isPrototypeOf(foo)); // false
console.log(Bar.prototype.isPrototypeOf(baz)); // true
console.log(Bar.prototype.isPrototypeOf(foo)); // false
console.log(Foo.prototype.isPrototypeOf(baz)); // true
console.log(Foo.prototype.isPrototypeOf(bar)); // true
console.log(Object.prototype.isPrototypeOf(baz)); // true

The isPrototypeOf() method — along with the instanceof operator — comes in particularly handy if you have code that can only function when dealing with objects descended from a specific prototype chain; e.g., to guarantee that certain methods or properties will be present on that object.
For example, to execute some code that's only safe to run if a baz object has Foo.prototype in its prototype chain, you can do this:
jsif (Foo.prototype.isPrototypeOf(baz)) {
  // do something safe
}

However, Foo.prototype existing in baz's prototype chain doesn't imply baz was created using Foo as its constructor. For example, baz could be directly assigned with Foo.prototype as its prototype. In this case, if your code reads private fields of Foo from baz, it would still fail:
jsclass Foo {
  #value = "foo";
  static getValue(x) {
    return x.#value;
  }
}

const baz = { __proto__: Foo.prototype };

if (Foo.prototype.isPrototypeOf(baz)) {
  console.log(Foo.getValue(baz)); // TypeError: Cannot read private member #value from an object whose class did not declare it
}

The same applies to instanceof. If you need to read private fields in a secure way, offer a branded check method using in instead.
jsclass Foo {
  #value = "foo";
  static getValue(x) {
    return x.#value;
  }
  static isFoo(x) {
    return #value in x;
  }
}

const baz = { __proto__: Foo.prototype };

if (Foo.isFoo(baz)) {
  // Doesn't run, because baz is not a Foo
  console.log(Foo.getValue(baz));
}
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object.prototype.isprototypeofBrowser compatibilitySee also
instanceof
Object.getPrototypeOf()
Object.setPrototypeOf()
Inheritance and the prototype chain
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nObject.prototype.isPrototypeOf()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe isPrototypeOf() method of Object instances checks if this object exists in another object's prototype chain.

Note: isPrototypeOf() differs from the instanceof operator. In the expression object instanceof AFunction, object's prototype chain is checked against AFunction.prototype, not against AFunction itself.
Try it
function Foo() {}
function Bar() {}

Bar.prototype = Object.create(Foo.prototype);

const bar = new Bar();

console.log(Foo.prototype.isPrototypeOf(bar));
// Expected output: true
console.log(Bar.prototype.isPrototypeOf(bar));
// Expected output: true
SyntaxjsisPrototypeOf(object)
Parameters
object

The object whose prototype chain will be searched.

Return valueA boolean indicating whether the calling object (this) lies in the prototype chain of object. Directly returns false when object is not an object (i.e., a primitive).Exceptions
TypeError

Thrown if this is null or undefined (because it can't be converted to an object).

DescriptionAll objects that inherit from Object.prototype (that is, all except null-prototype objects) inherit the isPrototypeOf() method. This method allows you to check whether or not the object exists within another object's prototype chain. If the object passed as the parameter is not an object (i.e., a primitive), the method directly returns false. Otherwise, the this value is converted to an object, and the prototype chain of object is searched for the this value, until the end of the chain is reached or the this value is found.ExamplesUsing isPrototypeOf()This example demonstrates that Baz.prototype, Bar.prototype, Foo.prototype and Object.prototype exist in the prototype chain for object baz:
jsclass Foo {}
class Bar extends Foo {}
class Baz extends Bar {}

const foo = new Foo();
const bar = new Bar();
const baz = new Baz();

// prototype chains:
// foo: Foo --> Object
// bar: Bar --> Foo --> Object
// baz: Baz --> Bar --> Foo --> Object
console.log(Baz.prototype.isPrototypeOf(baz)); // true
console.log(Baz.prototype.isPrototypeOf(bar)); // false
console.log(Baz.prototype.isPrototypeOf(foo)); // false
console.log(Bar.prototype.isPrototypeOf(baz)); // true
console.log(Bar.prototype.isPrototypeOf(foo)); // false
console.log(Foo.prototype.isPrototypeOf(baz)); // true
console.log(Foo.prototype.isPrototypeOf(bar)); // true
console.log(Object.prototype.isPrototypeOf(baz)); // true

The isPrototypeOf() method — along with the instanceof operator — comes in particularly handy if you have code that can only function when dealing with objects descended from a specific prototype chain; e.g., to guarantee that certain methods or properties will be present on that object.
For example, to execute some code that's only safe to run if a baz object has Foo.prototype in its prototype chain, you can do this:
jsif (Foo.prototype.isPrototypeOf(baz)) {
  // do something safe
}

However, Foo.prototype existing in baz's prototype chain doesn't imply baz was created using Foo as its constructor. For example, baz could be directly assigned with Foo.prototype as its prototype. In this case, if your code reads private fields of Foo from baz, it would still fail:
jsclass Foo {
  #value = "foo";
  static getValue(x) {
    return x.#value;
  }
}

const baz = { __proto__: Foo.prototype };

if (Foo.prototype.isPrototypeOf(baz)) {
  console.log(Foo.getValue(baz)); // TypeError: Cannot read private member #value from an object whose class did not declare it
}

The same applies to instanceof. If you need to read private fields in a secure way, offer a branded check method using in instead.
jsclass Foo {
  #value = "foo";
  static getValue(x) {
    return x.#value;
  }
  static isFoo(x) {
    return #value in x;
  }
}

const baz = { __proto__: Foo.prototype };

if (Foo.isFoo(baz)) {
  // Doesn't run, because baz is not a Foo
  console.log(Foo.getValue(baz));
}
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object.prototype.isprototypeofBrowser compatibilitySee also
instanceof
Object.getPrototypeOf()
Object.setPrototypeOf()
Inheritance and the prototype chain
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nObject.prototype.propertyIsEnumerable()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe propertyIsEnumerable() method of Object instances returns a boolean indicating whether the specified property is this object's enumerable own property.Try it
const object1 = {};
const array1 = [];
object1.property1 = 42;
array1[0] = 42;

console.log(object1.propertyIsEnumerable("property1"));
// Expected output: true

console.log(array1.propertyIsEnumerable(0));
// Expected output: true

console.log(array1.propertyIsEnumerable("length"));
// Expected output: false
SyntaxjspropertyIsEnumerable(prop)
Parameters
prop

The name of the property to test. Can be a string or a Symbol.

Return valueA boolean value indicating whether the specified property is enumerable and is the object's own property.DescriptionAll objects that inherit from Object.prototype (that is, all except null-prototype objects) inherit the propertyIsEnumerable() method. This method determines if the specified property, string or symbol, is an enumerable own property of the object. If the object does not have the specified property, this method returns false.
This method is equivalent to Object.getOwnPropertyDescriptor(obj, prop)?.enumerable ?? false.ExamplesUsing propertyIsEnumerable()The following example shows the use of propertyIsEnumerable() on objects and arrays.
jsconst o = {};
const a = [];
o.prop = "is enumerable";
a[0] = "is enumerable";

o.propertyIsEnumerable("prop"); // true
a.propertyIsEnumerable(0); // true
User-defined vs. built-in objectsMost built-in properties are non-enumerable by default, while user-created object properties are often enumerable, unless explicitly designated otherwise.
jsconst a = ["is enumerable"];

a.propertyIsEnumerable(0); // true
a.propertyIsEnumerable("length"); // false

Math.propertyIsEnumerable("random"); // false
globalThis.propertyIsEnumerable("Math"); // false
Direct vs. inherited propertiesOnly enumerable own properties cause propertyIsEnumerable() to return true, although all enumerable properties, including inherited ones, are visited by the for...in loop.
jsconst o1 = {
  enumerableInherited: "is enumerable",
};
Object.defineProperty(o1, "nonEnumerableInherited", {
  value: "is non-enumerable",
  enumerable: false,
});
const o2 = {
  // o1 is the prototype of o2
  __proto__: o1,
  enumerableOwn: "is enumerable",
};
Object.defineProperty(o2, "nonEnumerableOwn", {
  value: "is non-enumerable",
  enumerable: false,
});

o2.propertyIsEnumerable("enumerableInherited"); // false
o2.propertyIsEnumerable("nonEnumerableInherited"); // false
o2.propertyIsEnumerable("enumerableOwn"); // true
o2.propertyIsEnumerable("nonEnumerableOwn"); // false
Testing symbol propertiesSymbol properties are also supported by propertyIsEnumerable(). Note that most enumeration methods only visit string properties; enumerability of symbol properties is only useful when using Object.assign() or spread syntax. For more information, see Enumerability and ownership of properties.
jsconst sym = Symbol("enumerable");
const sym2 = Symbol("non-enumerable");
const o = {
  [sym]: "is enumerable",
};
Object.defineProperty(o, sym2, {
  value: "is non-enumerable",
  enumerable: false,
});

o.propertyIsEnumerable(sym); // true
o.propertyIsEnumerable(sym2); // false
Usage with null-prototype objectsBecause null-prototype objects do not inherit from Object.prototype, they do not inherit the propertyIsEnumerable() method. You must call Object.prototype.propertyIsEnumerable with the object as this instead.
jsconst o = {
  __proto__: null,
  enumerableOwn: "is enumerable",
};

o.propertyIsEnumerable("enumerableOwn"); // TypeError: o.propertyIsEnumerable is not a function
Object.prototype.propertyIsEnumerable.call(o, "enumerableOwn"); // true

Alternatively, you may use Object.getOwnPropertyDescriptor() instead, which also helps to distinguish between non-existent properties and actually non-enumerable properties.
jsconst o = {
  __proto__: null,
  enumerableOwn: "is enumerable",
};

Object.getOwnPropertyDescriptor(o, "enumerableOwn")?.enumerable; // true
Object.getOwnPropertyDescriptor(o, "nonExistent")?.enumerable; // undefined
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object.prototype.propertyisenumerableBrowser compatibilitySee also
Enumerability and ownership of properties
for...in
Object.keys()
Object.defineProperty()\n\nObject.prototype.propertyIsEnumerable()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe propertyIsEnumerable() method of Object instances returns a boolean indicating whether the specified property is this object's enumerable own property.Try it
const object1 = {};
const array1 = [];
object1.property1 = 42;
array1[0] = 42;

console.log(object1.propertyIsEnumerable("property1"));
// Expected output: true

console.log(array1.propertyIsEnumerable(0));
// Expected output: true

console.log(array1.propertyIsEnumerable("length"));
// Expected output: false
SyntaxjspropertyIsEnumerable(prop)
Parameters
prop

The name of the property to test. Can be a string or a Symbol.

Return valueA boolean value indicating whether the specified property is enumerable and is the object's own property.DescriptionAll objects that inherit from Object.prototype (that is, all except null-prototype objects) inherit the propertyIsEnumerable() method. This method determines if the specified property, string or symbol, is an enumerable own property of the object. If the object does not have the specified property, this method returns false.
This method is equivalent to Object.getOwnPropertyDescriptor(obj, prop)?.enumerable ?? false.ExamplesUsing propertyIsEnumerable()The following example shows the use of propertyIsEnumerable() on objects and arrays.
jsconst o = {};
const a = [];
o.prop = "is enumerable";
a[0] = "is enumerable";

o.propertyIsEnumerable("prop"); // true
a.propertyIsEnumerable(0); // true
User-defined vs. built-in objectsMost built-in properties are non-enumerable by default, while user-created object properties are often enumerable, unless explicitly designated otherwise.
jsconst a = ["is enumerable"];

a.propertyIsEnumerable(0); // true
a.propertyIsEnumerable("length"); // false

Math.propertyIsEnumerable("random"); // false
globalThis.propertyIsEnumerable("Math"); // false
Direct vs. inherited propertiesOnly enumerable own properties cause propertyIsEnumerable() to return true, although all enumerable properties, including inherited ones, are visited by the for...in loop.
jsconst o1 = {
  enumerableInherited: "is enumerable",
};
Object.defineProperty(o1, "nonEnumerableInherited", {
  value: "is non-enumerable",
  enumerable: false,
});
const o2 = {
  // o1 is the prototype of o2
  __proto__: o1,
  enumerableOwn: "is enumerable",
};
Object.defineProperty(o2, "nonEnumerableOwn", {
  value: "is non-enumerable",
  enumerable: false,
});

o2.propertyIsEnumerable("enumerableInherited"); // false
o2.propertyIsEnumerable("nonEnumerableInherited"); // false
o2.propertyIsEnumerable("enumerableOwn"); // true
o2.propertyIsEnumerable("nonEnumerableOwn"); // false
Testing symbol propertiesSymbol properties are also supported by propertyIsEnumerable(). Note that most enumeration methods only visit string properties; enumerability of symbol properties is only useful when using Object.assign() or spread syntax. For more information, see Enumerability and ownership of properties.
jsconst sym = Symbol("enumerable");
const sym2 = Symbol("non-enumerable");
const o = {
  [sym]: "is enumerable",
};
Object.defineProperty(o, sym2, {
  value: "is non-enumerable",
  enumerable: false,
});

o.propertyIsEnumerable(sym); // true
o.propertyIsEnumerable(sym2); // false
Usage with null-prototype objectsBecause null-prototype objects do not inherit from Object.prototype, they do not inherit the propertyIsEnumerable() method. You must call Object.prototype.propertyIsEnumerable with the object as this instead.
jsconst o = {
  __proto__: null,
  enumerableOwn: "is enumerable",
};

o.propertyIsEnumerable("enumerableOwn"); // TypeError: o.propertyIsEnumerable is not a function
Object.prototype.propertyIsEnumerable.call(o, "enumerableOwn"); // true

Alternatively, you may use Object.getOwnPropertyDescriptor() instead, which also helps to distinguish between non-existent properties and actually non-enumerable properties.
jsconst o = {
  __proto__: null,
  enumerableOwn: "is enumerable",
};

Object.getOwnPropertyDescriptor(o, "enumerableOwn")?.enumerable; // true
Object.getOwnPropertyDescriptor(o, "nonExistent")?.enumerable; // undefined
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object.prototype.propertyisenumerableBrowser compatibilitySee also
Enumerability and ownership of properties
for...in
Object.keys()
Object.defineProperty()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nObject.prototype.propertyIsEnumerable()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe propertyIsEnumerable() method of Object instances returns a boolean indicating whether the specified property is this object's enumerable own property.Try it
const object1 = {};
const array1 = [];
object1.property1 = 42;
array1[0] = 42;

console.log(object1.propertyIsEnumerable("property1"));
// Expected output: true

console.log(array1.propertyIsEnumerable(0));
// Expected output: true

console.log(array1.propertyIsEnumerable("length"));
// Expected output: false
SyntaxjspropertyIsEnumerable(prop)
Parameters
prop

The name of the property to test. Can be a string or a Symbol.

Return valueA boolean value indicating whether the specified property is enumerable and is the object's own property.DescriptionAll objects that inherit from Object.prototype (that is, all except null-prototype objects) inherit the propertyIsEnumerable() method. This method determines if the specified property, string or symbol, is an enumerable own property of the object. If the object does not have the specified property, this method returns false.
This method is equivalent to Object.getOwnPropertyDescriptor(obj, prop)?.enumerable ?? false.ExamplesUsing propertyIsEnumerable()The following example shows the use of propertyIsEnumerable() on objects and arrays.
jsconst o = {};
const a = [];
o.prop = "is enumerable";
a[0] = "is enumerable";

o.propertyIsEnumerable("prop"); // true
a.propertyIsEnumerable(0); // true
User-defined vs. built-in objectsMost built-in properties are non-enumerable by default, while user-created object properties are often enumerable, unless explicitly designated otherwise.
jsconst a = ["is enumerable"];

a.propertyIsEnumerable(0); // true
a.propertyIsEnumerable("length"); // false

Math.propertyIsEnumerable("random"); // false
globalThis.propertyIsEnumerable("Math"); // false
Direct vs. inherited propertiesOnly enumerable own properties cause propertyIsEnumerable() to return true, although all enumerable properties, including inherited ones, are visited by the for...in loop.
jsconst o1 = {
  enumerableInherited: "is enumerable",
};
Object.defineProperty(o1, "nonEnumerableInherited", {
  value: "is non-enumerable",
  enumerable: false,
});
const o2 = {
  // o1 is the prototype of o2
  __proto__: o1,
  enumerableOwn: "is enumerable",
};
Object.defineProperty(o2, "nonEnumerableOwn", {
  value: "is non-enumerable",
  enumerable: false,
});

o2.propertyIsEnumerable("enumerableInherited"); // false
o2.propertyIsEnumerable("nonEnumerableInherited"); // false
o2.propertyIsEnumerable("enumerableOwn"); // true
o2.propertyIsEnumerable("nonEnumerableOwn"); // false
Testing symbol propertiesSymbol properties are also supported by propertyIsEnumerable(). Note that most enumeration methods only visit string properties; enumerability of symbol properties is only useful when using Object.assign() or spread syntax. For more information, see Enumerability and ownership of properties.
jsconst sym = Symbol("enumerable");
const sym2 = Symbol("non-enumerable");
const o = {
  [sym]: "is enumerable",
};
Object.defineProperty(o, sym2, {
  value: "is non-enumerable",
  enumerable: false,
});

o.propertyIsEnumerable(sym); // true
o.propertyIsEnumerable(sym2); // false
Usage with null-prototype objectsBecause null-prototype objects do not inherit from Object.prototype, they do not inherit the propertyIsEnumerable() method. You must call Object.prototype.propertyIsEnumerable with the object as this instead.
jsconst o = {
  __proto__: null,
  enumerableOwn: "is enumerable",
};

o.propertyIsEnumerable("enumerableOwn"); // TypeError: o.propertyIsEnumerable is not a function
Object.prototype.propertyIsEnumerable.call(o, "enumerableOwn"); // true

Alternatively, you may use Object.getOwnPropertyDescriptor() instead, which also helps to distinguish between non-existent properties and actually non-enumerable properties.
jsconst o = {
  __proto__: null,
  enumerableOwn: "is enumerable",
};

Object.getOwnPropertyDescriptor(o, "enumerableOwn")?.enumerable; // true
Object.getOwnPropertyDescriptor(o, "nonExistent")?.enumerable; // undefined
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object.prototype.propertyisenumerableBrowser compatibilitySee also
Enumerability and ownership of properties
for...in
Object.keys()
Object.defineProperty()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nObject.prototype.toLocaleString()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.Learn moreSee full compatibilityReport feedbackThe toLocaleString() method of Object instances returns a string representing this object. This method is meant to be overridden by derived objects for locale-specific purposes.Try it
const date1 = new Date(Date.UTC(2012, 11, 20, 3, 0, 0));

console.log(date1.toLocaleString("ar-EG"));
// Expected output: "٢٠‏/١٢‏/٢٠١٢ ٤:٠٠:٠٠ ص"

const number1 = 123456.789;

console.log(number1.toLocaleString("de-DE"));
// Expected output: "123.456,789"
SyntaxjstoLocaleString()
ParametersNone. However, all objects that override this method are expected to accept at most two parameters, corresponding to locales and options, such as Number.prototype.toLocaleString. The parameter positions should not be used for any other purpose.Return valueThe return value of calling this.toString().DescriptionAll objects that inherit from Object.prototype (that is, all except null-prototype objects) inherit the toLocaleString() method. Object's toLocaleString returns the result of calling this.toString().
This function is provided to give objects a generic toLocaleString method, even though not all may use it. In the core language, these built-in objects override toLocaleString to provide locale-specific formatting:

Array: Array.prototype.toLocaleString()
Number: Number.prototype.toLocaleString()
Date: Date.prototype.toLocaleString()
TypedArray: TypedArray.prototype.toLocaleString()
BigInt: BigInt.prototype.toLocaleString()
ExamplesUsing the base toLocaleString() methodThe base toLocaleString() method simply calls toString().
jsconst obj = {
  toString() {
    return "My Object";
  },
};
console.log(obj.toLocaleString()); // "My Object"
Array toLocaleString() overrideArray.prototype.toLocaleString() is used to print array values as a string by invoking each element's toLocaleString() method and joining the results with a locale-specific separator. For example:
jsconst testArray = [4, 7, 10];

const euroPrices = testArray.toLocaleString("fr", {
  style: "currency",
  currency: "EUR",
});
// "4,00 €,7,00 €,10,00 €"
Date toLocaleString() overrideDate.prototype.toLocaleString() is used to print out date displays more suitable for specific locales. For example:
jsconst testDate = new Date();
// "Fri May 29 2020 18:04:24 GMT+0100 (British Summer Time)"

const deDate = testDate.toLocaleString("de");
// "29.5.2020, 18:04:24"

const frDate = testDate.toLocaleString("fr");
// "29/05/2020, 18:04:24"
Number toLocaleString() overrideNumber.prototype.toLocaleString() is used to print out number displays more suitable for specific locales, e.g., with the correct separators. For example:
jsconst testNumber = 2901234564;
// "2901234564"

const deNumber = testNumber.toLocaleString("de");
// "2.901.234.564"

const frNumber = testNumber.toLocaleString("fr");
// "2 901 234 564"
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object.prototype.tolocalestringBrowser compatibilitySee also
Object.prototype.toString()\n\nObject.prototype.toLocaleString()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.Learn moreSee full compatibilityReport feedbackThe toLocaleString() method of Object instances returns a string representing this object. This method is meant to be overridden by derived objects for locale-specific purposes.Try it
const date1 = new Date(Date.UTC(2012, 11, 20, 3, 0, 0));

console.log(date1.toLocaleString("ar-EG"));
// Expected output: "٢٠‏/١٢‏/٢٠١٢ ٤:٠٠:٠٠ ص"

const number1 = 123456.789;

console.log(number1.toLocaleString("de-DE"));
// Expected output: "123.456,789"
SyntaxjstoLocaleString()
ParametersNone. However, all objects that override this method are expected to accept at most two parameters, corresponding to locales and options, such as Number.prototype.toLocaleString. The parameter positions should not be used for any other purpose.Return valueThe return value of calling this.toString().DescriptionAll objects that inherit from Object.prototype (that is, all except null-prototype objects) inherit the toLocaleString() method. Object's toLocaleString returns the result of calling this.toString().
This function is provided to give objects a generic toLocaleString method, even though not all may use it. In the core language, these built-in objects override toLocaleString to provide locale-specific formatting:

Array: Array.prototype.toLocaleString()
Number: Number.prototype.toLocaleString()
Date: Date.prototype.toLocaleString()
TypedArray: TypedArray.prototype.toLocaleString()
BigInt: BigInt.prototype.toLocaleString()
ExamplesUsing the base toLocaleString() methodThe base toLocaleString() method simply calls toString().
jsconst obj = {
  toString() {
    return "My Object";
  },
};
console.log(obj.toLocaleString()); // "My Object"
Array toLocaleString() overrideArray.prototype.toLocaleString() is used to print array values as a string by invoking each element's toLocaleString() method and joining the results with a locale-specific separator. For example:
jsconst testArray = [4, 7, 10];

const euroPrices = testArray.toLocaleString("fr", {
  style: "currency",
  currency: "EUR",
});
// "4,00 €,7,00 €,10,00 €"
Date toLocaleString() overrideDate.prototype.toLocaleString() is used to print out date displays more suitable for specific locales. For example:
jsconst testDate = new Date();
// "Fri May 29 2020 18:04:24 GMT+0100 (British Summer Time)"

const deDate = testDate.toLocaleString("de");
// "29.5.2020, 18:04:24"

const frDate = testDate.toLocaleString("fr");
// "29/05/2020, 18:04:24"
Number toLocaleString() overrideNumber.prototype.toLocaleString() is used to print out number displays more suitable for specific locales, e.g., with the correct separators. For example:
jsconst testNumber = 2901234564;
// "2901234564"

const deNumber = testNumber.toLocaleString("de");
// "2.901.234.564"

const frNumber = testNumber.toLocaleString("fr");
// "2 901 234 564"
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object.prototype.tolocalestringBrowser compatibilitySee also
Object.prototype.toString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nObject.prototype.toLocaleString()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.Learn moreSee full compatibilityReport feedbackThe toLocaleString() method of Object instances returns a string representing this object. This method is meant to be overridden by derived objects for locale-specific purposes.Try it
const date1 = new Date(Date.UTC(2012, 11, 20, 3, 0, 0));

console.log(date1.toLocaleString("ar-EG"));
// Expected output: "٢٠‏/١٢‏/٢٠١٢ ٤:٠٠:٠٠ ص"

const number1 = 123456.789;

console.log(number1.toLocaleString("de-DE"));
// Expected output: "123.456,789"
SyntaxjstoLocaleString()
ParametersNone. However, all objects that override this method are expected to accept at most two parameters, corresponding to locales and options, such as Number.prototype.toLocaleString. The parameter positions should not be used for any other purpose.Return valueThe return value of calling this.toString().DescriptionAll objects that inherit from Object.prototype (that is, all except null-prototype objects) inherit the toLocaleString() method. Object's toLocaleString returns the result of calling this.toString().
This function is provided to give objects a generic toLocaleString method, even though not all may use it. In the core language, these built-in objects override toLocaleString to provide locale-specific formatting:

Array: Array.prototype.toLocaleString()
Number: Number.prototype.toLocaleString()
Date: Date.prototype.toLocaleString()
TypedArray: TypedArray.prototype.toLocaleString()
BigInt: BigInt.prototype.toLocaleString()
ExamplesUsing the base toLocaleString() methodThe base toLocaleString() method simply calls toString().
jsconst obj = {
  toString() {
    return "My Object";
  },
};
console.log(obj.toLocaleString()); // "My Object"
Array toLocaleString() overrideArray.prototype.toLocaleString() is used to print array values as a string by invoking each element's toLocaleString() method and joining the results with a locale-specific separator. For example:
jsconst testArray = [4, 7, 10];

const euroPrices = testArray.toLocaleString("fr", {
  style: "currency",
  currency: "EUR",
});
// "4,00 €,7,00 €,10,00 €"
Date toLocaleString() overrideDate.prototype.toLocaleString() is used to print out date displays more suitable for specific locales. For example:
jsconst testDate = new Date();
// "Fri May 29 2020 18:04:24 GMT+0100 (British Summer Time)"

const deDate = testDate.toLocaleString("de");
// "29.5.2020, 18:04:24"

const frDate = testDate.toLocaleString("fr");
// "29/05/2020, 18:04:24"
Number toLocaleString() overrideNumber.prototype.toLocaleString() is used to print out number displays more suitable for specific locales, e.g., with the correct separators. For example:
jsconst testNumber = 2901234564;
// "2901234564"

const deNumber = testNumber.toLocaleString("de");
// "2.901.234.564"

const frNumber = testNumber.toLocaleString("fr");
// "2 901 234 564"
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object.prototype.tolocalestringBrowser compatibilitySee also
Object.prototype.toString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nObject.prototype.toString()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe toString() method of Object instances returns a string representing this object. This method is meant to be overridden by derived objects for custom type coercion logic.Try it
function Dog(name) {
  this.name = name;
}

const dog1 = new Dog("Gabby");

Dog.prototype.toString = function dogToString() {
  return `${this.name}`;
};

console.log(dog1.toString());
// Expected output: "Gabby"
SyntaxjstoString()
ParametersBy default toString() takes no parameters. However, objects that inherit from Object may override it with their own implementations that do take parameters. For example, the Number.prototype.toString() and BigInt.prototype.toString() methods take an optional radix parameter.Return valueA string representing the object.DescriptionJavaScript calls the toString method to convert an object to a primitive value. You rarely need to invoke the toString method yourself; JavaScript automatically invokes it when encountering an object where a primitive value is expected.
This method is called in priority by string conversion, but numeric conversion and primitive conversion call valueOf() in priority. However, because the base valueOf() method returns an object, the toString() method is usually called in the end, unless the object overrides valueOf(). For example, +[1] returns 1, because its toString() method returns "1", which is then converted to a number.
All objects that inherit from Object.prototype (that is, all except null-prototype objects) inherit the toString() method. When you create a custom object, you can override toString() to call a custom method, so that your custom object can be converted to a string value. Alternatively, you can add a [Symbol.toPrimitive]() method, which allows even more control over the conversion process, and will always be preferred over valueOf or toString for any type conversion.
To use the base Object.prototype.toString() with an object that has it overridden (or to invoke it on null or undefined), you need to call Function.prototype.call() or Function.prototype.apply() on it, passing the object you want to inspect as the first parameter (called thisArg).
jsconst arr = [1, 2, 3];

arr.toString(); // "1,2,3"
Object.prototype.toString.call(arr); // "[object Array]"

Object.prototype.toString() returns "[object Type]", where Type is the object type. If the object has a Symbol.toStringTag property whose value is a string, that value will be used as the Type. Many built-in objects, including Map and Symbol, have a Symbol.toStringTag. Some objects predating ES6 do not have Symbol.toStringTag, but have a special tag nonetheless. They include (the tag is the same as the type name given below):

Array
Function (anything whose typeof returns "function")
Error
Boolean
Number
String
Date
RegExp

The arguments object returns "[object Arguments]". Everything else, including user-defined classes, unless with a custom Symbol.toStringTag, will return "[object Object]".
Object.prototype.toString() invoked on null and undefined returns [object Null] and [object Undefined], respectively.ExamplesOverriding toString for custom objectsYou can create a function to be called in place of the default toString() method. The toString() function you create should return a string value. If it returns an object and the method is called implicitly during type conversion, then its result is ignored and the value of a related method, valueOf(), is used instead, or a TypeError is thrown if none of these methods return a primitive.
The following code defines a Dog class.
jsclass Dog {
  constructor(name, breed, color, sex) {
    this.name = name;
    this.breed = breed;
    this.color = color;
    this.sex = sex;
  }
}

If you call the toString() method, either explicitly or implicitly, on an instance of Dog, it returns the default value inherited from Object:
jsconst theDog = new Dog("Gabby", "Lab", "chocolate", "female");

theDog.toString(); // "[object Object]"
`${theDog}`; // "[object Object]"

The following code overrides the default toString() method. This method generates a string containing the name, breed, color, and sex of the object.
jsclass Dog {
  constructor(name, breed, color, sex) {
    this.name = name;
    this.breed = breed;
    this.color = color;
    this.sex = sex;
  }
  toString() {
    return `Dog ${this.name} is a ${this.sex} ${this.color} ${this.breed}`;
  }
}

With the preceding code in place, any time an instance of Dog is used in a string context, JavaScript automatically calls the toString() method.
jsconst theDog = new Dog("Gabby", "Lab", "chocolate", "female");

`${theDog}`; // "Dog Gabby is a female chocolate Lab"
Using toString() to detect object classtoString() can be used with every object and (by default) allows you to get its class.
jsconst toString = Object.prototype.toString;

toString.call(new Date()); // [object Date]
toString.call(new String()); // [object String]
// Math has its Symbol.toStringTag
toString.call(Math); // [object Math]

toString.call(undefined); // [object Undefined]
toString.call(null); // [object Null]

Using toString() in this way is unreliable; objects can change the behavior of Object.prototype.toString() by defining a Symbol.toStringTag property, leading to unexpected results. For example:
jsconst myDate = new Date();
Object.prototype.toString.call(myDate); // [object Date]

myDate[Symbol.toStringTag] = "myDate";
Object.prototype.toString.call(myDate); // [object myDate]

Date.prototype[Symbol.toStringTag] = "prototype polluted";
Object.prototype.toString.call(new Date()); // [object prototype polluted]
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object.prototype.tostringBrowser compatibilitySee also
Polyfill of Object.prototype.toString with Symbol.toStringTag support in core-js
Object.prototype.valueOf()
Number.prototype.toString()
Symbol.toPrimitive
Symbol.toStringTag\n\nObject.prototype.toString()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe toString() method of Object instances returns a string representing this object. This method is meant to be overridden by derived objects for custom type coercion logic.Try it
function Dog(name) {
  this.name = name;
}

const dog1 = new Dog("Gabby");

Dog.prototype.toString = function dogToString() {
  return `${this.name}`;
};

console.log(dog1.toString());
// Expected output: "Gabby"
SyntaxjstoString()
ParametersBy default toString() takes no parameters. However, objects that inherit from Object may override it with their own implementations that do take parameters. For example, the Number.prototype.toString() and BigInt.prototype.toString() methods take an optional radix parameter.Return valueA string representing the object.DescriptionJavaScript calls the toString method to convert an object to a primitive value. You rarely need to invoke the toString method yourself; JavaScript automatically invokes it when encountering an object where a primitive value is expected.
This method is called in priority by string conversion, but numeric conversion and primitive conversion call valueOf() in priority. However, because the base valueOf() method returns an object, the toString() method is usually called in the end, unless the object overrides valueOf(). For example, +[1] returns 1, because its toString() method returns "1", which is then converted to a number.
All objects that inherit from Object.prototype (that is, all except null-prototype objects) inherit the toString() method. When you create a custom object, you can override toString() to call a custom method, so that your custom object can be converted to a string value. Alternatively, you can add a [Symbol.toPrimitive]() method, which allows even more control over the conversion process, and will always be preferred over valueOf or toString for any type conversion.
To use the base Object.prototype.toString() with an object that has it overridden (or to invoke it on null or undefined), you need to call Function.prototype.call() or Function.prototype.apply() on it, passing the object you want to inspect as the first parameter (called thisArg).
jsconst arr = [1, 2, 3];

arr.toString(); // "1,2,3"
Object.prototype.toString.call(arr); // "[object Array]"

Object.prototype.toString() returns "[object Type]", where Type is the object type. If the object has a Symbol.toStringTag property whose value is a string, that value will be used as the Type. Many built-in objects, including Map and Symbol, have a Symbol.toStringTag. Some objects predating ES6 do not have Symbol.toStringTag, but have a special tag nonetheless. They include (the tag is the same as the type name given below):

Array
Function (anything whose typeof returns "function")
Error
Boolean
Number
String
Date
RegExp

The arguments object returns "[object Arguments]". Everything else, including user-defined classes, unless with a custom Symbol.toStringTag, will return "[object Object]".
Object.prototype.toString() invoked on null and undefined returns [object Null] and [object Undefined], respectively.ExamplesOverriding toString for custom objectsYou can create a function to be called in place of the default toString() method. The toString() function you create should return a string value. If it returns an object and the method is called implicitly during type conversion, then its result is ignored and the value of a related method, valueOf(), is used instead, or a TypeError is thrown if none of these methods return a primitive.
The following code defines a Dog class.
jsclass Dog {
  constructor(name, breed, color, sex) {
    this.name = name;
    this.breed = breed;
    this.color = color;
    this.sex = sex;
  }
}

If you call the toString() method, either explicitly or implicitly, on an instance of Dog, it returns the default value inherited from Object:
jsconst theDog = new Dog("Gabby", "Lab", "chocolate", "female");

theDog.toString(); // "[object Object]"
`${theDog}`; // "[object Object]"

The following code overrides the default toString() method. This method generates a string containing the name, breed, color, and sex of the object.
jsclass Dog {
  constructor(name, breed, color, sex) {
    this.name = name;
    this.breed = breed;
    this.color = color;
    this.sex = sex;
  }
  toString() {
    return `Dog ${this.name} is a ${this.sex} ${this.color} ${this.breed}`;
  }
}

With the preceding code in place, any time an instance of Dog is used in a string context, JavaScript automatically calls the toString() method.
jsconst theDog = new Dog("Gabby", "Lab", "chocolate", "female");

`${theDog}`; // "Dog Gabby is a female chocolate Lab"
Using toString() to detect object classtoString() can be used with every object and (by default) allows you to get its class.
jsconst toString = Object.prototype.toString;

toString.call(new Date()); // [object Date]
toString.call(new String()); // [object String]
// Math has its Symbol.toStringTag
toString.call(Math); // [object Math]

toString.call(undefined); // [object Undefined]
toString.call(null); // [object Null]

Using toString() in this way is unreliable; objects can change the behavior of Object.prototype.toString() by defining a Symbol.toStringTag property, leading to unexpected results. For example:
jsconst myDate = new Date();
Object.prototype.toString.call(myDate); // [object Date]

myDate[Symbol.toStringTag] = "myDate";
Object.prototype.toString.call(myDate); // [object myDate]

Date.prototype[Symbol.toStringTag] = "prototype polluted";
Object.prototype.toString.call(new Date()); // [object prototype polluted]
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object.prototype.tostringBrowser compatibilitySee also
Polyfill of Object.prototype.toString with Symbol.toStringTag support in core-js
Object.prototype.valueOf()
Number.prototype.toString()
Symbol.toPrimitive
Symbol.toStringTag
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nObject.prototype.toString()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe toString() method of Object instances returns a string representing this object. This method is meant to be overridden by derived objects for custom type coercion logic.Try it
function Dog(name) {
  this.name = name;
}

const dog1 = new Dog("Gabby");

Dog.prototype.toString = function dogToString() {
  return `${this.name}`;
};

console.log(dog1.toString());
// Expected output: "Gabby"
SyntaxjstoString()
ParametersBy default toString() takes no parameters. However, objects that inherit from Object may override it with their own implementations that do take parameters. For example, the Number.prototype.toString() and BigInt.prototype.toString() methods take an optional radix parameter.Return valueA string representing the object.DescriptionJavaScript calls the toString method to convert an object to a primitive value. You rarely need to invoke the toString method yourself; JavaScript automatically invokes it when encountering an object where a primitive value is expected.
This method is called in priority by string conversion, but numeric conversion and primitive conversion call valueOf() in priority. However, because the base valueOf() method returns an object, the toString() method is usually called in the end, unless the object overrides valueOf(). For example, +[1] returns 1, because its toString() method returns "1", which is then converted to a number.
All objects that inherit from Object.prototype (that is, all except null-prototype objects) inherit the toString() method. When you create a custom object, you can override toString() to call a custom method, so that your custom object can be converted to a string value. Alternatively, you can add a [Symbol.toPrimitive]() method, which allows even more control over the conversion process, and will always be preferred over valueOf or toString for any type conversion.
To use the base Object.prototype.toString() with an object that has it overridden (or to invoke it on null or undefined), you need to call Function.prototype.call() or Function.prototype.apply() on it, passing the object you want to inspect as the first parameter (called thisArg).
jsconst arr = [1, 2, 3];

arr.toString(); // "1,2,3"
Object.prototype.toString.call(arr); // "[object Array]"

Object.prototype.toString() returns "[object Type]", where Type is the object type. If the object has a Symbol.toStringTag property whose value is a string, that value will be used as the Type. Many built-in objects, including Map and Symbol, have a Symbol.toStringTag. Some objects predating ES6 do not have Symbol.toStringTag, but have a special tag nonetheless. They include (the tag is the same as the type name given below):

Array
Function (anything whose typeof returns "function")
Error
Boolean
Number
String
Date
RegExp

The arguments object returns "[object Arguments]". Everything else, including user-defined classes, unless with a custom Symbol.toStringTag, will return "[object Object]".
Object.prototype.toString() invoked on null and undefined returns [object Null] and [object Undefined], respectively.ExamplesOverriding toString for custom objectsYou can create a function to be called in place of the default toString() method. The toString() function you create should return a string value. If it returns an object and the method is called implicitly during type conversion, then its result is ignored and the value of a related method, valueOf(), is used instead, or a TypeError is thrown if none of these methods return a primitive.
The following code defines a Dog class.
jsclass Dog {
  constructor(name, breed, color, sex) {
    this.name = name;
    this.breed = breed;
    this.color = color;
    this.sex = sex;
  }
}

If you call the toString() method, either explicitly or implicitly, on an instance of Dog, it returns the default value inherited from Object:
jsconst theDog = new Dog("Gabby", "Lab", "chocolate", "female");

theDog.toString(); // "[object Object]"
`${theDog}`; // "[object Object]"

The following code overrides the default toString() method. This method generates a string containing the name, breed, color, and sex of the object.
jsclass Dog {
  constructor(name, breed, color, sex) {
    this.name = name;
    this.breed = breed;
    this.color = color;
    this.sex = sex;
  }
  toString() {
    return `Dog ${this.name} is a ${this.sex} ${this.color} ${this.breed}`;
  }
}

With the preceding code in place, any time an instance of Dog is used in a string context, JavaScript automatically calls the toString() method.
jsconst theDog = new Dog("Gabby", "Lab", "chocolate", "female");

`${theDog}`; // "Dog Gabby is a female chocolate Lab"
Using toString() to detect object classtoString() can be used with every object and (by default) allows you to get its class.
jsconst toString = Object.prototype.toString;

toString.call(new Date()); // [object Date]
toString.call(new String()); // [object String]
// Math has its Symbol.toStringTag
toString.call(Math); // [object Math]

toString.call(undefined); // [object Undefined]
toString.call(null); // [object Null]

Using toString() in this way is unreliable; objects can change the behavior of Object.prototype.toString() by defining a Symbol.toStringTag property, leading to unexpected results. For example:
jsconst myDate = new Date();
Object.prototype.toString.call(myDate); // [object Date]

myDate[Symbol.toStringTag] = "myDate";
Object.prototype.toString.call(myDate); // [object myDate]

Date.prototype[Symbol.toStringTag] = "prototype polluted";
Object.prototype.toString.call(new Date()); // [object prototype polluted]
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object.prototype.tostringBrowser compatibilitySee also
Polyfill of Object.prototype.toString with Symbol.toStringTag support in core-js
Object.prototype.valueOf()
Number.prototype.toString()
Symbol.toPrimitive
Symbol.toStringTag
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nObject.prototype.valueOf()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe valueOf() method of Object instances converts the this value to an object. This method is meant to be overridden by derived objects for custom type conversion logic.Try it
function MyNumberType(n) {
  this.number = n;
}

MyNumberType.prototype.valueOf = function () {
  return this.number;
};

const object1 = new MyNumberType(4);

console.log(object1 + 3);
// Expected output: 7
SyntaxjsvalueOf()
ParametersNone.Return valueThe this value, converted to an object.

Note:
In order for valueOf to be useful during type conversion, it must return a primitive. Because all primitive types have their own valueOf() methods, calling aPrimitiveValue.valueOf() generally does not invoke Object.prototype.valueOf().
DescriptionJavaScript calls the valueOf method to convert an object to a primitive value. You rarely need to invoke the valueOf method yourself; JavaScript automatically invokes it when encountering an object where a primitive value is expected.
This method is called in priority by numeric conversion and primitive conversion, but string conversion calls toString() in priority, and toString() is very likely to return a string value (even for the Object.prototype.toString() base implementation), so valueOf() is usually not called in this case.
All objects that inherit from Object.prototype (that is, all except null-prototype objects) inherit the toString() method. The Object.prototype.valueOf() base implementation is deliberately useless: by returning an object, its return value will never be used by any primitive conversion algorithm. Many built-in objects override this method to return an appropriate primitive value. When you create a custom object, you can override valueOf() to call a custom method, so that your custom object can be converted to a primitive value. Generally, valueOf() is used to return a value that is most meaningful for the object — unlike toString(), it does not need to be a string. Alternatively, you can add a [Symbol.toPrimitive]() method, which allows even more control over the conversion process, and will always be preferred over valueOf or toString for any type conversion.ExamplesUsing valueOf()The base valueOf() method returns the this value itself, converted to an object if it isn't already. Therefore its return value will never be used by any primitive conversion algorithm.
jsconst obj = { foo: 1 };
console.log(obj.valueOf() === obj); // true

console.log(Object.prototype.valueOf.call("primitive"));
// [String: 'primitive'] (a wrapper object)
Overriding valueOf for custom objectsYou can create a function to be called in place of the default valueOf method. Your function should take no arguments, since it won't be passed any when called during type conversion.
For example, you can add a valueOf method to your custom class Box.
jsclass Box {
  #value;
  constructor(value) {
    this.#value = value;
  }
  valueOf() {
    return this.#value;
  }
}

With the preceding code in place, any time an object of type Box is used in a context where it is to be represented as a primitive value (but not specifically a string), JavaScript automatically calls the function defined in the preceding code.
jsconst box = new Box(123);
console.log(box + 456); // 579
console.log(box == 123); // true

An object's valueOf method is usually invoked by JavaScript, but you can invoke it yourself as follows:
jsbox.valueOf();
Using unary plus on objectsUnary plus performs number coercion on its operand, which, for most objects without [Symbol.toPrimitive](), means calling its valueOf(). However, if the object doesn't have a custom valueOf() method, the base implementation will cause valueOf() to be ignored and the return value of toString() to be used instead.
js+new Date(); // the current timestamp; same as new Date().getTime()
+{}; // NaN (toString() returns "[object Object]")
+[]; // 0 (toString() returns an empty string list)
+[1]; // 1 (toString() returns "1")
+[1, 2]; // NaN (toString() returns "1,2")
+new Set([1]); // NaN (toString() returns "[object Set]")
+{ valueOf: () => 42 }; // 42
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object.prototype.valueofBrowser compatibilitySee also
Object.prototype.toString()
parseInt()
Symbol.toPrimitive\n\nObject.prototype.valueOf()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe valueOf() method of Object instances converts the this value to an object. This method is meant to be overridden by derived objects for custom type conversion logic.Try it
function MyNumberType(n) {
  this.number = n;
}

MyNumberType.prototype.valueOf = function () {
  return this.number;
};

const object1 = new MyNumberType(4);

console.log(object1 + 3);
// Expected output: 7
SyntaxjsvalueOf()
ParametersNone.Return valueThe this value, converted to an object.

Note:
In order for valueOf to be useful during type conversion, it must return a primitive. Because all primitive types have their own valueOf() methods, calling aPrimitiveValue.valueOf() generally does not invoke Object.prototype.valueOf().
DescriptionJavaScript calls the valueOf method to convert an object to a primitive value. You rarely need to invoke the valueOf method yourself; JavaScript automatically invokes it when encountering an object where a primitive value is expected.
This method is called in priority by numeric conversion and primitive conversion, but string conversion calls toString() in priority, and toString() is very likely to return a string value (even for the Object.prototype.toString() base implementation), so valueOf() is usually not called in this case.
All objects that inherit from Object.prototype (that is, all except null-prototype objects) inherit the toString() method. The Object.prototype.valueOf() base implementation is deliberately useless: by returning an object, its return value will never be used by any primitive conversion algorithm. Many built-in objects override this method to return an appropriate primitive value. When you create a custom object, you can override valueOf() to call a custom method, so that your custom object can be converted to a primitive value. Generally, valueOf() is used to return a value that is most meaningful for the object — unlike toString(), it does not need to be a string. Alternatively, you can add a [Symbol.toPrimitive]() method, which allows even more control over the conversion process, and will always be preferred over valueOf or toString for any type conversion.ExamplesUsing valueOf()The base valueOf() method returns the this value itself, converted to an object if it isn't already. Therefore its return value will never be used by any primitive conversion algorithm.
jsconst obj = { foo: 1 };
console.log(obj.valueOf() === obj); // true

console.log(Object.prototype.valueOf.call("primitive"));
// [String: 'primitive'] (a wrapper object)
Overriding valueOf for custom objectsYou can create a function to be called in place of the default valueOf method. Your function should take no arguments, since it won't be passed any when called during type conversion.
For example, you can add a valueOf method to your custom class Box.
jsclass Box {
  #value;
  constructor(value) {
    this.#value = value;
  }
  valueOf() {
    return this.#value;
  }
}

With the preceding code in place, any time an object of type Box is used in a context where it is to be represented as a primitive value (but not specifically a string), JavaScript automatically calls the function defined in the preceding code.
jsconst box = new Box(123);
console.log(box + 456); // 579
console.log(box == 123); // true

An object's valueOf method is usually invoked by JavaScript, but you can invoke it yourself as follows:
jsbox.valueOf();
Using unary plus on objectsUnary plus performs number coercion on its operand, which, for most objects without [Symbol.toPrimitive](), means calling its valueOf(). However, if the object doesn't have a custom valueOf() method, the base implementation will cause valueOf() to be ignored and the return value of toString() to be used instead.
js+new Date(); // the current timestamp; same as new Date().getTime()
+{}; // NaN (toString() returns "[object Object]")
+[]; // 0 (toString() returns an empty string list)
+[1]; // 1 (toString() returns "1")
+[1, 2]; // NaN (toString() returns "1,2")
+new Set([1]); // NaN (toString() returns "[object Set]")
+{ valueOf: () => 42 }; // 42
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object.prototype.valueofBrowser compatibilitySee also
Object.prototype.toString()
parseInt()
Symbol.toPrimitive
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nObject.prototype.valueOf()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe valueOf() method of Object instances converts the this value to an object. This method is meant to be overridden by derived objects for custom type conversion logic.Try it
function MyNumberType(n) {
  this.number = n;
}

MyNumberType.prototype.valueOf = function () {
  return this.number;
};

const object1 = new MyNumberType(4);

console.log(object1 + 3);
// Expected output: 7
SyntaxjsvalueOf()
ParametersNone.Return valueThe this value, converted to an object.

Note:
In order for valueOf to be useful during type conversion, it must return a primitive. Because all primitive types have their own valueOf() methods, calling aPrimitiveValue.valueOf() generally does not invoke Object.prototype.valueOf().
DescriptionJavaScript calls the valueOf method to convert an object to a primitive value. You rarely need to invoke the valueOf method yourself; JavaScript automatically invokes it when encountering an object where a primitive value is expected.
This method is called in priority by numeric conversion and primitive conversion, but string conversion calls toString() in priority, and toString() is very likely to return a string value (even for the Object.prototype.toString() base implementation), so valueOf() is usually not called in this case.
All objects that inherit from Object.prototype (that is, all except null-prototype objects) inherit the toString() method. The Object.prototype.valueOf() base implementation is deliberately useless: by returning an object, its return value will never be used by any primitive conversion algorithm. Many built-in objects override this method to return an appropriate primitive value. When you create a custom object, you can override valueOf() to call a custom method, so that your custom object can be converted to a primitive value. Generally, valueOf() is used to return a value that is most meaningful for the object — unlike toString(), it does not need to be a string. Alternatively, you can add a [Symbol.toPrimitive]() method, which allows even more control over the conversion process, and will always be preferred over valueOf or toString for any type conversion.ExamplesUsing valueOf()The base valueOf() method returns the this value itself, converted to an object if it isn't already. Therefore its return value will never be used by any primitive conversion algorithm.
jsconst obj = { foo: 1 };
console.log(obj.valueOf() === obj); // true

console.log(Object.prototype.valueOf.call("primitive"));
// [String: 'primitive'] (a wrapper object)
Overriding valueOf for custom objectsYou can create a function to be called in place of the default valueOf method. Your function should take no arguments, since it won't be passed any when called during type conversion.
For example, you can add a valueOf method to your custom class Box.
jsclass Box {
  #value;
  constructor(value) {
    this.#value = value;
  }
  valueOf() {
    return this.#value;
  }
}

With the preceding code in place, any time an object of type Box is used in a context where it is to be represented as a primitive value (but not specifically a string), JavaScript automatically calls the function defined in the preceding code.
jsconst box = new Box(123);
console.log(box + 456); // 579
console.log(box == 123); // true

An object's valueOf method is usually invoked by JavaScript, but you can invoke it yourself as follows:
jsbox.valueOf();
Using unary plus on objectsUnary plus performs number coercion on its operand, which, for most objects without [Symbol.toPrimitive](), means calling its valueOf(). However, if the object doesn't have a custom valueOf() method, the base implementation will cause valueOf() to be ignored and the return value of toString() to be used instead.
js+new Date(); // the current timestamp; same as new Date().getTime()
+{}; // NaN (toString() returns "[object Object]")
+[]; // 0 (toString() returns an empty string list)
+[1]; // 1 (toString() returns "1")
+[1, 2]; // NaN (toString() returns "1,2")
+new Set([1]); // NaN (toString() returns "[object Set]")
+{ valueOf: () => 42 }; // 42
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object.prototype.valueofBrowser compatibilitySee also
Object.prototype.toString()
parseInt()
Symbol.toPrimitive
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nObject.prototype.__proto__Deprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time.

Warning:
Changing the [[Prototype]] of an object is, by the nature of how modern JavaScript engines optimize property accesses, currently a very slow operation in every browser and JavaScript engine. In addition, the effects of altering inheritance are subtle and far-flung, and are not limited to the time spent in the obj.__proto__ = ... statement, but may extend to any code that has access to any object whose [[Prototype]] has been altered. You can read more in JavaScript engine fundamentals: optimizing prototypes.


Note:
The use of __proto__ is controversial and discouraged. Its existence and exact behavior have only been standardized as a legacy feature to ensure web compatibility, while it presents several security issues and footguns. For better support, prefer Object.getPrototypeOf()/Reflect.getPrototypeOf() and Object.setPrototypeOf()/Reflect.setPrototypeOf() instead.

The __proto__ accessor property of Object instances exposes the [[Prototype]] (either an object or null) of this object.
The __proto__ property can also be used in an object literal definition to set the object [[Prototype]] on creation, as an alternative to Object.create(). See: object initializer / literal syntax. That syntax is standard and optimized for in implementations, and quite different from Object.prototype.__proto__.Syntaxjsobj.__proto__
Return valueIf used as a getter, returns the object's [[Prototype]].Exceptions
TypeError

Thrown if attempting to set the prototype of a non-extensible object or an immutable prototype exotic object, such as Object.prototype or window.

DescriptionThe __proto__ getter function exposes the value of the internal [[Prototype]] of an object. For objects created using an object literal (unless you use the prototype setter syntax), this value is Object.prototype. For objects created using array literals, this value is Array.prototype. For functions, this value is Function.prototype. You can read more about the prototype chain in Inheritance and the prototype chain.
The __proto__ setter allows the [[Prototype]] of an object to be mutated. The value provided must be an object or null. Providing any other value will do nothing.
Unlike Object.getPrototypeOf() and Object.setPrototypeOf(), which are always available on Object as static properties and always reflect the [[Prototype]] internal property, the __proto__ property doesn't always exist as a property on all objects, and as a result doesn't reflect [[Prototype]] reliably.
The __proto__ property is just an accessor property on Object.prototype consisting of a getter and setter function. A property access for __proto__ that eventually consults Object.prototype will find this property, but an access that does not consult Object.prototype will not. If some other __proto__ property is found before Object.prototype is consulted, that property will hide the one found on Object.prototype.
null-prototype objects don't inherit any property from Object.prototype, including the __proto__ accessor property, so if you try to read __proto__ on such an object, the value is always undefined regardless of the object's actual [[Prototype]], and any assignment to __proto__ would create a new property called __proto__ instead of setting the object's prototype. Furthermore, __proto__ can be redefined as an own property on any object instance through Object.defineProperty() without triggering the setter. In this case, __proto__ will no longer be an accessor for [[Prototype]]. Therefore, always prefer Object.getPrototypeOf() and Object.setPrototypeOf() for setting and getting the [[Prototype]] of an object.ExamplesUsing __proto__jsfunction Circle() {}
const shape = {};
const circle = new Circle();

// Set the object prototype.
// DEPRECATED. This is for example purposes only. DO NOT DO THIS in real code.
shape.__proto__ = circle;

// Get the object prototype
console.log(shape.__proto__ === Circle); // false

jsconst ShapeA = function () {};
const ShapeB = {
  a() {
    console.log("aaa");
  },
};

ShapeA.prototype.__proto__ = ShapeB;
console.log(ShapeA.prototype.__proto__); // { a: [Function: a] }

const shapeA = new ShapeA();
shapeA.a(); // aaa
console.log(ShapeA.prototype === shapeA.__proto__); // true

jsconst ShapeC = function () {};
const ShapeD = {
  a() {
    console.log("a");
  },
};

const shapeC = new ShapeC();
shapeC.__proto__ = ShapeD;
shapeC.a(); // a
console.log(ShapeC.prototype === shapeC.__proto__); // false

jsfunction Test() {}
Test.prototype.myName = function () {
  console.log("myName");
};

const test = new Test();
console.log(test.__proto__ === Test.prototype); // true
test.myName(); // myName

const obj = {};
obj.__proto__ = Test.prototype;
obj.myName(); // myName
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object.prototype.__proto__Browser compatibilitySee also
Object.prototype.isPrototypeOf()
Object.getPrototypeOf()
Object.setPrototypeOf()\n\nObject.prototype.__proto__Deprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time.

Warning:
Changing the [[Prototype]] of an object is, by the nature of how modern JavaScript engines optimize property accesses, currently a very slow operation in every browser and JavaScript engine. In addition, the effects of altering inheritance are subtle and far-flung, and are not limited to the time spent in the obj.__proto__ = ... statement, but may extend to any code that has access to any object whose [[Prototype]] has been altered. You can read more in JavaScript engine fundamentals: optimizing prototypes.


Note:
The use of __proto__ is controversial and discouraged. Its existence and exact behavior have only been standardized as a legacy feature to ensure web compatibility, while it presents several security issues and footguns. For better support, prefer Object.getPrototypeOf()/Reflect.getPrototypeOf() and Object.setPrototypeOf()/Reflect.setPrototypeOf() instead.

The __proto__ accessor property of Object instances exposes the [[Prototype]] (either an object or null) of this object.
The __proto__ property can also be used in an object literal definition to set the object [[Prototype]] on creation, as an alternative to Object.create(). See: object initializer / literal syntax. That syntax is standard and optimized for in implementations, and quite different from Object.prototype.__proto__.Syntaxjsobj.__proto__
Return valueIf used as a getter, returns the object's [[Prototype]].Exceptions
TypeError

Thrown if attempting to set the prototype of a non-extensible object or an immutable prototype exotic object, such as Object.prototype or window.

DescriptionThe __proto__ getter function exposes the value of the internal [[Prototype]] of an object. For objects created using an object literal (unless you use the prototype setter syntax), this value is Object.prototype. For objects created using array literals, this value is Array.prototype. For functions, this value is Function.prototype. You can read more about the prototype chain in Inheritance and the prototype chain.
The __proto__ setter allows the [[Prototype]] of an object to be mutated. The value provided must be an object or null. Providing any other value will do nothing.
Unlike Object.getPrototypeOf() and Object.setPrototypeOf(), which are always available on Object as static properties and always reflect the [[Prototype]] internal property, the __proto__ property doesn't always exist as a property on all objects, and as a result doesn't reflect [[Prototype]] reliably.
The __proto__ property is just an accessor property on Object.prototype consisting of a getter and setter function. A property access for __proto__ that eventually consults Object.prototype will find this property, but an access that does not consult Object.prototype will not. If some other __proto__ property is found before Object.prototype is consulted, that property will hide the one found on Object.prototype.
null-prototype objects don't inherit any property from Object.prototype, including the __proto__ accessor property, so if you try to read __proto__ on such an object, the value is always undefined regardless of the object's actual [[Prototype]], and any assignment to __proto__ would create a new property called __proto__ instead of setting the object's prototype. Furthermore, __proto__ can be redefined as an own property on any object instance through Object.defineProperty() without triggering the setter. In this case, __proto__ will no longer be an accessor for [[Prototype]]. Therefore, always prefer Object.getPrototypeOf() and Object.setPrototypeOf() for setting and getting the [[Prototype]] of an object.ExamplesUsing __proto__jsfunction Circle() {}
const shape = {};
const circle = new Circle();

// Set the object prototype.
// DEPRECATED. This is for example purposes only. DO NOT DO THIS in real code.
shape.__proto__ = circle;

// Get the object prototype
console.log(shape.__proto__ === Circle); // false

jsconst ShapeA = function () {};
const ShapeB = {
  a() {
    console.log("aaa");
  },
};

ShapeA.prototype.__proto__ = ShapeB;
console.log(ShapeA.prototype.__proto__); // { a: [Function: a] }

const shapeA = new ShapeA();
shapeA.a(); // aaa
console.log(ShapeA.prototype === shapeA.__proto__); // true

jsconst ShapeC = function () {};
const ShapeD = {
  a() {
    console.log("a");
  },
};

const shapeC = new ShapeC();
shapeC.__proto__ = ShapeD;
shapeC.a(); // a
console.log(ShapeC.prototype === shapeC.__proto__); // false

jsfunction Test() {}
Test.prototype.myName = function () {
  console.log("myName");
};

const test = new Test();
console.log(test.__proto__ === Test.prototype); // true
test.myName(); // myName

const obj = {};
obj.__proto__ = Test.prototype;
obj.myName(); // myName
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object.prototype.__proto__Browser compatibilitySee also
Object.prototype.isPrototypeOf()
Object.getPrototypeOf()
Object.setPrototypeOf()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nObject.prototype.__proto__Deprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time.

Warning:
Changing the [[Prototype]] of an object is, by the nature of how modern JavaScript engines optimize property accesses, currently a very slow operation in every browser and JavaScript engine. In addition, the effects of altering inheritance are subtle and far-flung, and are not limited to the time spent in the obj.__proto__ = ... statement, but may extend to any code that has access to any object whose [[Prototype]] has been altered. You can read more in JavaScript engine fundamentals: optimizing prototypes.


Note:
The use of __proto__ is controversial and discouraged. Its existence and exact behavior have only been standardized as a legacy feature to ensure web compatibility, while it presents several security issues and footguns. For better support, prefer Object.getPrototypeOf()/Reflect.getPrototypeOf() and Object.setPrototypeOf()/Reflect.setPrototypeOf() instead.

The __proto__ accessor property of Object instances exposes the [[Prototype]] (either an object or null) of this object.
The __proto__ property can also be used in an object literal definition to set the object [[Prototype]] on creation, as an alternative to Object.create(). See: object initializer / literal syntax. That syntax is standard and optimized for in implementations, and quite different from Object.prototype.__proto__.Syntaxjsobj.__proto__
Return valueIf used as a getter, returns the object's [[Prototype]].Exceptions
TypeError

Thrown if attempting to set the prototype of a non-extensible object or an immutable prototype exotic object, such as Object.prototype or window.

DescriptionThe __proto__ getter function exposes the value of the internal [[Prototype]] of an object. For objects created using an object literal (unless you use the prototype setter syntax), this value is Object.prototype. For objects created using array literals, this value is Array.prototype. For functions, this value is Function.prototype. You can read more about the prototype chain in Inheritance and the prototype chain.
The __proto__ setter allows the [[Prototype]] of an object to be mutated. The value provided must be an object or null. Providing any other value will do nothing.
Unlike Object.getPrototypeOf() and Object.setPrototypeOf(), which are always available on Object as static properties and always reflect the [[Prototype]] internal property, the __proto__ property doesn't always exist as a property on all objects, and as a result doesn't reflect [[Prototype]] reliably.
The __proto__ property is just an accessor property on Object.prototype consisting of a getter and setter function. A property access for __proto__ that eventually consults Object.prototype will find this property, but an access that does not consult Object.prototype will not. If some other __proto__ property is found before Object.prototype is consulted, that property will hide the one found on Object.prototype.
null-prototype objects don't inherit any property from Object.prototype, including the __proto__ accessor property, so if you try to read __proto__ on such an object, the value is always undefined regardless of the object's actual [[Prototype]], and any assignment to __proto__ would create a new property called __proto__ instead of setting the object's prototype. Furthermore, __proto__ can be redefined as an own property on any object instance through Object.defineProperty() without triggering the setter. In this case, __proto__ will no longer be an accessor for [[Prototype]]. Therefore, always prefer Object.getPrototypeOf() and Object.setPrototypeOf() for setting and getting the [[Prototype]] of an object.ExamplesUsing __proto__jsfunction Circle() {}
const shape = {};
const circle = new Circle();

// Set the object prototype.
// DEPRECATED. This is for example purposes only. DO NOT DO THIS in real code.
shape.__proto__ = circle;

// Get the object prototype
console.log(shape.__proto__ === Circle); // false

jsconst ShapeA = function () {};
const ShapeB = {
  a() {
    console.log("aaa");
  },
};

ShapeA.prototype.__proto__ = ShapeB;
console.log(ShapeA.prototype.__proto__); // { a: [Function: a] }

const shapeA = new ShapeA();
shapeA.a(); // aaa
console.log(ShapeA.prototype === shapeA.__proto__); // true

jsconst ShapeC = function () {};
const ShapeD = {
  a() {
    console.log("a");
  },
};

const shapeC = new ShapeC();
shapeC.__proto__ = ShapeD;
shapeC.a(); // a
console.log(ShapeC.prototype === shapeC.__proto__); // false

jsfunction Test() {}
Test.prototype.myName = function () {
  console.log("myName");
};

const test = new Test();
console.log(test.__proto__ === Test.prototype); // true
test.myName(); // myName

const obj = {};
obj.__proto__ = Test.prototype;
obj.myName(); // myName
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object.prototype.__proto__Browser compatibilitySee also
Object.prototype.isPrototypeOf()
Object.getPrototypeOf()
Object.setPrototypeOf()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nObject.prototype.constructorBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe constructor data property of an Object instance returns a reference to the constructor function that created the instance object. Note that the value of this property is a reference to the function itself, not a string containing the function's name.

Note:
This is a property of JavaScript objects. For the constructor method in classes, see its own reference page.
ValueA reference to the constructor function that created the instance object.
Property attributes of Object.prototype.constructorWritableyesEnumerablenoConfigurableyes

Note:
This property is created by default on the prototype property of every constructor function and is inherited by all objects created by that constructor.
DescriptionAny object (with the exception of null prototype objects) will have a constructor property on its [[Prototype]]. Objects created with literals will also have a constructor property that points to the constructor type for that object — for example, array literals create Array objects, and object literals create plain objects.
jsconst o1 = {};
o1.constructor === Object; // true

const o2 = new Object();
o2.constructor === Object; // true

const a1 = [];
a1.constructor === Array; // true

const a2 = new Array();
a2.constructor === Array; // true

const n = 3;
n.constructor === Number; // true

Note that constructor usually comes from the constructor's prototype property. If you have a longer prototype chain, you can usually expect every object in the chain to have a constructor property.
jsconst o = new TypeError(); // Inheritance: TypeError -> Error -> Object
const proto = Object.getPrototypeOf;

Object.hasOwn(o, "constructor"); // false
proto(o).constructor === TypeError; // true
proto(proto(o)).constructor === Error; // true
proto(proto(proto(o))).constructor === Object; // true
ExamplesDisplaying the constructor of an objectThe following example creates a constructor (Tree) and an object of that type (theTree). The example then displays the constructor property for the object theTree.
jsfunction Tree(name) {
  this.name = name;
}

const theTree = new Tree("Redwood");
console.log(`theTree.constructor is ${theTree.constructor}`);

This example displays the following output:
theTree.constructor is function Tree(name) {
  this.name = name;
}
Assigning the constructor property to an objectOne can assign the constructor property of non-primitives.
jsconst arr = [];
arr.constructor = String;
arr.constructor === String; // true
arr instanceof String; // false
arr instanceof Array; // true

const foo = new Foo();
foo.constructor = "bar";
foo.constructor === "bar"; // true

// etc.

This does not overwrite the old constructor property — it was originally present on the instance's [[Prototype]], not as its own property.
jsconst arr = [];
Object.hasOwn(arr, "constructor"); // false
Object.hasOwn(Object.getPrototypeOf(arr), "constructor"); // true

arr.constructor = String;
Object.hasOwn(arr, "constructor"); // true — the instance property shadows the one on its prototype

But even when Object.getPrototypeOf(a).constructor is re-assigned, it won't change other behaviors of the object. For example, the behavior of instanceof is controlled by Symbol.hasInstance, not constructor:
jsconst arr = [];
arr.constructor = String;
arr instanceof String; // false
arr instanceof Array; // true

There is nothing protecting the constructor property from being re-assigned or shadowed, so using it to detect the type of a variable should usually be avoided in favor of less fragile ways like instanceof and Symbol.toStringTag for objects, or typeof for primitives.Changing the constructor of a constructor function's prototypeEvery constructor has a prototype property, which will become the instance's [[Prototype]] when called via the new operator. ConstructorFunction.prototype.constructor will therefore become a property on the instance's [[Prototype]], as previously demonstrated.
However, if ConstructorFunction.prototype is re-assigned, the constructor property will be lost. For example, the following is a common way to create an inheritance pattern:
jsfunction Parent() {
  // …
}
Parent.prototype.parentMethod = function () {};

function Child() {
  Parent.call(this); // Make sure everything is initialized properly
}
// Pointing the [[Prototype]] of Child.prototype to Parent.prototype
Child.prototype = Object.create(Parent.prototype);

The constructor of instances of Child will be Parent due to Child.prototype being re-assigned.
This is usually not a big deal — the language almost never reads the constructor property of an object. The only exception is when using [Symbol.species] to create new instances of a class, but such cases are rare, and you should be using the extends syntax to subclass builtins anyway.
However, ensuring that Child.prototype.constructor always points to Child itself is crucial when some caller is using constructor to access the original class from an instance. Take the following case: the object has the create() method to create itself.
jsfunction Parent() {
  // …
}
function CreatedConstructor() {
  Parent.call(this);
}

CreatedConstructor.prototype = Object.create(Parent.prototype);

CreatedConstructor.prototype.create = function () {
  return new this.constructor();
};

new CreatedConstructor().create().create(); // TypeError: new CreatedConstructor().create().create is undefined, since constructor === Parent

In the example above, an exception is thrown, since the constructor links to Parent. To avoid this, just assign the necessary constructor you are going to use.
jsfunction Parent() {
  // …
}
function CreatedConstructor() {
  // …
}

CreatedConstructor.prototype = Object.create(Parent.prototype, {
  // Return original constructor to Child
  constructor: {
    value: CreatedConstructor,
    enumerable: false, // Make it non-enumerable, so it won't appear in `for...in` loop
    writable: true,
    configurable: true,
  },
});

CreatedConstructor.prototype.create = function () {
  return new this.constructor();
};

new CreatedConstructor().create().create(); // it's pretty fine

Note that when manually adding the constructor property, it's crucial to make the property non-enumerable, so constructor won't be visited in for...in loops — as it normally isn't.
If the code above looks like too much boilerplate, you may also consider using Object.setPrototypeOf() to manipulate the prototype chain.
jsfunction Parent() {
  // …
}
function CreatedConstructor() {
  // …
}

Object.setPrototypeOf(CreatedConstructor.prototype, Parent.prototype);

CreatedConstructor.prototype.create = function () {
  return new this.constructor();
};

new CreatedConstructor().create().create(); // still works without re-creating constructor property

Object.setPrototypeOf() comes with its potential performance downsides because all previously created objects involved in the prototype chain have to be re-compiled; but if the above initialization code happens before Parent or CreatedConstructor are constructed, the effect should be minimal.
Let's consider one more involved case.
jsfunction ParentWithStatic() {}

ParentWithStatic.startPosition = { x: 0, y: 0 }; // Static member property
ParentWithStatic.getStartPosition = function () {
  return this.startPosition;
};

function Child(x, y) {
  this.position = { x, y };
}

Child.prototype = Object.create(ParentWithStatic.prototype, {
  // Return original constructor to Child
  constructor: {
    value: Child,
    enumerable: false,
    writable: true,
    configurable: true,
  },
});

Child.prototype.getOffsetByInitialPosition = function () {
  const position = this.position;
  // Using this.constructor, in hope that getStartPosition exists as a static method
  const startPosition = this.constructor.getStartPosition();

  return {
    offsetX: startPosition.x - position.x,
    offsetY: startPosition.y - position.y,
  };
};

new Child(1, 1).getOffsetByInitialPosition();
// Error: this.constructor.getStartPosition is undefined, since the
// constructor is Child, which doesn't have the getStartPosition static method

For this example to work properly, we can reassign the Parent's static properties to Child:
js// …
Object.assign(Child, ParentWithStatic); // Notice that we assign it before we create() a prototype below
Child.prototype = Object.create(ParentWithStatic.prototype, {
  // Return original constructor to Child
  constructor: {
    value: Child,
    enumerable: false,
    writable: true,
    configurable: true,
  },
});
// …

But even better, we can make the constructor functions themselves extend each other, as classes' extends do.
jsfunction ParentWithStatic() {}

ParentWithStatic.startPosition = { x: 0, y: 0 }; // Static member property
ParentWithStatic.getStartPosition = function () {
  return this.startPosition;
};

function Child(x, y) {
  this.position = { x, y };
}

// Properly create inheritance!
Object.setPrototypeOf(Child.prototype, ParentWithStatic.prototype);
Object.setPrototypeOf(Child, ParentWithStatic);

Child.prototype.getOffsetByInitialPosition = function () {
  const position = this.position;
  const startPosition = this.constructor.getStartPosition();

  return {
    offsetX: startPosition.x - position.x,
    offsetY: startPosition.y - position.y,
  };
};

console.log(new Child(1, 1).getOffsetByInitialPosition()); // { offsetX: -1, offsetY: -1 }

Again, using Object.setPrototypeOf() may have adverse performance effects, so make sure it happens immediately after the constructor declaration and before any instances are created — to avoid objects being "tainted".

Note:
Manually updating or setting the constructor can lead to different and sometimes confusing consequences. To prevent this, just define the role of constructor in each specific case. In most cases, constructor is not used and reassigning it is not necessary.
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object.prototype.constructorBrowser compatibilitySee also
class
constructor
Constructor\n\nObject.prototype.constructorBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe constructor data property of an Object instance returns a reference to the constructor function that created the instance object. Note that the value of this property is a reference to the function itself, not a string containing the function's name.

Note:
This is a property of JavaScript objects. For the constructor method in classes, see its own reference page.
ValueA reference to the constructor function that created the instance object.
Property attributes of Object.prototype.constructorWritableyesEnumerablenoConfigurableyes

Note:
This property is created by default on the prototype property of every constructor function and is inherited by all objects created by that constructor.
DescriptionAny object (with the exception of null prototype objects) will have a constructor property on its [[Prototype]]. Objects created with literals will also have a constructor property that points to the constructor type for that object — for example, array literals create Array objects, and object literals create plain objects.
jsconst o1 = {};
o1.constructor === Object; // true

const o2 = new Object();
o2.constructor === Object; // true

const a1 = [];
a1.constructor === Array; // true

const a2 = new Array();
a2.constructor === Array; // true

const n = 3;
n.constructor === Number; // true

Note that constructor usually comes from the constructor's prototype property. If you have a longer prototype chain, you can usually expect every object in the chain to have a constructor property.
jsconst o = new TypeError(); // Inheritance: TypeError -> Error -> Object
const proto = Object.getPrototypeOf;

Object.hasOwn(o, "constructor"); // false
proto(o).constructor === TypeError; // true
proto(proto(o)).constructor === Error; // true
proto(proto(proto(o))).constructor === Object; // true
ExamplesDisplaying the constructor of an objectThe following example creates a constructor (Tree) and an object of that type (theTree). The example then displays the constructor property for the object theTree.
jsfunction Tree(name) {
  this.name = name;
}

const theTree = new Tree("Redwood");
console.log(`theTree.constructor is ${theTree.constructor}`);

This example displays the following output:
theTree.constructor is function Tree(name) {
  this.name = name;
}
Assigning the constructor property to an objectOne can assign the constructor property of non-primitives.
jsconst arr = [];
arr.constructor = String;
arr.constructor === String; // true
arr instanceof String; // false
arr instanceof Array; // true

const foo = new Foo();
foo.constructor = "bar";
foo.constructor === "bar"; // true

// etc.

This does not overwrite the old constructor property — it was originally present on the instance's [[Prototype]], not as its own property.
jsconst arr = [];
Object.hasOwn(arr, "constructor"); // false
Object.hasOwn(Object.getPrototypeOf(arr), "constructor"); // true

arr.constructor = String;
Object.hasOwn(arr, "constructor"); // true — the instance property shadows the one on its prototype

But even when Object.getPrototypeOf(a).constructor is re-assigned, it won't change other behaviors of the object. For example, the behavior of instanceof is controlled by Symbol.hasInstance, not constructor:
jsconst arr = [];
arr.constructor = String;
arr instanceof String; // false
arr instanceof Array; // true

There is nothing protecting the constructor property from being re-assigned or shadowed, so using it to detect the type of a variable should usually be avoided in favor of less fragile ways like instanceof and Symbol.toStringTag for objects, or typeof for primitives.Changing the constructor of a constructor function's prototypeEvery constructor has a prototype property, which will become the instance's [[Prototype]] when called via the new operator. ConstructorFunction.prototype.constructor will therefore become a property on the instance's [[Prototype]], as previously demonstrated.
However, if ConstructorFunction.prototype is re-assigned, the constructor property will be lost. For example, the following is a common way to create an inheritance pattern:
jsfunction Parent() {
  // …
}
Parent.prototype.parentMethod = function () {};

function Child() {
  Parent.call(this); // Make sure everything is initialized properly
}
// Pointing the [[Prototype]] of Child.prototype to Parent.prototype
Child.prototype = Object.create(Parent.prototype);

The constructor of instances of Child will be Parent due to Child.prototype being re-assigned.
This is usually not a big deal — the language almost never reads the constructor property of an object. The only exception is when using [Symbol.species] to create new instances of a class, but such cases are rare, and you should be using the extends syntax to subclass builtins anyway.
However, ensuring that Child.prototype.constructor always points to Child itself is crucial when some caller is using constructor to access the original class from an instance. Take the following case: the object has the create() method to create itself.
jsfunction Parent() {
  // …
}
function CreatedConstructor() {
  Parent.call(this);
}

CreatedConstructor.prototype = Object.create(Parent.prototype);

CreatedConstructor.prototype.create = function () {
  return new this.constructor();
};

new CreatedConstructor().create().create(); // TypeError: new CreatedConstructor().create().create is undefined, since constructor === Parent

In the example above, an exception is thrown, since the constructor links to Parent. To avoid this, just assign the necessary constructor you are going to use.
jsfunction Parent() {
  // …
}
function CreatedConstructor() {
  // …
}

CreatedConstructor.prototype = Object.create(Parent.prototype, {
  // Return original constructor to Child
  constructor: {
    value: CreatedConstructor,
    enumerable: false, // Make it non-enumerable, so it won't appear in `for...in` loop
    writable: true,
    configurable: true,
  },
});

CreatedConstructor.prototype.create = function () {
  return new this.constructor();
};

new CreatedConstructor().create().create(); // it's pretty fine

Note that when manually adding the constructor property, it's crucial to make the property non-enumerable, so constructor won't be visited in for...in loops — as it normally isn't.
If the code above looks like too much boilerplate, you may also consider using Object.setPrototypeOf() to manipulate the prototype chain.
jsfunction Parent() {
  // …
}
function CreatedConstructor() {
  // …
}

Object.setPrototypeOf(CreatedConstructor.prototype, Parent.prototype);

CreatedConstructor.prototype.create = function () {
  return new this.constructor();
};

new CreatedConstructor().create().create(); // still works without re-creating constructor property

Object.setPrototypeOf() comes with its potential performance downsides because all previously created objects involved in the prototype chain have to be re-compiled; but if the above initialization code happens before Parent or CreatedConstructor are constructed, the effect should be minimal.
Let's consider one more involved case.
jsfunction ParentWithStatic() {}

ParentWithStatic.startPosition = { x: 0, y: 0 }; // Static member property
ParentWithStatic.getStartPosition = function () {
  return this.startPosition;
};

function Child(x, y) {
  this.position = { x, y };
}

Child.prototype = Object.create(ParentWithStatic.prototype, {
  // Return original constructor to Child
  constructor: {
    value: Child,
    enumerable: false,
    writable: true,
    configurable: true,
  },
});

Child.prototype.getOffsetByInitialPosition = function () {
  const position = this.position;
  // Using this.constructor, in hope that getStartPosition exists as a static method
  const startPosition = this.constructor.getStartPosition();

  return {
    offsetX: startPosition.x - position.x,
    offsetY: startPosition.y - position.y,
  };
};

new Child(1, 1).getOffsetByInitialPosition();
// Error: this.constructor.getStartPosition is undefined, since the
// constructor is Child, which doesn't have the getStartPosition static method

For this example to work properly, we can reassign the Parent's static properties to Child:
js// …
Object.assign(Child, ParentWithStatic); // Notice that we assign it before we create() a prototype below
Child.prototype = Object.create(ParentWithStatic.prototype, {
  // Return original constructor to Child
  constructor: {
    value: Child,
    enumerable: false,
    writable: true,
    configurable: true,
  },
});
// …

But even better, we can make the constructor functions themselves extend each other, as classes' extends do.
jsfunction ParentWithStatic() {}

ParentWithStatic.startPosition = { x: 0, y: 0 }; // Static member property
ParentWithStatic.getStartPosition = function () {
  return this.startPosition;
};

function Child(x, y) {
  this.position = { x, y };
}

// Properly create inheritance!
Object.setPrototypeOf(Child.prototype, ParentWithStatic.prototype);
Object.setPrototypeOf(Child, ParentWithStatic);

Child.prototype.getOffsetByInitialPosition = function () {
  const position = this.position;
  const startPosition = this.constructor.getStartPosition();

  return {
    offsetX: startPosition.x - position.x,
    offsetY: startPosition.y - position.y,
  };
};

console.log(new Child(1, 1).getOffsetByInitialPosition()); // { offsetX: -1, offsetY: -1 }

Again, using Object.setPrototypeOf() may have adverse performance effects, so make sure it happens immediately after the constructor declaration and before any instances are created — to avoid objects being "tainted".

Note:
Manually updating or setting the constructor can lead to different and sometimes confusing consequences. To prevent this, just define the role of constructor in each specific case. In most cases, constructor is not used and reassigning it is not necessary.
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object.prototype.constructorBrowser compatibilitySee also
class
constructor
Constructor
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nObject.prototype.constructorBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe constructor data property of an Object instance returns a reference to the constructor function that created the instance object. Note that the value of this property is a reference to the function itself, not a string containing the function's name.

Note:
This is a property of JavaScript objects. For the constructor method in classes, see its own reference page.
ValueA reference to the constructor function that created the instance object.
Property attributes of Object.prototype.constructorWritableyesEnumerablenoConfigurableyes

Note:
This property is created by default on the prototype property of every constructor function and is inherited by all objects created by that constructor.
DescriptionAny object (with the exception of null prototype objects) will have a constructor property on its [[Prototype]]. Objects created with literals will also have a constructor property that points to the constructor type for that object — for example, array literals create Array objects, and object literals create plain objects.
jsconst o1 = {};
o1.constructor === Object; // true

const o2 = new Object();
o2.constructor === Object; // true

const a1 = [];
a1.constructor === Array; // true

const a2 = new Array();
a2.constructor === Array; // true

const n = 3;
n.constructor === Number; // true

Note that constructor usually comes from the constructor's prototype property. If you have a longer prototype chain, you can usually expect every object in the chain to have a constructor property.
jsconst o = new TypeError(); // Inheritance: TypeError -> Error -> Object
const proto = Object.getPrototypeOf;

Object.hasOwn(o, "constructor"); // false
proto(o).constructor === TypeError; // true
proto(proto(o)).constructor === Error; // true
proto(proto(proto(o))).constructor === Object; // true
ExamplesDisplaying the constructor of an objectThe following example creates a constructor (Tree) and an object of that type (theTree). The example then displays the constructor property for the object theTree.
jsfunction Tree(name) {
  this.name = name;
}

const theTree = new Tree("Redwood");
console.log(`theTree.constructor is ${theTree.constructor}`);

This example displays the following output:
theTree.constructor is function Tree(name) {
  this.name = name;
}
Assigning the constructor property to an objectOne can assign the constructor property of non-primitives.
jsconst arr = [];
arr.constructor = String;
arr.constructor === String; // true
arr instanceof String; // false
arr instanceof Array; // true

const foo = new Foo();
foo.constructor = "bar";
foo.constructor === "bar"; // true

// etc.

This does not overwrite the old constructor property — it was originally present on the instance's [[Prototype]], not as its own property.
jsconst arr = [];
Object.hasOwn(arr, "constructor"); // false
Object.hasOwn(Object.getPrototypeOf(arr), "constructor"); // true

arr.constructor = String;
Object.hasOwn(arr, "constructor"); // true — the instance property shadows the one on its prototype

But even when Object.getPrototypeOf(a).constructor is re-assigned, it won't change other behaviors of the object. For example, the behavior of instanceof is controlled by Symbol.hasInstance, not constructor:
jsconst arr = [];
arr.constructor = String;
arr instanceof String; // false
arr instanceof Array; // true

There is nothing protecting the constructor property from being re-assigned or shadowed, so using it to detect the type of a variable should usually be avoided in favor of less fragile ways like instanceof and Symbol.toStringTag for objects, or typeof for primitives.Changing the constructor of a constructor function's prototypeEvery constructor has a prototype property, which will become the instance's [[Prototype]] when called via the new operator. ConstructorFunction.prototype.constructor will therefore become a property on the instance's [[Prototype]], as previously demonstrated.
However, if ConstructorFunction.prototype is re-assigned, the constructor property will be lost. For example, the following is a common way to create an inheritance pattern:
jsfunction Parent() {
  // …
}
Parent.prototype.parentMethod = function () {};

function Child() {
  Parent.call(this); // Make sure everything is initialized properly
}
// Pointing the [[Prototype]] of Child.prototype to Parent.prototype
Child.prototype = Object.create(Parent.prototype);

The constructor of instances of Child will be Parent due to Child.prototype being re-assigned.
This is usually not a big deal — the language almost never reads the constructor property of an object. The only exception is when using [Symbol.species] to create new instances of a class, but such cases are rare, and you should be using the extends syntax to subclass builtins anyway.
However, ensuring that Child.prototype.constructor always points to Child itself is crucial when some caller is using constructor to access the original class from an instance. Take the following case: the object has the create() method to create itself.
jsfunction Parent() {
  // …
}
function CreatedConstructor() {
  Parent.call(this);
}

CreatedConstructor.prototype = Object.create(Parent.prototype);

CreatedConstructor.prototype.create = function () {
  return new this.constructor();
};

new CreatedConstructor().create().create(); // TypeError: new CreatedConstructor().create().create is undefined, since constructor === Parent

In the example above, an exception is thrown, since the constructor links to Parent. To avoid this, just assign the necessary constructor you are going to use.
jsfunction Parent() {
  // …
}
function CreatedConstructor() {
  // …
}

CreatedConstructor.prototype = Object.create(Parent.prototype, {
  // Return original constructor to Child
  constructor: {
    value: CreatedConstructor,
    enumerable: false, // Make it non-enumerable, so it won't appear in `for...in` loop
    writable: true,
    configurable: true,
  },
});

CreatedConstructor.prototype.create = function () {
  return new this.constructor();
};

new CreatedConstructor().create().create(); // it's pretty fine

Note that when manually adding the constructor property, it's crucial to make the property non-enumerable, so constructor won't be visited in for...in loops — as it normally isn't.
If the code above looks like too much boilerplate, you may also consider using Object.setPrototypeOf() to manipulate the prototype chain.
jsfunction Parent() {
  // …
}
function CreatedConstructor() {
  // …
}

Object.setPrototypeOf(CreatedConstructor.prototype, Parent.prototype);

CreatedConstructor.prototype.create = function () {
  return new this.constructor();
};

new CreatedConstructor().create().create(); // still works without re-creating constructor property

Object.setPrototypeOf() comes with its potential performance downsides because all previously created objects involved in the prototype chain have to be re-compiled; but if the above initialization code happens before Parent or CreatedConstructor are constructed, the effect should be minimal.
Let's consider one more involved case.
jsfunction ParentWithStatic() {}

ParentWithStatic.startPosition = { x: 0, y: 0 }; // Static member property
ParentWithStatic.getStartPosition = function () {
  return this.startPosition;
};

function Child(x, y) {
  this.position = { x, y };
}

Child.prototype = Object.create(ParentWithStatic.prototype, {
  // Return original constructor to Child
  constructor: {
    value: Child,
    enumerable: false,
    writable: true,
    configurable: true,
  },
});

Child.prototype.getOffsetByInitialPosition = function () {
  const position = this.position;
  // Using this.constructor, in hope that getStartPosition exists as a static method
  const startPosition = this.constructor.getStartPosition();

  return {
    offsetX: startPosition.x - position.x,
    offsetY: startPosition.y - position.y,
  };
};

new Child(1, 1).getOffsetByInitialPosition();
// Error: this.constructor.getStartPosition is undefined, since the
// constructor is Child, which doesn't have the getStartPosition static method

For this example to work properly, we can reassign the Parent's static properties to Child:
js// …
Object.assign(Child, ParentWithStatic); // Notice that we assign it before we create() a prototype below
Child.prototype = Object.create(ParentWithStatic.prototype, {
  // Return original constructor to Child
  constructor: {
    value: Child,
    enumerable: false,
    writable: true,
    configurable: true,
  },
});
// …

But even better, we can make the constructor functions themselves extend each other, as classes' extends do.
jsfunction ParentWithStatic() {}

ParentWithStatic.startPosition = { x: 0, y: 0 }; // Static member property
ParentWithStatic.getStartPosition = function () {
  return this.startPosition;
};

function Child(x, y) {
  this.position = { x, y };
}

// Properly create inheritance!
Object.setPrototypeOf(Child.prototype, ParentWithStatic.prototype);
Object.setPrototypeOf(Child, ParentWithStatic);

Child.prototype.getOffsetByInitialPosition = function () {
  const position = this.position;
  const startPosition = this.constructor.getStartPosition();

  return {
    offsetX: startPosition.x - position.x,
    offsetY: startPosition.y - position.y,
  };
};

console.log(new Child(1, 1).getOffsetByInitialPosition()); // { offsetX: -1, offsetY: -1 }

Again, using Object.setPrototypeOf() may have adverse performance effects, so make sure it happens immediately after the constructor declaration and before any instances are created — to avoid objects being "tainted".

Note:
Manually updating or setting the constructor can lead to different and sometimes confusing consequences. To prevent this, just define the role of constructor in each specific case. In most cases, constructor is not used and reassigning it is not necessary.
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object.prototype.constructorBrowser compatibilitySee also
class
constructor
Constructor
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIntl.CollatorBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.Learn moreSee full compatibilityReport feedbackThe Intl.Collator object enables language-sensitive string comparison.Try it
console.log(["Z", "a", "z", "ä"].sort(new Intl.Collator("de").compare));
// Expected output: Array ["a", "ä", "z", "Z"]

console.log(["Z", "a", "z", "ä"].sort(new Intl.Collator("sv").compare));
// Expected output: Array ["a", "z", "Z", "ä"]

console.log(
  ["Z", "a", "z", "ä"].sort(
    new Intl.Collator("de", { caseFirst: "upper" }).compare,
  ),
);
// Expected output: Array ["a", "ä", "Z", "z"]
Constructor
Intl.Collator()

Creates a new Collator object.

Static methods
Intl.Collator.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.Collator.prototype and shared by all Intl.Collator instances.

Intl.Collator.prototype.constructor

The constructor function that created the instance object. For Intl.Collator instances, the initial value is the Intl.Collator constructor.

Intl.Collator.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.Collator". This property is used in Object.prototype.toString().

Instance methods
Intl.Collator.prototype.compare()

Getter function that compares two strings according to the sort order of this Intl.Collator object.

Intl.Collator.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesUsing CollatorThe following example demonstrates the different potential results for a string occurring before, after, or at the same level as another:
jsconsole.log(new Intl.Collator().compare("a", "c")); // -1, or some other negative value
console.log(new Intl.Collator().compare("c", "a")); // 1, or some other positive value
console.log(new Intl.Collator().compare("a", "a")); // 0

Note that the results shown in the code above can vary between browsers and browser versions. This is because the values are implementation-specific. That is, the specification requires only that the before and after values are negative and positive.Using localesThe results provided by Intl.Collator.prototype.compare() vary between languages. In order to get the sort order of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
js// in German, ä sorts with a
console.log(new Intl.Collator("de").compare("ä", "z"));
// -1, or some other negative value

// in Swedish, ä sorts after z
console.log(new Intl.Collator("sv").compare("ä", "z"));
// 1, or some other positive value
Using optionsThe results provided by Intl.Collator.prototype.compare() can be customized using the options argument:
js// in German, ä has a as the base letter
console.log(new Intl.Collator("de", { sensitivity: "base" }).compare("ä", "a"));
// 0

// in Swedish, ä and a are separate base letters
console.log(new Intl.Collator("sv", { sensitivity: "base" }).compare("ä", "a"));
// 1, or some other positive value
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # collator-objectsBrowser compatibilitySee also
Intl
String.prototype.localeCompare()\n\nIntl.CollatorBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.Learn moreSee full compatibilityReport feedbackThe Intl.Collator object enables language-sensitive string comparison.Try it
console.log(["Z", "a", "z", "ä"].sort(new Intl.Collator("de").compare));
// Expected output: Array ["a", "ä", "z", "Z"]

console.log(["Z", "a", "z", "ä"].sort(new Intl.Collator("sv").compare));
// Expected output: Array ["a", "z", "Z", "ä"]

console.log(
  ["Z", "a", "z", "ä"].sort(
    new Intl.Collator("de", { caseFirst: "upper" }).compare,
  ),
);
// Expected output: Array ["a", "ä", "Z", "z"]
Constructor
Intl.Collator()

Creates a new Collator object.

Static methods
Intl.Collator.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.Collator.prototype and shared by all Intl.Collator instances.

Intl.Collator.prototype.constructor

The constructor function that created the instance object. For Intl.Collator instances, the initial value is the Intl.Collator constructor.

Intl.Collator.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.Collator". This property is used in Object.prototype.toString().

Instance methods
Intl.Collator.prototype.compare()

Getter function that compares two strings according to the sort order of this Intl.Collator object.

Intl.Collator.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesUsing CollatorThe following example demonstrates the different potential results for a string occurring before, after, or at the same level as another:
jsconsole.log(new Intl.Collator().compare("a", "c")); // -1, or some other negative value
console.log(new Intl.Collator().compare("c", "a")); // 1, or some other positive value
console.log(new Intl.Collator().compare("a", "a")); // 0

Note that the results shown in the code above can vary between browsers and browser versions. This is because the values are implementation-specific. That is, the specification requires only that the before and after values are negative and positive.Using localesThe results provided by Intl.Collator.prototype.compare() vary between languages. In order to get the sort order of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
js// in German, ä sorts with a
console.log(new Intl.Collator("de").compare("ä", "z"));
// -1, or some other negative value

// in Swedish, ä sorts after z
console.log(new Intl.Collator("sv").compare("ä", "z"));
// 1, or some other positive value
Using optionsThe results provided by Intl.Collator.prototype.compare() can be customized using the options argument:
js// in German, ä has a as the base letter
console.log(new Intl.Collator("de", { sensitivity: "base" }).compare("ä", "a"));
// 0

// in Swedish, ä and a are separate base letters
console.log(new Intl.Collator("sv", { sensitivity: "base" }).compare("ä", "a"));
// 1, or some other positive value
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # collator-objectsBrowser compatibilitySee also
Intl
String.prototype.localeCompare()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIntl.CollatorBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.Learn moreSee full compatibilityReport feedbackThe Intl.Collator object enables language-sensitive string comparison.Try it
console.log(["Z", "a", "z", "ä"].sort(new Intl.Collator("de").compare));
// Expected output: Array ["a", "ä", "z", "Z"]

console.log(["Z", "a", "z", "ä"].sort(new Intl.Collator("sv").compare));
// Expected output: Array ["a", "z", "Z", "ä"]

console.log(
  ["Z", "a", "z", "ä"].sort(
    new Intl.Collator("de", { caseFirst: "upper" }).compare,
  ),
);
// Expected output: Array ["a", "ä", "Z", "z"]
Constructor
Intl.Collator()

Creates a new Collator object.

Static methods
Intl.Collator.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.Collator.prototype and shared by all Intl.Collator instances.

Intl.Collator.prototype.constructor

The constructor function that created the instance object. For Intl.Collator instances, the initial value is the Intl.Collator constructor.

Intl.Collator.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.Collator". This property is used in Object.prototype.toString().

Instance methods
Intl.Collator.prototype.compare()

Getter function that compares two strings according to the sort order of this Intl.Collator object.

Intl.Collator.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesUsing CollatorThe following example demonstrates the different potential results for a string occurring before, after, or at the same level as another:
jsconsole.log(new Intl.Collator().compare("a", "c")); // -1, or some other negative value
console.log(new Intl.Collator().compare("c", "a")); // 1, or some other positive value
console.log(new Intl.Collator().compare("a", "a")); // 0

Note that the results shown in the code above can vary between browsers and browser versions. This is because the values are implementation-specific. That is, the specification requires only that the before and after values are negative and positive.Using localesThe results provided by Intl.Collator.prototype.compare() vary between languages. In order to get the sort order of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
js// in German, ä sorts with a
console.log(new Intl.Collator("de").compare("ä", "z"));
// -1, or some other negative value

// in Swedish, ä sorts after z
console.log(new Intl.Collator("sv").compare("ä", "z"));
// 1, or some other positive value
Using optionsThe results provided by Intl.Collator.prototype.compare() can be customized using the options argument:
js// in German, ä has a as the base letter
console.log(new Intl.Collator("de", { sensitivity: "base" }).compare("ä", "a"));
// 0

// in Swedish, ä and a are separate base letters
console.log(new Intl.Collator("sv", { sensitivity: "base" }).compare("ä", "a"));
// 1, or some other positive value
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # collator-objectsBrowser compatibilitySee also
Intl
String.prototype.localeCompare()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIntl.DateTimeFormatBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.Learn moreSee full compatibilityReport feedbackThe Intl.DateTimeFormat object enables language-sensitive date and time formatting.Try it
const date = new Date(Date.UTC(2020, 11, 20, 3, 23, 16, 738));
// Results below assume UTC timezone - your results may vary

// Specify default date formatting for language (locale)
console.log(new Intl.DateTimeFormat("en-US").format(date));
// Expected output: "12/20/2020"

// Specify default date formatting for language with a fallback language (in this case Indonesian)
console.log(new Intl.DateTimeFormat(["ban", "id"]).format(date));
// Expected output: "20/12/2020"

// Specify date and time format using "style" options (i.e. full, long, medium, short)
console.log(
  new Intl.DateTimeFormat("en-GB", {
    dateStyle: "full",
    timeStyle: "long",
    timeZone: "Australia/Sydney",
  }).format(date),
);
// Expected output: "Sunday, 20 December 2020 at 14:23:16 GMT+11"
Constructor
Intl.DateTimeFormat()

Creates a new Intl.DateTimeFormat object.

Static methods
Intl.DateTimeFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.DateTimeFormat.prototype and shared by all Intl.DateTimeFormat instances.

Intl.DateTimeFormat.prototype.constructor

The constructor function that created the instance object. For Intl.DateTimeFormat instances, the initial value is the Intl.DateTimeFormat constructor.

Intl.DateTimeFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.DateTimeFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.DateTimeFormat.prototype.format()

Getter function that formats a date according to the locale and formatting options of this DateTimeFormat object.

Intl.DateTimeFormat.prototype.formatRange()

This method receives two Dates and formats the date range in the most concise way based on the locale and options provided when instantiating DateTimeFormat.

Intl.DateTimeFormat.prototype.formatRangeToParts()

This method receives two Dates and returns an Array of objects containing the locale-specific tokens representing each part of the formatted date range.

Intl.DateTimeFormat.prototype.formatToParts()

Returns an Array of objects representing the date string in parts that can be used for custom locale-aware formatting.

Intl.DateTimeFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and formatting options computed during initialization of the object.

ExamplesUsing DateTimeFormatIn basic use without specifying a locale, DateTimeFormat uses the default locale and default options.
jsconst date = new Date(Date.UTC(2012, 11, 20, 3, 0, 0));

// toLocaleString without arguments depends on the implementation,
// the default locale, and the default time zone
console.log(new Intl.DateTimeFormat().format(date));
// "12/19/2012" if run with en-US locale (language) and time zone America/Los_Angeles (UTC-0800)
Using localesThis example shows some of the variations in localized date and time formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst date = new Date(Date.UTC(2012, 11, 20, 3, 0, 0));

// Results below use the time zone of America/Los_Angeles (UTC-0800, Pacific Standard Time)

// US English uses month-day-year order
console.log(new Intl.DateTimeFormat("en-US").format(date));
// "12/19/2012"

// British English uses day-month-year order
console.log(new Intl.DateTimeFormat("en-GB").format(date));
// "19/12/2012"

// Korean uses year-month-day order
console.log(new Intl.DateTimeFormat("ko-KR").format(date));
// "2012. 12. 19."

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.DateTimeFormat("ar-EG").format(date));
// "١٩‏/١٢‏/٢٠١٢"

// for Japanese, applications may want to use the Japanese calendar,
// where 2012 was the year 24 of the Heisei era
console.log(new Intl.DateTimeFormat("ja-JP-u-ca-japanese").format(date));
// "24/12/19"

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.DateTimeFormat(["ban", "id"]).format(date));
// "19/12/2012"
Using optionsThe date and time formats can be customized using the options argument:
jsconst date = new Date(Date.UTC(2012, 11, 20, 3, 0, 0, 200));

// request a weekday along with a long date
let options = {
  weekday: "long",
  year: "numeric",
  month: "long",
  day: "numeric",
};
console.log(new Intl.DateTimeFormat("de-DE", options).format(date));
// "Donnerstag, 20. Dezember 2012"

// an application may want to use UTC and make that visible
options.timeZone = "UTC";
options.timeZoneName = "short";
console.log(new Intl.DateTimeFormat("en-US", options).format(date));
// "Thursday, December 20, 2012, GMT"

// sometimes you want to be more precise
options = {
  hour: "numeric",
  minute: "numeric",
  second: "numeric",
  timeZone: "Australia/Sydney",
  timeZoneName: "short",
};
console.log(new Intl.DateTimeFormat("en-AU", options).format(date));
// "2:00:00 pm AEDT"

// sometimes you want to be very precise
options.fractionalSecondDigits = 3; // number digits for fraction-of-seconds
console.log(new Intl.DateTimeFormat("en-AU", options).format(date));
// "2:00:00.200 pm AEDT"

// sometimes even the US needs 24-hour time
options = {
  year: "numeric",
  month: "numeric",
  day: "numeric",
  hour: "numeric",
  minute: "numeric",
  second: "numeric",
  hour12: false,
  timeZone: "America/Los_Angeles",
};
console.log(new Intl.DateTimeFormat("en-US", options).format(date));
// "12/19/2012, 19:00:00"

// to specify options but use the browser's default locale, use undefined
console.log(new Intl.DateTimeFormat(undefined, options).format(date));
// "12/19/2012, 19:00:00"

// sometimes it's helpful to include the period of the day
options = { hour: "numeric", dayPeriod: "short" };
console.log(new Intl.DateTimeFormat("en-US", options).format(date));
// 10 at night

The used calendar and numbering formats can also be set independently via options arguments:
jsconst options = { calendar: "chinese", numberingSystem: "arab" };
const dateFormat = new Intl.DateTimeFormat(undefined, options);
const usedOptions = dateFormat.resolvedOptions();

console.log(usedOptions.calendar);
// "chinese"

console.log(usedOptions.numberingSystem);
// "arab"

console.log(usedOptions.timeZone);
// "America/New_York" (the users default timezone)
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # datetimeformat-objectsBrowser compatibilitySee also
Polyfill of Intl.DateTimeFormat in FormatJS
Intl
Date.prototype.toLocaleString()
Date.prototype.toLocaleDateString()
Date.prototype.toLocaleTimeString()
Temporal.Instant.prototype.toLocaleString()
Temporal.PlainDate.prototype.toLocaleString()
Temporal.PlainDateTime.prototype.toLocaleString()
Temporal.PlainTime.prototype.toLocaleString()
Temporal.PlainYearMonth.prototype.toLocaleString()
Temporal.PlainMonthDay.prototype.toLocaleString()
Temporal.ZonedDateTime.prototype.toLocaleString()\n\nIntl.DateTimeFormatBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.Learn moreSee full compatibilityReport feedbackThe Intl.DateTimeFormat object enables language-sensitive date and time formatting.Try it
const date = new Date(Date.UTC(2020, 11, 20, 3, 23, 16, 738));
// Results below assume UTC timezone - your results may vary

// Specify default date formatting for language (locale)
console.log(new Intl.DateTimeFormat("en-US").format(date));
// Expected output: "12/20/2020"

// Specify default date formatting for language with a fallback language (in this case Indonesian)
console.log(new Intl.DateTimeFormat(["ban", "id"]).format(date));
// Expected output: "20/12/2020"

// Specify date and time format using "style" options (i.e. full, long, medium, short)
console.log(
  new Intl.DateTimeFormat("en-GB", {
    dateStyle: "full",
    timeStyle: "long",
    timeZone: "Australia/Sydney",
  }).format(date),
);
// Expected output: "Sunday, 20 December 2020 at 14:23:16 GMT+11"
Constructor
Intl.DateTimeFormat()

Creates a new Intl.DateTimeFormat object.

Static methods
Intl.DateTimeFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.DateTimeFormat.prototype and shared by all Intl.DateTimeFormat instances.

Intl.DateTimeFormat.prototype.constructor

The constructor function that created the instance object. For Intl.DateTimeFormat instances, the initial value is the Intl.DateTimeFormat constructor.

Intl.DateTimeFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.DateTimeFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.DateTimeFormat.prototype.format()

Getter function that formats a date according to the locale and formatting options of this DateTimeFormat object.

Intl.DateTimeFormat.prototype.formatRange()

This method receives two Dates and formats the date range in the most concise way based on the locale and options provided when instantiating DateTimeFormat.

Intl.DateTimeFormat.prototype.formatRangeToParts()

This method receives two Dates and returns an Array of objects containing the locale-specific tokens representing each part of the formatted date range.

Intl.DateTimeFormat.prototype.formatToParts()

Returns an Array of objects representing the date string in parts that can be used for custom locale-aware formatting.

Intl.DateTimeFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and formatting options computed during initialization of the object.

ExamplesUsing DateTimeFormatIn basic use without specifying a locale, DateTimeFormat uses the default locale and default options.
jsconst date = new Date(Date.UTC(2012, 11, 20, 3, 0, 0));

// toLocaleString without arguments depends on the implementation,
// the default locale, and the default time zone
console.log(new Intl.DateTimeFormat().format(date));
// "12/19/2012" if run with en-US locale (language) and time zone America/Los_Angeles (UTC-0800)
Using localesThis example shows some of the variations in localized date and time formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst date = new Date(Date.UTC(2012, 11, 20, 3, 0, 0));

// Results below use the time zone of America/Los_Angeles (UTC-0800, Pacific Standard Time)

// US English uses month-day-year order
console.log(new Intl.DateTimeFormat("en-US").format(date));
// "12/19/2012"

// British English uses day-month-year order
console.log(new Intl.DateTimeFormat("en-GB").format(date));
// "19/12/2012"

// Korean uses year-month-day order
console.log(new Intl.DateTimeFormat("ko-KR").format(date));
// "2012. 12. 19."

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.DateTimeFormat("ar-EG").format(date));
// "١٩‏/١٢‏/٢٠١٢"

// for Japanese, applications may want to use the Japanese calendar,
// where 2012 was the year 24 of the Heisei era
console.log(new Intl.DateTimeFormat("ja-JP-u-ca-japanese").format(date));
// "24/12/19"

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.DateTimeFormat(["ban", "id"]).format(date));
// "19/12/2012"
Using optionsThe date and time formats can be customized using the options argument:
jsconst date = new Date(Date.UTC(2012, 11, 20, 3, 0, 0, 200));

// request a weekday along with a long date
let options = {
  weekday: "long",
  year: "numeric",
  month: "long",
  day: "numeric",
};
console.log(new Intl.DateTimeFormat("de-DE", options).format(date));
// "Donnerstag, 20. Dezember 2012"

// an application may want to use UTC and make that visible
options.timeZone = "UTC";
options.timeZoneName = "short";
console.log(new Intl.DateTimeFormat("en-US", options).format(date));
// "Thursday, December 20, 2012, GMT"

// sometimes you want to be more precise
options = {
  hour: "numeric",
  minute: "numeric",
  second: "numeric",
  timeZone: "Australia/Sydney",
  timeZoneName: "short",
};
console.log(new Intl.DateTimeFormat("en-AU", options).format(date));
// "2:00:00 pm AEDT"

// sometimes you want to be very precise
options.fractionalSecondDigits = 3; // number digits for fraction-of-seconds
console.log(new Intl.DateTimeFormat("en-AU", options).format(date));
// "2:00:00.200 pm AEDT"

// sometimes even the US needs 24-hour time
options = {
  year: "numeric",
  month: "numeric",
  day: "numeric",
  hour: "numeric",
  minute: "numeric",
  second: "numeric",
  hour12: false,
  timeZone: "America/Los_Angeles",
};
console.log(new Intl.DateTimeFormat("en-US", options).format(date));
// "12/19/2012, 19:00:00"

// to specify options but use the browser's default locale, use undefined
console.log(new Intl.DateTimeFormat(undefined, options).format(date));
// "12/19/2012, 19:00:00"

// sometimes it's helpful to include the period of the day
options = { hour: "numeric", dayPeriod: "short" };
console.log(new Intl.DateTimeFormat("en-US", options).format(date));
// 10 at night

The used calendar and numbering formats can also be set independently via options arguments:
jsconst options = { calendar: "chinese", numberingSystem: "arab" };
const dateFormat = new Intl.DateTimeFormat(undefined, options);
const usedOptions = dateFormat.resolvedOptions();

console.log(usedOptions.calendar);
// "chinese"

console.log(usedOptions.numberingSystem);
// "arab"

console.log(usedOptions.timeZone);
// "America/New_York" (the users default timezone)
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # datetimeformat-objectsBrowser compatibilitySee also
Polyfill of Intl.DateTimeFormat in FormatJS
Intl
Date.prototype.toLocaleString()
Date.prototype.toLocaleDateString()
Date.prototype.toLocaleTimeString()
Temporal.Instant.prototype.toLocaleString()
Temporal.PlainDate.prototype.toLocaleString()
Temporal.PlainDateTime.prototype.toLocaleString()
Temporal.PlainTime.prototype.toLocaleString()
Temporal.PlainYearMonth.prototype.toLocaleString()
Temporal.PlainMonthDay.prototype.toLocaleString()
Temporal.ZonedDateTime.prototype.toLocaleString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 27, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIntl.DateTimeFormatBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.Learn moreSee full compatibilityReport feedbackThe Intl.DateTimeFormat object enables language-sensitive date and time formatting.Try it
const date = new Date(Date.UTC(2020, 11, 20, 3, 23, 16, 738));
// Results below assume UTC timezone - your results may vary

// Specify default date formatting for language (locale)
console.log(new Intl.DateTimeFormat("en-US").format(date));
// Expected output: "12/20/2020"

// Specify default date formatting for language with a fallback language (in this case Indonesian)
console.log(new Intl.DateTimeFormat(["ban", "id"]).format(date));
// Expected output: "20/12/2020"

// Specify date and time format using "style" options (i.e. full, long, medium, short)
console.log(
  new Intl.DateTimeFormat("en-GB", {
    dateStyle: "full",
    timeStyle: "long",
    timeZone: "Australia/Sydney",
  }).format(date),
);
// Expected output: "Sunday, 20 December 2020 at 14:23:16 GMT+11"
Constructor
Intl.DateTimeFormat()

Creates a new Intl.DateTimeFormat object.

Static methods
Intl.DateTimeFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.DateTimeFormat.prototype and shared by all Intl.DateTimeFormat instances.

Intl.DateTimeFormat.prototype.constructor

The constructor function that created the instance object. For Intl.DateTimeFormat instances, the initial value is the Intl.DateTimeFormat constructor.

Intl.DateTimeFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.DateTimeFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.DateTimeFormat.prototype.format()

Getter function that formats a date according to the locale and formatting options of this DateTimeFormat object.

Intl.DateTimeFormat.prototype.formatRange()

This method receives two Dates and formats the date range in the most concise way based on the locale and options provided when instantiating DateTimeFormat.

Intl.DateTimeFormat.prototype.formatRangeToParts()

This method receives two Dates and returns an Array of objects containing the locale-specific tokens representing each part of the formatted date range.

Intl.DateTimeFormat.prototype.formatToParts()

Returns an Array of objects representing the date string in parts that can be used for custom locale-aware formatting.

Intl.DateTimeFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and formatting options computed during initialization of the object.

ExamplesUsing DateTimeFormatIn basic use without specifying a locale, DateTimeFormat uses the default locale and default options.
jsconst date = new Date(Date.UTC(2012, 11, 20, 3, 0, 0));

// toLocaleString without arguments depends on the implementation,
// the default locale, and the default time zone
console.log(new Intl.DateTimeFormat().format(date));
// "12/19/2012" if run with en-US locale (language) and time zone America/Los_Angeles (UTC-0800)
Using localesThis example shows some of the variations in localized date and time formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst date = new Date(Date.UTC(2012, 11, 20, 3, 0, 0));

// Results below use the time zone of America/Los_Angeles (UTC-0800, Pacific Standard Time)

// US English uses month-day-year order
console.log(new Intl.DateTimeFormat("en-US").format(date));
// "12/19/2012"

// British English uses day-month-year order
console.log(new Intl.DateTimeFormat("en-GB").format(date));
// "19/12/2012"

// Korean uses year-month-day order
console.log(new Intl.DateTimeFormat("ko-KR").format(date));
// "2012. 12. 19."

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.DateTimeFormat("ar-EG").format(date));
// "١٩‏/١٢‏/٢٠١٢"

// for Japanese, applications may want to use the Japanese calendar,
// where 2012 was the year 24 of the Heisei era
console.log(new Intl.DateTimeFormat("ja-JP-u-ca-japanese").format(date));
// "24/12/19"

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.DateTimeFormat(["ban", "id"]).format(date));
// "19/12/2012"
Using optionsThe date and time formats can be customized using the options argument:
jsconst date = new Date(Date.UTC(2012, 11, 20, 3, 0, 0, 200));

// request a weekday along with a long date
let options = {
  weekday: "long",
  year: "numeric",
  month: "long",
  day: "numeric",
};
console.log(new Intl.DateTimeFormat("de-DE", options).format(date));
// "Donnerstag, 20. Dezember 2012"

// an application may want to use UTC and make that visible
options.timeZone = "UTC";
options.timeZoneName = "short";
console.log(new Intl.DateTimeFormat("en-US", options).format(date));
// "Thursday, December 20, 2012, GMT"

// sometimes you want to be more precise
options = {
  hour: "numeric",
  minute: "numeric",
  second: "numeric",
  timeZone: "Australia/Sydney",
  timeZoneName: "short",
};
console.log(new Intl.DateTimeFormat("en-AU", options).format(date));
// "2:00:00 pm AEDT"

// sometimes you want to be very precise
options.fractionalSecondDigits = 3; // number digits for fraction-of-seconds
console.log(new Intl.DateTimeFormat("en-AU", options).format(date));
// "2:00:00.200 pm AEDT"

// sometimes even the US needs 24-hour time
options = {
  year: "numeric",
  month: "numeric",
  day: "numeric",
  hour: "numeric",
  minute: "numeric",
  second: "numeric",
  hour12: false,
  timeZone: "America/Los_Angeles",
};
console.log(new Intl.DateTimeFormat("en-US", options).format(date));
// "12/19/2012, 19:00:00"

// to specify options but use the browser's default locale, use undefined
console.log(new Intl.DateTimeFormat(undefined, options).format(date));
// "12/19/2012, 19:00:00"

// sometimes it's helpful to include the period of the day
options = { hour: "numeric", dayPeriod: "short" };
console.log(new Intl.DateTimeFormat("en-US", options).format(date));
// 10 at night

The used calendar and numbering formats can also be set independently via options arguments:
jsconst options = { calendar: "chinese", numberingSystem: "arab" };
const dateFormat = new Intl.DateTimeFormat(undefined, options);
const usedOptions = dateFormat.resolvedOptions();

console.log(usedOptions.calendar);
// "chinese"

console.log(usedOptions.numberingSystem);
// "arab"

console.log(usedOptions.timeZone);
// "America/New_York" (the users default timezone)
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # datetimeformat-objectsBrowser compatibilitySee also
Polyfill of Intl.DateTimeFormat in FormatJS
Intl
Date.prototype.toLocaleString()
Date.prototype.toLocaleDateString()
Date.prototype.toLocaleTimeString()
Temporal.Instant.prototype.toLocaleString()
Temporal.PlainDate.prototype.toLocaleString()
Temporal.PlainDateTime.prototype.toLocaleString()
Temporal.PlainTime.prototype.toLocaleString()
Temporal.PlainYearMonth.prototype.toLocaleString()
Temporal.PlainMonthDay.prototype.toLocaleString()
Temporal.ZonedDateTime.prototype.toLocaleString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 27, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIntl.DisplayNamesBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2021.Learn moreSee full compatibilityReport feedbackThe Intl.DisplayNames object enables the consistent translation of language, region and script display names.Try it
const regionNamesInEnglish = new Intl.DisplayNames(["en"], { type: "region" });
const regionNamesInTraditionalChinese = new Intl.DisplayNames(["zh-Hant"], {
  type: "region",
});

console.log(regionNamesInEnglish.of("US"));
// Expected output: "United States"

console.log(regionNamesInTraditionalChinese.of("US"));
// Expected output: "美國"
Constructor
Intl.DisplayNames()

Creates a new Intl.DisplayNames object.

Static methods
Intl.DisplayNames.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.DisplayNames.prototype and shared by all Intl.DisplayNames instances.

Intl.DisplayNames.prototype.constructor

The constructor function that created the instance object. For Intl.DisplayNames instances, the initial value is the Intl.DisplayNames constructor.

Intl.DisplayNames.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.DisplayNames". This property is used in Object.prototype.toString().

Instance methods
Intl.DisplayNames.prototype.of()

This method receives a code and returns a string based on the locale and options provided when instantiating Intl.DisplayNames.

Intl.DisplayNames.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and formatting options computed during initialization of the object.

ExamplesRegion Code Display NamesTo create an Intl.DisplayNames for a locale and get the display name for a region code.
js// Get display names of region in English
let regionNames = new Intl.DisplayNames(["en"], { type: "region" });
regionNames.of("419"); // "Latin America"
regionNames.of("BZ"); // "Belize"
regionNames.of("US"); // "United States"
regionNames.of("BA"); // "Bosnia & Herzegovina"
regionNames.of("MM"); // "Myanmar (Burma)"

// Get display names of region in Traditional Chinese
regionNames = new Intl.DisplayNames(["zh-Hant"], { type: "region" });
regionNames.of("419"); // "拉丁美洲"
regionNames.of("BZ"); // "貝里斯"
regionNames.of("US"); // "美國"
regionNames.of("BA"); // "波士尼亞與赫塞哥維納"
regionNames.of("MM"); // "緬甸"
Language Display NamesTo create an Intl.DisplayNames for a locale and get the display name for a language-script-region sequence.
js// Get display names of language in English
let languageNames = new Intl.DisplayNames(["en"], { type: "language" });
languageNames.of("fr"); // "French"
languageNames.of("de"); // "German"
languageNames.of("fr-CA"); // "Canadian French"
languageNames.of("zh-Hant"); // "Traditional Chinese"
languageNames.of("en-US"); // "American English"
languageNames.of("zh-TW"); // "Chinese (Taiwan)"]

// Get display names of language in Traditional Chinese
languageNames = new Intl.DisplayNames(["zh-Hant"], { type: "language" });
languageNames.of("fr"); // "法文"
languageNames.of("zh"); // "中文"
languageNames.of("de"); // "德文"
Script Code Display NamesTo create an Intl.DisplayNames for a locale and get the display name for a script code.
js// Get display names of script in English
let scriptNames = new Intl.DisplayNames(["en"], { type: "script" });
// Get script names
scriptNames.of("Latn"); // "Latin"
scriptNames.of("Arab"); // "Arabic"
scriptNames.of("Kana"); // "Katakana"

// Get display names of script in Traditional Chinese
scriptNames = new Intl.DisplayNames(["zh-Hant"], { type: "script" });
scriptNames.of("Latn"); // "拉丁文"
scriptNames.of("Arab"); // "阿拉伯文"
scriptNames.of("Kana"); // "片假名"
Currency Code Display NamesTo create an Intl.DisplayNames for a locale and get the display name for currency code.
js// Get display names of currency code in English
let currencyNames = new Intl.DisplayNames(["en"], { type: "currency" });
// Get currency names
currencyNames.of("USD"); // "US Dollar"
currencyNames.of("EUR"); // "Euro"
currencyNames.of("TWD"); // "New Taiwan Dollar"
currencyNames.of("CNY"); // "Chinese Yuan"

// Get display names of currency code in Traditional Chinese
currencyNames = new Intl.DisplayNames(["zh-Hant"], { type: "currency" });
currencyNames.of("USD"); // "美元"
currencyNames.of("EUR"); // "歐元"
currencyNames.of("TWD"); // "新台幣"
currencyNames.of("CNY"); // "人民幣"
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # intl-displaynames-objectsBrowser compatibilitySee also
Polyfill of Intl.DisplayNames in FormatJS
Intl\n\nIntl.DisplayNamesBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2021.Learn moreSee full compatibilityReport feedbackThe Intl.DisplayNames object enables the consistent translation of language, region and script display names.Try it
const regionNamesInEnglish = new Intl.DisplayNames(["en"], { type: "region" });
const regionNamesInTraditionalChinese = new Intl.DisplayNames(["zh-Hant"], {
  type: "region",
});

console.log(regionNamesInEnglish.of("US"));
// Expected output: "United States"

console.log(regionNamesInTraditionalChinese.of("US"));
// Expected output: "美國"
Constructor
Intl.DisplayNames()

Creates a new Intl.DisplayNames object.

Static methods
Intl.DisplayNames.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.DisplayNames.prototype and shared by all Intl.DisplayNames instances.

Intl.DisplayNames.prototype.constructor

The constructor function that created the instance object. For Intl.DisplayNames instances, the initial value is the Intl.DisplayNames constructor.

Intl.DisplayNames.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.DisplayNames". This property is used in Object.prototype.toString().

Instance methods
Intl.DisplayNames.prototype.of()

This method receives a code and returns a string based on the locale and options provided when instantiating Intl.DisplayNames.

Intl.DisplayNames.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and formatting options computed during initialization of the object.

ExamplesRegion Code Display NamesTo create an Intl.DisplayNames for a locale and get the display name for a region code.
js// Get display names of region in English
let regionNames = new Intl.DisplayNames(["en"], { type: "region" });
regionNames.of("419"); // "Latin America"
regionNames.of("BZ"); // "Belize"
regionNames.of("US"); // "United States"
regionNames.of("BA"); // "Bosnia & Herzegovina"
regionNames.of("MM"); // "Myanmar (Burma)"

// Get display names of region in Traditional Chinese
regionNames = new Intl.DisplayNames(["zh-Hant"], { type: "region" });
regionNames.of("419"); // "拉丁美洲"
regionNames.of("BZ"); // "貝里斯"
regionNames.of("US"); // "美國"
regionNames.of("BA"); // "波士尼亞與赫塞哥維納"
regionNames.of("MM"); // "緬甸"
Language Display NamesTo create an Intl.DisplayNames for a locale and get the display name for a language-script-region sequence.
js// Get display names of language in English
let languageNames = new Intl.DisplayNames(["en"], { type: "language" });
languageNames.of("fr"); // "French"
languageNames.of("de"); // "German"
languageNames.of("fr-CA"); // "Canadian French"
languageNames.of("zh-Hant"); // "Traditional Chinese"
languageNames.of("en-US"); // "American English"
languageNames.of("zh-TW"); // "Chinese (Taiwan)"]

// Get display names of language in Traditional Chinese
languageNames = new Intl.DisplayNames(["zh-Hant"], { type: "language" });
languageNames.of("fr"); // "法文"
languageNames.of("zh"); // "中文"
languageNames.of("de"); // "德文"
Script Code Display NamesTo create an Intl.DisplayNames for a locale and get the display name for a script code.
js// Get display names of script in English
let scriptNames = new Intl.DisplayNames(["en"], { type: "script" });
// Get script names
scriptNames.of("Latn"); // "Latin"
scriptNames.of("Arab"); // "Arabic"
scriptNames.of("Kana"); // "Katakana"

// Get display names of script in Traditional Chinese
scriptNames = new Intl.DisplayNames(["zh-Hant"], { type: "script" });
scriptNames.of("Latn"); // "拉丁文"
scriptNames.of("Arab"); // "阿拉伯文"
scriptNames.of("Kana"); // "片假名"
Currency Code Display NamesTo create an Intl.DisplayNames for a locale and get the display name for currency code.
js// Get display names of currency code in English
let currencyNames = new Intl.DisplayNames(["en"], { type: "currency" });
// Get currency names
currencyNames.of("USD"); // "US Dollar"
currencyNames.of("EUR"); // "Euro"
currencyNames.of("TWD"); // "New Taiwan Dollar"
currencyNames.of("CNY"); // "Chinese Yuan"

// Get display names of currency code in Traditional Chinese
currencyNames = new Intl.DisplayNames(["zh-Hant"], { type: "currency" });
currencyNames.of("USD"); // "美元"
currencyNames.of("EUR"); // "歐元"
currencyNames.of("TWD"); // "新台幣"
currencyNames.of("CNY"); // "人民幣"
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # intl-displaynames-objectsBrowser compatibilitySee also
Polyfill of Intl.DisplayNames in FormatJS
Intl
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIntl.DisplayNamesBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2021.Learn moreSee full compatibilityReport feedbackThe Intl.DisplayNames object enables the consistent translation of language, region and script display names.Try it
const regionNamesInEnglish = new Intl.DisplayNames(["en"], { type: "region" });
const regionNamesInTraditionalChinese = new Intl.DisplayNames(["zh-Hant"], {
  type: "region",
});

console.log(regionNamesInEnglish.of("US"));
// Expected output: "United States"

console.log(regionNamesInTraditionalChinese.of("US"));
// Expected output: "美國"
Constructor
Intl.DisplayNames()

Creates a new Intl.DisplayNames object.

Static methods
Intl.DisplayNames.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.DisplayNames.prototype and shared by all Intl.DisplayNames instances.

Intl.DisplayNames.prototype.constructor

The constructor function that created the instance object. For Intl.DisplayNames instances, the initial value is the Intl.DisplayNames constructor.

Intl.DisplayNames.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.DisplayNames". This property is used in Object.prototype.toString().

Instance methods
Intl.DisplayNames.prototype.of()

This method receives a code and returns a string based on the locale and options provided when instantiating Intl.DisplayNames.

Intl.DisplayNames.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and formatting options computed during initialization of the object.

ExamplesRegion Code Display NamesTo create an Intl.DisplayNames for a locale and get the display name for a region code.
js// Get display names of region in English
let regionNames = new Intl.DisplayNames(["en"], { type: "region" });
regionNames.of("419"); // "Latin America"
regionNames.of("BZ"); // "Belize"
regionNames.of("US"); // "United States"
regionNames.of("BA"); // "Bosnia & Herzegovina"
regionNames.of("MM"); // "Myanmar (Burma)"

// Get display names of region in Traditional Chinese
regionNames = new Intl.DisplayNames(["zh-Hant"], { type: "region" });
regionNames.of("419"); // "拉丁美洲"
regionNames.of("BZ"); // "貝里斯"
regionNames.of("US"); // "美國"
regionNames.of("BA"); // "波士尼亞與赫塞哥維納"
regionNames.of("MM"); // "緬甸"
Language Display NamesTo create an Intl.DisplayNames for a locale and get the display name for a language-script-region sequence.
js// Get display names of language in English
let languageNames = new Intl.DisplayNames(["en"], { type: "language" });
languageNames.of("fr"); // "French"
languageNames.of("de"); // "German"
languageNames.of("fr-CA"); // "Canadian French"
languageNames.of("zh-Hant"); // "Traditional Chinese"
languageNames.of("en-US"); // "American English"
languageNames.of("zh-TW"); // "Chinese (Taiwan)"]

// Get display names of language in Traditional Chinese
languageNames = new Intl.DisplayNames(["zh-Hant"], { type: "language" });
languageNames.of("fr"); // "法文"
languageNames.of("zh"); // "中文"
languageNames.of("de"); // "德文"
Script Code Display NamesTo create an Intl.DisplayNames for a locale and get the display name for a script code.
js// Get display names of script in English
let scriptNames = new Intl.DisplayNames(["en"], { type: "script" });
// Get script names
scriptNames.of("Latn"); // "Latin"
scriptNames.of("Arab"); // "Arabic"
scriptNames.of("Kana"); // "Katakana"

// Get display names of script in Traditional Chinese
scriptNames = new Intl.DisplayNames(["zh-Hant"], { type: "script" });
scriptNames.of("Latn"); // "拉丁文"
scriptNames.of("Arab"); // "阿拉伯文"
scriptNames.of("Kana"); // "片假名"
Currency Code Display NamesTo create an Intl.DisplayNames for a locale and get the display name for currency code.
js// Get display names of currency code in English
let currencyNames = new Intl.DisplayNames(["en"], { type: "currency" });
// Get currency names
currencyNames.of("USD"); // "US Dollar"
currencyNames.of("EUR"); // "Euro"
currencyNames.of("TWD"); // "New Taiwan Dollar"
currencyNames.of("CNY"); // "Chinese Yuan"

// Get display names of currency code in Traditional Chinese
currencyNames = new Intl.DisplayNames(["zh-Hant"], { type: "currency" });
currencyNames.of("USD"); // "美元"
currencyNames.of("EUR"); // "歐元"
currencyNames.of("TWD"); // "新台幣"
currencyNames.of("CNY"); // "人民幣"
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # intl-displaynames-objectsBrowser compatibilitySee also
Polyfill of Intl.DisplayNames in FormatJS
Intl
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIntl.DurationFormatBaseline 2025Newly availableSince March 2025, this feature works across the latest devices and browser versions. This feature might not work in older devices or browsers.Learn moreSee full compatibilityReport feedbackThe Intl.DurationFormat object enables language-sensitive duration formatting.Constructor
Intl.DurationFormat()

Creates a new Intl.DurationFormat object.

Static methods
Intl.DurationFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.DurationFormat.prototype and shared by all Intl.DurationFormat instances.

Intl.DurationFormat.prototype.constructor

The constructor function that created the instance object. For Intl.DurationFormat instances, the initial value is the Intl.DurationFormat constructor.

Intl.DurationFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.DurationFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.DurationFormat.prototype.format()

Getter function that formats a duration according to the locale and formatting options of this DurationFormat object.

Intl.DurationFormat.prototype.formatToParts()

Returns an Array of objects representing the formatted duration in parts.

Intl.DurationFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and formatting options computed during initialization of the object.

ExamplesUsing Intl.DurationFormatThe examples below show how to use the Intl.DurationFormat object to format a duration object with various locales and styles.
jsconst duration = {
  hours: 1,
  minutes: 46,
  seconds: 40,
};

// With style set to "long" and locale "fr-FR"
new Intl.DurationFormat("fr-FR", { style: "long" }).format(duration);
// "1 heure, 46 minutes et 40 secondes"

// With style set to "short" and locale "en"
new Intl.DurationFormat("en", { style: "short" }).format(duration);
// "1 hr, 46 min and 40 sec"

// With style set to "narrow" and locale "pt"
new Intl.DurationFormat("pt", { style: "narrow" }).format(duration);
// "1h 46min 40s"
SpecificationsSpecificationIntl.DurationFormat # durationformat-objectsBrowser compatibilitySee also
Polyfill of Intl.DurationFormat in FormatJS
Intl
Temporal.Duration.prototype.toLocaleString()\n\nIntl.DurationFormatBaseline 2025Newly availableSince March 2025, this feature works across the latest devices and browser versions. This feature might not work in older devices or browsers.Learn moreSee full compatibilityReport feedbackThe Intl.DurationFormat object enables language-sensitive duration formatting.Constructor
Intl.DurationFormat()

Creates a new Intl.DurationFormat object.

Static methods
Intl.DurationFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.DurationFormat.prototype and shared by all Intl.DurationFormat instances.

Intl.DurationFormat.prototype.constructor

The constructor function that created the instance object. For Intl.DurationFormat instances, the initial value is the Intl.DurationFormat constructor.

Intl.DurationFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.DurationFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.DurationFormat.prototype.format()

Getter function that formats a duration according to the locale and formatting options of this DurationFormat object.

Intl.DurationFormat.prototype.formatToParts()

Returns an Array of objects representing the formatted duration in parts.

Intl.DurationFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and formatting options computed during initialization of the object.

ExamplesUsing Intl.DurationFormatThe examples below show how to use the Intl.DurationFormat object to format a duration object with various locales and styles.
jsconst duration = {
  hours: 1,
  minutes: 46,
  seconds: 40,
};

// With style set to "long" and locale "fr-FR"
new Intl.DurationFormat("fr-FR", { style: "long" }).format(duration);
// "1 heure, 46 minutes et 40 secondes"

// With style set to "short" and locale "en"
new Intl.DurationFormat("en", { style: "short" }).format(duration);
// "1 hr, 46 min and 40 sec"

// With style set to "narrow" and locale "pt"
new Intl.DurationFormat("pt", { style: "narrow" }).format(duration);
// "1h 46min 40s"
SpecificationsSpecificationIntl.DurationFormat # durationformat-objectsBrowser compatibilitySee also
Polyfill of Intl.DurationFormat in FormatJS
Intl
Temporal.Duration.prototype.toLocaleString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jan 20, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIntl.DurationFormatBaseline 2025Newly availableSince March 2025, this feature works across the latest devices and browser versions. This feature might not work in older devices or browsers.Learn moreSee full compatibilityReport feedbackThe Intl.DurationFormat object enables language-sensitive duration formatting.Constructor
Intl.DurationFormat()

Creates a new Intl.DurationFormat object.

Static methods
Intl.DurationFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.DurationFormat.prototype and shared by all Intl.DurationFormat instances.

Intl.DurationFormat.prototype.constructor

The constructor function that created the instance object. For Intl.DurationFormat instances, the initial value is the Intl.DurationFormat constructor.

Intl.DurationFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.DurationFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.DurationFormat.prototype.format()

Getter function that formats a duration according to the locale and formatting options of this DurationFormat object.

Intl.DurationFormat.prototype.formatToParts()

Returns an Array of objects representing the formatted duration in parts.

Intl.DurationFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and formatting options computed during initialization of the object.

ExamplesUsing Intl.DurationFormatThe examples below show how to use the Intl.DurationFormat object to format a duration object with various locales and styles.
jsconst duration = {
  hours: 1,
  minutes: 46,
  seconds: 40,
};

// With style set to "long" and locale "fr-FR"
new Intl.DurationFormat("fr-FR", { style: "long" }).format(duration);
// "1 heure, 46 minutes et 40 secondes"

// With style set to "short" and locale "en"
new Intl.DurationFormat("en", { style: "short" }).format(duration);
// "1 hr, 46 min and 40 sec"

// With style set to "narrow" and locale "pt"
new Intl.DurationFormat("pt", { style: "narrow" }).format(duration);
// "1h 46min 40s"
SpecificationsSpecificationIntl.DurationFormat # durationformat-objectsBrowser compatibilitySee also
Polyfill of Intl.DurationFormat in FormatJS
Intl
Temporal.Duration.prototype.toLocaleString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jan 20, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIntl.ListFormatBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2021.Learn moreSee full compatibilityReport feedbackThe Intl.ListFormat object enables language-sensitive list formatting.Try it
const vehicles = ["Motorcycle", "Bus", "Car"];

const formatter = new Intl.ListFormat("en", {
  style: "long",
  type: "conjunction",
});
console.log(formatter.format(vehicles));
// Expected output: "Motorcycle, Bus, and Car"

const formatter2 = new Intl.ListFormat("de", {
  style: "short",
  type: "disjunction",
});
console.log(formatter2.format(vehicles));
// Expected output: "Motorcycle, Bus oder Car"

const formatter3 = new Intl.ListFormat("en", { style: "narrow", type: "unit" });
console.log(formatter3.format(vehicles));
// Expected output: "Motorcycle Bus Car"
Constructor
Intl.ListFormat()

Creates a new Intl.ListFormat object.

Static methods
Intl.ListFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.ListFormat.prototype and shared by all Intl.ListFormat instances.

Intl.ListFormat.prototype.constructor

The constructor function that created the instance object. For Intl.ListFormat instances, the initial value is the Intl.ListFormat constructor.

Intl.ListFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.ListFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.ListFormat.prototype.format()

Returns a language-specific formatted string representing the elements of the list.

Intl.ListFormat.prototype.formatToParts()

Returns an array of objects representing the different components that can be used to format a list of values in a locale-aware fashion.

Intl.ListFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and style formatting options computed during the construction of the current Intl.ListFormat object.

ExamplesUsing formatThe following example shows how to create a List formatter using the English language.
jsconst list = ["Motorcycle", "Bus", "Car"];

console.log(
  new Intl.ListFormat("en-GB", { style: "long", type: "conjunction" }).format(
    list,
  ),
);
// Motorcycle, Bus and Car

console.log(
  new Intl.ListFormat("en-GB", { style: "short", type: "disjunction" }).format(
    list,
  ),
);
// Motorcycle, Bus or Car

console.log(
  new Intl.ListFormat("en-GB", { style: "narrow", type: "unit" }).format(list),
);
// Motorcycle Bus Car
Using formatToPartsThe following example shows how to create a List formatter returning formatted parts
jsconst list = ["Motorcycle", "Bus", "Car"];
console.log(
  new Intl.ListFormat("en-GB", {
    style: "long",
    type: "conjunction",
  }).formatToParts(list),
);

// [ { "type": "element", "value": "Motorcycle" },
//   { "type": "literal", "value": ", " },
//   { "type": "element", "value": "Bus" },
//   { "type": "literal", "value": ", and " },
//   { "type": "element", "value": "Car" } ];
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # listformat-objectsBrowser compatibilitySee also
Polyfill of Intl.ListFormat in FormatJS
Intl\n\nIntl.ListFormatBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2021.Learn moreSee full compatibilityReport feedbackThe Intl.ListFormat object enables language-sensitive list formatting.Try it
const vehicles = ["Motorcycle", "Bus", "Car"];

const formatter = new Intl.ListFormat("en", {
  style: "long",
  type: "conjunction",
});
console.log(formatter.format(vehicles));
// Expected output: "Motorcycle, Bus, and Car"

const formatter2 = new Intl.ListFormat("de", {
  style: "short",
  type: "disjunction",
});
console.log(formatter2.format(vehicles));
// Expected output: "Motorcycle, Bus oder Car"

const formatter3 = new Intl.ListFormat("en", { style: "narrow", type: "unit" });
console.log(formatter3.format(vehicles));
// Expected output: "Motorcycle Bus Car"
Constructor
Intl.ListFormat()

Creates a new Intl.ListFormat object.

Static methods
Intl.ListFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.ListFormat.prototype and shared by all Intl.ListFormat instances.

Intl.ListFormat.prototype.constructor

The constructor function that created the instance object. For Intl.ListFormat instances, the initial value is the Intl.ListFormat constructor.

Intl.ListFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.ListFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.ListFormat.prototype.format()

Returns a language-specific formatted string representing the elements of the list.

Intl.ListFormat.prototype.formatToParts()

Returns an array of objects representing the different components that can be used to format a list of values in a locale-aware fashion.

Intl.ListFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and style formatting options computed during the construction of the current Intl.ListFormat object.

ExamplesUsing formatThe following example shows how to create a List formatter using the English language.
jsconst list = ["Motorcycle", "Bus", "Car"];

console.log(
  new Intl.ListFormat("en-GB", { style: "long", type: "conjunction" }).format(
    list,
  ),
);
// Motorcycle, Bus and Car

console.log(
  new Intl.ListFormat("en-GB", { style: "short", type: "disjunction" }).format(
    list,
  ),
);
// Motorcycle, Bus or Car

console.log(
  new Intl.ListFormat("en-GB", { style: "narrow", type: "unit" }).format(list),
);
// Motorcycle Bus Car
Using formatToPartsThe following example shows how to create a List formatter returning formatted parts
jsconst list = ["Motorcycle", "Bus", "Car"];
console.log(
  new Intl.ListFormat("en-GB", {
    style: "long",
    type: "conjunction",
  }).formatToParts(list),
);

// [ { "type": "element", "value": "Motorcycle" },
//   { "type": "literal", "value": ", " },
//   { "type": "element", "value": "Bus" },
//   { "type": "literal", "value": ", and " },
//   { "type": "element", "value": "Car" } ];
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # listformat-objectsBrowser compatibilitySee also
Polyfill of Intl.ListFormat in FormatJS
Intl
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIntl.ListFormatBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2021.Learn moreSee full compatibilityReport feedbackThe Intl.ListFormat object enables language-sensitive list formatting.Try it
const vehicles = ["Motorcycle", "Bus", "Car"];

const formatter = new Intl.ListFormat("en", {
  style: "long",
  type: "conjunction",
});
console.log(formatter.format(vehicles));
// Expected output: "Motorcycle, Bus, and Car"

const formatter2 = new Intl.ListFormat("de", {
  style: "short",
  type: "disjunction",
});
console.log(formatter2.format(vehicles));
// Expected output: "Motorcycle, Bus oder Car"

const formatter3 = new Intl.ListFormat("en", { style: "narrow", type: "unit" });
console.log(formatter3.format(vehicles));
// Expected output: "Motorcycle Bus Car"
Constructor
Intl.ListFormat()

Creates a new Intl.ListFormat object.

Static methods
Intl.ListFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.ListFormat.prototype and shared by all Intl.ListFormat instances.

Intl.ListFormat.prototype.constructor

The constructor function that created the instance object. For Intl.ListFormat instances, the initial value is the Intl.ListFormat constructor.

Intl.ListFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.ListFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.ListFormat.prototype.format()

Returns a language-specific formatted string representing the elements of the list.

Intl.ListFormat.prototype.formatToParts()

Returns an array of objects representing the different components that can be used to format a list of values in a locale-aware fashion.

Intl.ListFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and style formatting options computed during the construction of the current Intl.ListFormat object.

ExamplesUsing formatThe following example shows how to create a List formatter using the English language.
jsconst list = ["Motorcycle", "Bus", "Car"];

console.log(
  new Intl.ListFormat("en-GB", { style: "long", type: "conjunction" }).format(
    list,
  ),
);
// Motorcycle, Bus and Car

console.log(
  new Intl.ListFormat("en-GB", { style: "short", type: "disjunction" }).format(
    list,
  ),
);
// Motorcycle, Bus or Car

console.log(
  new Intl.ListFormat("en-GB", { style: "narrow", type: "unit" }).format(list),
);
// Motorcycle Bus Car
Using formatToPartsThe following example shows how to create a List formatter returning formatted parts
jsconst list = ["Motorcycle", "Bus", "Car"];
console.log(
  new Intl.ListFormat("en-GB", {
    style: "long",
    type: "conjunction",
  }).formatToParts(list),
);

// [ { "type": "element", "value": "Motorcycle" },
//   { "type": "literal", "value": ", " },
//   { "type": "element", "value": "Bus" },
//   { "type": "literal", "value": ", and " },
//   { "type": "element", "value": "Car" } ];
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # listformat-objectsBrowser compatibilitySee also
Polyfill of Intl.ListFormat in FormatJS
Intl
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIntl.LocaleBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2020.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.Locale object is a standard built-in property of the Intl object that represents a Unicode locale identifier.Try it
const korean = new Intl.Locale("ko", {
  script: "Kore",
  region: "KR",
  hourCycle: "h23",
  calendar: "gregory",
});

const japanese = new Intl.Locale("ja-Jpan-JP-u-ca-japanese-hc-h12");

console.log(korean.baseName, japanese.baseName);
// Expected output: "ko-Kore-KR" "ja-Jpan-JP"

console.log(korean.hourCycle, japanese.hourCycle);
// Expected output: "h23" "h12"
DescriptionThe Intl.Locale object was created to allow for easier manipulation of Unicode locales. Unicode represents locales with a string, called a locale identifier. The locale identifier consists of a language identifier and extension tags. Language identifiers are the core of the locale, consisting of language, script, and region subtags. Additional information about the locale is stored in the optional extension tags. Extension tags hold information about locale aspects such as calendar type, clock type, and numbering system type.
Traditionally, the Intl API used strings to represent locales, just as Unicode does. This is a simple and lightweight solution that works well. Adding a Locale class, however, adds ease of parsing and manipulating the language, script, and region, as well as extension tags. The following properties of Intl.Locale correspond to Unicode locale identifier subtags:



Property
Corresponding subtag




language
language (first part)


script
script (second part)


region
region (second/third part)


calendar
ca (extension)


caseFirst
kf (extension)


collation
co (extension)


hourCycle
hc (extension)


numberingSystem
nu (extension)


numeric
kn (extension)



The information above is exactly provided as-is when the Locale object is constructed, without consulting any external database. The Intl.Locale object additionally provides some methods that return information about the locale's real-world information, such as available calendars, collations, and numbering systems.Constructor
Intl.Locale()

Creates a new Locale object.

Instance propertiesThese properties are defined on Intl.Locale.prototype and shared by all Intl.Locale instances.

Intl.Locale.prototype.baseName

Returns basic, core information about the Locale in the form of a substring of the complete data string.

Intl.Locale.prototype.calendar

Returns the part of the Locale that indicates the Locale's calendar era.

Intl.Locale.prototype.caseFirst

Returns whether case is taken into account for the locale's collation rules.

Intl.Locale.prototype.collation

Returns the collation type for the Locale, which is used to order strings according to the locale's rules.

Intl.Locale.prototype.constructor

The constructor function that created the instance object. For Intl.Locale instances, the initial value is the Intl.Locale constructor.

Intl.Locale.prototype.hourCycle

Returns the time keeping format convention used by the locale.

Intl.Locale.prototype.language

Returns the language associated with the locale.

Intl.Locale.prototype.numberingSystem

Returns the numeral system used by the locale.

Intl.Locale.prototype.numeric

Returns whether the locale has special collation handling for numeric characters.

Intl.Locale.prototype.region

Returns the region of the world (usually a country) associated with the locale.

Intl.Locale.prototype.script

Returns the script used for writing the particular language used in the locale.

Intl.Locale.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.Locale". This property is used in Object.prototype.toString().

Instance methods
Intl.Locale.prototype.getCalendars()

Returns an Array of available calendar identifiers, according to the locale's rules.

Intl.Locale.prototype.getCollations()

Returns an Array of the collation types for the Locale.

Intl.Locale.prototype.getHourCycles()

Returns an Array of hour cycle identifiers, indicating either the 12-hour clock ("h12"), the Japanese 12-hour clock ("h11"), the 24-hour clock ("h23"), or the unused format "h24".

Intl.Locale.prototype.getNumberingSystems()

Returns an Array of numbering system identifiers available according to the locale's rules.

Intl.Locale.prototype.getTextInfo()

Returns the part indicating the ordering of characters ltr (left-to-right) or rtl (right-to-left).

Intl.Locale.prototype.getTimeZones()

Returns an Array of time zone identifiers, associated with the Locale.

Intl.Locale.prototype.getWeekInfo()

Returns UTS 35's Week Elements according to the locale rules.

Intl.Locale.prototype.maximize()

Gets the most likely values for the language, script, and region of the locale based on existing values.

Intl.Locale.prototype.minimize()

Attempts to remove information about the locale that would be added by calling maximize().

Intl.Locale.prototype.toString()

Returns the Locale's full locale identifier string.

ExamplesBasic usageAt its very simplest, the Intl.Locale() constructor takes a locale identifier string as its argument:
jsconst us = new Intl.Locale("en-US");
Using the Locale constructor with an options objectThe constructor also takes an optional configuration object argument, which can contain any of several extension types. For example, set the hourCycle property of the configuration object to your desired hour cycle type, and then pass it into the constructor:
jsconst us12hour = new Intl.Locale("en-US", { hourCycle: "h12" });
console.log(us12hour.hourCycle); // Prints "h12"
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # locale-objectsBrowser compatibilitySee also
Polyfill of Intl.Locale in FormatJS
Intl
Canonical Unicode Locale Identifiers in the Unicode locale data markup language spec\n\nIntl.LocaleBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2020.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.Locale object is a standard built-in property of the Intl object that represents a Unicode locale identifier.Try it
const korean = new Intl.Locale("ko", {
  script: "Kore",
  region: "KR",
  hourCycle: "h23",
  calendar: "gregory",
});

const japanese = new Intl.Locale("ja-Jpan-JP-u-ca-japanese-hc-h12");

console.log(korean.baseName, japanese.baseName);
// Expected output: "ko-Kore-KR" "ja-Jpan-JP"

console.log(korean.hourCycle, japanese.hourCycle);
// Expected output: "h23" "h12"
DescriptionThe Intl.Locale object was created to allow for easier manipulation of Unicode locales. Unicode represents locales with a string, called a locale identifier. The locale identifier consists of a language identifier and extension tags. Language identifiers are the core of the locale, consisting of language, script, and region subtags. Additional information about the locale is stored in the optional extension tags. Extension tags hold information about locale aspects such as calendar type, clock type, and numbering system type.
Traditionally, the Intl API used strings to represent locales, just as Unicode does. This is a simple and lightweight solution that works well. Adding a Locale class, however, adds ease of parsing and manipulating the language, script, and region, as well as extension tags. The following properties of Intl.Locale correspond to Unicode locale identifier subtags:



Property
Corresponding subtag




language
language (first part)


script
script (second part)


region
region (second/third part)


calendar
ca (extension)


caseFirst
kf (extension)


collation
co (extension)


hourCycle
hc (extension)


numberingSystem
nu (extension)


numeric
kn (extension)



The information above is exactly provided as-is when the Locale object is constructed, without consulting any external database. The Intl.Locale object additionally provides some methods that return information about the locale's real-world information, such as available calendars, collations, and numbering systems.Constructor
Intl.Locale()

Creates a new Locale object.

Instance propertiesThese properties are defined on Intl.Locale.prototype and shared by all Intl.Locale instances.

Intl.Locale.prototype.baseName

Returns basic, core information about the Locale in the form of a substring of the complete data string.

Intl.Locale.prototype.calendar

Returns the part of the Locale that indicates the Locale's calendar era.

Intl.Locale.prototype.caseFirst

Returns whether case is taken into account for the locale's collation rules.

Intl.Locale.prototype.collation

Returns the collation type for the Locale, which is used to order strings according to the locale's rules.

Intl.Locale.prototype.constructor

The constructor function that created the instance object. For Intl.Locale instances, the initial value is the Intl.Locale constructor.

Intl.Locale.prototype.hourCycle

Returns the time keeping format convention used by the locale.

Intl.Locale.prototype.language

Returns the language associated with the locale.

Intl.Locale.prototype.numberingSystem

Returns the numeral system used by the locale.

Intl.Locale.prototype.numeric

Returns whether the locale has special collation handling for numeric characters.

Intl.Locale.prototype.region

Returns the region of the world (usually a country) associated with the locale.

Intl.Locale.prototype.script

Returns the script used for writing the particular language used in the locale.

Intl.Locale.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.Locale". This property is used in Object.prototype.toString().

Instance methods
Intl.Locale.prototype.getCalendars()

Returns an Array of available calendar identifiers, according to the locale's rules.

Intl.Locale.prototype.getCollations()

Returns an Array of the collation types for the Locale.

Intl.Locale.prototype.getHourCycles()

Returns an Array of hour cycle identifiers, indicating either the 12-hour clock ("h12"), the Japanese 12-hour clock ("h11"), the 24-hour clock ("h23"), or the unused format "h24".

Intl.Locale.prototype.getNumberingSystems()

Returns an Array of numbering system identifiers available according to the locale's rules.

Intl.Locale.prototype.getTextInfo()

Returns the part indicating the ordering of characters ltr (left-to-right) or rtl (right-to-left).

Intl.Locale.prototype.getTimeZones()

Returns an Array of time zone identifiers, associated with the Locale.

Intl.Locale.prototype.getWeekInfo()

Returns UTS 35's Week Elements according to the locale rules.

Intl.Locale.prototype.maximize()

Gets the most likely values for the language, script, and region of the locale based on existing values.

Intl.Locale.prototype.minimize()

Attempts to remove information about the locale that would be added by calling maximize().

Intl.Locale.prototype.toString()

Returns the Locale's full locale identifier string.

ExamplesBasic usageAt its very simplest, the Intl.Locale() constructor takes a locale identifier string as its argument:
jsconst us = new Intl.Locale("en-US");
Using the Locale constructor with an options objectThe constructor also takes an optional configuration object argument, which can contain any of several extension types. For example, set the hourCycle property of the configuration object to your desired hour cycle type, and then pass it into the constructor:
jsconst us12hour = new Intl.Locale("en-US", { hourCycle: "h12" });
console.log(us12hour.hourCycle); // Prints "h12"
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # locale-objectsBrowser compatibilitySee also
Polyfill of Intl.Locale in FormatJS
Intl
Canonical Unicode Locale Identifiers in the Unicode locale data markup language spec
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIntl.LocaleBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2020.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.Locale object is a standard built-in property of the Intl object that represents a Unicode locale identifier.Try it
const korean = new Intl.Locale("ko", {
  script: "Kore",
  region: "KR",
  hourCycle: "h23",
  calendar: "gregory",
});

const japanese = new Intl.Locale("ja-Jpan-JP-u-ca-japanese-hc-h12");

console.log(korean.baseName, japanese.baseName);
// Expected output: "ko-Kore-KR" "ja-Jpan-JP"

console.log(korean.hourCycle, japanese.hourCycle);
// Expected output: "h23" "h12"
DescriptionThe Intl.Locale object was created to allow for easier manipulation of Unicode locales. Unicode represents locales with a string, called a locale identifier. The locale identifier consists of a language identifier and extension tags. Language identifiers are the core of the locale, consisting of language, script, and region subtags. Additional information about the locale is stored in the optional extension tags. Extension tags hold information about locale aspects such as calendar type, clock type, and numbering system type.
Traditionally, the Intl API used strings to represent locales, just as Unicode does. This is a simple and lightweight solution that works well. Adding a Locale class, however, adds ease of parsing and manipulating the language, script, and region, as well as extension tags. The following properties of Intl.Locale correspond to Unicode locale identifier subtags:



Property
Corresponding subtag




language
language (first part)


script
script (second part)


region
region (second/third part)


calendar
ca (extension)


caseFirst
kf (extension)


collation
co (extension)


hourCycle
hc (extension)


numberingSystem
nu (extension)


numeric
kn (extension)



The information above is exactly provided as-is when the Locale object is constructed, without consulting any external database. The Intl.Locale object additionally provides some methods that return information about the locale's real-world information, such as available calendars, collations, and numbering systems.Constructor
Intl.Locale()

Creates a new Locale object.

Instance propertiesThese properties are defined on Intl.Locale.prototype and shared by all Intl.Locale instances.

Intl.Locale.prototype.baseName

Returns basic, core information about the Locale in the form of a substring of the complete data string.

Intl.Locale.prototype.calendar

Returns the part of the Locale that indicates the Locale's calendar era.

Intl.Locale.prototype.caseFirst

Returns whether case is taken into account for the locale's collation rules.

Intl.Locale.prototype.collation

Returns the collation type for the Locale, which is used to order strings according to the locale's rules.

Intl.Locale.prototype.constructor

The constructor function that created the instance object. For Intl.Locale instances, the initial value is the Intl.Locale constructor.

Intl.Locale.prototype.hourCycle

Returns the time keeping format convention used by the locale.

Intl.Locale.prototype.language

Returns the language associated with the locale.

Intl.Locale.prototype.numberingSystem

Returns the numeral system used by the locale.

Intl.Locale.prototype.numeric

Returns whether the locale has special collation handling for numeric characters.

Intl.Locale.prototype.region

Returns the region of the world (usually a country) associated with the locale.

Intl.Locale.prototype.script

Returns the script used for writing the particular language used in the locale.

Intl.Locale.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.Locale". This property is used in Object.prototype.toString().

Instance methods
Intl.Locale.prototype.getCalendars()

Returns an Array of available calendar identifiers, according to the locale's rules.

Intl.Locale.prototype.getCollations()

Returns an Array of the collation types for the Locale.

Intl.Locale.prototype.getHourCycles()

Returns an Array of hour cycle identifiers, indicating either the 12-hour clock ("h12"), the Japanese 12-hour clock ("h11"), the 24-hour clock ("h23"), or the unused format "h24".

Intl.Locale.prototype.getNumberingSystems()

Returns an Array of numbering system identifiers available according to the locale's rules.

Intl.Locale.prototype.getTextInfo()

Returns the part indicating the ordering of characters ltr (left-to-right) or rtl (right-to-left).

Intl.Locale.prototype.getTimeZones()

Returns an Array of time zone identifiers, associated with the Locale.

Intl.Locale.prototype.getWeekInfo()

Returns UTS 35's Week Elements according to the locale rules.

Intl.Locale.prototype.maximize()

Gets the most likely values for the language, script, and region of the locale based on existing values.

Intl.Locale.prototype.minimize()

Attempts to remove information about the locale that would be added by calling maximize().

Intl.Locale.prototype.toString()

Returns the Locale's full locale identifier string.

ExamplesBasic usageAt its very simplest, the Intl.Locale() constructor takes a locale identifier string as its argument:
jsconst us = new Intl.Locale("en-US");
Using the Locale constructor with an options objectThe constructor also takes an optional configuration object argument, which can contain any of several extension types. For example, set the hourCycle property of the configuration object to your desired hour cycle type, and then pass it into the constructor:
jsconst us12hour = new Intl.Locale("en-US", { hourCycle: "h12" });
console.log(us12hour.hourCycle); // Prints "h12"
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # locale-objectsBrowser compatibilitySee also
Polyfill of Intl.Locale in FormatJS
Intl
Canonical Unicode Locale Identifiers in the Unicode locale data markup language spec
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIntl.PluralRulesBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2019.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.PluralRules object enables plural-sensitive formatting and plural-related language rules.DescriptionLanguages use different patterns for expressing both plural numbers of items (cardinal numbers) and for expressing the order of items (ordinal numbers).
English has two forms for expressing cardinal numbers: one for the singular "item" (1 hour, 1 dog, 1 fish) and the other for zero or any other number of "items" (0 hours, 2 lemmings, 100000.5 fish), while Chinese has only one form, and Arabic has six!
Similarly, English has four forms for expressing ordinal numbers: "th", "st", "nd", "rd", giving the sequence: 0th, 1st, 2nd, 3rd, 4th, 5th, ..., 21st, 22nd, 23rd, 24th, 25th, and so on, while both Chinese and Arabic only have one form for ordinal numbers.
Given a particular language and set of formatting options, the methods Intl.PluralRules.prototype.select() and Intl.PluralRules.prototype.selectRange() return a tag that represents the plural form of a single or a range of numbers, cardinal or ordinal.
Code can use the returned tags to represent numbers appropriately for the given language.
The full set of tags that might be returned are: zero, one, two, few, many, and other (the "general" plural form, also used if the language only has one form).
As English only has two forms for cardinal numbers, the select() method returns only two tags: "one" for the singular case, and "other" for all other cardinal numbers.
This allows construction of sentences that make sense in English for each case, such as: "1 dog is happy; do you want to play with it?" and "10 dogs are happy; do you want to play with them?".
Creating appropriate sentences for each form depends on the language, and even in English may not be as simple as just adding "s" to a noun to make the plural form.
Using the example above, we see that the form may affect:

Nouns: 1 dog, 2 dogs (but not "fish" or "sheep", which have the same singular and plural form).
Verbs: 1 dog is happy, 2 dogs are happy.
Pronouns (and other referents): Do you want to play with it / them.

Other languages have more forms, and choosing appropriate sentences can be even more complex.
select() can return any of four tags for ordinal numbers in English, representing each of the allowed forms: one for "st" numbers (1, 21, 31, ...), two for "nd" numbers (2, 22, 32, ...), few for "rd" numbers (3, 33, 43, ...), and other for "th" numbers (0, 4-20, etc.).
Again, the returned tags allow appropriate formatting of strings describing an ordinal number.
For more information about the rules and how they are used, see Plural Rules.
For a list of the rules and how they apply for different languages, see the LDML Language Plural Rules.Constructor
Intl.PluralRules()

Creates a new Intl.PluralRules object.

Static methods
Intl.PluralRules.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.PluralRules.prototype and shared by all Intl.PluralRules instances.

Intl.PluralRules.prototype.constructor

The constructor function that created the instance object. For Intl.PluralRules instances, the initial value is the Intl.PluralRules constructor.

Intl.PluralRules.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.PluralRules". This property is used in Object.prototype.toString().

Instance methods
Intl.PluralRules.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

Intl.PluralRules.prototype.select()

Returns a string indicating which plural rule to use for locale-aware formatting.

Intl.PluralRules.prototype.selectRange()

This method receives two values and returns a string indicating which plural rule to use for locale-aware formatting.

ExamplesUsing localesThis example shows some of the variations in localized plural rules for cardinal numbers.
In order to get the format for the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the constructor locales argument:
js// US English
const enCardinalRules = new Intl.PluralRules("en-US");
console.log(enCardinalRules.select(0)); // "other"
console.log(enCardinalRules.select(1)); // "one"
console.log(enCardinalRules.select(2)); // "other"
console.log(enCardinalRules.select(3)); // "other"

// Arabic
const arCardinalRules = new Intl.PluralRules("ar-EG");
console.log(arCardinalRules.select(0)); // "zero"
console.log(arCardinalRules.select(1)); // "one"
console.log(arCardinalRules.select(2)); // "two"
console.log(arCardinalRules.select(6)); // "few"
console.log(arCardinalRules.select(18)); // "many"
Using optionsThe plural form of the specified number may also depend on constructor options, such as how the number is rounded, and whether it is cardinal or ordinal.
This example shows how you can set the type of rules to "ordinal", and how this affects the form for some numbers in US English.
js// US English - ordinal
const enOrdinalRules = new Intl.PluralRules("en-US", { type: "ordinal" });
console.log(enOrdinalRules.select(0)); // "other" (0th)
console.log(enOrdinalRules.select(1)); // "one"   (1st)
console.log(enOrdinalRules.select(2)); // "two"   (2nd)
console.log(enOrdinalRules.select(3)); // "few"   (3rd)
console.log(enOrdinalRules.select(4)); // "other" (4th)
console.log(enOrdinalRules.select(21)); // "one"  (21st)
Formatting text using the returned tagThe code below extends the previous example, showing how you might use the returned tag for an ordinal number to format text in English.
jsconst enOrdinalRules = new Intl.PluralRules("en-US", { type: "ordinal" });

const suffixes = new Map([
  ["one", "st"],
  ["two", "nd"],
  ["few", "rd"],
  ["other", "th"],
]);
const formatOrdinals = (n) => {
  const rule = enOrdinalRules.select(n);
  const suffix = suffixes.get(rule);
  return `${n}${suffix}`;
};

formatOrdinals(0); // '0th'
formatOrdinals(1); // '1st'
formatOrdinals(2); // '2nd'
formatOrdinals(3); // '3rd'
formatOrdinals(4); // '4th'
formatOrdinals(11); // '11th'
formatOrdinals(21); // '21st'
formatOrdinals(42); // '42nd'
formatOrdinals(103); // '103rd'
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # pluralrules-objectsBrowser compatibilitySee also
Polyfill of Intl.PluralRules in FormatJS
Intl\n\nIntl.PluralRulesBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2019.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.PluralRules object enables plural-sensitive formatting and plural-related language rules.DescriptionLanguages use different patterns for expressing both plural numbers of items (cardinal numbers) and for expressing the order of items (ordinal numbers).
English has two forms for expressing cardinal numbers: one for the singular "item" (1 hour, 1 dog, 1 fish) and the other for zero or any other number of "items" (0 hours, 2 lemmings, 100000.5 fish), while Chinese has only one form, and Arabic has six!
Similarly, English has four forms for expressing ordinal numbers: "th", "st", "nd", "rd", giving the sequence: 0th, 1st, 2nd, 3rd, 4th, 5th, ..., 21st, 22nd, 23rd, 24th, 25th, and so on, while both Chinese and Arabic only have one form for ordinal numbers.
Given a particular language and set of formatting options, the methods Intl.PluralRules.prototype.select() and Intl.PluralRules.prototype.selectRange() return a tag that represents the plural form of a single or a range of numbers, cardinal or ordinal.
Code can use the returned tags to represent numbers appropriately for the given language.
The full set of tags that might be returned are: zero, one, two, few, many, and other (the "general" plural form, also used if the language only has one form).
As English only has two forms for cardinal numbers, the select() method returns only two tags: "one" for the singular case, and "other" for all other cardinal numbers.
This allows construction of sentences that make sense in English for each case, such as: "1 dog is happy; do you want to play with it?" and "10 dogs are happy; do you want to play with them?".
Creating appropriate sentences for each form depends on the language, and even in English may not be as simple as just adding "s" to a noun to make the plural form.
Using the example above, we see that the form may affect:

Nouns: 1 dog, 2 dogs (but not "fish" or "sheep", which have the same singular and plural form).
Verbs: 1 dog is happy, 2 dogs are happy.
Pronouns (and other referents): Do you want to play with it / them.

Other languages have more forms, and choosing appropriate sentences can be even more complex.
select() can return any of four tags for ordinal numbers in English, representing each of the allowed forms: one for "st" numbers (1, 21, 31, ...), two for "nd" numbers (2, 22, 32, ...), few for "rd" numbers (3, 33, 43, ...), and other for "th" numbers (0, 4-20, etc.).
Again, the returned tags allow appropriate formatting of strings describing an ordinal number.
For more information about the rules and how they are used, see Plural Rules.
For a list of the rules and how they apply for different languages, see the LDML Language Plural Rules.Constructor
Intl.PluralRules()

Creates a new Intl.PluralRules object.

Static methods
Intl.PluralRules.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.PluralRules.prototype and shared by all Intl.PluralRules instances.

Intl.PluralRules.prototype.constructor

The constructor function that created the instance object. For Intl.PluralRules instances, the initial value is the Intl.PluralRules constructor.

Intl.PluralRules.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.PluralRules". This property is used in Object.prototype.toString().

Instance methods
Intl.PluralRules.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

Intl.PluralRules.prototype.select()

Returns a string indicating which plural rule to use for locale-aware formatting.

Intl.PluralRules.prototype.selectRange()

This method receives two values and returns a string indicating which plural rule to use for locale-aware formatting.

ExamplesUsing localesThis example shows some of the variations in localized plural rules for cardinal numbers.
In order to get the format for the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the constructor locales argument:
js// US English
const enCardinalRules = new Intl.PluralRules("en-US");
console.log(enCardinalRules.select(0)); // "other"
console.log(enCardinalRules.select(1)); // "one"
console.log(enCardinalRules.select(2)); // "other"
console.log(enCardinalRules.select(3)); // "other"

// Arabic
const arCardinalRules = new Intl.PluralRules("ar-EG");
console.log(arCardinalRules.select(0)); // "zero"
console.log(arCardinalRules.select(1)); // "one"
console.log(arCardinalRules.select(2)); // "two"
console.log(arCardinalRules.select(6)); // "few"
console.log(arCardinalRules.select(18)); // "many"
Using optionsThe plural form of the specified number may also depend on constructor options, such as how the number is rounded, and whether it is cardinal or ordinal.
This example shows how you can set the type of rules to "ordinal", and how this affects the form for some numbers in US English.
js// US English - ordinal
const enOrdinalRules = new Intl.PluralRules("en-US", { type: "ordinal" });
console.log(enOrdinalRules.select(0)); // "other" (0th)
console.log(enOrdinalRules.select(1)); // "one"   (1st)
console.log(enOrdinalRules.select(2)); // "two"   (2nd)
console.log(enOrdinalRules.select(3)); // "few"   (3rd)
console.log(enOrdinalRules.select(4)); // "other" (4th)
console.log(enOrdinalRules.select(21)); // "one"  (21st)
Formatting text using the returned tagThe code below extends the previous example, showing how you might use the returned tag for an ordinal number to format text in English.
jsconst enOrdinalRules = new Intl.PluralRules("en-US", { type: "ordinal" });

const suffixes = new Map([
  ["one", "st"],
  ["two", "nd"],
  ["few", "rd"],
  ["other", "th"],
]);
const formatOrdinals = (n) => {
  const rule = enOrdinalRules.select(n);
  const suffix = suffixes.get(rule);
  return `${n}${suffix}`;
};

formatOrdinals(0); // '0th'
formatOrdinals(1); // '1st'
formatOrdinals(2); // '2nd'
formatOrdinals(3); // '3rd'
formatOrdinals(4); // '4th'
formatOrdinals(11); // '11th'
formatOrdinals(21); // '21st'
formatOrdinals(42); // '42nd'
formatOrdinals(103); // '103rd'
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # pluralrules-objectsBrowser compatibilitySee also
Polyfill of Intl.PluralRules in FormatJS
Intl
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Nov 24, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIntl.PluralRulesBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2019.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.PluralRules object enables plural-sensitive formatting and plural-related language rules.DescriptionLanguages use different patterns for expressing both plural numbers of items (cardinal numbers) and for expressing the order of items (ordinal numbers).
English has two forms for expressing cardinal numbers: one for the singular "item" (1 hour, 1 dog, 1 fish) and the other for zero or any other number of "items" (0 hours, 2 lemmings, 100000.5 fish), while Chinese has only one form, and Arabic has six!
Similarly, English has four forms for expressing ordinal numbers: "th", "st", "nd", "rd", giving the sequence: 0th, 1st, 2nd, 3rd, 4th, 5th, ..., 21st, 22nd, 23rd, 24th, 25th, and so on, while both Chinese and Arabic only have one form for ordinal numbers.
Given a particular language and set of formatting options, the methods Intl.PluralRules.prototype.select() and Intl.PluralRules.prototype.selectRange() return a tag that represents the plural form of a single or a range of numbers, cardinal or ordinal.
Code can use the returned tags to represent numbers appropriately for the given language.
The full set of tags that might be returned are: zero, one, two, few, many, and other (the "general" plural form, also used if the language only has one form).
As English only has two forms for cardinal numbers, the select() method returns only two tags: "one" for the singular case, and "other" for all other cardinal numbers.
This allows construction of sentences that make sense in English for each case, such as: "1 dog is happy; do you want to play with it?" and "10 dogs are happy; do you want to play with them?".
Creating appropriate sentences for each form depends on the language, and even in English may not be as simple as just adding "s" to a noun to make the plural form.
Using the example above, we see that the form may affect:

Nouns: 1 dog, 2 dogs (but not "fish" or "sheep", which have the same singular and plural form).
Verbs: 1 dog is happy, 2 dogs are happy.
Pronouns (and other referents): Do you want to play with it / them.

Other languages have more forms, and choosing appropriate sentences can be even more complex.
select() can return any of four tags for ordinal numbers in English, representing each of the allowed forms: one for "st" numbers (1, 21, 31, ...), two for "nd" numbers (2, 22, 32, ...), few for "rd" numbers (3, 33, 43, ...), and other for "th" numbers (0, 4-20, etc.).
Again, the returned tags allow appropriate formatting of strings describing an ordinal number.
For more information about the rules and how they are used, see Plural Rules.
For a list of the rules and how they apply for different languages, see the LDML Language Plural Rules.Constructor
Intl.PluralRules()

Creates a new Intl.PluralRules object.

Static methods
Intl.PluralRules.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.PluralRules.prototype and shared by all Intl.PluralRules instances.

Intl.PluralRules.prototype.constructor

The constructor function that created the instance object. For Intl.PluralRules instances, the initial value is the Intl.PluralRules constructor.

Intl.PluralRules.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.PluralRules". This property is used in Object.prototype.toString().

Instance methods
Intl.PluralRules.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

Intl.PluralRules.prototype.select()

Returns a string indicating which plural rule to use for locale-aware formatting.

Intl.PluralRules.prototype.selectRange()

This method receives two values and returns a string indicating which plural rule to use for locale-aware formatting.

ExamplesUsing localesThis example shows some of the variations in localized plural rules for cardinal numbers.
In order to get the format for the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the constructor locales argument:
js// US English
const enCardinalRules = new Intl.PluralRules("en-US");
console.log(enCardinalRules.select(0)); // "other"
console.log(enCardinalRules.select(1)); // "one"
console.log(enCardinalRules.select(2)); // "other"
console.log(enCardinalRules.select(3)); // "other"

// Arabic
const arCardinalRules = new Intl.PluralRules("ar-EG");
console.log(arCardinalRules.select(0)); // "zero"
console.log(arCardinalRules.select(1)); // "one"
console.log(arCardinalRules.select(2)); // "two"
console.log(arCardinalRules.select(6)); // "few"
console.log(arCardinalRules.select(18)); // "many"
Using optionsThe plural form of the specified number may also depend on constructor options, such as how the number is rounded, and whether it is cardinal or ordinal.
This example shows how you can set the type of rules to "ordinal", and how this affects the form for some numbers in US English.
js// US English - ordinal
const enOrdinalRules = new Intl.PluralRules("en-US", { type: "ordinal" });
console.log(enOrdinalRules.select(0)); // "other" (0th)
console.log(enOrdinalRules.select(1)); // "one"   (1st)
console.log(enOrdinalRules.select(2)); // "two"   (2nd)
console.log(enOrdinalRules.select(3)); // "few"   (3rd)
console.log(enOrdinalRules.select(4)); // "other" (4th)
console.log(enOrdinalRules.select(21)); // "one"  (21st)
Formatting text using the returned tagThe code below extends the previous example, showing how you might use the returned tag for an ordinal number to format text in English.
jsconst enOrdinalRules = new Intl.PluralRules("en-US", { type: "ordinal" });

const suffixes = new Map([
  ["one", "st"],
  ["two", "nd"],
  ["few", "rd"],
  ["other", "th"],
]);
const formatOrdinals = (n) => {
  const rule = enOrdinalRules.select(n);
  const suffix = suffixes.get(rule);
  return `${n}${suffix}`;
};

formatOrdinals(0); // '0th'
formatOrdinals(1); // '1st'
formatOrdinals(2); // '2nd'
formatOrdinals(3); // '3rd'
formatOrdinals(4); // '4th'
formatOrdinals(11); // '11th'
formatOrdinals(21); // '21st'
formatOrdinals(42); // '42nd'
formatOrdinals(103); // '103rd'
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # pluralrules-objectsBrowser compatibilitySee also
Polyfill of Intl.PluralRules in FormatJS
Intl
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Nov 24, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIntl.RelativeTimeFormatBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2020.Learn moreSee full compatibilityReport feedbackThe Intl.RelativeTimeFormat object enables language-sensitive relative time formatting.Try it
const rtf1 = new Intl.RelativeTimeFormat("en", { style: "short" });

console.log(rtf1.format(3, "quarter"));
// Expected output: "in 3 qtrs."

console.log(rtf1.format(-1, "day"));
// Expected output: "1 day ago"

const rtf2 = new Intl.RelativeTimeFormat("es", { numeric: "auto" });

console.log(rtf2.format(2, "day"));
// Expected output: "pasado mañana"
Constructor
Intl.RelativeTimeFormat()

Creates a new Intl.RelativeTimeFormat object.

Static methods
Intl.RelativeTimeFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.RelativeTimeFormat.prototype and shared by all Intl.RelativeTimeFormat instances.

Intl.RelativeTimeFormat.prototype.constructor

The constructor function that created the instance object. For Intl.RelativeTimeFormat instances, the initial value is the Intl.RelativeTimeFormat constructor.

Intl.RelativeTimeFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.RelativeTimeFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.RelativeTimeFormat.prototype.format()

Formats a value and a unit according to the locale and formatting options of the given Intl.RelativeTimeFormat object.

Intl.RelativeTimeFormat.prototype.formatToParts()

Returns an Array of objects representing the relative time format in parts that can be used for custom locale-aware formatting.

Intl.RelativeTimeFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and formatting options computed during initialization of the object.

ExamplesBasic format usageThe following example shows how to use a relative time formatter for the English language.
js// Create a relative time formatter in your locale
// with default values explicitly passed in.
const rtf = new Intl.RelativeTimeFormat("en", {
  localeMatcher: "best fit", // other values: "lookup"
  numeric: "always", // other values: "auto"
  style: "long", // other values: "short" or "narrow"
});

// Format relative time using negative value (-1).
rtf.format(-1, "day"); // "1 day ago"

// Format relative time using positive value (1).
rtf.format(1, "day"); // "in 1 day"
Using formatToPartsThe following example shows how to create a relative time formatter returning formatted parts.
jsconst rtf = new Intl.RelativeTimeFormat("en", { numeric: "auto" });

// Format relative time using the day unit.
rtf.formatToParts(-1, "day");
// [{ type: "literal", value: "yesterday"}]

rtf.formatToParts(100, "day");
// [
//   { type: "literal", value: "in " },
//   { type: "integer", value: "100", unit: "day" },
//   { type: "literal", value: " days" }
// ]
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # relativetimeformat-objectsBrowser compatibilitySee also
Polyfill of Intl.RelativeTimeFormat in FormatJS
Intl
Intl.RelativeTimeFormat on v8.dev (2018)\n\nIntl.RelativeTimeFormatBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2020.Learn moreSee full compatibilityReport feedbackThe Intl.RelativeTimeFormat object enables language-sensitive relative time formatting.Try it
const rtf1 = new Intl.RelativeTimeFormat("en", { style: "short" });

console.log(rtf1.format(3, "quarter"));
// Expected output: "in 3 qtrs."

console.log(rtf1.format(-1, "day"));
// Expected output: "1 day ago"

const rtf2 = new Intl.RelativeTimeFormat("es", { numeric: "auto" });

console.log(rtf2.format(2, "day"));
// Expected output: "pasado mañana"
Constructor
Intl.RelativeTimeFormat()

Creates a new Intl.RelativeTimeFormat object.

Static methods
Intl.RelativeTimeFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.RelativeTimeFormat.prototype and shared by all Intl.RelativeTimeFormat instances.

Intl.RelativeTimeFormat.prototype.constructor

The constructor function that created the instance object. For Intl.RelativeTimeFormat instances, the initial value is the Intl.RelativeTimeFormat constructor.

Intl.RelativeTimeFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.RelativeTimeFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.RelativeTimeFormat.prototype.format()

Formats a value and a unit according to the locale and formatting options of the given Intl.RelativeTimeFormat object.

Intl.RelativeTimeFormat.prototype.formatToParts()

Returns an Array of objects representing the relative time format in parts that can be used for custom locale-aware formatting.

Intl.RelativeTimeFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and formatting options computed during initialization of the object.

ExamplesBasic format usageThe following example shows how to use a relative time formatter for the English language.
js// Create a relative time formatter in your locale
// with default values explicitly passed in.
const rtf = new Intl.RelativeTimeFormat("en", {
  localeMatcher: "best fit", // other values: "lookup"
  numeric: "always", // other values: "auto"
  style: "long", // other values: "short" or "narrow"
});

// Format relative time using negative value (-1).
rtf.format(-1, "day"); // "1 day ago"

// Format relative time using positive value (1).
rtf.format(1, "day"); // "in 1 day"
Using formatToPartsThe following example shows how to create a relative time formatter returning formatted parts.
jsconst rtf = new Intl.RelativeTimeFormat("en", { numeric: "auto" });

// Format relative time using the day unit.
rtf.formatToParts(-1, "day");
// [{ type: "literal", value: "yesterday"}]

rtf.formatToParts(100, "day");
// [
//   { type: "literal", value: "in " },
//   { type: "integer", value: "100", unit: "day" },
//   { type: "literal", value: " days" }
// ]
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # relativetimeformat-objectsBrowser compatibilitySee also
Polyfill of Intl.RelativeTimeFormat in FormatJS
Intl
Intl.RelativeTimeFormat on v8.dev (2018)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIntl.RelativeTimeFormatBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2020.Learn moreSee full compatibilityReport feedbackThe Intl.RelativeTimeFormat object enables language-sensitive relative time formatting.Try it
const rtf1 = new Intl.RelativeTimeFormat("en", { style: "short" });

console.log(rtf1.format(3, "quarter"));
// Expected output: "in 3 qtrs."

console.log(rtf1.format(-1, "day"));
// Expected output: "1 day ago"

const rtf2 = new Intl.RelativeTimeFormat("es", { numeric: "auto" });

console.log(rtf2.format(2, "day"));
// Expected output: "pasado mañana"
Constructor
Intl.RelativeTimeFormat()

Creates a new Intl.RelativeTimeFormat object.

Static methods
Intl.RelativeTimeFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.RelativeTimeFormat.prototype and shared by all Intl.RelativeTimeFormat instances.

Intl.RelativeTimeFormat.prototype.constructor

The constructor function that created the instance object. For Intl.RelativeTimeFormat instances, the initial value is the Intl.RelativeTimeFormat constructor.

Intl.RelativeTimeFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.RelativeTimeFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.RelativeTimeFormat.prototype.format()

Formats a value and a unit according to the locale and formatting options of the given Intl.RelativeTimeFormat object.

Intl.RelativeTimeFormat.prototype.formatToParts()

Returns an Array of objects representing the relative time format in parts that can be used for custom locale-aware formatting.

Intl.RelativeTimeFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and formatting options computed during initialization of the object.

ExamplesBasic format usageThe following example shows how to use a relative time formatter for the English language.
js// Create a relative time formatter in your locale
// with default values explicitly passed in.
const rtf = new Intl.RelativeTimeFormat("en", {
  localeMatcher: "best fit", // other values: "lookup"
  numeric: "always", // other values: "auto"
  style: "long", // other values: "short" or "narrow"
});

// Format relative time using negative value (-1).
rtf.format(-1, "day"); // "1 day ago"

// Format relative time using positive value (1).
rtf.format(1, "day"); // "in 1 day"
Using formatToPartsThe following example shows how to create a relative time formatter returning formatted parts.
jsconst rtf = new Intl.RelativeTimeFormat("en", { numeric: "auto" });

// Format relative time using the day unit.
rtf.formatToParts(-1, "day");
// [{ type: "literal", value: "yesterday"}]

rtf.formatToParts(100, "day");
// [
//   { type: "literal", value: "in " },
//   { type: "integer", value: "100", unit: "day" },
//   { type: "literal", value: " days" }
// ]
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # relativetimeformat-objectsBrowser compatibilitySee also
Polyfill of Intl.RelativeTimeFormat in FormatJS
Intl
Intl.RelativeTimeFormat on v8.dev (2018)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIntl.SegmenterBaseline 2024Newly availableSince April 2024, this feature works across the latest devices and browser versions. This feature might not work in older devices or browsers.Learn moreSee full compatibilityReport feedbackThe Intl.Segmenter object enables locale-sensitive text segmentation, enabling you to get meaningful items (graphemes, words or sentences) from a string.Try it
const segmenterFr = new Intl.Segmenter("fr", { granularity: "word" });
const string1 = "Que ma joie demeure";

const iterator1 = segmenterFr.segment(string1)[Symbol.iterator]();

console.log(iterator1.next().value.segment);
// Expected output: 'Que'

console.log(iterator1.next().value.segment);
// Expected output: ' '
Constructor
Intl.Segmenter()

Creates a new Intl.Segmenter object.

Static methods
Intl.Segmenter.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.Segmenter.prototype and shared by all Intl.Segmenter instances.

Intl.Segmenter.prototype.constructor

The constructor function that created the instance object. For Intl.Segmenter instances, the initial value is the Intl.Segmenter constructor.

Intl.Segmenter.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.Segmenter". This property is used in Object.prototype.toString().

Instance methods
Intl.Segmenter.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and granularity options computed during initialization of this Intl.Segmenter object.

Intl.Segmenter.prototype.segment()

Returns a new iterable Segments instance representing the segments of a string according to the locale and granularity of this Intl.Segmenter instance.

ExamplesBasic usage and difference from String.prototype.split()If we were to use String.prototype.split(" ") to segment a text in words, we would not get the correct result if the locale of the text does not use whitespaces between words (which is the case for Japanese, Chinese, Thai, Lao, Khmer, Myanmar, etc.).
jsconst str = "吾輩は猫である。名前はたぬき。";
console.table(str.split(" "));
// ['吾輩は猫である。名前はたぬき。']
// The two sentences are not correctly segmented.

jsconst str = "吾輩は猫である。名前はたぬき。";
const segmenterJa = new Intl.Segmenter("ja-JP", { granularity: "word" });

const segments = segmenterJa.segment(str);
console.table(Array.from(segments));
// [{segment: '吾輩', index: 0, input: '吾輩は猫である。名前はたぬき。', isWordLike: true},
// etc.
// ]
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # segmenter-objectsBrowser compatibilitySee also
Polyfill of Intl.Segmenter in FormatJS
Intl\n\nIntl.SegmenterBaseline 2024Newly availableSince April 2024, this feature works across the latest devices and browser versions. This feature might not work in older devices or browsers.Learn moreSee full compatibilityReport feedbackThe Intl.Segmenter object enables locale-sensitive text segmentation, enabling you to get meaningful items (graphemes, words or sentences) from a string.Try it
const segmenterFr = new Intl.Segmenter("fr", { granularity: "word" });
const string1 = "Que ma joie demeure";

const iterator1 = segmenterFr.segment(string1)[Symbol.iterator]();

console.log(iterator1.next().value.segment);
// Expected output: 'Que'

console.log(iterator1.next().value.segment);
// Expected output: ' '
Constructor
Intl.Segmenter()

Creates a new Intl.Segmenter object.

Static methods
Intl.Segmenter.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.Segmenter.prototype and shared by all Intl.Segmenter instances.

Intl.Segmenter.prototype.constructor

The constructor function that created the instance object. For Intl.Segmenter instances, the initial value is the Intl.Segmenter constructor.

Intl.Segmenter.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.Segmenter". This property is used in Object.prototype.toString().

Instance methods
Intl.Segmenter.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and granularity options computed during initialization of this Intl.Segmenter object.

Intl.Segmenter.prototype.segment()

Returns a new iterable Segments instance representing the segments of a string according to the locale and granularity of this Intl.Segmenter instance.

ExamplesBasic usage and difference from String.prototype.split()If we were to use String.prototype.split(" ") to segment a text in words, we would not get the correct result if the locale of the text does not use whitespaces between words (which is the case for Japanese, Chinese, Thai, Lao, Khmer, Myanmar, etc.).
jsconst str = "吾輩は猫である。名前はたぬき。";
console.table(str.split(" "));
// ['吾輩は猫である。名前はたぬき。']
// The two sentences are not correctly segmented.

jsconst str = "吾輩は猫である。名前はたぬき。";
const segmenterJa = new Intl.Segmenter("ja-JP", { granularity: "word" });

const segments = segmenterJa.segment(str);
console.table(Array.from(segments));
// [{segment: '吾輩', index: 0, input: '吾輩は猫である。名前はたぬき。', isWordLike: true},
// etc.
// ]
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # segmenter-objectsBrowser compatibilitySee also
Polyfill of Intl.Segmenter in FormatJS
Intl
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIntl.SegmenterBaseline 2024Newly availableSince April 2024, this feature works across the latest devices and browser versions. This feature might not work in older devices or browsers.Learn moreSee full compatibilityReport feedbackThe Intl.Segmenter object enables locale-sensitive text segmentation, enabling you to get meaningful items (graphemes, words or sentences) from a string.Try it
const segmenterFr = new Intl.Segmenter("fr", { granularity: "word" });
const string1 = "Que ma joie demeure";

const iterator1 = segmenterFr.segment(string1)[Symbol.iterator]();

console.log(iterator1.next().value.segment);
// Expected output: 'Que'

console.log(iterator1.next().value.segment);
// Expected output: ' '
Constructor
Intl.Segmenter()

Creates a new Intl.Segmenter object.

Static methods
Intl.Segmenter.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.Segmenter.prototype and shared by all Intl.Segmenter instances.

Intl.Segmenter.prototype.constructor

The constructor function that created the instance object. For Intl.Segmenter instances, the initial value is the Intl.Segmenter constructor.

Intl.Segmenter.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.Segmenter". This property is used in Object.prototype.toString().

Instance methods
Intl.Segmenter.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and granularity options computed during initialization of this Intl.Segmenter object.

Intl.Segmenter.prototype.segment()

Returns a new iterable Segments instance representing the segments of a string according to the locale and granularity of this Intl.Segmenter instance.

ExamplesBasic usage and difference from String.prototype.split()If we were to use String.prototype.split(" ") to segment a text in words, we would not get the correct result if the locale of the text does not use whitespaces between words (which is the case for Japanese, Chinese, Thai, Lao, Khmer, Myanmar, etc.).
jsconst str = "吾輩は猫である。名前はたぬき。";
console.table(str.split(" "));
// ['吾輩は猫である。名前はたぬき。']
// The two sentences are not correctly segmented.

jsconst str = "吾輩は猫である。名前はたぬき。";
const segmenterJa = new Intl.Segmenter("ja-JP", { granularity: "word" });

const segments = segmenterJa.segment(str);
console.table(Array.from(segments));
// [{segment: '吾輩', index: 0, input: '吾輩は猫である。名前はたぬき。', isWordLike: true},
// etc.
// ]
SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # segmenter-objectsBrowser compatibilitySee also
Polyfill of Intl.Segmenter in FormatJS
Intl
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nBaseline (compatibility)Baseline identifies the availability of web platform features across popular browsers, including APIs, CSS properties, and JavaScript syntax. Baseline describes web features as being either widely available or newly available. Features that do not meet the Baseline criteria are said to have limited availability.
Baseline considers support in the following browsers:

Apple Safari (iOS)
Apple Safari (macOS)
Google Chrome (Android)
Google Chrome (desktop)
Microsoft Edge (desktop)
Mozilla Firefox (Android)
Mozilla Firefox (desktop)

Baseline is a summary of browser support. It is not a substitute for accessibility, usability, performance, security, or other testing. Baseline may not tell you if a feature works with:

Older devices and browser releases
Browsers not covered by the Baseline definition, such as operating system web views
Assistive technology, such as screen readers.
Baseline badges
Features listed as widely available have a consistent history of support in each of the Baseline browsers for at least 2.5 years.

Features listed as newly available work in at least the latest stable version of each of the Baseline browsers, but may not work with older browsers and devices.

Features listed with limited availability are not yet available in all browsers.See also
Testing
web-platform-dx/web-features repository
W3C WebDX Community Group
mdn/browser-compat-data repository
caniuse.com
a11ysupport.io\n\nBaseline (compatibility)Baseline identifies the availability of web platform features across popular browsers, including APIs, CSS properties, and JavaScript syntax. Baseline describes web features as being either widely available or newly available. Features that do not meet the Baseline criteria are said to have limited availability.
Baseline considers support in the following browsers:

Apple Safari (iOS)
Apple Safari (macOS)
Google Chrome (Android)
Google Chrome (desktop)
Microsoft Edge (desktop)
Mozilla Firefox (Android)
Mozilla Firefox (desktop)

Baseline is a summary of browser support. It is not a substitute for accessibility, usability, performance, security, or other testing. Baseline may not tell you if a feature works with:

Older devices and browser releases
Browsers not covered by the Baseline definition, such as operating system web views
Assistive technology, such as screen readers.
Baseline badges
Features listed as widely available have a consistent history of support in each of the Baseline browsers for at least 2.5 years.

Features listed as newly available work in at least the latest stable version of each of the Baseline browsers, but may not work with older browsers and devices.

Features listed with limited availability are not yet available in all browsers.See also
Testing
web-platform-dx/web-features repository
W3C WebDX Community Group
mdn/browser-compat-data repository
caniuse.com
a11ysupport.io
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Dec 19, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nBaseline (compatibility)Baseline identifies the availability of web platform features across popular browsers, including APIs, CSS properties, and JavaScript syntax. Baseline describes web features as being either widely available or newly available. Features that do not meet the Baseline criteria are said to have limited availability.
Baseline considers support in the following browsers:

Apple Safari (iOS)
Apple Safari (macOS)
Google Chrome (Android)
Google Chrome (desktop)
Microsoft Edge (desktop)
Mozilla Firefox (Android)
Mozilla Firefox (desktop)

Baseline is a summary of browser support. It is not a substitute for accessibility, usability, performance, security, or other testing. Baseline may not tell you if a feature works with:

Older devices and browser releases
Browsers not covered by the Baseline definition, such as operating system web views
Assistive technology, such as screen readers.
Baseline badges
Features listed as widely available have a consistent history of support in each of the Baseline browsers for at least 2.5 years.

Features listed as newly available work in at least the latest stable version of each of the Baseline browsers, but may not work with older browsers and devices.

Features listed with limited availability are not yet available in all browsers.See also
Testing
web-platform-dx/web-features repository
W3C WebDX Community Group
mdn/browser-compat-data repository
caniuse.com
a11ysupport.io
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Dec 19, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nSymbol.toStringTagBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2015.Learn moreSee full compatibilityReport feedbackThe Symbol.toStringTag static data property represents the well-known symbol Symbol.toStringTag. Object.prototype.toString() looks up this symbol on the this value for the property containing a string that represents the type of the object.Try it
class ValidatorClass {
  get [Symbol.toStringTag]() {
    return "Validator";
  }
}

console.log(Object.prototype.toString.call(new ValidatorClass()));
// Expected output: "[object Validator]"
ValueThe well-known symbol Symbol.toStringTag.
Property attributes of Symbol.toStringTagWritablenoEnumerablenoConfigurablenoExamplesDefault tagsSome values do not have Symbol.toStringTag, but have special toString() representations. For a complete list, see Object.prototype.toString().
jsObject.prototype.toString.call("foo"); // "[object String]"
Object.prototype.toString.call([1, 2]); // "[object Array]"
Object.prototype.toString.call(3); // "[object Number]"
Object.prototype.toString.call(true); // "[object Boolean]"
Object.prototype.toString.call(undefined); // "[object Undefined]"
Object.prototype.toString.call(null); // "[object Null]"
// … and more
Built-in toStringTag symbolsMost built-in objects provide their own [Symbol.toStringTag] property. Almost all built-in objects' [Symbol.toStringTag] property is not writable, not enumerable, and configurable; the exception is Iterator, which is writable for compatibility reasons.
For constructor objects like Promise, the property is installed on Constructor.prototype, so that all instances of the constructor inherit [Symbol.toStringTag] and can be stringified. For non-constructor objects like Math and JSON, the property is installed as a static property, so that the namespace object itself can be stringified. Sometimes, the constructor also provides its own toString method (for example, Intl.Locale), in which case the [Symbol.toStringTag] property is only used when you explicitly call Object.prototype.toString on it.
jsObject.prototype.toString.call(new Map()); // "[object Map]"
Object.prototype.toString.call(function* () {}); // "[object GeneratorFunction]"
Object.prototype.toString.call(Promise.resolve()); // "[object Promise]"
// … and more
Custom tag with toStringTagWhen creating your own class, JavaScript defaults to the "Object" tag:
jsclass ValidatorClass {}

Object.prototype.toString.call(new ValidatorClass()); // "[object Object]"

Now, with the help of toStringTag, you are able to set your own custom tag:
jsclass ValidatorClass {
  get [Symbol.toStringTag]() {
    return "Validator";
  }
}

Object.prototype.toString.call(new ValidatorClass()); // "[object Validator]"
toStringTag available on all DOM prototype objectsDue to a WebIDL spec change in mid-2020, browsers are adding a Symbol.toStringTag property to all DOM prototype objects. For example, to access the Symbol.toStringTag property on HTMLButtonElement:
jsconst test = document.createElement("button");
test.toString(); // "[object HTMLButtonElement]"
test[Symbol.toStringTag]; // "HTMLButtonElement"
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-symbol.tostringtagBrowser compatibilitySee also
Polyfill of Symbol.toStringTag in core-js
Object.prototype.toString()\n\nSymbol.toStringTagBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2015.Learn moreSee full compatibilityReport feedbackThe Symbol.toStringTag static data property represents the well-known symbol Symbol.toStringTag. Object.prototype.toString() looks up this symbol on the this value for the property containing a string that represents the type of the object.Try it
class ValidatorClass {
  get [Symbol.toStringTag]() {
    return "Validator";
  }
}

console.log(Object.prototype.toString.call(new ValidatorClass()));
// Expected output: "[object Validator]"
ValueThe well-known symbol Symbol.toStringTag.
Property attributes of Symbol.toStringTagWritablenoEnumerablenoConfigurablenoExamplesDefault tagsSome values do not have Symbol.toStringTag, but have special toString() representations. For a complete list, see Object.prototype.toString().
jsObject.prototype.toString.call("foo"); // "[object String]"
Object.prototype.toString.call([1, 2]); // "[object Array]"
Object.prototype.toString.call(3); // "[object Number]"
Object.prototype.toString.call(true); // "[object Boolean]"
Object.prototype.toString.call(undefined); // "[object Undefined]"
Object.prototype.toString.call(null); // "[object Null]"
// … and more
Built-in toStringTag symbolsMost built-in objects provide their own [Symbol.toStringTag] property. Almost all built-in objects' [Symbol.toStringTag] property is not writable, not enumerable, and configurable; the exception is Iterator, which is writable for compatibility reasons.
For constructor objects like Promise, the property is installed on Constructor.prototype, so that all instances of the constructor inherit [Symbol.toStringTag] and can be stringified. For non-constructor objects like Math and JSON, the property is installed as a static property, so that the namespace object itself can be stringified. Sometimes, the constructor also provides its own toString method (for example, Intl.Locale), in which case the [Symbol.toStringTag] property is only used when you explicitly call Object.prototype.toString on it.
jsObject.prototype.toString.call(new Map()); // "[object Map]"
Object.prototype.toString.call(function* () {}); // "[object GeneratorFunction]"
Object.prototype.toString.call(Promise.resolve()); // "[object Promise]"
// … and more
Custom tag with toStringTagWhen creating your own class, JavaScript defaults to the "Object" tag:
jsclass ValidatorClass {}

Object.prototype.toString.call(new ValidatorClass()); // "[object Object]"

Now, with the help of toStringTag, you are able to set your own custom tag:
jsclass ValidatorClass {
  get [Symbol.toStringTag]() {
    return "Validator";
  }
}

Object.prototype.toString.call(new ValidatorClass()); // "[object Validator]"
toStringTag available on all DOM prototype objectsDue to a WebIDL spec change in mid-2020, browsers are adding a Symbol.toStringTag property to all DOM prototype objects. For example, to access the Symbol.toStringTag property on HTMLButtonElement:
jsconst test = document.createElement("button");
test.toString(); // "[object HTMLButtonElement]"
test[Symbol.toStringTag]; // "HTMLButtonElement"
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-symbol.tostringtagBrowser compatibilitySee also
Polyfill of Symbol.toStringTag in core-js
Object.prototype.toString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 28, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nSymbol.toStringTagBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2015.Learn moreSee full compatibilityReport feedbackThe Symbol.toStringTag static data property represents the well-known symbol Symbol.toStringTag. Object.prototype.toString() looks up this symbol on the this value for the property containing a string that represents the type of the object.Try it
class ValidatorClass {
  get [Symbol.toStringTag]() {
    return "Validator";
  }
}

console.log(Object.prototype.toString.call(new ValidatorClass()));
// Expected output: "[object Validator]"
ValueThe well-known symbol Symbol.toStringTag.
Property attributes of Symbol.toStringTagWritablenoEnumerablenoConfigurablenoExamplesDefault tagsSome values do not have Symbol.toStringTag, but have special toString() representations. For a complete list, see Object.prototype.toString().
jsObject.prototype.toString.call("foo"); // "[object String]"
Object.prototype.toString.call([1, 2]); // "[object Array]"
Object.prototype.toString.call(3); // "[object Number]"
Object.prototype.toString.call(true); // "[object Boolean]"
Object.prototype.toString.call(undefined); // "[object Undefined]"
Object.prototype.toString.call(null); // "[object Null]"
// … and more
Built-in toStringTag symbolsMost built-in objects provide their own [Symbol.toStringTag] property. Almost all built-in objects' [Symbol.toStringTag] property is not writable, not enumerable, and configurable; the exception is Iterator, which is writable for compatibility reasons.
For constructor objects like Promise, the property is installed on Constructor.prototype, so that all instances of the constructor inherit [Symbol.toStringTag] and can be stringified. For non-constructor objects like Math and JSON, the property is installed as a static property, so that the namespace object itself can be stringified. Sometimes, the constructor also provides its own toString method (for example, Intl.Locale), in which case the [Symbol.toStringTag] property is only used when you explicitly call Object.prototype.toString on it.
jsObject.prototype.toString.call(new Map()); // "[object Map]"
Object.prototype.toString.call(function* () {}); // "[object GeneratorFunction]"
Object.prototype.toString.call(Promise.resolve()); // "[object Promise]"
// … and more
Custom tag with toStringTagWhen creating your own class, JavaScript defaults to the "Object" tag:
jsclass ValidatorClass {}

Object.prototype.toString.call(new ValidatorClass()); // "[object Object]"

Now, with the help of toStringTag, you are able to set your own custom tag:
jsclass ValidatorClass {
  get [Symbol.toStringTag]() {
    return "Validator";
  }
}

Object.prototype.toString.call(new ValidatorClass()); // "[object Validator]"
toStringTag available on all DOM prototype objectsDue to a WebIDL spec change in mid-2020, browsers are adding a Symbol.toStringTag property to all DOM prototype objects. For example, to access the Symbol.toStringTag property on HTMLButtonElement:
jsconst test = document.createElement("button");
test.toString(); // "[object HTMLButtonElement]"
test[Symbol.toStringTag]; // "HTMLButtonElement"
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-symbol.tostringtagBrowser compatibilitySee also
Polyfill of Symbol.toStringTag in core-js
Object.prototype.toString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 28, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nArrayBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Array object, as with arrays in other programming languages, enables storing a collection of multiple items under a single variable name, and has members for performing common array operations.DescriptionIn JavaScript, arrays aren't primitives but are instead Array objects with the following core characteristics:

JavaScript arrays are resizable and can contain a mix of different data types. (When those characteristics are undesirable, use typed arrays instead.)
JavaScript arrays are not associative arrays and so, array elements cannot be accessed using arbitrary strings as indexes, but must be accessed using nonnegative integers (or their respective string form) as indexes.
JavaScript arrays are zero-indexed: the first element of an array is at index 0, the second is at index 1, and so on — and the last element is at the value of the array's length property minus 1.
JavaScript array-copy operations create shallow copies. (All standard built-in copy operations with any JavaScript objects create shallow copies, rather than deep copies).
Array indicesArray objects cannot use arbitrary strings as element indexes (as in an associative array) but must use nonnegative integers (or their respective string form). Setting or accessing via non-integers will not set or retrieve an element from the array list itself, but will set or access a variable associated with that array's object property collection. The array's object properties and list of array elements are separate, and the array's traversal and mutation operations cannot be applied to these named properties.
Array elements are object properties in the same way that toString is a property (to be specific, however, toString() is a method). Nevertheless, trying to access an element of an array as follows throws a syntax error because the property name is not valid:
jsarr.0; // a syntax error

JavaScript syntax requires properties beginning with a digit to be accessed using bracket notation instead of dot notation. It's also possible to quote the array indices (e.g., years['2'] instead of years[2]), although usually not necessary.
The 2 in years[2] is coerced into a string by the JavaScript engine through an implicit toString conversion. As a result, '2' and '02' would refer to two different slots on the years object, and the following example could be true:
jsconsole.log(years["2"] !== years["02"]);

Only years['2'] is an actual array index. years['02'] is an arbitrary string property that will not be visited in array iteration.Relationship between length and numerical propertiesA JavaScript array's length property and numerical properties are connected.
Several of the built-in array methods (e.g., join(), slice(), indexOf(), etc.) take into account the value of an array's length property when they're called.
Other methods (e.g., push(), splice(), etc.) also result in updates to an array's length property.
jsconst fruits = [];
fruits.push("banana", "apple", "peach");
console.log(fruits.length); // 3

When setting a property on a JavaScript array when the property is a valid array index and that index is outside the current bounds of the array, the engine will update the array's length property accordingly:
jsfruits[5] = "mango";
console.log(fruits[5]); // 'mango'
console.log(Object.keys(fruits)); // ['0', '1', '2', '5']
console.log(fruits.length); // 6

Increasing the length extends the array by adding empty slots without creating any new elements — not even undefined.
jsfruits.length = 10;
console.log(fruits); // ['banana', 'apple', 'peach', empty x 2, 'mango', empty x 4]
console.log(Object.keys(fruits)); // ['0', '1', '2', '5']
console.log(fruits.length); // 10
console.log(fruits[8]); // undefined

Decreasing the length property does, however, delete elements.
jsfruits.length = 2;
console.log(Object.keys(fruits)); // ['0', '1']
console.log(fruits.length); // 2

This is explained further on the length page.Array methods and empty slotsArray methods have different behaviors when encountering empty slots in sparse arrays. In general, older methods (e.g., forEach) treat empty slots differently from indices that contain undefined.
Methods that have special treatment for empty slots include the following: concat(), copyWithin(), every(), filter(), flat(), flatMap(), forEach(), indexOf(), lastIndexOf(), map(), reduce(), reduceRight(), reverse(), slice(), some(), sort(), and splice(). Iteration methods such as forEach don't visit empty slots at all. Other methods, such as concat, copyWithin, etc., preserve empty slots when doing the copying, so in the end the array is still sparse.
jsconst colors = ["red", "yellow", "blue"];
colors[5] = "purple";
colors.forEach((item, index) => {
  console.log(`${index}: ${item}`);
});
// Output:
// 0: red
// 1: yellow
// 2: blue
// 5: purple

colors.reverse(); // ['purple', empty × 2, 'blue', 'yellow', 'red']

Newer methods (e.g., keys) do not treat empty slots specially and treat them as if they contain undefined. Methods that conflate empty slots with undefined elements include the following: entries(), fill(), find(), findIndex(), findLast(), findLastIndex(), includes(), join(), keys(), toLocaleString(), toReversed(), toSorted(), toSpliced(), values(), and with().
jsconst colors = ["red", "yellow", "blue"];
colors[5] = "purple";
const iterator = colors.keys();
for (const key of iterator) {
  console.log(`${key}: ${colors[key]}`);
}
// Output
// 0: red
// 1: yellow
// 2: blue
// 3: undefined
// 4: undefined
// 5: purple

const newColors = colors.toReversed(); // ['purple', undefined, undefined, 'blue', 'yellow', 'red']
Copying methods and mutating methodsSome methods do not mutate the existing array that the method was called on, but instead return a new array. They do so by first constructing a new array and then populating it with elements. The copy always happens shallowly — the method never copies anything beyond the initially created array. Elements of the original array(s) are copied into the new array as follows:

Objects: the object reference is copied into the new array. Both the original and new array refer to the same object. That is, if a referenced object is modified, the changes are visible to both the new and original arrays.
Primitive types such as strings, numbers and booleans (not String, Number, and Boolean objects): their values are copied into the new array.

Other methods mutate the array that the method was called on, in which case their return value differs depending on the method: sometimes a reference to the same array, sometimes the length of the new array.
The following methods create new arrays by accessing this.constructor[Symbol.species] to determine the constructor to use: concat(), filter(), flat(), flatMap(), map(), slice(), and splice() (to construct the array of removed elements that's returned).
The following methods always create new arrays with the Array base constructor: toReversed(), toSorted(), toSpliced(), and with().
The following table lists the methods that mutate the original array, and the corresponding non-mutating alternative:



Mutating method
Non-mutating alternative




copyWithin()
No one-method alternative


fill()
No one-method alternative


pop()
slice(0, -1)


push(v1, v2)
concat([v1, v2])


reverse()
toReversed()


shift()
slice(1)


sort()
toSorted()


splice()
toSpliced()


unshift(v1, v2)
toSpliced(0, 0, v1, v2)



An easy way to change a mutating method into a non-mutating alternative is to use the spread syntax or slice() to create a copy first:
jsarr.copyWithin(0, 1, 2); // mutates arr
const arr2 = arr.slice().copyWithin(0, 1, 2); // does not mutate arr
const arr3 = [...arr].copyWithin(0, 1, 2); // does not mutate arr
Iterative methodsMany array methods take a callback function as an argument. The callback function is called sequentially and at most once for each element in the array, and the return value of the callback function is used to determine the return value of the method. They all share the same signature:
jsmethod(callbackFn, thisArg)

Where callbackFn takes three arguments:

element

The current element being processed in the array.

index

The index of the current element being processed in the array.

array

The array that the method was called upon.


What callbackFn is expected to return depends on the array method that was called.
The thisArg argument (defaults to undefined) will be used as the this value when calling callbackFn. The this value ultimately observable by callbackFn is determined according to the usual rules: if callbackFn is non-strict, primitive this values are wrapped into objects, and undefined/null is substituted with globalThis. The thisArg argument is irrelevant for any callbackFn defined with an arrow function, as arrow functions don't have their own this binding.
The array argument passed to callbackFn is most useful if you want to read another index during iteration, because you may not always have an existing variable that refers to the current array. You should generally not mutate the array during iteration (see mutating initial array in iterative methods), but you can also use this argument to do so. The array argument is not the array that is being built, in the case of methods like map(), filter(), and flatMap() — there is no way to access the array being built from the callback function.
All iterative methods are copying and generic, although they behave differently with empty slots.
The following methods are iterative: every(), filter(), find(), findIndex(), findLast(), findLastIndex(), flatMap(), forEach(), map(), and some().
In particular, every(), find(), findIndex(), findLast(), findLastIndex(), and some() do not always invoke callbackFn on every element — they stop iteration as soon as the return value is determined.
The reduce() and reduceRight() methods also take a callback function and run it at most once for each element in the array, but they have slightly different signatures from typical iterative methods (for example, they don't accept thisArg).
The sort() method also takes a callback function, but it is not an iterative method. It mutates the array in-place, doesn't accept thisArg, and may invoke the callback multiple times on an index.
Iterative methods iterate the array like the following (with a lot of technical details omitted):
jsfunction method(callbackFn, thisArg) {
  const length = this.length;
  for (let i = 0; i < length; i++) {
    if (i in this) {
      const result = callbackFn.call(thisArg, this[i], i, this);
      // Do something with result; maybe return early
    }
  }
}

Note the following:

Not all methods do the i in this test. The find, findIndex, findLast, and findLastIndex methods do not, but other methods do.
The length is memorized before the loop starts. This affects how insertions and deletions during iteration are handled (see mutating initial array in iterative methods).
The method doesn't memorize the array contents, so if any index is modified during iteration, the new value might be observed.
The code above iterates the array in ascending order of index. Some methods iterate in descending order of index (for (let i = length - 1; i >= 0; i--)): reduceRight(), findLast(), and findLastIndex().
reduce and reduceRight have slightly different signatures and do not always start at the first/last element.
Generic array methodsArray methods are always generic — they don't access any internal data of the array object. They only access the array elements through the length property and the indexed elements. This means that they can be called on array-like objects as well.
jsconst arrayLike = {
  0: "a",
  1: "b",
  length: 2,
};
console.log(Array.prototype.join.call(arrayLike, "+")); // 'a+b'

Normalization of the length property
The length property is converted to an integer and then clamped to the range between 0 and 253 - 1. NaN becomes 0, so even when length is not present or is undefined, it behaves as if it has value 0.
The language avoids setting length to an unsafe integer. All built-in methods will throw a TypeError if length will be set to a number greater than 253 - 1. However, because the length property of arrays throws an error if it's set to greater than 232 - 1, the safe integer threshold is usually not reached unless the method is called on a non-array object.
jsArray.prototype.flat.call({}); // []

Some array methods set the length property of the array object. They always set the value after normalization, so length always ends as an integer.
jsconst a = { length: 0.7 };
Array.prototype.push.call(a);
console.log(a.length); // 0

Array-like objects
The term array-like object refers to any object that doesn't throw during the length conversion process described above. In practice, such object is expected to actually have a length property and to have indexed elements in the range 0 to length - 1. (If it doesn't have all indices, it will be functionally equivalent to a sparse array.) Any integer index less than zero or greater than length - 1 is ignored when an array method operates on an array-like object.
Many DOM objects are array-like — for example, NodeList and HTMLCollection. The arguments object is also array-like. You can call array methods on them even if they don't have these methods themselves.
jsfunction f() {
  console.log(Array.prototype.join.call(arguments, "+"));
}

f("a", "b"); // 'a+b'
Constructor
Array()

Creates a new Array object.

Static properties
Array[Symbol.species]

Returns the Array constructor.

Static methods
Array.from()

Creates a new Array instance from an iterable or array-like object.

Array.fromAsync()

Creates a new Array instance from an async iterable, iterable, or array-like object.

Array.isArray()

Returns true if the argument is an array, or false otherwise.

Array.of()

Creates a new Array instance with a variable number of arguments, regardless of number or type of the arguments.

Instance propertiesThese properties are defined on Array.prototype and shared by all Array instances.

Array.prototype.constructor

The constructor function that created the instance object. For Array instances, the initial value is the Array constructor.

Array.prototype[Symbol.unscopables]

Contains property names that were not included in the ECMAScript standard prior to the ES2015 version and that are ignored for with statement-binding purposes.


These properties are own properties of each Array instance.

length

Reflects the number of elements in an array.

Instance methods
Array.prototype.at()

Returns the array item at the given index. Accepts negative integers, which count back from the last item.

Array.prototype.concat()

Returns a new array that is the calling array joined with other array(s) and/or value(s).

Array.prototype.copyWithin()

Copies a sequence of array elements within an array.

Array.prototype.entries()

Returns a new array iterator object that contains the key/value pairs for each index in an array.

Array.prototype.every()

Returns true if every element in the calling array satisfies the testing function.

Array.prototype.fill()

Fills all the elements of an array from a start index to an end index with a static value.

Array.prototype.filter()

Returns a new array containing all elements of the calling array for which the provided filtering function returns true.

Array.prototype.find()

Returns the value of the first element in the array that satisfies the provided testing function, or undefined if no appropriate element is found.

Array.prototype.findIndex()

Returns the index of the first element in the array that satisfies the provided testing function, or -1 if no appropriate element was found.

Array.prototype.findLast()

Returns the value of the last element in the array that satisfies the provided testing function, or undefined if no appropriate element is found.

Array.prototype.findLastIndex()

Returns the index of the last element in the array that satisfies the provided testing function, or -1 if no appropriate element was found.

Array.prototype.flat()

Returns a new array with all sub-array elements concatenated into it recursively up to the specified depth.

Array.prototype.flatMap()

Returns a new array formed by applying a given callback function to each element of the calling array, and then flattening the result by one level.

Array.prototype.forEach()

Calls a function for each element in the calling array.

Array.prototype.includes()

Determines whether the calling array contains a value, returning true or false as appropriate.

Array.prototype.indexOf()

Returns the first (least) index at which a given element can be found in the calling array.

Array.prototype.join()

Joins all elements of an array into a string.

Array.prototype.keys()

Returns a new array iterator that contains the keys for each index in the calling array.

Array.prototype.lastIndexOf()

Returns the last (greatest) index at which a given element can be found in the calling array, or -1 if none is found.

Array.prototype.map()

Returns a new array containing the results of invoking a function on every element in the calling array.

Array.prototype.pop()

Removes the last element from an array and returns that element.

Array.prototype.push()

Adds one or more elements to the end of an array, and returns the new length of the array.

Array.prototype.reduce()

Executes a user-supplied "reducer" callback function on each element of the array (from left to right), to reduce it to a single value.

Array.prototype.reduceRight()

Executes a user-supplied "reducer" callback function on each element of the array (from right to left), to reduce it to a single value.

Array.prototype.reverse()

Reverses the order of the elements of an array in place. (First becomes the last, last becomes first.)

Array.prototype.shift()

Removes the first element from an array and returns that element.

Array.prototype.slice()

Extracts a section of the calling array and returns a new array.

Array.prototype.some()

Returns true if at least one element in the calling array satisfies the provided testing function.

Array.prototype.sort()

Sorts the elements of an array in place and returns the array.

Array.prototype.splice()

Adds and/or removes elements from an array.

Array.prototype.toLocaleString()

Returns a localized string representing the calling array and its elements. Overrides the Object.prototype.toLocaleString() method.

Array.prototype.toReversed()

Returns a new array with the elements in reversed order, without modifying the original array.

Array.prototype.toSorted()

Returns a new array with the elements sorted in ascending order, without modifying the original array.

Array.prototype.toSpliced()

Returns a new array with some elements removed and/or replaced at a given index, without modifying the original array.

Array.prototype.toString()

Returns a string representing the calling array and its elements. Overrides the Object.prototype.toString() method.

Array.prototype.unshift()

Adds one or more elements to the front of an array, and returns the new length of the array.

Array.prototype.values()

Returns a new array iterator object that contains the values for each index in the array.

Array.prototype.with()

Returns a new array with the element at the given index replaced with the given value, without modifying the original array.

Array.prototype[Symbol.iterator]()

An alias for the values() method by default.

ExamplesThis section provides some examples of common array operations in JavaScript.

Note:
If you're not yet familiar with array basics, consider first reading JavaScript First Steps: Arrays, which explains what arrays are, and includes other examples of common array operations.
Create an arrayThis example shows three ways to create new array: first using array literal notation, then using the Array() constructor, and finally using String.prototype.split() to build the array from a string.
js// 'fruits' array created using array literal notation.
const fruits = ["Apple", "Banana"];
console.log(fruits.length);
// 2

// 'fruits2' array created using the Array() constructor.
const fruits2 = new Array("Apple", "Banana");
console.log(fruits2.length);
// 2

// 'fruits3' array created using String.prototype.split().
const fruits3 = "Apple, Banana".split(", ");
console.log(fruits3.length);
// 2
Create a string from an arrayThis example uses the join() method to create a string from the fruits array.
jsconst fruits = ["Apple", "Banana"];
const fruitsString = fruits.join(", ");
console.log(fruitsString);
// "Apple, Banana"
Access an array item by its indexThis example shows how to access items in the fruits array by specifying the index number of their position in the array.
jsconst fruits = ["Apple", "Banana"];

// The index of an array's first element is always 0.
fruits[0]; // Apple

// The index of an array's second element is always 1.
fruits[1]; // Banana

// The index of an array's last element is always one
// less than the length of the array.
fruits[fruits.length - 1]; // Banana

// Using an index number larger than the array's length
// returns 'undefined'.
fruits[99]; // undefined
Find the index of an item in an arrayThis example uses the indexOf() method to find the position (index) of the string "Banana" in the fruits array.
jsconst fruits = ["Apple", "Banana"];
console.log(fruits.indexOf("Banana"));
// 1
Check if an array contains a certain itemThis example shows two ways to check if the fruits array contains "Banana" and "Cherry": first with the includes() method, and then with the indexOf() method to test for an index value that's not -1.
jsconst fruits = ["Apple", "Banana"];

fruits.includes("Banana"); // true
fruits.includes("Cherry"); // false

// If indexOf() doesn't return -1, the array contains the given item.
fruits.indexOf("Banana") !== -1; // true
fruits.indexOf("Cherry") !== -1; // false
Append an item to an arrayThis example uses the push() method to append a new string to the fruits array.
jsconst fruits = ["Apple", "Banana"];
const newLength = fruits.push("Orange");
console.log(fruits);
// ["Apple", "Banana", "Orange"]
console.log(newLength);
// 3
Remove the last item from an arrayThis example uses the pop() method to remove the last item from the fruits array.
jsconst fruits = ["Apple", "Banana", "Orange"];
const removedItem = fruits.pop();
console.log(fruits);
// ["Apple", "Banana"]
console.log(removedItem);
// Orange


Note: pop() can only be used to remove the last item from an array. To remove multiple items from the end of an array, see the next example.
Remove multiple items from the end of an arrayThis example uses the splice() method to remove the last 3 items from the fruits array.
jsconst fruits = ["Apple", "Banana", "Strawberry", "Mango", "Cherry"];
const start = -3;
const removedItems = fruits.splice(start);
console.log(fruits);
// ["Apple", "Banana"]
console.log(removedItems);
// ["Strawberry", "Mango", "Cherry"]
Truncate an array down to just its first N itemsThis example uses the splice() method to truncate the fruits array down to just its first 2 items.
jsconst fruits = ["Apple", "Banana", "Strawberry", "Mango", "Cherry"];
const start = 2;
const removedItems = fruits.splice(start);
console.log(fruits);
// ["Apple", "Banana"]
console.log(removedItems);
// ["Strawberry", "Mango", "Cherry"]
Remove the first item from an arrayThis example uses the shift() method to remove the first item from the fruits array.
jsconst fruits = ["Apple", "Banana"];
const removedItem = fruits.shift();
console.log(fruits);
// ["Banana"]
console.log(removedItem);
// Apple


Note: shift() can only be used to remove the first item from an array. To remove multiple items from the beginning of an array, see the next example.
Remove multiple items from the beginning of an arrayThis example uses the splice() method to remove the first 3 items from the fruits array.
jsconst fruits = ["Apple", "Strawberry", "Cherry", "Banana", "Mango"];
const start = 0;
const deleteCount = 3;
const removedItems = fruits.splice(start, deleteCount);
console.log(fruits);
// ["Banana", "Mango"]
console.log(removedItems);
// ["Apple", "Strawberry", "Cherry"]
Add a new first item to an arrayThis example uses the unshift() method to add, at index 0, a new item to the fruits array — making it the new first item in the array.
jsconst fruits = ["Banana", "Mango"];
const newLength = fruits.unshift("Strawberry");
console.log(fruits);
// ["Strawberry", "Banana", "Mango"]
console.log(newLength);
// 3
Remove a single item by indexThis example uses the splice() method to remove the string "Banana" from the fruits array — by specifying the index position of "Banana".
jsconst fruits = ["Strawberry", "Banana", "Mango"];
const start = fruits.indexOf("Banana");
const deleteCount = 1;
const removedItems = fruits.splice(start, deleteCount);
console.log(fruits);
// ["Strawberry", "Mango"]
console.log(removedItems);
// ["Banana"]
Remove multiple items by indexThis example uses the splice() method to remove the strings "Banana" and "Strawberry" from the fruits array — by specifying the index position of "Banana", along with a count of the number of total items to remove.
jsconst fruits = ["Apple", "Banana", "Strawberry", "Mango"];
const start = 1;
const deleteCount = 2;
const removedItems = fruits.splice(start, deleteCount);
console.log(fruits);
// ["Apple", "Mango"]
console.log(removedItems);
// ["Banana", "Strawberry"]
Replace multiple items in an arrayThis example uses the splice() method to replace the last 2 items in the fruits array with new items.
jsconst fruits = ["Apple", "Banana", "Strawberry"];
const start = -2;
const deleteCount = 2;
const removedItems = fruits.splice(start, deleteCount, "Mango", "Cherry");
console.log(fruits);
// ["Apple", "Mango", "Cherry"]
console.log(removedItems);
// ["Banana", "Strawberry"]
Iterate over an arrayThis example uses a for...of loop to iterate over the fruits array, logging each item to the console.
jsconst fruits = ["Apple", "Mango", "Cherry"];
for (const fruit of fruits) {
  console.log(fruit);
}
// Apple
// Mango
// Cherry

But for...of is just one of many ways to iterate over any array; for more ways, see Loops and iteration, and see the documentation for the every(), filter(), flatMap(), map(), reduce(), and reduceRight() methods — and see the next example, which uses the forEach() method.Call a function on each element in an arrayThis example uses the forEach() method to call a function on each element in the fruits array; the function causes each item to be logged to the console, along with the item's index number.
jsconst fruits = ["Apple", "Mango", "Cherry"];
fruits.forEach((item, index, array) => {
  console.log(item, index);
});
// Apple 0
// Mango 1
// Cherry 2
Merge multiple arrays togetherThis example uses the concat() method to merge the fruits array with a moreFruits array, to produce a new combinedFruits array. Notice that fruits and moreFruits remain unchanged.
jsconst fruits = ["Apple", "Banana", "Strawberry"];
const moreFruits = ["Mango", "Cherry"];
const combinedFruits = fruits.concat(moreFruits);
console.log(combinedFruits);
// ["Apple", "Banana", "Strawberry", "Mango", "Cherry"]

// The 'fruits' array remains unchanged.
console.log(fruits);
// ["Apple", "Banana", "Strawberry"]

// The 'moreFruits' array also remains unchanged.
console.log(moreFruits);
// ["Mango", "Cherry"]
Copy an arrayThis example shows three ways to create a new array from the existing fruits array: first by using spread syntax, then by using the from() method, and then by using the slice() method.
jsconst fruits = ["Strawberry", "Mango"];

// Create a copy using spread syntax.
const fruitsCopy = [...fruits];
// ["Strawberry", "Mango"]

// Create a copy using the from() method.
const fruitsCopy2 = Array.from(fruits);
// ["Strawberry", "Mango"]

// Create a copy using the slice() method.
const fruitsCopy3 = fruits.slice();
// ["Strawberry", "Mango"]

All built-in array-copy operations (spread syntax, Array.from(), Array.prototype.slice(), and Array.prototype.concat()) create shallow copies. If you instead want a deep copy of an array, you can use JSON.stringify() to convert the array to a JSON string, and then JSON.parse() to convert the string back into a new array that's completely independent from the original array.
jsconst fruitsDeepCopy = JSON.parse(JSON.stringify(fruits));

You can also create deep copies using the structuredClone() method, which has the advantage of allowing transferable objects in the source to be transferred to the new copy, rather than just cloned.
Finally, it's important to understand that assigning an existing array to a new variable doesn't create a copy of either the array or its elements. Instead the new variable is just a reference, or alias, to the original array; that is, the original array's name and the new variable name are just two names for the exact same object (and so will always evaluate as strictly equivalent). Therefore, if you make any changes at all either to the value of the original array or to the value of the new variable, the other will change, too:
jsconst fruits = ["Strawberry", "Mango"];
const fruitsAlias = fruits;
// 'fruits' and 'fruitsAlias' are the same object, strictly equivalent.
fruits === fruitsAlias; // true
// Any changes to the 'fruits' array change 'fruitsAlias' too.
fruits.unshift("Apple", "Banana");
console.log(fruits);
// ['Apple', 'Banana', 'Strawberry', 'Mango']
console.log(fruitsAlias);
// ['Apple', 'Banana', 'Strawberry', 'Mango']
Creating a two-dimensional arrayThe following creates a chessboard as a two-dimensional array of strings. The first move is made by copying the 'p' in board[6][4] to board[4][4]. The old position at [6][4] is made blank.
jsconst board = [
  ["R", "N", "B", "Q", "K", "B", "N", "R"],
  ["P", "P", "P", "P", "P", "P", "P", "P"],
  [" ", " ", " ", " ", " ", " ", " ", " "],
  [" ", " ", " ", " ", " ", " ", " ", " "],
  [" ", " ", " ", " ", " ", " ", " ", " "],
  [" ", " ", " ", " ", " ", " ", " ", " "],
  ["p", "p", "p", "p", "p", "p", "p", "p"],
  ["r", "n", "b", "q", "k", "b", "n", "r"],
];

console.log(`${board.join("\n")}\n\n`);

// Move King's Pawn forward 2
board[4][4] = board[6][4];
board[6][4] = " ";
console.log(board.join("\n"));

Here is the output:
R,N,B,Q,K,B,N,R
P,P,P,P,P,P,P,P
 , , , , , , ,
 , , , , , , ,
 , , , , , , ,
 , , , , , , ,
p,p,p,p,p,p,p,p
r,n,b,q,k,b,n,r

R,N,B,Q,K,B,N,R
P,P,P,P,P,P,P,P
 , , , , , , ,
 , , , , , , ,
 , , , ,p, , ,
 , , , , , , ,
p,p,p,p, ,p,p,p
r,n,b,q,k,b,n,r
Using an array to tabulate a set of valuesjsconst values = [];
for (let x = 0; x < 10; x++) {
  values.push([2 ** x, 2 * x ** 2]);
}
console.table(values);

Results in
// The first column is the index
0  1    0
1  2    2
2  4    8
3  8    18
4  16   32
5  32   50
6  64   72
7  128  98
8  256  128
9  512  162
Creating an array using the result of a matchThe result of a match between a RegExp and a string can create a JavaScript array that has properties and elements which provide information about the match. Such an array is returned by RegExp.prototype.exec() and String.prototype.match().
For example:
js// Match one d followed by one or more b's followed by one d
// Remember matched b's and the following d
// Ignore case

const myRe = /d(b+)(d)/i;
const execResult = myRe.exec("cdbBdbsbz");

console.log(execResult.input); // 'cdbBdbsbz'
console.log(execResult.index); // 1
console.log(execResult); // [ "dbBd", "bB", "d" ]

For more information about the result of a match, see the RegExp.prototype.exec() and String.prototype.match() pages.Mutating initial array in iterative methodsIterative methods do not mutate the array on which it is called, but the function provided as callbackFn can. The key principle to remember is that only indexes between 0 and arrayLength - 1 are visited, where arrayLength is the length of the array at the time the array method was first called, but the element passed to the callback is the value at the time the index is visited. Therefore:

callbackFn will not visit any elements added beyond the array's initial length when the call to the iterative method began.
Changes to already-visited indexes do not cause callbackFn to be invoked on them again.
If an existing, yet-unvisited element of the array is changed by callbackFn, its value passed to the callbackFn will be the value at the time that element gets visited. Removed elements are not visited.


Warning:
Concurrent modifications of the kind described above frequently lead to hard-to-understand code and are generally to be avoided (except in special cases).

The following examples use the forEach method as an example, but other methods that visit indexes in ascending order work in the same way. We will first define a helper function:
jsfunction testSideEffect(effect) {
  const arr = ["e1", "e2", "e3", "e4"];
  arr.forEach((elem, index, arr) => {
    console.log(`array: [${arr.join(", ")}], index: ${index}, elem: ${elem}`);
    effect(arr, index);
  });
  console.log(`Final array: [${arr.join(", ")}]`);
}

Modification to indexes not visited yet will be visible once the index is reached:
jstestSideEffect((arr, index) => {
  if (index + 1 < arr.length) arr[index + 1] += "*";
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2*, e3, e4], index: 1, elem: e2*
// array: [e1, e2*, e3*, e4], index: 2, elem: e3*
// array: [e1, e2*, e3*, e4*], index: 3, elem: e4*
// Final array: [e1, e2*, e3*, e4*]

Modification to already visited indexes does not change iteration behavior, although the array will be different afterwards:
jstestSideEffect((arr, index) => {
  if (index > 0) arr[index - 1] += "*";
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2, e3, e4], index: 1, elem: e2
// array: [e1*, e2, e3, e4], index: 2, elem: e3
// array: [e1*, e2*, e3, e4], index: 3, elem: e4
// Final array: [e1*, e2*, e3*, e4]

Inserting n elements at unvisited indexes that are less than the initial array length will make them be visited. The last n elements in the original array that now have index greater than the initial array length will not be visited:
jstestSideEffect((arr, index) => {
  if (index === 1) arr.splice(2, 0, "new");
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2, e3, e4], index: 1, elem: e2
// array: [e1, e2, new, e3, e4], index: 2, elem: new
// array: [e1, e2, new, e3, e4], index: 3, elem: e3
// Final array: [e1, e2, new, e3, e4]
// e4 is not visited because it now has index 4

Inserting n elements with index greater than the initial array length will not make them be visited:
jstestSideEffect((arr) => arr.push("new"));
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2, e3, e4, new], index: 1, elem: e2
// array: [e1, e2, e3, e4, new, new], index: 2, elem: e3
// array: [e1, e2, e3, e4, new, new, new], index: 3, elem: e4
// Final array: [e1, e2, e3, e4, new, new, new, new]

Inserting n elements at already visited indexes will not make them be visited, but it shifts remaining elements back by n, so the current index and the n - 1 elements before it are visited again:
jstestSideEffect((arr, index) => arr.splice(index, 0, "new"));
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [new, e1, e2, e3, e4], index: 1, elem: e1
// array: [new, new, e1, e2, e3, e4], index: 2, elem: e1
// array: [new, new, new, e1, e2, e3, e4], index: 3, elem: e1
// Final array: [new, new, new, new, e1, e2, e3, e4]
// e1 keeps getting visited because it keeps getting shifted back

Deleting n elements at unvisited indexes will make them not be visited anymore. Because the array has shrunk, the last n iterations will visit out-of-bounds indexes. If the method ignores non-existent indexes (see array methods and empty slots), the last n iterations will be skipped; otherwise, they will receive undefined:
jstestSideEffect((arr, index) => {
  if (index === 1) arr.splice(2, 1);
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2, e3, e4], index: 1, elem: e2
// array: [e1, e2, e4], index: 2, elem: e4
// Final array: [e1, e2, e4]
// Does not visit index 3 because it's out-of-bounds

// Compare this with find(), which treats nonexistent indexes as undefined:
const arr2 = ["e1", "e2", "e3", "e4"];
arr2.find((elem, index, arr) => {
  console.log(`array: [${arr.join(", ")}], index: ${index}, elem: ${elem}`);
  if (index === 1) arr.splice(2, 1);
  return false;
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2, e3, e4], index: 1, elem: e2
// array: [e1, e2, e4], index: 2, elem: e4
// array: [e1, e2, e4], index: 3, elem: undefined

Deleting n elements at already visited indexes does not change the fact that they were visited before they get deleted. Because the array has shrunk, the next n elements after the current index are skipped. If the method ignores non-existent indexes, the last n iterations will be skipped; otherwise, they will receive undefined:
jstestSideEffect((arr, index) => arr.splice(index, 1));
// array: [e1, e2, e3, e4], index: 0, elem: e1
// Does not visit e2 because e2 now has index 0, which has already been visited
// array: [e2, e3, e4], index: 1, elem: e3
// Does not visit e4 because e4 now has index 1, which has already been visited
// Final array: [e2, e4]
// Index 2 is out-of-bounds, so it's not visited

// Compare this with find(), which treats nonexistent indexes as undefined:
const arr2 = ["e1", "e2", "e3", "e4"];
arr2.find((elem, index, arr) => {
  console.log(`array: [${arr.join(", ")}], index: ${index}, elem: ${elem}`);
  arr.splice(index, 1);
  return false;
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e2, e3, e4], index: 1, elem: e3
// array: [e2, e4], index: 2, elem: undefined
// array: [e2, e4], index: 3, elem: undefined

For methods that iterate in descending order of index, insertion causes elements to be skipped, and deletion causes elements to be visited multiple times. Adjust the code above yourself to see the effects.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-array-objectsBrowser compatibilitySee also
Indexed collections guide
TypedArray
ArrayBuffer\n\nArrayBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Array object, as with arrays in other programming languages, enables storing a collection of multiple items under a single variable name, and has members for performing common array operations.DescriptionIn JavaScript, arrays aren't primitives but are instead Array objects with the following core characteristics:

JavaScript arrays are resizable and can contain a mix of different data types. (When those characteristics are undesirable, use typed arrays instead.)
JavaScript arrays are not associative arrays and so, array elements cannot be accessed using arbitrary strings as indexes, but must be accessed using nonnegative integers (or their respective string form) as indexes.
JavaScript arrays are zero-indexed: the first element of an array is at index 0, the second is at index 1, and so on — and the last element is at the value of the array's length property minus 1.
JavaScript array-copy operations create shallow copies. (All standard built-in copy operations with any JavaScript objects create shallow copies, rather than deep copies).
Array indicesArray objects cannot use arbitrary strings as element indexes (as in an associative array) but must use nonnegative integers (or their respective string form). Setting or accessing via non-integers will not set or retrieve an element from the array list itself, but will set or access a variable associated with that array's object property collection. The array's object properties and list of array elements are separate, and the array's traversal and mutation operations cannot be applied to these named properties.
Array elements are object properties in the same way that toString is a property (to be specific, however, toString() is a method). Nevertheless, trying to access an element of an array as follows throws a syntax error because the property name is not valid:
jsarr.0; // a syntax error

JavaScript syntax requires properties beginning with a digit to be accessed using bracket notation instead of dot notation. It's also possible to quote the array indices (e.g., years['2'] instead of years[2]), although usually not necessary.
The 2 in years[2] is coerced into a string by the JavaScript engine through an implicit toString conversion. As a result, '2' and '02' would refer to two different slots on the years object, and the following example could be true:
jsconsole.log(years["2"] !== years["02"]);

Only years['2'] is an actual array index. years['02'] is an arbitrary string property that will not be visited in array iteration.Relationship between length and numerical propertiesA JavaScript array's length property and numerical properties are connected.
Several of the built-in array methods (e.g., join(), slice(), indexOf(), etc.) take into account the value of an array's length property when they're called.
Other methods (e.g., push(), splice(), etc.) also result in updates to an array's length property.
jsconst fruits = [];
fruits.push("banana", "apple", "peach");
console.log(fruits.length); // 3

When setting a property on a JavaScript array when the property is a valid array index and that index is outside the current bounds of the array, the engine will update the array's length property accordingly:
jsfruits[5] = "mango";
console.log(fruits[5]); // 'mango'
console.log(Object.keys(fruits)); // ['0', '1', '2', '5']
console.log(fruits.length); // 6

Increasing the length extends the array by adding empty slots without creating any new elements — not even undefined.
jsfruits.length = 10;
console.log(fruits); // ['banana', 'apple', 'peach', empty x 2, 'mango', empty x 4]
console.log(Object.keys(fruits)); // ['0', '1', '2', '5']
console.log(fruits.length); // 10
console.log(fruits[8]); // undefined

Decreasing the length property does, however, delete elements.
jsfruits.length = 2;
console.log(Object.keys(fruits)); // ['0', '1']
console.log(fruits.length); // 2

This is explained further on the length page.Array methods and empty slotsArray methods have different behaviors when encountering empty slots in sparse arrays. In general, older methods (e.g., forEach) treat empty slots differently from indices that contain undefined.
Methods that have special treatment for empty slots include the following: concat(), copyWithin(), every(), filter(), flat(), flatMap(), forEach(), indexOf(), lastIndexOf(), map(), reduce(), reduceRight(), reverse(), slice(), some(), sort(), and splice(). Iteration methods such as forEach don't visit empty slots at all. Other methods, such as concat, copyWithin, etc., preserve empty slots when doing the copying, so in the end the array is still sparse.
jsconst colors = ["red", "yellow", "blue"];
colors[5] = "purple";
colors.forEach((item, index) => {
  console.log(`${index}: ${item}`);
});
// Output:
// 0: red
// 1: yellow
// 2: blue
// 5: purple

colors.reverse(); // ['purple', empty × 2, 'blue', 'yellow', 'red']

Newer methods (e.g., keys) do not treat empty slots specially and treat them as if they contain undefined. Methods that conflate empty slots with undefined elements include the following: entries(), fill(), find(), findIndex(), findLast(), findLastIndex(), includes(), join(), keys(), toLocaleString(), toReversed(), toSorted(), toSpliced(), values(), and with().
jsconst colors = ["red", "yellow", "blue"];
colors[5] = "purple";
const iterator = colors.keys();
for (const key of iterator) {
  console.log(`${key}: ${colors[key]}`);
}
// Output
// 0: red
// 1: yellow
// 2: blue
// 3: undefined
// 4: undefined
// 5: purple

const newColors = colors.toReversed(); // ['purple', undefined, undefined, 'blue', 'yellow', 'red']
Copying methods and mutating methodsSome methods do not mutate the existing array that the method was called on, but instead return a new array. They do so by first constructing a new array and then populating it with elements. The copy always happens shallowly — the method never copies anything beyond the initially created array. Elements of the original array(s) are copied into the new array as follows:

Objects: the object reference is copied into the new array. Both the original and new array refer to the same object. That is, if a referenced object is modified, the changes are visible to both the new and original arrays.
Primitive types such as strings, numbers and booleans (not String, Number, and Boolean objects): their values are copied into the new array.

Other methods mutate the array that the method was called on, in which case their return value differs depending on the method: sometimes a reference to the same array, sometimes the length of the new array.
The following methods create new arrays by accessing this.constructor[Symbol.species] to determine the constructor to use: concat(), filter(), flat(), flatMap(), map(), slice(), and splice() (to construct the array of removed elements that's returned).
The following methods always create new arrays with the Array base constructor: toReversed(), toSorted(), toSpliced(), and with().
The following table lists the methods that mutate the original array, and the corresponding non-mutating alternative:



Mutating method
Non-mutating alternative




copyWithin()
No one-method alternative


fill()
No one-method alternative


pop()
slice(0, -1)


push(v1, v2)
concat([v1, v2])


reverse()
toReversed()


shift()
slice(1)


sort()
toSorted()


splice()
toSpliced()


unshift(v1, v2)
toSpliced(0, 0, v1, v2)



An easy way to change a mutating method into a non-mutating alternative is to use the spread syntax or slice() to create a copy first:
jsarr.copyWithin(0, 1, 2); // mutates arr
const arr2 = arr.slice().copyWithin(0, 1, 2); // does not mutate arr
const arr3 = [...arr].copyWithin(0, 1, 2); // does not mutate arr
Iterative methodsMany array methods take a callback function as an argument. The callback function is called sequentially and at most once for each element in the array, and the return value of the callback function is used to determine the return value of the method. They all share the same signature:
jsmethod(callbackFn, thisArg)

Where callbackFn takes three arguments:

element

The current element being processed in the array.

index

The index of the current element being processed in the array.

array

The array that the method was called upon.


What callbackFn is expected to return depends on the array method that was called.
The thisArg argument (defaults to undefined) will be used as the this value when calling callbackFn. The this value ultimately observable by callbackFn is determined according to the usual rules: if callbackFn is non-strict, primitive this values are wrapped into objects, and undefined/null is substituted with globalThis. The thisArg argument is irrelevant for any callbackFn defined with an arrow function, as arrow functions don't have their own this binding.
The array argument passed to callbackFn is most useful if you want to read another index during iteration, because you may not always have an existing variable that refers to the current array. You should generally not mutate the array during iteration (see mutating initial array in iterative methods), but you can also use this argument to do so. The array argument is not the array that is being built, in the case of methods like map(), filter(), and flatMap() — there is no way to access the array being built from the callback function.
All iterative methods are copying and generic, although they behave differently with empty slots.
The following methods are iterative: every(), filter(), find(), findIndex(), findLast(), findLastIndex(), flatMap(), forEach(), map(), and some().
In particular, every(), find(), findIndex(), findLast(), findLastIndex(), and some() do not always invoke callbackFn on every element — they stop iteration as soon as the return value is determined.
The reduce() and reduceRight() methods also take a callback function and run it at most once for each element in the array, but they have slightly different signatures from typical iterative methods (for example, they don't accept thisArg).
The sort() method also takes a callback function, but it is not an iterative method. It mutates the array in-place, doesn't accept thisArg, and may invoke the callback multiple times on an index.
Iterative methods iterate the array like the following (with a lot of technical details omitted):
jsfunction method(callbackFn, thisArg) {
  const length = this.length;
  for (let i = 0; i < length; i++) {
    if (i in this) {
      const result = callbackFn.call(thisArg, this[i], i, this);
      // Do something with result; maybe return early
    }
  }
}

Note the following:

Not all methods do the i in this test. The find, findIndex, findLast, and findLastIndex methods do not, but other methods do.
The length is memorized before the loop starts. This affects how insertions and deletions during iteration are handled (see mutating initial array in iterative methods).
The method doesn't memorize the array contents, so if any index is modified during iteration, the new value might be observed.
The code above iterates the array in ascending order of index. Some methods iterate in descending order of index (for (let i = length - 1; i >= 0; i--)): reduceRight(), findLast(), and findLastIndex().
reduce and reduceRight have slightly different signatures and do not always start at the first/last element.
Generic array methodsArray methods are always generic — they don't access any internal data of the array object. They only access the array elements through the length property and the indexed elements. This means that they can be called on array-like objects as well.
jsconst arrayLike = {
  0: "a",
  1: "b",
  length: 2,
};
console.log(Array.prototype.join.call(arrayLike, "+")); // 'a+b'

Normalization of the length property
The length property is converted to an integer and then clamped to the range between 0 and 253 - 1. NaN becomes 0, so even when length is not present or is undefined, it behaves as if it has value 0.
The language avoids setting length to an unsafe integer. All built-in methods will throw a TypeError if length will be set to a number greater than 253 - 1. However, because the length property of arrays throws an error if it's set to greater than 232 - 1, the safe integer threshold is usually not reached unless the method is called on a non-array object.
jsArray.prototype.flat.call({}); // []

Some array methods set the length property of the array object. They always set the value after normalization, so length always ends as an integer.
jsconst a = { length: 0.7 };
Array.prototype.push.call(a);
console.log(a.length); // 0

Array-like objects
The term array-like object refers to any object that doesn't throw during the length conversion process described above. In practice, such object is expected to actually have a length property and to have indexed elements in the range 0 to length - 1. (If it doesn't have all indices, it will be functionally equivalent to a sparse array.) Any integer index less than zero or greater than length - 1 is ignored when an array method operates on an array-like object.
Many DOM objects are array-like — for example, NodeList and HTMLCollection. The arguments object is also array-like. You can call array methods on them even if they don't have these methods themselves.
jsfunction f() {
  console.log(Array.prototype.join.call(arguments, "+"));
}

f("a", "b"); // 'a+b'
Constructor
Array()

Creates a new Array object.

Static properties
Array[Symbol.species]

Returns the Array constructor.

Static methods
Array.from()

Creates a new Array instance from an iterable or array-like object.

Array.fromAsync()

Creates a new Array instance from an async iterable, iterable, or array-like object.

Array.isArray()

Returns true if the argument is an array, or false otherwise.

Array.of()

Creates a new Array instance with a variable number of arguments, regardless of number or type of the arguments.

Instance propertiesThese properties are defined on Array.prototype and shared by all Array instances.

Array.prototype.constructor

The constructor function that created the instance object. For Array instances, the initial value is the Array constructor.

Array.prototype[Symbol.unscopables]

Contains property names that were not included in the ECMAScript standard prior to the ES2015 version and that are ignored for with statement-binding purposes.


These properties are own properties of each Array instance.

length

Reflects the number of elements in an array.

Instance methods
Array.prototype.at()

Returns the array item at the given index. Accepts negative integers, which count back from the last item.

Array.prototype.concat()

Returns a new array that is the calling array joined with other array(s) and/or value(s).

Array.prototype.copyWithin()

Copies a sequence of array elements within an array.

Array.prototype.entries()

Returns a new array iterator object that contains the key/value pairs for each index in an array.

Array.prototype.every()

Returns true if every element in the calling array satisfies the testing function.

Array.prototype.fill()

Fills all the elements of an array from a start index to an end index with a static value.

Array.prototype.filter()

Returns a new array containing all elements of the calling array for which the provided filtering function returns true.

Array.prototype.find()

Returns the value of the first element in the array that satisfies the provided testing function, or undefined if no appropriate element is found.

Array.prototype.findIndex()

Returns the index of the first element in the array that satisfies the provided testing function, or -1 if no appropriate element was found.

Array.prototype.findLast()

Returns the value of the last element in the array that satisfies the provided testing function, or undefined if no appropriate element is found.

Array.prototype.findLastIndex()

Returns the index of the last element in the array that satisfies the provided testing function, or -1 if no appropriate element was found.

Array.prototype.flat()

Returns a new array with all sub-array elements concatenated into it recursively up to the specified depth.

Array.prototype.flatMap()

Returns a new array formed by applying a given callback function to each element of the calling array, and then flattening the result by one level.

Array.prototype.forEach()

Calls a function for each element in the calling array.

Array.prototype.includes()

Determines whether the calling array contains a value, returning true or false as appropriate.

Array.prototype.indexOf()

Returns the first (least) index at which a given element can be found in the calling array.

Array.prototype.join()

Joins all elements of an array into a string.

Array.prototype.keys()

Returns a new array iterator that contains the keys for each index in the calling array.

Array.prototype.lastIndexOf()

Returns the last (greatest) index at which a given element can be found in the calling array, or -1 if none is found.

Array.prototype.map()

Returns a new array containing the results of invoking a function on every element in the calling array.

Array.prototype.pop()

Removes the last element from an array and returns that element.

Array.prototype.push()

Adds one or more elements to the end of an array, and returns the new length of the array.

Array.prototype.reduce()

Executes a user-supplied "reducer" callback function on each element of the array (from left to right), to reduce it to a single value.

Array.prototype.reduceRight()

Executes a user-supplied "reducer" callback function on each element of the array (from right to left), to reduce it to a single value.

Array.prototype.reverse()

Reverses the order of the elements of an array in place. (First becomes the last, last becomes first.)

Array.prototype.shift()

Removes the first element from an array and returns that element.

Array.prototype.slice()

Extracts a section of the calling array and returns a new array.

Array.prototype.some()

Returns true if at least one element in the calling array satisfies the provided testing function.

Array.prototype.sort()

Sorts the elements of an array in place and returns the array.

Array.prototype.splice()

Adds and/or removes elements from an array.

Array.prototype.toLocaleString()

Returns a localized string representing the calling array and its elements. Overrides the Object.prototype.toLocaleString() method.

Array.prototype.toReversed()

Returns a new array with the elements in reversed order, without modifying the original array.

Array.prototype.toSorted()

Returns a new array with the elements sorted in ascending order, without modifying the original array.

Array.prototype.toSpliced()

Returns a new array with some elements removed and/or replaced at a given index, without modifying the original array.

Array.prototype.toString()

Returns a string representing the calling array and its elements. Overrides the Object.prototype.toString() method.

Array.prototype.unshift()

Adds one or more elements to the front of an array, and returns the new length of the array.

Array.prototype.values()

Returns a new array iterator object that contains the values for each index in the array.

Array.prototype.with()

Returns a new array with the element at the given index replaced with the given value, without modifying the original array.

Array.prototype[Symbol.iterator]()

An alias for the values() method by default.

ExamplesThis section provides some examples of common array operations in JavaScript.

Note:
If you're not yet familiar with array basics, consider first reading JavaScript First Steps: Arrays, which explains what arrays are, and includes other examples of common array operations.
Create an arrayThis example shows three ways to create new array: first using array literal notation, then using the Array() constructor, and finally using String.prototype.split() to build the array from a string.
js// 'fruits' array created using array literal notation.
const fruits = ["Apple", "Banana"];
console.log(fruits.length);
// 2

// 'fruits2' array created using the Array() constructor.
const fruits2 = new Array("Apple", "Banana");
console.log(fruits2.length);
// 2

// 'fruits3' array created using String.prototype.split().
const fruits3 = "Apple, Banana".split(", ");
console.log(fruits3.length);
// 2
Create a string from an arrayThis example uses the join() method to create a string from the fruits array.
jsconst fruits = ["Apple", "Banana"];
const fruitsString = fruits.join(", ");
console.log(fruitsString);
// "Apple, Banana"
Access an array item by its indexThis example shows how to access items in the fruits array by specifying the index number of their position in the array.
jsconst fruits = ["Apple", "Banana"];

// The index of an array's first element is always 0.
fruits[0]; // Apple

// The index of an array's second element is always 1.
fruits[1]; // Banana

// The index of an array's last element is always one
// less than the length of the array.
fruits[fruits.length - 1]; // Banana

// Using an index number larger than the array's length
// returns 'undefined'.
fruits[99]; // undefined
Find the index of an item in an arrayThis example uses the indexOf() method to find the position (index) of the string "Banana" in the fruits array.
jsconst fruits = ["Apple", "Banana"];
console.log(fruits.indexOf("Banana"));
// 1
Check if an array contains a certain itemThis example shows two ways to check if the fruits array contains "Banana" and "Cherry": first with the includes() method, and then with the indexOf() method to test for an index value that's not -1.
jsconst fruits = ["Apple", "Banana"];

fruits.includes("Banana"); // true
fruits.includes("Cherry"); // false

// If indexOf() doesn't return -1, the array contains the given item.
fruits.indexOf("Banana") !== -1; // true
fruits.indexOf("Cherry") !== -1; // false
Append an item to an arrayThis example uses the push() method to append a new string to the fruits array.
jsconst fruits = ["Apple", "Banana"];
const newLength = fruits.push("Orange");
console.log(fruits);
// ["Apple", "Banana", "Orange"]
console.log(newLength);
// 3
Remove the last item from an arrayThis example uses the pop() method to remove the last item from the fruits array.
jsconst fruits = ["Apple", "Banana", "Orange"];
const removedItem = fruits.pop();
console.log(fruits);
// ["Apple", "Banana"]
console.log(removedItem);
// Orange


Note: pop() can only be used to remove the last item from an array. To remove multiple items from the end of an array, see the next example.
Remove multiple items from the end of an arrayThis example uses the splice() method to remove the last 3 items from the fruits array.
jsconst fruits = ["Apple", "Banana", "Strawberry", "Mango", "Cherry"];
const start = -3;
const removedItems = fruits.splice(start);
console.log(fruits);
// ["Apple", "Banana"]
console.log(removedItems);
// ["Strawberry", "Mango", "Cherry"]
Truncate an array down to just its first N itemsThis example uses the splice() method to truncate the fruits array down to just its first 2 items.
jsconst fruits = ["Apple", "Banana", "Strawberry", "Mango", "Cherry"];
const start = 2;
const removedItems = fruits.splice(start);
console.log(fruits);
// ["Apple", "Banana"]
console.log(removedItems);
// ["Strawberry", "Mango", "Cherry"]
Remove the first item from an arrayThis example uses the shift() method to remove the first item from the fruits array.
jsconst fruits = ["Apple", "Banana"];
const removedItem = fruits.shift();
console.log(fruits);
// ["Banana"]
console.log(removedItem);
// Apple


Note: shift() can only be used to remove the first item from an array. To remove multiple items from the beginning of an array, see the next example.
Remove multiple items from the beginning of an arrayThis example uses the splice() method to remove the first 3 items from the fruits array.
jsconst fruits = ["Apple", "Strawberry", "Cherry", "Banana", "Mango"];
const start = 0;
const deleteCount = 3;
const removedItems = fruits.splice(start, deleteCount);
console.log(fruits);
// ["Banana", "Mango"]
console.log(removedItems);
// ["Apple", "Strawberry", "Cherry"]
Add a new first item to an arrayThis example uses the unshift() method to add, at index 0, a new item to the fruits array — making it the new first item in the array.
jsconst fruits = ["Banana", "Mango"];
const newLength = fruits.unshift("Strawberry");
console.log(fruits);
// ["Strawberry", "Banana", "Mango"]
console.log(newLength);
// 3
Remove a single item by indexThis example uses the splice() method to remove the string "Banana" from the fruits array — by specifying the index position of "Banana".
jsconst fruits = ["Strawberry", "Banana", "Mango"];
const start = fruits.indexOf("Banana");
const deleteCount = 1;
const removedItems = fruits.splice(start, deleteCount);
console.log(fruits);
// ["Strawberry", "Mango"]
console.log(removedItems);
// ["Banana"]
Remove multiple items by indexThis example uses the splice() method to remove the strings "Banana" and "Strawberry" from the fruits array — by specifying the index position of "Banana", along with a count of the number of total items to remove.
jsconst fruits = ["Apple", "Banana", "Strawberry", "Mango"];
const start = 1;
const deleteCount = 2;
const removedItems = fruits.splice(start, deleteCount);
console.log(fruits);
// ["Apple", "Mango"]
console.log(removedItems);
// ["Banana", "Strawberry"]
Replace multiple items in an arrayThis example uses the splice() method to replace the last 2 items in the fruits array with new items.
jsconst fruits = ["Apple", "Banana", "Strawberry"];
const start = -2;
const deleteCount = 2;
const removedItems = fruits.splice(start, deleteCount, "Mango", "Cherry");
console.log(fruits);
// ["Apple", "Mango", "Cherry"]
console.log(removedItems);
// ["Banana", "Strawberry"]
Iterate over an arrayThis example uses a for...of loop to iterate over the fruits array, logging each item to the console.
jsconst fruits = ["Apple", "Mango", "Cherry"];
for (const fruit of fruits) {
  console.log(fruit);
}
// Apple
// Mango
// Cherry

But for...of is just one of many ways to iterate over any array; for more ways, see Loops and iteration, and see the documentation for the every(), filter(), flatMap(), map(), reduce(), and reduceRight() methods — and see the next example, which uses the forEach() method.Call a function on each element in an arrayThis example uses the forEach() method to call a function on each element in the fruits array; the function causes each item to be logged to the console, along with the item's index number.
jsconst fruits = ["Apple", "Mango", "Cherry"];
fruits.forEach((item, index, array) => {
  console.log(item, index);
});
// Apple 0
// Mango 1
// Cherry 2
Merge multiple arrays togetherThis example uses the concat() method to merge the fruits array with a moreFruits array, to produce a new combinedFruits array. Notice that fruits and moreFruits remain unchanged.
jsconst fruits = ["Apple", "Banana", "Strawberry"];
const moreFruits = ["Mango", "Cherry"];
const combinedFruits = fruits.concat(moreFruits);
console.log(combinedFruits);
// ["Apple", "Banana", "Strawberry", "Mango", "Cherry"]

// The 'fruits' array remains unchanged.
console.log(fruits);
// ["Apple", "Banana", "Strawberry"]

// The 'moreFruits' array also remains unchanged.
console.log(moreFruits);
// ["Mango", "Cherry"]
Copy an arrayThis example shows three ways to create a new array from the existing fruits array: first by using spread syntax, then by using the from() method, and then by using the slice() method.
jsconst fruits = ["Strawberry", "Mango"];

// Create a copy using spread syntax.
const fruitsCopy = [...fruits];
// ["Strawberry", "Mango"]

// Create a copy using the from() method.
const fruitsCopy2 = Array.from(fruits);
// ["Strawberry", "Mango"]

// Create a copy using the slice() method.
const fruitsCopy3 = fruits.slice();
// ["Strawberry", "Mango"]

All built-in array-copy operations (spread syntax, Array.from(), Array.prototype.slice(), and Array.prototype.concat()) create shallow copies. If you instead want a deep copy of an array, you can use JSON.stringify() to convert the array to a JSON string, and then JSON.parse() to convert the string back into a new array that's completely independent from the original array.
jsconst fruitsDeepCopy = JSON.parse(JSON.stringify(fruits));

You can also create deep copies using the structuredClone() method, which has the advantage of allowing transferable objects in the source to be transferred to the new copy, rather than just cloned.
Finally, it's important to understand that assigning an existing array to a new variable doesn't create a copy of either the array or its elements. Instead the new variable is just a reference, or alias, to the original array; that is, the original array's name and the new variable name are just two names for the exact same object (and so will always evaluate as strictly equivalent). Therefore, if you make any changes at all either to the value of the original array or to the value of the new variable, the other will change, too:
jsconst fruits = ["Strawberry", "Mango"];
const fruitsAlias = fruits;
// 'fruits' and 'fruitsAlias' are the same object, strictly equivalent.
fruits === fruitsAlias; // true
// Any changes to the 'fruits' array change 'fruitsAlias' too.
fruits.unshift("Apple", "Banana");
console.log(fruits);
// ['Apple', 'Banana', 'Strawberry', 'Mango']
console.log(fruitsAlias);
// ['Apple', 'Banana', 'Strawberry', 'Mango']
Creating a two-dimensional arrayThe following creates a chessboard as a two-dimensional array of strings. The first move is made by copying the 'p' in board[6][4] to board[4][4]. The old position at [6][4] is made blank.
jsconst board = [
  ["R", "N", "B", "Q", "K", "B", "N", "R"],
  ["P", "P", "P", "P", "P", "P", "P", "P"],
  [" ", " ", " ", " ", " ", " ", " ", " "],
  [" ", " ", " ", " ", " ", " ", " ", " "],
  [" ", " ", " ", " ", " ", " ", " ", " "],
  [" ", " ", " ", " ", " ", " ", " ", " "],
  ["p", "p", "p", "p", "p", "p", "p", "p"],
  ["r", "n", "b", "q", "k", "b", "n", "r"],
];

console.log(`${board.join("\n")}\n\n`);

// Move King's Pawn forward 2
board[4][4] = board[6][4];
board[6][4] = " ";
console.log(board.join("\n"));

Here is the output:
R,N,B,Q,K,B,N,R
P,P,P,P,P,P,P,P
 , , , , , , ,
 , , , , , , ,
 , , , , , , ,
 , , , , , , ,
p,p,p,p,p,p,p,p
r,n,b,q,k,b,n,r

R,N,B,Q,K,B,N,R
P,P,P,P,P,P,P,P
 , , , , , , ,
 , , , , , , ,
 , , , ,p, , ,
 , , , , , , ,
p,p,p,p, ,p,p,p
r,n,b,q,k,b,n,r
Using an array to tabulate a set of valuesjsconst values = [];
for (let x = 0; x < 10; x++) {
  values.push([2 ** x, 2 * x ** 2]);
}
console.table(values);

Results in
// The first column is the index
0  1    0
1  2    2
2  4    8
3  8    18
4  16   32
5  32   50
6  64   72
7  128  98
8  256  128
9  512  162
Creating an array using the result of a matchThe result of a match between a RegExp and a string can create a JavaScript array that has properties and elements which provide information about the match. Such an array is returned by RegExp.prototype.exec() and String.prototype.match().
For example:
js// Match one d followed by one or more b's followed by one d
// Remember matched b's and the following d
// Ignore case

const myRe = /d(b+)(d)/i;
const execResult = myRe.exec("cdbBdbsbz");

console.log(execResult.input); // 'cdbBdbsbz'
console.log(execResult.index); // 1
console.log(execResult); // [ "dbBd", "bB", "d" ]

For more information about the result of a match, see the RegExp.prototype.exec() and String.prototype.match() pages.Mutating initial array in iterative methodsIterative methods do not mutate the array on which it is called, but the function provided as callbackFn can. The key principle to remember is that only indexes between 0 and arrayLength - 1 are visited, where arrayLength is the length of the array at the time the array method was first called, but the element passed to the callback is the value at the time the index is visited. Therefore:

callbackFn will not visit any elements added beyond the array's initial length when the call to the iterative method began.
Changes to already-visited indexes do not cause callbackFn to be invoked on them again.
If an existing, yet-unvisited element of the array is changed by callbackFn, its value passed to the callbackFn will be the value at the time that element gets visited. Removed elements are not visited.


Warning:
Concurrent modifications of the kind described above frequently lead to hard-to-understand code and are generally to be avoided (except in special cases).

The following examples use the forEach method as an example, but other methods that visit indexes in ascending order work in the same way. We will first define a helper function:
jsfunction testSideEffect(effect) {
  const arr = ["e1", "e2", "e3", "e4"];
  arr.forEach((elem, index, arr) => {
    console.log(`array: [${arr.join(", ")}], index: ${index}, elem: ${elem}`);
    effect(arr, index);
  });
  console.log(`Final array: [${arr.join(", ")}]`);
}

Modification to indexes not visited yet will be visible once the index is reached:
jstestSideEffect((arr, index) => {
  if (index + 1 < arr.length) arr[index + 1] += "*";
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2*, e3, e4], index: 1, elem: e2*
// array: [e1, e2*, e3*, e4], index: 2, elem: e3*
// array: [e1, e2*, e3*, e4*], index: 3, elem: e4*
// Final array: [e1, e2*, e3*, e4*]

Modification to already visited indexes does not change iteration behavior, although the array will be different afterwards:
jstestSideEffect((arr, index) => {
  if (index > 0) arr[index - 1] += "*";
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2, e3, e4], index: 1, elem: e2
// array: [e1*, e2, e3, e4], index: 2, elem: e3
// array: [e1*, e2*, e3, e4], index: 3, elem: e4
// Final array: [e1*, e2*, e3*, e4]

Inserting n elements at unvisited indexes that are less than the initial array length will make them be visited. The last n elements in the original array that now have index greater than the initial array length will not be visited:
jstestSideEffect((arr, index) => {
  if (index === 1) arr.splice(2, 0, "new");
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2, e3, e4], index: 1, elem: e2
// array: [e1, e2, new, e3, e4], index: 2, elem: new
// array: [e1, e2, new, e3, e4], index: 3, elem: e3
// Final array: [e1, e2, new, e3, e4]
// e4 is not visited because it now has index 4

Inserting n elements with index greater than the initial array length will not make them be visited:
jstestSideEffect((arr) => arr.push("new"));
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2, e3, e4, new], index: 1, elem: e2
// array: [e1, e2, e3, e4, new, new], index: 2, elem: e3
// array: [e1, e2, e3, e4, new, new, new], index: 3, elem: e4
// Final array: [e1, e2, e3, e4, new, new, new, new]

Inserting n elements at already visited indexes will not make them be visited, but it shifts remaining elements back by n, so the current index and the n - 1 elements before it are visited again:
jstestSideEffect((arr, index) => arr.splice(index, 0, "new"));
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [new, e1, e2, e3, e4], index: 1, elem: e1
// array: [new, new, e1, e2, e3, e4], index: 2, elem: e1
// array: [new, new, new, e1, e2, e3, e4], index: 3, elem: e1
// Final array: [new, new, new, new, e1, e2, e3, e4]
// e1 keeps getting visited because it keeps getting shifted back

Deleting n elements at unvisited indexes will make them not be visited anymore. Because the array has shrunk, the last n iterations will visit out-of-bounds indexes. If the method ignores non-existent indexes (see array methods and empty slots), the last n iterations will be skipped; otherwise, they will receive undefined:
jstestSideEffect((arr, index) => {
  if (index === 1) arr.splice(2, 1);
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2, e3, e4], index: 1, elem: e2
// array: [e1, e2, e4], index: 2, elem: e4
// Final array: [e1, e2, e4]
// Does not visit index 3 because it's out-of-bounds

// Compare this with find(), which treats nonexistent indexes as undefined:
const arr2 = ["e1", "e2", "e3", "e4"];
arr2.find((elem, index, arr) => {
  console.log(`array: [${arr.join(", ")}], index: ${index}, elem: ${elem}`);
  if (index === 1) arr.splice(2, 1);
  return false;
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2, e3, e4], index: 1, elem: e2
// array: [e1, e2, e4], index: 2, elem: e4
// array: [e1, e2, e4], index: 3, elem: undefined

Deleting n elements at already visited indexes does not change the fact that they were visited before they get deleted. Because the array has shrunk, the next n elements after the current index are skipped. If the method ignores non-existent indexes, the last n iterations will be skipped; otherwise, they will receive undefined:
jstestSideEffect((arr, index) => arr.splice(index, 1));
// array: [e1, e2, e3, e4], index: 0, elem: e1
// Does not visit e2 because e2 now has index 0, which has already been visited
// array: [e2, e3, e4], index: 1, elem: e3
// Does not visit e4 because e4 now has index 1, which has already been visited
// Final array: [e2, e4]
// Index 2 is out-of-bounds, so it's not visited

// Compare this with find(), which treats nonexistent indexes as undefined:
const arr2 = ["e1", "e2", "e3", "e4"];
arr2.find((elem, index, arr) => {
  console.log(`array: [${arr.join(", ")}], index: ${index}, elem: ${elem}`);
  arr.splice(index, 1);
  return false;
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e2, e3, e4], index: 1, elem: e3
// array: [e2, e4], index: 2, elem: undefined
// array: [e2, e4], index: 3, elem: undefined

For methods that iterate in descending order of index, insertion causes elements to be skipped, and deletion causes elements to be visited multiple times. Adjust the code above yourself to see the effects.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-array-objectsBrowser compatibilitySee also
Indexed collections guide
TypedArray
ArrayBuffer
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nArrayBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Array object, as with arrays in other programming languages, enables storing a collection of multiple items under a single variable name, and has members for performing common array operations.DescriptionIn JavaScript, arrays aren't primitives but are instead Array objects with the following core characteristics:

JavaScript arrays are resizable and can contain a mix of different data types. (When those characteristics are undesirable, use typed arrays instead.)
JavaScript arrays are not associative arrays and so, array elements cannot be accessed using arbitrary strings as indexes, but must be accessed using nonnegative integers (or their respective string form) as indexes.
JavaScript arrays are zero-indexed: the first element of an array is at index 0, the second is at index 1, and so on — and the last element is at the value of the array's length property minus 1.
JavaScript array-copy operations create shallow copies. (All standard built-in copy operations with any JavaScript objects create shallow copies, rather than deep copies).
Array indicesArray objects cannot use arbitrary strings as element indexes (as in an associative array) but must use nonnegative integers (or their respective string form). Setting or accessing via non-integers will not set or retrieve an element from the array list itself, but will set or access a variable associated with that array's object property collection. The array's object properties and list of array elements are separate, and the array's traversal and mutation operations cannot be applied to these named properties.
Array elements are object properties in the same way that toString is a property (to be specific, however, toString() is a method). Nevertheless, trying to access an element of an array as follows throws a syntax error because the property name is not valid:
jsarr.0; // a syntax error

JavaScript syntax requires properties beginning with a digit to be accessed using bracket notation instead of dot notation. It's also possible to quote the array indices (e.g., years['2'] instead of years[2]), although usually not necessary.
The 2 in years[2] is coerced into a string by the JavaScript engine through an implicit toString conversion. As a result, '2' and '02' would refer to two different slots on the years object, and the following example could be true:
jsconsole.log(years["2"] !== years["02"]);

Only years['2'] is an actual array index. years['02'] is an arbitrary string property that will not be visited in array iteration.Relationship between length and numerical propertiesA JavaScript array's length property and numerical properties are connected.
Several of the built-in array methods (e.g., join(), slice(), indexOf(), etc.) take into account the value of an array's length property when they're called.
Other methods (e.g., push(), splice(), etc.) also result in updates to an array's length property.
jsconst fruits = [];
fruits.push("banana", "apple", "peach");
console.log(fruits.length); // 3

When setting a property on a JavaScript array when the property is a valid array index and that index is outside the current bounds of the array, the engine will update the array's length property accordingly:
jsfruits[5] = "mango";
console.log(fruits[5]); // 'mango'
console.log(Object.keys(fruits)); // ['0', '1', '2', '5']
console.log(fruits.length); // 6

Increasing the length extends the array by adding empty slots without creating any new elements — not even undefined.
jsfruits.length = 10;
console.log(fruits); // ['banana', 'apple', 'peach', empty x 2, 'mango', empty x 4]
console.log(Object.keys(fruits)); // ['0', '1', '2', '5']
console.log(fruits.length); // 10
console.log(fruits[8]); // undefined

Decreasing the length property does, however, delete elements.
jsfruits.length = 2;
console.log(Object.keys(fruits)); // ['0', '1']
console.log(fruits.length); // 2

This is explained further on the length page.Array methods and empty slotsArray methods have different behaviors when encountering empty slots in sparse arrays. In general, older methods (e.g., forEach) treat empty slots differently from indices that contain undefined.
Methods that have special treatment for empty slots include the following: concat(), copyWithin(), every(), filter(), flat(), flatMap(), forEach(), indexOf(), lastIndexOf(), map(), reduce(), reduceRight(), reverse(), slice(), some(), sort(), and splice(). Iteration methods such as forEach don't visit empty slots at all. Other methods, such as concat, copyWithin, etc., preserve empty slots when doing the copying, so in the end the array is still sparse.
jsconst colors = ["red", "yellow", "blue"];
colors[5] = "purple";
colors.forEach((item, index) => {
  console.log(`${index}: ${item}`);
});
// Output:
// 0: red
// 1: yellow
// 2: blue
// 5: purple

colors.reverse(); // ['purple', empty × 2, 'blue', 'yellow', 'red']

Newer methods (e.g., keys) do not treat empty slots specially and treat them as if they contain undefined. Methods that conflate empty slots with undefined elements include the following: entries(), fill(), find(), findIndex(), findLast(), findLastIndex(), includes(), join(), keys(), toLocaleString(), toReversed(), toSorted(), toSpliced(), values(), and with().
jsconst colors = ["red", "yellow", "blue"];
colors[5] = "purple";
const iterator = colors.keys();
for (const key of iterator) {
  console.log(`${key}: ${colors[key]}`);
}
// Output
// 0: red
// 1: yellow
// 2: blue
// 3: undefined
// 4: undefined
// 5: purple

const newColors = colors.toReversed(); // ['purple', undefined, undefined, 'blue', 'yellow', 'red']
Copying methods and mutating methodsSome methods do not mutate the existing array that the method was called on, but instead return a new array. They do so by first constructing a new array and then populating it with elements. The copy always happens shallowly — the method never copies anything beyond the initially created array. Elements of the original array(s) are copied into the new array as follows:

Objects: the object reference is copied into the new array. Both the original and new array refer to the same object. That is, if a referenced object is modified, the changes are visible to both the new and original arrays.
Primitive types such as strings, numbers and booleans (not String, Number, and Boolean objects): their values are copied into the new array.

Other methods mutate the array that the method was called on, in which case their return value differs depending on the method: sometimes a reference to the same array, sometimes the length of the new array.
The following methods create new arrays by accessing this.constructor[Symbol.species] to determine the constructor to use: concat(), filter(), flat(), flatMap(), map(), slice(), and splice() (to construct the array of removed elements that's returned).
The following methods always create new arrays with the Array base constructor: toReversed(), toSorted(), toSpliced(), and with().
The following table lists the methods that mutate the original array, and the corresponding non-mutating alternative:



Mutating method
Non-mutating alternative




copyWithin()
No one-method alternative


fill()
No one-method alternative


pop()
slice(0, -1)


push(v1, v2)
concat([v1, v2])


reverse()
toReversed()


shift()
slice(1)


sort()
toSorted()


splice()
toSpliced()


unshift(v1, v2)
toSpliced(0, 0, v1, v2)



An easy way to change a mutating method into a non-mutating alternative is to use the spread syntax or slice() to create a copy first:
jsarr.copyWithin(0, 1, 2); // mutates arr
const arr2 = arr.slice().copyWithin(0, 1, 2); // does not mutate arr
const arr3 = [...arr].copyWithin(0, 1, 2); // does not mutate arr
Iterative methodsMany array methods take a callback function as an argument. The callback function is called sequentially and at most once for each element in the array, and the return value of the callback function is used to determine the return value of the method. They all share the same signature:
jsmethod(callbackFn, thisArg)

Where callbackFn takes three arguments:

element

The current element being processed in the array.

index

The index of the current element being processed in the array.

array

The array that the method was called upon.


What callbackFn is expected to return depends on the array method that was called.
The thisArg argument (defaults to undefined) will be used as the this value when calling callbackFn. The this value ultimately observable by callbackFn is determined according to the usual rules: if callbackFn is non-strict, primitive this values are wrapped into objects, and undefined/null is substituted with globalThis. The thisArg argument is irrelevant for any callbackFn defined with an arrow function, as arrow functions don't have their own this binding.
The array argument passed to callbackFn is most useful if you want to read another index during iteration, because you may not always have an existing variable that refers to the current array. You should generally not mutate the array during iteration (see mutating initial array in iterative methods), but you can also use this argument to do so. The array argument is not the array that is being built, in the case of methods like map(), filter(), and flatMap() — there is no way to access the array being built from the callback function.
All iterative methods are copying and generic, although they behave differently with empty slots.
The following methods are iterative: every(), filter(), find(), findIndex(), findLast(), findLastIndex(), flatMap(), forEach(), map(), and some().
In particular, every(), find(), findIndex(), findLast(), findLastIndex(), and some() do not always invoke callbackFn on every element — they stop iteration as soon as the return value is determined.
The reduce() and reduceRight() methods also take a callback function and run it at most once for each element in the array, but they have slightly different signatures from typical iterative methods (for example, they don't accept thisArg).
The sort() method also takes a callback function, but it is not an iterative method. It mutates the array in-place, doesn't accept thisArg, and may invoke the callback multiple times on an index.
Iterative methods iterate the array like the following (with a lot of technical details omitted):
jsfunction method(callbackFn, thisArg) {
  const length = this.length;
  for (let i = 0; i < length; i++) {
    if (i in this) {
      const result = callbackFn.call(thisArg, this[i], i, this);
      // Do something with result; maybe return early
    }
  }
}

Note the following:

Not all methods do the i in this test. The find, findIndex, findLast, and findLastIndex methods do not, but other methods do.
The length is memorized before the loop starts. This affects how insertions and deletions during iteration are handled (see mutating initial array in iterative methods).
The method doesn't memorize the array contents, so if any index is modified during iteration, the new value might be observed.
The code above iterates the array in ascending order of index. Some methods iterate in descending order of index (for (let i = length - 1; i >= 0; i--)): reduceRight(), findLast(), and findLastIndex().
reduce and reduceRight have slightly different signatures and do not always start at the first/last element.
Generic array methodsArray methods are always generic — they don't access any internal data of the array object. They only access the array elements through the length property and the indexed elements. This means that they can be called on array-like objects as well.
jsconst arrayLike = {
  0: "a",
  1: "b",
  length: 2,
};
console.log(Array.prototype.join.call(arrayLike, "+")); // 'a+b'

Normalization of the length property
The length property is converted to an integer and then clamped to the range between 0 and 253 - 1. NaN becomes 0, so even when length is not present or is undefined, it behaves as if it has value 0.
The language avoids setting length to an unsafe integer. All built-in methods will throw a TypeError if length will be set to a number greater than 253 - 1. However, because the length property of arrays throws an error if it's set to greater than 232 - 1, the safe integer threshold is usually not reached unless the method is called on a non-array object.
jsArray.prototype.flat.call({}); // []

Some array methods set the length property of the array object. They always set the value after normalization, so length always ends as an integer.
jsconst a = { length: 0.7 };
Array.prototype.push.call(a);
console.log(a.length); // 0

Array-like objects
The term array-like object refers to any object that doesn't throw during the length conversion process described above. In practice, such object is expected to actually have a length property and to have indexed elements in the range 0 to length - 1. (If it doesn't have all indices, it will be functionally equivalent to a sparse array.) Any integer index less than zero or greater than length - 1 is ignored when an array method operates on an array-like object.
Many DOM objects are array-like — for example, NodeList and HTMLCollection. The arguments object is also array-like. You can call array methods on them even if they don't have these methods themselves.
jsfunction f() {
  console.log(Array.prototype.join.call(arguments, "+"));
}

f("a", "b"); // 'a+b'
Constructor
Array()

Creates a new Array object.

Static properties
Array[Symbol.species]

Returns the Array constructor.

Static methods
Array.from()

Creates a new Array instance from an iterable or array-like object.

Array.fromAsync()

Creates a new Array instance from an async iterable, iterable, or array-like object.

Array.isArray()

Returns true if the argument is an array, or false otherwise.

Array.of()

Creates a new Array instance with a variable number of arguments, regardless of number or type of the arguments.

Instance propertiesThese properties are defined on Array.prototype and shared by all Array instances.

Array.prototype.constructor

The constructor function that created the instance object. For Array instances, the initial value is the Array constructor.

Array.prototype[Symbol.unscopables]

Contains property names that were not included in the ECMAScript standard prior to the ES2015 version and that are ignored for with statement-binding purposes.


These properties are own properties of each Array instance.

length

Reflects the number of elements in an array.

Instance methods
Array.prototype.at()

Returns the array item at the given index. Accepts negative integers, which count back from the last item.

Array.prototype.concat()

Returns a new array that is the calling array joined with other array(s) and/or value(s).

Array.prototype.copyWithin()

Copies a sequence of array elements within an array.

Array.prototype.entries()

Returns a new array iterator object that contains the key/value pairs for each index in an array.

Array.prototype.every()

Returns true if every element in the calling array satisfies the testing function.

Array.prototype.fill()

Fills all the elements of an array from a start index to an end index with a static value.

Array.prototype.filter()

Returns a new array containing all elements of the calling array for which the provided filtering function returns true.

Array.prototype.find()

Returns the value of the first element in the array that satisfies the provided testing function, or undefined if no appropriate element is found.

Array.prototype.findIndex()

Returns the index of the first element in the array that satisfies the provided testing function, or -1 if no appropriate element was found.

Array.prototype.findLast()

Returns the value of the last element in the array that satisfies the provided testing function, or undefined if no appropriate element is found.

Array.prototype.findLastIndex()

Returns the index of the last element in the array that satisfies the provided testing function, or -1 if no appropriate element was found.

Array.prototype.flat()

Returns a new array with all sub-array elements concatenated into it recursively up to the specified depth.

Array.prototype.flatMap()

Returns a new array formed by applying a given callback function to each element of the calling array, and then flattening the result by one level.

Array.prototype.forEach()

Calls a function for each element in the calling array.

Array.prototype.includes()

Determines whether the calling array contains a value, returning true or false as appropriate.

Array.prototype.indexOf()

Returns the first (least) index at which a given element can be found in the calling array.

Array.prototype.join()

Joins all elements of an array into a string.

Array.prototype.keys()

Returns a new array iterator that contains the keys for each index in the calling array.

Array.prototype.lastIndexOf()

Returns the last (greatest) index at which a given element can be found in the calling array, or -1 if none is found.

Array.prototype.map()

Returns a new array containing the results of invoking a function on every element in the calling array.

Array.prototype.pop()

Removes the last element from an array and returns that element.

Array.prototype.push()

Adds one or more elements to the end of an array, and returns the new length of the array.

Array.prototype.reduce()

Executes a user-supplied "reducer" callback function on each element of the array (from left to right), to reduce it to a single value.

Array.prototype.reduceRight()

Executes a user-supplied "reducer" callback function on each element of the array (from right to left), to reduce it to a single value.

Array.prototype.reverse()

Reverses the order of the elements of an array in place. (First becomes the last, last becomes first.)

Array.prototype.shift()

Removes the first element from an array and returns that element.

Array.prototype.slice()

Extracts a section of the calling array and returns a new array.

Array.prototype.some()

Returns true if at least one element in the calling array satisfies the provided testing function.

Array.prototype.sort()

Sorts the elements of an array in place and returns the array.

Array.prototype.splice()

Adds and/or removes elements from an array.

Array.prototype.toLocaleString()

Returns a localized string representing the calling array and its elements. Overrides the Object.prototype.toLocaleString() method.

Array.prototype.toReversed()

Returns a new array with the elements in reversed order, without modifying the original array.

Array.prototype.toSorted()

Returns a new array with the elements sorted in ascending order, without modifying the original array.

Array.prototype.toSpliced()

Returns a new array with some elements removed and/or replaced at a given index, without modifying the original array.

Array.prototype.toString()

Returns a string representing the calling array and its elements. Overrides the Object.prototype.toString() method.

Array.prototype.unshift()

Adds one or more elements to the front of an array, and returns the new length of the array.

Array.prototype.values()

Returns a new array iterator object that contains the values for each index in the array.

Array.prototype.with()

Returns a new array with the element at the given index replaced with the given value, without modifying the original array.

Array.prototype[Symbol.iterator]()

An alias for the values() method by default.

ExamplesThis section provides some examples of common array operations in JavaScript.

Note:
If you're not yet familiar with array basics, consider first reading JavaScript First Steps: Arrays, which explains what arrays are, and includes other examples of common array operations.
Create an arrayThis example shows three ways to create new array: first using array literal notation, then using the Array() constructor, and finally using String.prototype.split() to build the array from a string.
js// 'fruits' array created using array literal notation.
const fruits = ["Apple", "Banana"];
console.log(fruits.length);
// 2

// 'fruits2' array created using the Array() constructor.
const fruits2 = new Array("Apple", "Banana");
console.log(fruits2.length);
// 2

// 'fruits3' array created using String.prototype.split().
const fruits3 = "Apple, Banana".split(", ");
console.log(fruits3.length);
// 2
Create a string from an arrayThis example uses the join() method to create a string from the fruits array.
jsconst fruits = ["Apple", "Banana"];
const fruitsString = fruits.join(", ");
console.log(fruitsString);
// "Apple, Banana"
Access an array item by its indexThis example shows how to access items in the fruits array by specifying the index number of their position in the array.
jsconst fruits = ["Apple", "Banana"];

// The index of an array's first element is always 0.
fruits[0]; // Apple

// The index of an array's second element is always 1.
fruits[1]; // Banana

// The index of an array's last element is always one
// less than the length of the array.
fruits[fruits.length - 1]; // Banana

// Using an index number larger than the array's length
// returns 'undefined'.
fruits[99]; // undefined
Find the index of an item in an arrayThis example uses the indexOf() method to find the position (index) of the string "Banana" in the fruits array.
jsconst fruits = ["Apple", "Banana"];
console.log(fruits.indexOf("Banana"));
// 1
Check if an array contains a certain itemThis example shows two ways to check if the fruits array contains "Banana" and "Cherry": first with the includes() method, and then with the indexOf() method to test for an index value that's not -1.
jsconst fruits = ["Apple", "Banana"];

fruits.includes("Banana"); // true
fruits.includes("Cherry"); // false

// If indexOf() doesn't return -1, the array contains the given item.
fruits.indexOf("Banana") !== -1; // true
fruits.indexOf("Cherry") !== -1; // false
Append an item to an arrayThis example uses the push() method to append a new string to the fruits array.
jsconst fruits = ["Apple", "Banana"];
const newLength = fruits.push("Orange");
console.log(fruits);
// ["Apple", "Banana", "Orange"]
console.log(newLength);
// 3
Remove the last item from an arrayThis example uses the pop() method to remove the last item from the fruits array.
jsconst fruits = ["Apple", "Banana", "Orange"];
const removedItem = fruits.pop();
console.log(fruits);
// ["Apple", "Banana"]
console.log(removedItem);
// Orange


Note: pop() can only be used to remove the last item from an array. To remove multiple items from the end of an array, see the next example.
Remove multiple items from the end of an arrayThis example uses the splice() method to remove the last 3 items from the fruits array.
jsconst fruits = ["Apple", "Banana", "Strawberry", "Mango", "Cherry"];
const start = -3;
const removedItems = fruits.splice(start);
console.log(fruits);
// ["Apple", "Banana"]
console.log(removedItems);
// ["Strawberry", "Mango", "Cherry"]
Truncate an array down to just its first N itemsThis example uses the splice() method to truncate the fruits array down to just its first 2 items.
jsconst fruits = ["Apple", "Banana", "Strawberry", "Mango", "Cherry"];
const start = 2;
const removedItems = fruits.splice(start);
console.log(fruits);
// ["Apple", "Banana"]
console.log(removedItems);
// ["Strawberry", "Mango", "Cherry"]
Remove the first item from an arrayThis example uses the shift() method to remove the first item from the fruits array.
jsconst fruits = ["Apple", "Banana"];
const removedItem = fruits.shift();
console.log(fruits);
// ["Banana"]
console.log(removedItem);
// Apple


Note: shift() can only be used to remove the first item from an array. To remove multiple items from the beginning of an array, see the next example.
Remove multiple items from the beginning of an arrayThis example uses the splice() method to remove the first 3 items from the fruits array.
jsconst fruits = ["Apple", "Strawberry", "Cherry", "Banana", "Mango"];
const start = 0;
const deleteCount = 3;
const removedItems = fruits.splice(start, deleteCount);
console.log(fruits);
// ["Banana", "Mango"]
console.log(removedItems);
// ["Apple", "Strawberry", "Cherry"]
Add a new first item to an arrayThis example uses the unshift() method to add, at index 0, a new item to the fruits array — making it the new first item in the array.
jsconst fruits = ["Banana", "Mango"];
const newLength = fruits.unshift("Strawberry");
console.log(fruits);
// ["Strawberry", "Banana", "Mango"]
console.log(newLength);
// 3
Remove a single item by indexThis example uses the splice() method to remove the string "Banana" from the fruits array — by specifying the index position of "Banana".
jsconst fruits = ["Strawberry", "Banana", "Mango"];
const start = fruits.indexOf("Banana");
const deleteCount = 1;
const removedItems = fruits.splice(start, deleteCount);
console.log(fruits);
// ["Strawberry", "Mango"]
console.log(removedItems);
// ["Banana"]
Remove multiple items by indexThis example uses the splice() method to remove the strings "Banana" and "Strawberry" from the fruits array — by specifying the index position of "Banana", along with a count of the number of total items to remove.
jsconst fruits = ["Apple", "Banana", "Strawberry", "Mango"];
const start = 1;
const deleteCount = 2;
const removedItems = fruits.splice(start, deleteCount);
console.log(fruits);
// ["Apple", "Mango"]
console.log(removedItems);
// ["Banana", "Strawberry"]
Replace multiple items in an arrayThis example uses the splice() method to replace the last 2 items in the fruits array with new items.
jsconst fruits = ["Apple", "Banana", "Strawberry"];
const start = -2;
const deleteCount = 2;
const removedItems = fruits.splice(start, deleteCount, "Mango", "Cherry");
console.log(fruits);
// ["Apple", "Mango", "Cherry"]
console.log(removedItems);
// ["Banana", "Strawberry"]
Iterate over an arrayThis example uses a for...of loop to iterate over the fruits array, logging each item to the console.
jsconst fruits = ["Apple", "Mango", "Cherry"];
for (const fruit of fruits) {
  console.log(fruit);
}
// Apple
// Mango
// Cherry

But for...of is just one of many ways to iterate over any array; for more ways, see Loops and iteration, and see the documentation for the every(), filter(), flatMap(), map(), reduce(), and reduceRight() methods — and see the next example, which uses the forEach() method.Call a function on each element in an arrayThis example uses the forEach() method to call a function on each element in the fruits array; the function causes each item to be logged to the console, along with the item's index number.
jsconst fruits = ["Apple", "Mango", "Cherry"];
fruits.forEach((item, index, array) => {
  console.log(item, index);
});
// Apple 0
// Mango 1
// Cherry 2
Merge multiple arrays togetherThis example uses the concat() method to merge the fruits array with a moreFruits array, to produce a new combinedFruits array. Notice that fruits and moreFruits remain unchanged.
jsconst fruits = ["Apple", "Banana", "Strawberry"];
const moreFruits = ["Mango", "Cherry"];
const combinedFruits = fruits.concat(moreFruits);
console.log(combinedFruits);
// ["Apple", "Banana", "Strawberry", "Mango", "Cherry"]

// The 'fruits' array remains unchanged.
console.log(fruits);
// ["Apple", "Banana", "Strawberry"]

// The 'moreFruits' array also remains unchanged.
console.log(moreFruits);
// ["Mango", "Cherry"]
Copy an arrayThis example shows three ways to create a new array from the existing fruits array: first by using spread syntax, then by using the from() method, and then by using the slice() method.
jsconst fruits = ["Strawberry", "Mango"];

// Create a copy using spread syntax.
const fruitsCopy = [...fruits];
// ["Strawberry", "Mango"]

// Create a copy using the from() method.
const fruitsCopy2 = Array.from(fruits);
// ["Strawberry", "Mango"]

// Create a copy using the slice() method.
const fruitsCopy3 = fruits.slice();
// ["Strawberry", "Mango"]

All built-in array-copy operations (spread syntax, Array.from(), Array.prototype.slice(), and Array.prototype.concat()) create shallow copies. If you instead want a deep copy of an array, you can use JSON.stringify() to convert the array to a JSON string, and then JSON.parse() to convert the string back into a new array that's completely independent from the original array.
jsconst fruitsDeepCopy = JSON.parse(JSON.stringify(fruits));

You can also create deep copies using the structuredClone() method, which has the advantage of allowing transferable objects in the source to be transferred to the new copy, rather than just cloned.
Finally, it's important to understand that assigning an existing array to a new variable doesn't create a copy of either the array or its elements. Instead the new variable is just a reference, or alias, to the original array; that is, the original array's name and the new variable name are just two names for the exact same object (and so will always evaluate as strictly equivalent). Therefore, if you make any changes at all either to the value of the original array or to the value of the new variable, the other will change, too:
jsconst fruits = ["Strawberry", "Mango"];
const fruitsAlias = fruits;
// 'fruits' and 'fruitsAlias' are the same object, strictly equivalent.
fruits === fruitsAlias; // true
// Any changes to the 'fruits' array change 'fruitsAlias' too.
fruits.unshift("Apple", "Banana");
console.log(fruits);
// ['Apple', 'Banana', 'Strawberry', 'Mango']
console.log(fruitsAlias);
// ['Apple', 'Banana', 'Strawberry', 'Mango']
Creating a two-dimensional arrayThe following creates a chessboard as a two-dimensional array of strings. The first move is made by copying the 'p' in board[6][4] to board[4][4]. The old position at [6][4] is made blank.
jsconst board = [
  ["R", "N", "B", "Q", "K", "B", "N", "R"],
  ["P", "P", "P", "P", "P", "P", "P", "P"],
  [" ", " ", " ", " ", " ", " ", " ", " "],
  [" ", " ", " ", " ", " ", " ", " ", " "],
  [" ", " ", " ", " ", " ", " ", " ", " "],
  [" ", " ", " ", " ", " ", " ", " ", " "],
  ["p", "p", "p", "p", "p", "p", "p", "p"],
  ["r", "n", "b", "q", "k", "b", "n", "r"],
];

console.log(`${board.join("\n")}\n\n`);

// Move King's Pawn forward 2
board[4][4] = board[6][4];
board[6][4] = " ";
console.log(board.join("\n"));

Here is the output:
R,N,B,Q,K,B,N,R
P,P,P,P,P,P,P,P
 , , , , , , ,
 , , , , , , ,
 , , , , , , ,
 , , , , , , ,
p,p,p,p,p,p,p,p
r,n,b,q,k,b,n,r

R,N,B,Q,K,B,N,R
P,P,P,P,P,P,P,P
 , , , , , , ,
 , , , , , , ,
 , , , ,p, , ,
 , , , , , , ,
p,p,p,p, ,p,p,p
r,n,b,q,k,b,n,r
Using an array to tabulate a set of valuesjsconst values = [];
for (let x = 0; x < 10; x++) {
  values.push([2 ** x, 2 * x ** 2]);
}
console.table(values);

Results in
// The first column is the index
0  1    0
1  2    2
2  4    8
3  8    18
4  16   32
5  32   50
6  64   72
7  128  98
8  256  128
9  512  162
Creating an array using the result of a matchThe result of a match between a RegExp and a string can create a JavaScript array that has properties and elements which provide information about the match. Such an array is returned by RegExp.prototype.exec() and String.prototype.match().
For example:
js// Match one d followed by one or more b's followed by one d
// Remember matched b's and the following d
// Ignore case

const myRe = /d(b+)(d)/i;
const execResult = myRe.exec("cdbBdbsbz");

console.log(execResult.input); // 'cdbBdbsbz'
console.log(execResult.index); // 1
console.log(execResult); // [ "dbBd", "bB", "d" ]

For more information about the result of a match, see the RegExp.prototype.exec() and String.prototype.match() pages.Mutating initial array in iterative methodsIterative methods do not mutate the array on which it is called, but the function provided as callbackFn can. The key principle to remember is that only indexes between 0 and arrayLength - 1 are visited, where arrayLength is the length of the array at the time the array method was first called, but the element passed to the callback is the value at the time the index is visited. Therefore:

callbackFn will not visit any elements added beyond the array's initial length when the call to the iterative method began.
Changes to already-visited indexes do not cause callbackFn to be invoked on them again.
If an existing, yet-unvisited element of the array is changed by callbackFn, its value passed to the callbackFn will be the value at the time that element gets visited. Removed elements are not visited.


Warning:
Concurrent modifications of the kind described above frequently lead to hard-to-understand code and are generally to be avoided (except in special cases).

The following examples use the forEach method as an example, but other methods that visit indexes in ascending order work in the same way. We will first define a helper function:
jsfunction testSideEffect(effect) {
  const arr = ["e1", "e2", "e3", "e4"];
  arr.forEach((elem, index, arr) => {
    console.log(`array: [${arr.join(", ")}], index: ${index}, elem: ${elem}`);
    effect(arr, index);
  });
  console.log(`Final array: [${arr.join(", ")}]`);
}

Modification to indexes not visited yet will be visible once the index is reached:
jstestSideEffect((arr, index) => {
  if (index + 1 < arr.length) arr[index + 1] += "*";
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2*, e3, e4], index: 1, elem: e2*
// array: [e1, e2*, e3*, e4], index: 2, elem: e3*
// array: [e1, e2*, e3*, e4*], index: 3, elem: e4*
// Final array: [e1, e2*, e3*, e4*]

Modification to already visited indexes does not change iteration behavior, although the array will be different afterwards:
jstestSideEffect((arr, index) => {
  if (index > 0) arr[index - 1] += "*";
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2, e3, e4], index: 1, elem: e2
// array: [e1*, e2, e3, e4], index: 2, elem: e3
// array: [e1*, e2*, e3, e4], index: 3, elem: e4
// Final array: [e1*, e2*, e3*, e4]

Inserting n elements at unvisited indexes that are less than the initial array length will make them be visited. The last n elements in the original array that now have index greater than the initial array length will not be visited:
jstestSideEffect((arr, index) => {
  if (index === 1) arr.splice(2, 0, "new");
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2, e3, e4], index: 1, elem: e2
// array: [e1, e2, new, e3, e4], index: 2, elem: new
// array: [e1, e2, new, e3, e4], index: 3, elem: e3
// Final array: [e1, e2, new, e3, e4]
// e4 is not visited because it now has index 4

Inserting n elements with index greater than the initial array length will not make them be visited:
jstestSideEffect((arr) => arr.push("new"));
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2, e3, e4, new], index: 1, elem: e2
// array: [e1, e2, e3, e4, new, new], index: 2, elem: e3
// array: [e1, e2, e3, e4, new, new, new], index: 3, elem: e4
// Final array: [e1, e2, e3, e4, new, new, new, new]

Inserting n elements at already visited indexes will not make them be visited, but it shifts remaining elements back by n, so the current index and the n - 1 elements before it are visited again:
jstestSideEffect((arr, index) => arr.splice(index, 0, "new"));
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [new, e1, e2, e3, e4], index: 1, elem: e1
// array: [new, new, e1, e2, e3, e4], index: 2, elem: e1
// array: [new, new, new, e1, e2, e3, e4], index: 3, elem: e1
// Final array: [new, new, new, new, e1, e2, e3, e4]
// e1 keeps getting visited because it keeps getting shifted back

Deleting n elements at unvisited indexes will make them not be visited anymore. Because the array has shrunk, the last n iterations will visit out-of-bounds indexes. If the method ignores non-existent indexes (see array methods and empty slots), the last n iterations will be skipped; otherwise, they will receive undefined:
jstestSideEffect((arr, index) => {
  if (index === 1) arr.splice(2, 1);
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2, e3, e4], index: 1, elem: e2
// array: [e1, e2, e4], index: 2, elem: e4
// Final array: [e1, e2, e4]
// Does not visit index 3 because it's out-of-bounds

// Compare this with find(), which treats nonexistent indexes as undefined:
const arr2 = ["e1", "e2", "e3", "e4"];
arr2.find((elem, index, arr) => {
  console.log(`array: [${arr.join(", ")}], index: ${index}, elem: ${elem}`);
  if (index === 1) arr.splice(2, 1);
  return false;
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2, e3, e4], index: 1, elem: e2
// array: [e1, e2, e4], index: 2, elem: e4
// array: [e1, e2, e4], index: 3, elem: undefined

Deleting n elements at already visited indexes does not change the fact that they were visited before they get deleted. Because the array has shrunk, the next n elements after the current index are skipped. If the method ignores non-existent indexes, the last n iterations will be skipped; otherwise, they will receive undefined:
jstestSideEffect((arr, index) => arr.splice(index, 1));
// array: [e1, e2, e3, e4], index: 0, elem: e1
// Does not visit e2 because e2 now has index 0, which has already been visited
// array: [e2, e3, e4], index: 1, elem: e3
// Does not visit e4 because e4 now has index 1, which has already been visited
// Final array: [e2, e4]
// Index 2 is out-of-bounds, so it's not visited

// Compare this with find(), which treats nonexistent indexes as undefined:
const arr2 = ["e1", "e2", "e3", "e4"];
arr2.find((elem, index, arr) => {
  console.log(`array: [${arr.join(", ")}], index: ${index}, elem: ${elem}`);
  arr.splice(index, 1);
  return false;
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e2, e3, e4], index: 1, elem: e3
// array: [e2, e4], index: 2, elem: undefined
// array: [e2, e4], index: 3, elem: undefined

For methods that iterate in descending order of index, insertion causes elements to be skipped, and deletion causes elements to be visited multiple times. Adjust the code above yourself to see the effects.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-array-objectsBrowser compatibilitySee also
Indexed collections guide
TypedArray
ArrayBuffer
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIntl.NumberFormatBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat object enables language-sensitive number formatting.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Constructor
Intl.NumberFormat()

Creates a new NumberFormat object.

Static methods
Intl.NumberFormat.supportedLocalesOf()

Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.

Instance propertiesThese properties are defined on Intl.NumberFormat.prototype and shared by all Intl.NumberFormat instances.

Intl.NumberFormat.prototype.constructor

The constructor function that created the instance object. For Intl.NumberFormat instances, the initial value is the Intl.NumberFormat constructor.

Intl.NumberFormat.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl.NumberFormat". This property is used in Object.prototype.toString().

Instance methods
Intl.NumberFormat.prototype.format()

Getter function that formats a number according to the locale and formatting options of this Intl.NumberFormat object.

Intl.NumberFormat.prototype.formatRange()

Getter function that formats a range of numbers according to the locale and formatting options of the Intl.NumberFormat object from which the method is called.

Intl.NumberFormat.prototype.formatRangeToParts()

Returns an Array of objects representing the range of number strings in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.formatToParts()

Returns an Array of objects representing the number string in parts that can be used for custom locale-aware formatting.

Intl.NumberFormat.prototype.resolvedOptions()

Returns a new object with properties reflecting the locale and collation options computed during initialization of the object.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst number = 3500;

console.log(new Intl.NumberFormat().format(number));
// '3,500' if in US English locale
Using localesThis example shows some of the variations in localized number formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(new Intl.NumberFormat("de-DE").format(number));
// 123.456,789

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.NumberFormat("ar-EG").format(number));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(new Intl.NumberFormat("en-IN").format(number));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.NumberFormat(["ban", "id"]).format(number));
// 123.456,789
Using optionsThe results can be customized using the options argument:
jsconst number = 123456.789;

// request a currency format
console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// ￥123,457

// limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// 1,23,000

// Formatting with units
console.log(
  new Intl.NumberFormat("pt-PT", {
    style: "unit",
    unit: "kilometer-per-hour",
  }).format(50),
);
// 50 km/h

console.log(
  (16).toLocaleString("en-GB", {
    style: "unit",
    unit: "liter",
    unitDisplay: "long",
  }),
);
// 16 litres

For an exhaustive list of options, see the Intl.NumberFormat() constructor page.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # numberformat-objectsBrowser compatibilitySee also
Polyfill of Intl.NumberFormat in FormatJS
Intl
Number.prototype.toLocaleString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIntl.NumberFormat() constructorBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat() constructor creates Intl.NumberFormat objects.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Syntaxjsnew Intl.NumberFormat()
new Intl.NumberFormat(locales)
new Intl.NumberFormat(locales, options)

Intl.NumberFormat()
Intl.NumberFormat(locales)
Intl.NumberFormat(locales, options)


Note: Intl.NumberFormat() can be called with or without new. Both create a new Intl.NumberFormat instance. However, there's a special behavior when it's called without new and the this value is another Intl.NumberFormat instance; see Return value.
Parameters
locales Optional

A string with a BCP 47 language tag or an Intl.Locale instance, or an array of such locale identifiers. The runtime's default locale is used when undefined is passed or when none of the specified locale identifiers is supported. For the general form and interpretation of the locales argument, see the parameter description on the Intl main page.
The following Unicode extension key is allowed:

nu

See numberingSystem.


This key can also be set with options (as listed below). When both are set, the options property takes precedence.

options Optional

An object. For ease of reading, the property list is broken into sections based on their purposes, including locale options, style options, digit options, and other options.


Locale options

localeMatcher

The locale matching algorithm to use. Possible values are "lookup" and "best fit"; the default is "best fit".
For information about this option, see Locale identification and negotiation.

numberingSystem

The numbering system to use for number formatting, such as "arab", "hans", "mathsans", and so on. For a list of supported numbering system types, see Intl.supportedValuesOf(). This option can also be set through the nu Unicode extension key; if both are provided, this options property takes precedence.


Style options
Depending on the style used, some of them may be ignored, and others may be required:

style

The formatting style to use.

"decimal" (default)

For plain number formatting.

"currency"

For currency formatting.

"percent"

For percent formatting.

"unit"

For unit formatting.



currency

The currency to use in currency formatting. Possible values are the ISO 4217 currency codes, such as "USD" for the US dollar, "EUR" for the euro, or "CNY" for the Chinese RMB — see Intl.supportedValuesOf(). There is no default value; if the style is "currency", the currency property must be provided. It is normalized to uppercase.

currencyDisplay

How to display the currency in currency formatting.

"code"

Use the ISO currency code.

"symbol" (default)

Use a localized currency symbol such as €.

"narrowSymbol"

Use a narrow format symbol ("$100" rather than "US$100").

"name"

Use a localized currency name such as "dollar".



currencySign

In many locales, accounting format means to wrap the number with parentheses instead of appending a minus sign. Possible values are "standard" and "accounting"; the default is "standard".

unit

The unit to use in unit formatting, Possible values are listed in Intl.supportedValuesOf(). Pairs of simple units can be concatenated with "-per-" to make a compound unit. There is no default value; if the style is "unit", the unit property must be provided.

unitDisplay

The unit formatting style to use in unit formatting. Possible values are:

"short" (default)

E.g., 16 l.

"narrow"

E.g., 16l.

"long"

E.g., 16 litres.




Digit options
The following properties are also supported by Intl.PluralRules.

minimumIntegerDigits

The minimum number of integer digits to use. A value with a smaller number of integer digits than this number will be left-padded with zeros (to the specified length) when formatted. Possible values are from 1 to 21; the default is 1.

minimumFractionDigits

The minimum number of fraction digits to use. Possible values are from 0 to 100; the default for plain number and percent formatting is 0; the default for currency formatting is the number of minor unit digits provided by the ISO 4217 currency code list (2 if the list doesn't provide that information). See SignificantDigits/FractionDigits default values for when this default gets applied.

maximumFractionDigits

The maximum number of fraction digits to use. Possible values are from 0 to 100; the default for plain number formatting is the larger of minimumFractionDigits and 3; the default for currency formatting is the larger of minimumFractionDigits and the number of minor unit digits provided by the ISO 4217 currency code list (2 if the list doesn't provide that information); the default for percent formatting is the larger of minimumFractionDigits and 0. See SignificantDigits/FractionDigits default values for when this default gets applied.

minimumSignificantDigits

The minimum number of significant digits to use. Possible values are from 1 to 21; the default is 1. See SignificantDigits/FractionDigits default values for when this default gets applied.

maximumSignificantDigits

The maximum number of significant digits to use. Possible values are from 1 to 21; the default is 21. See SignificantDigits/FractionDigits default values for when this default gets applied.

roundingPriority

Specify how rounding conflicts will be resolved if both "FractionDigits" (minimumFractionDigits/maximumFractionDigits) and "SignificantDigits" (minimumSignificantDigits/maximumSignificantDigits) are specified.
Possible values are:

"auto" (default)

The result from the significant digits property is used.

"morePrecision"

The result from the property that results in more precision is used.

"lessPrecision"

The result from the property that results in less precision is used.


The value "auto" is normalized to "morePrecision" if notation is "compact" and none of the four "FractionDigits"/"SignificantDigits" options are set.
Note that for values other than auto the result with more precision is calculated from the maximumSignificantDigits and maximumFractionDigits (minimum fractional and significant digit settings are ignored).

roundingIncrement

Indicates the increment at which rounding should take place relative to the calculated rounding magnitude. Possible values are 1, 2, 5, 10, 20, 25, 50, 100, 200, 250, 500, 1000, 2000, 2500, and 5000; the default is 1. It cannot be mixed with significant-digits rounding or any setting of roundingPriority other than auto.

roundingMode

How decimals should be rounded. Possible values are:

"ceil"

Round toward +∞. Positive values round up. Negative values round "more positive".

"floor"

Round toward -∞. Positive values round down. Negative values round "more negative".

"expand"

Round away from 0. The magnitude of the value is always increased by rounding. Positive values round up. Negative values round "more negative".

"trunc"

Round toward 0. This magnitude of the value is always reduced by rounding. Positive values round down. Negative values round "less negative".

"halfCeil"

Ties toward +∞. Values above the half-increment round like "ceil" (towards +∞), and below like "floor" (towards -∞). On the half-increment, values round like "ceil".

"halfFloor"

Ties toward -∞. Values above the half-increment round like "ceil" (towards +∞), and below like "floor" (towards -∞). On the half-increment, values round like "floor".

"halfExpand" (default)

Ties away from 0. Values above the half-increment round like "expand" (away from zero), and below like "trunc" (towards 0). On the half-increment, values round like "expand".

"halfTrunc"

Ties toward 0. Values above the half-increment round like "expand" (away from zero), and below like "trunc" (towards 0). On the half-increment, values round like "trunc".

"halfEven"

Ties towards the nearest even integer. Values above the half-increment round like "expand" (away from zero), and below like "trunc" (towards 0). On the half-increment values round towards the nearest even digit.


These options reflect the ICU user guide, where "expand" and "trunc" map to ICU "UP" and "DOWN", respectively.
The rounding modes example below demonstrates how each mode works.

trailingZeroDisplay

The strategy for displaying trailing zeros on whole numbers. Possible values are:

"auto" (default)

Keep trailing zeros according to minimumFractionDigits and minimumSignificantDigits.

"stripIfInteger"

Remove the fraction digits if they are all zero. This is the same as "auto" if any of the fraction digits is non-zero.




SignificantDigits/FractionDigits default values
For the four options above (the FractionDigits and SignificantDigits options), we mentioned their defaults; however, these defaults are not unconditionally applied. They are only applied when the property is actually going to be used, which depends on the roundingPriority and notation settings. Specifically:

If roundingPriority is not "auto", then all four options apply.
If roundingPriority is "auto" and at least one SignificantDigits option is set, then the SignificantDigits options apply and the FractionDigits options are ignored.
If roundingPriority is "auto", and either at least one FractionDigits option is set or notation is not "compact", then the FractionDigits options apply and the SignificantDigits options are ignored.
If roundingPriority is "auto", notation is "compact", and none of the four options are set, then they are set to { minimumFractionDigits: 0, maximumFractionDigits: 0, minimumSignificantDigits: 1, maximumSignificantDigits: 2 }, regardless of the defaults mentioned above, and roundingPriority is set to "morePrecision".

Other options

notation

The formatting that should be displayed for the number. Possible values are:

"standard" (default)

Plain number formatting.

"scientific"

Return the order-of-magnitude for formatted number.

"engineering"

Return the exponent of ten when divisible by three.

"compact"

String representing exponent; defaults to using the "short" form.



compactDisplay

Only used when notation is "compact". Possible values are "short" and "long"; the default is "short".

useGrouping

Whether to use grouping separators, such as thousands separators or thousand/lakh/crore separators.

"always"

Display grouping separators even if the locale prefers otherwise.

"auto"

Display grouping separators based on the locale preference, which may also be dependent on the currency.

"min2"

Display grouping separators when there are at least 2 digits in a group.

true

Same as "always".

false

Display no grouping separators.


The default is "min2" if notation is "compact", and "auto" otherwise. The string values "true" and "false" are accepted, but are always converted to the default value.

signDisplay

When to display the sign for the number. Possible values are:

"auto" (default)

Sign display for negative numbers only, including negative zero.

"always"

Always display sign.

"exceptZero"

Sign display for positive and negative numbers, but not zero.

"negative"

Sign display for negative numbers only, excluding negative zero.

"never"

Never display sign.



Return valueA new Intl.NumberFormat object.

Note:
The text below describes behavior that is marked by the specification as "optional". It may not work in all environments. Check the browser compatibility table.

Normally, Intl.NumberFormat() can be called with or without new, and a new Intl.NumberFormat instance is returned in both cases. However, if the this value is an object that is instanceof Intl.NumberFormat (doesn't necessarily mean it's created via new Intl.NumberFormat; just that it has Intl.NumberFormat.prototype in its prototype chain), then the value of this is returned instead, with the newly created Intl.NumberFormat object hidden in a [Symbol(IntlLegacyConstructedSymbol)] property (a unique symbol that's reused between instances).
jsconst formatter = Intl.NumberFormat.call(
  { __proto__: Intl.NumberFormat.prototype },
  "en-US",
  { notation: "scientific" },
);
console.log(Object.getOwnPropertyDescriptors(formatter));
// {
//   [Symbol(IntlLegacyConstructedSymbol)]: {
//     value: NumberFormat [Intl.NumberFormat] {},
//     writable: false,
//     enumerable: false,
//     configurable: false
//   }
// }

Note that there's only one actual Intl.NumberFormat instance here: the one hidden in [Symbol(IntlLegacyConstructedSymbol)]. Calling the format() and resolvedOptions() methods on formatter would correctly use the options stored in that instance, but calling all other methods (e.g., formatRange()) would fail with "TypeError: formatRange method called on incompatible Object", because those methods don't consult the hidden instance's options.
This behavior, called ChainNumberFormat, does not happen when Intl.NumberFormat() is called without new but with this set to anything else that's not an instanceof Intl.NumberFormat. If you call it directly as Intl.NumberFormat(), the this value is Intl, and a new Intl.NumberFormat instance is created normally.Exceptions
RangeError

Thrown in one of the following cases:

A property that takes enumerated values (such as style, units, currency, and so on) is set to an invalid value.
Both maximumFractionDigits and minimumFractionDigits are set, and they are set to different values.
Note that depending on various formatting options, these properties can have default values.
It is therefore possible to get this error even if you only set one of the properties.


TypeError

Thrown if the options.style property is set to "unit" or "currency", and no value has been set for the corresponding property options.unit or options.currency.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst amount = 3500;

console.log(new Intl.NumberFormat().format(amount));
// '3,500' if in US English locale
Decimal and percent formattingjsconst amount = 3500;

new Intl.NumberFormat("en-US", {
  style: "decimal",
}).format(amount); // '3,500'
new Intl.NumberFormat("en-US", {
  style: "percent",
}).format(amount); // '350,000%'
Unit formattingIf the style is 'unit', a unit property must be provided.
Optionally, unitDisplay controls the unit formatting.
jsconst amount = 3500;

new Intl.NumberFormat("en-US", {
  style: "unit",
  unit: "liter",
}).format(amount); // '3,500 L'

new Intl.NumberFormat("en-US", {
  style: "unit",
  unit: "liter",
  unitDisplay: "long",
}).format(amount); // '3,500 liters'
Currency formattingIf the style is 'currency', a currency property
must be provided. Optionally, currencyDisplay and
currencySign control the unit formatting.
jsconst amount = -3500;
new Intl.NumberFormat("en-US", {
  style: "currency",
  currency: "USD",
}).format(amount); // '-$3,500.00'

new Intl.NumberFormat("bn", {
  style: "currency",
  currency: "USD",
  currencyDisplay: "name",
}).format(amount); // '-3,500.00 US dollars'

new Intl.NumberFormat("bn", {
  style: "currency",
  currency: "USD",
  currencySign: "accounting",
}).format(amount); // '($3,500.00)'
Scientific, engineering or compact notationsScientific and compact notation are represented by the notation option and can be formatted like this:
jsnew Intl.NumberFormat("en-US", {
  notation: "scientific",
}).format(987654321);
// 9.877E8

new Intl.NumberFormat("pt-PT", {
  notation: "scientific",
}).format(987654321);
// 9,877E8

new Intl.NumberFormat("en-GB", {
  notation: "engineering",
}).format(987654321);
// 987.654E6

new Intl.NumberFormat("de", {
  notation: "engineering",
}).format(987654321);
// 987,654E6

new Intl.NumberFormat("zh-CN", {
  notation: "compact",
}).format(987654321);
// 9.9亿

new Intl.NumberFormat("fr", {
  notation: "compact",
  compactDisplay: "long",
}).format(987654321);
// 988 millions

new Intl.NumberFormat("en-GB", {
  notation: "compact",
  compactDisplay: "short",
}).format(987654321);
// 988M
Displaying signsDisplay a sign for positive and negative numbers, but not zero:
jsnew Intl.NumberFormat("en-US", {
  style: "percent",
  signDisplay: "exceptZero",
}).format(0.55);
// '+55%'

Note that when the currency sign is "accounting", parentheses might be used instead of a minus sign:
jsnew Intl.NumberFormat("bn", {
  style: "currency",
  currency: "USD",
  currencySign: "accounting",
  signDisplay: "always",
}).format(-3500);
// '($3,500.00)'
FractionDigits, SignificantDigits and IntegerDigitsYou can specify the minimum or maximum number of fractional, integer or significant digits to display when formatting a number.

Note:
If both significant and fractional digit limits are specified, then the actual formatting depends on the roundingPriority.

Using FractionDigits and IntegerDigits
The integer and fraction digit properties indicate the number of digits to display before and after the decimal point, respectively.
If the value to display has fewer integer digits than specified, it will be left-padded with zeros to the expected number.
If it has fewer fractional digits, it will be right-padded with zeros.
Both cases are shown below:
js// Formatting adds zeros to display minimum integers and fractions
console.log(
  new Intl.NumberFormat("en", {
    minimumIntegerDigits: 3,
    minimumFractionDigits: 4,
  }).format(4.33),
);
// "004.3300"

If a value has more fractional digits than the specified maximum number, it will be rounded.
The way that it is rounded depends on the roundingMode property (more details are provided in the rounding modes section).
Below the value is rounded from five fractional digits (4.33145) to two (4.33):
js// Display value shortened to maximum number of digits
console.log(
  new Intl.NumberFormat("en", {
    maximumFractionDigits: 2,
  }).format(4.33145),
);
// "4.33"

The minimum fractional digits have no effect if the value already has more than 2 fractional digits:
js// Minimum fractions have no effect if value is higher precision.
console.log(
  new Intl.NumberFormat("en", {
    minimumFractionDigits: 2,
  }).format(4.33145),
);
// "4.331"


Warning:
Watch out for default values as they may affect formatting even if not specified in your code.
The default maximum digit value is 3 for plain values, 2 for currency, and may have different values for other predefined types.

The formatted value above is rounded to 3 digits, even though we didn't specify the maximum digits!
This is because a default value of maximumFractionDigits is set when we specify minimumFractionDigits, and visa versa. The default values of maximumFractionDigits and minimumFractionDigits are 3 and 0, respectively.
You can use resolvedOptions() to inspect the formatter.
jsconsole.log(
  new Intl.NumberFormat("en", {
    maximumFractionDigits: 2,
  }).resolvedOptions(),
);
// {
//   …
//   minimumIntegerDigits: 1,
//   minimumFractionDigits: 0,
//   maximumFractionDigits: 2,
//   …
// }

console.log(
  new Intl.NumberFormat("en", {
    minimumFractionDigits: 2,
  }).resolvedOptions(),
);
// {
//   …
//   minimumIntegerDigits: 1,
//   minimumFractionDigits: 2,
//   maximumFractionDigits: 3,
//   …
// }

Using SignificantDigits
The number of significant digits is the total number of digits including both integer and fractional parts.
The maximumSignificantDigits is used to indicate the total number of digits from the original value to display.
The examples below show how this works.
Note in particular the last case: only the first digit is retained and the others are discarded/set to zero.
js// Display 5 significant digits
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 5,
  }).format(54.33145),
);
// "54.331"

// Max 2 significant digits
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(54.33145),
);
// "54"

// Max 1 significant digits
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 1,
  }).format(54.33145),
);
// "50"

The minimumSignificantDigits ensures that at least the specified number of digits are displayed, adding zeros to the end of the value if needed.
js// Minimum 10 significant digits
console.log(
  new Intl.NumberFormat("en", {
    minimumSignificantDigits: 10,
  }).format(54.33145),
);
// "54.33145000"


Warning:
Watch out for default values as they may affect formatting.
If only one SignificantDigits property is used, then its counterpart will automatically be applied with the default value.
The default maximum and minimum significant digit values are 21 and 1, respectively.

Specifying significant and fractional digits at the same time
The fraction digits (minimumFractionDigits/maximumFractionDigits) and significant digits (minimumSignificantDigits/maximumSignificantDigits) are both ways of controlling how many fractional and leading digits should be formatted.
If both are used at the same time, it is possible for them to conflict.
These conflicts are resolved using the roundingPriority property.
By default, this has a value of "auto", which means that if either minimumSignificantDigits or maximumSignificantDigits is specified, the fractional and integer digit properties will be ignored.
For example, the code below formats the value of 4.33145 with maximumFractionDigits: 3, and then maximumSignificantDigits: 2, and then both.
The value with both is the one set with maximumSignificantDigits.
jsconsole.log(
  new Intl.NumberFormat("en", {
    maximumFractionDigits: 3,
  }).format(4.33145),
);
// "4.331"
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(4.33145),
);
// "4.3"
console.log(
  new Intl.NumberFormat("en", {
    maximumFractionDigits: 3,
    maximumSignificantDigits: 2,
  }).format(4.33145),
);
// "4.3"

Using resolvedOptions() to inspect the formatter, we can see that the returned object does not include maximumFractionDigits when maximumSignificantDigits or minimumSignificantDigits are specified.
jsconsole.log(
  new Intl.NumberFormat("en", {
    maximumFractionDigits: 3,
    maximumSignificantDigits: 2,
  }).resolvedOptions(),
);
// {
//   …
//   minimumIntegerDigits: 1,
//   minimumSignificantDigits: 1,
//   maximumSignificantDigits: 2,
//   …
// }
console.log(
  new Intl.NumberFormat("en", {
    maximumFractionDigits: 3,
    minimumSignificantDigits: 2,
  }).resolvedOptions(),
);
// {
//   …
//   minimumIntegerDigits: 1,
//   minimumSignificantDigits: 2,
//   maximumSignificantDigits: 21,
//   …
// }

In addition to "auto", you can resolve conflicts by specifying roundingPriority as "morePrecision" or "lessPrecision".
The formatter calculates the precision using the values of maximumSignificantDigits and maximumFractionDigits.
The code below shows the format being selected for the three different rounding priorities:
jsconst maxFracNF = new Intl.NumberFormat("en", {
  maximumFractionDigits: 3,
});
console.log(`maximumFractionDigits:3 - ${maxFracNF.format(1.23456)}`);
// "maximumFractionDigits:2 - 1.235"

const maxSigNS = new Intl.NumberFormat("en", {
  maximumSignificantDigits: 3,
});
console.log(`maximumSignificantDigits:3 - ${maxSigNS.format(1.23456)}`);
// "maximumSignificantDigits:3 - 1.23"

const bothAuto = new Intl.NumberFormat("en", {
  maximumSignificantDigits: 3,
  maximumFractionDigits: 3,
});
console.log(`auto - ${bothAuto.format(1.23456)}`);
// "auto - 1.23"

const bothLess = new Intl.NumberFormat("en", {
  roundingPriority: "lessPrecision",
  maximumSignificantDigits: 3,
  maximumFractionDigits: 3,
});
console.log(`lessPrecision - ${bothLess.format(1.23456)}`);
// "lessPrecision - 1.23"

const bothMore = new Intl.NumberFormat("en", {
  roundingPriority: "morePrecision",
  maximumSignificantDigits: 3,
  maximumFractionDigits: 3,
});
console.log(`morePrecision - ${bothMore.format(1.23456)}`);
// "morePrecision - 1.235"

Note that the algorithm can behave in an unintuitive way if a minimum value is specified without a maximum value.
The example below formats the value 1 specifying minimumFractionDigits: 2 (formatting to 1.00) and minimumSignificantDigits: 2 (formatting to 1.0).
Since 1.00 has more digits than 1.0, this should be the result when prioritizing morePrecision, but in fact the opposite is true:
jsconst bothLess = new Intl.NumberFormat("en", {
  roundingPriority: "lessPrecision",
  minimumFractionDigits: 2,
  minimumSignificantDigits: 2,
});
console.log(`lessPrecision - ${bothLess.format(1)}`);
// "lessPrecision - 1.00"

const bothMore = new Intl.NumberFormat("en", {
  roundingPriority: "morePrecision",
  minimumFractionDigits: 2,
  minimumSignificantDigits: 2,
});
console.log(`morePrecision - ${bothMore.format(1)}`);
// "morePrecision - 1.0"

The reason for this is that only the "maximum precision" values are used for the calculation, and the default value of maximumSignificantDigits is much higher than maximumFractionDigits.

Note:
The working group have proposed a modification of the algorithm where the formatter should evaluate the result of using the specified fractional and significant digits independently (taking account of both minimum and maximum values).
It will then select the option that displays more fractional digits if morePrecision is set, and fewer if lessPrecision is set.
This will result in more intuitive behavior for this case.
Rounding modesIf a value has more fractional digits than allowed by the constructor options, the formatted value will be rounded to the specified number of fractional digits.
The way in which the value is rounded depends on the roundingMode property.
Number formatters use halfExpand rounding by default, which rounds values "away from zero" at the half-increment (in other words, the magnitude of the value is rounded up).
For a positive number, if the fractional digits to be removed are closer to the next increment (or on the half way point) then the remaining fractional digits will be rounded up, otherwise they are rounded down.
This is shown below: 2.23 rounded to two significant digits is truncated to 2.2 because 2.23 is less than the half increment 2.25, while values of 2.25 and greater are rounded up to 2.3:
js// Value below half-increment: round down.
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(2.23),
);
// "2.2"

// Value on or above half-increment: round up.
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(2.25),
);
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(2.28),
);
// "2.3"
// "2.3"

A negative number on or below the half-increment point is also rounded away from zero (becomes more negative):
js// Value below half-increment: round down.
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(-2.23),
);
// "-2.2"

// Value on or above half-increment: round up.
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(-2.25),
);
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(-2.28),
);
// "-2.3"
// "-2.3"

The table below show the effect of different rounding modes for positive and negative values that are on and around the half-increment.



rounding mode
2.23
2.25
2.28
-2.23
-2.25
-2.28




ceil
2.3
2.3
2.3
-2.2
-2.2
-2.2


floor
2.2
2.2
2.2
-2.3
-2.3
-2.3


expand
2.3
2.3
2.3
-2.3
-2.3
-2.3


trunc
2.2
2.2
2.2
-2.2
-2.2
-2.2


halfCeil
2.2
2.3
2.3
-2.2
-2.2
-2.3


halfFloor
2.2
2.2
2.3
-2.2
-2.3
-2.3


halfExpand
2.2
2.3
2.3
-2.2
-2.3
-2.3


halfTrunc
2.2
2.2
2.3
-2.2
-2.2
-2.3


halfEven
2.2
2.2
2.3
-2.2
-2.2
-2.3



When using halfEven, its behavior also depends on the parity (odd or even) of the last digit of the rounded number. For example, the behavior of halfEven in the table above is the same as halfTrunc, because the magnitudes of all numbers are between a smaller "even" number (2.2) and a larger "odd" number (2.3). If the numbers are between ±2.3 and ±2.4, halfEven will behave like halfExpand instead. This behavior avoids consistently under- or over-estimating half-increments in a large data sample.Using roundingIncrementSometimes we want to round the remaining fractional digits to some other increment than the next integer.
For example, currencies for which the smallest coin is 5 cents might want to round the value to increments of 5, reflecting amounts that can actually be paid in cash.
This kind of rounding can be achieved with the roundingIncrement property.
For example, if maximumFractionDigits is 2 and roundingIncrement is 5, then the number is rounded to the nearest 0.05:
jsconst nf = new Intl.NumberFormat("en-US", {
  style: "currency",
  currency: "USD",
  maximumFractionDigits: 2,
  roundingIncrement: 5,
});

console.log(nf.format(11.29)); // "$11.30"
console.log(nf.format(11.25)); // "$11.25"
console.log(nf.format(11.22)); // "$11.20"

This particular pattern is referred to as "nickel rounding", where nickel is the colloquial name for a USA 5 cent coin.
To round to the nearest 10 cents ("dime rounding"), you could change roundingIncrement to 10.
jsconst nf = new Intl.NumberFormat("en-US", {
  style: "currency",
  currency: "USD",
  maximumFractionDigits: 2,
  roundingIncrement: 10,
});

console.log(nf.format(11.29)); // "$11.30"
console.log(nf.format(11.25)); // "$11.30"
console.log(nf.format(11.22)); // "$11.20"

You can also use roundingMode to change the rounding algorithm.
The example below shows how halfCeil rounding can be used to round the value "less positive" below the half-rounding increment and "more positive" if above or on the half-increment.
The incremented digit is "0.05" so the half-increment is at .025 (below, this is shown at 11.225).
jsconst nf = new Intl.NumberFormat("en-US", {
  style: "currency",
  currency: "USD",
  maximumFractionDigits: 2,
  roundingIncrement: 5,
  roundingMode: "halfCeil",
});

console.log(nf.format(11.21)); // "$11.20"
console.log(nf.format(11.22)); // "$11.20"
console.log(nf.format(11.224)); // "$11.20"
console.log(nf.format(11.225)); // "$11.25"
console.log(nf.format(11.23)); // "$11.25"

If you need to change the number of digits, remember that minimumFractionDigits and maximumFractionDigits must both be set to the same value, or a RangeError is thrown.
roundingIncrement cannot be mixed with significant-digits rounding or any setting of roundingPriority other than auto.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # sec-intl-numberformat-constructorBrowser compatibilitySee also
Intl.NumberFormat
Intl.supportedValuesOf()
Intl\n\nIntl.NumberFormat() constructorBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat() constructor creates Intl.NumberFormat objects.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Syntaxjsnew Intl.NumberFormat()
new Intl.NumberFormat(locales)
new Intl.NumberFormat(locales, options)

Intl.NumberFormat()
Intl.NumberFormat(locales)
Intl.NumberFormat(locales, options)


Note: Intl.NumberFormat() can be called with or without new. Both create a new Intl.NumberFormat instance. However, there's a special behavior when it's called without new and the this value is another Intl.NumberFormat instance; see Return value.
Parameters
locales Optional

A string with a BCP 47 language tag or an Intl.Locale instance, or an array of such locale identifiers. The runtime's default locale is used when undefined is passed or when none of the specified locale identifiers is supported. For the general form and interpretation of the locales argument, see the parameter description on the Intl main page.
The following Unicode extension key is allowed:

nu

See numberingSystem.


This key can also be set with options (as listed below). When both are set, the options property takes precedence.

options Optional

An object. For ease of reading, the property list is broken into sections based on their purposes, including locale options, style options, digit options, and other options.


Locale options

localeMatcher

The locale matching algorithm to use. Possible values are "lookup" and "best fit"; the default is "best fit".
For information about this option, see Locale identification and negotiation.

numberingSystem

The numbering system to use for number formatting, such as "arab", "hans", "mathsans", and so on. For a list of supported numbering system types, see Intl.supportedValuesOf(). This option can also be set through the nu Unicode extension key; if both are provided, this options property takes precedence.


Style options
Depending on the style used, some of them may be ignored, and others may be required:

style

The formatting style to use.

"decimal" (default)

For plain number formatting.

"currency"

For currency formatting.

"percent"

For percent formatting.

"unit"

For unit formatting.



currency

The currency to use in currency formatting. Possible values are the ISO 4217 currency codes, such as "USD" for the US dollar, "EUR" for the euro, or "CNY" for the Chinese RMB — see Intl.supportedValuesOf(). There is no default value; if the style is "currency", the currency property must be provided. It is normalized to uppercase.

currencyDisplay

How to display the currency in currency formatting.

"code"

Use the ISO currency code.

"symbol" (default)

Use a localized currency symbol such as €.

"narrowSymbol"

Use a narrow format symbol ("$100" rather than "US$100").

"name"

Use a localized currency name such as "dollar".



currencySign

In many locales, accounting format means to wrap the number with parentheses instead of appending a minus sign. Possible values are "standard" and "accounting"; the default is "standard".

unit

The unit to use in unit formatting, Possible values are listed in Intl.supportedValuesOf(). Pairs of simple units can be concatenated with "-per-" to make a compound unit. There is no default value; if the style is "unit", the unit property must be provided.

unitDisplay

The unit formatting style to use in unit formatting. Possible values are:

"short" (default)

E.g., 16 l.

"narrow"

E.g., 16l.

"long"

E.g., 16 litres.




Digit options
The following properties are also supported by Intl.PluralRules.

minimumIntegerDigits

The minimum number of integer digits to use. A value with a smaller number of integer digits than this number will be left-padded with zeros (to the specified length) when formatted. Possible values are from 1 to 21; the default is 1.

minimumFractionDigits

The minimum number of fraction digits to use. Possible values are from 0 to 100; the default for plain number and percent formatting is 0; the default for currency formatting is the number of minor unit digits provided by the ISO 4217 currency code list (2 if the list doesn't provide that information). See SignificantDigits/FractionDigits default values for when this default gets applied.

maximumFractionDigits

The maximum number of fraction digits to use. Possible values are from 0 to 100; the default for plain number formatting is the larger of minimumFractionDigits and 3; the default for currency formatting is the larger of minimumFractionDigits and the number of minor unit digits provided by the ISO 4217 currency code list (2 if the list doesn't provide that information); the default for percent formatting is the larger of minimumFractionDigits and 0. See SignificantDigits/FractionDigits default values for when this default gets applied.

minimumSignificantDigits

The minimum number of significant digits to use. Possible values are from 1 to 21; the default is 1. See SignificantDigits/FractionDigits default values for when this default gets applied.

maximumSignificantDigits

The maximum number of significant digits to use. Possible values are from 1 to 21; the default is 21. See SignificantDigits/FractionDigits default values for when this default gets applied.

roundingPriority

Specify how rounding conflicts will be resolved if both "FractionDigits" (minimumFractionDigits/maximumFractionDigits) and "SignificantDigits" (minimumSignificantDigits/maximumSignificantDigits) are specified.
Possible values are:

"auto" (default)

The result from the significant digits property is used.

"morePrecision"

The result from the property that results in more precision is used.

"lessPrecision"

The result from the property that results in less precision is used.


The value "auto" is normalized to "morePrecision" if notation is "compact" and none of the four "FractionDigits"/"SignificantDigits" options are set.
Note that for values other than auto the result with more precision is calculated from the maximumSignificantDigits and maximumFractionDigits (minimum fractional and significant digit settings are ignored).

roundingIncrement

Indicates the increment at which rounding should take place relative to the calculated rounding magnitude. Possible values are 1, 2, 5, 10, 20, 25, 50, 100, 200, 250, 500, 1000, 2000, 2500, and 5000; the default is 1. It cannot be mixed with significant-digits rounding or any setting of roundingPriority other than auto.

roundingMode

How decimals should be rounded. Possible values are:

"ceil"

Round toward +∞. Positive values round up. Negative values round "more positive".

"floor"

Round toward -∞. Positive values round down. Negative values round "more negative".

"expand"

Round away from 0. The magnitude of the value is always increased by rounding. Positive values round up. Negative values round "more negative".

"trunc"

Round toward 0. This magnitude of the value is always reduced by rounding. Positive values round down. Negative values round "less negative".

"halfCeil"

Ties toward +∞. Values above the half-increment round like "ceil" (towards +∞), and below like "floor" (towards -∞). On the half-increment, values round like "ceil".

"halfFloor"

Ties toward -∞. Values above the half-increment round like "ceil" (towards +∞), and below like "floor" (towards -∞). On the half-increment, values round like "floor".

"halfExpand" (default)

Ties away from 0. Values above the half-increment round like "expand" (away from zero), and below like "trunc" (towards 0). On the half-increment, values round like "expand".

"halfTrunc"

Ties toward 0. Values above the half-increment round like "expand" (away from zero), and below like "trunc" (towards 0). On the half-increment, values round like "trunc".

"halfEven"

Ties towards the nearest even integer. Values above the half-increment round like "expand" (away from zero), and below like "trunc" (towards 0). On the half-increment values round towards the nearest even digit.


These options reflect the ICU user guide, where "expand" and "trunc" map to ICU "UP" and "DOWN", respectively.
The rounding modes example below demonstrates how each mode works.

trailingZeroDisplay

The strategy for displaying trailing zeros on whole numbers. Possible values are:

"auto" (default)

Keep trailing zeros according to minimumFractionDigits and minimumSignificantDigits.

"stripIfInteger"

Remove the fraction digits if they are all zero. This is the same as "auto" if any of the fraction digits is non-zero.




SignificantDigits/FractionDigits default values
For the four options above (the FractionDigits and SignificantDigits options), we mentioned their defaults; however, these defaults are not unconditionally applied. They are only applied when the property is actually going to be used, which depends on the roundingPriority and notation settings. Specifically:

If roundingPriority is not "auto", then all four options apply.
If roundingPriority is "auto" and at least one SignificantDigits option is set, then the SignificantDigits options apply and the FractionDigits options are ignored.
If roundingPriority is "auto", and either at least one FractionDigits option is set or notation is not "compact", then the FractionDigits options apply and the SignificantDigits options are ignored.
If roundingPriority is "auto", notation is "compact", and none of the four options are set, then they are set to { minimumFractionDigits: 0, maximumFractionDigits: 0, minimumSignificantDigits: 1, maximumSignificantDigits: 2 }, regardless of the defaults mentioned above, and roundingPriority is set to "morePrecision".

Other options

notation

The formatting that should be displayed for the number. Possible values are:

"standard" (default)

Plain number formatting.

"scientific"

Return the order-of-magnitude for formatted number.

"engineering"

Return the exponent of ten when divisible by three.

"compact"

String representing exponent; defaults to using the "short" form.



compactDisplay

Only used when notation is "compact". Possible values are "short" and "long"; the default is "short".

useGrouping

Whether to use grouping separators, such as thousands separators or thousand/lakh/crore separators.

"always"

Display grouping separators even if the locale prefers otherwise.

"auto"

Display grouping separators based on the locale preference, which may also be dependent on the currency.

"min2"

Display grouping separators when there are at least 2 digits in a group.

true

Same as "always".

false

Display no grouping separators.


The default is "min2" if notation is "compact", and "auto" otherwise. The string values "true" and "false" are accepted, but are always converted to the default value.

signDisplay

When to display the sign for the number. Possible values are:

"auto" (default)

Sign display for negative numbers only, including negative zero.

"always"

Always display sign.

"exceptZero"

Sign display for positive and negative numbers, but not zero.

"negative"

Sign display for negative numbers only, excluding negative zero.

"never"

Never display sign.



Return valueA new Intl.NumberFormat object.

Note:
The text below describes behavior that is marked by the specification as "optional". It may not work in all environments. Check the browser compatibility table.

Normally, Intl.NumberFormat() can be called with or without new, and a new Intl.NumberFormat instance is returned in both cases. However, if the this value is an object that is instanceof Intl.NumberFormat (doesn't necessarily mean it's created via new Intl.NumberFormat; just that it has Intl.NumberFormat.prototype in its prototype chain), then the value of this is returned instead, with the newly created Intl.NumberFormat object hidden in a [Symbol(IntlLegacyConstructedSymbol)] property (a unique symbol that's reused between instances).
jsconst formatter = Intl.NumberFormat.call(
  { __proto__: Intl.NumberFormat.prototype },
  "en-US",
  { notation: "scientific" },
);
console.log(Object.getOwnPropertyDescriptors(formatter));
// {
//   [Symbol(IntlLegacyConstructedSymbol)]: {
//     value: NumberFormat [Intl.NumberFormat] {},
//     writable: false,
//     enumerable: false,
//     configurable: false
//   }
// }

Note that there's only one actual Intl.NumberFormat instance here: the one hidden in [Symbol(IntlLegacyConstructedSymbol)]. Calling the format() and resolvedOptions() methods on formatter would correctly use the options stored in that instance, but calling all other methods (e.g., formatRange()) would fail with "TypeError: formatRange method called on incompatible Object", because those methods don't consult the hidden instance's options.
This behavior, called ChainNumberFormat, does not happen when Intl.NumberFormat() is called without new but with this set to anything else that's not an instanceof Intl.NumberFormat. If you call it directly as Intl.NumberFormat(), the this value is Intl, and a new Intl.NumberFormat instance is created normally.Exceptions
RangeError

Thrown in one of the following cases:

A property that takes enumerated values (such as style, units, currency, and so on) is set to an invalid value.
Both maximumFractionDigits and minimumFractionDigits are set, and they are set to different values.
Note that depending on various formatting options, these properties can have default values.
It is therefore possible to get this error even if you only set one of the properties.


TypeError

Thrown if the options.style property is set to "unit" or "currency", and no value has been set for the corresponding property options.unit or options.currency.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst amount = 3500;

console.log(new Intl.NumberFormat().format(amount));
// '3,500' if in US English locale
Decimal and percent formattingjsconst amount = 3500;

new Intl.NumberFormat("en-US", {
  style: "decimal",
}).format(amount); // '3,500'
new Intl.NumberFormat("en-US", {
  style: "percent",
}).format(amount); // '350,000%'
Unit formattingIf the style is 'unit', a unit property must be provided.
Optionally, unitDisplay controls the unit formatting.
jsconst amount = 3500;

new Intl.NumberFormat("en-US", {
  style: "unit",
  unit: "liter",
}).format(amount); // '3,500 L'

new Intl.NumberFormat("en-US", {
  style: "unit",
  unit: "liter",
  unitDisplay: "long",
}).format(amount); // '3,500 liters'
Currency formattingIf the style is 'currency', a currency property
must be provided. Optionally, currencyDisplay and
currencySign control the unit formatting.
jsconst amount = -3500;
new Intl.NumberFormat("en-US", {
  style: "currency",
  currency: "USD",
}).format(amount); // '-$3,500.00'

new Intl.NumberFormat("bn", {
  style: "currency",
  currency: "USD",
  currencyDisplay: "name",
}).format(amount); // '-3,500.00 US dollars'

new Intl.NumberFormat("bn", {
  style: "currency",
  currency: "USD",
  currencySign: "accounting",
}).format(amount); // '($3,500.00)'
Scientific, engineering or compact notationsScientific and compact notation are represented by the notation option and can be formatted like this:
jsnew Intl.NumberFormat("en-US", {
  notation: "scientific",
}).format(987654321);
// 9.877E8

new Intl.NumberFormat("pt-PT", {
  notation: "scientific",
}).format(987654321);
// 9,877E8

new Intl.NumberFormat("en-GB", {
  notation: "engineering",
}).format(987654321);
// 987.654E6

new Intl.NumberFormat("de", {
  notation: "engineering",
}).format(987654321);
// 987,654E6

new Intl.NumberFormat("zh-CN", {
  notation: "compact",
}).format(987654321);
// 9.9亿

new Intl.NumberFormat("fr", {
  notation: "compact",
  compactDisplay: "long",
}).format(987654321);
// 988 millions

new Intl.NumberFormat("en-GB", {
  notation: "compact",
  compactDisplay: "short",
}).format(987654321);
// 988M
Displaying signsDisplay a sign for positive and negative numbers, but not zero:
jsnew Intl.NumberFormat("en-US", {
  style: "percent",
  signDisplay: "exceptZero",
}).format(0.55);
// '+55%'

Note that when the currency sign is "accounting", parentheses might be used instead of a minus sign:
jsnew Intl.NumberFormat("bn", {
  style: "currency",
  currency: "USD",
  currencySign: "accounting",
  signDisplay: "always",
}).format(-3500);
// '($3,500.00)'
FractionDigits, SignificantDigits and IntegerDigitsYou can specify the minimum or maximum number of fractional, integer or significant digits to display when formatting a number.

Note:
If both significant and fractional digit limits are specified, then the actual formatting depends on the roundingPriority.

Using FractionDigits and IntegerDigits
The integer and fraction digit properties indicate the number of digits to display before and after the decimal point, respectively.
If the value to display has fewer integer digits than specified, it will be left-padded with zeros to the expected number.
If it has fewer fractional digits, it will be right-padded with zeros.
Both cases are shown below:
js// Formatting adds zeros to display minimum integers and fractions
console.log(
  new Intl.NumberFormat("en", {
    minimumIntegerDigits: 3,
    minimumFractionDigits: 4,
  }).format(4.33),
);
// "004.3300"

If a value has more fractional digits than the specified maximum number, it will be rounded.
The way that it is rounded depends on the roundingMode property (more details are provided in the rounding modes section).
Below the value is rounded from five fractional digits (4.33145) to two (4.33):
js// Display value shortened to maximum number of digits
console.log(
  new Intl.NumberFormat("en", {
    maximumFractionDigits: 2,
  }).format(4.33145),
);
// "4.33"

The minimum fractional digits have no effect if the value already has more than 2 fractional digits:
js// Minimum fractions have no effect if value is higher precision.
console.log(
  new Intl.NumberFormat("en", {
    minimumFractionDigits: 2,
  }).format(4.33145),
);
// "4.331"


Warning:
Watch out for default values as they may affect formatting even if not specified in your code.
The default maximum digit value is 3 for plain values, 2 for currency, and may have different values for other predefined types.

The formatted value above is rounded to 3 digits, even though we didn't specify the maximum digits!
This is because a default value of maximumFractionDigits is set when we specify minimumFractionDigits, and visa versa. The default values of maximumFractionDigits and minimumFractionDigits are 3 and 0, respectively.
You can use resolvedOptions() to inspect the formatter.
jsconsole.log(
  new Intl.NumberFormat("en", {
    maximumFractionDigits: 2,
  }).resolvedOptions(),
);
// {
//   …
//   minimumIntegerDigits: 1,
//   minimumFractionDigits: 0,
//   maximumFractionDigits: 2,
//   …
// }

console.log(
  new Intl.NumberFormat("en", {
    minimumFractionDigits: 2,
  }).resolvedOptions(),
);
// {
//   …
//   minimumIntegerDigits: 1,
//   minimumFractionDigits: 2,
//   maximumFractionDigits: 3,
//   …
// }

Using SignificantDigits
The number of significant digits is the total number of digits including both integer and fractional parts.
The maximumSignificantDigits is used to indicate the total number of digits from the original value to display.
The examples below show how this works.
Note in particular the last case: only the first digit is retained and the others are discarded/set to zero.
js// Display 5 significant digits
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 5,
  }).format(54.33145),
);
// "54.331"

// Max 2 significant digits
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(54.33145),
);
// "54"

// Max 1 significant digits
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 1,
  }).format(54.33145),
);
// "50"

The minimumSignificantDigits ensures that at least the specified number of digits are displayed, adding zeros to the end of the value if needed.
js// Minimum 10 significant digits
console.log(
  new Intl.NumberFormat("en", {
    minimumSignificantDigits: 10,
  }).format(54.33145),
);
// "54.33145000"


Warning:
Watch out for default values as they may affect formatting.
If only one SignificantDigits property is used, then its counterpart will automatically be applied with the default value.
The default maximum and minimum significant digit values are 21 and 1, respectively.

Specifying significant and fractional digits at the same time
The fraction digits (minimumFractionDigits/maximumFractionDigits) and significant digits (minimumSignificantDigits/maximumSignificantDigits) are both ways of controlling how many fractional and leading digits should be formatted.
If both are used at the same time, it is possible for them to conflict.
These conflicts are resolved using the roundingPriority property.
By default, this has a value of "auto", which means that if either minimumSignificantDigits or maximumSignificantDigits is specified, the fractional and integer digit properties will be ignored.
For example, the code below formats the value of 4.33145 with maximumFractionDigits: 3, and then maximumSignificantDigits: 2, and then both.
The value with both is the one set with maximumSignificantDigits.
jsconsole.log(
  new Intl.NumberFormat("en", {
    maximumFractionDigits: 3,
  }).format(4.33145),
);
// "4.331"
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(4.33145),
);
// "4.3"
console.log(
  new Intl.NumberFormat("en", {
    maximumFractionDigits: 3,
    maximumSignificantDigits: 2,
  }).format(4.33145),
);
// "4.3"

Using resolvedOptions() to inspect the formatter, we can see that the returned object does not include maximumFractionDigits when maximumSignificantDigits or minimumSignificantDigits are specified.
jsconsole.log(
  new Intl.NumberFormat("en", {
    maximumFractionDigits: 3,
    maximumSignificantDigits: 2,
  }).resolvedOptions(),
);
// {
//   …
//   minimumIntegerDigits: 1,
//   minimumSignificantDigits: 1,
//   maximumSignificantDigits: 2,
//   …
// }
console.log(
  new Intl.NumberFormat("en", {
    maximumFractionDigits: 3,
    minimumSignificantDigits: 2,
  }).resolvedOptions(),
);
// {
//   …
//   minimumIntegerDigits: 1,
//   minimumSignificantDigits: 2,
//   maximumSignificantDigits: 21,
//   …
// }

In addition to "auto", you can resolve conflicts by specifying roundingPriority as "morePrecision" or "lessPrecision".
The formatter calculates the precision using the values of maximumSignificantDigits and maximumFractionDigits.
The code below shows the format being selected for the three different rounding priorities:
jsconst maxFracNF = new Intl.NumberFormat("en", {
  maximumFractionDigits: 3,
});
console.log(`maximumFractionDigits:3 - ${maxFracNF.format(1.23456)}`);
// "maximumFractionDigits:2 - 1.235"

const maxSigNS = new Intl.NumberFormat("en", {
  maximumSignificantDigits: 3,
});
console.log(`maximumSignificantDigits:3 - ${maxSigNS.format(1.23456)}`);
// "maximumSignificantDigits:3 - 1.23"

const bothAuto = new Intl.NumberFormat("en", {
  maximumSignificantDigits: 3,
  maximumFractionDigits: 3,
});
console.log(`auto - ${bothAuto.format(1.23456)}`);
// "auto - 1.23"

const bothLess = new Intl.NumberFormat("en", {
  roundingPriority: "lessPrecision",
  maximumSignificantDigits: 3,
  maximumFractionDigits: 3,
});
console.log(`lessPrecision - ${bothLess.format(1.23456)}`);
// "lessPrecision - 1.23"

const bothMore = new Intl.NumberFormat("en", {
  roundingPriority: "morePrecision",
  maximumSignificantDigits: 3,
  maximumFractionDigits: 3,
});
console.log(`morePrecision - ${bothMore.format(1.23456)}`);
// "morePrecision - 1.235"

Note that the algorithm can behave in an unintuitive way if a minimum value is specified without a maximum value.
The example below formats the value 1 specifying minimumFractionDigits: 2 (formatting to 1.00) and minimumSignificantDigits: 2 (formatting to 1.0).
Since 1.00 has more digits than 1.0, this should be the result when prioritizing morePrecision, but in fact the opposite is true:
jsconst bothLess = new Intl.NumberFormat("en", {
  roundingPriority: "lessPrecision",
  minimumFractionDigits: 2,
  minimumSignificantDigits: 2,
});
console.log(`lessPrecision - ${bothLess.format(1)}`);
// "lessPrecision - 1.00"

const bothMore = new Intl.NumberFormat("en", {
  roundingPriority: "morePrecision",
  minimumFractionDigits: 2,
  minimumSignificantDigits: 2,
});
console.log(`morePrecision - ${bothMore.format(1)}`);
// "morePrecision - 1.0"

The reason for this is that only the "maximum precision" values are used for the calculation, and the default value of maximumSignificantDigits is much higher than maximumFractionDigits.

Note:
The working group have proposed a modification of the algorithm where the formatter should evaluate the result of using the specified fractional and significant digits independently (taking account of both minimum and maximum values).
It will then select the option that displays more fractional digits if morePrecision is set, and fewer if lessPrecision is set.
This will result in more intuitive behavior for this case.
Rounding modesIf a value has more fractional digits than allowed by the constructor options, the formatted value will be rounded to the specified number of fractional digits.
The way in which the value is rounded depends on the roundingMode property.
Number formatters use halfExpand rounding by default, which rounds values "away from zero" at the half-increment (in other words, the magnitude of the value is rounded up).
For a positive number, if the fractional digits to be removed are closer to the next increment (or on the half way point) then the remaining fractional digits will be rounded up, otherwise they are rounded down.
This is shown below: 2.23 rounded to two significant digits is truncated to 2.2 because 2.23 is less than the half increment 2.25, while values of 2.25 and greater are rounded up to 2.3:
js// Value below half-increment: round down.
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(2.23),
);
// "2.2"

// Value on or above half-increment: round up.
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(2.25),
);
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(2.28),
);
// "2.3"
// "2.3"

A negative number on or below the half-increment point is also rounded away from zero (becomes more negative):
js// Value below half-increment: round down.
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(-2.23),
);
// "-2.2"

// Value on or above half-increment: round up.
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(-2.25),
);
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(-2.28),
);
// "-2.3"
// "-2.3"

The table below show the effect of different rounding modes for positive and negative values that are on and around the half-increment.



rounding mode
2.23
2.25
2.28
-2.23
-2.25
-2.28




ceil
2.3
2.3
2.3
-2.2
-2.2
-2.2


floor
2.2
2.2
2.2
-2.3
-2.3
-2.3


expand
2.3
2.3
2.3
-2.3
-2.3
-2.3


trunc
2.2
2.2
2.2
-2.2
-2.2
-2.2


halfCeil
2.2
2.3
2.3
-2.2
-2.2
-2.3


halfFloor
2.2
2.2
2.3
-2.2
-2.3
-2.3


halfExpand
2.2
2.3
2.3
-2.2
-2.3
-2.3


halfTrunc
2.2
2.2
2.3
-2.2
-2.2
-2.3


halfEven
2.2
2.2
2.3
-2.2
-2.2
-2.3



When using halfEven, its behavior also depends on the parity (odd or even) of the last digit of the rounded number. For example, the behavior of halfEven in the table above is the same as halfTrunc, because the magnitudes of all numbers are between a smaller "even" number (2.2) and a larger "odd" number (2.3). If the numbers are between ±2.3 and ±2.4, halfEven will behave like halfExpand instead. This behavior avoids consistently under- or over-estimating half-increments in a large data sample.Using roundingIncrementSometimes we want to round the remaining fractional digits to some other increment than the next integer.
For example, currencies for which the smallest coin is 5 cents might want to round the value to increments of 5, reflecting amounts that can actually be paid in cash.
This kind of rounding can be achieved with the roundingIncrement property.
For example, if maximumFractionDigits is 2 and roundingIncrement is 5, then the number is rounded to the nearest 0.05:
jsconst nf = new Intl.NumberFormat("en-US", {
  style: "currency",
  currency: "USD",
  maximumFractionDigits: 2,
  roundingIncrement: 5,
});

console.log(nf.format(11.29)); // "$11.30"
console.log(nf.format(11.25)); // "$11.25"
console.log(nf.format(11.22)); // "$11.20"

This particular pattern is referred to as "nickel rounding", where nickel is the colloquial name for a USA 5 cent coin.
To round to the nearest 10 cents ("dime rounding"), you could change roundingIncrement to 10.
jsconst nf = new Intl.NumberFormat("en-US", {
  style: "currency",
  currency: "USD",
  maximumFractionDigits: 2,
  roundingIncrement: 10,
});

console.log(nf.format(11.29)); // "$11.30"
console.log(nf.format(11.25)); // "$11.30"
console.log(nf.format(11.22)); // "$11.20"

You can also use roundingMode to change the rounding algorithm.
The example below shows how halfCeil rounding can be used to round the value "less positive" below the half-rounding increment and "more positive" if above or on the half-increment.
The incremented digit is "0.05" so the half-increment is at .025 (below, this is shown at 11.225).
jsconst nf = new Intl.NumberFormat("en-US", {
  style: "currency",
  currency: "USD",
  maximumFractionDigits: 2,
  roundingIncrement: 5,
  roundingMode: "halfCeil",
});

console.log(nf.format(11.21)); // "$11.20"
console.log(nf.format(11.22)); // "$11.20"
console.log(nf.format(11.224)); // "$11.20"
console.log(nf.format(11.225)); // "$11.25"
console.log(nf.format(11.23)); // "$11.25"

If you need to change the number of digits, remember that minimumFractionDigits and maximumFractionDigits must both be set to the same value, or a RangeError is thrown.
roundingIncrement cannot be mixed with significant-digits rounding or any setting of roundingPriority other than auto.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # sec-intl-numberformat-constructorBrowser compatibilitySee also
Intl.NumberFormat
Intl.supportedValuesOf()
Intl
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 4, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIntl.NumberFormat() constructorBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl.NumberFormat() constructor creates Intl.NumberFormat objects.Try it
const number = 123456.789;

console.log(
  new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format(
    number,
  ),
);
// Expected output: "123.456,79 €"

// The Japanese yen doesn't use a minor unit
console.log(
  new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format(
    number,
  ),
);
// Expected output: "￥123,457"

// Limit to three significant digits
console.log(
  new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format(
    number,
  ),
);
// Expected output: "1,23,000"
Syntaxjsnew Intl.NumberFormat()
new Intl.NumberFormat(locales)
new Intl.NumberFormat(locales, options)

Intl.NumberFormat()
Intl.NumberFormat(locales)
Intl.NumberFormat(locales, options)


Note: Intl.NumberFormat() can be called with or without new. Both create a new Intl.NumberFormat instance. However, there's a special behavior when it's called without new and the this value is another Intl.NumberFormat instance; see Return value.
Parameters
locales Optional

A string with a BCP 47 language tag or an Intl.Locale instance, or an array of such locale identifiers. The runtime's default locale is used when undefined is passed or when none of the specified locale identifiers is supported. For the general form and interpretation of the locales argument, see the parameter description on the Intl main page.
The following Unicode extension key is allowed:

nu

See numberingSystem.


This key can also be set with options (as listed below). When both are set, the options property takes precedence.

options Optional

An object. For ease of reading, the property list is broken into sections based on their purposes, including locale options, style options, digit options, and other options.


Locale options

localeMatcher

The locale matching algorithm to use. Possible values are "lookup" and "best fit"; the default is "best fit".
For information about this option, see Locale identification and negotiation.

numberingSystem

The numbering system to use for number formatting, such as "arab", "hans", "mathsans", and so on. For a list of supported numbering system types, see Intl.supportedValuesOf(). This option can also be set through the nu Unicode extension key; if both are provided, this options property takes precedence.


Style options
Depending on the style used, some of them may be ignored, and others may be required:

style

The formatting style to use.

"decimal" (default)

For plain number formatting.

"currency"

For currency formatting.

"percent"

For percent formatting.

"unit"

For unit formatting.



currency

The currency to use in currency formatting. Possible values are the ISO 4217 currency codes, such as "USD" for the US dollar, "EUR" for the euro, or "CNY" for the Chinese RMB — see Intl.supportedValuesOf(). There is no default value; if the style is "currency", the currency property must be provided. It is normalized to uppercase.

currencyDisplay

How to display the currency in currency formatting.

"code"

Use the ISO currency code.

"symbol" (default)

Use a localized currency symbol such as €.

"narrowSymbol"

Use a narrow format symbol ("$100" rather than "US$100").

"name"

Use a localized currency name such as "dollar".



currencySign

In many locales, accounting format means to wrap the number with parentheses instead of appending a minus sign. Possible values are "standard" and "accounting"; the default is "standard".

unit

The unit to use in unit formatting, Possible values are listed in Intl.supportedValuesOf(). Pairs of simple units can be concatenated with "-per-" to make a compound unit. There is no default value; if the style is "unit", the unit property must be provided.

unitDisplay

The unit formatting style to use in unit formatting. Possible values are:

"short" (default)

E.g., 16 l.

"narrow"

E.g., 16l.

"long"

E.g., 16 litres.




Digit options
The following properties are also supported by Intl.PluralRules.

minimumIntegerDigits

The minimum number of integer digits to use. A value with a smaller number of integer digits than this number will be left-padded with zeros (to the specified length) when formatted. Possible values are from 1 to 21; the default is 1.

minimumFractionDigits

The minimum number of fraction digits to use. Possible values are from 0 to 100; the default for plain number and percent formatting is 0; the default for currency formatting is the number of minor unit digits provided by the ISO 4217 currency code list (2 if the list doesn't provide that information). See SignificantDigits/FractionDigits default values for when this default gets applied.

maximumFractionDigits

The maximum number of fraction digits to use. Possible values are from 0 to 100; the default for plain number formatting is the larger of minimumFractionDigits and 3; the default for currency formatting is the larger of minimumFractionDigits and the number of minor unit digits provided by the ISO 4217 currency code list (2 if the list doesn't provide that information); the default for percent formatting is the larger of minimumFractionDigits and 0. See SignificantDigits/FractionDigits default values for when this default gets applied.

minimumSignificantDigits

The minimum number of significant digits to use. Possible values are from 1 to 21; the default is 1. See SignificantDigits/FractionDigits default values for when this default gets applied.

maximumSignificantDigits

The maximum number of significant digits to use. Possible values are from 1 to 21; the default is 21. See SignificantDigits/FractionDigits default values for when this default gets applied.

roundingPriority

Specify how rounding conflicts will be resolved if both "FractionDigits" (minimumFractionDigits/maximumFractionDigits) and "SignificantDigits" (minimumSignificantDigits/maximumSignificantDigits) are specified.
Possible values are:

"auto" (default)

The result from the significant digits property is used.

"morePrecision"

The result from the property that results in more precision is used.

"lessPrecision"

The result from the property that results in less precision is used.


The value "auto" is normalized to "morePrecision" if notation is "compact" and none of the four "FractionDigits"/"SignificantDigits" options are set.
Note that for values other than auto the result with more precision is calculated from the maximumSignificantDigits and maximumFractionDigits (minimum fractional and significant digit settings are ignored).

roundingIncrement

Indicates the increment at which rounding should take place relative to the calculated rounding magnitude. Possible values are 1, 2, 5, 10, 20, 25, 50, 100, 200, 250, 500, 1000, 2000, 2500, and 5000; the default is 1. It cannot be mixed with significant-digits rounding or any setting of roundingPriority other than auto.

roundingMode

How decimals should be rounded. Possible values are:

"ceil"

Round toward +∞. Positive values round up. Negative values round "more positive".

"floor"

Round toward -∞. Positive values round down. Negative values round "more negative".

"expand"

Round away from 0. The magnitude of the value is always increased by rounding. Positive values round up. Negative values round "more negative".

"trunc"

Round toward 0. This magnitude of the value is always reduced by rounding. Positive values round down. Negative values round "less negative".

"halfCeil"

Ties toward +∞. Values above the half-increment round like "ceil" (towards +∞), and below like "floor" (towards -∞). On the half-increment, values round like "ceil".

"halfFloor"

Ties toward -∞. Values above the half-increment round like "ceil" (towards +∞), and below like "floor" (towards -∞). On the half-increment, values round like "floor".

"halfExpand" (default)

Ties away from 0. Values above the half-increment round like "expand" (away from zero), and below like "trunc" (towards 0). On the half-increment, values round like "expand".

"halfTrunc"

Ties toward 0. Values above the half-increment round like "expand" (away from zero), and below like "trunc" (towards 0). On the half-increment, values round like "trunc".

"halfEven"

Ties towards the nearest even integer. Values above the half-increment round like "expand" (away from zero), and below like "trunc" (towards 0). On the half-increment values round towards the nearest even digit.


These options reflect the ICU user guide, where "expand" and "trunc" map to ICU "UP" and "DOWN", respectively.
The rounding modes example below demonstrates how each mode works.

trailingZeroDisplay

The strategy for displaying trailing zeros on whole numbers. Possible values are:

"auto" (default)

Keep trailing zeros according to minimumFractionDigits and minimumSignificantDigits.

"stripIfInteger"

Remove the fraction digits if they are all zero. This is the same as "auto" if any of the fraction digits is non-zero.




SignificantDigits/FractionDigits default values
For the four options above (the FractionDigits and SignificantDigits options), we mentioned their defaults; however, these defaults are not unconditionally applied. They are only applied when the property is actually going to be used, which depends on the roundingPriority and notation settings. Specifically:

If roundingPriority is not "auto", then all four options apply.
If roundingPriority is "auto" and at least one SignificantDigits option is set, then the SignificantDigits options apply and the FractionDigits options are ignored.
If roundingPriority is "auto", and either at least one FractionDigits option is set or notation is not "compact", then the FractionDigits options apply and the SignificantDigits options are ignored.
If roundingPriority is "auto", notation is "compact", and none of the four options are set, then they are set to { minimumFractionDigits: 0, maximumFractionDigits: 0, minimumSignificantDigits: 1, maximumSignificantDigits: 2 }, regardless of the defaults mentioned above, and roundingPriority is set to "morePrecision".

Other options

notation

The formatting that should be displayed for the number. Possible values are:

"standard" (default)

Plain number formatting.

"scientific"

Return the order-of-magnitude for formatted number.

"engineering"

Return the exponent of ten when divisible by three.

"compact"

String representing exponent; defaults to using the "short" form.



compactDisplay

Only used when notation is "compact". Possible values are "short" and "long"; the default is "short".

useGrouping

Whether to use grouping separators, such as thousands separators or thousand/lakh/crore separators.

"always"

Display grouping separators even if the locale prefers otherwise.

"auto"

Display grouping separators based on the locale preference, which may also be dependent on the currency.

"min2"

Display grouping separators when there are at least 2 digits in a group.

true

Same as "always".

false

Display no grouping separators.


The default is "min2" if notation is "compact", and "auto" otherwise. The string values "true" and "false" are accepted, but are always converted to the default value.

signDisplay

When to display the sign for the number. Possible values are:

"auto" (default)

Sign display for negative numbers only, including negative zero.

"always"

Always display sign.

"exceptZero"

Sign display for positive and negative numbers, but not zero.

"negative"

Sign display for negative numbers only, excluding negative zero.

"never"

Never display sign.



Return valueA new Intl.NumberFormat object.

Note:
The text below describes behavior that is marked by the specification as "optional". It may not work in all environments. Check the browser compatibility table.

Normally, Intl.NumberFormat() can be called with or without new, and a new Intl.NumberFormat instance is returned in both cases. However, if the this value is an object that is instanceof Intl.NumberFormat (doesn't necessarily mean it's created via new Intl.NumberFormat; just that it has Intl.NumberFormat.prototype in its prototype chain), then the value of this is returned instead, with the newly created Intl.NumberFormat object hidden in a [Symbol(IntlLegacyConstructedSymbol)] property (a unique symbol that's reused between instances).
jsconst formatter = Intl.NumberFormat.call(
  { __proto__: Intl.NumberFormat.prototype },
  "en-US",
  { notation: "scientific" },
);
console.log(Object.getOwnPropertyDescriptors(formatter));
// {
//   [Symbol(IntlLegacyConstructedSymbol)]: {
//     value: NumberFormat [Intl.NumberFormat] {},
//     writable: false,
//     enumerable: false,
//     configurable: false
//   }
// }

Note that there's only one actual Intl.NumberFormat instance here: the one hidden in [Symbol(IntlLegacyConstructedSymbol)]. Calling the format() and resolvedOptions() methods on formatter would correctly use the options stored in that instance, but calling all other methods (e.g., formatRange()) would fail with "TypeError: formatRange method called on incompatible Object", because those methods don't consult the hidden instance's options.
This behavior, called ChainNumberFormat, does not happen when Intl.NumberFormat() is called without new but with this set to anything else that's not an instanceof Intl.NumberFormat. If you call it directly as Intl.NumberFormat(), the this value is Intl, and a new Intl.NumberFormat instance is created normally.Exceptions
RangeError

Thrown in one of the following cases:

A property that takes enumerated values (such as style, units, currency, and so on) is set to an invalid value.
Both maximumFractionDigits and minimumFractionDigits are set, and they are set to different values.
Note that depending on various formatting options, these properties can have default values.
It is therefore possible to get this error even if you only set one of the properties.


TypeError

Thrown if the options.style property is set to "unit" or "currency", and no value has been set for the corresponding property options.unit or options.currency.

ExamplesBasic usageIn basic use without specifying a locale, a formatted string in the default locale and with default options is returned.
jsconst amount = 3500;

console.log(new Intl.NumberFormat().format(amount));
// '3,500' if in US English locale
Decimal and percent formattingjsconst amount = 3500;

new Intl.NumberFormat("en-US", {
  style: "decimal",
}).format(amount); // '3,500'
new Intl.NumberFormat("en-US", {
  style: "percent",
}).format(amount); // '350,000%'
Unit formattingIf the style is 'unit', a unit property must be provided.
Optionally, unitDisplay controls the unit formatting.
jsconst amount = 3500;

new Intl.NumberFormat("en-US", {
  style: "unit",
  unit: "liter",
}).format(amount); // '3,500 L'

new Intl.NumberFormat("en-US", {
  style: "unit",
  unit: "liter",
  unitDisplay: "long",
}).format(amount); // '3,500 liters'
Currency formattingIf the style is 'currency', a currency property
must be provided. Optionally, currencyDisplay and
currencySign control the unit formatting.
jsconst amount = -3500;
new Intl.NumberFormat("en-US", {
  style: "currency",
  currency: "USD",
}).format(amount); // '-$3,500.00'

new Intl.NumberFormat("bn", {
  style: "currency",
  currency: "USD",
  currencyDisplay: "name",
}).format(amount); // '-3,500.00 US dollars'

new Intl.NumberFormat("bn", {
  style: "currency",
  currency: "USD",
  currencySign: "accounting",
}).format(amount); // '($3,500.00)'
Scientific, engineering or compact notationsScientific and compact notation are represented by the notation option and can be formatted like this:
jsnew Intl.NumberFormat("en-US", {
  notation: "scientific",
}).format(987654321);
// 9.877E8

new Intl.NumberFormat("pt-PT", {
  notation: "scientific",
}).format(987654321);
// 9,877E8

new Intl.NumberFormat("en-GB", {
  notation: "engineering",
}).format(987654321);
// 987.654E6

new Intl.NumberFormat("de", {
  notation: "engineering",
}).format(987654321);
// 987,654E6

new Intl.NumberFormat("zh-CN", {
  notation: "compact",
}).format(987654321);
// 9.9亿

new Intl.NumberFormat("fr", {
  notation: "compact",
  compactDisplay: "long",
}).format(987654321);
// 988 millions

new Intl.NumberFormat("en-GB", {
  notation: "compact",
  compactDisplay: "short",
}).format(987654321);
// 988M
Displaying signsDisplay a sign for positive and negative numbers, but not zero:
jsnew Intl.NumberFormat("en-US", {
  style: "percent",
  signDisplay: "exceptZero",
}).format(0.55);
// '+55%'

Note that when the currency sign is "accounting", parentheses might be used instead of a minus sign:
jsnew Intl.NumberFormat("bn", {
  style: "currency",
  currency: "USD",
  currencySign: "accounting",
  signDisplay: "always",
}).format(-3500);
// '($3,500.00)'
FractionDigits, SignificantDigits and IntegerDigitsYou can specify the minimum or maximum number of fractional, integer or significant digits to display when formatting a number.

Note:
If both significant and fractional digit limits are specified, then the actual formatting depends on the roundingPriority.

Using FractionDigits and IntegerDigits
The integer and fraction digit properties indicate the number of digits to display before and after the decimal point, respectively.
If the value to display has fewer integer digits than specified, it will be left-padded with zeros to the expected number.
If it has fewer fractional digits, it will be right-padded with zeros.
Both cases are shown below:
js// Formatting adds zeros to display minimum integers and fractions
console.log(
  new Intl.NumberFormat("en", {
    minimumIntegerDigits: 3,
    minimumFractionDigits: 4,
  }).format(4.33),
);
// "004.3300"

If a value has more fractional digits than the specified maximum number, it will be rounded.
The way that it is rounded depends on the roundingMode property (more details are provided in the rounding modes section).
Below the value is rounded from five fractional digits (4.33145) to two (4.33):
js// Display value shortened to maximum number of digits
console.log(
  new Intl.NumberFormat("en", {
    maximumFractionDigits: 2,
  }).format(4.33145),
);
// "4.33"

The minimum fractional digits have no effect if the value already has more than 2 fractional digits:
js// Minimum fractions have no effect if value is higher precision.
console.log(
  new Intl.NumberFormat("en", {
    minimumFractionDigits: 2,
  }).format(4.33145),
);
// "4.331"


Warning:
Watch out for default values as they may affect formatting even if not specified in your code.
The default maximum digit value is 3 for plain values, 2 for currency, and may have different values for other predefined types.

The formatted value above is rounded to 3 digits, even though we didn't specify the maximum digits!
This is because a default value of maximumFractionDigits is set when we specify minimumFractionDigits, and visa versa. The default values of maximumFractionDigits and minimumFractionDigits are 3 and 0, respectively.
You can use resolvedOptions() to inspect the formatter.
jsconsole.log(
  new Intl.NumberFormat("en", {
    maximumFractionDigits: 2,
  }).resolvedOptions(),
);
// {
//   …
//   minimumIntegerDigits: 1,
//   minimumFractionDigits: 0,
//   maximumFractionDigits: 2,
//   …
// }

console.log(
  new Intl.NumberFormat("en", {
    minimumFractionDigits: 2,
  }).resolvedOptions(),
);
// {
//   …
//   minimumIntegerDigits: 1,
//   minimumFractionDigits: 2,
//   maximumFractionDigits: 3,
//   …
// }

Using SignificantDigits
The number of significant digits is the total number of digits including both integer and fractional parts.
The maximumSignificantDigits is used to indicate the total number of digits from the original value to display.
The examples below show how this works.
Note in particular the last case: only the first digit is retained and the others are discarded/set to zero.
js// Display 5 significant digits
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 5,
  }).format(54.33145),
);
// "54.331"

// Max 2 significant digits
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(54.33145),
);
// "54"

// Max 1 significant digits
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 1,
  }).format(54.33145),
);
// "50"

The minimumSignificantDigits ensures that at least the specified number of digits are displayed, adding zeros to the end of the value if needed.
js// Minimum 10 significant digits
console.log(
  new Intl.NumberFormat("en", {
    minimumSignificantDigits: 10,
  }).format(54.33145),
);
// "54.33145000"


Warning:
Watch out for default values as they may affect formatting.
If only one SignificantDigits property is used, then its counterpart will automatically be applied with the default value.
The default maximum and minimum significant digit values are 21 and 1, respectively.

Specifying significant and fractional digits at the same time
The fraction digits (minimumFractionDigits/maximumFractionDigits) and significant digits (minimumSignificantDigits/maximumSignificantDigits) are both ways of controlling how many fractional and leading digits should be formatted.
If both are used at the same time, it is possible for them to conflict.
These conflicts are resolved using the roundingPriority property.
By default, this has a value of "auto", which means that if either minimumSignificantDigits or maximumSignificantDigits is specified, the fractional and integer digit properties will be ignored.
For example, the code below formats the value of 4.33145 with maximumFractionDigits: 3, and then maximumSignificantDigits: 2, and then both.
The value with both is the one set with maximumSignificantDigits.
jsconsole.log(
  new Intl.NumberFormat("en", {
    maximumFractionDigits: 3,
  }).format(4.33145),
);
// "4.331"
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(4.33145),
);
// "4.3"
console.log(
  new Intl.NumberFormat("en", {
    maximumFractionDigits: 3,
    maximumSignificantDigits: 2,
  }).format(4.33145),
);
// "4.3"

Using resolvedOptions() to inspect the formatter, we can see that the returned object does not include maximumFractionDigits when maximumSignificantDigits or minimumSignificantDigits are specified.
jsconsole.log(
  new Intl.NumberFormat("en", {
    maximumFractionDigits: 3,
    maximumSignificantDigits: 2,
  }).resolvedOptions(),
);
// {
//   …
//   minimumIntegerDigits: 1,
//   minimumSignificantDigits: 1,
//   maximumSignificantDigits: 2,
//   …
// }
console.log(
  new Intl.NumberFormat("en", {
    maximumFractionDigits: 3,
    minimumSignificantDigits: 2,
  }).resolvedOptions(),
);
// {
//   …
//   minimumIntegerDigits: 1,
//   minimumSignificantDigits: 2,
//   maximumSignificantDigits: 21,
//   …
// }

In addition to "auto", you can resolve conflicts by specifying roundingPriority as "morePrecision" or "lessPrecision".
The formatter calculates the precision using the values of maximumSignificantDigits and maximumFractionDigits.
The code below shows the format being selected for the three different rounding priorities:
jsconst maxFracNF = new Intl.NumberFormat("en", {
  maximumFractionDigits: 3,
});
console.log(`maximumFractionDigits:3 - ${maxFracNF.format(1.23456)}`);
// "maximumFractionDigits:2 - 1.235"

const maxSigNS = new Intl.NumberFormat("en", {
  maximumSignificantDigits: 3,
});
console.log(`maximumSignificantDigits:3 - ${maxSigNS.format(1.23456)}`);
// "maximumSignificantDigits:3 - 1.23"

const bothAuto = new Intl.NumberFormat("en", {
  maximumSignificantDigits: 3,
  maximumFractionDigits: 3,
});
console.log(`auto - ${bothAuto.format(1.23456)}`);
// "auto - 1.23"

const bothLess = new Intl.NumberFormat("en", {
  roundingPriority: "lessPrecision",
  maximumSignificantDigits: 3,
  maximumFractionDigits: 3,
});
console.log(`lessPrecision - ${bothLess.format(1.23456)}`);
// "lessPrecision - 1.23"

const bothMore = new Intl.NumberFormat("en", {
  roundingPriority: "morePrecision",
  maximumSignificantDigits: 3,
  maximumFractionDigits: 3,
});
console.log(`morePrecision - ${bothMore.format(1.23456)}`);
// "morePrecision - 1.235"

Note that the algorithm can behave in an unintuitive way if a minimum value is specified without a maximum value.
The example below formats the value 1 specifying minimumFractionDigits: 2 (formatting to 1.00) and minimumSignificantDigits: 2 (formatting to 1.0).
Since 1.00 has more digits than 1.0, this should be the result when prioritizing morePrecision, but in fact the opposite is true:
jsconst bothLess = new Intl.NumberFormat("en", {
  roundingPriority: "lessPrecision",
  minimumFractionDigits: 2,
  minimumSignificantDigits: 2,
});
console.log(`lessPrecision - ${bothLess.format(1)}`);
// "lessPrecision - 1.00"

const bothMore = new Intl.NumberFormat("en", {
  roundingPriority: "morePrecision",
  minimumFractionDigits: 2,
  minimumSignificantDigits: 2,
});
console.log(`morePrecision - ${bothMore.format(1)}`);
// "morePrecision - 1.0"

The reason for this is that only the "maximum precision" values are used for the calculation, and the default value of maximumSignificantDigits is much higher than maximumFractionDigits.

Note:
The working group have proposed a modification of the algorithm where the formatter should evaluate the result of using the specified fractional and significant digits independently (taking account of both minimum and maximum values).
It will then select the option that displays more fractional digits if morePrecision is set, and fewer if lessPrecision is set.
This will result in more intuitive behavior for this case.
Rounding modesIf a value has more fractional digits than allowed by the constructor options, the formatted value will be rounded to the specified number of fractional digits.
The way in which the value is rounded depends on the roundingMode property.
Number formatters use halfExpand rounding by default, which rounds values "away from zero" at the half-increment (in other words, the magnitude of the value is rounded up).
For a positive number, if the fractional digits to be removed are closer to the next increment (or on the half way point) then the remaining fractional digits will be rounded up, otherwise they are rounded down.
This is shown below: 2.23 rounded to two significant digits is truncated to 2.2 because 2.23 is less than the half increment 2.25, while values of 2.25 and greater are rounded up to 2.3:
js// Value below half-increment: round down.
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(2.23),
);
// "2.2"

// Value on or above half-increment: round up.
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(2.25),
);
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(2.28),
);
// "2.3"
// "2.3"

A negative number on or below the half-increment point is also rounded away from zero (becomes more negative):
js// Value below half-increment: round down.
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(-2.23),
);
// "-2.2"

// Value on or above half-increment: round up.
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(-2.25),
);
console.log(
  new Intl.NumberFormat("en", {
    maximumSignificantDigits: 2,
  }).format(-2.28),
);
// "-2.3"
// "-2.3"

The table below show the effect of different rounding modes for positive and negative values that are on and around the half-increment.



rounding mode
2.23
2.25
2.28
-2.23
-2.25
-2.28




ceil
2.3
2.3
2.3
-2.2
-2.2
-2.2


floor
2.2
2.2
2.2
-2.3
-2.3
-2.3


expand
2.3
2.3
2.3
-2.3
-2.3
-2.3


trunc
2.2
2.2
2.2
-2.2
-2.2
-2.2


halfCeil
2.2
2.3
2.3
-2.2
-2.2
-2.3


halfFloor
2.2
2.2
2.3
-2.2
-2.3
-2.3


halfExpand
2.2
2.3
2.3
-2.2
-2.3
-2.3


halfTrunc
2.2
2.2
2.3
-2.2
-2.2
-2.3


halfEven
2.2
2.2
2.3
-2.2
-2.2
-2.3



When using halfEven, its behavior also depends on the parity (odd or even) of the last digit of the rounded number. For example, the behavior of halfEven in the table above is the same as halfTrunc, because the magnitudes of all numbers are between a smaller "even" number (2.2) and a larger "odd" number (2.3). If the numbers are between ±2.3 and ±2.4, halfEven will behave like halfExpand instead. This behavior avoids consistently under- or over-estimating half-increments in a large data sample.Using roundingIncrementSometimes we want to round the remaining fractional digits to some other increment than the next integer.
For example, currencies for which the smallest coin is 5 cents might want to round the value to increments of 5, reflecting amounts that can actually be paid in cash.
This kind of rounding can be achieved with the roundingIncrement property.
For example, if maximumFractionDigits is 2 and roundingIncrement is 5, then the number is rounded to the nearest 0.05:
jsconst nf = new Intl.NumberFormat("en-US", {
  style: "currency",
  currency: "USD",
  maximumFractionDigits: 2,
  roundingIncrement: 5,
});

console.log(nf.format(11.29)); // "$11.30"
console.log(nf.format(11.25)); // "$11.25"
console.log(nf.format(11.22)); // "$11.20"

This particular pattern is referred to as "nickel rounding", where nickel is the colloquial name for a USA 5 cent coin.
To round to the nearest 10 cents ("dime rounding"), you could change roundingIncrement to 10.
jsconst nf = new Intl.NumberFormat("en-US", {
  style: "currency",
  currency: "USD",
  maximumFractionDigits: 2,
  roundingIncrement: 10,
});

console.log(nf.format(11.29)); // "$11.30"
console.log(nf.format(11.25)); // "$11.30"
console.log(nf.format(11.22)); // "$11.20"

You can also use roundingMode to change the rounding algorithm.
The example below shows how halfCeil rounding can be used to round the value "less positive" below the half-rounding increment and "more positive" if above or on the half-increment.
The incremented digit is "0.05" so the half-increment is at .025 (below, this is shown at 11.225).
jsconst nf = new Intl.NumberFormat("en-US", {
  style: "currency",
  currency: "USD",
  maximumFractionDigits: 2,
  roundingIncrement: 5,
  roundingMode: "halfCeil",
});

console.log(nf.format(11.21)); // "$11.20"
console.log(nf.format(11.22)); // "$11.20"
console.log(nf.format(11.224)); // "$11.20"
console.log(nf.format(11.225)); // "$11.25"
console.log(nf.format(11.23)); // "$11.25"

If you need to change the number of digits, remember that minimumFractionDigits and maximumFractionDigits must both be set to the same value, or a RangeError is thrown.
roundingIncrement cannot be mixed with significant-digits rounding or any setting of roundingPriority other than auto.SpecificationsSpecificationECMAScript® 2026 Internationalization API Specification # sec-intl-numberformat-constructorBrowser compatibilitySee also
Intl.NumberFormat
Intl.supportedValuesOf()
Intl
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 4, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nNumber.prototype.toLocaleString()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.Learn moreSee full compatibilityReport feedbackThe toLocaleString() method of Number values returns a string with a language-sensitive representation of this number. In implementations with Intl.NumberFormat API support, this method delegates to Intl.NumberFormat.
Every time toLocaleString is called, it has to perform a search in a big database of localization strings, which is potentially inefficient. When the method is called many times with the same arguments, it is better to create a Intl.NumberFormat object and use its format() method, because a NumberFormat object remembers the arguments passed to it and may decide to cache a slice of the database, so future format calls can search for localization strings within a more constrained context.Try it
function eArabic(x) {
  return x.toLocaleString("ar-EG");
}

console.log(eArabic(123456.789));
// Expected output: "١٢٣٬٤٥٦٫٧٨٩"

console.log(eArabic("123456.789"));
// Expected output: "123456.789"

console.log(eArabic(NaN));
// Expected output: "ليس رقم"
SyntaxjstoLocaleString()
toLocaleString(locales)
toLocaleString(locales, options)
ParametersThe locales and options parameters customize the behavior of the function and let applications specify the language whose formatting conventions should be used.
In implementations that support the Intl.NumberFormat API, these parameters correspond exactly to the Intl.NumberFormat() constructor's parameters. Implementations without Intl.NumberFormat support are asked to ignore both parameters, making the locale used and the form of the string returned entirely implementation-dependent.

locales Optional

A string with a BCP 47 language tag, or an array of such strings. Corresponds to the locales parameter of the Intl.NumberFormat() constructor.
In implementations without Intl.NumberFormat support, this parameter is ignored and the host's locale is usually used.

options Optional

An object adjusting the output format. Corresponds to the options parameter of the Intl.NumberFormat() constructor.
In implementations without Intl.NumberFormat support, this parameter is ignored.


See the Intl.NumberFormat() constructor for details on these parameters and how to use them.Return valueA string representing the given number according to language-specific conventions.
In implementations with Intl.NumberFormat, this is equivalent to new Intl.NumberFormat(locales, options).format(number).

Note:
Most of the time, the formatting returned by toLocaleString() is consistent. However, the output may vary between implementations, even within the same locale — output variations are by design and allowed by the specification. It may also not be what you expect. For example, the string may use non-breaking spaces or be surrounded by bidirectional control characters. You should not compare the results of toLocaleString() to hardcoded constants.
ExamplesUsing toLocaleString()Basic use of this method without specifying a locale returns a formatted string in the default locale and with default options.
jsconst number = 3500;

console.log(number.toLocaleString()); // "3,500" if in U.S. English locale
Checking for support for locales and options parametersThe locales and options parameters may not be supported in all implementations, because support for the internationalization API is optional, and some systems may not have the necessary data. For implementations without internationalization support, toLocaleString() always uses the system's locale, which may not be what you want. Because any implementation that supports the locales and options parameters must support the Intl API, you can check the existence of the latter for support:
jsfunction toLocaleStringSupportsLocales() {
  return (
    typeof Intl === "object" &&
    !!Intl &&
    typeof Intl.NumberFormat === "function"
  );
}
Using localesThis example shows some of the variations in localized number formats. In order to get
the format of the language used in the user interface of your application, make sure to
specify that language (and possibly some fallback languages) using the
locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(number.toLocaleString("de-DE"));
// 123.456,789

// Arabic in most Arabic speaking countries uses Eastern Arabic digits
console.log(number.toLocaleString("ar-EG"));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(number.toLocaleString("en-IN"));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(number.toLocaleString("zh-Hans-CN-u-nu-hanidec"));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(number.toLocaleString(["ban", "id"]));
// 123.456,789
Using optionsThe results provided by toLocaleString() can be customized using the options parameter:
jsconst number = 123456.789;

// request a currency format
console.log(
  number.toLocaleString("de-DE", { style: "currency", currency: "EUR" }),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  number.toLocaleString("ja-JP", { style: "currency", currency: "JPY" }),
);
// ￥123,457

// limit to three significant digits
console.log(number.toLocaleString("en-IN", { maximumSignificantDigits: 3 }));
// 1,23,000

// Use the host default language with options for number formatting
const num = 30000.65;
console.log(
  num.toLocaleString(undefined, {
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  }),
);
// "30,000.65" where English is the default language, or
// "30.000,65" where German is the default language, or
// "30 000,65" where French is the default language
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-number.prototype.tolocalestringECMAScript® 2026 Internationalization API Specification # sup-number.prototype.tolocalestringBrowser compatibilitySee also
Intl.NumberFormat
Number.prototype.toString()\n\nNumber.prototype.toLocaleString()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.Learn moreSee full compatibilityReport feedbackThe toLocaleString() method of Number values returns a string with a language-sensitive representation of this number. In implementations with Intl.NumberFormat API support, this method delegates to Intl.NumberFormat.
Every time toLocaleString is called, it has to perform a search in a big database of localization strings, which is potentially inefficient. When the method is called many times with the same arguments, it is better to create a Intl.NumberFormat object and use its format() method, because a NumberFormat object remembers the arguments passed to it and may decide to cache a slice of the database, so future format calls can search for localization strings within a more constrained context.Try it
function eArabic(x) {
  return x.toLocaleString("ar-EG");
}

console.log(eArabic(123456.789));
// Expected output: "١٢٣٬٤٥٦٫٧٨٩"

console.log(eArabic("123456.789"));
// Expected output: "123456.789"

console.log(eArabic(NaN));
// Expected output: "ليس رقم"
SyntaxjstoLocaleString()
toLocaleString(locales)
toLocaleString(locales, options)
ParametersThe locales and options parameters customize the behavior of the function and let applications specify the language whose formatting conventions should be used.
In implementations that support the Intl.NumberFormat API, these parameters correspond exactly to the Intl.NumberFormat() constructor's parameters. Implementations without Intl.NumberFormat support are asked to ignore both parameters, making the locale used and the form of the string returned entirely implementation-dependent.

locales Optional

A string with a BCP 47 language tag, or an array of such strings. Corresponds to the locales parameter of the Intl.NumberFormat() constructor.
In implementations without Intl.NumberFormat support, this parameter is ignored and the host's locale is usually used.

options Optional

An object adjusting the output format. Corresponds to the options parameter of the Intl.NumberFormat() constructor.
In implementations without Intl.NumberFormat support, this parameter is ignored.


See the Intl.NumberFormat() constructor for details on these parameters and how to use them.Return valueA string representing the given number according to language-specific conventions.
In implementations with Intl.NumberFormat, this is equivalent to new Intl.NumberFormat(locales, options).format(number).

Note:
Most of the time, the formatting returned by toLocaleString() is consistent. However, the output may vary between implementations, even within the same locale — output variations are by design and allowed by the specification. It may also not be what you expect. For example, the string may use non-breaking spaces or be surrounded by bidirectional control characters. You should not compare the results of toLocaleString() to hardcoded constants.
ExamplesUsing toLocaleString()Basic use of this method without specifying a locale returns a formatted string in the default locale and with default options.
jsconst number = 3500;

console.log(number.toLocaleString()); // "3,500" if in U.S. English locale
Checking for support for locales and options parametersThe locales and options parameters may not be supported in all implementations, because support for the internationalization API is optional, and some systems may not have the necessary data. For implementations without internationalization support, toLocaleString() always uses the system's locale, which may not be what you want. Because any implementation that supports the locales and options parameters must support the Intl API, you can check the existence of the latter for support:
jsfunction toLocaleStringSupportsLocales() {
  return (
    typeof Intl === "object" &&
    !!Intl &&
    typeof Intl.NumberFormat === "function"
  );
}
Using localesThis example shows some of the variations in localized number formats. In order to get
the format of the language used in the user interface of your application, make sure to
specify that language (and possibly some fallback languages) using the
locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(number.toLocaleString("de-DE"));
// 123.456,789

// Arabic in most Arabic speaking countries uses Eastern Arabic digits
console.log(number.toLocaleString("ar-EG"));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(number.toLocaleString("en-IN"));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(number.toLocaleString("zh-Hans-CN-u-nu-hanidec"));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(number.toLocaleString(["ban", "id"]));
// 123.456,789
Using optionsThe results provided by toLocaleString() can be customized using the options parameter:
jsconst number = 123456.789;

// request a currency format
console.log(
  number.toLocaleString("de-DE", { style: "currency", currency: "EUR" }),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  number.toLocaleString("ja-JP", { style: "currency", currency: "JPY" }),
);
// ￥123,457

// limit to three significant digits
console.log(number.toLocaleString("en-IN", { maximumSignificantDigits: 3 }));
// 1,23,000

// Use the host default language with options for number formatting
const num = 30000.65;
console.log(
  num.toLocaleString(undefined, {
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  }),
);
// "30,000.65" where English is the default language, or
// "30.000,65" where German is the default language, or
// "30 000,65" where French is the default language
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-number.prototype.tolocalestringECMAScript® 2026 Internationalization API Specification # sup-number.prototype.tolocalestringBrowser compatibilitySee also
Intl.NumberFormat
Number.prototype.toString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nNumber.prototype.toLocaleString()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.Learn moreSee full compatibilityReport feedbackThe toLocaleString() method of Number values returns a string with a language-sensitive representation of this number. In implementations with Intl.NumberFormat API support, this method delegates to Intl.NumberFormat.
Every time toLocaleString is called, it has to perform a search in a big database of localization strings, which is potentially inefficient. When the method is called many times with the same arguments, it is better to create a Intl.NumberFormat object and use its format() method, because a NumberFormat object remembers the arguments passed to it and may decide to cache a slice of the database, so future format calls can search for localization strings within a more constrained context.Try it
function eArabic(x) {
  return x.toLocaleString("ar-EG");
}

console.log(eArabic(123456.789));
// Expected output: "١٢٣٬٤٥٦٫٧٨٩"

console.log(eArabic("123456.789"));
// Expected output: "123456.789"

console.log(eArabic(NaN));
// Expected output: "ليس رقم"
SyntaxjstoLocaleString()
toLocaleString(locales)
toLocaleString(locales, options)
ParametersThe locales and options parameters customize the behavior of the function and let applications specify the language whose formatting conventions should be used.
In implementations that support the Intl.NumberFormat API, these parameters correspond exactly to the Intl.NumberFormat() constructor's parameters. Implementations without Intl.NumberFormat support are asked to ignore both parameters, making the locale used and the form of the string returned entirely implementation-dependent.

locales Optional

A string with a BCP 47 language tag, or an array of such strings. Corresponds to the locales parameter of the Intl.NumberFormat() constructor.
In implementations without Intl.NumberFormat support, this parameter is ignored and the host's locale is usually used.

options Optional

An object adjusting the output format. Corresponds to the options parameter of the Intl.NumberFormat() constructor.
In implementations without Intl.NumberFormat support, this parameter is ignored.


See the Intl.NumberFormat() constructor for details on these parameters and how to use them.Return valueA string representing the given number according to language-specific conventions.
In implementations with Intl.NumberFormat, this is equivalent to new Intl.NumberFormat(locales, options).format(number).

Note:
Most of the time, the formatting returned by toLocaleString() is consistent. However, the output may vary between implementations, even within the same locale — output variations are by design and allowed by the specification. It may also not be what you expect. For example, the string may use non-breaking spaces or be surrounded by bidirectional control characters. You should not compare the results of toLocaleString() to hardcoded constants.
ExamplesUsing toLocaleString()Basic use of this method without specifying a locale returns a formatted string in the default locale and with default options.
jsconst number = 3500;

console.log(number.toLocaleString()); // "3,500" if in U.S. English locale
Checking for support for locales and options parametersThe locales and options parameters may not be supported in all implementations, because support for the internationalization API is optional, and some systems may not have the necessary data. For implementations without internationalization support, toLocaleString() always uses the system's locale, which may not be what you want. Because any implementation that supports the locales and options parameters must support the Intl API, you can check the existence of the latter for support:
jsfunction toLocaleStringSupportsLocales() {
  return (
    typeof Intl === "object" &&
    !!Intl &&
    typeof Intl.NumberFormat === "function"
  );
}
Using localesThis example shows some of the variations in localized number formats. In order to get
the format of the language used in the user interface of your application, make sure to
specify that language (and possibly some fallback languages) using the
locales argument:
jsconst number = 123456.789;

// German uses comma as decimal separator and period for thousands
console.log(number.toLocaleString("de-DE"));
// 123.456,789

// Arabic in most Arabic speaking countries uses Eastern Arabic digits
console.log(number.toLocaleString("ar-EG"));
// ١٢٣٤٥٦٫٧٨٩

// India uses thousands/lakh/crore separators
console.log(number.toLocaleString("en-IN"));
// 1,23,456.789

// the nu extension key requests a numbering system, e.g. Chinese decimal
console.log(number.toLocaleString("zh-Hans-CN-u-nu-hanidec"));
// 一二三,四五六.七八九

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(number.toLocaleString(["ban", "id"]));
// 123.456,789
Using optionsThe results provided by toLocaleString() can be customized using the options parameter:
jsconst number = 123456.789;

// request a currency format
console.log(
  number.toLocaleString("de-DE", { style: "currency", currency: "EUR" }),
);
// 123.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(
  number.toLocaleString("ja-JP", { style: "currency", currency: "JPY" }),
);
// ￥123,457

// limit to three significant digits
console.log(number.toLocaleString("en-IN", { maximumSignificantDigits: 3 }));
// 1,23,000

// Use the host default language with options for number formatting
const num = 30000.65;
console.log(
  num.toLocaleString(undefined, {
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  }),
);
// "30,000.65" where English is the default language, or
// "30.000,65" where German is the default language, or
// "30 000,65" where French is the default language
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-number.prototype.tolocalestringECMAScript® 2026 Internationalization API Specification # sup-number.prototype.tolocalestringBrowser compatibilitySee also
Intl.NumberFormat
Number.prototype.toString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nResources for Developers, by DevelopersDocumenting web technologies, including CSS, HTML, and JavaScript, since 2005.Search MDNClear search inputSearchFeatured articlesBlogJavaScript Temporal is comingA new way to handle dates and times is being added to JavaScript. Let's take a look at Temporal, what problems it solves, the current state, and what you'll find in the new documentation about it on MDN.
CSSCSS anchor positioningThe CSS anchor positioning module defines features that allow you to tether elements together. Certain elements are defined as anchor elements; anchor-positioned elements can then have their size and position set based on the size and location of the anchor elements to which they are bound.
Web APIsUsing the View Transition APIThis article explains the theory behind how the View Transition API works, how to create view transitions and customize the transition animations, and how to manipulate active view transitions. This covers view transitions for both DOM state updates in a single-page app (SPA), and navigating between documents in a multi-page app (MPA).
JavaScriptTemporalThe Temporal object enables date and time management in various scenarios, including built-in time zone and calendar representation, wall-clock time conversions, arithmetics, formatting, and more. It is designed as a full replacement for the Date object.
Latest newsMDN 2024 content projectsdeveloper.mozilla.org4 months agoA new learning experience on MDNdeveloper.mozilla.org4 months agoIntroducing the new MDN Community pagedeveloper.mozilla.org6 months agoRecent contributions[zh-cn]: update the translation of CSS writing modesmdn/translated-content19 hours ago2025/03/22 時点の英語版に同期mdn/translated-content12 hours ago2025/04/10 時点の英語版に同期mdn/translated-content12 hours agoBump autocorrect-node from 2.13.3 to 2.14.0mdn/translated-content11 hours agoBump lefthook from 1.11.11 to 1.11.12mdn/translated-content11 hours agoUse proper ellipsis charactermdn/content9 hours agoBump cspell from 8.19.2 to 8.19.3mdn/content9 hours agoBump lefthook from 1.11.11 to 1.11.12mdn/content8 hours agoFix plaindate.compare return value explanationmdn/content7 hours agoAdd HTML attribute templatemdn/contentan hour agoContributor SpotlightYash Raj BhartiMDN resonates with my passion to build a consistent and open web, where developers can learn and grow.Get involved →\n\nResources for Developers, by DevelopersDocumenting web technologies, including CSS, HTML, and JavaScript, since 2005.Search MDNClear search inputSearchFeatured articlesBlogJavaScript Temporal is comingA new way to handle dates and times is being added to JavaScript. Let's take a look at Temporal, what problems it solves, the current state, and what you'll find in the new documentation about it on MDN.
CSSCSS anchor positioningThe CSS anchor positioning module defines features that allow you to tether elements together. Certain elements are defined as anchor elements; anchor-positioned elements can then have their size and position set based on the size and location of the anchor elements to which they are bound.
Web APIsUsing the View Transition APIThis article explains the theory behind how the View Transition API works, how to create view transitions and customize the transition animations, and how to manipulate active view transitions. This covers view transitions for both DOM state updates in a single-page app (SPA), and navigating between documents in a multi-page app (MPA).
JavaScriptTemporalThe Temporal object enables date and time management in various scenarios, including built-in time zone and calendar representation, wall-clock time conversions, arithmetics, formatting, and more. It is designed as a full replacement for the Date object.
Latest newsMDN 2024 content projectsdeveloper.mozilla.org4 months agoA new learning experience on MDNdeveloper.mozilla.org4 months agoIntroducing the new MDN Community pagedeveloper.mozilla.org6 months agoRecent contributions[zh-cn]: update the translation of CSS writing modesmdn/translated-content19 hours ago2025/03/22 時点の英語版に同期mdn/translated-content12 hours ago2025/04/10 時点の英語版に同期mdn/translated-content12 hours agoBump autocorrect-node from 2.13.3 to 2.14.0mdn/translated-content11 hours agoBump lefthook from 1.11.11 to 1.11.12mdn/translated-content11 hours agoUse proper ellipsis charactermdn/content9 hours agoBump cspell from 8.19.2 to 8.19.3mdn/content9 hours agoBump lefthook from 1.11.11 to 1.11.12mdn/content8 hours agoFix plaindate.compare return value explanationmdn/content7 hours agoAdd HTML attribute templatemdn/contentan hour agoContributor SpotlightYash Raj BhartiMDN resonates with my passion to build a consistent and open web, where developers can learn and grow.Get involved →\n\n\n\nAbout MDN
Empowering developers worldwide to build a better, open web

45K Pages of content
7 Languages
46M Monthly pageviews
Who we areMDN is an open-source, collaborative project owned by Mozilla Corporation and
developed by Mozilla, in partnership with a global community of volunteers and
partners. Mozilla’s MDN team leads the platform’s development, content strategy,
and overall direction, while the community actively
contributes to content creation, translations, and browser compatibility
improvements, ensuring MDN remains a vital and evolving resource for all.What we offerOur journeyOur core valuesOur teamOur partners

MDN Web Docs
Your comprehensive resource for web development documentation, covering
everything from CSS, HTML,
JavaScript, Web APIs, and
other web technologies.


MDN Learn
Ideal for beginners, MDN Learn offers guides and a
structured curriculum to kickstart your web development
journey. Enhance your learning with interactive courses from our partner,
Scrimba.


MDN Blog
Stay updated with the latest in web development. Our blog
features updates, tips, tutorials from web experts, MDN announcements, and
curated sponsored content.


MDN Plus
Experience a personalized MDN with our premium subscription service. Enjoy
features like AI-powered assistance and
Collections to streamline your workflow.


MDN Tools
Experiment and learn with tools like Playground for live coding
and HTTP Observatory for analyzing website security,
designed to enhance your development experience.

From our beginnings to becoming the go-to resource for web developers worldwide,
here's how we've evolved:


2005
Launched as
DevMo by Mozilla,
a community-driven wiki dedicated to documenting open web standards.



2010
Rebranded as
Mozilla Developer Network (MDN),
reinforcing our commitment to the developer community.



2017
Achieved a milestone when major tech companies began contributing and
supporting web documentation on our platform, solidifying MDN as the central
hub for web development knowledge.


2020
Transitioned from its wiki-based origins to a modern,
GitHub-hosted project with the launch of Yari,
modernizing our infrastructure and workflows.



2022
Unveiled a
major redesign and
introduced
MDN Plus,
offering personalized features for an enhanced user experience.



2023/2024
Launched new tools, including Playground for coding experiments, AI Help for
easier content discovery, and HTTP Observatory for website security scans. We
also introduced a Blog to cover interesting topics beyond MDN’s core focus,
and a Curriculum to provide a structured approach to learning web development.


Discover more
We had fun exploring the
internet archives
and putting together a fast-forward trip through our transformation!























Accurate and reliable
MDN is built on the fundamental principle of accuracy, which has established
it as the trusted source of web documentation globally. We are committed to
providing expertly curated and rigorously reviewed content to maintain the
highest standards of quality and accuracy. Our dedication is backed by the
best developer community in the world—a passionate group of contributors who
help us enhance and refine our documentation. We welcome the knowledge and
experience of our diverse developer community to ensure that millions of users
can rely on MDN daily for up-to-date and accurate information.


Collaborative and community-driven
MDN is a Mozilla project that is powered by its global community. We are a
diverse group of developers, writers, and technologists working together to
build resources for a better web. Our open-source approach welcomes
contributions from anyone. Each of the individuals who have
contributed over the past decades has strengthened MDN. Through our GitHub
repository, contributors can make changes and get their work reviewed and
integrated into MDN’s content.


Inclusive and dynamic
MDN is committed to providing documentation for a wide range of web
technologies while continuously adapting to the changing landscape of web
development. We strive to create content that’s relevant and valuable to
developers working across different browsers and platforms. We are dedicated
to regularly updating our resources to reflect the latest standards and best
practices, helping developers stay current in a rapidly changing field.


Our mission
At MDN, our mission is to provide developers with the resources they need to
create innovative and accessible web experiences. We offer a free,
high-quality, and comprehensive platform that includes documentation on
essential web technologies like CSS,
HTML, JavaScript, and
Web APIs. Our learning materials
are tailored for a diverse audience—from beginners and students to professors
teaching web development.

From technical writers and engineers to product and community managers, we are a
diverse group dedicated to driving MDN’s mission, growth, and success. Get to
know the people behind MDN and discover what motivates us to keep you at the
forefront of web development!

Joe Walker

Senior Director

@joewalker
Joe is based in London and has been at Mozilla since 2009. He got interested in Mozilla after suddenly being anointed as the maintainer of Venkman, a precursor to Firebug. He later worked on and managed Firebug and Firefox DevTools. Since 2020, he's managed various teams across Firefox Web Platform, including looking after the core parts of Firefox that you don't usually see—like JavaScript and the DOM. In 2025, he took on the leadership of MDN as well. Joe sometimes works from his office at the bottom of a disused canal, with three chickens and a few newts for company.



Ruth John

Senior Manager

@Rumyra
Based in the UK, Ruth has been working on MDN since 2017. Starting out as a
contracting technical writer documenting fun Web APIs, she joined the team
full-time in 2021 and now heads up the content and community teams. She has
always been a big supporter of the web platform due to her long experience as
a front-end developer and cares deeply about the accuracy and usefulness of
MDN for its developer audience. In her spare time, you can find her walking
her dog Yoshi or in her studio, where she enjoys sewing, sculpting, painting,
and anything else that takes her away from a screen.



Florian Dieminger

Senior Engineering Manager

@fiji-flo
A Berlin resident and a long-time Mozilian, Florian was an active community
member before he joined the Mozilla staff in 2018. His passion for the web
spans across front-end, back-end, browser-engine and anything in-between. He
is a nerd outside of work too and is rediscovering online gaming. He loves
spending time with his family.



Dipika Bhattacharya

Staff Technical Writer

@dipikabh
Dipika works out of Toronto. She joined the MDN team in 2022, bringing her
background in instructional design to the role. She is passionate about
delivering clear and concise documentation to make complex concepts easy to
understand, paying special attention to how information is organized and
presented. She cares about improving the clarity, usability, and
discoverability of MDN’s documentation. Outside of work, she loves exploring
the city, discovering unique coffee shops, and trying different cuisines.



Vadim Makeev

Staff Technical Writer

@pepelsbey
Based in Berlin, Vadim has been working on MDN since 2023. He combines his
previous experience as a front-end developer with a deep passion for browsers
and the web platform. Before joining Mozilla, he worked as a DevRel for the
Opera browser, authored front-end courses, and was also involved in organizing
conferences and meetups. In his spare time, he goes on bikepacking trips,
hangs out on punk gigs, and records podcasts and videos in his home studio.



Brian Smith

Staff Technical Writer

@bsmth
Brian has been with MDN since 2022. He lives in Berlin. With around 20 years
of experience hacking on web technologies and working full-time as a technical
writer since 2016, Brian is passionate about open-source software and writing
docs that make complex concepts fun and easy to grasp for people of all
levels. Before joining Mozilla, Brian worked on a TypeScript-like language
specification, a time series database, and REST API documentation for cloud
services. Outside of work, he enjoys exploring new European destinations with
family, discovering local coffee shops, and using music gear as long as it
doesn't have a screen.



Dave Letorey


Technical Writer





@dletorey


Based in London, UK, Dave has been with MDN since 2022 where he's been focused
on Firefox release documentation, particularly HTML, CSS and SVG updates. He's
passionate about web standards, accessibility, performance and digital
inclusion. He is constantly learning about new web technologies and standards.
Outside of work he loves live music and tries to attend as many gigs and music
festivals as he can. He particularly loves post-punk, indie, house and techno.
He also attends many conferences and meetups and is an organizer of
London Web Standards &
State of the Browser. He also has a large
collection of red hats, so is easy to spot in the wild. He is never happier
than when in a field with his friends.




Chris Mills

Technical Writer and Product Strategist

@chrisdavidmills
Based in Greenfield, UK, Chris has been part of MDN since 2013, initially as a
technical writer and then as the writers' team lead until 2021. He came back
on board as a contractor in 2022 to document new technologies and contribute
to various MDN products and initiatives. Chris loves tinkering with CSS and
JavaScript and is passionate about accessibility and semantics. Outside work,
he is obsessed with loud, heavy music, and plays drums and guitar. He enjoys
cycling, country walks, and spending time with his wife and three awesome
kids.



Hamish Willee

Technical Writer

@hamishwillee
Based in Melbourne, Australia, Hamish has been with MDN since 2014, initially
on short-term contracts for various projects. From 2020, he’s been focused on
Firefox release documentation, particularly Web API and HTTP updates, while
also contributing to other aspects of the open-source project. He’s passionate
about efficient processes that maximize time for creating clear, concise, and
maintainable documentation. Hamish values that his writing reaches thousands
of developers and enjoys working with the diverse community to make expert
knowledge accessible to everyone in a clear format. Outside work, he brews
beer, reads science fiction and fantasy, enjoys running, and likes drones.



Andi Pieper

Staff Software Engineer

@argl
Andi lives in Berlin. He joined the MDN team in 2023. He is focused on keeping
up the high quality of MDN and ensuring that it remains an accessible,
competent, and friendly help for anyone concerned with the web, regardless of
their level of expertise. Growing up with the internet of the 90s, Andi has
worked on a multitude of projects on the web over the years, occasionally
veering off into desktop and mobile development. Apart from his daytime
obligations, he enjoys creating organized noise.



Claas Augner

Senior Software Engineer

@caugner
Based in Paris, Claas has been working as a Software Engineer in the MDN team
since 2022. He is passionate about clean code and continuous improvement. He
enjoys entertaining (the team), and maintaining (the platform). Outside of
work, he loves baking rye sourdough breads and playing cooperative board
games.



Leo McArdle

Senior Software Engineer

@LeoMcA
A London-based long-term Mozilla contributor, Leo has been working on MDN
since 2022 and volunteering for Mozilla since around 2008. As a self-taught
developer, largely through MDN, he cares about making the website discoverable
and functional for everyone. In his free time, he can be found cycling around
the city, photographing panoramas, or watching almost every sport imaginable,
from cricket to karting.



Pranshu Khanna

Staff Community Manager

@pransh15
Pranshu has been a long-term contributor to Mozilla as a Rep. Based in Berlin,
he joined the MDN team in 2024. He works on moderating, growing and managing
MDN’s awesome community. Pranshu is passionate about building a healthy and
inclusive community for developers and helping them build better. Before
working at Mozilla, Pranshu gained extensive experience in growing developer
communities for startups, organizing conferences like GraphQL Conf. 2021 &
2022, and running global programs for devs and students around AI, Web, and
DevOps. In his free time, he likes to play football in any form - physical,
digital, and fantasy.



Anuja Rajput

Senior User Experience Designer

@AnujaRajput727
Located in London, Anuja has been a part of the MDN team since 2023. With over
8 years of experience, she has passionately contributed to various phases of
product development, including design, business analysis, and testing. She is
empathetic and deeply cares about understanding users' perspectives and pain
points. She combines her work experience with her creative skills to enhance
her UX designs. In her free time, she enjoys painting, sketching, and travel
sketching.



Sonal Sood

Senior Product Manager

@s-sood
Sonal lives in Berlin. She has been with MDN since 2022. As a product manager,
she is adept at identifying and prioritizing features that truly meet users'
needs. With a strong background in data analysis and product management, she
is always focused on delivering valuable and impactful products that make a
difference. In her free time, Sonal enjoys cycling, running, and practicing
yoga.



Miruna Curtean

Quality Assurance

@mirunacurtean
Miruna calls Cluj-Napoca, Romania home. Contracting with Mozilla since 2019,
she worked on Firefox Add-ons and Mozilla Support before switching to MDN
in 2022. She focuses on analyzing requirements and community issues, building
comprehensive test bases, and ensuring delivered features meet requirements.
Before Mozilla, she worked in game development and e-commerce but found
greater joy in website development, particularly inspired by its community
aspect. Outside of work, Miruna enjoys story-based entertainment including
books, movies, shows, anime, and podcasts.


Product Advisory Board

Rachel Andrew

Content Lead at Google

Rachel has been working on the web as a developer since 1996 and writing about web development for almost as long. She now works for Google as Content Lead for Chrome Developer Relations, owning the content strategy of web.dev and developer.chrome.com, and is also a lead on the Baseline project. Rachel is a CSS Working Group member and specification editor, and in the past has been a contributor to MDN as a contractor for Mozilla and for Google.
Photo © Drew McLellan.



Robert Nyman

Web Developer Relations at Google

Robert wants to make the web the best platform for developers and has always been heavily invested in the community and helping developers succeed. Prior to Google, Robert was a technical evangelist at Mozilla, focused on the Open Web and the company's various products and initiatives. He's a co-founder of Open Web Docs, lives in Stockholm, has a passion for traveling and meeting people, and has given presentations in 42 countries.



Patrick Brosset

Senior Product Manager, Microsoft Edge

Patrick Brosset is a senior Product Manager on the Microsoft Edge web platform team, where he drives efforts around developer advocacy, documentation, and evangelism for the web platform. Patrick has worked with the web for more than 20 years, and on web browsers at Mozilla and Microsoft, including on developer tools, web apps, and the rendering engine for over a decade. He is a member of the Governing Committee at Open Web Docs, and a co-chair of the W3C WebDX Community Group.



Dominique Hazael-Massieux

Web Technology Expert including Web, W3C

Dominique Hazael-Massieux is part of the W3C staff, leading W3C
efforts in developer relations. Dom has been working for W3C since 2000,
and in addition to dev rel, is currently involved in the standardization
of WebRTC, WebNN and looking over the systemic impact of AI on the Web.
Dom also sits on the W3C Board of Directors and on the Open Web Docs
Governing Committee.



Carmen Cañas

Technical Project Manager, Bocoup

Carmen Cañas is part of the worker-owner team at Bocoup where she manages web platform projects and product development projects with a special focus on accessibility and privacy. Before joining Bocoup, she spent over 10 years building open source projects in Latin America and Africa, with a focus on implementing open data standards for publishing government data.  Carmen lives between Cuzcatlán (El Salvador) and Tkaronto (Toronto).



Laura Morinigo

Web Developer Advocate

Laura is a software developer, advocate, and mentor, passionate about sharing her knowledge and connecting with tech communities worldwide. She has been recognized as a Google Developer Expert and a Woman Techmakers Ambassador for her contributions. As a mentor, she has supported startups in accelerator programs like Google Launchpad and the United Nations’ World Food Programme. Currently, Laura contributes to web standards and advocates for advanced web features, helping developers build more inclusive and impactful web applications.




Open Web Docs
Open Web Docs (OWD), an independent open source organization, is one of the most productive contributors to MDN Web Docs. OWD contributes as part of their mission to support “web platform documentation for the benefit of web developers & designers worldwide.” The team at OWD has led or contributed to many projects to improve documentation on MDN. They're an invaluable partner in the day-to-day work of making MDN. Read more about OWD’s activities in their 2024 Impact and Transparency Report and get continuous updates on their Mastodon account.

Florian Scholz

Director

@Elchi3
Florian Scholz is the Director of Open Web Docs. He began volunteer editing MDN as a teen in 2009 and previously worked at Mozilla as MDN's Lead Content Strategist, Technical Writer & Documentation Engineer from 2013 until 2020. He's one of the creators of the browser compatibility data (BCD) project and it makes him happy when open source projects collaborate. He lives in Bremen, Germany; not Berlin. Other than submitting and reviewing PRs on GitHub, he enjoys listening to wave and post-punk music.



Will Bamberg

Sr. Technical Writer and Documentation Engineer

@wbamberg
Will Bamberg is a perfectionist and professional pedant who has been writing about the web for a long time, mostly on MDN. He enjoys learning about new aspects of the web platform and then turning that knowledge into accessible documentation. He believes that writing good documentation depends on understanding what it's like for someone who is learning something new or looking for the answer to their question.



Estelle Weyl

Sr. Technical Writer and Developer Advocate

@estelle
Estelle Weyl is a Sr. Technical Writer and Developer Advocate on the Open Web Docs team. She is a frontend engineer, writing CSS, JS and HTML since 1999. Estelle has always been a web standardista, advocating for a free, accessible, and performant web. Estelle has been documenting and teaching web standards since 2007, writing numerous books, blogs, and tutorials. She’s typing with her cat (who thinks he's a dog) and dog (who thinks she's a cat) in San Francisco.



Queen Vinyl Da.i'gyu-Kazotetsu

Compat Data Engineer

@queengooborg
Vinyl works for Open Web Docs leading the browser compatibility data (BCD) project that millions of developers around the world rely on. Previously a contractor at Google and Mozilla and a long-time BCD community member, Vinyl has a lot of experience with compatibility on the open web. She was already the number #1 contributor to the BCD repository before officially joining our team! When she's not submitting pull requests to BCD, she's usually slicing blocks to the music in Beat Saber or staffing at various conventions across the globe.


Global impactServing over 15 million users monthly from around the globe, MDN connects
developers with the tools and information they need to easily build projects on
the open web.


Educational influence: Our resources are integral to many coding bootcamps and
university courses worldwide.


Trusted reference: Platforms like freeCodeCamp and Codecademy frequently link
to MDN articles as authoritative references.


Industry standard: Tools like Can I use leverage
MDN’s browser compatibility data
for up-to-date information on web feature support across browsers.


Collaborative partnerships: We work closely with partners such as
Open Web Docs,
Microsoft,
Google, Igalia,
W3C, and others to drive web innovation and serve the
common good.

Join us in building a better webBe a part of our mission to foster innovation and inclusivity on the web.
Start contributing today and make a lasting impact
on the global developer community.\n\nAbout MDN
Empowering developers worldwide to build a better, open web

45K Pages of content
7 Languages
46M Monthly pageviews
Who we areMDN is an open-source, collaborative project owned by Mozilla Corporation and
developed by Mozilla, in partnership with a global community of volunteers and
partners. Mozilla’s MDN team leads the platform’s development, content strategy,
and overall direction, while the community actively
contributes to content creation, translations, and browser compatibility
improvements, ensuring MDN remains a vital and evolving resource for all.What we offerOur journeyOur core valuesOur teamOur partners

MDN Web Docs
Your comprehensive resource for web development documentation, covering
everything from CSS, HTML,
JavaScript, Web APIs, and
other web technologies.


MDN Learn
Ideal for beginners, MDN Learn offers guides and a
structured curriculum to kickstart your web development
journey. Enhance your learning with interactive courses from our partner,
Scrimba.


MDN Blog
Stay updated with the latest in web development. Our blog
features updates, tips, tutorials from web experts, MDN announcements, and
curated sponsored content.


MDN Plus
Experience a personalized MDN with our premium subscription service. Enjoy
features like AI-powered assistance and
Collections to streamline your workflow.


MDN Tools
Experiment and learn with tools like Playground for live coding
and HTTP Observatory for analyzing website security,
designed to enhance your development experience.

From our beginnings to becoming the go-to resource for web developers worldwide,
here's how we've evolved:


2005
Launched as
DevMo by Mozilla,
a community-driven wiki dedicated to documenting open web standards.



2010
Rebranded as
Mozilla Developer Network (MDN),
reinforcing our commitment to the developer community.



2017
Achieved a milestone when major tech companies began contributing and
supporting web documentation on our platform, solidifying MDN as the central
hub for web development knowledge.


2020
Transitioned from its wiki-based origins to a modern,
GitHub-hosted project with the launch of Yari,
modernizing our infrastructure and workflows.



2022
Unveiled a
major redesign and
introduced
MDN Plus,
offering personalized features for an enhanced user experience.



2023/2024
Launched new tools, including Playground for coding experiments, AI Help for
easier content discovery, and HTTP Observatory for website security scans. We
also introduced a Blog to cover interesting topics beyond MDN’s core focus,
and a Curriculum to provide a structured approach to learning web development.


Discover more
We had fun exploring the
internet archives
and putting together a fast-forward trip through our transformation!























Accurate and reliable
MDN is built on the fundamental principle of accuracy, which has established
it as the trusted source of web documentation globally. We are committed to
providing expertly curated and rigorously reviewed content to maintain the
highest standards of quality and accuracy. Our dedication is backed by the
best developer community in the world—a passionate group of contributors who
help us enhance and refine our documentation. We welcome the knowledge and
experience of our diverse developer community to ensure that millions of users
can rely on MDN daily for up-to-date and accurate information.


Collaborative and community-driven
MDN is a Mozilla project that is powered by its global community. We are a
diverse group of developers, writers, and technologists working together to
build resources for a better web. Our open-source approach welcomes
contributions from anyone. Each of the individuals who have
contributed over the past decades has strengthened MDN. Through our GitHub
repository, contributors can make changes and get their work reviewed and
integrated into MDN’s content.


Inclusive and dynamic
MDN is committed to providing documentation for a wide range of web
technologies while continuously adapting to the changing landscape of web
development. We strive to create content that’s relevant and valuable to
developers working across different browsers and platforms. We are dedicated
to regularly updating our resources to reflect the latest standards and best
practices, helping developers stay current in a rapidly changing field.


Our mission
At MDN, our mission is to provide developers with the resources they need to
create innovative and accessible web experiences. We offer a free,
high-quality, and comprehensive platform that includes documentation on
essential web technologies like CSS,
HTML, JavaScript, and
Web APIs. Our learning materials
are tailored for a diverse audience—from beginners and students to professors
teaching web development.

From technical writers and engineers to product and community managers, we are a
diverse group dedicated to driving MDN’s mission, growth, and success. Get to
know the people behind MDN and discover what motivates us to keep you at the
forefront of web development!

Joe Walker

Senior Director

@joewalker
Joe is based in London and has been at Mozilla since 2009. He got interested in Mozilla after suddenly being anointed as the maintainer of Venkman, a precursor to Firebug. He later worked on and managed Firebug and Firefox DevTools. Since 2020, he's managed various teams across Firefox Web Platform, including looking after the core parts of Firefox that you don't usually see—like JavaScript and the DOM. In 2025, he took on the leadership of MDN as well. Joe sometimes works from his office at the bottom of a disused canal, with three chickens and a few newts for company.



Ruth John

Senior Manager

@Rumyra
Based in the UK, Ruth has been working on MDN since 2017. Starting out as a
contracting technical writer documenting fun Web APIs, she joined the team
full-time in 2021 and now heads up the content and community teams. She has
always been a big supporter of the web platform due to her long experience as
a front-end developer and cares deeply about the accuracy and usefulness of
MDN for its developer audience. In her spare time, you can find her walking
her dog Yoshi or in her studio, where she enjoys sewing, sculpting, painting,
and anything else that takes her away from a screen.



Florian Dieminger

Senior Engineering Manager

@fiji-flo
A Berlin resident and a long-time Mozilian, Florian was an active community
member before he joined the Mozilla staff in 2018. His passion for the web
spans across front-end, back-end, browser-engine and anything in-between. He
is a nerd outside of work too and is rediscovering online gaming. He loves
spending time with his family.



Dipika Bhattacharya

Staff Technical Writer

@dipikabh
Dipika works out of Toronto. She joined the MDN team in 2022, bringing her
background in instructional design to the role. She is passionate about
delivering clear and concise documentation to make complex concepts easy to
understand, paying special attention to how information is organized and
presented. She cares about improving the clarity, usability, and
discoverability of MDN’s documentation. Outside of work, she loves exploring
the city, discovering unique coffee shops, and trying different cuisines.



Vadim Makeev

Staff Technical Writer

@pepelsbey
Based in Berlin, Vadim has been working on MDN since 2023. He combines his
previous experience as a front-end developer with a deep passion for browsers
and the web platform. Before joining Mozilla, he worked as a DevRel for the
Opera browser, authored front-end courses, and was also involved in organizing
conferences and meetups. In his spare time, he goes on bikepacking trips,
hangs out on punk gigs, and records podcasts and videos in his home studio.



Brian Smith

Staff Technical Writer

@bsmth
Brian has been with MDN since 2022. He lives in Berlin. With around 20 years
of experience hacking on web technologies and working full-time as a technical
writer since 2016, Brian is passionate about open-source software and writing
docs that make complex concepts fun and easy to grasp for people of all
levels. Before joining Mozilla, Brian worked on a TypeScript-like language
specification, a time series database, and REST API documentation for cloud
services. Outside of work, he enjoys exploring new European destinations with
family, discovering local coffee shops, and using music gear as long as it
doesn't have a screen.



Dave Letorey


Technical Writer





@dletorey


Based in London, UK, Dave has been with MDN since 2022 where he's been focused
on Firefox release documentation, particularly HTML, CSS and SVG updates. He's
passionate about web standards, accessibility, performance and digital
inclusion. He is constantly learning about new web technologies and standards.
Outside of work he loves live music and tries to attend as many gigs and music
festivals as he can. He particularly loves post-punk, indie, house and techno.
He also attends many conferences and meetups and is an organizer of
London Web Standards &
State of the Browser. He also has a large
collection of red hats, so is easy to spot in the wild. He is never happier
than when in a field with his friends.




Chris Mills

Technical Writer and Product Strategist

@chrisdavidmills
Based in Greenfield, UK, Chris has been part of MDN since 2013, initially as a
technical writer and then as the writers' team lead until 2021. He came back
on board as a contractor in 2022 to document new technologies and contribute
to various MDN products and initiatives. Chris loves tinkering with CSS and
JavaScript and is passionate about accessibility and semantics. Outside work,
he is obsessed with loud, heavy music, and plays drums and guitar. He enjoys
cycling, country walks, and spending time with his wife and three awesome
kids.



Hamish Willee

Technical Writer

@hamishwillee
Based in Melbourne, Australia, Hamish has been with MDN since 2014, initially
on short-term contracts for various projects. From 2020, he’s been focused on
Firefox release documentation, particularly Web API and HTTP updates, while
also contributing to other aspects of the open-source project. He’s passionate
about efficient processes that maximize time for creating clear, concise, and
maintainable documentation. Hamish values that his writing reaches thousands
of developers and enjoys working with the diverse community to make expert
knowledge accessible to everyone in a clear format. Outside work, he brews
beer, reads science fiction and fantasy, enjoys running, and likes drones.



Andi Pieper

Staff Software Engineer

@argl
Andi lives in Berlin. He joined the MDN team in 2023. He is focused on keeping
up the high quality of MDN and ensuring that it remains an accessible,
competent, and friendly help for anyone concerned with the web, regardless of
their level of expertise. Growing up with the internet of the 90s, Andi has
worked on a multitude of projects on the web over the years, occasionally
veering off into desktop and mobile development. Apart from his daytime
obligations, he enjoys creating organized noise.



Claas Augner

Senior Software Engineer

@caugner
Based in Paris, Claas has been working as a Software Engineer in the MDN team
since 2022. He is passionate about clean code and continuous improvement. He
enjoys entertaining (the team), and maintaining (the platform). Outside of
work, he loves baking rye sourdough breads and playing cooperative board
games.



Leo McArdle

Senior Software Engineer

@LeoMcA
A London-based long-term Mozilla contributor, Leo has been working on MDN
since 2022 and volunteering for Mozilla since around 2008. As a self-taught
developer, largely through MDN, he cares about making the website discoverable
and functional for everyone. In his free time, he can be found cycling around
the city, photographing panoramas, or watching almost every sport imaginable,
from cricket to karting.



Pranshu Khanna

Staff Community Manager

@pransh15
Pranshu has been a long-term contributor to Mozilla as a Rep. Based in Berlin,
he joined the MDN team in 2024. He works on moderating, growing and managing
MDN’s awesome community. Pranshu is passionate about building a healthy and
inclusive community for developers and helping them build better. Before
working at Mozilla, Pranshu gained extensive experience in growing developer
communities for startups, organizing conferences like GraphQL Conf. 2021 &
2022, and running global programs for devs and students around AI, Web, and
DevOps. In his free time, he likes to play football in any form - physical,
digital, and fantasy.



Anuja Rajput

Senior User Experience Designer

@AnujaRajput727
Located in London, Anuja has been a part of the MDN team since 2023. With over
8 years of experience, she has passionately contributed to various phases of
product development, including design, business analysis, and testing. She is
empathetic and deeply cares about understanding users' perspectives and pain
points. She combines her work experience with her creative skills to enhance
her UX designs. In her free time, she enjoys painting, sketching, and travel
sketching.



Sonal Sood

Senior Product Manager

@s-sood
Sonal lives in Berlin. She has been with MDN since 2022. As a product manager,
she is adept at identifying and prioritizing features that truly meet users'
needs. With a strong background in data analysis and product management, she
is always focused on delivering valuable and impactful products that make a
difference. In her free time, Sonal enjoys cycling, running, and practicing
yoga.



Miruna Curtean

Quality Assurance

@mirunacurtean
Miruna calls Cluj-Napoca, Romania home. Contracting with Mozilla since 2019,
she worked on Firefox Add-ons and Mozilla Support before switching to MDN
in 2022. She focuses on analyzing requirements and community issues, building
comprehensive test bases, and ensuring delivered features meet requirements.
Before Mozilla, she worked in game development and e-commerce but found
greater joy in website development, particularly inspired by its community
aspect. Outside of work, Miruna enjoys story-based entertainment including
books, movies, shows, anime, and podcasts.


Product Advisory Board

Rachel Andrew

Content Lead at Google

Rachel has been working on the web as a developer since 1996 and writing about web development for almost as long. She now works for Google as Content Lead for Chrome Developer Relations, owning the content strategy of web.dev and developer.chrome.com, and is also a lead on the Baseline project. Rachel is a CSS Working Group member and specification editor, and in the past has been a contributor to MDN as a contractor for Mozilla and for Google.
Photo © Drew McLellan.



Robert Nyman

Web Developer Relations at Google

Robert wants to make the web the best platform for developers and has always been heavily invested in the community and helping developers succeed. Prior to Google, Robert was a technical evangelist at Mozilla, focused on the Open Web and the company's various products and initiatives. He's a co-founder of Open Web Docs, lives in Stockholm, has a passion for traveling and meeting people, and has given presentations in 42 countries.



Patrick Brosset

Senior Product Manager, Microsoft Edge

Patrick Brosset is a senior Product Manager on the Microsoft Edge web platform team, where he drives efforts around developer advocacy, documentation, and evangelism for the web platform. Patrick has worked with the web for more than 20 years, and on web browsers at Mozilla and Microsoft, including on developer tools, web apps, and the rendering engine for over a decade. He is a member of the Governing Committee at Open Web Docs, and a co-chair of the W3C WebDX Community Group.



Dominique Hazael-Massieux

Web Technology Expert including Web, W3C

Dominique Hazael-Massieux is part of the W3C staff, leading W3C
efforts in developer relations. Dom has been working for W3C since 2000,
and in addition to dev rel, is currently involved in the standardization
of WebRTC, WebNN and looking over the systemic impact of AI on the Web.
Dom also sits on the W3C Board of Directors and on the Open Web Docs
Governing Committee.



Carmen Cañas

Technical Project Manager, Bocoup

Carmen Cañas is part of the worker-owner team at Bocoup where she manages web platform projects and product development projects with a special focus on accessibility and privacy. Before joining Bocoup, she spent over 10 years building open source projects in Latin America and Africa, with a focus on implementing open data standards for publishing government data.  Carmen lives between Cuzcatlán (El Salvador) and Tkaronto (Toronto).



Laura Morinigo

Web Developer Advocate

Laura is a software developer, advocate, and mentor, passionate about sharing her knowledge and connecting with tech communities worldwide. She has been recognized as a Google Developer Expert and a Woman Techmakers Ambassador for her contributions. As a mentor, she has supported startups in accelerator programs like Google Launchpad and the United Nations’ World Food Programme. Currently, Laura contributes to web standards and advocates for advanced web features, helping developers build more inclusive and impactful web applications.




Open Web Docs
Open Web Docs (OWD), an independent open source organization, is one of the most productive contributors to MDN Web Docs. OWD contributes as part of their mission to support “web platform documentation for the benefit of web developers & designers worldwide.” The team at OWD has led or contributed to many projects to improve documentation on MDN. They're an invaluable partner in the day-to-day work of making MDN. Read more about OWD’s activities in their 2024 Impact and Transparency Report and get continuous updates on their Mastodon account.

Florian Scholz

Director

@Elchi3
Florian Scholz is the Director of Open Web Docs. He began volunteer editing MDN as a teen in 2009 and previously worked at Mozilla as MDN's Lead Content Strategist, Technical Writer & Documentation Engineer from 2013 until 2020. He's one of the creators of the browser compatibility data (BCD) project and it makes him happy when open source projects collaborate. He lives in Bremen, Germany; not Berlin. Other than submitting and reviewing PRs on GitHub, he enjoys listening to wave and post-punk music.



Will Bamberg

Sr. Technical Writer and Documentation Engineer

@wbamberg
Will Bamberg is a perfectionist and professional pedant who has been writing about the web for a long time, mostly on MDN. He enjoys learning about new aspects of the web platform and then turning that knowledge into accessible documentation. He believes that writing good documentation depends on understanding what it's like for someone who is learning something new or looking for the answer to their question.



Estelle Weyl

Sr. Technical Writer and Developer Advocate

@estelle
Estelle Weyl is a Sr. Technical Writer and Developer Advocate on the Open Web Docs team. She is a frontend engineer, writing CSS, JS and HTML since 1999. Estelle has always been a web standardista, advocating for a free, accessible, and performant web. Estelle has been documenting and teaching web standards since 2007, writing numerous books, blogs, and tutorials. She’s typing with her cat (who thinks he's a dog) and dog (who thinks she's a cat) in San Francisco.



Queen Vinyl Da.i'gyu-Kazotetsu

Compat Data Engineer

@queengooborg
Vinyl works for Open Web Docs leading the browser compatibility data (BCD) project that millions of developers around the world rely on. Previously a contractor at Google and Mozilla and a long-time BCD community member, Vinyl has a lot of experience with compatibility on the open web. She was already the number #1 contributor to the BCD repository before officially joining our team! When she's not submitting pull requests to BCD, she's usually slicing blocks to the music in Beat Saber or staffing at various conventions across the globe.


Global impactServing over 15 million users monthly from around the globe, MDN connects
developers with the tools and information they need to easily build projects on
the open web.


Educational influence: Our resources are integral to many coding bootcamps and
university courses worldwide.


Trusted reference: Platforms like freeCodeCamp and Codecademy frequently link
to MDN articles as authoritative references.


Industry standard: Tools like Can I use leverage
MDN’s browser compatibility data
for up-to-date information on web feature support across browsers.


Collaborative partnerships: We work closely with partners such as
Open Web Docs,
Microsoft,
Google, Igalia,
W3C, and others to drive web innovation and serve the
common good.

Join us in building a better webBe a part of our mission to foster innovation and inclusivity on the web.
Start contributing today and make a lasting impact
on the global developer community.\n\n\n\n\n\n\n\n\n\nCreating and working on issuesAs a contributor, you can report and work on issues.
After you report an issue, the issue gets triaged. Issue triaging is typically done by people assigned the role of a maintainer or an owner.General guidelines for participationWhile reporting an issue or participating in a conversation in an issue, always ensure that your inputs are contributing to the overall progress of the project. Consider whether the issues you open and your comments in an issue are constructive and on topic and are not just adding noise.
Do the following:

Before filing an issue, consider if you need to discuss it with the staff/community. Use discussions to gain different viewpoints and to converge on an agreed-upon course of action. This helps to keep issues focused and productive.
After filing an issue, try to fix the problem yourself. Read our contribution guide to learn more.
If you have a question, you can ask it in the MDN Web Docs chat rooms instead of filing an issue.

Avoid doing the following:

Complicating issues by trying to discuss multiple topics or by making off-topic comments.
Opening lots of issues asking vague questions.
Asking questions without trying to solve the problem yourself first.
Guidelines for reporting an issueIssues are used to track bugs. An issue must be a single actionable task or a collection of related actionable tasks and must have a clear outcome.Before filing an issueIf you think you've found a bug with the content on MDN Web Docs or with the look and feel of the website, search the current open issues in the relevant repository and make sure nobody else has reported the issue.Reporting an issueDepending on the type of problem you've discovered, you can report it by filing an issue on one of the main MDN GitHub repositories.
If the information you provide in the issue is incomplete, you might be asked to provide more details during the issue triaging process.
Here are some hints for opening issues:

Choose the appropriate category to report the issue. For example, to report a content bug, use the Content issue template in the mdn/content repository.
Provide sufficient information while reporting the issue:

Issue title must convey succinctly the required action.
Issue description must clearly describe the bug and the action required to resolve the issue. It must also list the task or sub-tasks to be completed to resolve the issue. Some other guidelines include:

Use the description field to indicate the status of the task or sub-tasks by using checklists.
Update the status of a task in the issue description instead of commenting on the issue. Use task lists in the description if an issue has multiple parts. This helps others who may otherwise need to scroll through comments on the issue to determine the status of various tasks.
Comments in an issue should be limited to details or context that help resolve the issue.




If you find yourself in one of the following situations, move the conversation to MDN's discussion on GitHub:

A discussion needs to take place to clarify an issue.
A discussion begins after opening the issue.
The issue has no clear consensus on its resolution.
The requirements for completing the task expand while it's being resolved or the work is unclear.


For minor bugs, you can make the changes yourself and submit a pull request.
Creating a task list issueIf the issue you're opening is not to report a bug but to perform a series of tasks, you can create the issue as a task list.
Explain the context or reason for performing the tasks in the description.
Ensure that you list all the actionable tasks as a checklist.
For example:
md// Issue title
Ensure sections follow the order defined in the CSS property template

### Description

The CSS property page template is defined [here](/en-US/docs/MDN/Writing_guidelines/Page_structures/Page_types/CSS_property_page_template).
The task list in this issue will be used to compare the documented CSS properties with the template and track changes to the property pages for compliance.

### List of pages checked

- [x] [accent-color](/en-US/docs/Web/CSS/accent-color) - checked, okay
- [ ] [backdrop-filter](/en-US/docs/Web/CSS/backdrop-filter)
- [ ] [letter-spacing](/en-US/docs/Web/CSS/letter-spacing) - open pull request to move `Accessibility concerns` and `Internationalization concerns` sections before the `Specifications` section.
Guidelines for working on an issueRemember that if you take on an issue, the expectation is for the work to be completed in a timely manner. If you're not able to make any progress for a week after being assigned or can no longer complete the required task, leave a comment and unassign yourself from the issue.
These are the general steps for working on an issue:


Find an issue: If you're looking to contribute, search for issues with good first issue, help wanted or p3 label. Most repositories have issues with these labels. You are welcome to browse and pick an issue that is suitable for your skill set. Another useful place to look for issues to work on is the MDN Contributors Task Board. This project view lists open issues from multiple repositories. You can filter the list based on the topics (Labels column) you're interested in. See the description of some of the labels that get applied during the issue triage process.

Note:
An issue with the needs triage label indicates that the MDN Web Docs core team has not reviewed the issue yet, and you shouldn't begin work on it.



Assign the issue to yourself: After finding an issue you'd like to work on, make sure that the issue is not assigned to anybody else. Add a comment saying you would like to work on the issue, and if you are able to, assign the issue to yourself.


Do the research: Most issues need some investigation before work can start.

Scope out the work that needs to be done. If you need to ask questions, ask them in the MDN Web Docs chat rooms.
If the issue is well-described, and the work is pretty obvious, go ahead and do it.
If the issue is not well-described, and/or you are not sure what is needed, feel free to @mention the poster and ask for more information.



Make the changes: Fork and branch the repository. Do your work and open a pull request in the repository. Reference the issue in the pull request description. Depending on the files you've updated in the pull request, a reviewer will be assigned to your pull request automatically. (Teams per topic area are defined in the CODEOWNERS file).
After opening the pull request, if you find you no longer have the time to make changes or incorporate review feedback, let the team know as soon as possible in a comment in the pull request. This will help the team assign another interested contributor to complete the work on the pull request and close the linked issue.


After your pull request has been reviewed and merged, you can mark the linked issue as closed. If you opened the pull request with Fixes #<issue> verbiage, the issue will be closed automatically when the pull request is merged.

Fixing issues yourselfIf you spot a bug — whether it's a problem with the website's look and feel or an error in documentation — you can try to fix it yourself. Learn how you can contribute by going through our contribution guide.
If the bug is small, such as a typo or a minor sentence improvement, or involves an uncontroversial fix, submit a pull request with the changes.
For all other type of bugs, begin by opening the issue. Add a comment about your intent to work on the issue and if possible, describe your proposed solution or steps to fix the issue.
Wait for the issue to be triaged, so that the MDN Web Docs team can verify that the issue is legit and approves your proposed solution.

Note:
If you open a pull request before the issue has been triaged, your time and effort might go waste if the linked issue is deemed invalid or the solution does not match the one expected by the MDN Web Docs team.
After the issue is triaged, assign the issue to yourself.

Using the guidelines on working on an issue, try to fix the problem by updating the appropriate source, such as:

The MDN Web Docs content (in English) in the mdn/content repository
The MDN Web Docs translated content in the mdn/translated-content repository
The MDN Web Docs frontend in the mdn/yari repository

Each repository includes useful information to guide you on how to contribute.
For more information, see our main GitHub repositories.Guidelines for triaging issuesIf you are a maintainer or an owner in the MDN Web Docs GitHub organization, you are responsible for triaging issues in one or more MDN Web Docs repository.
The overall process for triaging includes some general and some issue-specific tasks.General triaging tasks

When an issue is opened, the needs triage label is set on the issue automatically. You can search for this label to look for issues that need to be triaged. Contributors or anybody else should not work on the issue until the issue has been triaged. (Triagers should remember to remove the needs triage label after triaging the issue.)


In the mdn/content repository, an additional Content: label, such as Content:CSS or Content:WebAPI, is set on the issue automatically. This gets set based on the MDN URL mentioned in the issue. You can use the content-specific label to look for issues to be triaged in your specific topic area.


If an issue concerns an active, non-en-US locale, set the appropriate label, such as l10n-fr, l10n-zh, or l10n-ja. The teams for those locales will pick these issues up and triage them.


You don't need to actively triage issues all the time. Set aside time, say 30 minutes every week, to triage issues on a regular basis in your area of responsibility. Triaging doesn't have to be done as part of a synchronous meeting or even at the same time as everyone else, but it should be done regularly to make sure that the backlog of untriaged bugs doesn't get too high.


Apart from triaging incoming issues every week, review the list of old bugs to see if there are any that are stalled, need closing, or are no longer relevant. The idle label is automatically set on issues that have had no activity for 30 days.

Check assigned issues that are still open to see if the assignee is making progress. If there is no progress after a week of being assigned, ask them if they still have time to work on the issue. If another week passes by without any progress, unassign them and leave a comment indicating that you're making the issue available for other interested contributors.
If a pull request has been opened to fix the issue but has not been reviewed for a week, give the reviewer a gentle ping to ask if they can get to it.
If a pull request to fix the issue is waiting on review comments to be addressed after a week, then ask the author if they can respond to their review. If another week goes by, either fix the review comments yourself if you have time, or close the pull request and unassign the related issue.


Issue-specific triaging tasksThese are the guidelines to follow while triaging each issue.
Review if the issue is valid
These are some of the things to keep in mind while reviewing the validity of an issue:

Check if the issue raised is valid and if the fix will improve the content for the readers and the website.
Evaluate if the impact of the fix will be small or site-wide.
Evaluate if the fix for the issue will need a discussion first, in which case, point the author to open a discussion instead.
Check if the issue complies with our writing guidelines and templates.
Check whether suggestions for adding links comply with our external links policy.

Review the issue for completeness of information
Review each issue against the following checklist to ensure that the issue contains the described information for someone to start working on the bug:

URL of the MDN Web Docs page with the problem or URL of an example MDN Web Docs page if the problem exists on multiple pages
The specific heading or section on the MDN Web Docs page where the problem was found
A clear description of the incorrect, unhelpful, incomplete, or missing information

If any of the above information is not present, then you should ask the author of the issue to provide these details, and add the needs info label to the issue. Resume triaging the issue only after those details have been provided (after which, you can remove the needs info label). It is okay to wait for up to a week to get a response from the author.
Set a priority label
For each bug, set a priority label based on the severity of the issue to help people who want to work on the most important issues or areas.


Critical issue: This type of issue needs to be fixed as soon as possible, regardless of where it appears on the site. This type of issue could damage MDN's reputation severely and/or harm users. Examples of this issue include an incorrect code snippet, which if used in production, could create a severe security problem and undesirable content such as malware, profanity, pornography, hate speech, or links to such content.

Label: p0 (will be addressed immediately)



Major issue: This type of issue could severely affect a page's usefulness. For example, a significant amount of out-of-date information, a complex and important code example that doesn't work, a significant amount of prose that is badly written and hard to understand, or a large number of broken links.

Labels: p1 (will be addressed soon) and p2 (will be addressed soon, but higher priority items will take precedence)



Minor issue: This is a type of improvement issue that can make the existing content better but does not affect learning or only has a minor effect on learning. Since these types of issues are not actively planned for, help from contributors to fix these issues is welcome and much appreciated. Fixing some of these issues can also provide the necessary practice to beginner contributors who are starting to get familiar with the contribution process. Examples include typos, bad grammar, a broken link, a small amount of out-of-date information or badly-written prose, or a code snippet that doesn't work.

Labels: p3 (no visibility when the issue will be addressed)



In general, critical issues should be fixed immediately and are most likely handled by MDN Web Docs staff and peers.
Add helpful information
If possible, add information that can help contributors to fix the issue. The information can be in the form of steps, general approach, links to other similar fixed issues, or reading resources. A well-laid out plan or steps is especially required in issues that are labeled good first issue and can help ramp up new contributors quickly. You can time-box this task to 5-10 minutes.
For example, as a triager, you can add the following information to the issue you are triaging:
mdTo whoever fixes this issue, it looks like the following is needed:

- Update the first paragraph below heading X to correct the problem with Y
- Add a description of X
- Update the compatibility data at Link-X

Set other labels
Next, set the following labels as appropriate:


effort: small, effort: medium, effort: large: Some contributors like to search for bugs based on the time and effort that will be needed to fix the bug. So where possible, you should try to provide an estimate of the required effort.


good first issue: Set this label on the issue if the fix for the issue is really simple and if fixing the issue would provide good practice for a newcomer who is getting used to the process.


help wanted: Set this label if the issue requires help from someone who knows about or is familiar with the topic. This is a popular label and some contributors use it to search for issues to work on in open source projects in their areas of familiarity or expertise.


broken link external: Set this label if the issue involves a broken link to an external page.


document not written: Set this label if the issue involves a necessary document that has not been written yet, usually because a link points to it.


needs content update: Set this label if the issue fix in another repository will need an equivalent fix in the mdn/content repository.

Note:
After the triage process is complete, remove the needs triage label.\n\nCreating and working on issuesAs a contributor, you can report and work on issues.
After you report an issue, the issue gets triaged. Issue triaging is typically done by people assigned the role of a maintainer or an owner.General guidelines for participationWhile reporting an issue or participating in a conversation in an issue, always ensure that your inputs are contributing to the overall progress of the project. Consider whether the issues you open and your comments in an issue are constructive and on topic and are not just adding noise.
Do the following:

Before filing an issue, consider if you need to discuss it with the staff/community. Use discussions to gain different viewpoints and to converge on an agreed-upon course of action. This helps to keep issues focused and productive.
After filing an issue, try to fix the problem yourself. Read our contribution guide to learn more.
If you have a question, you can ask it in the MDN Web Docs chat rooms instead of filing an issue.

Avoid doing the following:

Complicating issues by trying to discuss multiple topics or by making off-topic comments.
Opening lots of issues asking vague questions.
Asking questions without trying to solve the problem yourself first.
Guidelines for reporting an issueIssues are used to track bugs. An issue must be a single actionable task or a collection of related actionable tasks and must have a clear outcome.Before filing an issueIf you think you've found a bug with the content on MDN Web Docs or with the look and feel of the website, search the current open issues in the relevant repository and make sure nobody else has reported the issue.Reporting an issueDepending on the type of problem you've discovered, you can report it by filing an issue on one of the main MDN GitHub repositories.
If the information you provide in the issue is incomplete, you might be asked to provide more details during the issue triaging process.
Here are some hints for opening issues:

Choose the appropriate category to report the issue. For example, to report a content bug, use the Content issue template in the mdn/content repository.
Provide sufficient information while reporting the issue:

Issue title must convey succinctly the required action.
Issue description must clearly describe the bug and the action required to resolve the issue. It must also list the task or sub-tasks to be completed to resolve the issue. Some other guidelines include:

Use the description field to indicate the status of the task or sub-tasks by using checklists.
Update the status of a task in the issue description instead of commenting on the issue. Use task lists in the description if an issue has multiple parts. This helps others who may otherwise need to scroll through comments on the issue to determine the status of various tasks.
Comments in an issue should be limited to details or context that help resolve the issue.




If you find yourself in one of the following situations, move the conversation to MDN's discussion on GitHub:

A discussion needs to take place to clarify an issue.
A discussion begins after opening the issue.
The issue has no clear consensus on its resolution.
The requirements for completing the task expand while it's being resolved or the work is unclear.


For minor bugs, you can make the changes yourself and submit a pull request.
Creating a task list issueIf the issue you're opening is not to report a bug but to perform a series of tasks, you can create the issue as a task list.
Explain the context or reason for performing the tasks in the description.
Ensure that you list all the actionable tasks as a checklist.
For example:
md// Issue title
Ensure sections follow the order defined in the CSS property template

### Description

The CSS property page template is defined [here](/en-US/docs/MDN/Writing_guidelines/Page_structures/Page_types/CSS_property_page_template).
The task list in this issue will be used to compare the documented CSS properties with the template and track changes to the property pages for compliance.

### List of pages checked

- [x] [accent-color](/en-US/docs/Web/CSS/accent-color) - checked, okay
- [ ] [backdrop-filter](/en-US/docs/Web/CSS/backdrop-filter)
- [ ] [letter-spacing](/en-US/docs/Web/CSS/letter-spacing) - open pull request to move `Accessibility concerns` and `Internationalization concerns` sections before the `Specifications` section.
Guidelines for working on an issueRemember that if you take on an issue, the expectation is for the work to be completed in a timely manner. If you're not able to make any progress for a week after being assigned or can no longer complete the required task, leave a comment and unassign yourself from the issue.
These are the general steps for working on an issue:


Find an issue: If you're looking to contribute, search for issues with good first issue, help wanted or p3 label. Most repositories have issues with these labels. You are welcome to browse and pick an issue that is suitable for your skill set. Another useful place to look for issues to work on is the MDN Contributors Task Board. This project view lists open issues from multiple repositories. You can filter the list based on the topics (Labels column) you're interested in. See the description of some of the labels that get applied during the issue triage process.

Note:
An issue with the needs triage label indicates that the MDN Web Docs core team has not reviewed the issue yet, and you shouldn't begin work on it.



Assign the issue to yourself: After finding an issue you'd like to work on, make sure that the issue is not assigned to anybody else. Add a comment saying you would like to work on the issue, and if you are able to, assign the issue to yourself.


Do the research: Most issues need some investigation before work can start.

Scope out the work that needs to be done. If you need to ask questions, ask them in the MDN Web Docs chat rooms.
If the issue is well-described, and the work is pretty obvious, go ahead and do it.
If the issue is not well-described, and/or you are not sure what is needed, feel free to @mention the poster and ask for more information.



Make the changes: Fork and branch the repository. Do your work and open a pull request in the repository. Reference the issue in the pull request description. Depending on the files you've updated in the pull request, a reviewer will be assigned to your pull request automatically. (Teams per topic area are defined in the CODEOWNERS file).
After opening the pull request, if you find you no longer have the time to make changes or incorporate review feedback, let the team know as soon as possible in a comment in the pull request. This will help the team assign another interested contributor to complete the work on the pull request and close the linked issue.


After your pull request has been reviewed and merged, you can mark the linked issue as closed. If you opened the pull request with Fixes #<issue> verbiage, the issue will be closed automatically when the pull request is merged.

Fixing issues yourselfIf you spot a bug — whether it's a problem with the website's look and feel or an error in documentation — you can try to fix it yourself. Learn how you can contribute by going through our contribution guide.
If the bug is small, such as a typo or a minor sentence improvement, or involves an uncontroversial fix, submit a pull request with the changes.
For all other type of bugs, begin by opening the issue. Add a comment about your intent to work on the issue and if possible, describe your proposed solution or steps to fix the issue.
Wait for the issue to be triaged, so that the MDN Web Docs team can verify that the issue is legit and approves your proposed solution.

Note:
If you open a pull request before the issue has been triaged, your time and effort might go waste if the linked issue is deemed invalid or the solution does not match the one expected by the MDN Web Docs team.
After the issue is triaged, assign the issue to yourself.

Using the guidelines on working on an issue, try to fix the problem by updating the appropriate source, such as:

The MDN Web Docs content (in English) in the mdn/content repository
The MDN Web Docs translated content in the mdn/translated-content repository
The MDN Web Docs frontend in the mdn/yari repository

Each repository includes useful information to guide you on how to contribute.
For more information, see our main GitHub repositories.Guidelines for triaging issuesIf you are a maintainer or an owner in the MDN Web Docs GitHub organization, you are responsible for triaging issues in one or more MDN Web Docs repository.
The overall process for triaging includes some general and some issue-specific tasks.General triaging tasks

When an issue is opened, the needs triage label is set on the issue automatically. You can search for this label to look for issues that need to be triaged. Contributors or anybody else should not work on the issue until the issue has been triaged. (Triagers should remember to remove the needs triage label after triaging the issue.)


In the mdn/content repository, an additional Content: label, such as Content:CSS or Content:WebAPI, is set on the issue automatically. This gets set based on the MDN URL mentioned in the issue. You can use the content-specific label to look for issues to be triaged in your specific topic area.


If an issue concerns an active, non-en-US locale, set the appropriate label, such as l10n-fr, l10n-zh, or l10n-ja. The teams for those locales will pick these issues up and triage them.


You don't need to actively triage issues all the time. Set aside time, say 30 minutes every week, to triage issues on a regular basis in your area of responsibility. Triaging doesn't have to be done as part of a synchronous meeting or even at the same time as everyone else, but it should be done regularly to make sure that the backlog of untriaged bugs doesn't get too high.


Apart from triaging incoming issues every week, review the list of old bugs to see if there are any that are stalled, need closing, or are no longer relevant. The idle label is automatically set on issues that have had no activity for 30 days.

Check assigned issues that are still open to see if the assignee is making progress. If there is no progress after a week of being assigned, ask them if they still have time to work on the issue. If another week passes by without any progress, unassign them and leave a comment indicating that you're making the issue available for other interested contributors.
If a pull request has been opened to fix the issue but has not been reviewed for a week, give the reviewer a gentle ping to ask if they can get to it.
If a pull request to fix the issue is waiting on review comments to be addressed after a week, then ask the author if they can respond to their review. If another week goes by, either fix the review comments yourself if you have time, or close the pull request and unassign the related issue.


Issue-specific triaging tasksThese are the guidelines to follow while triaging each issue.
Review if the issue is valid
These are some of the things to keep in mind while reviewing the validity of an issue:

Check if the issue raised is valid and if the fix will improve the content for the readers and the website.
Evaluate if the impact of the fix will be small or site-wide.
Evaluate if the fix for the issue will need a discussion first, in which case, point the author to open a discussion instead.
Check if the issue complies with our writing guidelines and templates.
Check whether suggestions for adding links comply with our external links policy.

Review the issue for completeness of information
Review each issue against the following checklist to ensure that the issue contains the described information for someone to start working on the bug:

URL of the MDN Web Docs page with the problem or URL of an example MDN Web Docs page if the problem exists on multiple pages
The specific heading or section on the MDN Web Docs page where the problem was found
A clear description of the incorrect, unhelpful, incomplete, or missing information

If any of the above information is not present, then you should ask the author of the issue to provide these details, and add the needs info label to the issue. Resume triaging the issue only after those details have been provided (after which, you can remove the needs info label). It is okay to wait for up to a week to get a response from the author.
Set a priority label
For each bug, set a priority label based on the severity of the issue to help people who want to work on the most important issues or areas.


Critical issue: This type of issue needs to be fixed as soon as possible, regardless of where it appears on the site. This type of issue could damage MDN's reputation severely and/or harm users. Examples of this issue include an incorrect code snippet, which if used in production, could create a severe security problem and undesirable content such as malware, profanity, pornography, hate speech, or links to such content.

Label: p0 (will be addressed immediately)



Major issue: This type of issue could severely affect a page's usefulness. For example, a significant amount of out-of-date information, a complex and important code example that doesn't work, a significant amount of prose that is badly written and hard to understand, or a large number of broken links.

Labels: p1 (will be addressed soon) and p2 (will be addressed soon, but higher priority items will take precedence)



Minor issue: This is a type of improvement issue that can make the existing content better but does not affect learning or only has a minor effect on learning. Since these types of issues are not actively planned for, help from contributors to fix these issues is welcome and much appreciated. Fixing some of these issues can also provide the necessary practice to beginner contributors who are starting to get familiar with the contribution process. Examples include typos, bad grammar, a broken link, a small amount of out-of-date information or badly-written prose, or a code snippet that doesn't work.

Labels: p3 (no visibility when the issue will be addressed)



In general, critical issues should be fixed immediately and are most likely handled by MDN Web Docs staff and peers.
Add helpful information
If possible, add information that can help contributors to fix the issue. The information can be in the form of steps, general approach, links to other similar fixed issues, or reading resources. A well-laid out plan or steps is especially required in issues that are labeled good first issue and can help ramp up new contributors quickly. You can time-box this task to 5-10 minutes.
For example, as a triager, you can add the following information to the issue you are triaging:
mdTo whoever fixes this issue, it looks like the following is needed:

- Update the first paragraph below heading X to correct the problem with Y
- Add a description of X
- Update the compatibility data at Link-X

Set other labels
Next, set the following labels as appropriate:


effort: small, effort: medium, effort: large: Some contributors like to search for bugs based on the time and effort that will be needed to fix the bug. So where possible, you should try to provide an estimate of the required effort.


good first issue: Set this label on the issue if the fix for the issue is really simple and if fixing the issue would provide good practice for a newcomer who is getting used to the process.


help wanted: Set this label if the issue requires help from someone who knows about or is familiar with the topic. This is a popular label and some contributors use it to search for issues to work on in open source projects in their areas of familiarity or expertise.


broken link external: Set this label if the issue involves a broken link to an external page.


document not written: Set this label if the issue involves a necessary document that has not been written yet, usually because a link points to it.


needs content update: Set this label if the issue fix in another repository will need an equivalent fix in the mdn/content repository.

Note:
After the triage process is complete, remove the needs triage label.


Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 7, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nCreating and working on issuesAs a contributor, you can report and work on issues.
After you report an issue, the issue gets triaged. Issue triaging is typically done by people assigned the role of a maintainer or an owner.General guidelines for participationWhile reporting an issue or participating in a conversation in an issue, always ensure that your inputs are contributing to the overall progress of the project. Consider whether the issues you open and your comments in an issue are constructive and on topic and are not just adding noise.
Do the following:

Before filing an issue, consider if you need to discuss it with the staff/community. Use discussions to gain different viewpoints and to converge on an agreed-upon course of action. This helps to keep issues focused and productive.
After filing an issue, try to fix the problem yourself. Read our contribution guide to learn more.
If you have a question, you can ask it in the MDN Web Docs chat rooms instead of filing an issue.

Avoid doing the following:

Complicating issues by trying to discuss multiple topics or by making off-topic comments.
Opening lots of issues asking vague questions.
Asking questions without trying to solve the problem yourself first.
Guidelines for reporting an issueIssues are used to track bugs. An issue must be a single actionable task or a collection of related actionable tasks and must have a clear outcome.Before filing an issueIf you think you've found a bug with the content on MDN Web Docs or with the look and feel of the website, search the current open issues in the relevant repository and make sure nobody else has reported the issue.Reporting an issueDepending on the type of problem you've discovered, you can report it by filing an issue on one of the main MDN GitHub repositories.
If the information you provide in the issue is incomplete, you might be asked to provide more details during the issue triaging process.
Here are some hints for opening issues:

Choose the appropriate category to report the issue. For example, to report a content bug, use the Content issue template in the mdn/content repository.
Provide sufficient information while reporting the issue:

Issue title must convey succinctly the required action.
Issue description must clearly describe the bug and the action required to resolve the issue. It must also list the task or sub-tasks to be completed to resolve the issue. Some other guidelines include:

Use the description field to indicate the status of the task or sub-tasks by using checklists.
Update the status of a task in the issue description instead of commenting on the issue. Use task lists in the description if an issue has multiple parts. This helps others who may otherwise need to scroll through comments on the issue to determine the status of various tasks.
Comments in an issue should be limited to details or context that help resolve the issue.




If you find yourself in one of the following situations, move the conversation to MDN's discussion on GitHub:

A discussion needs to take place to clarify an issue.
A discussion begins after opening the issue.
The issue has no clear consensus on its resolution.
The requirements for completing the task expand while it's being resolved or the work is unclear.


For minor bugs, you can make the changes yourself and submit a pull request.
Creating a task list issueIf the issue you're opening is not to report a bug but to perform a series of tasks, you can create the issue as a task list.
Explain the context or reason for performing the tasks in the description.
Ensure that you list all the actionable tasks as a checklist.
For example:
md// Issue title
Ensure sections follow the order defined in the CSS property template

### Description

The CSS property page template is defined [here](/en-US/docs/MDN/Writing_guidelines/Page_structures/Page_types/CSS_property_page_template).
The task list in this issue will be used to compare the documented CSS properties with the template and track changes to the property pages for compliance.

### List of pages checked

- [x] [accent-color](/en-US/docs/Web/CSS/accent-color) - checked, okay
- [ ] [backdrop-filter](/en-US/docs/Web/CSS/backdrop-filter)
- [ ] [letter-spacing](/en-US/docs/Web/CSS/letter-spacing) - open pull request to move `Accessibility concerns` and `Internationalization concerns` sections before the `Specifications` section.
Guidelines for working on an issueRemember that if you take on an issue, the expectation is for the work to be completed in a timely manner. If you're not able to make any progress for a week after being assigned or can no longer complete the required task, leave a comment and unassign yourself from the issue.
These are the general steps for working on an issue:


Find an issue: If you're looking to contribute, search for issues with good first issue, help wanted or p3 label. Most repositories have issues with these labels. You are welcome to browse and pick an issue that is suitable for your skill set. Another useful place to look for issues to work on is the MDN Contributors Task Board. This project view lists open issues from multiple repositories. You can filter the list based on the topics (Labels column) you're interested in. See the description of some of the labels that get applied during the issue triage process.

Note:
An issue with the needs triage label indicates that the MDN Web Docs core team has not reviewed the issue yet, and you shouldn't begin work on it.



Assign the issue to yourself: After finding an issue you'd like to work on, make sure that the issue is not assigned to anybody else. Add a comment saying you would like to work on the issue, and if you are able to, assign the issue to yourself.


Do the research: Most issues need some investigation before work can start.

Scope out the work that needs to be done. If you need to ask questions, ask them in the MDN Web Docs chat rooms.
If the issue is well-described, and the work is pretty obvious, go ahead and do it.
If the issue is not well-described, and/or you are not sure what is needed, feel free to @mention the poster and ask for more information.



Make the changes: Fork and branch the repository. Do your work and open a pull request in the repository. Reference the issue in the pull request description. Depending on the files you've updated in the pull request, a reviewer will be assigned to your pull request automatically. (Teams per topic area are defined in the CODEOWNERS file).
After opening the pull request, if you find you no longer have the time to make changes or incorporate review feedback, let the team know as soon as possible in a comment in the pull request. This will help the team assign another interested contributor to complete the work on the pull request and close the linked issue.


After your pull request has been reviewed and merged, you can mark the linked issue as closed. If you opened the pull request with Fixes #<issue> verbiage, the issue will be closed automatically when the pull request is merged.

Fixing issues yourselfIf you spot a bug — whether it's a problem with the website's look and feel or an error in documentation — you can try to fix it yourself. Learn how you can contribute by going through our contribution guide.
If the bug is small, such as a typo or a minor sentence improvement, or involves an uncontroversial fix, submit a pull request with the changes.
For all other type of bugs, begin by opening the issue. Add a comment about your intent to work on the issue and if possible, describe your proposed solution or steps to fix the issue.
Wait for the issue to be triaged, so that the MDN Web Docs team can verify that the issue is legit and approves your proposed solution.

Note:
If you open a pull request before the issue has been triaged, your time and effort might go waste if the linked issue is deemed invalid or the solution does not match the one expected by the MDN Web Docs team.
After the issue is triaged, assign the issue to yourself.

Using the guidelines on working on an issue, try to fix the problem by updating the appropriate source, such as:

The MDN Web Docs content (in English) in the mdn/content repository
The MDN Web Docs translated content in the mdn/translated-content repository
The MDN Web Docs frontend in the mdn/yari repository

Each repository includes useful information to guide you on how to contribute.
For more information, see our main GitHub repositories.Guidelines for triaging issuesIf you are a maintainer or an owner in the MDN Web Docs GitHub organization, you are responsible for triaging issues in one or more MDN Web Docs repository.
The overall process for triaging includes some general and some issue-specific tasks.General triaging tasks

When an issue is opened, the needs triage label is set on the issue automatically. You can search for this label to look for issues that need to be triaged. Contributors or anybody else should not work on the issue until the issue has been triaged. (Triagers should remember to remove the needs triage label after triaging the issue.)


In the mdn/content repository, an additional Content: label, such as Content:CSS or Content:WebAPI, is set on the issue automatically. This gets set based on the MDN URL mentioned in the issue. You can use the content-specific label to look for issues to be triaged in your specific topic area.


If an issue concerns an active, non-en-US locale, set the appropriate label, such as l10n-fr, l10n-zh, or l10n-ja. The teams for those locales will pick these issues up and triage them.


You don't need to actively triage issues all the time. Set aside time, say 30 minutes every week, to triage issues on a regular basis in your area of responsibility. Triaging doesn't have to be done as part of a synchronous meeting or even at the same time as everyone else, but it should be done regularly to make sure that the backlog of untriaged bugs doesn't get too high.


Apart from triaging incoming issues every week, review the list of old bugs to see if there are any that are stalled, need closing, or are no longer relevant. The idle label is automatically set on issues that have had no activity for 30 days.

Check assigned issues that are still open to see if the assignee is making progress. If there is no progress after a week of being assigned, ask them if they still have time to work on the issue. If another week passes by without any progress, unassign them and leave a comment indicating that you're making the issue available for other interested contributors.
If a pull request has been opened to fix the issue but has not been reviewed for a week, give the reviewer a gentle ping to ask if they can get to it.
If a pull request to fix the issue is waiting on review comments to be addressed after a week, then ask the author if they can respond to their review. If another week goes by, either fix the review comments yourself if you have time, or close the pull request and unassign the related issue.


Issue-specific triaging tasksThese are the guidelines to follow while triaging each issue.
Review if the issue is valid
These are some of the things to keep in mind while reviewing the validity of an issue:

Check if the issue raised is valid and if the fix will improve the content for the readers and the website.
Evaluate if the impact of the fix will be small or site-wide.
Evaluate if the fix for the issue will need a discussion first, in which case, point the author to open a discussion instead.
Check if the issue complies with our writing guidelines and templates.
Check whether suggestions for adding links comply with our external links policy.

Review the issue for completeness of information
Review each issue against the following checklist to ensure that the issue contains the described information for someone to start working on the bug:

URL of the MDN Web Docs page with the problem or URL of an example MDN Web Docs page if the problem exists on multiple pages
The specific heading or section on the MDN Web Docs page where the problem was found
A clear description of the incorrect, unhelpful, incomplete, or missing information

If any of the above information is not present, then you should ask the author of the issue to provide these details, and add the needs info label to the issue. Resume triaging the issue only after those details have been provided (after which, you can remove the needs info label). It is okay to wait for up to a week to get a response from the author.
Set a priority label
For each bug, set a priority label based on the severity of the issue to help people who want to work on the most important issues or areas.


Critical issue: This type of issue needs to be fixed as soon as possible, regardless of where it appears on the site. This type of issue could damage MDN's reputation severely and/or harm users. Examples of this issue include an incorrect code snippet, which if used in production, could create a severe security problem and undesirable content such as malware, profanity, pornography, hate speech, or links to such content.

Label: p0 (will be addressed immediately)



Major issue: This type of issue could severely affect a page's usefulness. For example, a significant amount of out-of-date information, a complex and important code example that doesn't work, a significant amount of prose that is badly written and hard to understand, or a large number of broken links.

Labels: p1 (will be addressed soon) and p2 (will be addressed soon, but higher priority items will take precedence)



Minor issue: This is a type of improvement issue that can make the existing content better but does not affect learning or only has a minor effect on learning. Since these types of issues are not actively planned for, help from contributors to fix these issues is welcome and much appreciated. Fixing some of these issues can also provide the necessary practice to beginner contributors who are starting to get familiar with the contribution process. Examples include typos, bad grammar, a broken link, a small amount of out-of-date information or badly-written prose, or a code snippet that doesn't work.

Labels: p3 (no visibility when the issue will be addressed)



In general, critical issues should be fixed immediately and are most likely handled by MDN Web Docs staff and peers.
Add helpful information
If possible, add information that can help contributors to fix the issue. The information can be in the form of steps, general approach, links to other similar fixed issues, or reading resources. A well-laid out plan or steps is especially required in issues that are labeled good first issue and can help ramp up new contributors quickly. You can time-box this task to 5-10 minutes.
For example, as a triager, you can add the following information to the issue you are triaging:
mdTo whoever fixes this issue, it looks like the following is needed:

- Update the first paragraph below heading X to correct the problem with Y
- Add a description of X
- Update the compatibility data at Link-X

Set other labels
Next, set the following labels as appropriate:


effort: small, effort: medium, effort: large: Some contributors like to search for bugs based on the time and effort that will be needed to fix the bug. So where possible, you should try to provide an estimate of the required effort.


good first issue: Set this label on the issue if the fix for the issue is really simple and if fixing the issue would provide good practice for a newcomer who is getting used to the process.


help wanted: Set this label if the issue requires help from someone who knows about or is familiar with the topic. This is a popular label and some contributors use it to search for issues to work on in open source projects in their areas of familiarity or expertise.


broken link external: Set this label if the issue involves a broken link to an external page.


document not written: Set this label if the issue involves a necessary document that has not been written yet, usually because a link points to it.


needs content update: Set this label if the issue fix in another repository will need an equivalent fix in the mdn/content repository.

Note:
After the triage process is complete, remove the needs triage label.


Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 7, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nMDN Community
Where web enthusiasts learn, collaborate, and create

Start contributing
Join MDN Discord



45K+ Total contributors
200+ Weekly commits
7 Language communities
MDN's community powers the webMDN’s strength comes from the passion and dedication of our global community.
Since our founding in 2005, we’ve grown into a thriving network. Together, we’ve
created a comprehensive, open, and free resource that serves web developers
across the globe. With volunteers leading translation efforts in
7 languages, we’re
truly international.Meet our contributorsWe are an open-source community dedicated to building resources for a better
web. Our diverse contributors, including developers, technical writers,
students, educators, designers, and more, come from various backgrounds and
platforms. Anyone can contribute, and each contribution strengthens our
community, driving innovation and improving this vital resource for developers
worldwide.

Join us
View all contributors



Jason Lam, 林家祥 https://github.com/JasonLamv-t Grantit
Nicolò Ribaudo https://github.com/nicolo-ribaudo Igalia
Joshua Chen https://github.com/Josh-Cena
Kimchanmin https://github.com/c17an SK Planet
Gibbeum Yoon https://github.com/givvemee
Jongha Kim https://github.com/wisedog
Qizhe ZHANG https://github.com/PassionPenguin
Artem Shibakov https://github.com/saionaro Bright Data
HoChan Lee https://github.com/hochan222 11STREET
Sangchul Lee https://github.com/1ilsang WoowaBros
Park Sunhee https://github.com/sunhpark42 WoowaBros
FU CHUNHUI https://github.com/fuchunhui Baidu
Estelle Weyl https://github.com/estelle Open Web Docs
Yitao Yin https://github.com/yin1999 Northwestern Polytechnical University
Florian Scholz https://github.com/Elchi3 Open Web Docs

Contributor spotlight


There are many other things I like about MDN: the openness of its
governance, the respect for contributors' work, the professional
conversations, and the always timely reviews. MDN has consistently
demonstrated the ideal form of an open-source project.

Joshua Chen (MDN contributor)



MDN Web Docs has the most up-to-date and accurate information and the
content is presented in an easy-to-understand manner. I also like that it's
available in many languages (very important!).

Yuji (MDN contributor)



There are millions of web developers in China, and many of them begin their
developer journey at MDN Web Docs. Contributing to MDN Web Docs is an
excellent way to help people who are starting out.

YiTao Yin (MDN contributor)


If you wish to be a part of the featured contributors here,
let us know. If you’re featured here
and would like to opt-out,
please file an issue on GitHub.Learn how to get startedWe collaborate on GitHub, our project's home, on
various tasks such as writing and improving documentation, fixing bugs, and
providing review feedback. It starts here, with you. Want to start right away,
but not sure how? Follow
our guide
to make your first contribution.
Watch this video on
how to get started with contributing to MDN.
Video from the community team on contributing to MDNJoin us in shaping a better webBecome part of this globally cherished group that’s dedicated to documenting web
technologies. Whether you’re an expert or a beginner, there’s a place for you in
our inclusive community. Check out some of the ways you can contribute and
engage.


Fix issues
Submit pull requests to fix reported issues.
Squash bugs


Improve content
Fix inaccuracies and fill in missing information.
Start writing


Localize content
Participate in translating content into one of our supported languages.
Find your locale


Answer questions
Share your knowledge and expertise and guide fellow learners.
Help on Discord

Help us fix open issuesNew to MDN or open-source projects? Tackle our beginner-friendly issues to help
improve MDN.TitleRepositoryJoin the conversation

Chat with us on Discord
Connect with the community. Engage with domain experts. Help others learn.
Join MDN Discord


Join our Community Call
Every month, get exclusive updates from the MDN team. Share your ideas and
contributions.
RSVP to the next community call


While working in Mozilla spaces and communities, please adhere to the
Mozilla Community Participation Guidelines,
which promote respect, inclusion, and a harassment-free environment for all
community members.Licensing and reuseMDN's resources are freely available under various open-source licenses. For
detailed information on reusing MDN content, check out our
Attribution and Copyright Licensing
page.\n\nMDN Community
Where web enthusiasts learn, collaborate, and create

Start contributing
Join MDN Discord



45K+ Total contributors
200+ Weekly commits
7 Language communities
MDN's community powers the webMDN’s strength comes from the passion and dedication of our global community.
Since our founding in 2005, we’ve grown into a thriving network. Together, we’ve
created a comprehensive, open, and free resource that serves web developers
across the globe. With volunteers leading translation efforts in
7 languages, we’re
truly international.Meet our contributorsWe are an open-source community dedicated to building resources for a better
web. Our diverse contributors, including developers, technical writers,
students, educators, designers, and more, come from various backgrounds and
platforms. Anyone can contribute, and each contribution strengthens our
community, driving innovation and improving this vital resource for developers
worldwide.

Join us
View all contributors



Jason Lam, 林家祥 https://github.com/JasonLamv-t Grantit
Nicolò Ribaudo https://github.com/nicolo-ribaudo Igalia
Joshua Chen https://github.com/Josh-Cena
Kimchanmin https://github.com/c17an SK Planet
Gibbeum Yoon https://github.com/givvemee
Jongha Kim https://github.com/wisedog
Qizhe ZHANG https://github.com/PassionPenguin
Artem Shibakov https://github.com/saionaro Bright Data
HoChan Lee https://github.com/hochan222 11STREET
Sangchul Lee https://github.com/1ilsang WoowaBros
Park Sunhee https://github.com/sunhpark42 WoowaBros
FU CHUNHUI https://github.com/fuchunhui Baidu
Estelle Weyl https://github.com/estelle Open Web Docs
Yitao Yin https://github.com/yin1999 Northwestern Polytechnical University
Florian Scholz https://github.com/Elchi3 Open Web Docs

Contributor spotlight


There are many other things I like about MDN: the openness of its
governance, the respect for contributors' work, the professional
conversations, and the always timely reviews. MDN has consistently
demonstrated the ideal form of an open-source project.

Joshua Chen (MDN contributor)



MDN Web Docs has the most up-to-date and accurate information and the
content is presented in an easy-to-understand manner. I also like that it's
available in many languages (very important!).

Yuji (MDN contributor)



There are millions of web developers in China, and many of them begin their
developer journey at MDN Web Docs. Contributing to MDN Web Docs is an
excellent way to help people who are starting out.

YiTao Yin (MDN contributor)


If you wish to be a part of the featured contributors here,
let us know. If you’re featured here
and would like to opt-out,
please file an issue on GitHub.Learn how to get startedWe collaborate on GitHub, our project's home, on
various tasks such as writing and improving documentation, fixing bugs, and
providing review feedback. It starts here, with you. Want to start right away,
but not sure how? Follow
our guide
to make your first contribution.
Watch this video on
how to get started with contributing to MDN.
Video from the community team on contributing to MDNJoin us in shaping a better webBecome part of this globally cherished group that’s dedicated to documenting web
technologies. Whether you’re an expert or a beginner, there’s a place for you in
our inclusive community. Check out some of the ways you can contribute and
engage.


Fix issues
Submit pull requests to fix reported issues.
Squash bugs


Improve content
Fix inaccuracies and fill in missing information.
Start writing


Localize content
Participate in translating content into one of our supported languages.
Find your locale


Answer questions
Share your knowledge and expertise and guide fellow learners.
Help on Discord

Help us fix open issuesNew to MDN or open-source projects? Tackle our beginner-friendly issues to help
improve MDN.TitleRepositoryJoin the conversation

Chat with us on Discord
Connect with the community. Engage with domain experts. Help others learn.
Join MDN Discord


Join our Community Call
Every month, get exclusive updates from the MDN team. Share your ideas and
contributions.
RSVP to the next community call


While working in Mozilla spaces and communities, please adhere to the
Mozilla Community Participation Guidelines,
which promote respect, inclusion, and a harassment-free environment for all
community members.Licensing and reuseMDN's resources are freely available under various open-source licenses. For
detailed information on reusing MDN content, check out our
Attribution and Copyright Licensing
page.\n\n\n\n\n\nLearn web developmentThe essential skill set for new front-end developersWelcome to MDN Learning Web Development (also known as Learn). This resource provides a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer, along with challenges and further recommended resources.About Learn web development

Teaches the essential skills and knowledge every front-end developer needs for career success and industry relevance, as defined in the MDN Curriculum.


Created by the MDN community and refined with insights from students, educators, and developers from the broader web community.


Designed to take you from "beginner" to "comfortable" (not "beginner" to "expert"), giving you enough knowledge to use more advanced resources (such as the rest of MDN).



Note:
Last updated: December 2024 (see changelog).
Don't know where to get started?
Never coded before?

Our Getting started modules provide setup tutorials and essential concepts and background information for complete beginners. You should start here if you are a complete beginner (i.e., you've not installed a code editor or written any code yet).

Want to master the essentials?

Our Core modules provide a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer.

Beyond the basics?

Our Extension modules cover useful additional skills to learn as you start to expand your knowledge and develop specialisms. Go onto these after you finish our Core.

Working at a school?

Use our modules to guide your teaching, check out our Educators page for more ideas, or enroll your students in Scrimba's Frontend Developer Career PathMDN learning partner.

Getting our code examplesThe code examples you'll encounter in the Learning Area are all available on GitHub:

The easiest way to get them is to download a ZIP of the latest main code branch.
If you are familiar with Git and GitHub, you could also choose to clone the repository.
Contact usIf you want to get in touch with us about anything, use the communication channels. We'd love to hear from you about anything you think is wrong or missing on the site, requests for new learning topics, requests for help with items you don't understand, or any other questions or concerns.
If you're interested in helping develop/improve the content, take a look at how you can help and get in touch! We are more than happy to talk to you, whether you are a learner, teacher, experienced web developer, or someone else interested in helping to improve the learning experience.See also
The Frontend Developer Career Path MDN learning partner

Scrimba's Frontend Developer Career Path teaches all you need to know to be a competent front-end web developer, with fun interactive lessons and challenges, knowledgeable teachers, and a supportive community. Go from zero to landing your first front-end job! Many of the course components are available as standalone free versions.

Codecademy

A great interactive site for learning programming languages from scratch.

freeCodeCamp.org

Interactive site with tutorials and projects to learn web development.

Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.\n\nLearn web developmentThe essential skill set for new front-end developersWelcome to MDN Learning Web Development (also known as Learn). This resource provides a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer, along with challenges and further recommended resources.About Learn web development

Teaches the essential skills and knowledge every front-end developer needs for career success and industry relevance, as defined in the MDN Curriculum.


Created by the MDN community and refined with insights from students, educators, and developers from the broader web community.


Designed to take you from "beginner" to "comfortable" (not "beginner" to "expert"), giving you enough knowledge to use more advanced resources (such as the rest of MDN).



Note:
Last updated: December 2024 (see changelog).
Don't know where to get started?
Never coded before?

Our Getting started modules provide setup tutorials and essential concepts and background information for complete beginners. You should start here if you are a complete beginner (i.e., you've not installed a code editor or written any code yet).

Want to master the essentials?

Our Core modules provide a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer.

Beyond the basics?

Our Extension modules cover useful additional skills to learn as you start to expand your knowledge and develop specialisms. Go onto these after you finish our Core.

Working at a school?

Use our modules to guide your teaching, check out our Educators page for more ideas, or enroll your students in Scrimba's Frontend Developer Career PathMDN learning partner.

Getting our code examplesThe code examples you'll encounter in the Learning Area are all available on GitHub:

The easiest way to get them is to download a ZIP of the latest main code branch.
If you are familiar with Git and GitHub, you could also choose to clone the repository.
Contact usIf you want to get in touch with us about anything, use the communication channels. We'd love to hear from you about anything you think is wrong or missing on the site, requests for new learning topics, requests for help with items you don't understand, or any other questions or concerns.
If you're interested in helping develop/improve the content, take a look at how you can help and get in touch! We are more than happy to talk to you, whether you are a learner, teacher, experienced web developer, or someone else interested in helping to improve the learning experience.See also
The Frontend Developer Career Path MDN learning partner

Scrimba's Frontend Developer Career Path teaches all you need to know to be a competent front-end web developer, with fun interactive lessons and challenges, knowledgeable teachers, and a supportive community. Go from zero to landing your first front-end job! Many of the course components are available as standalone free versions.

Codecademy

A great interactive site for learning programming languages from scratch.

freeCodeCamp.org

Interactive site with tutorials and projects to learn web development.

Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 28, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nLearn web developmentThe essential skill set for new front-end developersWelcome to MDN Learning Web Development (also known as Learn). This resource provides a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer, along with challenges and further recommended resources.About Learn web development

Teaches the essential skills and knowledge every front-end developer needs for career success and industry relevance, as defined in the MDN Curriculum.


Created by the MDN community and refined with insights from students, educators, and developers from the broader web community.


Designed to take you from "beginner" to "comfortable" (not "beginner" to "expert"), giving you enough knowledge to use more advanced resources (such as the rest of MDN).



Note:
Last updated: December 2024 (see changelog).
Don't know where to get started?
Never coded before?

Our Getting started modules provide setup tutorials and essential concepts and background information for complete beginners. You should start here if you are a complete beginner (i.e., you've not installed a code editor or written any code yet).

Want to master the essentials?

Our Core modules provide a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer.

Beyond the basics?

Our Extension modules cover useful additional skills to learn as you start to expand your knowledge and develop specialisms. Go onto these after you finish our Core.

Working at a school?

Use our modules to guide your teaching, check out our Educators page for more ideas, or enroll your students in Scrimba's Frontend Developer Career PathMDN learning partner.

Getting our code examplesThe code examples you'll encounter in the Learning Area are all available on GitHub:

The easiest way to get them is to download a ZIP of the latest main code branch.
If you are familiar with Git and GitHub, you could also choose to clone the repository.
Contact usIf you want to get in touch with us about anything, use the communication channels. We'd love to hear from you about anything you think is wrong or missing on the site, requests for new learning topics, requests for help with items you don't understand, or any other questions or concerns.
If you're interested in helping develop/improve the content, take a look at how you can help and get in touch! We are more than happy to talk to you, whether you are a learner, teacher, experienced web developer, or someone else interested in helping to improve the learning experience.See also
The Frontend Developer Career Path MDN learning partner

Scrimba's Frontend Developer Career Path teaches all you need to know to be a competent front-end web developer, with fun interactive lessons and challenges, knowledgeable teachers, and a supportive community. Go from zero to landing your first front-end job! Many of the course components are available as standalone free versions.

Codecademy

A great interactive site for learning programming languages from scratch.

freeCodeCamp.org

Interactive site with tutorials and projects to learn web development.

Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 28, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nAttribution and copyright licensingMDN Web Docs content is available free of charge and is available under various open-source licenses.Using MDN Web Docs contentThis section covers the types of content we provide and the copyrights and licenses that are in effect for each type if you choose to reuse any of it.Documentation
Note:
The content on MDN Web Docs has been prepared with the contributions of authors from both inside and outside Mozilla. Unless otherwise indicated, the content is available under the terms of the Creative Commons Attribution-ShareAlike license (CC-BY-SA), v2.5 or any later version.

Your reuse of the content here is published under the same license as the original content – CC-BY-SA v2.5 or any later version.
When reusing the content on MDN Web Docs, you need to ensure that attribution is given to the material as well as to "Mozilla Contributors".
Good attribution is the title of the document, with a hyperlink (online) or URL (in print) to the specific page of the content being sourced, and any modifications you've made briefly described.
For example, to provide attribution for this page, you can write:

"Attributions and copyright licensing" by Mozilla Contributors, licensed under CC-BY-SA 2.5.

You may also want to link "Mozilla Contributors" to a contributors.txt file linked in the page footer you're referencing for a list of authors, if reasonable.
See Recommended practices for attribution for more details.Code samplesCode samples added on or after August 20, 2010 are in the public domain CC0. No licensing notice is necessary but if you need one, you can use: Any copyright is dedicated to the Public Domain: https://creativecommons.org/publicdomain/zero/1.0/
Code samples added before August 20, 2010 are available under the MIT license; you should insert the following attribution information into the MIT template: "© <date of last wiki page revision> <name of person who put it in the wiki>".
Since the launch of the new Yari MDN platform on December 14 2020, there is currently no way to determine which one you need. We are working on this and will update this content soon. Your contributionsIf you wish to contribute to MDN Web Docs, you agree that your documentation is available under the Attribution-ShareAlike license (or occasionally an alternative license already specified by the page you are editing) and that your code samples are available under Creative Commons CC-0 (a Public Domain dedication).

Warning:
No new pages may be created using alternate licenses.

Copyright for contributed materials remains with the author unless the author assigns it to someone else.
If you have any questions or concerns about anything discussed here, please contact the MDN Web Docs team.Logos, trademarks, service marks, and wordmarksThe rights in the logos, trademarks, and service marks of the Mozilla Foundation, as well as the look and feel of this website, are not licensed under the Creative Commons license, and to the extent they are works of authorship (like logos and graphic design), they are not included in the work that is licensed under those terms. If you use the text of documents and wish to also use any of these rights, or if you have any other questions about complying with our licensing terms for this collection, you should contact the Mozilla Foundation here: licensing@mozilla.org.Using content from elsewhere on MDN Web DocsIn general, we do not approve of copying content from other sources and putting it on MDN.
MDN should be made up of original content wherever possible.
If we receive a pull request and discover that it contains plagiarized content, we will close it and request that the submitter resubmit the change with the content rewritten into their own words.Reusing or republishing your content on MDN
Note:
Unless there is a good reason to republish the content, we will probably say "no".
The MDN writing team's decision is final.

If someone wants to donate an article to MDN that they previously published on their blog or it makes sense to copy a complex reference sheet to MDN, there may be justification for republishing it. For these cases, discuss your plan with the MDN team beforehand:

Create a GitHub issue that explains your intention.

Describe what you would like to copy or republish.
Provide a URL to the resource.
Explain why you think it's appropriate.



If the content is published under a closed license:

If you hold the rights to the content, state this and your express agreement to republish it on MDN.
If you do not hold the rights to the content, include the author/publisher on the issue if possible, or include details of how they could be contacted so we can ask them for permission to republish the content.

If the content is published under an open license:

Say what it is, and link to the license so we can check whether it is compatible with MDN's license.
Linking to MDN Web Docs articlesWe regularly get users asking us questions about how to link to MDN Web Docs and whether or not it is even allowed. The short answer is: yes, you can link to MDN Web Docs! Not only is the hypertext link the essence of the web, it is both a way to point your users to valuable resources as well as a show of trust toward the work our community does.\n\nAttribution and copyright licensingMDN Web Docs content is available free of charge and is available under various open-source licenses.Using MDN Web Docs contentThis section covers the types of content we provide and the copyrights and licenses that are in effect for each type if you choose to reuse any of it.Documentation
Note:
The content on MDN Web Docs has been prepared with the contributions of authors from both inside and outside Mozilla. Unless otherwise indicated, the content is available under the terms of the Creative Commons Attribution-ShareAlike license (CC-BY-SA), v2.5 or any later version.

Your reuse of the content here is published under the same license as the original content – CC-BY-SA v2.5 or any later version.
When reusing the content on MDN Web Docs, you need to ensure that attribution is given to the material as well as to "Mozilla Contributors".
Good attribution is the title of the document, with a hyperlink (online) or URL (in print) to the specific page of the content being sourced, and any modifications you've made briefly described.
For example, to provide attribution for this page, you can write:

"Attributions and copyright licensing" by Mozilla Contributors, licensed under CC-BY-SA 2.5.

You may also want to link "Mozilla Contributors" to a contributors.txt file linked in the page footer you're referencing for a list of authors, if reasonable.
See Recommended practices for attribution for more details.Code samplesCode samples added on or after August 20, 2010 are in the public domain CC0. No licensing notice is necessary but if you need one, you can use: Any copyright is dedicated to the Public Domain: https://creativecommons.org/publicdomain/zero/1.0/
Code samples added before August 20, 2010 are available under the MIT license; you should insert the following attribution information into the MIT template: "© <date of last wiki page revision> <name of person who put it in the wiki>".
Since the launch of the new Yari MDN platform on December 14 2020, there is currently no way to determine which one you need. We are working on this and will update this content soon. Your contributionsIf you wish to contribute to MDN Web Docs, you agree that your documentation is available under the Attribution-ShareAlike license (or occasionally an alternative license already specified by the page you are editing) and that your code samples are available under Creative Commons CC-0 (a Public Domain dedication).

Warning:
No new pages may be created using alternate licenses.

Copyright for contributed materials remains with the author unless the author assigns it to someone else.
If you have any questions or concerns about anything discussed here, please contact the MDN Web Docs team.Logos, trademarks, service marks, and wordmarksThe rights in the logos, trademarks, and service marks of the Mozilla Foundation, as well as the look and feel of this website, are not licensed under the Creative Commons license, and to the extent they are works of authorship (like logos and graphic design), they are not included in the work that is licensed under those terms. If you use the text of documents and wish to also use any of these rights, or if you have any other questions about complying with our licensing terms for this collection, you should contact the Mozilla Foundation here: licensing@mozilla.org.Using content from elsewhere on MDN Web DocsIn general, we do not approve of copying content from other sources and putting it on MDN.
MDN should be made up of original content wherever possible.
If we receive a pull request and discover that it contains plagiarized content, we will close it and request that the submitter resubmit the change with the content rewritten into their own words.Reusing or republishing your content on MDN
Note:
Unless there is a good reason to republish the content, we will probably say "no".
The MDN writing team's decision is final.

If someone wants to donate an article to MDN that they previously published on their blog or it makes sense to copy a complex reference sheet to MDN, there may be justification for republishing it. For these cases, discuss your plan with the MDN team beforehand:

Create a GitHub issue that explains your intention.

Describe what you would like to copy or republish.
Provide a URL to the resource.
Explain why you think it's appropriate.



If the content is published under a closed license:

If you hold the rights to the content, state this and your express agreement to republish it on MDN.
If you do not hold the rights to the content, include the author/publisher on the issue if possible, or include details of how they could be contacted so we can ask them for permission to republish the content.

If the content is published under an open license:

Say what it is, and link to the license so we can check whether it is compatible with MDN's license.
Linking to MDN Web Docs articlesWe regularly get users asking us questions about how to link to MDN Web Docs and whether or not it is even allowed. The short answer is: yes, you can link to MDN Web Docs! Not only is the hypertext link the essence of the web, it is both a way to point your users to valuable resources as well as a show of trust toward the work our community does.Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 19, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nAttribution and copyright licensingMDN Web Docs content is available free of charge and is available under various open-source licenses.Using MDN Web Docs contentThis section covers the types of content we provide and the copyrights and licenses that are in effect for each type if you choose to reuse any of it.Documentation
Note:
The content on MDN Web Docs has been prepared with the contributions of authors from both inside and outside Mozilla. Unless otherwise indicated, the content is available under the terms of the Creative Commons Attribution-ShareAlike license (CC-BY-SA), v2.5 or any later version.

Your reuse of the content here is published under the same license as the original content – CC-BY-SA v2.5 or any later version.
When reusing the content on MDN Web Docs, you need to ensure that attribution is given to the material as well as to "Mozilla Contributors".
Good attribution is the title of the document, with a hyperlink (online) or URL (in print) to the specific page of the content being sourced, and any modifications you've made briefly described.
For example, to provide attribution for this page, you can write:

"Attributions and copyright licensing" by Mozilla Contributors, licensed under CC-BY-SA 2.5.

You may also want to link "Mozilla Contributors" to a contributors.txt file linked in the page footer you're referencing for a list of authors, if reasonable.
See Recommended practices for attribution for more details.Code samplesCode samples added on or after August 20, 2010 are in the public domain CC0. No licensing notice is necessary but if you need one, you can use: Any copyright is dedicated to the Public Domain: https://creativecommons.org/publicdomain/zero/1.0/
Code samples added before August 20, 2010 are available under the MIT license; you should insert the following attribution information into the MIT template: "© <date of last wiki page revision> <name of person who put it in the wiki>".
Since the launch of the new Yari MDN platform on December 14 2020, there is currently no way to determine which one you need. We are working on this and will update this content soon. Your contributionsIf you wish to contribute to MDN Web Docs, you agree that your documentation is available under the Attribution-ShareAlike license (or occasionally an alternative license already specified by the page you are editing) and that your code samples are available under Creative Commons CC-0 (a Public Domain dedication).

Warning:
No new pages may be created using alternate licenses.

Copyright for contributed materials remains with the author unless the author assigns it to someone else.
If you have any questions or concerns about anything discussed here, please contact the MDN Web Docs team.Logos, trademarks, service marks, and wordmarksThe rights in the logos, trademarks, and service marks of the Mozilla Foundation, as well as the look and feel of this website, are not licensed under the Creative Commons license, and to the extent they are works of authorship (like logos and graphic design), they are not included in the work that is licensed under those terms. If you use the text of documents and wish to also use any of these rights, or if you have any other questions about complying with our licensing terms for this collection, you should contact the Mozilla Foundation here: licensing@mozilla.org.Using content from elsewhere on MDN Web DocsIn general, we do not approve of copying content from other sources and putting it on MDN.
MDN should be made up of original content wherever possible.
If we receive a pull request and discover that it contains plagiarized content, we will close it and request that the submitter resubmit the change with the content rewritten into their own words.Reusing or republishing your content on MDN
Note:
Unless there is a good reason to republish the content, we will probably say "no".
The MDN writing team's decision is final.

If someone wants to donate an article to MDN that they previously published on their blog or it makes sense to copy a complex reference sheet to MDN, there may be justification for republishing it. For these cases, discuss your plan with the MDN team beforehand:

Create a GitHub issue that explains your intention.

Describe what you would like to copy or republish.
Provide a URL to the resource.
Explain why you think it's appropriate.



If the content is published under a closed license:

If you hold the rights to the content, state this and your express agreement to republish it on MDN.
If you do not hold the rights to the content, include the author/publisher on the issue if possible, or include details of how they could be contacted so we can ask them for permission to republish the content.

If the content is published under an open license:

Say what it is, and link to the license so we can check whether it is compatible with MDN's license.
Linking to MDN Web Docs articlesWe regularly get users asking us questions about how to link to MDN Web Docs and whether or not it is even allowed. The short answer is: yes, you can link to MDN Web Docs! Not only is the hypertext link the essence of the web, it is both a way to point your users to valuable resources as well as a show of trust toward the work our community does.Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 19, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nResources for Developers, by DevelopersDocumenting web technologies, including CSS, HTML, and JavaScript, since 2005.Search MDNClear search inputSearchFeatured articlesBlogJavaScript Temporal is comingA new way to handle dates and times is being added to JavaScript. Let's take a look at Temporal, what problems it solves, the current state, and what you'll find in the new documentation about it on MDN.
CSSCSS anchor positioningThe CSS anchor positioning module defines features that allow you to tether elements together. Certain elements are defined as anchor elements; anchor-positioned elements can then have their size and position set based on the size and location of the anchor elements to which they are bound.
Web APIsUsing the View Transition APIThis article explains the theory behind how the View Transition API works, how to create view transitions and customize the transition animations, and how to manipulate active view transitions. This covers view transitions for both DOM state updates in a single-page app (SPA), and navigating between documents in a multi-page app (MPA).
JavaScriptTemporalThe Temporal object enables date and time management in various scenarios, including built-in time zone and calendar representation, wall-clock time conversions, arithmetics, formatting, and more. It is designed as a full replacement for the Date object.
Latest newsMDN 2024 content projectsdeveloper.mozilla.org4 months agoA new learning experience on MDNdeveloper.mozilla.org4 months agoIntroducing the new MDN Community pagedeveloper.mozilla.org6 months agoRecent contributions[zh-cn]: update the translation of CSS writing modesmdn/translated-content19 hours ago2025/03/22 時点の英語版に同期mdn/translated-content12 hours ago2025/04/10 時点の英語版に同期mdn/translated-content12 hours agoBump autocorrect-node from 2.13.3 to 2.14.0mdn/translated-content11 hours agoBump lefthook from 1.11.11 to 1.11.12mdn/translated-content11 hours agoUse proper ellipsis charactermdn/content9 hours agoBump cspell from 8.19.2 to 8.19.3mdn/content9 hours agoBump lefthook from 1.11.11 to 1.11.12mdn/content8 hours agoFix plaindate.compare return value explanationmdn/content7 hours agoAdd HTML attribute templatemdn/contentan hour agoContributor SpotlightYash Raj BhartiMDN resonates with my passion to build a consistent and open web, where developers can learn and grow.Get involved →\n\nResources for Developers, by DevelopersDocumenting web technologies, including CSS, HTML, and JavaScript, since 2005.Search MDNClear search inputSearchFeatured articlesBlogJavaScript Temporal is comingA new way to handle dates and times is being added to JavaScript. Let's take a look at Temporal, what problems it solves, the current state, and what you'll find in the new documentation about it on MDN.
CSSCSS anchor positioningThe CSS anchor positioning module defines features that allow you to tether elements together. Certain elements are defined as anchor elements; anchor-positioned elements can then have their size and position set based on the size and location of the anchor elements to which they are bound.
Web APIsUsing the View Transition APIThis article explains the theory behind how the View Transition API works, how to create view transitions and customize the transition animations, and how to manipulate active view transitions. This covers view transitions for both DOM state updates in a single-page app (SPA), and navigating between documents in a multi-page app (MPA).
JavaScriptTemporalThe Temporal object enables date and time management in various scenarios, including built-in time zone and calendar representation, wall-clock time conversions, arithmetics, formatting, and more. It is designed as a full replacement for the Date object.
Latest newsMDN 2024 content projectsdeveloper.mozilla.org4 months agoA new learning experience on MDNdeveloper.mozilla.org4 months agoIntroducing the new MDN Community pagedeveloper.mozilla.org6 months agoRecent contributions[zh-cn]: update the translation of CSS writing modesmdn/translated-content19 hours ago2025/03/22 時点の英語版に同期mdn/translated-content12 hours ago2025/04/10 時点の英語版に同期mdn/translated-content12 hours agoBump autocorrect-node from 2.13.3 to 2.14.0mdn/translated-content11 hours agoBump lefthook from 1.11.11 to 1.11.12mdn/translated-content11 hours agoUse proper ellipsis charactermdn/content9 hours agoBump cspell from 8.19.2 to 8.19.3mdn/content9 hours agoBump lefthook from 1.11.11 to 1.11.12mdn/content8 hours agoFix plaindate.compare return value explanationmdn/content7 hours agoAdd HTML attribute templatemdn/contentan hour agoContributor SpotlightYash Raj BhartiMDN resonates with my passion to build a consistent and open web, where developers can learn and grow.Get involved →\n\n\n\nResources for Developers, by DevelopersDocumenting web technologies, including CSS, HTML, and JavaScript, since 2005.Search MDNClear search inputSearchFeatured articlesBlogJavaScript Temporal is comingA new way to handle dates and times is being added to JavaScript. Let's take a look at Temporal, what problems it solves, the current state, and what you'll find in the new documentation about it on MDN.
CSSCSS anchor positioningThe CSS anchor positioning module defines features that allow you to tether elements together. Certain elements are defined as anchor elements; anchor-positioned elements can then have their size and position set based on the size and location of the anchor elements to which they are bound.
Web APIsUsing the View Transition APIThis article explains the theory behind how the View Transition API works, how to create view transitions and customize the transition animations, and how to manipulate active view transitions. This covers view transitions for both DOM state updates in a single-page app (SPA), and navigating between documents in a multi-page app (MPA).
JavaScriptTemporalThe Temporal object enables date and time management in various scenarios, including built-in time zone and calendar representation, wall-clock time conversions, arithmetics, formatting, and more. It is designed as a full replacement for the Date object.
Latest newsMDN 2024 content projectsdeveloper.mozilla.org4 months agoA new learning experience on MDNdeveloper.mozilla.org4 months agoIntroducing the new MDN Community pagedeveloper.mozilla.org6 months agoRecent contributions[zh-cn]: update the translation of CSS writing modesmdn/translated-content19 hours ago2025/03/22 時点の英語版に同期mdn/translated-content12 hours ago2025/04/10 時点の英語版に同期mdn/translated-content12 hours agoBump autocorrect-node from 2.13.3 to 2.14.0mdn/translated-content11 hours agoBump lefthook from 1.11.11 to 1.11.12mdn/translated-content11 hours agoUse proper ellipsis charactermdn/content9 hours agoBump cspell from 8.19.2 to 8.19.3mdn/content9 hours agoBump lefthook from 1.11.11 to 1.11.12mdn/content8 hours agoFix plaindate.compare return value explanationmdn/content7 hours agoAdd HTML attribute templatemdn/contentan hour agoContributor SpotlightYash Raj BhartiMDN resonates with my passion to build a consistent and open web, where developers can learn and grow.Get involved →\n\nResources for Developers, by DevelopersDocumenting web technologies, including CSS, HTML, and JavaScript, since 2005.Search MDNClear search inputSearchFeatured articlesBlogJavaScript Temporal is comingA new way to handle dates and times is being added to JavaScript. Let's take a look at Temporal, what problems it solves, the current state, and what you'll find in the new documentation about it on MDN.
CSSCSS anchor positioningThe CSS anchor positioning module defines features that allow you to tether elements together. Certain elements are defined as anchor elements; anchor-positioned elements can then have their size and position set based on the size and location of the anchor elements to which they are bound.
Web APIsUsing the View Transition APIThis article explains the theory behind how the View Transition API works, how to create view transitions and customize the transition animations, and how to manipulate active view transitions. This covers view transitions for both DOM state updates in a single-page app (SPA), and navigating between documents in a multi-page app (MPA).
JavaScriptTemporalThe Temporal object enables date and time management in various scenarios, including built-in time zone and calendar representation, wall-clock time conversions, arithmetics, formatting, and more. It is designed as a full replacement for the Date object.
Latest newsMDN 2024 content projectsdeveloper.mozilla.org4 months agoA new learning experience on MDNdeveloper.mozilla.org4 months agoIntroducing the new MDN Community pagedeveloper.mozilla.org6 months agoRecent contributions[zh-cn]: update the translation of CSS writing modesmdn/translated-content19 hours ago2025/03/22 時点の英語版に同期mdn/translated-content12 hours ago2025/04/10 時点の英語版に同期mdn/translated-content12 hours agoBump autocorrect-node from 2.13.3 to 2.14.0mdn/translated-content11 hours agoBump lefthook from 1.11.11 to 1.11.12mdn/translated-content11 hours agoUse proper ellipsis charactermdn/content9 hours agoBump cspell from 8.19.2 to 8.19.3mdn/content9 hours agoBump lefthook from 1.11.11 to 1.11.12mdn/content8 hours agoFix plaindate.compare return value explanationmdn/content7 hours agoAdd HTML attribute templatemdn/contentan hour agoContributor SpotlightYash Raj BhartiMDN resonates with my passion to build a consistent and open web, where developers can learn and grow.Get involved →\n\n\n\n\n\n