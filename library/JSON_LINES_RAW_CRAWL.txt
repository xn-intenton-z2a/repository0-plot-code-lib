JSON Lines
          Documentation for the JSON Lines text file format
        
        
          
            Home
            Examples
            Validator
            On the web
            json.org
          
        
        
        
          
            This page describes the JSON Lines text format, also called newline-delimited JSON.
            JSON Lines is a convenient format for storing structured data that may be processed
            one record at a time. It works well with unix-style text processing tools and shell
            pipelines. It's a great format for log files. It's also a flexible format for passing
            messages between cooperating processes.
          
          
            The JSON Lines format has three requirements:
          
          
            
            1. UTF-8 Encoding
          
          
            JSON allows encoding Unicode strings with only ASCII escape sequences, however those
            escapes will be hard to read when viewed in a text editor. The author of the JSON Lines
            file may choose to escape characters to work with plain ASCII files.
          
          
            Encodings other than UTF-8 are very unlikely to be valid when decoded as UTF-8 so the chance
            of accidentally misinterpreting characters
            in JSON Lines files is low.
          
          
            Like the JSON standard a byte order mark (U+FEFF) must NOT be included.
          
          
            
            2. Each Line is a Valid JSON Value
          
          
            The most common values will be objects or arrays, but any JSON value is permitted.
          
          
            See json.org for a definition of JSON values.
          
          
            
            3. Line Separator is '\n'
          
          
            This means '\r\n' is also supported because surrounding white space is
            implicitly ignored when parsing JSON values.
          
          
            The last character in a file following the last JSON value may be a line separator.
            In this case the line separator does not indicate the start of another JSON value.
          
          
            
            4. Suggested Conventions
          
          
            JSON Lines files may be saved with the file extension .jsonl.
          
          
            Stream compressors like gzip or bzip2 are recommended for
            saving space, resulting in .jsonl.gz or .jsonl.bz2 files.
          
          
            MIME type may be application/jsonl, but this is not yet standardized; any help
            writing the RFC would be greatly appreciated (see issue).
          
          
            Text editing programs call the first line of a text file "line 1". The first value in a
            JSON Lines file should also be called "value 1".
          
        
        
          Report a bug or make a suggestion •
          Tactile theme by Jason Long •
          This page is maintained by Ian Ward.\nJSON Lines
          Documentation for the JSON Lines text file format
        
        
          
            Home
            Examples
            Validator
            On the web
            json.org
          
        
        
        
          
            This page describes the JSON Lines text format, also called newline-delimited JSON.
            JSON Lines is a convenient format for storing structured data that may be processed
            one record at a time. It works well with unix-style text processing tools and shell
            pipelines. It's a great format for log files. It's also a flexible format for passing
            messages between cooperating processes.
          
          
            The JSON Lines format has three requirements:
          
          
            
            1. UTF-8 Encoding
          
          
            JSON allows encoding Unicode strings with only ASCII escape sequences, however those
            escapes will be hard to read when viewed in a text editor. The author of the JSON Lines
            file may choose to escape characters to work with plain ASCII files.
          
          
            Encodings other than UTF-8 are very unlikely to be valid when decoded as UTF-8 so the chance
            of accidentally misinterpreting characters
            in JSON Lines files is low.
          
          
            Like the JSON standard a byte order mark (U+FEFF) must NOT be included.
          
          
            
            2. Each Line is a Valid JSON Value
          
          
            The most common values will be objects or arrays, but any JSON value is permitted.
          
          
            See json.org for a definition of JSON values.
          
          
            
            3. Line Separator is '\n'
          
          
            This means '\r\n' is also supported because surrounding white space is
            implicitly ignored when parsing JSON values.
          
          
            The last character in a file following the last JSON value may be a line separator.
            In this case the line separator does not indicate the start of another JSON value.
          
          
            
            4. Suggested Conventions
          
          
            JSON Lines files may be saved with the file extension .jsonl.
          
          
            Stream compressors like gzip or bzip2 are recommended for
            saving space, resulting in .jsonl.gz or .jsonl.bz2 files.
          
          
            MIME type may be application/jsonl, but this is not yet standardized; any help
            writing the RFC would be greatly appreciated (see issue).
          
          
            Text editing programs call the first line of a text file "line 1". The first value in a
            JSON Lines file should also be called "value 1".
          
        
        
          Report a bug or make a suggestion •
          Tactile theme by Jason Long •
          This page is maintained by Ian Ward.\nDocumentation for the JSON Lines text file format\nThis page describes the JSON Lines text format, also called newline-delimited JSON.
            JSON Lines is a convenient format for storing structured data that may be processed
            one record at a time. It works well with unix-style text processing tools and shell
            pipelines. It's a great format for log files. It's also a flexible format for passing
            messages between cooperating processes.\nThe JSON Lines format has three requirements:\nJSON allows encoding Unicode strings with only ASCII escape sequences, however those
            escapes will be hard to read when viewed in a text editor. The author of the JSON Lines
            file may choose to escape characters to work with plain ASCII files.\nEncodings other than UTF-8 are very unlikely to be valid when decoded as UTF-8 so the chance
            of accidentally misinterpreting characters
            in JSON Lines files is low.\naccidentally misinterpreting characters\nLike the JSON standard a byte order mark (U+FEFF) must NOT be included.\na byte order mark (U+FEFF) must NOT be included\n2. Each Line is a Valid JSON Value\nThe most common values will be objects or arrays, but any JSON value is permitted.\nSee json.org for a definition of JSON values.\n3. Line Separator is '\n'\nThis means '\r\n' is also supported because surrounding white space is
            implicitly ignored when parsing JSON values.\nThe last character in a file following the last JSON value may be a line separator.
            In this case the line separator does not indicate the start of another JSON value.\n4. Suggested Conventions\nJSON Lines files may be saved with the file extension .jsonl.\nStream compressors like gzip or bzip2 are recommended for
            saving space, resulting in .jsonl.gz or .jsonl.bz2 files.\nMIME type may be application/jsonl, but this is not yet standardized; any help
            writing the RFC would be greatly appreciated (see issue).\nText editing programs call the first line of a text file "line 1". The first value in a
            JSON Lines file should also be called "value 1".\nReport a bug or make a suggestion\n\n\nJSON Lines
          Examples
        


Home
Examples
Validator
On the web
json.org


        

        
          
Better than CSV

["Name", "Session", "Score", "Completed"]
["Gilbert", "2013", 24, true]
["Alexa", "2013", 29, true]
["May", "2012B", 14, false]
["Deloise", "2012A", 19, true] 


          CSV seems so easy that many programmers have written code to generate it themselves, and almost every implementation is different. Handling broken CSV files is a common and frustrating task. CSV has no standard encoding, no standard column separator and multiple character escaping standards. String is the only type supported for cell values, so some programs attempt to guess the correct types.

          JSON Lines handles tabular data cleanly and without ambiguity. Cells may use the standard JSON types.

          The biggest missing piece is an import/export filter for popular spreadsheet programs so that non-programmers can use this format.

          
Self-describing data

{"name": "Gilbert", "session": "2013", "score": 24, "completed": true}
{"name": "Alexa", "session": "2013", "score": 29, "completed": true}
{"name": "May", "session": "2012B", "score": 14, "completed": false}
{"name": "Deloise", "session": "2012A", "score": 19, "completed": true} 


          JSON Lines enables applications to read objects line-by-line, with each line fully describing a JSON object.  The example above contains the same data as the tabular example above, but allows applications to split files on newline boundaries for parallel loading, and eliminates any ambiguity if fields are omitted or re-ordered.

          
Easy Nested Data

{"name": "Gilbert", "wins": [["straight", "7♣"], ["one pair", "10♥"]]}
{"name": "Alexa", "wins": [["two pair", "4♠"], ["two pair", "9♠"]]}
{"name": "May", "wins": []}
{"name": "Deloise", "wins": [["three of a kind", "5♣"]]}


        

        JSON Lines' biggest strength is in handling lots of similar nested data structures. One .jsonl file is easier to work with than a directory full of XML files.

        If you have large nested structures then reading the JSON Lines text directly isn't recommended. Use the "jq" tool to make viewing large structures easier:

grep pair winning_hands.jsonl | jq .


{
  "name": "Gilbert", 
  "wins": [
    [
      "straight", 
      "7♣"
    ], 
    [
      "one pair", 
      "10♥"
    ]
  ]
}
{
  "name": "Alexa", 
  "wins": [
    [
      "two pair", 
      "4♠"
    ], 
    [
      "two pair", 
      "9♠"
    ]
  ]
}




        
          Report a bug or make a suggestion •
          Tactile theme by Jason Long •
          This page is maintained by Ian Ward.\nJSON Lines
          Examples
        


Home
Examples
Validator
On the web
json.org


        

        
          
Better than CSV

["Name", "Session", "Score", "Completed"]
["Gilbert", "2013", 24, true]
["Alexa", "2013", 29, true]
["May", "2012B", 14, false]
["Deloise", "2012A", 19, true] 


          CSV seems so easy that many programmers have written code to generate it themselves, and almost every implementation is different. Handling broken CSV files is a common and frustrating task. CSV has no standard encoding, no standard column separator and multiple character escaping standards. String is the only type supported for cell values, so some programs attempt to guess the correct types.

          JSON Lines handles tabular data cleanly and without ambiguity. Cells may use the standard JSON types.

          The biggest missing piece is an import/export filter for popular spreadsheet programs so that non-programmers can use this format.

          
Self-describing data

{"name": "Gilbert", "session": "2013", "score": 24, "completed": true}
{"name": "Alexa", "session": "2013", "score": 29, "completed": true}
{"name": "May", "session": "2012B", "score": 14, "completed": false}
{"name": "Deloise", "session": "2012A", "score": 19, "completed": true} 


          JSON Lines enables applications to read objects line-by-line, with each line fully describing a JSON object.  The example above contains the same data as the tabular example above, but allows applications to split files on newline boundaries for parallel loading, and eliminates any ambiguity if fields are omitted or re-ordered.

          
Easy Nested Data

{"name": "Gilbert", "wins": [["straight", "7♣"], ["one pair", "10♥"]]}
{"name": "Alexa", "wins": [["two pair", "4♠"], ["two pair", "9♠"]]}
{"name": "May", "wins": []}
{"name": "Deloise", "wins": [["three of a kind", "5♣"]]}


        

        JSON Lines' biggest strength is in handling lots of similar nested data structures. One .jsonl file is easier to work with than a directory full of XML files.

        If you have large nested structures then reading the JSON Lines text directly isn't recommended. Use the "jq" tool to make viewing large structures easier:

grep pair winning_hands.jsonl | jq .


{
  "name": "Gilbert", 
  "wins": [
    [
      "straight", 
      "7♣"
    ], 
    [
      "one pair", 
      "10♥"
    ]
  ]
}
{
  "name": "Alexa", 
  "wins": [
    [
      "two pair", 
      "4♠"
    ], 
    [
      "two pair", 
      "9♠"
    ]
  ]
}




        
          Report a bug or make a suggestion •
          Tactile theme by Jason Long •
          This page is maintained by Ian Ward.\n["Name", "Session", "Score", "Completed"]
["Gilbert", "2013", 24, true]
["Alexa", "2013", 29, true]
["May", "2012B", 14, false]
["Deloise", "2012A", 19, true]\nCSV seems so easy that many programmers have written code to generate it themselves, and almost every implementation is different. Handling broken CSV files is a common and frustrating task. CSV has no standard encoding, no standard column separator and multiple character escaping standards. String is the only type supported for cell values, so some programs attempt to guess the correct types.\nJSON Lines handles tabular data cleanly and without ambiguity. Cells may use the standard JSON types.\nThe biggest missing piece is an import/export filter for popular spreadsheet programs so that non-programmers can use this format.\n{"name": "Gilbert", "session": "2013", "score": 24, "completed": true}
{"name": "Alexa", "session": "2013", "score": 29, "completed": true}
{"name": "May", "session": "2012B", "score": 14, "completed": false}
{"name": "Deloise", "session": "2012A", "score": 19, "completed": true}\nJSON Lines enables applications to read objects line-by-line, with each line fully describing a JSON object.  The example above contains the same data as the tabular example above, but allows applications to split files on newline boundaries for parallel loading, and eliminates any ambiguity if fields are omitted or re-ordered.\n{"name": "Gilbert", "wins": [["straight", "7♣"], ["one pair", "10♥"]]}
{"name": "Alexa", "wins": [["two pair", "4♠"], ["two pair", "9♠"]]}
{"name": "May", "wins": []}
{"name": "Deloise", "wins": [["three of a kind", "5♣"]]}\nJSON Lines' biggest strength is in handling lots of similar nested data structures. One .jsonl file is easier to work with than a directory full of XML files.\nIf you have large nested structures then reading the JSON Lines text directly isn't recommended. Use the "jq" tool to make viewing large structures easier:\ngrep pair winning_hands.jsonl | jq .\n{
  "name": "Gilbert", 
  "wins": [
    [
      "straight", 
      "7♣"
    ], 
    [
      "one pair", 
      "10♥"
    ]
  ]
}
{
  "name": "Alexa", 
  "wins": [
    [
      "two pair", 
      "4♠"
    ], 
    [
      "two pair", 
      "9♠"
    ]
  ]
}\nReport a bug or make a suggestion\n\n\nJSON Lines
          Validator
        
        
          
            Home
            Examples
            Validator
            On the web
            json.org
          
        
        
        
          
          
          
          
        
        
          Report a bug or make a suggestion
          • Tactile theme by Jason Long
          • This page is maintained by Ian Ward.\nJSON Lines
          Validator
        
        
          
            Home
            Examples
            Validator
            On the web
            json.org
          
        
        
        
          
          
          
          
        
        
          Report a bug or make a suggestion
          • Tactile theme by Jason Long
          • This page is maintained by Ian Ward.\nReport a bug or make a suggestion\n\n\nJSON Lines
          On the web
        


Home
Examples
Validator
On the web
json.org


        

        

pytest-reportlog is a pytest plugin which writes testing report data in JSON lines format

NDJSON is a similar format that also allows blank lines

Bubbles supports JSON Lines datastores

Logstash supports JSON Lines via the json_lines codec

plot.ly uses JSON Lines for its streaming data API

Graylog GELF is format for log messages, their stream is de-facto JSON lines.

Scrapy is a framework for web scraping & crawling, it supports and recommends JSON lines since long -- it might've even coined the term.

ClickHouse is an open source column-oriented DBMS. It supports JSON lines as JSONEachRow format for input and output.

Dataflow kit is a web scraping open source framework written in Go. JSON Lines is one of the supported formats for storing results.

dart uses JSON Lines as one of the possible reporters when running tests.

Apache Spark uses JSONL for reading and writing JSON data.

ArangoDB is an open source multi-model database. The JSON lines format allows to import huge amounts of documents sequentially (via arangoimport).

Rumble is a JSONiq engine that runs on top of Spark. It can process datasets in the JSON lines format that have billions of objects and more.

Neo4j the open-source graph database supports JSONL export and import via its standard library procedures apoc.export/import.json to allow stream processing of nodes and relationships.

petl is a general purpose Python package for extracting, transforming and loading tables of data. It allows importing and exporting documents/records between many databases and file formats, including JSON lines, in local and remote filesystems and clouds.

BigQuery uses JSON Lines as one of the supported formats to load data into the database.

Airbyte is an open-source data integration tool that uses JSON Lines to communicate between containerized source applications that pull data from files/APIs/databses and containerized destination applications that write data to warehouses.

Shopify GraphQL Bulk Operations API, designed for very large data exports from Shopify stores, returns results in the form of a JSONL file.

CSS HTML Validator for Windows v22.0211+ now supports JSON Lines syntax checking.
          
Go Standard library's json.Encoder will produce JSON lines by default. The decoder parses Concatenated JSON, which is compatible with, though less strict than, JSON lines

Golang JSONL library

Miller supports JSON Lines format as input.

Mattermost is an open-source, self-hostable online chat service. It uses JSON Lines as the format for bulk data migration on self-hosted instances.

Mattermost is a collaboration tool and uses the JSON Lines format for bulk data import.

serde-jsonlines is a Rust library for reading & writing JSON Lines documents.

php-jsonl is a PHP library for reading & writing JSON Lines documents, taking advantage of the streaming benefits.

        
        
          Report a bug or make a suggestion •
          Tactile theme by Jason Long •
          This page is maintained by Ian Ward.\nJSON Lines
          On the web
        


Home
Examples
Validator
On the web
json.org


        

        

pytest-reportlog is a pytest plugin which writes testing report data in JSON lines format

NDJSON is a similar format that also allows blank lines

Bubbles supports JSON Lines datastores

Logstash supports JSON Lines via the json_lines codec

plot.ly uses JSON Lines for its streaming data API

Graylog GELF is format for log messages, their stream is de-facto JSON lines.

Scrapy is a framework for web scraping & crawling, it supports and recommends JSON lines since long -- it might've even coined the term.

ClickHouse is an open source column-oriented DBMS. It supports JSON lines as JSONEachRow format for input and output.

Dataflow kit is a web scraping open source framework written in Go. JSON Lines is one of the supported formats for storing results.

dart uses JSON Lines as one of the possible reporters when running tests.

Apache Spark uses JSONL for reading and writing JSON data.

ArangoDB is an open source multi-model database. The JSON lines format allows to import huge amounts of documents sequentially (via arangoimport).

Rumble is a JSONiq engine that runs on top of Spark. It can process datasets in the JSON lines format that have billions of objects and more.

Neo4j the open-source graph database supports JSONL export and import via its standard library procedures apoc.export/import.json to allow stream processing of nodes and relationships.

petl is a general purpose Python package for extracting, transforming and loading tables of data. It allows importing and exporting documents/records between many databases and file formats, including JSON lines, in local and remote filesystems and clouds.

BigQuery uses JSON Lines as one of the supported formats to load data into the database.

Airbyte is an open-source data integration tool that uses JSON Lines to communicate between containerized source applications that pull data from files/APIs/databses and containerized destination applications that write data to warehouses.

Shopify GraphQL Bulk Operations API, designed for very large data exports from Shopify stores, returns results in the form of a JSONL file.

CSS HTML Validator for Windows v22.0211+ now supports JSON Lines syntax checking.
          
Go Standard library's json.Encoder will produce JSON lines by default. The decoder parses Concatenated JSON, which is compatible with, though less strict than, JSON lines

Golang JSONL library

Miller supports JSON Lines format as input.

Mattermost is an open-source, self-hostable online chat service. It uses JSON Lines as the format for bulk data migration on self-hosted instances.

Mattermost is a collaboration tool and uses the JSON Lines format for bulk data import.

serde-jsonlines is a Rust library for reading & writing JSON Lines documents.

php-jsonl is a PHP library for reading & writing JSON Lines documents, taking advantage of the streaming benefits.

        
        
          Report a bug or make a suggestion •
          Tactile theme by Jason Long •
          This page is maintained by Ian Ward.\npytest-reportlog is a pytest plugin which writes testing report data in JSON lines format\nNDJSON is a similar format that also allows blank lines\nBubbles supports JSON Lines datastores\nLogstash supports JSON Lines via the json_lines codec\nplot.ly uses JSON Lines for its streaming data API\nGraylog GELF is format for log messages, their stream is de-facto JSON lines.\nScrapy is a framework for web scraping & crawling, it supports and recommends JSON lines since long -- it might've even coined the term.\nit might've even coined the term\nClickHouse is an open source column-oriented DBMS. It supports JSON lines as JSONEachRow format for input and output.\nDataflow kit is a web scraping open source framework written in Go. JSON Lines is one of the supported formats for storing results.\ndart uses JSON Lines as one of the possible reporters when running tests.\nApache Spark uses JSONL for reading and writing JSON data.\nArangoDB is an open source multi-model database. The JSON lines format allows to import huge amounts of documents sequentially (via arangoimport).\nRumble is a JSONiq engine that runs on top of Spark. It can process datasets in the JSON lines format that have billions of objects and more.\nNeo4j the open-source graph database supports JSONL export and import via its standard library procedures apoc.export/import.json to allow stream processing of nodes and relationships.\napoc.export/import.json\npetl is a general purpose Python package for extracting, transforming and loading tables of data. It allows importing and exporting documents/records between many databases and file formats, including JSON lines, in local and remote filesystems and clouds.\nBigQuery uses JSON Lines as one of the supported formats to load data into the database.\nAirbyte is an open-source data integration tool that uses JSON Lines to communicate between containerized source applications that pull data from files/APIs/databses and containerized destination applications that write data to warehouses.\nShopify GraphQL Bulk Operations API, designed for very large data exports from Shopify stores, returns results in the form of a JSONL file.\nShopify GraphQL Bulk Operations API\nCSS HTML Validator for Windows v22.0211+ now supports JSON Lines syntax checking.\nCSS HTML Validator for Windows v22.0211+\nGo Standard library's json.Encoder will produce JSON lines by default. The decoder parses Concatenated JSON, which is compatible with, though less strict than, JSON lines\nGo Standard library's json.Encoder\nMiller supports JSON Lines format as input.\nMattermost is an open-source, self-hostable online chat service. It uses JSON Lines as the format for bulk data migration on self-hosted instances.\nMattermost is a collaboration tool and uses the JSON Lines format for bulk data import.\nserde-jsonlines is a Rust library for reading & writing JSON Lines documents.\nphp-jsonl is a PHP library for reading & writing JSON Lines documents, taking advantage of the streaming benefits.\nReport a bug or make a suggestion\n\n\nJSON Lines
          Documentation for the JSON Lines text file format
        
        
          
            Home
            Examples
            Validator
            On the web
            json.org
          
        
        
        
          
            This page describes the JSON Lines text format, also called newline-delimited JSON.
            JSON Lines is a convenient format for storing structured data that may be processed
            one record at a time. It works well with unix-style text processing tools and shell
            pipelines. It's a great format for log files. It's also a flexible format for passing
            messages between cooperating processes.
          
          
            The JSON Lines format has three requirements:
          
          
            
            1. UTF-8 Encoding
          
          
            JSON allows encoding Unicode strings with only ASCII escape sequences, however those
            escapes will be hard to read when viewed in a text editor. The author of the JSON Lines
            file may choose to escape characters to work with plain ASCII files.
          
          
            Encodings other than UTF-8 are very unlikely to be valid when decoded as UTF-8 so the chance
            of accidentally misinterpreting characters
            in JSON Lines files is low.
          
          
            Like the JSON standard a byte order mark (U+FEFF) must NOT be included.
          
          
            
            2. Each Line is a Valid JSON Value
          
          
            The most common values will be objects or arrays, but any JSON value is permitted.
          
          
            See json.org for a definition of JSON values.
          
          
            
            3. Line Separator is '\n'
          
          
            This means '\r\n' is also supported because surrounding white space is
            implicitly ignored when parsing JSON values.
          
          
            The last character in a file following the last JSON value may be a line separator.
            In this case the line separator does not indicate the start of another JSON value.
          
          
            
            4. Suggested Conventions
          
          
            JSON Lines files may be saved with the file extension .jsonl.
          
          
            Stream compressors like gzip or bzip2 are recommended for
            saving space, resulting in .jsonl.gz or .jsonl.bz2 files.
          
          
            MIME type may be application/jsonl, but this is not yet standardized; any help
            writing the RFC would be greatly appreciated (see issue).
          
          
            Text editing programs call the first line of a text file "line 1". The first value in a
            JSON Lines file should also be called "value 1".
          
        
        
          Report a bug or make a suggestion •
          Tactile theme by Jason Long •
          This page is maintained by Ian Ward.\nJSON Lines
          Documentation for the JSON Lines text file format
        
        
          
            Home
            Examples
            Validator
            On the web
            json.org
          
        
        
        
          
            This page describes the JSON Lines text format, also called newline-delimited JSON.
            JSON Lines is a convenient format for storing structured data that may be processed
            one record at a time. It works well with unix-style text processing tools and shell
            pipelines. It's a great format for log files. It's also a flexible format for passing
            messages between cooperating processes.
          
          
            The JSON Lines format has three requirements:
          
          
            
            1. UTF-8 Encoding
          
          
            JSON allows encoding Unicode strings with only ASCII escape sequences, however those
            escapes will be hard to read when viewed in a text editor. The author of the JSON Lines
            file may choose to escape characters to work with plain ASCII files.
          
          
            Encodings other than UTF-8 are very unlikely to be valid when decoded as UTF-8 so the chance
            of accidentally misinterpreting characters
            in JSON Lines files is low.
          
          
            Like the JSON standard a byte order mark (U+FEFF) must NOT be included.
          
          
            
            2. Each Line is a Valid JSON Value
          
          
            The most common values will be objects or arrays, but any JSON value is permitted.
          
          
            See json.org for a definition of JSON values.
          
          
            
            3. Line Separator is '\n'
          
          
            This means '\r\n' is also supported because surrounding white space is
            implicitly ignored when parsing JSON values.
          
          
            The last character in a file following the last JSON value may be a line separator.
            In this case the line separator does not indicate the start of another JSON value.
          
          
            
            4. Suggested Conventions
          
          
            JSON Lines files may be saved with the file extension .jsonl.
          
          
            Stream compressors like gzip or bzip2 are recommended for
            saving space, resulting in .jsonl.gz or .jsonl.bz2 files.
          
          
            MIME type may be application/jsonl, but this is not yet standardized; any help
            writing the RFC would be greatly appreciated (see issue).
          
          
            Text editing programs call the first line of a text file "line 1". The first value in a
            JSON Lines file should also be called "value 1".
          
        
        
          Report a bug or make a suggestion •
          Tactile theme by Jason Long •
          This page is maintained by Ian Ward.\nDocumentation for the JSON Lines text file format\nThis page describes the JSON Lines text format, also called newline-delimited JSON.
            JSON Lines is a convenient format for storing structured data that may be processed
            one record at a time. It works well with unix-style text processing tools and shell
            pipelines. It's a great format for log files. It's also a flexible format for passing
            messages between cooperating processes.\nThe JSON Lines format has three requirements:\nJSON allows encoding Unicode strings with only ASCII escape sequences, however those
            escapes will be hard to read when viewed in a text editor. The author of the JSON Lines
            file may choose to escape characters to work with plain ASCII files.\nEncodings other than UTF-8 are very unlikely to be valid when decoded as UTF-8 so the chance
            of accidentally misinterpreting characters
            in JSON Lines files is low.\naccidentally misinterpreting characters\nLike the JSON standard a byte order mark (U+FEFF) must NOT be included.\na byte order mark (U+FEFF) must NOT be included\n2. Each Line is a Valid JSON Value\nThe most common values will be objects or arrays, but any JSON value is permitted.\nSee json.org for a definition of JSON values.\n3. Line Separator is '\n'\nThis means '\r\n' is also supported because surrounding white space is
            implicitly ignored when parsing JSON values.\nThe last character in a file following the last JSON value may be a line separator.
            In this case the line separator does not indicate the start of another JSON value.\n4. Suggested Conventions\nJSON Lines files may be saved with the file extension .jsonl.\nStream compressors like gzip or bzip2 are recommended for
            saving space, resulting in .jsonl.gz or .jsonl.bz2 files.\nMIME type may be application/jsonl, but this is not yet standardized; any help
            writing the RFC would be greatly appreciated (see issue).\nText editing programs call the first line of a text file "line 1". The first value in a
            JSON Lines file should also be called "value 1".\nReport a bug or make a suggestion\n\n\nJSON Lines
          Documentation for the JSON Lines text file format
        
        
          
            Home
            Examples
            Validator
            On the web
            json.org
          
        
        
        
          
            This page describes the JSON Lines text format, also called newline-delimited JSON.
            JSON Lines is a convenient format for storing structured data that may be processed
            one record at a time. It works well with unix-style text processing tools and shell
            pipelines. It's a great format for log files. It's also a flexible format for passing
            messages between cooperating processes.
          
          
            The JSON Lines format has three requirements:
          
          
            
            1. UTF-8 Encoding
          
          
            JSON allows encoding Unicode strings with only ASCII escape sequences, however those
            escapes will be hard to read when viewed in a text editor. The author of the JSON Lines
            file may choose to escape characters to work with plain ASCII files.
          
          
            Encodings other than UTF-8 are very unlikely to be valid when decoded as UTF-8 so the chance
            of accidentally misinterpreting characters
            in JSON Lines files is low.
          
          
            Like the JSON standard a byte order mark (U+FEFF) must NOT be included.
          
          
            
            2. Each Line is a Valid JSON Value
          
          
            The most common values will be objects or arrays, but any JSON value is permitted.
          
          
            See json.org for a definition of JSON values.
          
          
            
            3. Line Separator is '\n'
          
          
            This means '\r\n' is also supported because surrounding white space is
            implicitly ignored when parsing JSON values.
          
          
            The last character in a file following the last JSON value may be a line separator.
            In this case the line separator does not indicate the start of another JSON value.
          
          
            
            4. Suggested Conventions
          
          
            JSON Lines files may be saved with the file extension .jsonl.
          
          
            Stream compressors like gzip or bzip2 are recommended for
            saving space, resulting in .jsonl.gz or .jsonl.bz2 files.
          
          
            MIME type may be application/jsonl, but this is not yet standardized; any help
            writing the RFC would be greatly appreciated (see issue).
          
          
            Text editing programs call the first line of a text file "line 1". The first value in a
            JSON Lines file should also be called "value 1".
          
        
        
          Report a bug or make a suggestion •
          Tactile theme by Jason Long •
          This page is maintained by Ian Ward.\nJSON Lines
          Documentation for the JSON Lines text file format
        
        
          
            Home
            Examples
            Validator
            On the web
            json.org
          
        
        
        
          
            This page describes the JSON Lines text format, also called newline-delimited JSON.
            JSON Lines is a convenient format for storing structured data that may be processed
            one record at a time. It works well with unix-style text processing tools and shell
            pipelines. It's a great format for log files. It's also a flexible format for passing
            messages between cooperating processes.
          
          
            The JSON Lines format has three requirements:
          
          
            
            1. UTF-8 Encoding
          
          
            JSON allows encoding Unicode strings with only ASCII escape sequences, however those
            escapes will be hard to read when viewed in a text editor. The author of the JSON Lines
            file may choose to escape characters to work with plain ASCII files.
          
          
            Encodings other than UTF-8 are very unlikely to be valid when decoded as UTF-8 so the chance
            of accidentally misinterpreting characters
            in JSON Lines files is low.
          
          
            Like the JSON standard a byte order mark (U+FEFF) must NOT be included.
          
          
            
            2. Each Line is a Valid JSON Value
          
          
            The most common values will be objects or arrays, but any JSON value is permitted.
          
          
            See json.org for a definition of JSON values.
          
          
            
            3. Line Separator is '\n'
          
          
            This means '\r\n' is also supported because surrounding white space is
            implicitly ignored when parsing JSON values.
          
          
            The last character in a file following the last JSON value may be a line separator.
            In this case the line separator does not indicate the start of another JSON value.
          
          
            
            4. Suggested Conventions
          
          
            JSON Lines files may be saved with the file extension .jsonl.
          
          
            Stream compressors like gzip or bzip2 are recommended for
            saving space, resulting in .jsonl.gz or .jsonl.bz2 files.
          
          
            MIME type may be application/jsonl, but this is not yet standardized; any help
            writing the RFC would be greatly appreciated (see issue).
          
          
            Text editing programs call the first line of a text file "line 1". The first value in a
            JSON Lines file should also be called "value 1".
          
        
        
          Report a bug or make a suggestion •
          Tactile theme by Jason Long •
          This page is maintained by Ian Ward.\nDocumentation for the JSON Lines text file format\nThis page describes the JSON Lines text format, also called newline-delimited JSON.
            JSON Lines is a convenient format for storing structured data that may be processed
            one record at a time. It works well with unix-style text processing tools and shell
            pipelines. It's a great format for log files. It's also a flexible format for passing
            messages between cooperating processes.\nThe JSON Lines format has three requirements:\nJSON allows encoding Unicode strings with only ASCII escape sequences, however those
            escapes will be hard to read when viewed in a text editor. The author of the JSON Lines
            file may choose to escape characters to work with plain ASCII files.\nEncodings other than UTF-8 are very unlikely to be valid when decoded as UTF-8 so the chance
            of accidentally misinterpreting characters
            in JSON Lines files is low.\naccidentally misinterpreting characters\nLike the JSON standard a byte order mark (U+FEFF) must NOT be included.\na byte order mark (U+FEFF) must NOT be included\n2. Each Line is a Valid JSON Value\nThe most common values will be objects or arrays, but any JSON value is permitted.\nSee json.org for a definition of JSON values.\n3. Line Separator is '\n'\nThis means '\r\n' is also supported because surrounding white space is
            implicitly ignored when parsing JSON values.\nThe last character in a file following the last JSON value may be a line separator.
            In this case the line separator does not indicate the start of another JSON value.\n4. Suggested Conventions\nJSON Lines files may be saved with the file extension .jsonl.\nStream compressors like gzip or bzip2 are recommended for
            saving space, resulting in .jsonl.gz or .jsonl.bz2 files.\nMIME type may be application/jsonl, but this is not yet standardized; any help
            writing the RFC would be greatly appreciated (see issue).\nText editing programs call the first line of a text file "line 1". The first value in a
            JSON Lines file should also be called "value 1".\nReport a bug or make a suggestion\n\n\nJSON Lines
          Documentation for the JSON Lines text file format
        
        
          
            Home
            Examples
            Validator
            On the web
            json.org
          
        
        
        
          
            This page describes the JSON Lines text format, also called newline-delimited JSON.
            JSON Lines is a convenient format for storing structured data that may be processed
            one record at a time. It works well with unix-style text processing tools and shell
            pipelines. It's a great format for log files. It's also a flexible format for passing
            messages between cooperating processes.
          
          
            The JSON Lines format has three requirements:
          
          
            
            1. UTF-8 Encoding
          
          
            JSON allows encoding Unicode strings with only ASCII escape sequences, however those
            escapes will be hard to read when viewed in a text editor. The author of the JSON Lines
            file may choose to escape characters to work with plain ASCII files.
          
          
            Encodings other than UTF-8 are very unlikely to be valid when decoded as UTF-8 so the chance
            of accidentally misinterpreting characters
            in JSON Lines files is low.
          
          
            Like the JSON standard a byte order mark (U+FEFF) must NOT be included.
          
          
            
            2. Each Line is a Valid JSON Value
          
          
            The most common values will be objects or arrays, but any JSON value is permitted.
          
          
            See json.org for a definition of JSON values.
          
          
            
            3. Line Separator is '\n'
          
          
            This means '\r\n' is also supported because surrounding white space is
            implicitly ignored when parsing JSON values.
          
          
            The last character in a file following the last JSON value may be a line separator.
            In this case the line separator does not indicate the start of another JSON value.
          
          
            
            4. Suggested Conventions
          
          
            JSON Lines files may be saved with the file extension .jsonl.
          
          
            Stream compressors like gzip or bzip2 are recommended for
            saving space, resulting in .jsonl.gz or .jsonl.bz2 files.
          
          
            MIME type may be application/jsonl, but this is not yet standardized; any help
            writing the RFC would be greatly appreciated (see issue).
          
          
            Text editing programs call the first line of a text file "line 1". The first value in a
            JSON Lines file should also be called "value 1".
          
        
        
          Report a bug or make a suggestion •
          Tactile theme by Jason Long •
          This page is maintained by Ian Ward.\nJSON Lines
          Documentation for the JSON Lines text file format
        
        
          
            Home
            Examples
            Validator
            On the web
            json.org
          
        
        
        
          
            This page describes the JSON Lines text format, also called newline-delimited JSON.
            JSON Lines is a convenient format for storing structured data that may be processed
            one record at a time. It works well with unix-style text processing tools and shell
            pipelines. It's a great format for log files. It's also a flexible format for passing
            messages between cooperating processes.
          
          
            The JSON Lines format has three requirements:
          
          
            
            1. UTF-8 Encoding
          
          
            JSON allows encoding Unicode strings with only ASCII escape sequences, however those
            escapes will be hard to read when viewed in a text editor. The author of the JSON Lines
            file may choose to escape characters to work with plain ASCII files.
          
          
            Encodings other than UTF-8 are very unlikely to be valid when decoded as UTF-8 so the chance
            of accidentally misinterpreting characters
            in JSON Lines files is low.
          
          
            Like the JSON standard a byte order mark (U+FEFF) must NOT be included.
          
          
            
            2. Each Line is a Valid JSON Value
          
          
            The most common values will be objects or arrays, but any JSON value is permitted.
          
          
            See json.org for a definition of JSON values.
          
          
            
            3. Line Separator is '\n'
          
          
            This means '\r\n' is also supported because surrounding white space is
            implicitly ignored when parsing JSON values.
          
          
            The last character in a file following the last JSON value may be a line separator.
            In this case the line separator does not indicate the start of another JSON value.
          
          
            
            4. Suggested Conventions
          
          
            JSON Lines files may be saved with the file extension .jsonl.
          
          
            Stream compressors like gzip or bzip2 are recommended for
            saving space, resulting in .jsonl.gz or .jsonl.bz2 files.
          
          
            MIME type may be application/jsonl, but this is not yet standardized; any help
            writing the RFC would be greatly appreciated (see issue).
          
          
            Text editing programs call the first line of a text file "line 1". The first value in a
            JSON Lines file should also be called "value 1".
          
        
        
          Report a bug or make a suggestion •
          Tactile theme by Jason Long •
          This page is maintained by Ian Ward.\nDocumentation for the JSON Lines text file format\nThis page describes the JSON Lines text format, also called newline-delimited JSON.
            JSON Lines is a convenient format for storing structured data that may be processed
            one record at a time. It works well with unix-style text processing tools and shell
            pipelines. It's a great format for log files. It's also a flexible format for passing
            messages between cooperating processes.\nThe JSON Lines format has three requirements:\nJSON allows encoding Unicode strings with only ASCII escape sequences, however those
            escapes will be hard to read when viewed in a text editor. The author of the JSON Lines
            file may choose to escape characters to work with plain ASCII files.\nEncodings other than UTF-8 are very unlikely to be valid when decoded as UTF-8 so the chance
            of accidentally misinterpreting characters
            in JSON Lines files is low.\naccidentally misinterpreting characters\nLike the JSON standard a byte order mark (U+FEFF) must NOT be included.\na byte order mark (U+FEFF) must NOT be included\n2. Each Line is a Valid JSON Value\nThe most common values will be objects or arrays, but any JSON value is permitted.\nSee json.org for a definition of JSON values.\n3. Line Separator is '\n'\nThis means '\r\n' is also supported because surrounding white space is
            implicitly ignored when parsing JSON values.\nThe last character in a file following the last JSON value may be a line separator.
            In this case the line separator does not indicate the start of another JSON value.\n4. Suggested Conventions\nJSON Lines files may be saved with the file extension .jsonl.\nStream compressors like gzip or bzip2 are recommended for
            saving space, resulting in .jsonl.gz or .jsonl.bz2 files.\nMIME type may be application/jsonl, but this is not yet standardized; any help
            writing the RFC would be greatly appreciated (see issue).\nText editing programs call the first line of a text file "line 1". The first value in a
            JSON Lines file should also be called "value 1".\nReport a bug or make a suggestion\n\n\nJSON Lines
          Documentation for the JSON Lines text file format
        
        
          
            Home
            Examples
            Validator
            On the web
            json.org
          
        
        
        
          
            This page describes the JSON Lines text format, also called newline-delimited JSON.
            JSON Lines is a convenient format for storing structured data that may be processed
            one record at a time. It works well with unix-style text processing tools and shell
            pipelines. It's a great format for log files. It's also a flexible format for passing
            messages between cooperating processes.
          
          
            The JSON Lines format has three requirements:
          
          
            
            1. UTF-8 Encoding
          
          
            JSON allows encoding Unicode strings with only ASCII escape sequences, however those
            escapes will be hard to read when viewed in a text editor. The author of the JSON Lines
            file may choose to escape characters to work with plain ASCII files.
          
          
            Encodings other than UTF-8 are very unlikely to be valid when decoded as UTF-8 so the chance
            of accidentally misinterpreting characters
            in JSON Lines files is low.
          
          
            Like the JSON standard a byte order mark (U+FEFF) must NOT be included.
          
          
            
            2. Each Line is a Valid JSON Value
          
          
            The most common values will be objects or arrays, but any JSON value is permitted.
          
          
            See json.org for a definition of JSON values.
          
          
            
            3. Line Separator is '\n'
          
          
            This means '\r\n' is also supported because surrounding white space is
            implicitly ignored when parsing JSON values.
          
          
            The last character in a file following the last JSON value may be a line separator.
            In this case the line separator does not indicate the start of another JSON value.
          
          
            
            4. Suggested Conventions
          
          
            JSON Lines files may be saved with the file extension .jsonl.
          
          
            Stream compressors like gzip or bzip2 are recommended for
            saving space, resulting in .jsonl.gz or .jsonl.bz2 files.
          
          
            MIME type may be application/jsonl, but this is not yet standardized; any help
            writing the RFC would be greatly appreciated (see issue).
          
          
            Text editing programs call the first line of a text file "line 1". The first value in a
            JSON Lines file should also be called "value 1".
          
        
        
          Report a bug or make a suggestion •
          Tactile theme by Jason Long •
          This page is maintained by Ian Ward.\nJSON Lines
          Documentation for the JSON Lines text file format
        
        
          
            Home
            Examples
            Validator
            On the web
            json.org
          
        
        
        
          
            This page describes the JSON Lines text format, also called newline-delimited JSON.
            JSON Lines is a convenient format for storing structured data that may be processed
            one record at a time. It works well with unix-style text processing tools and shell
            pipelines. It's a great format for log files. It's also a flexible format for passing
            messages between cooperating processes.
          
          
            The JSON Lines format has three requirements:
          
          
            
            1. UTF-8 Encoding
          
          
            JSON allows encoding Unicode strings with only ASCII escape sequences, however those
            escapes will be hard to read when viewed in a text editor. The author of the JSON Lines
            file may choose to escape characters to work with plain ASCII files.
          
          
            Encodings other than UTF-8 are very unlikely to be valid when decoded as UTF-8 so the chance
            of accidentally misinterpreting characters
            in JSON Lines files is low.
          
          
            Like the JSON standard a byte order mark (U+FEFF) must NOT be included.
          
          
            
            2. Each Line is a Valid JSON Value
          
          
            The most common values will be objects or arrays, but any JSON value is permitted.
          
          
            See json.org for a definition of JSON values.
          
          
            
            3. Line Separator is '\n'
          
          
            This means '\r\n' is also supported because surrounding white space is
            implicitly ignored when parsing JSON values.
          
          
            The last character in a file following the last JSON value may be a line separator.
            In this case the line separator does not indicate the start of another JSON value.
          
          
            
            4. Suggested Conventions
          
          
            JSON Lines files may be saved with the file extension .jsonl.
          
          
            Stream compressors like gzip or bzip2 are recommended for
            saving space, resulting in .jsonl.gz or .jsonl.bz2 files.
          
          
            MIME type may be application/jsonl, but this is not yet standardized; any help
            writing the RFC would be greatly appreciated (see issue).
          
          
            Text editing programs call the first line of a text file "line 1". The first value in a
            JSON Lines file should also be called "value 1".
          
        
        
          Report a bug or make a suggestion •
          Tactile theme by Jason Long •
          This page is maintained by Ian Ward.\nDocumentation for the JSON Lines text file format\nThis page describes the JSON Lines text format, also called newline-delimited JSON.
            JSON Lines is a convenient format for storing structured data that may be processed
            one record at a time. It works well with unix-style text processing tools and shell
            pipelines. It's a great format for log files. It's also a flexible format for passing
            messages between cooperating processes.\nThe JSON Lines format has three requirements:\nJSON allows encoding Unicode strings with only ASCII escape sequences, however those
            escapes will be hard to read when viewed in a text editor. The author of the JSON Lines
            file may choose to escape characters to work with plain ASCII files.\nEncodings other than UTF-8 are very unlikely to be valid when decoded as UTF-8 so the chance
            of accidentally misinterpreting characters
            in JSON Lines files is low.\naccidentally misinterpreting characters\nLike the JSON standard a byte order mark (U+FEFF) must NOT be included.\na byte order mark (U+FEFF) must NOT be included\n2. Each Line is a Valid JSON Value\nThe most common values will be objects or arrays, but any JSON value is permitted.\nSee json.org for a definition of JSON values.\n3. Line Separator is '\n'\nThis means '\r\n' is also supported because surrounding white space is
            implicitly ignored when parsing JSON values.\nThe last character in a file following the last JSON value may be a line separator.
            In this case the line separator does not indicate the start of another JSON value.\n4. Suggested Conventions\nJSON Lines files may be saved with the file extension .jsonl.\nStream compressors like gzip or bzip2 are recommended for
            saving space, resulting in .jsonl.gz or .jsonl.bz2 files.\nMIME type may be application/jsonl, but this is not yet standardized; any help
            writing the RFC would be greatly appreciated (see issue).\nText editing programs call the first line of a text file "line 1". The first value in a
            JSON Lines file should also be called "value 1".\nReport a bug or make a suggestion\n\n\nJSON Lines
          Examples
        


Home
Examples
Validator
On the web
json.org


        

        
          
Better than CSV

["Name", "Session", "Score", "Completed"]
["Gilbert", "2013", 24, true]
["Alexa", "2013", 29, true]
["May", "2012B", 14, false]
["Deloise", "2012A", 19, true] 


          CSV seems so easy that many programmers have written code to generate it themselves, and almost every implementation is different. Handling broken CSV files is a common and frustrating task. CSV has no standard encoding, no standard column separator and multiple character escaping standards. String is the only type supported for cell values, so some programs attempt to guess the correct types.

          JSON Lines handles tabular data cleanly and without ambiguity. Cells may use the standard JSON types.

          The biggest missing piece is an import/export filter for popular spreadsheet programs so that non-programmers can use this format.

          
Self-describing data

{"name": "Gilbert", "session": "2013", "score": 24, "completed": true}
{"name": "Alexa", "session": "2013", "score": 29, "completed": true}
{"name": "May", "session": "2012B", "score": 14, "completed": false}
{"name": "Deloise", "session": "2012A", "score": 19, "completed": true} 


          JSON Lines enables applications to read objects line-by-line, with each line fully describing a JSON object.  The example above contains the same data as the tabular example above, but allows applications to split files on newline boundaries for parallel loading, and eliminates any ambiguity if fields are omitted or re-ordered.

          
Easy Nested Data

{"name": "Gilbert", "wins": [["straight", "7♣"], ["one pair", "10♥"]]}
{"name": "Alexa", "wins": [["two pair", "4♠"], ["two pair", "9♠"]]}
{"name": "May", "wins": []}
{"name": "Deloise", "wins": [["three of a kind", "5♣"]]}


        

        JSON Lines' biggest strength is in handling lots of similar nested data structures. One .jsonl file is easier to work with than a directory full of XML files.

        If you have large nested structures then reading the JSON Lines text directly isn't recommended. Use the "jq" tool to make viewing large structures easier:

grep pair winning_hands.jsonl | jq .


{
  "name": "Gilbert", 
  "wins": [
    [
      "straight", 
      "7♣"
    ], 
    [
      "one pair", 
      "10♥"
    ]
  ]
}
{
  "name": "Alexa", 
  "wins": [
    [
      "two pair", 
      "4♠"
    ], 
    [
      "two pair", 
      "9♠"
    ]
  ]
}




        
          Report a bug or make a suggestion •
          Tactile theme by Jason Long •
          This page is maintained by Ian Ward.\nJSON Lines
          Examples
        


Home
Examples
Validator
On the web
json.org


        

        
          
Better than CSV

["Name", "Session", "Score", "Completed"]
["Gilbert", "2013", 24, true]
["Alexa", "2013", 29, true]
["May", "2012B", 14, false]
["Deloise", "2012A", 19, true] 


          CSV seems so easy that many programmers have written code to generate it themselves, and almost every implementation is different. Handling broken CSV files is a common and frustrating task. CSV has no standard encoding, no standard column separator and multiple character escaping standards. String is the only type supported for cell values, so some programs attempt to guess the correct types.

          JSON Lines handles tabular data cleanly and without ambiguity. Cells may use the standard JSON types.

          The biggest missing piece is an import/export filter for popular spreadsheet programs so that non-programmers can use this format.

          
Self-describing data

{"name": "Gilbert", "session": "2013", "score": 24, "completed": true}
{"name": "Alexa", "session": "2013", "score": 29, "completed": true}
{"name": "May", "session": "2012B", "score": 14, "completed": false}
{"name": "Deloise", "session": "2012A", "score": 19, "completed": true} 


          JSON Lines enables applications to read objects line-by-line, with each line fully describing a JSON object.  The example above contains the same data as the tabular example above, but allows applications to split files on newline boundaries for parallel loading, and eliminates any ambiguity if fields are omitted or re-ordered.

          
Easy Nested Data

{"name": "Gilbert", "wins": [["straight", "7♣"], ["one pair", "10♥"]]}
{"name": "Alexa", "wins": [["two pair", "4♠"], ["two pair", "9♠"]]}
{"name": "May", "wins": []}
{"name": "Deloise", "wins": [["three of a kind", "5♣"]]}


        

        JSON Lines' biggest strength is in handling lots of similar nested data structures. One .jsonl file is easier to work with than a directory full of XML files.

        If you have large nested structures then reading the JSON Lines text directly isn't recommended. Use the "jq" tool to make viewing large structures easier:

grep pair winning_hands.jsonl | jq .


{
  "name": "Gilbert", 
  "wins": [
    [
      "straight", 
      "7♣"
    ], 
    [
      "one pair", 
      "10♥"
    ]
  ]
}
{
  "name": "Alexa", 
  "wins": [
    [
      "two pair", 
      "4♠"
    ], 
    [
      "two pair", 
      "9♠"
    ]
  ]
}




        
          Report a bug or make a suggestion •
          Tactile theme by Jason Long •
          This page is maintained by Ian Ward.\n["Name", "Session", "Score", "Completed"]
["Gilbert", "2013", 24, true]
["Alexa", "2013", 29, true]
["May", "2012B", 14, false]
["Deloise", "2012A", 19, true]\nCSV seems so easy that many programmers have written code to generate it themselves, and almost every implementation is different. Handling broken CSV files is a common and frustrating task. CSV has no standard encoding, no standard column separator and multiple character escaping standards. String is the only type supported for cell values, so some programs attempt to guess the correct types.\nJSON Lines handles tabular data cleanly and without ambiguity. Cells may use the standard JSON types.\nThe biggest missing piece is an import/export filter for popular spreadsheet programs so that non-programmers can use this format.\n{"name": "Gilbert", "session": "2013", "score": 24, "completed": true}
{"name": "Alexa", "session": "2013", "score": 29, "completed": true}
{"name": "May", "session": "2012B", "score": 14, "completed": false}
{"name": "Deloise", "session": "2012A", "score": 19, "completed": true}\nJSON Lines enables applications to read objects line-by-line, with each line fully describing a JSON object.  The example above contains the same data as the tabular example above, but allows applications to split files on newline boundaries for parallel loading, and eliminates any ambiguity if fields are omitted or re-ordered.\n{"name": "Gilbert", "wins": [["straight", "7♣"], ["one pair", "10♥"]]}
{"name": "Alexa", "wins": [["two pair", "4♠"], ["two pair", "9♠"]]}
{"name": "May", "wins": []}
{"name": "Deloise", "wins": [["three of a kind", "5♣"]]}\nJSON Lines' biggest strength is in handling lots of similar nested data structures. One .jsonl file is easier to work with than a directory full of XML files.\nIf you have large nested structures then reading the JSON Lines text directly isn't recommended. Use the "jq" tool to make viewing large structures easier:\ngrep pair winning_hands.jsonl | jq .\n{
  "name": "Gilbert", 
  "wins": [
    [
      "straight", 
      "7♣"
    ], 
    [
      "one pair", 
      "10♥"
    ]
  ]
}
{
  "name": "Alexa", 
  "wins": [
    [
      "two pair", 
      "4♠"
    ], 
    [
      "two pair", 
      "9♠"
    ]
  ]
}\nReport a bug or make a suggestion\n\n\nJSON Lines
          Examples
        


Home
Examples
Validator
On the web
json.org


        

        
          
Better than CSV

["Name", "Session", "Score", "Completed"]
["Gilbert", "2013", 24, true]
["Alexa", "2013", 29, true]
["May", "2012B", 14, false]
["Deloise", "2012A", 19, true] 


          CSV seems so easy that many programmers have written code to generate it themselves, and almost every implementation is different. Handling broken CSV files is a common and frustrating task. CSV has no standard encoding, no standard column separator and multiple character escaping standards. String is the only type supported for cell values, so some programs attempt to guess the correct types.

          JSON Lines handles tabular data cleanly and without ambiguity. Cells may use the standard JSON types.

          The biggest missing piece is an import/export filter for popular spreadsheet programs so that non-programmers can use this format.

          
Self-describing data

{"name": "Gilbert", "session": "2013", "score": 24, "completed": true}
{"name": "Alexa", "session": "2013", "score": 29, "completed": true}
{"name": "May", "session": "2012B", "score": 14, "completed": false}
{"name": "Deloise", "session": "2012A", "score": 19, "completed": true} 


          JSON Lines enables applications to read objects line-by-line, with each line fully describing a JSON object.  The example above contains the same data as the tabular example above, but allows applications to split files on newline boundaries for parallel loading, and eliminates any ambiguity if fields are omitted or re-ordered.

          
Easy Nested Data

{"name": "Gilbert", "wins": [["straight", "7♣"], ["one pair", "10♥"]]}
{"name": "Alexa", "wins": [["two pair", "4♠"], ["two pair", "9♠"]]}
{"name": "May", "wins": []}
{"name": "Deloise", "wins": [["three of a kind", "5♣"]]}


        

        JSON Lines' biggest strength is in handling lots of similar nested data structures. One .jsonl file is easier to work with than a directory full of XML files.

        If you have large nested structures then reading the JSON Lines text directly isn't recommended. Use the "jq" tool to make viewing large structures easier:

grep pair winning_hands.jsonl | jq .


{
  "name": "Gilbert", 
  "wins": [
    [
      "straight", 
      "7♣"
    ], 
    [
      "one pair", 
      "10♥"
    ]
  ]
}
{
  "name": "Alexa", 
  "wins": [
    [
      "two pair", 
      "4♠"
    ], 
    [
      "two pair", 
      "9♠"
    ]
  ]
}




        
          Report a bug or make a suggestion •
          Tactile theme by Jason Long •
          This page is maintained by Ian Ward.\nJSON Lines
          Examples
        


Home
Examples
Validator
On the web
json.org


        

        
          
Better than CSV

["Name", "Session", "Score", "Completed"]
["Gilbert", "2013", 24, true]
["Alexa", "2013", 29, true]
["May", "2012B", 14, false]
["Deloise", "2012A", 19, true] 


          CSV seems so easy that many programmers have written code to generate it themselves, and almost every implementation is different. Handling broken CSV files is a common and frustrating task. CSV has no standard encoding, no standard column separator and multiple character escaping standards. String is the only type supported for cell values, so some programs attempt to guess the correct types.

          JSON Lines handles tabular data cleanly and without ambiguity. Cells may use the standard JSON types.

          The biggest missing piece is an import/export filter for popular spreadsheet programs so that non-programmers can use this format.

          
Self-describing data

{"name": "Gilbert", "session": "2013", "score": 24, "completed": true}
{"name": "Alexa", "session": "2013", "score": 29, "completed": true}
{"name": "May", "session": "2012B", "score": 14, "completed": false}
{"name": "Deloise", "session": "2012A", "score": 19, "completed": true} 


          JSON Lines enables applications to read objects line-by-line, with each line fully describing a JSON object.  The example above contains the same data as the tabular example above, but allows applications to split files on newline boundaries for parallel loading, and eliminates any ambiguity if fields are omitted or re-ordered.

          
Easy Nested Data

{"name": "Gilbert", "wins": [["straight", "7♣"], ["one pair", "10♥"]]}
{"name": "Alexa", "wins": [["two pair", "4♠"], ["two pair", "9♠"]]}
{"name": "May", "wins": []}
{"name": "Deloise", "wins": [["three of a kind", "5♣"]]}


        

        JSON Lines' biggest strength is in handling lots of similar nested data structures. One .jsonl file is easier to work with than a directory full of XML files.

        If you have large nested structures then reading the JSON Lines text directly isn't recommended. Use the "jq" tool to make viewing large structures easier:

grep pair winning_hands.jsonl | jq .


{
  "name": "Gilbert", 
  "wins": [
    [
      "straight", 
      "7♣"
    ], 
    [
      "one pair", 
      "10♥"
    ]
  ]
}
{
  "name": "Alexa", 
  "wins": [
    [
      "two pair", 
      "4♠"
    ], 
    [
      "two pair", 
      "9♠"
    ]
  ]
}




        
          Report a bug or make a suggestion •
          Tactile theme by Jason Long •
          This page is maintained by Ian Ward.\n["Name", "Session", "Score", "Completed"]
["Gilbert", "2013", 24, true]
["Alexa", "2013", 29, true]
["May", "2012B", 14, false]
["Deloise", "2012A", 19, true]\nCSV seems so easy that many programmers have written code to generate it themselves, and almost every implementation is different. Handling broken CSV files is a common and frustrating task. CSV has no standard encoding, no standard column separator and multiple character escaping standards. String is the only type supported for cell values, so some programs attempt to guess the correct types.\nJSON Lines handles tabular data cleanly and without ambiguity. Cells may use the standard JSON types.\nThe biggest missing piece is an import/export filter for popular spreadsheet programs so that non-programmers can use this format.\n{"name": "Gilbert", "session": "2013", "score": 24, "completed": true}
{"name": "Alexa", "session": "2013", "score": 29, "completed": true}
{"name": "May", "session": "2012B", "score": 14, "completed": false}
{"name": "Deloise", "session": "2012A", "score": 19, "completed": true}\nJSON Lines enables applications to read objects line-by-line, with each line fully describing a JSON object.  The example above contains the same data as the tabular example above, but allows applications to split files on newline boundaries for parallel loading, and eliminates any ambiguity if fields are omitted or re-ordered.\n{"name": "Gilbert", "wins": [["straight", "7♣"], ["one pair", "10♥"]]}
{"name": "Alexa", "wins": [["two pair", "4♠"], ["two pair", "9♠"]]}
{"name": "May", "wins": []}
{"name": "Deloise", "wins": [["three of a kind", "5♣"]]}\nJSON Lines' biggest strength is in handling lots of similar nested data structures. One .jsonl file is easier to work with than a directory full of XML files.\nIf you have large nested structures then reading the JSON Lines text directly isn't recommended. Use the "jq" tool to make viewing large structures easier:\ngrep pair winning_hands.jsonl | jq .\n{
  "name": "Gilbert", 
  "wins": [
    [
      "straight", 
      "7♣"
    ], 
    [
      "one pair", 
      "10♥"
    ]
  ]
}
{
  "name": "Alexa", 
  "wins": [
    [
      "two pair", 
      "4♠"
    ], 
    [
      "two pair", 
      "9♠"
    ]
  ]
}\nReport a bug or make a suggestion\n\n\nJSON Lines
          Examples
        


Home
Examples
Validator
On the web
json.org


        

        
          
Better than CSV

["Name", "Session", "Score", "Completed"]
["Gilbert", "2013", 24, true]
["Alexa", "2013", 29, true]
["May", "2012B", 14, false]
["Deloise", "2012A", 19, true] 


          CSV seems so easy that many programmers have written code to generate it themselves, and almost every implementation is different. Handling broken CSV files is a common and frustrating task. CSV has no standard encoding, no standard column separator and multiple character escaping standards. String is the only type supported for cell values, so some programs attempt to guess the correct types.

          JSON Lines handles tabular data cleanly and without ambiguity. Cells may use the standard JSON types.

          The biggest missing piece is an import/export filter for popular spreadsheet programs so that non-programmers can use this format.

          
Self-describing data

{"name": "Gilbert", "session": "2013", "score": 24, "completed": true}
{"name": "Alexa", "session": "2013", "score": 29, "completed": true}
{"name": "May", "session": "2012B", "score": 14, "completed": false}
{"name": "Deloise", "session": "2012A", "score": 19, "completed": true} 


          JSON Lines enables applications to read objects line-by-line, with each line fully describing a JSON object.  The example above contains the same data as the tabular example above, but allows applications to split files on newline boundaries for parallel loading, and eliminates any ambiguity if fields are omitted or re-ordered.

          
Easy Nested Data

{"name": "Gilbert", "wins": [["straight", "7♣"], ["one pair", "10♥"]]}
{"name": "Alexa", "wins": [["two pair", "4♠"], ["two pair", "9♠"]]}
{"name": "May", "wins": []}
{"name": "Deloise", "wins": [["three of a kind", "5♣"]]}


        

        JSON Lines' biggest strength is in handling lots of similar nested data structures. One .jsonl file is easier to work with than a directory full of XML files.

        If you have large nested structures then reading the JSON Lines text directly isn't recommended. Use the "jq" tool to make viewing large structures easier:

grep pair winning_hands.jsonl | jq .


{
  "name": "Gilbert", 
  "wins": [
    [
      "straight", 
      "7♣"
    ], 
    [
      "one pair", 
      "10♥"
    ]
  ]
}
{
  "name": "Alexa", 
  "wins": [
    [
      "two pair", 
      "4♠"
    ], 
    [
      "two pair", 
      "9♠"
    ]
  ]
}




        
          Report a bug or make a suggestion •
          Tactile theme by Jason Long •
          This page is maintained by Ian Ward.\nJSON Lines
          Examples
        


Home
Examples
Validator
On the web
json.org


        

        
          
Better than CSV

["Name", "Session", "Score", "Completed"]
["Gilbert", "2013", 24, true]
["Alexa", "2013", 29, true]
["May", "2012B", 14, false]
["Deloise", "2012A", 19, true] 


          CSV seems so easy that many programmers have written code to generate it themselves, and almost every implementation is different. Handling broken CSV files is a common and frustrating task. CSV has no standard encoding, no standard column separator and multiple character escaping standards. String is the only type supported for cell values, so some programs attempt to guess the correct types.

          JSON Lines handles tabular data cleanly and without ambiguity. Cells may use the standard JSON types.

          The biggest missing piece is an import/export filter for popular spreadsheet programs so that non-programmers can use this format.

          
Self-describing data

{"name": "Gilbert", "session": "2013", "score": 24, "completed": true}
{"name": "Alexa", "session": "2013", "score": 29, "completed": true}
{"name": "May", "session": "2012B", "score": 14, "completed": false}
{"name": "Deloise", "session": "2012A", "score": 19, "completed": true} 


          JSON Lines enables applications to read objects line-by-line, with each line fully describing a JSON object.  The example above contains the same data as the tabular example above, but allows applications to split files on newline boundaries for parallel loading, and eliminates any ambiguity if fields are omitted or re-ordered.

          
Easy Nested Data

{"name": "Gilbert", "wins": [["straight", "7♣"], ["one pair", "10♥"]]}
{"name": "Alexa", "wins": [["two pair", "4♠"], ["two pair", "9♠"]]}
{"name": "May", "wins": []}
{"name": "Deloise", "wins": [["three of a kind", "5♣"]]}


        

        JSON Lines' biggest strength is in handling lots of similar nested data structures. One .jsonl file is easier to work with than a directory full of XML files.

        If you have large nested structures then reading the JSON Lines text directly isn't recommended. Use the "jq" tool to make viewing large structures easier:

grep pair winning_hands.jsonl | jq .


{
  "name": "Gilbert", 
  "wins": [
    [
      "straight", 
      "7♣"
    ], 
    [
      "one pair", 
      "10♥"
    ]
  ]
}
{
  "name": "Alexa", 
  "wins": [
    [
      "two pair", 
      "4♠"
    ], 
    [
      "two pair", 
      "9♠"
    ]
  ]
}




        
          Report a bug or make a suggestion •
          Tactile theme by Jason Long •
          This page is maintained by Ian Ward.\n["Name", "Session", "Score", "Completed"]
["Gilbert", "2013", 24, true]
["Alexa", "2013", 29, true]
["May", "2012B", 14, false]
["Deloise", "2012A", 19, true]\nCSV seems so easy that many programmers have written code to generate it themselves, and almost every implementation is different. Handling broken CSV files is a common and frustrating task. CSV has no standard encoding, no standard column separator and multiple character escaping standards. String is the only type supported for cell values, so some programs attempt to guess the correct types.\nJSON Lines handles tabular data cleanly and without ambiguity. Cells may use the standard JSON types.\nThe biggest missing piece is an import/export filter for popular spreadsheet programs so that non-programmers can use this format.\n{"name": "Gilbert", "session": "2013", "score": 24, "completed": true}
{"name": "Alexa", "session": "2013", "score": 29, "completed": true}
{"name": "May", "session": "2012B", "score": 14, "completed": false}
{"name": "Deloise", "session": "2012A", "score": 19, "completed": true}\nJSON Lines enables applications to read objects line-by-line, with each line fully describing a JSON object.  The example above contains the same data as the tabular example above, but allows applications to split files on newline boundaries for parallel loading, and eliminates any ambiguity if fields are omitted or re-ordered.\n{"name": "Gilbert", "wins": [["straight", "7♣"], ["one pair", "10♥"]]}
{"name": "Alexa", "wins": [["two pair", "4♠"], ["two pair", "9♠"]]}
{"name": "May", "wins": []}
{"name": "Deloise", "wins": [["three of a kind", "5♣"]]}\nJSON Lines' biggest strength is in handling lots of similar nested data structures. One .jsonl file is easier to work with than a directory full of XML files.\nIf you have large nested structures then reading the JSON Lines text directly isn't recommended. Use the "jq" tool to make viewing large structures easier:\ngrep pair winning_hands.jsonl | jq .\n{
  "name": "Gilbert", 
  "wins": [
    [
      "straight", 
      "7♣"
    ], 
    [
      "one pair", 
      "10♥"
    ]
  ]
}
{
  "name": "Alexa", 
  "wins": [
    [
      "two pair", 
      "4♠"
    ], 
    [
      "two pair", 
      "9♠"
    ]
  ]
}\nReport a bug or make a suggestion\n\n\n