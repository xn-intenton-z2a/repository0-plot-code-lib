On this pageWhat is Prettier?Prettier is an opinionated code formatter with support for:

JavaScript (including experimental features)
JSX
Angular
Vue
Flow
TypeScript
CSS, Less, and SCSS
HTML
Ember/Handlebars
JSON
GraphQL
Markdown, including GFM and MDX v1
YAML

It removes all original styling* and ensures that all outputted code conforms to a consistent style. (See this blog post)
Prettier takes your code and reprints it from scratch by taking the line length into account.
For example, take the following code:
foo(arg1, arg2, arg3, arg4);
It fits in a single line so it‚Äôs going to stay as is. However, we've all run into this situation:
foo(reallyLongArg(), omgSoManyParameters(), IShouldRefactorThis(), isThereSeriouslyAnotherOne());
Suddenly our previous format for calling function breaks down because this is too long. Prettier is going to do the painstaking work of reprinting it like that for you:
foo(  reallyLongArg(),  omgSoManyParameters(),  IShouldRefactorThis(),  isThereSeriouslyAnotherOne(),);
Prettier enforces a consistent code style (i.e. code formatting that won‚Äôt affect the AST) across your entire codebase because it disregards the original styling* by parsing it away and re-printing the parsed AST with its own rules that take the maximum line length into account, wrapping code when necessary.
If you want to learn more, these two conference talks are great introductions:


Footnotes‚Äã
* Well actually, some original styling is preserved when practical‚Äîsee empty lines and multi-line objects.Edit this page\n\nOn this pageWhat is Prettier?Prettier is an opinionated code formatter with support for:

JavaScript (including experimental features)
JSX
Angular
Vue
Flow
TypeScript
CSS, Less, and SCSS
HTML
Ember/Handlebars
JSON
GraphQL
Markdown, including GFM and MDX v1
YAML

It removes all original styling* and ensures that all outputted code conforms to a consistent style. (See this blog post)
Prettier takes your code and reprints it from scratch by taking the line length into account.
For example, take the following code:
foo(arg1, arg2, arg3, arg4);
It fits in a single line so it‚Äôs going to stay as is. However, we've all run into this situation:
foo(reallyLongArg(), omgSoManyParameters(), IShouldRefactorThis(), isThereSeriouslyAnotherOne());
Suddenly our previous format for calling function breaks down because this is too long. Prettier is going to do the painstaking work of reprinting it like that for you:
foo(  reallyLongArg(),  omgSoManyParameters(),  IShouldRefactorThis(),  isThereSeriouslyAnotherOne(),);
Prettier enforces a consistent code style (i.e. code formatting that won‚Äôt affect the AST) across your entire codebase because it disregards the original styling* by parsing it away and re-printing the parsed AST with its own rules that take the maximum line length into account, wrapping code when necessary.
If you want to learn more, these two conference talks are great introductions:


Footnotes‚Äã
* Well actually, some original styling is preserved when practical‚Äîsee empty lines and multi-line objects.Edit this pageNextWhy Prettier?\n\n\n\nOn this pageWhat is Prettier?Prettier is an opinionated code formatter with support for:

JavaScript (including experimental features)
JSX
Angular
Vue
Flow
TypeScript
CSS, Less, and SCSS
HTML
Ember/Handlebars
JSON
GraphQL
Markdown, including GFM and MDX v1
YAML

It removes all original styling* and ensures that all outputted code conforms to a consistent style. (See this blog post)
Prettier takes your code and reprints it from scratch by taking the line length into account.
For example, take the following code:
foo(arg1, arg2, arg3, arg4);
It fits in a single line so it‚Äôs going to stay as is. However, we've all run into this situation:
foo(reallyLongArg(), omgSoManyParameters(), IShouldRefactorThis(), isThereSeriouslyAnotherOne());
Suddenly our previous format for calling function breaks down because this is too long. Prettier is going to do the painstaking work of reprinting it like that for you:
foo(  reallyLongArg(),  omgSoManyParameters(),  IShouldRefactorThis(),  isThereSeriouslyAnotherOne(),);
Prettier enforces a consistent code style (i.e. code formatting that won‚Äôt affect the AST) across your entire codebase because it disregards the original styling* by parsing it away and re-printing the parsed AST with its own rules that take the maximum line length into account, wrapping code when necessary.
If you want to learn more, these two conference talks are great introductions:


Footnotes‚Äã
* Well actually, some original styling is preserved when practical‚Äîsee empty lines and multi-line objects.Edit this page\n\nOn this pageWhat is Prettier?Prettier is an opinionated code formatter with support for:

JavaScript (including experimental features)
JSX
Angular
Vue
Flow
TypeScript
CSS, Less, and SCSS
HTML
Ember/Handlebars
JSON
GraphQL
Markdown, including GFM and MDX v1
YAML

It removes all original styling* and ensures that all outputted code conforms to a consistent style. (See this blog post)
Prettier takes your code and reprints it from scratch by taking the line length into account.
For example, take the following code:
foo(arg1, arg2, arg3, arg4);
It fits in a single line so it‚Äôs going to stay as is. However, we've all run into this situation:
foo(reallyLongArg(), omgSoManyParameters(), IShouldRefactorThis(), isThereSeriouslyAnotherOne());
Suddenly our previous format for calling function breaks down because this is too long. Prettier is going to do the painstaking work of reprinting it like that for you:
foo(  reallyLongArg(),  omgSoManyParameters(),  IShouldRefactorThis(),  isThereSeriouslyAnotherOne(),);
Prettier enforces a consistent code style (i.e. code formatting that won‚Äôt affect the AST) across your entire codebase because it disregards the original styling* by parsing it away and re-printing the parsed AST with its own rules that take the maximum line length into account, wrapping code when necessary.
If you want to learn more, these two conference talks are great introductions:


Footnotes‚Äã
* Well actually, some original styling is preserved when practical‚Äîsee empty lines and multi-line objects.Edit this pageNextWhy Prettier?\n\n\n\nSkip to main contentPrettierstablenextstablePlaygroundDocsBlogDonateSearchPRETTIER FOR ENTERPRISETry It OnlineInstall PrettierLimited edition tshirts are now available to buy! $10 per tshirt goes to maintain the project.What is Prettier?An opinionated code formatterSupports many languagesIntegrates with most editorsHas few options ¬ªWhy?Your code is formatted on saveNo need to discuss style in code reviewSaves you time and energyAnd more ¬ªWorks with the Tools You UseJavaScriptJSXFlowTypeScriptJSONHTMLVueAngularEmber / HandlebarsCSSLessSCSSstyled-components üíÖstyled-jsxGraphQLGraphQL SchemasMarkdownCommonMarkGitHub-Flavored MarkdownMDX v1YAMLCommunity PluginsApexElm (via elm-format)JavaPHPRubyRustTOMLXMLAnd more...Editor SupportEmacsprettier-js
prettier.el
ApheleiaEspressoespresso-prettierNovaPrettier
Prettier‚Å∫Sublime TextJsPrettierVimvim-prettier
neoformat
ALE
coc-prettierVisual StudioJavaScriptPrettierVS Codeprettier-vscodeWebStormBuilt-in supportGot more?Send a PRUsed By People You Rely OnSee othersEstablished in the EcosystemRegularly used by:More than 83% of respondents to State of JS 2021.More than 70% of respondents to State of JS 2020.More than 9.3 million dependent repositories on GitHubCheck Them OutMore than 19.3k dependent packages on npmSee them allDocsAboutUsage
                  
                    
                  
                CommunityUser ShowcaseStack Overflow@PrettierCode on TwitterMoreBlogGitHubIssues\nSkip to main contentPrettierstablenextstablePlaygroundDocsBlogDonateSearchPRETTIER FOR ENTERPRISETry It OnlineInstall PrettierLimited edition tshirts are now available to buy! $10 per tshirt goes to maintain the project.What is Prettier?An opinionated code formatterSupports many languagesIntegrates with most editorsHas few options ¬ªWhy?Your code is formatted on saveNo need to discuss style in code reviewSaves you time and energyAnd more ¬ªWorks with the Tools You UseJavaScriptJSXFlowTypeScriptJSONHTMLVueAngularEmber / HandlebarsCSSLessSCSSstyled-components üíÖstyled-jsxGraphQLGraphQL SchemasMarkdownCommonMarkGitHub-Flavored MarkdownMDX v1YAMLCommunity PluginsApexElm (via elm-format)JavaPHPRubyRustTOMLXMLAnd more...Editor SupportEmacsprettier-js
prettier.el
ApheleiaEspressoespresso-prettierNovaPrettier
Prettier‚Å∫Sublime TextJsPrettierVimvim-prettier
neoformat
ALE
coc-prettierVisual StudioJavaScriptPrettierVS Codeprettier-vscodeWebStormBuilt-in supportGot more?Send a PRUsed By People You Rely OnSee othersEstablished in the EcosystemRegularly used by:More than 83% of respondents to State of JS 2021.More than 70% of respondents to State of JS 2020.More than 9.3 million dependent repositories on GitHubCheck Them OutMore than 19.3k dependent packages on npmSee them allDocsAboutUsage
                  
                    
                  
                CommunityUser ShowcaseStack Overflow@PrettierCode on TwitterMoreBlogGitHubIssues\nPrettierstablenextstablePlaygroundDocsBlogDonateSearch\nPrettierstablenextstable\nPlaygroundDocsBlogDonateSearch\nPRETTIER FOR ENTERPRISETry It OnlineInstall PrettierLimited edition tshirts are now available to buy! $10 per tshirt goes to maintain the project.What is Prettier?An opinionated code formatterSupports many languagesIntegrates with most editorsHas few options ¬ªWhy?Your code is formatted on saveNo need to discuss style in code reviewSaves you time and energyAnd more ¬ªWorks with the Tools You UseJavaScriptJSXFlowTypeScriptJSONHTMLVueAngularEmber / HandlebarsCSSLessSCSSstyled-components üíÖstyled-jsxGraphQLGraphQL SchemasMarkdownCommonMarkGitHub-Flavored MarkdownMDX v1YAMLCommunity PluginsApexElm (via elm-format)JavaPHPRubyRustTOMLXMLAnd more...Editor SupportEmacsprettier-js
prettier.el
ApheleiaEspressoespresso-prettierNovaPrettier
Prettier‚Å∫Sublime TextJsPrettierVimvim-prettier
neoformat
ALE
coc-prettierVisual StudioJavaScriptPrettierVS Codeprettier-vscodeWebStormBuilt-in supportGot more?Send a PRUsed By People You Rely OnSee othersEstablished in the EcosystemRegularly used by:More than 83% of respondents to State of JS 2021.More than 70% of respondents to State of JS 2020.More than 9.3 million dependent repositories on GitHubCheck Them OutMore than 19.3k dependent packages on npmSee them all\nPRETTIER FOR ENTERPRISE\nTry It OnlineInstall Prettier\nTry It OnlineInstall Prettier\nLimited edition tshirts are now available to buy! $10 per tshirt goes to maintain the project.\nLimited edition tshirts are now available to buy! $10 per tshirt goes to maintain the project.\nWhat is Prettier?An opinionated code formatterSupports many languagesIntegrates with most editorsHas few options ¬ªWhy?Your code is formatted on saveNo need to discuss style in code reviewSaves you time and energyAnd more ¬ª\nWhat is Prettier?An opinionated code formatterSupports many languagesIntegrates with most editorsHas few options ¬ªWhy?Your code is formatted on saveNo need to discuss style in code reviewSaves you time and energyAnd more ¬ª\nWhat is Prettier?An opinionated code formatterSupports many languagesIntegrates with most editorsHas few options ¬ª\nAn opinionated code formatter\nSupports many languages\nIntegrates with most editors\nWhy?Your code is formatted on saveNo need to discuss style in code reviewSaves you time and energyAnd more ¬ª\nYour code is formatted on save\nNo need to discuss style in code review\nSaves you time and energy\nWorks with the Tools You UseJavaScriptJSXFlowTypeScriptJSONHTMLVueAngularEmber / HandlebarsCSSLessSCSSstyled-components üíÖstyled-jsxGraphQLGraphQL SchemasMarkdownCommonMarkGitHub-Flavored MarkdownMDX v1YAMLCommunity PluginsApexElm (via elm-format)JavaPHPRubyRustTOMLXMLAnd more...\nWorks with the Tools You Use\nJavaScriptJSXFlowTypeScriptJSONHTMLVueAngularEmber / HandlebarsCSSLessSCSSstyled-components üíÖstyled-jsxGraphQLGraphQL SchemasMarkdownCommonMarkGitHub-Flavored MarkdownMDX v1YAMLCommunity PluginsApexElm (via elm-format)JavaPHPRubyRustTOMLXMLAnd more...\nJavaScriptJSXFlowTypeScriptJSONHTMLVueAngularEmber / Handlebars\nJavaScriptJSXFlowTypeScriptJSON\nHTMLVueAngularEmber / Handlebars\nCSSLessSCSSstyled-components üíÖstyled-jsxGraphQLGraphQL Schemas\nCSSLessSCSSstyled-components üíÖstyled-jsx\nGraphQLGraphQL Schemas\nMarkdownCommonMarkGitHub-Flavored MarkdownMDX v1YAML\nMarkdownCommonMarkGitHub-Flavored MarkdownMDX v1\nGitHub-Flavored Markdown\nGitHub-Flavored Markdown\nGitHub-Flavored Markdown\nCommunity PluginsApexElm (via elm-format)JavaPHPRubyRustTOMLXMLAnd more...\nCommunity PluginsApexElm (via elm-format)JavaPHPRubyRustTOMLXMLAnd more...\nEditor SupportEmacsprettier-js
prettier.el
ApheleiaEspressoespresso-prettierNovaPrettier
Prettier‚Å∫Sublime TextJsPrettierVimvim-prettier
neoformat
ALE
coc-prettierVisual StudioJavaScriptPrettierVS Codeprettier-vscodeWebStormBuilt-in supportGot more?Send a PR\nEditor SupportEmacsprettier-js
prettier.el
ApheleiaEspressoespresso-prettierNovaPrettier
Prettier‚Å∫Sublime TextJsPrettierVimvim-prettier
neoformat
ALE
coc-prettierVisual StudioJavaScriptPrettierVS Codeprettier-vscodeWebStormBuilt-in supportGot more?Send a PR\nEmacsprettier-js
prettier.el
ApheleiaEspressoespresso-prettierNovaPrettier
Prettier‚Å∫Sublime TextJsPrettierVimvim-prettier
neoformat
ALE
coc-prettierVisual StudioJavaScriptPrettierVS Codeprettier-vscodeWebStormBuilt-in support\nEmacsprettier-js
prettier.el
Apheleia\nEmacsprettier-js
prettier.el
Apheleia\nprettier-js
prettier.el
Apheleia\nEspressoespresso-prettier\nEspressoespresso-prettier\nNovaPrettier
Prettier‚Å∫\nNovaPrettier
Prettier‚Å∫\nSublime TextJsPrettier\nSublime TextJsPrettier\nVimvim-prettier
neoformat
ALE
coc-prettier\nVimvim-prettier
neoformat
ALE
coc-prettier\nvim-prettier
neoformat
ALE
coc-prettier\nVisual StudioJavaScriptPrettier\nVisual StudioJavaScriptPrettier\nVS Codeprettier-vscode\nVS Codeprettier-vscode\nWebStormBuilt-in support\nWebStormBuilt-in support\nUsed By People You Rely OnSee othersEstablished in the EcosystemRegularly used by:More than 83% of respondents to State of JS 2021.More than 70% of respondents to State of JS 2020.More than 9.3 million dependent repositories on GitHubCheck Them OutMore than 19.3k dependent packages on npmSee them all\nUsed By People You Rely OnSee others\nUsed By People You Rely On\nEstablished in the EcosystemRegularly used by:More than 83% of respondents to State of JS 2021.More than 70% of respondents to State of JS 2020.More than 9.3 million dependent repositories on GitHubCheck Them OutMore than 19.3k dependent packages on npmSee them all\nEstablished in the Ecosystem\nRegularly used by:More than 83% of respondents to State of JS 2021.More than 70% of respondents to State of JS 2020.More than 9.3 million dependent repositories on GitHubCheck Them OutMore than 19.3k dependent packages on npmSee them all\nRegularly used by:More than 83% of respondents to State of JS 2021.More than 70% of respondents to State of JS 2020.\nRegularly used by:More than 83% of respondents to State of JS 2021.More than 70% of respondents to State of JS 2020.\nMore than 83% of respondents to State of JS 2021.\nMore than 83% of respondents to State of JS 2021.\nMore than 70% of respondents to State of JS 2020.\nMore than 70% of respondents to State of JS 2020.\nMore than 9.3 million dependent repositories on GitHubCheck Them Out\nMore than 9.3 million dependent repositories on GitHubCheck Them Out\nMore than 9.3 million dependent repositories on GitHub\nMore than 19.3k dependent packages on npmSee them all\nMore than 19.3k dependent packages on npmSee them all\nMore than 19.3k dependent packages on npm\nDocsAboutUsage
                  
                    
                  
                CommunityUser ShowcaseStack Overflow@PrettierCode on TwitterMoreBlogGitHubIssues\nDocsAboutUsage
                  
                    
                  
                CommunityUser ShowcaseStack Overflow@PrettierCode on TwitterMoreBlogGitHubIssues\nCommunityUser ShowcaseStack Overflow@PrettierCode on Twitter\n@PrettierCode on Twitter\n@PrettierCode on Twitter\n\n\nOn this pageWhat is Prettier?Prettier is an opinionated code formatter with support for:

JavaScript (including experimental features)
JSX
Angular
Vue
Flow
TypeScript
CSS, Less, and SCSS
HTML
Ember/Handlebars
JSON
GraphQL
Markdown, including GFM and MDX v1
YAML

It removes all original styling* and ensures that all outputted code conforms to a consistent style. (See this blog post)
Prettier takes your code and reprints it from scratch by taking the line length into account.
For example, take the following code:
foo(arg1, arg2, arg3, arg4);
It fits in a single line so it‚Äôs going to stay as is. However, we've all run into this situation:
foo(reallyLongArg(), omgSoManyParameters(), IShouldRefactorThis(), isThereSeriouslyAnotherOne());
Suddenly our previous format for calling function breaks down because this is too long. Prettier is going to do the painstaking work of reprinting it like that for you:
foo(  reallyLongArg(),  omgSoManyParameters(),  IShouldRefactorThis(),  isThereSeriouslyAnotherOne(),);
Prettier enforces a consistent code style (i.e. code formatting that won‚Äôt affect the AST) across your entire codebase because it disregards the original styling* by parsing it away and re-printing the parsed AST with its own rules that take the maximum line length into account, wrapping code when necessary.
If you want to learn more, these two conference talks are great introductions:


Footnotes‚Äã
* Well actually, some original styling is preserved when practical‚Äîsee empty lines and multi-line objects.Edit this page\n\nOn this pageWhat is Prettier?Prettier is an opinionated code formatter with support for:

JavaScript (including experimental features)
JSX
Angular
Vue
Flow
TypeScript
CSS, Less, and SCSS
HTML
Ember/Handlebars
JSON
GraphQL
Markdown, including GFM and MDX v1
YAML

It removes all original styling* and ensures that all outputted code conforms to a consistent style. (See this blog post)
Prettier takes your code and reprints it from scratch by taking the line length into account.
For example, take the following code:
foo(arg1, arg2, arg3, arg4);
It fits in a single line so it‚Äôs going to stay as is. However, we've all run into this situation:
foo(reallyLongArg(), omgSoManyParameters(), IShouldRefactorThis(), isThereSeriouslyAnotherOne());
Suddenly our previous format for calling function breaks down because this is too long. Prettier is going to do the painstaking work of reprinting it like that for you:
foo(  reallyLongArg(),  omgSoManyParameters(),  IShouldRefactorThis(),  isThereSeriouslyAnotherOne(),);
Prettier enforces a consistent code style (i.e. code formatting that won‚Äôt affect the AST) across your entire codebase because it disregards the original styling* by parsing it away and re-printing the parsed AST with its own rules that take the maximum line length into account, wrapping code when necessary.
If you want to learn more, these two conference talks are great introductions:


Footnotes‚Äã
* Well actually, some original styling is preserved when practical‚Äîsee empty lines and multi-line objects.Edit this pageNextWhy Prettier?\n\n\n\nOn this pageWhat is Prettier?Prettier is an opinionated code formatter with support for:

JavaScript (including experimental features)
JSX
Angular
Vue
Flow
TypeScript
CSS, Less, and SCSS
HTML
Ember/Handlebars
JSON
GraphQL
Markdown, including GFM and MDX v1
YAML

It removes all original styling* and ensures that all outputted code conforms to a consistent style. (See this blog post)
Prettier takes your code and reprints it from scratch by taking the line length into account.
For example, take the following code:
foo(arg1, arg2, arg3, arg4);
It fits in a single line so it‚Äôs going to stay as is. However, we've all run into this situation:
foo(reallyLongArg(), omgSoManyParameters(), IShouldRefactorThis(), isThereSeriouslyAnotherOne());
Suddenly our previous format for calling function breaks down because this is too long. Prettier is going to do the painstaking work of reprinting it like that for you:
foo(  reallyLongArg(),  omgSoManyParameters(),  IShouldRefactorThis(),  isThereSeriouslyAnotherOne(),);
Prettier enforces a consistent code style (i.e. code formatting that won‚Äôt affect the AST) across your entire codebase because it disregards the original styling* by parsing it away and re-printing the parsed AST with its own rules that take the maximum line length into account, wrapping code when necessary.
If you want to learn more, these two conference talks are great introductions:


Footnotes‚Äã
* Well actually, some original styling is preserved when practical‚Äîsee empty lines and multi-line objects.Edit this page\n\nThis is unreleased documentation for Prettier next version.For up-to-date documentation, see the latest version (stable).On this pageWhat is Prettier?Prettier is an opinionated code formatter with support for:

JavaScript (including experimental features)
JSX
Angular
Vue
Flow
TypeScript
CSS, Less, and SCSS
HTML
Ember/Handlebars
JSON
GraphQL
Markdown, including GFM and MDX v1
YAML

It removes all original styling* and ensures that all outputted code conforms to a consistent style. (See this blog post)
Prettier takes your code and reprints it from scratch by taking the line length into account.
For example, take the following code:
foo(arg1, arg2, arg3, arg4);
It fits in a single line so it‚Äôs going to stay as is. However, we've all run into this situation:
foo(reallyLongArg(), omgSoManyParameters(), IShouldRefactorThis(), isThereSeriouslyAnotherOne());
Suddenly our previous format for calling function breaks down because this is too long. Prettier is going to do the painstaking work of reprinting it like that for you:
foo(  reallyLongArg(),  omgSoManyParameters(),  IShouldRefactorThis(),  isThereSeriouslyAnotherOne(),);
Prettier enforces a consistent code style (i.e. code formatting that won‚Äôt affect the AST) across your entire codebase because it disregards the original styling* by parsing it away and re-printing the parsed AST with its own rules that take the maximum line length into account, wrapping code when necessary.
If you want to learn more, these two conference talks are great introductions:


Footnotes‚Äã
* Well actually, some original styling is preserved when practical‚Äîsee empty lines and multi-line objects.Edit this pageNextWhy Prettier?\n\n\n\nPrettier 
      

      
        
          GitHub\n\nPrettier 3.5: New objectWrap option, experimentalOperatorPosition option and TS config file support!February 9, 2025 ¬∑ 9 min readSosuke SuzukiThis release includes a lot of bug fixes and the following new features:

Support for the new objectWrap option
Support for the new experimental experimentalOperatorPosition option
Support for TypeScript configuration file

See each section for details.Read morePrettier 3.4: A lot of bug fixesNovember 26, 2024 ¬∑ 19 min readSosuke SuzukiThis release includes numerous bug fixes and other improvements.
If you appreciate Prettier and would like to support our work, please consider sponsoring us directly via our OpenCollective or by sponsoring the projects we depend on, such as typescript-eslint, remark, and Babel. Thank you for your continued support!Read morePrettier 3.3: New Flow features and a lot of bug fixesJune 1, 2024 ¬∑ 7 min readSosuke SuzukiThis release includes support for new Flow features such as component and hook declarations. All of these features were implemented by the engineers on the Flow team, thank you.
If you appreciate Prettier and would like to support our work, please consider sponsoring us directly via our OpenCollective or by sponsoring the projects we depend on, such as typescript-eslint, remark, and Babel. Thank you for your continued support!Read morePrettier 3.2: Support JSONC and Angular‚Äôs ICU expressionJanuary 12, 2024 ¬∑ 6 min readSosuke SuzukiThis release includes new features such as adding a JSONC parser, adding Angular‚Äôs ICU expressions, and many bug fixes.
We are still seeking feedback for the --experimental-ternaries option released in Prettier 3.1. Please read A curious case of the ternaries and respond via the Google Forms link provided.
Additionally, we recommend reading Prettier's CLI: A Performance Deep Dive by Fabio Spampinato. This faster CLI is slated to be released as version 4.0.Read morePrettier's CLI: A Performance Deep DiveNovember 30, 2023 ¬∑ 24 min readFabio SpampinatoHey, I'm Fabio and I've been contracted by the Prettier team to speed up Prettier's command line interface (CLI). In this post we'll take a look at the optimizations I've discovered, the process that lead to finding them, some exciting numbers comparing the current CLI with the new one, and some guesses about what could be optimized next.Read more$20k Bounty was Claimed!November 27, 2023 ¬∑ 4 min readChristopher ChedeauPrettier, a JavaScript code formatter, has seen an incredible adoption thanks to its careful handling of the very, very, long tail of ways people can write code. At this point, the formatting logic has been solid and after our work on ternaries lands, it will be in a happy state.
This means that we can now focus on the next important aspect: Performance. Prettier has never been fast per se, but fast enough for most use cases. This has always felt unsatisfying so we wanted to do something about it. What better way than a friendly competition.
On November 9th, we put up a $10k bounty for any project written in Rust that would pass 95% of Prettier test suite. Guillermo Rauch, CEO of Vercel, matched it to bring it to $20k and napi.rs added another $2.5k. The folks at Algora even made an amazing landing page for it.
Read morePrettier 3.1: New experimental ternaries formatting and Angular control flow syntax!November 13, 2023 ¬∑ 12 min readSosuke SuzukiThis release adds indentation back to nested ternaries along with a new --experimental-ternaries flag to try a more novel "curious ternary" format that scales better to deeply nested conditionals. We are keen for your feedback on the experimental format before it rolls out as the default behavior later this year!
We have also added support for the control flow syntax in Angular v17. For details on the syntax, please read the official Angular release post.Read moreA curious case of the ternariesNovember 13, 2023 ¬∑ 6 min readAlex RattrayTernary formatting has always been a challenge, and we're finally addressing it in v3.1.0 with the introduction of a novel formatting style.
Read on for our journey and the motivation behind this change, along with early developer feedback and an overview of the "curious ternaries" style.
Please give the --experimental-ternaries option a try and let us know what you think!
For a quick tl;dr, see the release post.Read morePrettier 3.0: Hello, ECMAScript Modules!July 5, 2023 ¬∑ 36 min readSosuke SuzukiWe are excited to announce the release of the new version of Prettier!
We have made the migration to using ECMAScript Modules for all our source code. This change has significantly improved the development experience for the Prettier team. Please rest assured that when using Prettier as a library, you can still use it as CommonJS as well.
This update comes with several breaking changes. One notable example is the alteration in markdown formatting - spaces are no longer inserted between Latin characters and Chinese or Japanese characters. We'd like to extend our gratitude to Tatsunori Uchino, who has made significant contributions to Prettier over the past year, particularly with this feature. Additionally, the default value of trailingComma has been changed to "all".
Another important change in this release is the significant overhaul of the plugin interface. Prettier now supports plugins written using ECMAScript Modules and async parsers. If you're a plugin developer, please exercise caution while updating. You can find the migration guide here. As always, we welcome bug reports and feedback!
This release also includes numerous formatting improvements and bug fixes.
If you appreciate Prettier and would like to support our work, please consider sponsoring us directly via our OpenCollective or by sponsoring the projects we depend on, such as typescript-eslint, remark, and Babel. Thank you for your continued support!Read morePrettier 2.8: improve --cache CLI option and TypeScript 4.9 satisfies operator!November 23, 2022 ¬∑ 7 min readSosuke SuzukiThis release includes improvements to the --cache option added in 2.7. A new --cache-location option has been added, and a bug that saved the cache even when --write wasn't specified has been fixed.
We're also adding support for TypeScript 4.9 satisfies operator!
If you enjoy Prettier and would like to support our work, consider sponsoring us directly via our OpenCollective or by sponsoring the projects we depend on, including typescript-eslint, remark, and Babel.
The Prettier team plans to release 3.0 within the next few months. If you are a plugin developer, get ready for the migration. Visit the migration guide and issue #13606 for more information.Read more\n\nPrettier 3.5: New objectWrap option, experimentalOperatorPosition option and TS config file support!February 9, 2025 ¬∑ 9 min readSosuke SuzukiThis release includes a lot of bug fixes and the following new features:

Support for the new objectWrap option
Support for the new experimental experimentalOperatorPosition option
Support for TypeScript configuration file

See each section for details.Read morePrettier 3.4: A lot of bug fixesNovember 26, 2024 ¬∑ 19 min readSosuke SuzukiThis release includes numerous bug fixes and other improvements.
If you appreciate Prettier and would like to support our work, please consider sponsoring us directly via our OpenCollective or by sponsoring the projects we depend on, such as typescript-eslint, remark, and Babel. Thank you for your continued support!Read morePrettier 3.3: New Flow features and a lot of bug fixesJune 1, 2024 ¬∑ 7 min readSosuke SuzukiThis release includes support for new Flow features such as component and hook declarations. All of these features were implemented by the engineers on the Flow team, thank you.
If you appreciate Prettier and would like to support our work, please consider sponsoring us directly via our OpenCollective or by sponsoring the projects we depend on, such as typescript-eslint, remark, and Babel. Thank you for your continued support!Read morePrettier 3.2: Support JSONC and Angular‚Äôs ICU expressionJanuary 12, 2024 ¬∑ 6 min readSosuke SuzukiThis release includes new features such as adding a JSONC parser, adding Angular‚Äôs ICU expressions, and many bug fixes.
We are still seeking feedback for the --experimental-ternaries option released in Prettier 3.1. Please read A curious case of the ternaries and respond via the Google Forms link provided.
Additionally, we recommend reading Prettier's CLI: A Performance Deep Dive by Fabio Spampinato. This faster CLI is slated to be released as version 4.0.Read morePrettier's CLI: A Performance Deep DiveNovember 30, 2023 ¬∑ 24 min readFabio SpampinatoHey, I'm Fabio and I've been contracted by the Prettier team to speed up Prettier's command line interface (CLI). In this post we'll take a look at the optimizations I've discovered, the process that lead to finding them, some exciting numbers comparing the current CLI with the new one, and some guesses about what could be optimized next.Read more$20k Bounty was Claimed!November 27, 2023 ¬∑ 4 min readChristopher ChedeauPrettier, a JavaScript code formatter, has seen an incredible adoption thanks to its careful handling of the very, very, long tail of ways people can write code. At this point, the formatting logic has been solid and after our work on ternaries lands, it will be in a happy state.
This means that we can now focus on the next important aspect: Performance. Prettier has never been fast per se, but fast enough for most use cases. This has always felt unsatisfying so we wanted to do something about it. What better way than a friendly competition.
On November 9th, we put up a $10k bounty for any project written in Rust that would pass 95% of Prettier test suite. Guillermo Rauch, CEO of Vercel, matched it to bring it to $20k and napi.rs added another $2.5k. The folks at Algora even made an amazing landing page for it.
Read morePrettier 3.1: New experimental ternaries formatting and Angular control flow syntax!November 13, 2023 ¬∑ 12 min readSosuke SuzukiThis release adds indentation back to nested ternaries along with a new --experimental-ternaries flag to try a more novel "curious ternary" format that scales better to deeply nested conditionals. We are keen for your feedback on the experimental format before it rolls out as the default behavior later this year!
We have also added support for the control flow syntax in Angular v17. For details on the syntax, please read the official Angular release post.Read moreA curious case of the ternariesNovember 13, 2023 ¬∑ 6 min readAlex RattrayTernary formatting has always been a challenge, and we're finally addressing it in v3.1.0 with the introduction of a novel formatting style.
Read on for our journey and the motivation behind this change, along with early developer feedback and an overview of the "curious ternaries" style.
Please give the --experimental-ternaries option a try and let us know what you think!
For a quick tl;dr, see the release post.Read morePrettier 3.0: Hello, ECMAScript Modules!July 5, 2023 ¬∑ 36 min readSosuke SuzukiWe are excited to announce the release of the new version of Prettier!
We have made the migration to using ECMAScript Modules for all our source code. This change has significantly improved the development experience for the Prettier team. Please rest assured that when using Prettier as a library, you can still use it as CommonJS as well.
This update comes with several breaking changes. One notable example is the alteration in markdown formatting - spaces are no longer inserted between Latin characters and Chinese or Japanese characters. We'd like to extend our gratitude to Tatsunori Uchino, who has made significant contributions to Prettier over the past year, particularly with this feature. Additionally, the default value of trailingComma has been changed to "all".
Another important change in this release is the significant overhaul of the plugin interface. Prettier now supports plugins written using ECMAScript Modules and async parsers. If you're a plugin developer, please exercise caution while updating. You can find the migration guide here. As always, we welcome bug reports and feedback!
This release also includes numerous formatting improvements and bug fixes.
If you appreciate Prettier and would like to support our work, please consider sponsoring us directly via our OpenCollective or by sponsoring the projects we depend on, such as typescript-eslint, remark, and Babel. Thank you for your continued support!Read morePrettier 2.8: improve --cache CLI option and TypeScript 4.9 satisfies operator!November 23, 2022 ¬∑ 7 min readSosuke SuzukiThis release includes improvements to the --cache option added in 2.7. A new --cache-location option has been added, and a bug that saved the cache even when --write wasn't specified has been fixed.
We're also adding support for TypeScript 4.9 satisfies operator!
If you enjoy Prettier and would like to support our work, consider sponsoring us directly via our OpenCollective or by sponsoring the projects we depend on, including typescript-eslint, remark, and Babel.
The Prettier team plans to release 3.0 within the next few months. If you are a plugin developer, get ready for the migration. Visit the migration guide and issue #13606 for more information.Read moreOlder entries\n\n\n\nOn this pageWhy Prettier?Building and enforcing a style guide‚Äã
By far the biggest reason for adopting Prettier is to stop all the on-going debates over styles. It is generally accepted that having a common style guide is valuable for a project and team but getting there is a very painful and unrewarding process. People get very emotional around particular ways of writing code and nobody likes spending time writing and receiving nits.
So why choose the ‚ÄúPrettier style guide‚Äù over any other random style guide? Because Prettier is the only ‚Äústyle guide‚Äù that is fully automatic. Even if Prettier does not format all code 100% the way you‚Äôd like, it‚Äôs worth the ‚Äúsacrifice‚Äù given the unique benefits of Prettier, don‚Äôt you think?

‚ÄúWe want to free mental threads and end discussions around style. While sometimes fruitful, these discussions are for the most part wasteful.‚Äù
‚ÄúLiterally had an engineer go through a huge effort of cleaning up all of our code because we were debating ternary style for the longest time and were inconsistent about it. It was dumb, but it was a weird on-going ‚Äúgreat debate‚Äù that wasted lots of little back and forth bits. It‚Äôs far easier for us all to agree now: just run Prettier, and go with that style.‚Äù
‚ÄúGetting tired telling people how to style their product code.‚Äù
‚ÄúOur top reason was to stop wasting our time debating style nits.‚Äù
‚ÄúHaving a githook set up has reduced the amount of style issues in PRs that result in broken builds due to ESLint rules or things I have to nit-pick or clean up later.‚Äù
‚ÄúI don‚Äôt want anybody to nitpick any other person ever again.‚Äù
‚ÄúIt reminds me of how Steve Jobs used to wear the same clothes every day because he has a million decisions to make and he didn‚Äôt want to be bothered to make trivial ones like picking out clothes. I think Prettier is like that.‚Äù

Helping Newcomers‚Äã
Prettier is usually introduced by people with experience in the current codebase and JavaScript but the people that disproportionally benefit from it are newcomers to the codebase. One may think that it‚Äôs only useful for people with very limited programming experience, but we've seen it quicken the ramp up time from experienced engineers joining the company, as they likely used a different coding style before, and developers coming from a different programming language.

‚ÄúMy motivations for using Prettier are: appearing that I know how to write JavaScript well.‚Äù
‚ÄúI always put spaces in the wrong place, now I don‚Äôt have to worry about it anymore.‚Äù
‚ÄúWhen you're a beginner you're making a lot of mistakes caused by the syntax. Thanks to Prettier, you can reduce these mistakes and save a lot of time to focus on what really matters.‚Äù
‚ÄúAs a teacher, I will also tell to my students to install Prettier to help them to learn the JS syntax and have readable files.‚Äù

Writing code‚Äã
What usually happens once people are using Prettier is that they realize that they actually spend a lot of time and mental energy formatting their code. With Prettier editor integration, you can just press that magic key binding and poof, the code is formatted. This is an eye opening experience if anything else.

‚ÄúI want to write code. Not spend cycles on formatting.‚Äù
‚ÄúIt removed 5% that sucks in our daily life - aka formatting‚Äù
‚ÄúWe're in 2017 and it‚Äôs still painful to break a call into multiple lines when you happen to add an argument that makes it go over the 80 columns limit :(‚Äú

Easy to adopt‚Äã
We've worked very hard to use the least controversial coding styles, went through many rounds of fixing all the edge cases and polished the getting started experience. When you're ready to push Prettier into your codebase, not only should it be painless for you to do it technically but the newly formatted codebase should not generate major controversy and be accepted painlessly by your co-workers.

‚ÄúIt‚Äôs low overhead. We were able to throw Prettier at very different kinds of repos without much work.‚Äù
‚ÄúIt‚Äôs been mostly bug free. Had there been major styling issues during the course of implementation we would have been wary about throwing this at our JS codebase. I‚Äôm happy to say that‚Äôs not the case.‚Äù
‚ÄúEveryone runs it as part of their pre commit scripts, a couple of us use the editor on save extensions as well.‚Äù
‚ÄúIt‚Äôs fast, against one of our larger JS codebases we were able to run Prettier in under 13 seconds.‚Äù
‚ÄúThe biggest benefit for Prettier for us was being able to format the entire code base at once.‚Äù

Clean up an existing codebase‚Äã
Since coming up with a coding style and enforcing it is a big undertaking, it often slips through the cracks and you are left working on inconsistent codebases. Running Prettier in this case is a quick win, the codebase is now uniform and easier to read without spending hardly any time.

‚ÄúTake a look at the code :) I just need to restore sanity.‚Äù
‚ÄúWe inherited a ~2000 module ES6 code base, developed by 20 different developers over 18 months, in a global team. Felt like such a win without much research.‚Äù

Ride the hype train‚Äã
Purely technical aspects of the projects aren‚Äôt the only thing people look into when choosing to adopt Prettier. Who built and uses it and how quickly it spreads through the community has a non-trivial impact.

‚ÄúThe amazing thing, for me, is: 1) Announced 2 months ago. 2) Already adopted by, it seems, every major JS project. 3) 7000 stars, 100,000 npm downloads/mo‚Äù
‚ÄúWas built by the same people as React & React Native.‚Äù
‚ÄúI like to be part of the hot new things.‚Äù
‚ÄúBecause soon enough people are gonna ask for it.‚Äù
Edit this page\n\nOn this pageWhy Prettier?Building and enforcing a style guide‚Äã
By far the biggest reason for adopting Prettier is to stop all the on-going debates over styles. It is generally accepted that having a common style guide is valuable for a project and team but getting there is a very painful and unrewarding process. People get very emotional around particular ways of writing code and nobody likes spending time writing and receiving nits.
So why choose the ‚ÄúPrettier style guide‚Äù over any other random style guide? Because Prettier is the only ‚Äústyle guide‚Äù that is fully automatic. Even if Prettier does not format all code 100% the way you‚Äôd like, it‚Äôs worth the ‚Äúsacrifice‚Äù given the unique benefits of Prettier, don‚Äôt you think?

‚ÄúWe want to free mental threads and end discussions around style. While sometimes fruitful, these discussions are for the most part wasteful.‚Äù
‚ÄúLiterally had an engineer go through a huge effort of cleaning up all of our code because we were debating ternary style for the longest time and were inconsistent about it. It was dumb, but it was a weird on-going ‚Äúgreat debate‚Äù that wasted lots of little back and forth bits. It‚Äôs far easier for us all to agree now: just run Prettier, and go with that style.‚Äù
‚ÄúGetting tired telling people how to style their product code.‚Äù
‚ÄúOur top reason was to stop wasting our time debating style nits.‚Äù
‚ÄúHaving a githook set up has reduced the amount of style issues in PRs that result in broken builds due to ESLint rules or things I have to nit-pick or clean up later.‚Äù
‚ÄúI don‚Äôt want anybody to nitpick any other person ever again.‚Äù
‚ÄúIt reminds me of how Steve Jobs used to wear the same clothes every day because he has a million decisions to make and he didn‚Äôt want to be bothered to make trivial ones like picking out clothes. I think Prettier is like that.‚Äù

Helping Newcomers‚Äã
Prettier is usually introduced by people with experience in the current codebase and JavaScript but the people that disproportionally benefit from it are newcomers to the codebase. One may think that it‚Äôs only useful for people with very limited programming experience, but we've seen it quicken the ramp up time from experienced engineers joining the company, as they likely used a different coding style before, and developers coming from a different programming language.

‚ÄúMy motivations for using Prettier are: appearing that I know how to write JavaScript well.‚Äù
‚ÄúI always put spaces in the wrong place, now I don‚Äôt have to worry about it anymore.‚Äù
‚ÄúWhen you're a beginner you're making a lot of mistakes caused by the syntax. Thanks to Prettier, you can reduce these mistakes and save a lot of time to focus on what really matters.‚Äù
‚ÄúAs a teacher, I will also tell to my students to install Prettier to help them to learn the JS syntax and have readable files.‚Äù

Writing code‚Äã
What usually happens once people are using Prettier is that they realize that they actually spend a lot of time and mental energy formatting their code. With Prettier editor integration, you can just press that magic key binding and poof, the code is formatted. This is an eye opening experience if anything else.

‚ÄúI want to write code. Not spend cycles on formatting.‚Äù
‚ÄúIt removed 5% that sucks in our daily life - aka formatting‚Äù
‚ÄúWe're in 2017 and it‚Äôs still painful to break a call into multiple lines when you happen to add an argument that makes it go over the 80 columns limit :(‚Äú

Easy to adopt‚Äã
We've worked very hard to use the least controversial coding styles, went through many rounds of fixing all the edge cases and polished the getting started experience. When you're ready to push Prettier into your codebase, not only should it be painless for you to do it technically but the newly formatted codebase should not generate major controversy and be accepted painlessly by your co-workers.

‚ÄúIt‚Äôs low overhead. We were able to throw Prettier at very different kinds of repos without much work.‚Äù
‚ÄúIt‚Äôs been mostly bug free. Had there been major styling issues during the course of implementation we would have been wary about throwing this at our JS codebase. I‚Äôm happy to say that‚Äôs not the case.‚Äù
‚ÄúEveryone runs it as part of their pre commit scripts, a couple of us use the editor on save extensions as well.‚Äù
‚ÄúIt‚Äôs fast, against one of our larger JS codebases we were able to run Prettier in under 13 seconds.‚Äù
‚ÄúThe biggest benefit for Prettier for us was being able to format the entire code base at once.‚Äù

Clean up an existing codebase‚Äã
Since coming up with a coding style and enforcing it is a big undertaking, it often slips through the cracks and you are left working on inconsistent codebases. Running Prettier in this case is a quick win, the codebase is now uniform and easier to read without spending hardly any time.

‚ÄúTake a look at the code :) I just need to restore sanity.‚Äù
‚ÄúWe inherited a ~2000 module ES6 code base, developed by 20 different developers over 18 months, in a global team. Felt like such a win without much research.‚Äù

Ride the hype train‚Äã
Purely technical aspects of the projects aren‚Äôt the only thing people look into when choosing to adopt Prettier. Who built and uses it and how quickly it spreads through the community has a non-trivial impact.

‚ÄúThe amazing thing, for me, is: 1) Announced 2 months ago. 2) Already adopted by, it seems, every major JS project. 3) 7000 stars, 100,000 npm downloads/mo‚Äù
‚ÄúWas built by the same people as React & React Native.‚Äù
‚ÄúI like to be part of the hot new things.‚Äù
‚ÄúBecause soon enough people are gonna ask for it.‚Äù
Edit this pagePreviousWhat is Prettier?NextPrettier vs. LintersBuilding and enforcing a style guideHelping NewcomersWriting codeEasy to adoptClean up an existing codebaseRide the hype train\n\n\n\nOn this pagePrettier vs. LintersHow does it compare to ESLint/TSLint/stylelint, etc.?‚Äã
Linters have two categories of rules:
Formatting rules: eg: max-len, no-mixed-spaces-and-tabs, keyword-spacing, comma-style‚Ä¶
Prettier alleviates the need for this whole category of rules! Prettier is going to reprint the entire program from scratch in a consistent way, so it‚Äôs not possible for the programmer to make a mistake there anymore :)
Code-quality rules: eg no-unused-vars, no-extra-bind, no-implicit-globals, prefer-promise-reject-errors‚Ä¶
Prettier does nothing to help with those kind of rules. They are also the most important ones provided by linters as they are likely to catch real bugs with your code!
In other words, use Prettier for formatting and linters for catching bugs!Edit this page\n\nOn this pagePrettier vs. LintersHow does it compare to ESLint/TSLint/stylelint, etc.?‚Äã
Linters have two categories of rules:
Formatting rules: eg: max-len, no-mixed-spaces-and-tabs, keyword-spacing, comma-style‚Ä¶
Prettier alleviates the need for this whole category of rules! Prettier is going to reprint the entire program from scratch in a consistent way, so it‚Äôs not possible for the programmer to make a mistake there anymore :)
Code-quality rules: eg no-unused-vars, no-extra-bind, no-implicit-globals, prefer-promise-reject-errors‚Ä¶
Prettier does nothing to help with those kind of rules. They are also the most important ones provided by linters as they are likely to catch real bugs with your code!
In other words, use Prettier for formatting and linters for catching bugs!Edit this pagePreviousWhy Prettier?NextOption PhilosophyHow does it compare to ESLint/TSLint/stylelint, etc.?\n\n\n\nOption PhilosophyinfoPrettier has a few options because of history. But we won‚Äôt add more of them.Read on to learn more.
Prettier is not a kitchen-sink code formatter that attempts to print your code in any way you wish. It is opinionated. Quoting the Why Prettier? page:

By far the biggest reason for adopting Prettier is to stop all the ongoing debates over styles.

Yet the more options Prettier has, the further from the above goal it gets. The debates over styles just turn into debates over which Prettier options to use. Formatting wars break out with renewed vigour: ‚ÄúWhich option values are better? Why? Did we make the right choices?‚Äù
And it‚Äôs not the only cost options have. To learn more about their downsides, see the issue about resisting adding configuration, which has more üëçs than any option request issue.
So why are there any options at all?

A few were added during Prettier‚Äôs infancy to make it take off at all. üöÄ
A couple were added after ‚Äúgreat demand.‚Äù ü§î
Some were added for compatibility reasons. üëç

Options that are easier to motivate include:

--trailing-comma es5 lets you use trailing commas in most environments without having to transpile (trailing function commas were added in ES2017).
--prose-wrap is important to support all quirky Markdown renderers in the wild.
--html-whitespace-sensitivity is needed due to the unfortunate whitespace rules of HTML.
--end-of-line makes it easier for teams to keep CRLFs out of their git repositories.
--quote-props is important for advanced usage of the Google Closure Compiler.

But other options are harder to motivate in hindsight: --arrow-parens, --jsx-single-quote, --bracket-same-line and --no-bracket-spacing are not the type of options we‚Äôre happy to have. They cause a lot of bike-shedding in teams, and we‚Äôre sorry for that. Difficult to remove now, these options exist as a historical artifact and should not motivate adding more options (‚ÄúIf those options exist, why can‚Äôt this one?‚Äù).
For a long time, we left option requests open in order to let discussions play out and collect feedback. What we‚Äôve learned during those years is that it‚Äôs really hard to measure demand. Prettier has grown a lot in usage. What was ‚Äúgreat demand‚Äù back in the day is not as much today. GitHub reactions and Twitter polls became unrepresentative. What about all silent users? It looked easy to add ‚Äújust one more‚Äù option. But where should we have stopped? When is one too many? Even after adding ‚Äúthat one final option‚Äù, there would always be a ‚Äútop issue‚Äù in the issue tracker.
However, the time to stop has come. Now that Prettier is mature enough and we see it adopted by so many organizations and projects, the research phase is over. We have enough confidence to conclude that Prettier reached a point where the set of options should be ‚Äúfrozen‚Äù. Option requests aren‚Äôt accepted anymore. We‚Äôre thankful to everyone who participated in this difficult journey.
Please note that as option requests are out of scope for Prettier, they will be closed without discussion. The same applies to requests to preserve elements of input formatting (e.g. line breaks) since that‚Äôs nothing else but an option in disguise with all the downsides of ‚Äúreal‚Äù options. There may be situations where adding an option can‚Äôt be avoided because of technical necessity (e.g. compatibility), but for formatting-related options, this is final.Edit this page\n\nOption PhilosophyinfoPrettier has a few options because of history. But we won‚Äôt add more of them.Read on to learn more.
Prettier is not a kitchen-sink code formatter that attempts to print your code in any way you wish. It is opinionated. Quoting the Why Prettier? page:

By far the biggest reason for adopting Prettier is to stop all the ongoing debates over styles.

Yet the more options Prettier has, the further from the above goal it gets. The debates over styles just turn into debates over which Prettier options to use. Formatting wars break out with renewed vigour: ‚ÄúWhich option values are better? Why? Did we make the right choices?‚Äù
And it‚Äôs not the only cost options have. To learn more about their downsides, see the issue about resisting adding configuration, which has more üëçs than any option request issue.
So why are there any options at all?

A few were added during Prettier‚Äôs infancy to make it take off at all. üöÄ
A couple were added after ‚Äúgreat demand.‚Äù ü§î
Some were added for compatibility reasons. üëç

Options that are easier to motivate include:

--trailing-comma es5 lets you use trailing commas in most environments without having to transpile (trailing function commas were added in ES2017).
--prose-wrap is important to support all quirky Markdown renderers in the wild.
--html-whitespace-sensitivity is needed due to the unfortunate whitespace rules of HTML.
--end-of-line makes it easier for teams to keep CRLFs out of their git repositories.
--quote-props is important for advanced usage of the Google Closure Compiler.

But other options are harder to motivate in hindsight: --arrow-parens, --jsx-single-quote, --bracket-same-line and --no-bracket-spacing are not the type of options we‚Äôre happy to have. They cause a lot of bike-shedding in teams, and we‚Äôre sorry for that. Difficult to remove now, these options exist as a historical artifact and should not motivate adding more options (‚ÄúIf those options exist, why can‚Äôt this one?‚Äù).
For a long time, we left option requests open in order to let discussions play out and collect feedback. What we‚Äôve learned during those years is that it‚Äôs really hard to measure demand. Prettier has grown a lot in usage. What was ‚Äúgreat demand‚Äù back in the day is not as much today. GitHub reactions and Twitter polls became unrepresentative. What about all silent users? It looked easy to add ‚Äújust one more‚Äù option. But where should we have stopped? When is one too many? Even after adding ‚Äúthat one final option‚Äù, there would always be a ‚Äútop issue‚Äù in the issue tracker.
However, the time to stop has come. Now that Prettier is mature enough and we see it adopted by so many organizations and projects, the research phase is over. We have enough confidence to conclude that Prettier reached a point where the set of options should be ‚Äúfrozen‚Äù. Option requests aren‚Äôt accepted anymore. We‚Äôre thankful to everyone who participated in this difficult journey.
Please note that as option requests are out of scope for Prettier, they will be closed without discussion. The same applies to requests to preserve elements of input formatting (e.g. line breaks) since that‚Äôs nothing else but an option in disguise with all the downsides of ‚Äúreal‚Äù options. There may be situations where adding an option can‚Äôt be avoided because of technical necessity (e.g. compatibility), but for formatting-related options, this is final.Edit this pagePreviousPrettier vs. LintersNextRationale\n\n\n\nOn this pageRationalePrettier is an opinionated code formatter. This document explains some of its choices.
What Prettier is concerned about‚Äã
Correctness‚Äã
The first requirement of Prettier is to output valid code that has the exact same behavior as before formatting. Please report any code where Prettier fails to follow these correctness rules ‚Äî that‚Äôs a bug which needs to be fixed!
Strings‚Äã
Double or single quotes? Prettier chooses the one which results in the fewest number of escapes. "It's gettin' better!", not 'It\'s gettin\' better!'. In case of a tie or the string not containing any quotes, Prettier defaults to double quotes (but that can be changed via the singleQuote option).
JSX has its own option for quotes: jsxSingleQuote.
JSX takes its roots from HTML, where the dominant use of quotes for attributes is double quotes. Browser developer tools also follow this convention by always displaying HTML with double quotes, even if the source code uses single quotes. A separate option allows using single quotes for JS and double quotes for "HTML" (JSX).
Prettier maintains the way your string is escaped. For example, "üôÇ" won‚Äôt be formatted into "\uD83D\uDE42" and vice versa.
Empty lines‚Äã
It turns out that empty lines are very hard to automatically generate. The approach that Prettier takes is to preserve empty lines the way they were in the original source code. There are two additional rules:

Prettier collapses multiple blank lines into a single blank line.
Empty lines at the start and end of blocks (and whole files) are removed. (Files always end with a single newline, though.)

Multi-line objects‚Äã
By default, Prettier‚Äôs printing algorithm prints expressions on a single line if they fit. Objects are used for a lot of different things in JavaScript, though, and sometimes it really helps readability if they stay multiline. See object lists, nested configs, stylesheets and keyed methods, for example. We haven‚Äôt been able to find a good rule for all those cases, so by default Prettier keeps objects multi-line if there‚Äôs a newline between the { and the first key in the original source code. Consequently, long single-line objects are automatically expanded, but short multi-line objects are never collapsed.
You can disable this conditional behavior with the objectWrap option.
Tip: If you have a multi-line object that you‚Äôd like to join up into a single line:
const user = {  name: "John Doe",  age: 30,};
‚Ä¶all you need to do is remove the newline after {:
const user = {  name: "John Doe",  age: 30};
‚Ä¶and then run Prettier:
const user = { name: "John Doe", age: 30 };
And if you‚Äôd like to go multi-line again, add in a newline after {:
const user = { name: "John Doe", age: 30 };
‚Ä¶and run Prettier:
const user = {  name: "John Doe",  age: 30,};
A note on formatting reversibilityThe semi-manual formatting for object literals is in fact a workaround, not a feature. It was implemented only because at the time a good heuristic wasn‚Äôt found and an urgent fix was needed. However, as a general strategy, Prettier avoids non-reversible formatting like that, so the team is still looking for heuristics that would allow either to remove this behavior completely or at least to reduce the number of situations where it‚Äôs applied.What does reversible mean? Once an object literal becomes multiline, Prettier won‚Äôt collapse it back. If in Prettier-formatted code, we add a property to an object literal, run Prettier, then change our mind, remove the added property, and then run Prettier again, we might end up with a formatting not identical to the initial one. This useless change might even get included in a commit, which is exactly the kind of situation Prettier was created to prevent.
Decorators‚Äã
Just like with objects, decorators are used for a lot of different things. Sometimes it makes sense to write decorators above the line they're decorating, sometimes it‚Äôs nicer if they're on the same line. We haven‚Äôt been able to find a good rule for this, so Prettier keeps your decorator positioned like you wrote them (if they fit on the line). This isn‚Äôt ideal, but a pragmatic solution to a difficult problem.
@Component({  selector: "hero-button",  template: `<button>{{ label }}</button>`,})class HeroButtonComponent {  // These decorators were written inline and fit on the line so they stay  // inline.  @Output() change = new EventEmitter();  @Input() label: string;  // These were written multiline, so they stay multiline.  @readonly  @nonenumerable  NODE_TYPE: 2;}
There‚Äôs one exception: classes. We don‚Äôt think it ever makes sense to inline the decorators for them, so they are always moved to their own line.
// Before running Prettier:@observer class OrderLine {  @observable price: number = 0;}
// After running Prettier:@observerclass OrderLine {  @observable price: number = 0;}
Note: Prettier 1.14.x and older tried to automatically move your decorators, so if you've run an older Prettier version on your code you might need to manually join up some decorators here and there to avoid inconsistencies:
@observerclass OrderLine {  @observable price: number = 0;  @observable  amount: number = 0;}
One final thing: TC39 has not yet decided if decorators come before or after export. In the meantime, Prettier supports both:
@decorator export class Foo {}export @decorator class Foo {}
Template literals‚Äã
Template literals can contain interpolations. Deciding whether it's appropriate to insert a linebreak within an interpolation unfortunately depends on the semantic content of the template - for example, introducing a linebreak in the middle of a natural-language sentence is usually undesirable. Since Prettier doesn't have enough information to make this decision itself, it uses a heuristic similar to that used for objects: it will only split an interpolation expression across multiple lines if there was already a linebreak within that interpolation.
This means that a literal like the following will not be broken onto multiple lines, even if it exceeds the print width:
`this is a long message which contains an interpolation: ${format(data)} <- like this`;
If you want Prettier to split up an interpolation, you'll need to ensure there's a linebreak somewhere within the ${...}. Otherwise it will keep everything on a single line, no matter how long it is.
The team would prefer not to depend on the original formatting in this way, but it's the best heuristic we have at the moment.
Semicolons‚Äã
This is about using the noSemi option.
Consider this piece of code:
if (shouldAddLines) {  [-1, 1].forEach(delta => addLine(delta * 20))}
While the above code works just fine without semicolons, Prettier actually turns it into:
if (shouldAddLines) {  ;[-1, 1].forEach(delta => addLine(delta * 20))}
This is to help you avoid mistakes. Imagine Prettier not inserting that semicolon and adding this line:
 if (shouldAddLines) {+  console.log('Do we even get here??')   [-1, 1].forEach(delta => addLine(delta * 20)) }
Oops! The above actually means:
if (shouldAddLines) {  console.log('Do we even get here??')[-1, 1].forEach(delta => addLine(delta * 20))}
With a semicolon in front of that [ such issues never happen. It makes the line independent of other lines so you can move and add lines without having to think about ASI rules.
This practice is also common in standard which uses a semicolon-free style.
Note that if your program currently has a semicolon-related bug in it, Prettier will not auto-fix the bug for you. Remember, Prettier only reformats code, it does not change the behavior of the code. Take this buggy piece of code as an example, where the developer forgot to place a semicolon before the (:
console.log('Running a background task')(async () => {  await doBackgroundWork()})()
If you feed this into Prettier, it will not alter the behavior of this code, instead, it will reformat it in a way that shows how this code will actually behave when ran.
console.log("Running a background task")(async () => {  await doBackgroundWork();})();
Print width‚Äã
The printWidth option is more of a guideline to Prettier than a hard rule. It is not the upper allowed line length limit. It is a way to say to Prettier roughly how long you‚Äôd like lines to be. Prettier will make both shorter and longer lines, but generally strive to meet the specified print width.
There are some edge cases, such as really long string literals, regexps, comments and variable names, which cannot be broken across lines (without using code transforms which Prettier doesn‚Äôt do). Or if you nest your code 50 levels deep your lines are of course going to be mostly indentation :)
Apart from that, there are a few cases where Prettier intentionally exceeds the print width.
Imports‚Äã
Prettier can break long import statements across several lines:
import {  CollectionDashboard,  DashboardPlaceholder,} from "../components/collections/collection-dashboard/main";
The following example doesn‚Äôt fit within the print width, but Prettier prints it in a single line anyway:
import { CollectionDashboard } from "../components/collections/collection-dashboard/main";
This might be unexpected by some, but we do it this way since it was a common request to keep imports with single elements in a single line. The same applies for require calls.
Testing functions‚Äã
Another common request was to keep lengthy test descriptions in one line, even if it gets too long. In such cases, wrapping the arguments to new lines doesn‚Äôt help much.
describe("NodeRegistry", () => {  it("makes no request if there are no nodes to prefetch, even if the cache is stale", async () => {    // The above line exceeds the print width but stayed on one line anyway.  });});
Prettier has special cases for common testing framework functions such as describe, it and test.
JSX‚Äã
Prettier prints things a little differently compared to other JS when JSX is involved:
function greet(user) {  return user    ? `Welcome back, ${user.name}!`    : "Greetings, traveler! Sign up today!";}function Greet({ user }) {  return (    <div>      {user ? (        <p>Welcome back, {user.name}!</p>      ) : (        <p>Greetings, traveler! Sign up today!</p>      )}    </div>  );}
There are two reasons.
First off, lots of people already wrapped their JSX in parentheses, especially in return statements. Prettier follows this common style.
Secondly, the alternate formatting makes it easier to edit the JSX. It is easy to leave a semicolon behind. As opposed to normal JS, a leftover semicolon in JSX can end up as plain text showing on your page.
<div>  <p>Greetings, traveler! Sign up today!</p>; {/* <-- Oops! */}</div>
Comments‚Äã
When it comes to the content of comments, Prettier can‚Äôt do much really. Comments can contain everything from prose to commented out code and ASCII diagrams. Since they can contain anything, Prettier can‚Äôt know how to format or wrap them. So they are left as-is. The only exception to this are JSDoc-style comments (block comments where every line starts with a *), which Prettier can fix the indentation of.
Then there‚Äôs the question of where to put the comments. Turns out this is a really difficult problem. Prettier tries its best to keep your comments roughly where they were, but it‚Äôs no easy task because comments can be placed almost anywhere.
Generally, you get the best results when placing comments on their own lines, instead of at the end of lines. Prefer // eslint-disable-next-line over // eslint-disable-line.
Note that ‚Äúmagic comments‚Äù such as eslint-disable-next-line and $FlowFixMe might sometimes need to be manually moved due to Prettier breaking an expression into multiple lines.
Imagine this piece of code:
// eslint-disable-next-line no-evalconst result = safeToEval ? eval(input) : fallback(input);
Then you need to add another condition:
// eslint-disable-next-line no-evalconst result = safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);
Prettier will turn the above into:
// eslint-disable-next-line no-evalconst result =  safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);
Which means that the eslint-disable-next-line comment is no longer effective. In this case you need to move the comment:
const result =  // eslint-disable-next-line no-eval  safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);
If possible, prefer comments that operate on line ranges (e.g. eslint-disable and eslint-enable) or on the statement level (e.g. /* istanbul ignore next */), they are even safer. It‚Äôs possible to disallow using eslint-disable-line and eslint-disable-next-line comments using eslint-plugin-eslint-comments.
Disclaimer about non-standard syntax‚Äã
Prettier is often able to recognize and format non-standard syntax such as ECMAScript early-stage proposals and Markdown syntax extensions not defined by any specification. The support for such syntax is considered best-effort and experimental. Incompatibilities may be introduced in any release and should not be viewed as breaking changes.
Disclaimer about machine-generated files‚Äã
Some files, like package.json or composer.lock, are machine-generated and regularly updated by the package manager. If Prettier were to use the same JSON formatting rules as with other files, it would regularly conflict with these other tools. To avoid this inconvenience, Prettier will use a formatter based on JSON.stringify on such files instead. You may notice these differences, such as the removal of vertical whitespace, but this is an intended behavior.
What Prettier is not concerned about‚Äã
Prettier only prints code. It does not transform it. This is to limit the scope of Prettier. Let‚Äôs focus on the printing and do it really well!
Here are a few examples of things that are out of scope for Prettier:

Turning single- or double-quoted strings into template literals or vice versa.
Using + to break long string literals into parts that fit the print width.
Adding/removing {} and return where they are optional.
Turning ?: into if-else statements.
Sorting/moving imports, object keys, class members, JSX keys, CSS properties or anything else. Apart from being a transform rather than just printing (as mentioned above), sorting is potentially unsafe because of side effects (for imports, as an example) and makes it difficult to verify the most important correctness goal.
Edit this page\n\nOn this pageRationalePrettier is an opinionated code formatter. This document explains some of its choices.
What Prettier is concerned about‚Äã
Correctness‚Äã
The first requirement of Prettier is to output valid code that has the exact same behavior as before formatting. Please report any code where Prettier fails to follow these correctness rules ‚Äî that‚Äôs a bug which needs to be fixed!
Strings‚Äã
Double or single quotes? Prettier chooses the one which results in the fewest number of escapes. "It's gettin' better!", not 'It\'s gettin\' better!'. In case of a tie or the string not containing any quotes, Prettier defaults to double quotes (but that can be changed via the singleQuote option).
JSX has its own option for quotes: jsxSingleQuote.
JSX takes its roots from HTML, where the dominant use of quotes for attributes is double quotes. Browser developer tools also follow this convention by always displaying HTML with double quotes, even if the source code uses single quotes. A separate option allows using single quotes for JS and double quotes for "HTML" (JSX).
Prettier maintains the way your string is escaped. For example, "üôÇ" won‚Äôt be formatted into "\uD83D\uDE42" and vice versa.
Empty lines‚Äã
It turns out that empty lines are very hard to automatically generate. The approach that Prettier takes is to preserve empty lines the way they were in the original source code. There are two additional rules:

Prettier collapses multiple blank lines into a single blank line.
Empty lines at the start and end of blocks (and whole files) are removed. (Files always end with a single newline, though.)

Multi-line objects‚Äã
By default, Prettier‚Äôs printing algorithm prints expressions on a single line if they fit. Objects are used for a lot of different things in JavaScript, though, and sometimes it really helps readability if they stay multiline. See object lists, nested configs, stylesheets and keyed methods, for example. We haven‚Äôt been able to find a good rule for all those cases, so by default Prettier keeps objects multi-line if there‚Äôs a newline between the { and the first key in the original source code. Consequently, long single-line objects are automatically expanded, but short multi-line objects are never collapsed.
You can disable this conditional behavior with the objectWrap option.
Tip: If you have a multi-line object that you‚Äôd like to join up into a single line:
const user = {  name: "John Doe",  age: 30,};
‚Ä¶all you need to do is remove the newline after {:
const user = {  name: "John Doe",  age: 30};
‚Ä¶and then run Prettier:
const user = { name: "John Doe", age: 30 };
And if you‚Äôd like to go multi-line again, add in a newline after {:
const user = { name: "John Doe", age: 30 };
‚Ä¶and run Prettier:
const user = {  name: "John Doe",  age: 30,};
A note on formatting reversibilityThe semi-manual formatting for object literals is in fact a workaround, not a feature. It was implemented only because at the time a good heuristic wasn‚Äôt found and an urgent fix was needed. However, as a general strategy, Prettier avoids non-reversible formatting like that, so the team is still looking for heuristics that would allow either to remove this behavior completely or at least to reduce the number of situations where it‚Äôs applied.What does reversible mean? Once an object literal becomes multiline, Prettier won‚Äôt collapse it back. If in Prettier-formatted code, we add a property to an object literal, run Prettier, then change our mind, remove the added property, and then run Prettier again, we might end up with a formatting not identical to the initial one. This useless change might even get included in a commit, which is exactly the kind of situation Prettier was created to prevent.
Decorators‚Äã
Just like with objects, decorators are used for a lot of different things. Sometimes it makes sense to write decorators above the line they're decorating, sometimes it‚Äôs nicer if they're on the same line. We haven‚Äôt been able to find a good rule for this, so Prettier keeps your decorator positioned like you wrote them (if they fit on the line). This isn‚Äôt ideal, but a pragmatic solution to a difficult problem.
@Component({  selector: "hero-button",  template: `<button>{{ label }}</button>`,})class HeroButtonComponent {  // These decorators were written inline and fit on the line so they stay  // inline.  @Output() change = new EventEmitter();  @Input() label: string;  // These were written multiline, so they stay multiline.  @readonly  @nonenumerable  NODE_TYPE: 2;}
There‚Äôs one exception: classes. We don‚Äôt think it ever makes sense to inline the decorators for them, so they are always moved to their own line.
// Before running Prettier:@observer class OrderLine {  @observable price: number = 0;}
// After running Prettier:@observerclass OrderLine {  @observable price: number = 0;}
Note: Prettier 1.14.x and older tried to automatically move your decorators, so if you've run an older Prettier version on your code you might need to manually join up some decorators here and there to avoid inconsistencies:
@observerclass OrderLine {  @observable price: number = 0;  @observable  amount: number = 0;}
One final thing: TC39 has not yet decided if decorators come before or after export. In the meantime, Prettier supports both:
@decorator export class Foo {}export @decorator class Foo {}
Template literals‚Äã
Template literals can contain interpolations. Deciding whether it's appropriate to insert a linebreak within an interpolation unfortunately depends on the semantic content of the template - for example, introducing a linebreak in the middle of a natural-language sentence is usually undesirable. Since Prettier doesn't have enough information to make this decision itself, it uses a heuristic similar to that used for objects: it will only split an interpolation expression across multiple lines if there was already a linebreak within that interpolation.
This means that a literal like the following will not be broken onto multiple lines, even if it exceeds the print width:
`this is a long message which contains an interpolation: ${format(data)} <- like this`;
If you want Prettier to split up an interpolation, you'll need to ensure there's a linebreak somewhere within the ${...}. Otherwise it will keep everything on a single line, no matter how long it is.
The team would prefer not to depend on the original formatting in this way, but it's the best heuristic we have at the moment.
Semicolons‚Äã
This is about using the noSemi option.
Consider this piece of code:
if (shouldAddLines) {  [-1, 1].forEach(delta => addLine(delta * 20))}
While the above code works just fine without semicolons, Prettier actually turns it into:
if (shouldAddLines) {  ;[-1, 1].forEach(delta => addLine(delta * 20))}
This is to help you avoid mistakes. Imagine Prettier not inserting that semicolon and adding this line:
 if (shouldAddLines) {+  console.log('Do we even get here??')   [-1, 1].forEach(delta => addLine(delta * 20)) }
Oops! The above actually means:
if (shouldAddLines) {  console.log('Do we even get here??')[-1, 1].forEach(delta => addLine(delta * 20))}
With a semicolon in front of that [ such issues never happen. It makes the line independent of other lines so you can move and add lines without having to think about ASI rules.
This practice is also common in standard which uses a semicolon-free style.
Note that if your program currently has a semicolon-related bug in it, Prettier will not auto-fix the bug for you. Remember, Prettier only reformats code, it does not change the behavior of the code. Take this buggy piece of code as an example, where the developer forgot to place a semicolon before the (:
console.log('Running a background task')(async () => {  await doBackgroundWork()})()
If you feed this into Prettier, it will not alter the behavior of this code, instead, it will reformat it in a way that shows how this code will actually behave when ran.
console.log("Running a background task")(async () => {  await doBackgroundWork();})();
Print width‚Äã
The printWidth option is more of a guideline to Prettier than a hard rule. It is not the upper allowed line length limit. It is a way to say to Prettier roughly how long you‚Äôd like lines to be. Prettier will make both shorter and longer lines, but generally strive to meet the specified print width.
There are some edge cases, such as really long string literals, regexps, comments and variable names, which cannot be broken across lines (without using code transforms which Prettier doesn‚Äôt do). Or if you nest your code 50 levels deep your lines are of course going to be mostly indentation :)
Apart from that, there are a few cases where Prettier intentionally exceeds the print width.
Imports‚Äã
Prettier can break long import statements across several lines:
import {  CollectionDashboard,  DashboardPlaceholder,} from "../components/collections/collection-dashboard/main";
The following example doesn‚Äôt fit within the print width, but Prettier prints it in a single line anyway:
import { CollectionDashboard } from "../components/collections/collection-dashboard/main";
This might be unexpected by some, but we do it this way since it was a common request to keep imports with single elements in a single line. The same applies for require calls.
Testing functions‚Äã
Another common request was to keep lengthy test descriptions in one line, even if it gets too long. In such cases, wrapping the arguments to new lines doesn‚Äôt help much.
describe("NodeRegistry", () => {  it("makes no request if there are no nodes to prefetch, even if the cache is stale", async () => {    // The above line exceeds the print width but stayed on one line anyway.  });});
Prettier has special cases for common testing framework functions such as describe, it and test.
JSX‚Äã
Prettier prints things a little differently compared to other JS when JSX is involved:
function greet(user) {  return user    ? `Welcome back, ${user.name}!`    : "Greetings, traveler! Sign up today!";}function Greet({ user }) {  return (    <div>      {user ? (        <p>Welcome back, {user.name}!</p>      ) : (        <p>Greetings, traveler! Sign up today!</p>      )}    </div>  );}
There are two reasons.
First off, lots of people already wrapped their JSX in parentheses, especially in return statements. Prettier follows this common style.
Secondly, the alternate formatting makes it easier to edit the JSX. It is easy to leave a semicolon behind. As opposed to normal JS, a leftover semicolon in JSX can end up as plain text showing on your page.
<div>  <p>Greetings, traveler! Sign up today!</p>; {/* <-- Oops! */}</div>
Comments‚Äã
When it comes to the content of comments, Prettier can‚Äôt do much really. Comments can contain everything from prose to commented out code and ASCII diagrams. Since they can contain anything, Prettier can‚Äôt know how to format or wrap them. So they are left as-is. The only exception to this are JSDoc-style comments (block comments where every line starts with a *), which Prettier can fix the indentation of.
Then there‚Äôs the question of where to put the comments. Turns out this is a really difficult problem. Prettier tries its best to keep your comments roughly where they were, but it‚Äôs no easy task because comments can be placed almost anywhere.
Generally, you get the best results when placing comments on their own lines, instead of at the end of lines. Prefer // eslint-disable-next-line over // eslint-disable-line.
Note that ‚Äúmagic comments‚Äù such as eslint-disable-next-line and $FlowFixMe might sometimes need to be manually moved due to Prettier breaking an expression into multiple lines.
Imagine this piece of code:
// eslint-disable-next-line no-evalconst result = safeToEval ? eval(input) : fallback(input);
Then you need to add another condition:
// eslint-disable-next-line no-evalconst result = safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);
Prettier will turn the above into:
// eslint-disable-next-line no-evalconst result =  safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);
Which means that the eslint-disable-next-line comment is no longer effective. In this case you need to move the comment:
const result =  // eslint-disable-next-line no-eval  safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);
If possible, prefer comments that operate on line ranges (e.g. eslint-disable and eslint-enable) or on the statement level (e.g. /* istanbul ignore next */), they are even safer. It‚Äôs possible to disallow using eslint-disable-line and eslint-disable-next-line comments using eslint-plugin-eslint-comments.
Disclaimer about non-standard syntax‚Äã
Prettier is often able to recognize and format non-standard syntax such as ECMAScript early-stage proposals and Markdown syntax extensions not defined by any specification. The support for such syntax is considered best-effort and experimental. Incompatibilities may be introduced in any release and should not be viewed as breaking changes.
Disclaimer about machine-generated files‚Äã
Some files, like package.json or composer.lock, are machine-generated and regularly updated by the package manager. If Prettier were to use the same JSON formatting rules as with other files, it would regularly conflict with these other tools. To avoid this inconvenience, Prettier will use a formatter based on JSON.stringify on such files instead. You may notice these differences, such as the removal of vertical whitespace, but this is an intended behavior.
What Prettier is not concerned about‚Äã
Prettier only prints code. It does not transform it. This is to limit the scope of Prettier. Let‚Äôs focus on the printing and do it really well!
Here are a few examples of things that are out of scope for Prettier:

Turning single- or double-quoted strings into template literals or vice versa.
Using + to break long string literals into parts that fit the print width.
Adding/removing {} and return where they are optional.
Turning ?: into if-else statements.
Sorting/moving imports, object keys, class members, JSX keys, CSS properties or anything else. Apart from being a transform rather than just printing (as mentioned above), sorting is potentially unsafe because of side effects (for imports, as an example) and makes it difficult to verify the most important correctness goal.
Edit this pagePreviousOption PhilosophyNextInstallWhat Prettier is concerned aboutCorrectnessStringsEmpty linesMulti-line objectsDecoratorsTemplate literalsSemicolonsPrint widthJSXCommentsDisclaimer about non-standard syntaxDisclaimer about machine-generated filesWhat Prettier is not concerned about\n\n\n\nOn this pageInstallFirst, install Prettier locally:
npmyarnpnpmbunnpm install --save-dev --save-exact prettieryarn add --dev --exact prettierpnpm add --save-dev --save-exact prettierbun add --dev --exact prettier
Then, create an empty config file to let editors and other tools know you are using Prettier:
node --eval "fs.writeFileSync('.prettierrc','{}\n')"
Next, create a .prettierignore file to let the Prettier CLI and editors know which files to not format. Here‚Äôs an example:
node --eval "fs.writeFileSync('.prettierignore','# Ignore artifacts:\nbuild\ncoverage\n')"
tipPrettier will follow rules specified in .gitignore if it exists in the same directory from which it is run. You can also base your .prettierignore on .eslintignore (if you have one).
Another tipIf your project isn‚Äôt ready to format, say, HTML files yet, add *.html.
Now, format all files with Prettier:
npmyarnpnpmbunnpx prettier . --writeinfoWhat is that npx thing? npx ships with npm and lets you run locally installed tools. We‚Äôll leave off the npx part for brevity throughout the rest of this file!warningIf you forget to install Prettier first, npx will temporarily download the latest version. That‚Äôs not a good idea when using Prettier, because we change how code is formatted in each release! It‚Äôs important to have a locked down version of Prettier in your package.json. And it‚Äôs faster, too.yarn exec prettier . --writeinfoWhat is yarn exec doing at the start? yarn exec prettier runs the locally installed version of Prettier. We‚Äôll leave off the yarn exec part for brevity throughout the rest of this file!pnpm exec prettier . --writeinfoWhat is pnpm exec doing at the start? pnpm exec prettier runs the locally installed version of Prettier. We‚Äôll leave off the pnpm exec part for brevity throughout the rest of this file!bun exec prettier . --writeinfoWhat is bun exec doing at the start? bun exec prettier runs the locally installed version of Prettier. We‚Äôll leave off the bun exec part for brevity throughout the rest of this file!
prettier --write . is great for formatting everything, but for a big project it might take a little while. You may run prettier --write app/ to format a certain directory, or prettier --write app/components/Button.js to format a certain file. Or use a glob like prettier --write "app/**/*.test.js" to format all tests in a directory (see fast-glob for supported glob syntax).
If you have a CI setup, run the following as part of it to make sure that everyone runs Prettier. This avoids merge conflicts and other collaboration issues!
npx prettier . --check
--check is like --write, but only checks that files are already formatted, rather than overwriting them. prettier --write and prettier --check are the most common ways to run Prettier.
Set up your editor‚Äã
Formatting from the command line is a good way to get started, but you get the most from Prettier by running it from your editor, either via a keyboard shortcut or automatically whenever you save a file. When a line has gotten so long while coding that it won‚Äôt fit your screen, just hit a key and watch it magically be wrapped into multiple lines! Or when you paste some code and the indentation gets all messed up, let Prettier fix it up for you without leaving your editor.
See Editor Integration for how to set up your editor. If your editor does not support Prettier, you can instead run Prettier with a file watcher.
noteDon‚Äôt skip the regular local install! Editor plugins will pick up your local version of Prettier, making sure you use the correct version in every project. (You wouldn‚Äôt want your editor accidentally causing lots of changes because it‚Äôs using a newer version of Prettier than your project!)And being able to run Prettier from the command line is still a good fallback, and needed for CI setups.
ESLint (and other linters)‚Äã
If you use ESLint, install eslint-config-prettier to make ESLint and Prettier play nice with each other. It turns off all ESLint rules that are unnecessary or might conflict with Prettier. There‚Äôs a similar config for Stylelint: stylelint-config-prettier
(See Prettier vs. Linters to learn more about formatting vs linting, Integrating with Linters for more in-depth information on configuring your linters, and Related projects for even more integration possibilities, if needed.)
Git hooks‚Äã
In addition to running Prettier from the command line (prettier --write), checking formatting in CI, and running Prettier from your editor, many people like to run Prettier as a pre-commit hook as well. This makes sure all your commits are formatted, without having to wait for your CI build to finish.
For example, you can do the following to have Prettier run before each commit:

Install husky and lint-staged:

npmyarnpnpmbunnpm install --save-dev husky lint-stagednpx husky initnode --eval "fs.writeFileSync('.husky/pre-commit','npx lint-staged\n')"yarn add --dev husky lint-stagednpx husky initnode --eval "fs.writeFileSync('.husky/pre-commit','yarn lint-staged\n')"noteIf you use Yarn 2, see https://typicode.github.io/husky/#/?id=yarn-2pnpm add --save-dev husky lint-stagedpnpm exec husky initnode --eval "fs.writeFileSync('.husky/pre-commit','pnpm exec lint-staged\n')"bun add --dev husky lint-stagedbunx husky initbun --eval "fs.writeFileSync('.husky/pre-commit','bunx lint-staged\n')"

Add the following to your package.json:

{  "lint-staged": {    "**/*": "prettier --write --ignore-unknown"  }}
noteIf you use ESLint, make sure lint-staged runs it before Prettier, not after.
See Pre-commit Hook for more information.
Summary‚Äã
To summarize, we have learned to:

Install an exact version of Prettier locally in your project. This makes sure that everyone in the project gets the exact same version of Prettier. Even a patch release of Prettier can result in slightly different formatting, so you wouldn‚Äôt want different team members using different versions and formatting each other‚Äôs changes back and forth.
Add a .prettierrc to let your editor know that you are using Prettier.
Add a .prettierignore to let your editor know which files not to touch, as well as for being able to run prettier --write . to format the entire project (without mangling files you don‚Äôt want, or choking on generated files).
Run prettier --check . in CI to make sure that your project stays formatted.
Run Prettier from your editor for the best experience.
Use eslint-config-prettier to make Prettier and ESLint play nice together.
Set up a pre-commit hook to make sure that every commit is formatted.
Edit this page\n\nOn this pageInstallFirst, install Prettier locally:
npmyarnpnpmbunnpm install --save-dev --save-exact prettieryarn add --dev --exact prettierpnpm add --save-dev --save-exact prettierbun add --dev --exact prettier
Then, create an empty config file to let editors and other tools know you are using Prettier:
node --eval "fs.writeFileSync('.prettierrc','{}\n')"
Next, create a .prettierignore file to let the Prettier CLI and editors know which files to not format. Here‚Äôs an example:
node --eval "fs.writeFileSync('.prettierignore','# Ignore artifacts:\nbuild\ncoverage\n')"
tipPrettier will follow rules specified in .gitignore if it exists in the same directory from which it is run. You can also base your .prettierignore on .eslintignore (if you have one).
Another tipIf your project isn‚Äôt ready to format, say, HTML files yet, add *.html.
Now, format all files with Prettier:
npmyarnpnpmbunnpx prettier . --writeinfoWhat is that npx thing? npx ships with npm and lets you run locally installed tools. We‚Äôll leave off the npx part for brevity throughout the rest of this file!warningIf you forget to install Prettier first, npx will temporarily download the latest version. That‚Äôs not a good idea when using Prettier, because we change how code is formatted in each release! It‚Äôs important to have a locked down version of Prettier in your package.json. And it‚Äôs faster, too.yarn exec prettier . --writeinfoWhat is yarn exec doing at the start? yarn exec prettier runs the locally installed version of Prettier. We‚Äôll leave off the yarn exec part for brevity throughout the rest of this file!pnpm exec prettier . --writeinfoWhat is pnpm exec doing at the start? pnpm exec prettier runs the locally installed version of Prettier. We‚Äôll leave off the pnpm exec part for brevity throughout the rest of this file!bun exec prettier . --writeinfoWhat is bun exec doing at the start? bun exec prettier runs the locally installed version of Prettier. We‚Äôll leave off the bun exec part for brevity throughout the rest of this file!
prettier --write . is great for formatting everything, but for a big project it might take a little while. You may run prettier --write app/ to format a certain directory, or prettier --write app/components/Button.js to format a certain file. Or use a glob like prettier --write "app/**/*.test.js" to format all tests in a directory (see fast-glob for supported glob syntax).
If you have a CI setup, run the following as part of it to make sure that everyone runs Prettier. This avoids merge conflicts and other collaboration issues!
npx prettier . --check
--check is like --write, but only checks that files are already formatted, rather than overwriting them. prettier --write and prettier --check are the most common ways to run Prettier.
Set up your editor‚Äã
Formatting from the command line is a good way to get started, but you get the most from Prettier by running it from your editor, either via a keyboard shortcut or automatically whenever you save a file. When a line has gotten so long while coding that it won‚Äôt fit your screen, just hit a key and watch it magically be wrapped into multiple lines! Or when you paste some code and the indentation gets all messed up, let Prettier fix it up for you without leaving your editor.
See Editor Integration for how to set up your editor. If your editor does not support Prettier, you can instead run Prettier with a file watcher.
noteDon‚Äôt skip the regular local install! Editor plugins will pick up your local version of Prettier, making sure you use the correct version in every project. (You wouldn‚Äôt want your editor accidentally causing lots of changes because it‚Äôs using a newer version of Prettier than your project!)And being able to run Prettier from the command line is still a good fallback, and needed for CI setups.
ESLint (and other linters)‚Äã
If you use ESLint, install eslint-config-prettier to make ESLint and Prettier play nice with each other. It turns off all ESLint rules that are unnecessary or might conflict with Prettier. There‚Äôs a similar config for Stylelint: stylelint-config-prettier
(See Prettier vs. Linters to learn more about formatting vs linting, Integrating with Linters for more in-depth information on configuring your linters, and Related projects for even more integration possibilities, if needed.)
Git hooks‚Äã
In addition to running Prettier from the command line (prettier --write), checking formatting in CI, and running Prettier from your editor, many people like to run Prettier as a pre-commit hook as well. This makes sure all your commits are formatted, without having to wait for your CI build to finish.
For example, you can do the following to have Prettier run before each commit:

Install husky and lint-staged:

npmyarnpnpmbunnpm install --save-dev husky lint-stagednpx husky initnode --eval "fs.writeFileSync('.husky/pre-commit','npx lint-staged\n')"yarn add --dev husky lint-stagednpx husky initnode --eval "fs.writeFileSync('.husky/pre-commit','yarn lint-staged\n')"noteIf you use Yarn 2, see https://typicode.github.io/husky/#/?id=yarn-2pnpm add --save-dev husky lint-stagedpnpm exec husky initnode --eval "fs.writeFileSync('.husky/pre-commit','pnpm exec lint-staged\n')"bun add --dev husky lint-stagedbunx husky initbun --eval "fs.writeFileSync('.husky/pre-commit','bunx lint-staged\n')"

Add the following to your package.json:

{  "lint-staged": {    "**/*": "prettier --write --ignore-unknown"  }}
noteIf you use ESLint, make sure lint-staged runs it before Prettier, not after.
See Pre-commit Hook for more information.
Summary‚Äã
To summarize, we have learned to:

Install an exact version of Prettier locally in your project. This makes sure that everyone in the project gets the exact same version of Prettier. Even a patch release of Prettier can result in slightly different formatting, so you wouldn‚Äôt want different team members using different versions and formatting each other‚Äôs changes back and forth.
Add a .prettierrc to let your editor know that you are using Prettier.
Add a .prettierignore to let your editor know which files not to touch, as well as for being able to run prettier --write . to format the entire project (without mangling files you don‚Äôt want, or choking on generated files).
Run prettier --check . in CI to make sure that your project stays formatted.
Run Prettier from your editor for the best experience.
Use eslint-config-prettier to make Prettier and ESLint play nice together.
Set up a pre-commit hook to make sure that every commit is formatted.
Edit this pagePreviousRationaleNextIgnoring CodeSet up your editorESLint (and other linters)Git hooksSummary\n\n\n\nOn this pageIgnoring CodeUse .prettierignore to ignore (i.e. not reformat) certain files and folders completely.
Use ‚Äúprettier-ignore‚Äù comments to ignore parts of files.
Ignoring Files: .prettierignore‚Äã
To exclude files from formatting, create a .prettierignore file in the root of your project. .prettierignore uses gitignore syntax.
Example:
# Ignore artifacts:buildcoverage# Ignore all HTML files:**/*.html
It‚Äôs recommended to have a .prettierignore in your project! This way you can run prettier --write . to make sure that everything is formatted (without mangling files you don‚Äôt want, or choking on generated files). And ‚Äì your editor will know which files not to format!
By default prettier ignores files in version control systems directories (".git", ".jj", ".sl", ".svn" and ".hg") and node_modules (unless the --with-node-modules CLI option is specified). Prettier will also follow rules specified in the ".gitignore" file if it exists in the same directory from which it is run.
So by default it will be
**/.git**/.svn**/.hg**/node_modules
and
**/.git**/.svn**/.hg
if --with-node-modules CLI option provided
(See also the --ignore-path CLI option.)
JavaScript‚Äã
A JavaScript comment of // prettier-ignore will exclude the next node in the abstract syntax tree from formatting.
For example:
matrix(  1, 0, 0,  0, 1, 0,  0, 0, 1)// prettier-ignorematrix(  1, 0, 0,  0, 1, 0,  0, 0, 1)
will be transformed to:
matrix(1, 0, 0, 0, 1, 0, 0, 0, 1);// prettier-ignorematrix(  1, 0, 0,  0, 1, 0,  0, 0, 1)
JSX‚Äã
<div>  {/* prettier-ignore */}  <span     ugly  format=''   /></div>
HTML‚Äã
<!-- prettier-ignore --><div         class="x"       >hello world</div            ><!-- prettier-ignore-attribute --><div  (mousedown)="       onStart    (    )         "  (mouseup)="         onEnd      (    )         "></div><!-- prettier-ignore-attribute (mouseup) --><div  (mousedown)="onStart()"  (mouseup)="         onEnd      (    )         "></div>
CSS‚Äã
/* prettier-ignore */.my    ugly rule{}
Markdown‚Äã
<!-- prettier-ignore -->Do   not    format   this
Range Ignore‚Äã
available in v1.12.0+
This type of ignore is only allowed to be used in top-level and aimed to disable formatting for auto-generated content, e.g. all-contributors, markdown-toc, etc.
<!-- prettier-ignore-start --><!-- SOMETHING AUTO-GENERATED BY TOOLS - START -->| MY | AWESOME | AUTO-GENERATED | TABLE ||-|-|-|-|| a | b | c | d |<!-- SOMETHING AUTO-GENERATED BY TOOLS - END --><!-- prettier-ignore-end -->
Important: You must have a blank line before <!-- prettier-ignore-start --> and <!-- prettier-ignore-end --> for Prettier to recognize the comments.
YAML‚Äã
To ignore a part of a YAML file, # prettier-ignore should be placed on the line immediately above the ignored node:
# prettier-ignorekey  : valuehello: world
GraphQL‚Äã
{  # prettier-ignore  addReaction(input:{superLongInputFieldName:"MDU6SXNzdWUyMzEzOTE1NTE=",content:HOORAY}) {    reaction {content}  }}
Handlebars‚Äã
{{! prettier-ignore }}<div>  "hello! my parent was ignored"  {{#my-crazy-component     "shall"     be="preserved"}}    <This      is  =  "also preserved as is"    />  {{/my-crazy-component}}</div>
Command Line File Patterns‚Äã
For one-off commands, when you want to exclude some files without adding them to .prettierignore, negative patterns can come in handy:
prettier . "!**/*.{js,jsx,vue}" --write
See fast-glob to learn more about advanced glob syntax.Edit this page\n\nOn this pageIgnoring CodeUse .prettierignore to ignore (i.e. not reformat) certain files and folders completely.
Use ‚Äúprettier-ignore‚Äù comments to ignore parts of files.
Ignoring Files: .prettierignore‚Äã
To exclude files from formatting, create a .prettierignore file in the root of your project. .prettierignore uses gitignore syntax.
Example:
# Ignore artifacts:buildcoverage# Ignore all HTML files:**/*.html
It‚Äôs recommended to have a .prettierignore in your project! This way you can run prettier --write . to make sure that everything is formatted (without mangling files you don‚Äôt want, or choking on generated files). And ‚Äì your editor will know which files not to format!
By default prettier ignores files in version control systems directories (".git", ".jj", ".sl", ".svn" and ".hg") and node_modules (unless the --with-node-modules CLI option is specified). Prettier will also follow rules specified in the ".gitignore" file if it exists in the same directory from which it is run.
So by default it will be
**/.git**/.svn**/.hg**/node_modules
and
**/.git**/.svn**/.hg
if --with-node-modules CLI option provided
(See also the --ignore-path CLI option.)
JavaScript‚Äã
A JavaScript comment of // prettier-ignore will exclude the next node in the abstract syntax tree from formatting.
For example:
matrix(  1, 0, 0,  0, 1, 0,  0, 0, 1)// prettier-ignorematrix(  1, 0, 0,  0, 1, 0,  0, 0, 1)
will be transformed to:
matrix(1, 0, 0, 0, 1, 0, 0, 0, 1);// prettier-ignorematrix(  1, 0, 0,  0, 1, 0,  0, 0, 1)
JSX‚Äã
<div>  {/* prettier-ignore */}  <span     ugly  format=''   /></div>
HTML‚Äã
<!-- prettier-ignore --><div         class="x"       >hello world</div            ><!-- prettier-ignore-attribute --><div  (mousedown)="       onStart    (    )         "  (mouseup)="         onEnd      (    )         "></div><!-- prettier-ignore-attribute (mouseup) --><div  (mousedown)="onStart()"  (mouseup)="         onEnd      (    )         "></div>
CSS‚Äã
/* prettier-ignore */.my    ugly rule{}
Markdown‚Äã
<!-- prettier-ignore -->Do   not    format   this
Range Ignore‚Äã
available in v1.12.0+
This type of ignore is only allowed to be used in top-level and aimed to disable formatting for auto-generated content, e.g. all-contributors, markdown-toc, etc.
<!-- prettier-ignore-start --><!-- SOMETHING AUTO-GENERATED BY TOOLS - START -->| MY | AWESOME | AUTO-GENERATED | TABLE ||-|-|-|-|| a | b | c | d |<!-- SOMETHING AUTO-GENERATED BY TOOLS - END --><!-- prettier-ignore-end -->
Important: You must have a blank line before <!-- prettier-ignore-start --> and <!-- prettier-ignore-end --> for Prettier to recognize the comments.
YAML‚Äã
To ignore a part of a YAML file, # prettier-ignore should be placed on the line immediately above the ignored node:
# prettier-ignorekey  : valuehello: world
GraphQL‚Äã
{  # prettier-ignore  addReaction(input:{superLongInputFieldName:"MDU6SXNzdWUyMzEzOTE1NTE=",content:HOORAY}) {    reaction {content}  }}
Handlebars‚Äã
{{! prettier-ignore }}<div>  "hello! my parent was ignored"  {{#my-crazy-component     "shall"     be="preserved"}}    <This      is  =  "also preserved as is"    />  {{/my-crazy-component}}</div>
Command Line File Patterns‚Äã
For one-off commands, when you want to exclude some files without adding them to .prettierignore, negative patterns can come in handy:
prettier . "!**/*.{js,jsx,vue}" --write
See fast-glob to learn more about advanced glob syntax.Edit this pagePreviousInstallNextIntegrating with LintersIgnoring Files: .prettierignoreJavaScriptJSXHTMLCSSMarkdownRange IgnoreYAMLGraphQLHandlebarsCommand Line File Patterns\n\n\n\nOn this pageIntegrating with LintersLinters usually contain not only code quality rules, but also stylistic rules. Most stylistic rules are unnecessary when using Prettier, but worse ‚Äì they might conflict with Prettier! Use Prettier for code formatting concerns, and linters for code-quality concerns, as outlined in Prettier vs. Linters.
Luckily it‚Äôs easy to turn off rules that conflict or are unnecessary with Prettier, by using these pre-made configs:

eslint-config-prettier

Check out the above links for instructions on how to install and set things up.
Notes‚Äã
When searching for both Prettier and your linter on the Internet you‚Äôll probably find more related projects. These are generally not recommended, but can be useful in certain circumstances.
First, we have plugins that let you run Prettier as if it was a linter rule:

eslint-plugin-prettier
stylelint-prettier

These plugins were especially useful when Prettier was new. By running Prettier inside your linters, you didn‚Äôt have to set up any new infrastructure and you could re-use your editor integrations for the linters. But these days you can run prettier --check . and most editors have Prettier support.
The downsides of those plugins are:

You end up with a lot of red squiggly lines in your editor, which gets annoying. Prettier is supposed to make you forget about formatting ‚Äì and not be in your face about it!
They are slower than running Prettier directly.
They‚Äôre yet one layer of indirection where things may break.

Finally, we have tools that run prettier and then immediately lint files by running, for example, eslint --fix on them.

prettier-eslint
prettier-stylelint

Those are useful if some aspect of Prettier‚Äôs output makes Prettier completely unusable to you. Then you can have for example eslint --fix fix that up for you. The downside is that these tools are much slower than just running Prettier.Edit this page\n\nOn this pageIntegrating with LintersLinters usually contain not only code quality rules, but also stylistic rules. Most stylistic rules are unnecessary when using Prettier, but worse ‚Äì they might conflict with Prettier! Use Prettier for code formatting concerns, and linters for code-quality concerns, as outlined in Prettier vs. Linters.
Luckily it‚Äôs easy to turn off rules that conflict or are unnecessary with Prettier, by using these pre-made configs:

eslint-config-prettier

Check out the above links for instructions on how to install and set things up.
Notes‚Äã
When searching for both Prettier and your linter on the Internet you‚Äôll probably find more related projects. These are generally not recommended, but can be useful in certain circumstances.
First, we have plugins that let you run Prettier as if it was a linter rule:

eslint-plugin-prettier
stylelint-prettier

These plugins were especially useful when Prettier was new. By running Prettier inside your linters, you didn‚Äôt have to set up any new infrastructure and you could re-use your editor integrations for the linters. But these days you can run prettier --check . and most editors have Prettier support.
The downsides of those plugins are:

You end up with a lot of red squiggly lines in your editor, which gets annoying. Prettier is supposed to make you forget about formatting ‚Äì and not be in your face about it!
They are slower than running Prettier directly.
They‚Äôre yet one layer of indirection where things may break.

Finally, we have tools that run prettier and then immediately lint files by running, for example, eslint --fix on them.

prettier-eslint
prettier-stylelint

Those are useful if some aspect of Prettier‚Äôs output makes Prettier completely unusable to you. Then you can have for example eslint --fix fix that up for you. The downside is that these tools are much slower than just running Prettier.Edit this pagePreviousIgnoring CodeNextPre-commit HookNotes\n\n\n\nOn this pagePre-commit HookYou can use Prettier with a pre-commit tool. This can re-format your files that are marked as ‚Äústaged‚Äù via git add before you commit.
Option 1. lint-staged‚Äã
Use Case: Useful for when you want to use other code quality tools along with Prettier (e.g. ESLint, Stylelint, etc.) or if you need support for partially staged files (git add --patch).
Make sure Prettier is installed and is in your devDependencies before you proceed.
npx mrm@2 lint-staged
This will install husky and lint-staged, then add a configuration to the project‚Äôs package.json that will automatically format supported files in a pre-commit hook.
Read more at the lint-staged repo.
Option 2. pretty-quick‚Äã
Use Case: Great for when you want an entire file formatting on your changed/staged files.
Install it along with simple-git-hooks:
npmyarnpnpmbunnpm install --save-dev simple-git-hooks pretty-quickecho '{\n  "pre-commit": "npx pretty-quick --staged"\n}\n' > .simple-git-hooks.jsonnpx simple-git-hooksyarn add --dev simple-git-hooks pretty-quickecho '{\n  "pre-commit": "yarn pretty-quick --staged"\n}\n' > .simple-git-hooks.jsonyarn simple-git-hookspnpm add --save-dev simple-git-hooks pretty-quickecho '{\n  "pre-commit": "pnpm pretty-quick --staged"\n}\n' > .simple-git-hooks.jsonpnpm simple-git-hooksbun add --dev simple-git-hooks pretty-quickecho '{\n  "pre-commit": "bun pretty-quick --staged"\n}\n' > .simple-git-hooks.jsonbun simple-git-hooks
Read more at the pretty-quick repo.
Option 3. Husky.Net‚Äã
Use Case: A dotnet solution to use Prettier along with other code quality tools (e.g. dotnet-format, ESLint, Stylelint, etc.). It supports multiple file states (staged - last-commit, git-files etc.)
dotnet new tool-manifestdotnet tool install huskydotnet husky installdotnet husky add pre-commit
after installation you can add prettier task to the task-runner.json.
{  "command": "npx",  "args": ["prettier", "--ignore-unknown", "--write", "${staged}"],  "pathMode": "absolute"}
Option 4. git-format-staged‚Äã
Use Case: Great for when you want to format partially-staged files, and other options do not provide a good fit for your project.
Git-format-staged is used to run any formatter that can accept file content via stdin. It operates differently than other tools that format partially-staged files: it applies the formatter directly to objects in the git object database, and merges changes back to the working tree. This procedure provides several guarantees:

Changes in commits are always formatted.
Unstaged changes are never, under any circumstances staged during the formatting process.
If there are conflicts between formatted, staged changes and unstaged changes then your working tree files are left untouched - your work won‚Äôt be overwritten, and there are no stashes to clean up.
Unstaged changes are not formatted.

Git-format-staged requires Python v3 or v2.7. Python is usually pre-installed on Linux and macOS, but not on Windows. Use git-format-staged with husky:
npmyarnpnpmbunnpx husky initnpm install --save-dev git-format-stagednode --eval "fs.writeFileSync('.husky/pre-commit', 'git-format-staged -f \'prettier --ignore-unknown --stdin --stdin-filepath \"{}\"\' .\n')"yarn husky inityarn add --dev git-format-stagednode --eval "fs.writeFileSync('.husky/pre-commit', 'git-format-staged -f \'prettier --ignore-unknown --stdin --stdin-filepath \"{}\"\' .\n')"pnpm exec husky initpnpm add --save-dev git-format-stagednode --eval "fs.writeFileSync('.husky/pre-commit', 'git-format-staged -f \'prettier --ignore-unknown --stdin --stdin-filepath \"{}\"\' .\n')"bunx husky initbun add --dev git-format-stagedbun --eval "fs.writeFileSync('.husky/pre-commit', 'git-format-staged -f \'prettier --ignore-unknown --stdin --stdin-filepath \"{}\"\' .\n')"
Add or remove file extensions to suit your project. Note that regardless of which extensions you list formatting will respect any .prettierignore files in your project.
To read about how git-format-staged works see Automatic Code Formatting for Partially-Staged Files.
Option 5. Shell script‚Äã
Alternately you can save this script as .git/hooks/pre-commit and give it execute permission:
#!/bin/shFILES=$(git diff --cached --name-only --diff-filter=ACMR | sed 's| |\\ |g')[ -z "$FILES" ] && exit 0# Prettify all selected filesecho "$FILES" | xargs ./node_modules/.bin/prettier --ignore-unknown --write# Add back the modified/prettified files to stagingecho "$FILES" | xargs git addexit 0
If git is reporting that your prettified files are still modified after committing, you may need to add a post-commit script to update git‚Äôs index.
Add something like the following to .git/hooks/post-commit:
#!/bin/shgit update-index -gEdit this page\n\nOn this pagePre-commit HookYou can use Prettier with a pre-commit tool. This can re-format your files that are marked as ‚Äústaged‚Äù via git add before you commit.
Option 1. lint-staged‚Äã
Use Case: Useful for when you want to use other code quality tools along with Prettier (e.g. ESLint, Stylelint, etc.) or if you need support for partially staged files (git add --patch).
Make sure Prettier is installed and is in your devDependencies before you proceed.
npx mrm@2 lint-staged
This will install husky and lint-staged, then add a configuration to the project‚Äôs package.json that will automatically format supported files in a pre-commit hook.
Read more at the lint-staged repo.
Option 2. pretty-quick‚Äã
Use Case: Great for when you want an entire file formatting on your changed/staged files.
Install it along with simple-git-hooks:
npmyarnpnpmbunnpm install --save-dev simple-git-hooks pretty-quickecho '{\n  "pre-commit": "npx pretty-quick --staged"\n}\n' > .simple-git-hooks.jsonnpx simple-git-hooksyarn add --dev simple-git-hooks pretty-quickecho '{\n  "pre-commit": "yarn pretty-quick --staged"\n}\n' > .simple-git-hooks.jsonyarn simple-git-hookspnpm add --save-dev simple-git-hooks pretty-quickecho '{\n  "pre-commit": "pnpm pretty-quick --staged"\n}\n' > .simple-git-hooks.jsonpnpm simple-git-hooksbun add --dev simple-git-hooks pretty-quickecho '{\n  "pre-commit": "bun pretty-quick --staged"\n}\n' > .simple-git-hooks.jsonbun simple-git-hooks
Read more at the pretty-quick repo.
Option 3. Husky.Net‚Äã
Use Case: A dotnet solution to use Prettier along with other code quality tools (e.g. dotnet-format, ESLint, Stylelint, etc.). It supports multiple file states (staged - last-commit, git-files etc.)
dotnet new tool-manifestdotnet tool install huskydotnet husky installdotnet husky add pre-commit
after installation you can add prettier task to the task-runner.json.
{  "command": "npx",  "args": ["prettier", "--ignore-unknown", "--write", "${staged}"],  "pathMode": "absolute"}
Option 4. git-format-staged‚Äã
Use Case: Great for when you want to format partially-staged files, and other options do not provide a good fit for your project.
Git-format-staged is used to run any formatter that can accept file content via stdin. It operates differently than other tools that format partially-staged files: it applies the formatter directly to objects in the git object database, and merges changes back to the working tree. This procedure provides several guarantees:

Changes in commits are always formatted.
Unstaged changes are never, under any circumstances staged during the formatting process.
If there are conflicts between formatted, staged changes and unstaged changes then your working tree files are left untouched - your work won‚Äôt be overwritten, and there are no stashes to clean up.
Unstaged changes are not formatted.

Git-format-staged requires Python v3 or v2.7. Python is usually pre-installed on Linux and macOS, but not on Windows. Use git-format-staged with husky:
npmyarnpnpmbunnpx husky initnpm install --save-dev git-format-stagednode --eval "fs.writeFileSync('.husky/pre-commit', 'git-format-staged -f \'prettier --ignore-unknown --stdin --stdin-filepath \"{}\"\' .\n')"yarn husky inityarn add --dev git-format-stagednode --eval "fs.writeFileSync('.husky/pre-commit', 'git-format-staged -f \'prettier --ignore-unknown --stdin --stdin-filepath \"{}\"\' .\n')"pnpm exec husky initpnpm add --save-dev git-format-stagednode --eval "fs.writeFileSync('.husky/pre-commit', 'git-format-staged -f \'prettier --ignore-unknown --stdin --stdin-filepath \"{}\"\' .\n')"bunx husky initbun add --dev git-format-stagedbun --eval "fs.writeFileSync('.husky/pre-commit', 'git-format-staged -f \'prettier --ignore-unknown --stdin --stdin-filepath \"{}\"\' .\n')"
Add or remove file extensions to suit your project. Note that regardless of which extensions you list formatting will respect any .prettierignore files in your project.
To read about how git-format-staged works see Automatic Code Formatting for Partially-Staged Files.
Option 5. Shell script‚Äã
Alternately you can save this script as .git/hooks/pre-commit and give it execute permission:
#!/bin/shFILES=$(git diff --cached --name-only --diff-filter=ACMR | sed 's| |\\ |g')[ -z "$FILES" ] && exit 0# Prettify all selected filesecho "$FILES" | xargs ./node_modules/.bin/prettier --ignore-unknown --write# Add back the modified/prettified files to stagingecho "$FILES" | xargs git addexit 0
If git is reporting that your prettified files are still modified after committing, you may need to add a post-commit script to update git‚Äôs index.
Add something like the following to .git/hooks/post-commit:
#!/bin/shgit update-index -gEdit this pagePreviousIntegrating with LintersNextPluginsOption 1. lint-stagedOption 2. pretty-quickOption 3. Husky.NetOption 4. git-format-stagedOption 5. Shell script\n\n\n\nOn this pagePluginsPlugins are ways of adding new languages or formatting rules to Prettier. Prettier‚Äôs own implementations of all languages are expressed using the plugin API. The core prettier package contains JavaScript and other web-focused languages built in. For additional languages you‚Äôll need to install a plugin.
Using Plugins‚Äã
You can load plugins with:


The CLI, via --plugin:
prettier --write main.foo --plugin=prettier-plugin-foo
tipYou can set --plugin options multiple times.


The API, via the plugins options:
await prettier.format("code", {  parser: "foo",  plugins: ["prettier-plugin-foo"],});


The Configuration File:
{  "plugins": ["prettier-plugin-foo"]}


Strings provided to plugins are ultimately passed to import() expression, so you can provide a module/package name, a path, or anything else import() takes.
Official Plugins‚Äã

@prettier/plugin-php
@prettier/plugin-pug by @Shinigami92
@prettier/plugin-ruby
@prettier/plugin-xml

Community Plugins‚Äã

prettier-plugin-apex by @dangmai
prettier-plugin-astro by @withastro contributors
prettier-plugin-elm by @giCentre
prettier-plugin-erb by @adamzapasnik
prettier-plugin-gherkin by @mapado
prettier-plugin-glsl by @NaridaL
prettier-plugin-go-template by @NiklasPor
prettier-plugin-java by @JHipster
prettier-plugin-jinja-template by @davidodenwald
prettier-plugin-jsonata by @Stedi
prettier-plugin-kotlin by @Angry-Potato
prettier-plugin-motoko by @dfinity
prettier-plugin-nginx by @joedeandev
prettier-plugin-prisma by @umidbekk
prettier-plugin-properties by @eemeli
prettier-plugin-rust by @jinxdash
prettier-plugin-sh by @JounQin
prettier-plugin-sql by @JounQin
prettier-plugin-sql-cst by @nene
prettier-plugin-solidity by @mattiaerre
prettier-plugin-svelte by @sveltejs
prettier-plugin-toml by @bd82

Developing Plugins‚Äã
Prettier plugins are regular JavaScript modules with the following five exports or default export with the following properties:

languages
parsers
printers
options
defaultOptions

languages‚Äã
Languages is an array of language definitions that your plugin will contribute to Prettier. It can include all of the fields specified in prettier.getSupportInfo().
It must include name and parsers.
export const languages = [  {    // The language name    name: "InterpretedDanceScript",    // Parsers that can parse this language.    // This can be built-in parsers, or parsers you have contributed via this plugin.    parsers: ["dance-parse"],  },];
parsers‚Äã
Parsers convert code as a string into an AST.
The key must match the name in the parsers array from languages. The value contains a parse function, an AST format name, and two location extraction functions (locStart and locEnd).
export const parsers = {  "dance-parse": {    parse,    // The name of the AST that the parser produces.    astFormat: "dance-ast",    hasPragma,    locStart,    locEnd,    preprocess,  },};
The signature of the parse function is:
function parse(text: string, options: object): Promise<AST> | AST;
The location extraction functions (locStart and locEnd) return the starting and ending locations of a given AST node:
function locStart(node: object): number;
(Optional) The pragma detection function (hasPragma) should return if the text contains the pragma comment.
function hasPragma(text: string): boolean;
(Optional) The preprocess function can process the input text before passing into parse function.
function preprocess(text: string, options: object): string;
printers‚Äã
Printers convert ASTs into a Prettier intermediate representation, also known as a Doc.
The key must match the astFormat that the parser produces. The value contains an object with a print function. All other properties (embed, preprocess, etc.) are optional.
export const printers = {  "dance-ast": {    print,    embed,    preprocess,    getVisitorKeys,    insertPragma,    canAttachComment,    isBlockComment,    printComment,    getCommentChildNodes,    handleComments: {      ownLine,      endOfLine,      remaining,    },  },};
The printing process‚Äã
Prettier uses an intermediate representation, called a Doc, which Prettier then turns into a string (based on options like printWidth). A printer's job is to take the AST generated by parsers[<parser name>].parse and return a Doc. A Doc is constructed using builder commands:
import { doc } from "prettier";const { join, line, ifBreak, group } = doc.builders;
The printing process consists of the following steps:

AST preprocessing (optional). See preprocess.
Comment attachment (optional). See Handling comments in a printer.
Processing embedded languages (optional). The embed method, if defined, is called for each node, depth-first. While, for performance reasons, the recursion itself is synchronous, embed may return asynchronous functions that can call other parsers and printers to compose docs for embedded syntaxes like CSS-in-JS. These returned functions are queued up and sequentially executed before the next step.
Recursive printing. A doc is recursively constructed from the AST. Starting from the root node:

If, from the step 3, there is an embedded language doc associated with the current node, this doc is used.
Otherwise, the print(path, options, print): Doc method is called. It composes a doc for the current node, often by printing child nodes using the print callback.



print‚Äã
Most of the work of a plugin's printer will take place in its print function, whose signature is:
function print(  // Path to the AST node to print  path: AstPath,  options: object,  // Recursively print a child node  print: (selector?: string | number | Array<string | number> | AstPath) => Doc,): Doc;
The print function is passed the following parameters:

path: An object, which can be used to access nodes in the AST. It‚Äôs a stack-like data structure that maintains the current state of the recursion. It is called ‚Äúpath‚Äù because it represents the path to the current node from the root of the AST. The current node is returned by path.node.
options: A persistent object, which contains global options and which a plugin may mutate to store contextual data.
print: A callback for printing sub-nodes. This function contains the core printing logic that consists of steps whose implementation is provided by plugins. In particular, it calls the printer‚Äôs print function and passes itself to it. Thus, the two print functions ‚Äì the one from the core and the one from the plugin ‚Äì call each other while descending down the AST recursively.

Here‚Äôs a simplified example to give an idea of what a typical implementation of print looks like:
import { doc } from "prettier";const { group, indent, join, line, softline } = doc.builders;function print(path, options, print) {  const node = path.node;  switch (node.type) {    case "list":      return group([        "(",        indent([softline, join(line, path.map(print, "elements"))]),        softline,        ")",      ]);    case "pair":      return group([        "(",        indent([softline, print("left"), line, ". ", print("right")]),        softline,        ")",      ]);    case "symbol":      return node.name;  }  throw new Error(`Unknown node type: ${node.type}`);}
Check out prettier-python's printer for some examples of what is possible.
(optional) embed‚Äã
A printer can have the embed method to print one language inside another. Examples of this are printing CSS-in-JS or fenced code blocks in Markdown. The signature is:
function embed(  // Path to the current AST node  path: AstPath,  // Current options  options: Options,):  | ((      // Parses and prints the passed text using a different parser.      // You should set `options.parser` to specify which parser to use.      textToDoc: (text: string, options: Options) => Promise<Doc>,      // Prints the current node or its descendant node with the current printer      print: (        selector?: string | number | Array<string | number> | AstPath,      ) => Doc,      // The following two arguments are passed for convenience.      // They're the same `path` and `options` that are passed to `embed`.      path: AstPath,      options: Options,    ) => Promise<Doc | undefined> | Doc | undefined)  | Doc  | undefined;
The embed method is similar to the print method in that it maps AST nodes to docs, but unlike print, it has power to do async work by returning an async function. That function's first parameter, the textToDoc async function, can be used to render a doc using a different plugin.
If a function returned from embed returns a doc or a promise that resolves to a doc, that doc will be used in printing, and the print method won‚Äôt be called for this node. It's also possible and, in rare situations, might be convenient to return a doc synchronously directly from embed, however textToDoc and the print callback aren‚Äôt available at that case. Return a function to get them.
If embed returns undefined, or if a function it returned returns undefined or a promise that resolves to undefined, the node will be printed normally with the print method. Same will happen if a returned function throws an error or returns a promise that rejects (e.g., if a parsing error has happened). Set the PRETTIER_DEBUG environment variable to a non-empty value if you want Prettier to rethrow these errors.
For example, a plugin that has nodes with embedded JavaScript might have the following embed method:
function embed(path, options) {  const node = path.node;  if (node.type === "javascript") {    return async (textToDoc) => {      return [        "<script>",        hardline,        await textToDoc(node.javaScriptCode, { parser: "babel" }),        hardline,        "</script>",      ];    };  }}
If the --embedded-language-formatting option is set to off, the embedding step is entirely skipped, embed isn‚Äôt called, and all nodes are printed with the print method.
(optional) preprocess‚Äã
The preprocess method can process the AST from the parser before passing it into the print method.
function preprocess(ast: AST, options: Options): AST | Promise<AST>;
(optional) getVisitorKeys‚Äã
This property might come in handy if the plugin uses comment attachment or embedded languages. These features traverse the AST iterating through all the own enumerable properties of each node starting from the root. If the AST has cycles, such a traverse ends up in an infinite loop. Also, nodes might contain non-node objects (e.g., location data), iterating through which is a waste of resources. To solve these issues, the printer can define a function to return property names that should be traversed.
Its signature is:
function getVisitorKeys(node, nonTraversableKeys: Set<string>): string[];
The default getVisitorKeys:
function getVisitorKeys(node, nonTraversableKeys) {  return Object.keys(node).filter((key) => !nonTraversableKeys.has(key));}
The second argument nonTraversableKeys is a set of common keys and keys that prettier used internal.
If you have full list of visitor keys
const visitorKeys = {  Program: ["body"],  Identifier: [],  // ...};function getVisitorKeys(node /* , nonTraversableKeys*/) {  // Return `[]` for unknown node to prevent Prettier fallback to use `Object.keys()`  return visitorKeys[node.type] ?? [];}
If you only need exclude a small set of keys
const ignoredKeys = new Set(["prev", "next", "range"]);function getVisitorKeys(node, nonTraversableKeys) {  return Object.keys(node).filter(    (key) => !nonTraversableKeys.has(key) && !ignoredKeys.has(key),  );}
(optional) insertPragma‚Äã
A plugin can implement how a pragma comment is inserted in the resulting code when the --insert-pragma option is used, in the insertPragma function. Its signature is:
function insertPragma(text: string): string;
Handling comments in a printer‚Äã
Comments are often not part of a language's AST and present a challenge for pretty printers. A Prettier plugin can either print comments itself in its print function or rely on Prettier's comment algorithm.
By default, if the AST has a top-level comments property, Prettier assumes that comments stores an array of comment nodes. Prettier will then use the provided parsers[<plugin>].locStart/locEnd functions to search for the AST node that each comment "belongs" to. Comments are then attached to these nodes mutating the AST in the process, and the comments property is deleted from the AST root. The *Comment functions are used to adjust Prettier's algorithm. Once the comments are attached to the AST, Prettier will automatically call the printComment(path, options): Doc function and insert the returned doc into the (hopefully) correct place.
(optional) getCommentChildNodes‚Äã
By default, Prettier searches all object properties (except for a few predefined ones) of each node recursively. This function can be provided to override that behavior. It has the signature:
function getCommentChildNodes(  // The node whose children should be returned.  node: AST,  // Current options  options: object,): AST[] | undefined;
Return [] if the node has no children or undefined to fall back on the default behavior.
(optional) printComment‚Äã
Called whenever a comment node needs to be printed. It has the signature:
function printComment(  // Path to the current comment node  commentPath: AstPath,  // Current options  options: object,): Doc;
(optional) canAttachComment‚Äã
function canAttachComment(node: AST): boolean;
This function is used for deciding whether a comment can be attached to a particular AST node. By default, all AST properties are traversed searching for nodes that comments can be attached to. This function is used to prevent comments from being attached to a particular node. A typical implementation looks like
function canAttachComment(node) {  return node.type && node.type !== "comment";}
(optional) isBlockComment‚Äã
function isBlockComment(node: AST): boolean;
Returns whether or not the AST node is a block comment.
(optional) handleComments‚Äã
The handleComments object contains three optional functions, each with signature
(  // The AST node corresponding to the comment  comment: AST,  // The full source code text  text: string,  // The global options object  options: object,  // The AST  ast: AST,  // Whether this comment is the last comment  isLastComment: boolean,) => boolean;
These functions are used to override Prettier's default comment attachment algorithm. ownLine/endOfLine/remaining is expected to either manually attach a comment to a node and return true, or return false and let Prettier attach the comment.
Based on the text surrounding a comment node, Prettier dispatches:

ownLine if a comment has only whitespace preceding it and a newline afterwards,
endOfLine if a comment has a newline afterwards but some non-whitespace preceding it,
remaining in all other cases.

At the time of dispatching, Prettier will have annotated each AST comment node (i.e., created new properties) with at least one of enclosingNode, precedingNode, or followingNode. These can be used to aid a plugin's decision process (of course the entire AST and original text is also passed in for making more complicated decisions).
Manually attaching a comment‚Äã
The util.addTrailingComment/addLeadingComment/addDanglingComment functions can be used to manually attach a comment to an AST node. An example ownLine function that ensures a comment does not follow a "punctuation" node (made up for demonstration purposes) might look like:
import { util } from "prettier";function ownLine(comment, text, options, ast, isLastComment) {  const { precedingNode } = comment;  if (precedingNode && precedingNode.type === "punctuation") {    util.addTrailingComment(precedingNode, comment);    return true;  }  return false;}
Nodes with comments are expected to have a comments property containing an array of comments. Each comment is expected to have the following properties: leading, trailing, printed.
The example above uses util.addTrailingComment, which automatically sets comment.leading/trailing/printed to appropriate values and adds the comment to the AST node's comments array.
The --debug-print-comments CLI flag can help with debugging comment attachment issues. It prints a detailed list of comments, which includes information on how every comment was classified (ownLine/endOfLine/remaining, leading/trailing/dangling) and to which node it was attached. For Prettier‚Äôs built-in languages, this information is also available on the Playground (the 'show comments' checkbox in the Debug section).
options‚Äã
options is an object containing the custom options your plugin supports.
Example:
export default {  // ... plugin implementation  options: {    openingBraceNewLine: {      type: "boolean",      category: "Global",      default: true,      description: "Move open brace for code blocks onto new line.",    },  },};
defaultOptions‚Äã
If your plugin requires different default values for some of Prettier‚Äôs core options, you can specify them in defaultOptions:
export default {  // ... plugin implementation  defaultOptions: {    tabWidth: 4,  },};
Utility functions‚Äã
A util module from Prettier core is considered a private API and is not meant to be consumed by plugins. Instead, the util-shared module provides the following limited set of utility functions for plugins:
type Quote = '"' | "'";type SkipOptions = { backwards?: boolean };function getMaxContinuousCount(text: string, searchString: string): number;function getStringWidth(text: string): number;function getAlignmentSize(  text: string,  tabWidth: number,  startIndex?: number,): number;function getIndentSize(value: string, tabWidth: number): number;function skip(  characters: string | RegExp,): (  text: string,  startIndex: number | false,  options?: SkipOptions,) => number | false;function skipWhitespace(  text: string,  startIndex: number | false,  options?: SkipOptions,): number | false;function skipSpaces(  text: string,  startIndex: number | false,  options?: SkipOptions,): number | false;function skipToLineEnd(  text: string,  startIndex: number | false,  options?: SkipOptions,): number | false;function skipEverythingButNewLine(  text: string,  startIndex: number | false,  options?: SkipOptions,): number | false;function skipInlineComment(  text: string,  startIndex: number | false,): number | false;function skipTrailingComment(  text: string,  startIndex: number | false,): number | false;function skipNewline(  text: string,  startIndex: number | false,  options?: SkipOptions,): number | false;function hasNewline(  text: string,  startIndex: number,  options?: SkipOptions,): boolean;function hasNewlineInRange(  text: string,  startIndex: number,  startIndex: number,): boolean;function hasSpaces(  text: string,  startIndex: number,  options?: SkipOptions,): boolean;function getPreferredQuote(  text: string,  preferredQuoteOrPreferSingleQuote: Quote | boolean,): Quote;function makeString(  rawText: string,  enclosingQuote: Quote,  unescapeUnnecessaryEscapes?: boolean,): string;function getNextNonSpaceNonCommentCharacter(  text: string,  startIndex: number,): string;function getNextNonSpaceNonCommentCharacterIndex(  text: string,  startIndex: number,): number | false;function isNextLineEmpty(text: string, startIndex: number): boolean;function isPreviousLineEmpty(text: string, startIndex: number): boolean;
Tutorials‚Äã

How to write a plugin for Prettier: Teaches you how to write a very basic Prettier plugin for TOML.

Testing Plugins‚Äã
Since plugins can be resolved using relative paths, when working on one you can do:
import * as prettier from "prettier";const code = "(add 1 2)";await prettier.format(code, {  parser: "lisp",  plugins: ["."],});
This will resolve a plugin relative to the current working directory.Edit this page\n\nOn this pagePluginsPlugins are ways of adding new languages or formatting rules to Prettier. Prettier‚Äôs own implementations of all languages are expressed using the plugin API. The core prettier package contains JavaScript and other web-focused languages built in. For additional languages you‚Äôll need to install a plugin.
Using Plugins‚Äã
You can load plugins with:


The CLI, via --plugin:
prettier --write main.foo --plugin=prettier-plugin-foo
tipYou can set --plugin options multiple times.


The API, via the plugins options:
await prettier.format("code", {  parser: "foo",  plugins: ["prettier-plugin-foo"],});


The Configuration File:
{  "plugins": ["prettier-plugin-foo"]}


Strings provided to plugins are ultimately passed to import() expression, so you can provide a module/package name, a path, or anything else import() takes.
Official Plugins‚Äã

@prettier/plugin-php
@prettier/plugin-pug by @Shinigami92
@prettier/plugin-ruby
@prettier/plugin-xml

Community Plugins‚Äã

prettier-plugin-apex by @dangmai
prettier-plugin-astro by @withastro contributors
prettier-plugin-elm by @giCentre
prettier-plugin-erb by @adamzapasnik
prettier-plugin-gherkin by @mapado
prettier-plugin-glsl by @NaridaL
prettier-plugin-go-template by @NiklasPor
prettier-plugin-java by @JHipster
prettier-plugin-jinja-template by @davidodenwald
prettier-plugin-jsonata by @Stedi
prettier-plugin-kotlin by @Angry-Potato
prettier-plugin-motoko by @dfinity
prettier-plugin-nginx by @joedeandev
prettier-plugin-prisma by @umidbekk
prettier-plugin-properties by @eemeli
prettier-plugin-rust by @jinxdash
prettier-plugin-sh by @JounQin
prettier-plugin-sql by @JounQin
prettier-plugin-sql-cst by @nene
prettier-plugin-solidity by @mattiaerre
prettier-plugin-svelte by @sveltejs
prettier-plugin-toml by @bd82

Developing Plugins‚Äã
Prettier plugins are regular JavaScript modules with the following five exports or default export with the following properties:

languages
parsers
printers
options
defaultOptions

languages‚Äã
Languages is an array of language definitions that your plugin will contribute to Prettier. It can include all of the fields specified in prettier.getSupportInfo().
It must include name and parsers.
export const languages = [  {    // The language name    name: "InterpretedDanceScript",    // Parsers that can parse this language.    // This can be built-in parsers, or parsers you have contributed via this plugin.    parsers: ["dance-parse"],  },];
parsers‚Äã
Parsers convert code as a string into an AST.
The key must match the name in the parsers array from languages. The value contains a parse function, an AST format name, and two location extraction functions (locStart and locEnd).
export const parsers = {  "dance-parse": {    parse,    // The name of the AST that the parser produces.    astFormat: "dance-ast",    hasPragma,    locStart,    locEnd,    preprocess,  },};
The signature of the parse function is:
function parse(text: string, options: object): Promise<AST> | AST;
The location extraction functions (locStart and locEnd) return the starting and ending locations of a given AST node:
function locStart(node: object): number;
(Optional) The pragma detection function (hasPragma) should return if the text contains the pragma comment.
function hasPragma(text: string): boolean;
(Optional) The preprocess function can process the input text before passing into parse function.
function preprocess(text: string, options: object): string;
printers‚Äã
Printers convert ASTs into a Prettier intermediate representation, also known as a Doc.
The key must match the astFormat that the parser produces. The value contains an object with a print function. All other properties (embed, preprocess, etc.) are optional.
export const printers = {  "dance-ast": {    print,    embed,    preprocess,    getVisitorKeys,    insertPragma,    canAttachComment,    isBlockComment,    printComment,    getCommentChildNodes,    handleComments: {      ownLine,      endOfLine,      remaining,    },  },};
The printing process‚Äã
Prettier uses an intermediate representation, called a Doc, which Prettier then turns into a string (based on options like printWidth). A printer's job is to take the AST generated by parsers[<parser name>].parse and return a Doc. A Doc is constructed using builder commands:
import { doc } from "prettier";const { join, line, ifBreak, group } = doc.builders;
The printing process consists of the following steps:

AST preprocessing (optional). See preprocess.
Comment attachment (optional). See Handling comments in a printer.
Processing embedded languages (optional). The embed method, if defined, is called for each node, depth-first. While, for performance reasons, the recursion itself is synchronous, embed may return asynchronous functions that can call other parsers and printers to compose docs for embedded syntaxes like CSS-in-JS. These returned functions are queued up and sequentially executed before the next step.
Recursive printing. A doc is recursively constructed from the AST. Starting from the root node:

If, from the step 3, there is an embedded language doc associated with the current node, this doc is used.
Otherwise, the print(path, options, print): Doc method is called. It composes a doc for the current node, often by printing child nodes using the print callback.



print‚Äã
Most of the work of a plugin's printer will take place in its print function, whose signature is:
function print(  // Path to the AST node to print  path: AstPath,  options: object,  // Recursively print a child node  print: (selector?: string | number | Array<string | number> | AstPath) => Doc,): Doc;
The print function is passed the following parameters:

path: An object, which can be used to access nodes in the AST. It‚Äôs a stack-like data structure that maintains the current state of the recursion. It is called ‚Äúpath‚Äù because it represents the path to the current node from the root of the AST. The current node is returned by path.node.
options: A persistent object, which contains global options and which a plugin may mutate to store contextual data.
print: A callback for printing sub-nodes. This function contains the core printing logic that consists of steps whose implementation is provided by plugins. In particular, it calls the printer‚Äôs print function and passes itself to it. Thus, the two print functions ‚Äì the one from the core and the one from the plugin ‚Äì call each other while descending down the AST recursively.

Here‚Äôs a simplified example to give an idea of what a typical implementation of print looks like:
import { doc } from "prettier";const { group, indent, join, line, softline } = doc.builders;function print(path, options, print) {  const node = path.node;  switch (node.type) {    case "list":      return group([        "(",        indent([softline, join(line, path.map(print, "elements"))]),        softline,        ")",      ]);    case "pair":      return group([        "(",        indent([softline, print("left"), line, ". ", print("right")]),        softline,        ")",      ]);    case "symbol":      return node.name;  }  throw new Error(`Unknown node type: ${node.type}`);}
Check out prettier-python's printer for some examples of what is possible.
(optional) embed‚Äã
A printer can have the embed method to print one language inside another. Examples of this are printing CSS-in-JS or fenced code blocks in Markdown. The signature is:
function embed(  // Path to the current AST node  path: AstPath,  // Current options  options: Options,):  | ((      // Parses and prints the passed text using a different parser.      // You should set `options.parser` to specify which parser to use.      textToDoc: (text: string, options: Options) => Promise<Doc>,      // Prints the current node or its descendant node with the current printer      print: (        selector?: string | number | Array<string | number> | AstPath,      ) => Doc,      // The following two arguments are passed for convenience.      // They're the same `path` and `options` that are passed to `embed`.      path: AstPath,      options: Options,    ) => Promise<Doc | undefined> | Doc | undefined)  | Doc  | undefined;
The embed method is similar to the print method in that it maps AST nodes to docs, but unlike print, it has power to do async work by returning an async function. That function's first parameter, the textToDoc async function, can be used to render a doc using a different plugin.
If a function returned from embed returns a doc or a promise that resolves to a doc, that doc will be used in printing, and the print method won‚Äôt be called for this node. It's also possible and, in rare situations, might be convenient to return a doc synchronously directly from embed, however textToDoc and the print callback aren‚Äôt available at that case. Return a function to get them.
If embed returns undefined, or if a function it returned returns undefined or a promise that resolves to undefined, the node will be printed normally with the print method. Same will happen if a returned function throws an error or returns a promise that rejects (e.g., if a parsing error has happened). Set the PRETTIER_DEBUG environment variable to a non-empty value if you want Prettier to rethrow these errors.
For example, a plugin that has nodes with embedded JavaScript might have the following embed method:
function embed(path, options) {  const node = path.node;  if (node.type === "javascript") {    return async (textToDoc) => {      return [        "<script>",        hardline,        await textToDoc(node.javaScriptCode, { parser: "babel" }),        hardline,        "</script>",      ];    };  }}
If the --embedded-language-formatting option is set to off, the embedding step is entirely skipped, embed isn‚Äôt called, and all nodes are printed with the print method.
(optional) preprocess‚Äã
The preprocess method can process the AST from the parser before passing it into the print method.
function preprocess(ast: AST, options: Options): AST | Promise<AST>;
(optional) getVisitorKeys‚Äã
This property might come in handy if the plugin uses comment attachment or embedded languages. These features traverse the AST iterating through all the own enumerable properties of each node starting from the root. If the AST has cycles, such a traverse ends up in an infinite loop. Also, nodes might contain non-node objects (e.g., location data), iterating through which is a waste of resources. To solve these issues, the printer can define a function to return property names that should be traversed.
Its signature is:
function getVisitorKeys(node, nonTraversableKeys: Set<string>): string[];
The default getVisitorKeys:
function getVisitorKeys(node, nonTraversableKeys) {  return Object.keys(node).filter((key) => !nonTraversableKeys.has(key));}
The second argument nonTraversableKeys is a set of common keys and keys that prettier used internal.
If you have full list of visitor keys
const visitorKeys = {  Program: ["body"],  Identifier: [],  // ...};function getVisitorKeys(node /* , nonTraversableKeys*/) {  // Return `[]` for unknown node to prevent Prettier fallback to use `Object.keys()`  return visitorKeys[node.type] ?? [];}
If you only need exclude a small set of keys
const ignoredKeys = new Set(["prev", "next", "range"]);function getVisitorKeys(node, nonTraversableKeys) {  return Object.keys(node).filter(    (key) => !nonTraversableKeys.has(key) && !ignoredKeys.has(key),  );}
(optional) insertPragma‚Äã
A plugin can implement how a pragma comment is inserted in the resulting code when the --insert-pragma option is used, in the insertPragma function. Its signature is:
function insertPragma(text: string): string;
Handling comments in a printer‚Äã
Comments are often not part of a language's AST and present a challenge for pretty printers. A Prettier plugin can either print comments itself in its print function or rely on Prettier's comment algorithm.
By default, if the AST has a top-level comments property, Prettier assumes that comments stores an array of comment nodes. Prettier will then use the provided parsers[<plugin>].locStart/locEnd functions to search for the AST node that each comment "belongs" to. Comments are then attached to these nodes mutating the AST in the process, and the comments property is deleted from the AST root. The *Comment functions are used to adjust Prettier's algorithm. Once the comments are attached to the AST, Prettier will automatically call the printComment(path, options): Doc function and insert the returned doc into the (hopefully) correct place.
(optional) getCommentChildNodes‚Äã
By default, Prettier searches all object properties (except for a few predefined ones) of each node recursively. This function can be provided to override that behavior. It has the signature:
function getCommentChildNodes(  // The node whose children should be returned.  node: AST,  // Current options  options: object,): AST[] | undefined;
Return [] if the node has no children or undefined to fall back on the default behavior.
(optional) printComment‚Äã
Called whenever a comment node needs to be printed. It has the signature:
function printComment(  // Path to the current comment node  commentPath: AstPath,  // Current options  options: object,): Doc;
(optional) canAttachComment‚Äã
function canAttachComment(node: AST): boolean;
This function is used for deciding whether a comment can be attached to a particular AST node. By default, all AST properties are traversed searching for nodes that comments can be attached to. This function is used to prevent comments from being attached to a particular node. A typical implementation looks like
function canAttachComment(node) {  return node.type && node.type !== "comment";}
(optional) isBlockComment‚Äã
function isBlockComment(node: AST): boolean;
Returns whether or not the AST node is a block comment.
(optional) handleComments‚Äã
The handleComments object contains three optional functions, each with signature
(  // The AST node corresponding to the comment  comment: AST,  // The full source code text  text: string,  // The global options object  options: object,  // The AST  ast: AST,  // Whether this comment is the last comment  isLastComment: boolean,) => boolean;
These functions are used to override Prettier's default comment attachment algorithm. ownLine/endOfLine/remaining is expected to either manually attach a comment to a node and return true, or return false and let Prettier attach the comment.
Based on the text surrounding a comment node, Prettier dispatches:

ownLine if a comment has only whitespace preceding it and a newline afterwards,
endOfLine if a comment has a newline afterwards but some non-whitespace preceding it,
remaining in all other cases.

At the time of dispatching, Prettier will have annotated each AST comment node (i.e., created new properties) with at least one of enclosingNode, precedingNode, or followingNode. These can be used to aid a plugin's decision process (of course the entire AST and original text is also passed in for making more complicated decisions).
Manually attaching a comment‚Äã
The util.addTrailingComment/addLeadingComment/addDanglingComment functions can be used to manually attach a comment to an AST node. An example ownLine function that ensures a comment does not follow a "punctuation" node (made up for demonstration purposes) might look like:
import { util } from "prettier";function ownLine(comment, text, options, ast, isLastComment) {  const { precedingNode } = comment;  if (precedingNode && precedingNode.type === "punctuation") {    util.addTrailingComment(precedingNode, comment);    return true;  }  return false;}
Nodes with comments are expected to have a comments property containing an array of comments. Each comment is expected to have the following properties: leading, trailing, printed.
The example above uses util.addTrailingComment, which automatically sets comment.leading/trailing/printed to appropriate values and adds the comment to the AST node's comments array.
The --debug-print-comments CLI flag can help with debugging comment attachment issues. It prints a detailed list of comments, which includes information on how every comment was classified (ownLine/endOfLine/remaining, leading/trailing/dangling) and to which node it was attached. For Prettier‚Äôs built-in languages, this information is also available on the Playground (the 'show comments' checkbox in the Debug section).
options‚Äã
options is an object containing the custom options your plugin supports.
Example:
export default {  // ... plugin implementation  options: {    openingBraceNewLine: {      type: "boolean",      category: "Global",      default: true,      description: "Move open brace for code blocks onto new line.",    },  },};
defaultOptions‚Äã
If your plugin requires different default values for some of Prettier‚Äôs core options, you can specify them in defaultOptions:
export default {  // ... plugin implementation  defaultOptions: {    tabWidth: 4,  },};
Utility functions‚Äã
A util module from Prettier core is considered a private API and is not meant to be consumed by plugins. Instead, the util-shared module provides the following limited set of utility functions for plugins:
type Quote = '"' | "'";type SkipOptions = { backwards?: boolean };function getMaxContinuousCount(text: string, searchString: string): number;function getStringWidth(text: string): number;function getAlignmentSize(  text: string,  tabWidth: number,  startIndex?: number,): number;function getIndentSize(value: string, tabWidth: number): number;function skip(  characters: string | RegExp,): (  text: string,  startIndex: number | false,  options?: SkipOptions,) => number | false;function skipWhitespace(  text: string,  startIndex: number | false,  options?: SkipOptions,): number | false;function skipSpaces(  text: string,  startIndex: number | false,  options?: SkipOptions,): number | false;function skipToLineEnd(  text: string,  startIndex: number | false,  options?: SkipOptions,): number | false;function skipEverythingButNewLine(  text: string,  startIndex: number | false,  options?: SkipOptions,): number | false;function skipInlineComment(  text: string,  startIndex: number | false,): number | false;function skipTrailingComment(  text: string,  startIndex: number | false,): number | false;function skipNewline(  text: string,  startIndex: number | false,  options?: SkipOptions,): number | false;function hasNewline(  text: string,  startIndex: number,  options?: SkipOptions,): boolean;function hasNewlineInRange(  text: string,  startIndex: number,  startIndex: number,): boolean;function hasSpaces(  text: string,  startIndex: number,  options?: SkipOptions,): boolean;function getPreferredQuote(  text: string,  preferredQuoteOrPreferSingleQuote: Quote | boolean,): Quote;function makeString(  rawText: string,  enclosingQuote: Quote,  unescapeUnnecessaryEscapes?: boolean,): string;function getNextNonSpaceNonCommentCharacter(  text: string,  startIndex: number,): string;function getNextNonSpaceNonCommentCharacterIndex(  text: string,  startIndex: number,): number | false;function isNextLineEmpty(text: string, startIndex: number): boolean;function isPreviousLineEmpty(text: string, startIndex: number): boolean;
Tutorials‚Äã

How to write a plugin for Prettier: Teaches you how to write a very basic Prettier plugin for TOML.

Testing Plugins‚Äã
Since plugins can be resolved using relative paths, when working on one you can do:
import * as prettier from "prettier";const code = "(add 1 2)";await prettier.format(code, {  parser: "lisp",  plugins: ["."],});
This will resolve a plugin relative to the current working directory.Edit this pagePreviousPre-commit HookNextCLIUsing PluginsOfficial PluginsCommunity PluginsDeveloping PluginslanguagesparsersprintersoptionsdefaultOptionsUtility functionsTutorialsTesting Plugins\n\n\n\nOn this pageCLIUse the prettier command to run Prettier from the command line.
prettier [options] [file/dir/glob ...]
noteTo run your locally installed version of Prettier, prefix the command with npx, yarn exec, pnpm exec, or bun exec, i.e. npx prettier --help, yarn exec prettier --help, pnpm exec prettier --help, or bun exec prettier --help.
To format a file in-place, use --write. (Note: This overwrites your files!)
In practice, this may look something like:
prettier . --write
This command formats all files supported by Prettier in the current directory and its subdirectories.
It‚Äôs recommended to always make sure that prettier --write . only formats what you want in your project. Use a .prettierignore file to ignore things that should not be formatted.
A more complicated example:
prettier docs package.json "{app,__{tests,mocks}__}/**/*.js" --write --single-quote --trailing-comma all
warningDon‚Äôt forget the quotes around the globs! The quotes make sure that Prettier CLI expands the globs rather than your shell, which is important for cross-platform usage.
noteIt‚Äôs better to use a configuration file for formatting options like --single-quote and --trailing-comma instead of passing them as CLI flags. This way the Prettier CLI, editor integrations, and other tooling can all know what options you use.
File patterns‚Äã
Given a list of paths/patterns, the Prettier CLI first treats every entry in it as a literal path.


If the path points to an existing file, Prettier CLI proceeds with that file and doesn‚Äôt resolve the path as a glob pattern.


If the path points to an existing directory, Prettier CLI recursively finds supported files in that directory. This resolution process is based on file extensions and well-known file names that Prettier and its plugins associate with supported languages.


Otherwise, the entry is resolved as a glob pattern using the glob syntax from the fast-glob module.


Prettier CLI will ignore files located in node_modules directory. To opt out from this behavior, use --with-node-modules flag.
Prettier CLI will not follow symbolic links when expanding arguments.
To escape special characters in globs, one of the two escaping syntaxes can be used: prettier "\[my-dir]/*.js" or prettier "[[]my-dir]/*.js". Both match all JS files in a directory named [my-dir], however the latter syntax is preferable as the former doesn‚Äôt work on Windows, where backslashes are treated as path separators.
--check‚Äã
When you want to check if your files are formatted, you can run Prettier with the --check flag (or -c).
This will output a human-friendly message and a list of unformatted files, if any.
prettier . --check
Console output if all files are formatted:
Checking formatting...All matched files use Prettier code style!
Console output if some of the files require re-formatting:
Checking formatting...[warn] src/fileA.js[warn] src/fileB.js[warn] Code style issues found in 2 files. Run Prettier with --write to fix.
The command will return exit code 1 in the second case, which is helpful inside the CI pipelines.
Human-friendly status messages help project contributors react on possible problems.
To minimise the number of times prettier --check finds unformatted files, you may be interested in configuring a pre-commit hook in your repo.
Applying this practice will minimise the number of times the CI fails because of code formatting problems.
If you need to pipe the list of unformatted files to another command,¬†you can use --list-different flag instead of --check.
Exit codes‚Äã
CodeInformation0Everything formatted properly1Something wasn‚Äôt formatted properly2Something‚Äôs wrong with Prettier
--debug-check‚Äã
If you're worried that Prettier will change the correctness of your code, add --debug-check to the command. This will cause Prettier to print an error message if it detects that code correctness might have changed. Note that --write cannot be used with --debug-check.
--find-config-path and --config‚Äã
If you are repeatedly formatting individual files with prettier, you will incur a small performance cost when Prettier attempts to look up a configuration file. In order to skip this, you may ask Prettier to find the config file once, and re-use it later on.
$ prettier --find-config-path path/to/file.jspath/to/.prettierrc
This will provide you with a path to the configuration file, which you can pass to --config:
prettier path/to/file.js --write --config path/to/.prettierrc
You can also use --config if your configuration file lives somewhere where Prettier cannot find it, such as a config/ directory.
If you don‚Äôt have a configuration file, or want to ignore it if it does exist, you can pass --no-config instead.
--ignore-path‚Äã
Path to a file containing patterns that describe files to ignore. By default, Prettier looks for ./.gitignore and ./.prettierignore.
Multiple values are accepted.
--list-different‚Äã
Another useful flag is --list-different (or -l) which prints the filenames of files that are different from Prettier formatting. If there are differences the script errors out, which is useful in a CI scenario.
prettier . --single-quote --list-different
You can also use --check flag, which works the same way as --list-different, but also prints a human-friendly summary message to stdout.
--no-config‚Äã
Do not look for a configuration file. The default settings will be used.
--config-precedence‚Äã
Defines how config file should be evaluated in combination of CLI options.
cli-override (default)
CLI options take precedence over config file
file-override
Config file take precedence over CLI options
prefer-file
If a config file is found will evaluate it and ignore other CLI options. If no config file is found, CLI options will evaluate as normal.
This option adds support to editor integrations where users define their default configuration but want to respect project specific configuration.
--no-editorconfig‚Äã
Don‚Äôt take .editorconfig into account when parsing configuration. See the prettier.resolveConfig docs for details.
--with-node-modules‚Äã
Prettier CLI will ignore files located in node_modules directory. To opt out from this behavior, use --with-node-modules flag.
--write‚Äã
This rewrites all processed files in place. This is comparable to the eslint --fix workflow. You can also use -w alias.
--log-level‚Äã
Change the level of logging for the CLI. Valid options are:

error
warn
log (default)
debug
silent

--stdin-filepath‚Äã
A path to the file that the Prettier CLI will treat like stdin. For example:
abc.css
.name {  display: none;}
shell
$ cat abc.css | prettier --stdin-filepath abc.css.name {  display: none;}
--ignore-unknown‚Äã
With --ignore-unknown (or -u), prettier will ignore unknown files matched by patterns.
prettier "**/*" --write --ignore-unknown
--no-error-on-unmatched-pattern‚Äã
Prevent errors when pattern is unmatched.
--cache‚Äã
If this option is enabled, the following values are used as cache keys and the file is formatted only if one of them is changed.

Prettier version
Options
Node.js version
(if --cache-strategy is metadata) file metadata, such as timestamps
(if --cache-strategy is content) content of the file

prettier . --write --cache
Running Prettier without --cache will delete the cache.
Also, since the cache file is stored in ./node_modules/.cache/prettier/.prettier-cache, so you can use rm ./node_modules/.cache/prettier/.prettier-cache to remove it manually.
warningPlugins version and implementation are not used as cache keys. We recommend that you delete the cache when updating plugins.
--cache-location‚Äã
Path to the cache file location used by --cache flag. If you don't explicit --cache-location, Prettier saves cache file at ./node_modules/.cache/prettier/.prettier-cache.
If a file path is passed, that file is used as the cache file.
prettier . --write --cache --cache-location=path/to/cache-file
--cache-strategy‚Äã
Strategy for the cache to use for detecting changed files. Can be either metadata or content.
In general, metadata is faster. However, content is useful for updating the timestamp without changing the file content. This can happen, for example, during git operations such as git clone, because it does not track file modification times.
If no strategy is specified, content will be used.
prettier . --write --cache --cache-strategy metadataEdit this page\n\nOn this pageCLIUse the prettier command to run Prettier from the command line.
prettier [options] [file/dir/glob ...]
noteTo run your locally installed version of Prettier, prefix the command with npx, yarn exec, pnpm exec, or bun exec, i.e. npx prettier --help, yarn exec prettier --help, pnpm exec prettier --help, or bun exec prettier --help.
To format a file in-place, use --write. (Note: This overwrites your files!)
In practice, this may look something like:
prettier . --write
This command formats all files supported by Prettier in the current directory and its subdirectories.
It‚Äôs recommended to always make sure that prettier --write . only formats what you want in your project. Use a .prettierignore file to ignore things that should not be formatted.
A more complicated example:
prettier docs package.json "{app,__{tests,mocks}__}/**/*.js" --write --single-quote --trailing-comma all
warningDon‚Äôt forget the quotes around the globs! The quotes make sure that Prettier CLI expands the globs rather than your shell, which is important for cross-platform usage.
noteIt‚Äôs better to use a configuration file for formatting options like --single-quote and --trailing-comma instead of passing them as CLI flags. This way the Prettier CLI, editor integrations, and other tooling can all know what options you use.
File patterns‚Äã
Given a list of paths/patterns, the Prettier CLI first treats every entry in it as a literal path.


If the path points to an existing file, Prettier CLI proceeds with that file and doesn‚Äôt resolve the path as a glob pattern.


If the path points to an existing directory, Prettier CLI recursively finds supported files in that directory. This resolution process is based on file extensions and well-known file names that Prettier and its plugins associate with supported languages.


Otherwise, the entry is resolved as a glob pattern using the glob syntax from the fast-glob module.


Prettier CLI will ignore files located in node_modules directory. To opt out from this behavior, use --with-node-modules flag.
Prettier CLI will not follow symbolic links when expanding arguments.
To escape special characters in globs, one of the two escaping syntaxes can be used: prettier "\[my-dir]/*.js" or prettier "[[]my-dir]/*.js". Both match all JS files in a directory named [my-dir], however the latter syntax is preferable as the former doesn‚Äôt work on Windows, where backslashes are treated as path separators.
--check‚Äã
When you want to check if your files are formatted, you can run Prettier with the --check flag (or -c).
This will output a human-friendly message and a list of unformatted files, if any.
prettier . --check
Console output if all files are formatted:
Checking formatting...All matched files use Prettier code style!
Console output if some of the files require re-formatting:
Checking formatting...[warn] src/fileA.js[warn] src/fileB.js[warn] Code style issues found in 2 files. Run Prettier with --write to fix.
The command will return exit code 1 in the second case, which is helpful inside the CI pipelines.
Human-friendly status messages help project contributors react on possible problems.
To minimise the number of times prettier --check finds unformatted files, you may be interested in configuring a pre-commit hook in your repo.
Applying this practice will minimise the number of times the CI fails because of code formatting problems.
If you need to pipe the list of unformatted files to another command,¬†you can use --list-different flag instead of --check.
Exit codes‚Äã
CodeInformation0Everything formatted properly1Something wasn‚Äôt formatted properly2Something‚Äôs wrong with Prettier
--debug-check‚Äã
If you're worried that Prettier will change the correctness of your code, add --debug-check to the command. This will cause Prettier to print an error message if it detects that code correctness might have changed. Note that --write cannot be used with --debug-check.
--find-config-path and --config‚Äã
If you are repeatedly formatting individual files with prettier, you will incur a small performance cost when Prettier attempts to look up a configuration file. In order to skip this, you may ask Prettier to find the config file once, and re-use it later on.
$ prettier --find-config-path path/to/file.jspath/to/.prettierrc
This will provide you with a path to the configuration file, which you can pass to --config:
prettier path/to/file.js --write --config path/to/.prettierrc
You can also use --config if your configuration file lives somewhere where Prettier cannot find it, such as a config/ directory.
If you don‚Äôt have a configuration file, or want to ignore it if it does exist, you can pass --no-config instead.
--ignore-path‚Äã
Path to a file containing patterns that describe files to ignore. By default, Prettier looks for ./.gitignore and ./.prettierignore.
Multiple values are accepted.
--list-different‚Äã
Another useful flag is --list-different (or -l) which prints the filenames of files that are different from Prettier formatting. If there are differences the script errors out, which is useful in a CI scenario.
prettier . --single-quote --list-different
You can also use --check flag, which works the same way as --list-different, but also prints a human-friendly summary message to stdout.
--no-config‚Äã
Do not look for a configuration file. The default settings will be used.
--config-precedence‚Äã
Defines how config file should be evaluated in combination of CLI options.
cli-override (default)
CLI options take precedence over config file
file-override
Config file take precedence over CLI options
prefer-file
If a config file is found will evaluate it and ignore other CLI options. If no config file is found, CLI options will evaluate as normal.
This option adds support to editor integrations where users define their default configuration but want to respect project specific configuration.
--no-editorconfig‚Äã
Don‚Äôt take .editorconfig into account when parsing configuration. See the prettier.resolveConfig docs for details.
--with-node-modules‚Äã
Prettier CLI will ignore files located in node_modules directory. To opt out from this behavior, use --with-node-modules flag.
--write‚Äã
This rewrites all processed files in place. This is comparable to the eslint --fix workflow. You can also use -w alias.
--log-level‚Äã
Change the level of logging for the CLI. Valid options are:

error
warn
log (default)
debug
silent

--stdin-filepath‚Äã
A path to the file that the Prettier CLI will treat like stdin. For example:
abc.css
.name {  display: none;}
shell
$ cat abc.css | prettier --stdin-filepath abc.css.name {  display: none;}
--ignore-unknown‚Äã
With --ignore-unknown (or -u), prettier will ignore unknown files matched by patterns.
prettier "**/*" --write --ignore-unknown
--no-error-on-unmatched-pattern‚Äã
Prevent errors when pattern is unmatched.
--cache‚Äã
If this option is enabled, the following values are used as cache keys and the file is formatted only if one of them is changed.

Prettier version
Options
Node.js version
(if --cache-strategy is metadata) file metadata, such as timestamps
(if --cache-strategy is content) content of the file

prettier . --write --cache
Running Prettier without --cache will delete the cache.
Also, since the cache file is stored in ./node_modules/.cache/prettier/.prettier-cache, so you can use rm ./node_modules/.cache/prettier/.prettier-cache to remove it manually.
warningPlugins version and implementation are not used as cache keys. We recommend that you delete the cache when updating plugins.
--cache-location‚Äã
Path to the cache file location used by --cache flag. If you don't explicit --cache-location, Prettier saves cache file at ./node_modules/.cache/prettier/.prettier-cache.
If a file path is passed, that file is used as the cache file.
prettier . --write --cache --cache-location=path/to/cache-file
--cache-strategy‚Äã
Strategy for the cache to use for detecting changed files. Can be either metadata or content.
In general, metadata is faster. However, content is useful for updating the timestamp without changing the file content. This can happen, for example, during git operations such as git clone, because it does not track file modification times.
If no strategy is specified, content will be used.
prettier . --write --cache --cache-strategy metadataEdit this pagePreviousPluginsNextAPIFile patterns--checkExit codes--debug-check--find-config-path and --config--ignore-path--list-different--no-config--config-precedence--no-editorconfig--with-node-modules--write--log-level--stdin-filepath--ignore-unknown--no-error-on-unmatched-pattern--cache--cache-location--cache-strategy\n\n\n\nOn this pageAPIIf you want to run Prettier programmatically, check this page out.
import * as prettier from "prettier";
Our public APIs are all asynchronous, if you must use synchronous version for some reason, you can try @prettier/sync.
prettier.format(source, options)‚Äã
format is used to format text using Prettier. options.parser must be set according to the language you are formatting (see the list of available parsers). Alternatively, options.filepath can be specified for Prettier to infer the parser from the file extension. Other options may be provided to override the defaults.
await prettier.format("foo ( );", { semi: false, parser: "babel" });// -> 'foo()\n'
prettier.check(source [, options])‚Äã
check checks to see if the file has been formatted with Prettier given those options and returns a Promise<boolean>. This is similar to the --check or --list-different parameter in the CLI and is useful for running Prettier in CI scenarios.
prettier.formatWithCursor(source [, options])‚Äã
formatWithCursor both formats the code, and translates a cursor position from unformatted code to formatted code. This is useful for editor integrations, to prevent the cursor from moving when code is formatted.
The cursorOffset option should be provided, to specify where the cursor is.
await prettier.formatWithCursor(" 1", { cursorOffset: 2, parser: "babel" });// -> { formatted: '1;\n', cursorOffset: 1 }
prettier.resolveConfig(fileUrlOrPath [, options])‚Äã
resolveConfig can be used to resolve configuration for a given source file, passing its path or url as the first argument. The config search will start at the directory of the file location and continue to search up the directory. Or you can pass directly the path of the config file as options.config if you don‚Äôt wish to search for it. A promise is returned which will resolve to:

An options object, providing a config file was found.
null, if no file was found.

The promise will be rejected if there was an error parsing the configuration file.
If options.useCache is false, all caching will be bypassed.
const text = await fs.readFile(filePath, "utf8");const options = await prettier.resolveConfig(filePath);const formatted = await prettier.format(text, {  ...options,  filepath: filePath,});
If options.editorconfig is true and an .editorconfig file is in your project, Prettier will parse it and convert its properties to the corresponding Prettier configuration. This configuration will be overridden by .prettierrc, etc. Currently, the following EditorConfig properties are supported:

end_of_line
indent_style
indent_size/tab_width
max_line_length

prettier.resolveConfigFile([fileUrlOrPath])‚Äã
resolveConfigFile can be used to find the path of the Prettier configuration file that will be used when resolving the config (i.e. when calling resolveConfig). A promise is returned which will resolve to:

The path of the configuration file.
null, if no file was found.

The promise will be rejected if there was an error parsing the configuration file.
The search starts at process.cwd(), or at the directory of fileUrlOrPath if provided.
const configFile = await prettier.resolveConfigFile(filePath);// you got the path of the configuration file
prettier.clearConfigCache()‚Äã
When Prettier loads configuration files and plugins, the file system structure is cached for performance. This function will clear the cache. Generally this is only needed for editor integrations that know that the file system has changed since the last format took place.
prettier.getFileInfo(fileUrlOrPath [, options])‚Äã
getFileInfo can be used by editor extensions to decide if a particular file needs to be formatted. This method returns a promise, which resolves to an object with the following properties:
{  ignored: boolean;  inferredParser: string | null;}
The promise will be rejected if the type of fileUrlOrPath is not string or URL.
Setting options.ignorePath (string | URL | (string | URL)[]) and options.withNodeModules (boolean) influence the value of ignored (false by default).
If the given fileUrlOrPath is ignored, the inferredParser is always null.
Providing plugin paths in options.plugins (string[]) helps extract inferredParser for files that are not supported by Prettier core.
When setting options.resolveConfig (boolean, default true) to false, Prettier will not search for configuration file. This can be useful if this function is only used to check if file is ignored.
prettier.getSupportInfo()‚Äã
Returns a promise which resolves to an object representing the options, parsers, languages and file types Prettier supports.
The support information looks like this:
{  languages: Array<{    name: string;    parsers: string[];    group?: string;    tmScope?: string;    aceMode?: string;    codemirrorMode?: string;    codemirrorMimeType?: string;    aliases?: string[];    extensions?: string[];    filenames?: string[];    linguistLanguageId?: number;    vscodeLanguageIds?: string[];  }>;}

Custom Parser API (removed)‚Äã
Removed in v3.0.0 (superseded by the Plugin API)
Before plugins were a thing, Prettier had a similar but more limited feature called custom parsers. It‚Äôs been removed in v3.0.0 as its functionality was a subset of what the Plugin API did. If you used it, please check the example below on how to migrate.
‚ùå Custom parser API (removed):
import { format } from "prettier";format("lodash ( )", {  parser(text, { babel }) {    const ast = babel(text);    ast.program.body[0].expression.callee.name = "_";    return ast;  },});// -> "_();\n"
‚úîÔ∏è Plugin API:
import { format } from "prettier";import * as prettierPluginBabel from "prettier/plugins/babel";const myCustomPlugin = {  parsers: {    "my-custom-parser": {      async parse(text) {        const ast = await prettierPluginBabel.parsers.babel.parse(text);        ast.program.body[0].expression.callee.name = "_";        return ast;      },      astFormat: "estree",    },  },};await format("lodash ( )", {  parser: "my-custom-parser",  plugins: [myCustomPlugin],});// -> "_();\n"
noteOverall, doing codemods this way isn‚Äôt recommended. Prettier uses the location data of AST nodes for many things like preserving blank lines and attaching comments. When the AST is modified after the parsing, the location data often gets out of sync, which may lead to unpredictable results. Consider using jscodeshift if you need codemods.
As part of the removed Custom parser API, it was previously possible to pass a path to a module exporting a parse function via the --parser option. Use the --plugin CLI option or the plugins API option instead to load plugins.Edit this page\n\nOn this pageAPIIf you want to run Prettier programmatically, check this page out.
import * as prettier from "prettier";
Our public APIs are all asynchronous, if you must use synchronous version for some reason, you can try @prettier/sync.
prettier.format(source, options)‚Äã
format is used to format text using Prettier. options.parser must be set according to the language you are formatting (see the list of available parsers). Alternatively, options.filepath can be specified for Prettier to infer the parser from the file extension. Other options may be provided to override the defaults.
await prettier.format("foo ( );", { semi: false, parser: "babel" });// -> 'foo()\n'
prettier.check(source [, options])‚Äã
check checks to see if the file has been formatted with Prettier given those options and returns a Promise<boolean>. This is similar to the --check or --list-different parameter in the CLI and is useful for running Prettier in CI scenarios.
prettier.formatWithCursor(source [, options])‚Äã
formatWithCursor both formats the code, and translates a cursor position from unformatted code to formatted code. This is useful for editor integrations, to prevent the cursor from moving when code is formatted.
The cursorOffset option should be provided, to specify where the cursor is.
await prettier.formatWithCursor(" 1", { cursorOffset: 2, parser: "babel" });// -> { formatted: '1;\n', cursorOffset: 1 }
prettier.resolveConfig(fileUrlOrPath [, options])‚Äã
resolveConfig can be used to resolve configuration for a given source file, passing its path or url as the first argument. The config search will start at the directory of the file location and continue to search up the directory. Or you can pass directly the path of the config file as options.config if you don‚Äôt wish to search for it. A promise is returned which will resolve to:

An options object, providing a config file was found.
null, if no file was found.

The promise will be rejected if there was an error parsing the configuration file.
If options.useCache is false, all caching will be bypassed.
const text = await fs.readFile(filePath, "utf8");const options = await prettier.resolveConfig(filePath);const formatted = await prettier.format(text, {  ...options,  filepath: filePath,});
If options.editorconfig is true and an .editorconfig file is in your project, Prettier will parse it and convert its properties to the corresponding Prettier configuration. This configuration will be overridden by .prettierrc, etc. Currently, the following EditorConfig properties are supported:

end_of_line
indent_style
indent_size/tab_width
max_line_length

prettier.resolveConfigFile([fileUrlOrPath])‚Äã
resolveConfigFile can be used to find the path of the Prettier configuration file that will be used when resolving the config (i.e. when calling resolveConfig). A promise is returned which will resolve to:

The path of the configuration file.
null, if no file was found.

The promise will be rejected if there was an error parsing the configuration file.
The search starts at process.cwd(), or at the directory of fileUrlOrPath if provided.
const configFile = await prettier.resolveConfigFile(filePath);// you got the path of the configuration file
prettier.clearConfigCache()‚Äã
When Prettier loads configuration files and plugins, the file system structure is cached for performance. This function will clear the cache. Generally this is only needed for editor integrations that know that the file system has changed since the last format took place.
prettier.getFileInfo(fileUrlOrPath [, options])‚Äã
getFileInfo can be used by editor extensions to decide if a particular file needs to be formatted. This method returns a promise, which resolves to an object with the following properties:
{  ignored: boolean;  inferredParser: string | null;}
The promise will be rejected if the type of fileUrlOrPath is not string or URL.
Setting options.ignorePath (string | URL | (string | URL)[]) and options.withNodeModules (boolean) influence the value of ignored (false by default).
If the given fileUrlOrPath is ignored, the inferredParser is always null.
Providing plugin paths in options.plugins (string[]) helps extract inferredParser for files that are not supported by Prettier core.
When setting options.resolveConfig (boolean, default true) to false, Prettier will not search for configuration file. This can be useful if this function is only used to check if file is ignored.
prettier.getSupportInfo()‚Äã
Returns a promise which resolves to an object representing the options, parsers, languages and file types Prettier supports.
The support information looks like this:
{  languages: Array<{    name: string;    parsers: string[];    group?: string;    tmScope?: string;    aceMode?: string;    codemirrorMode?: string;    codemirrorMimeType?: string;    aliases?: string[];    extensions?: string[];    filenames?: string[];    linguistLanguageId?: number;    vscodeLanguageIds?: string[];  }>;}

Custom Parser API (removed)‚Äã
Removed in v3.0.0 (superseded by the Plugin API)
Before plugins were a thing, Prettier had a similar but more limited feature called custom parsers. It‚Äôs been removed in v3.0.0 as its functionality was a subset of what the Plugin API did. If you used it, please check the example below on how to migrate.
‚ùå Custom parser API (removed):
import { format } from "prettier";format("lodash ( )", {  parser(text, { babel }) {    const ast = babel(text);    ast.program.body[0].expression.callee.name = "_";    return ast;  },});// -> "_();\n"
‚úîÔ∏è Plugin API:
import { format } from "prettier";import * as prettierPluginBabel from "prettier/plugins/babel";const myCustomPlugin = {  parsers: {    "my-custom-parser": {      async parse(text) {        const ast = await prettierPluginBabel.parsers.babel.parse(text);        ast.program.body[0].expression.callee.name = "_";        return ast;      },      astFormat: "estree",    },  },};await format("lodash ( )", {  parser: "my-custom-parser",  plugins: [myCustomPlugin],});// -> "_();\n"
noteOverall, doing codemods this way isn‚Äôt recommended. Prettier uses the location data of AST nodes for many things like preserving blank lines and attaching comments. When the AST is modified after the parsing, the location data often gets out of sync, which may lead to unpredictable results. Consider using jscodeshift if you need codemods.
As part of the removed Custom parser API, it was previously possible to pass a path to a module exporting a parse function via the --parser option. Use the --plugin CLI option or the plugins API option instead to load plugins.Edit this pagePreviousCLINextBrowserprettier.format(source, options)prettier.check(source [, options])prettier.formatWithCursor(source [, options])prettier.resolveConfig(fileUrlOrPath [, options])prettier.resolveConfigFile([fileUrlOrPath])prettier.clearConfigCache()prettier.getFileInfo(fileUrlOrPath [, options])prettier.getSupportInfo()Custom Parser API (removed)\n\n\n\nOn this pageBrowserRun Prettier in the browser using its standalone version. This version doesn‚Äôt depend on Node.js. It only formats the code and has no support for config files, ignore files, CLI usage, or automatic loading of plugins.
The standalone version comes as:

ES modules: standalone.mjs, starting in version 3.0 (In version 2, esm/standalone.mjs.)
UMD: standalone.js, starting in version 1.13

The browser field in Prettier‚Äôs package.json points to standalone.js. That‚Äôs why you can just import or require the prettier module to access Prettier‚Äôs API, and your code can stay compatible with both Node and the browser as long as webpack or another bundler that supports the browser field is used. This is especially convenient for plugins.
prettier.format(code, options)‚Äã
Required options:


parser (or filepath): One of these options has to be specified for Prettier to know which parser to use.


plugins: Unlike the format function from the Node.js-based API, this function doesn‚Äôt load plugins automatically. The plugins option is required because all the parsers included in the Prettier package come as plugins (for reasons of file size). These plugins are files in https://unpkg.com/browse/prettier@3.5.3/plugins. Note that estree plugin should be loaded when printing JavaScript, TypeScript, Flow, or JSON.
You need to load the ones that you‚Äôre going to use and pass them to prettier.format using the plugins option.


See below for examples.
Usage‚Äã
Global‚Äã
<script src="https://unpkg.com/prettier@3.5.3/standalone.js"></script><script src="https://unpkg.com/prettier@3.5.3/plugins/graphql.js"></script><script>  (async () => {    const formatted = await prettier.format("type Query { hello: String }", {      parser: "graphql",      plugins: prettierPlugins,    });  })();</script>
Note that the unpkg field in Prettier‚Äôs package.json points to standalone.js, that‚Äôs why https://unpkg.com/prettier can also be used instead of https://unpkg.com/prettier/standalone.js.
ES Modules‚Äã
<script type="module">  import * as prettier from "https://unpkg.com/prettier@3.5.3/standalone.mjs";  import * as prettierPluginGraphql from "https://unpkg.com/prettier@3.5.3/plugins/graphql.mjs";  const formatted = await prettier.format("type Query { hello: String }", {    parser: "graphql",    plugins: [prettierPluginGraphql],  });</script>
AMD‚Äã
define([  "https://unpkg.com/prettier@3.5.3/standalone.js",  "https://unpkg.com/prettier@3.5.3/plugins/graphql.js",], async (prettier, ...plugins) => {  const formatted = await prettier.format("type Query { hello: String }", {    parser: "graphql",    plugins,  });});
CommonJS‚Äã
const prettier = require("prettier/standalone");const plugins = [require("prettier/plugins/graphql")];(async () => {  const formatted = await prettier.format("type Query { hello: String }", {    parser: "graphql",    plugins,  });})();
This syntax doesn‚Äôt necessarily work in the browser, but it can be used when bundling the code with browserify, Rollup, webpack, or another bundler.
Worker‚Äã
Module workerClassic workerimport * as prettier from "https://unpkg.com/prettier@3.5.3/standalone.mjs";import * as prettierPluginGraphql from "https://unpkg.com/prettier@3.5.31/plugins/graphql.mjs";const formatted = await prettier.format("type Query { hello: String }", {  parser: "graphql",  plugins: [prettierPluginGraphql],});importScripts(  "https://unpkg.com/prettier@3.5.3/standalone.js",  "https://unpkg.com/prettier@3.5.3/plugins/graphql.js",);(async () => {  const formatted = await prettier.format("type Query { hello: String }", {    parser: "graphql",    plugins: prettierPlugins,  });})();
Parser plugins for embedded code‚Äã
If you want to format embedded code, you need to load related plugins too. For example:
<script type="module">  import * as prettier from "https://unpkg.com/prettier@3.5.3/standalone.mjs";  import * as prettierPluginBabel from "https://unpkg.com/prettier@3.5.3/plugins/babel.mjs";  import * as prettierPluginEstree from "https://unpkg.com/prettier@3.5.3/plugins/estree.mjs";  console.log(    await prettier.format("const html=/* HTML */ `<DIV> </DIV>`", {      parser: "babel",      plugins: [prettierPluginBabel, prettierPluginEstree],    }),  );  // Output: const html = /* HTML */ `<DIV> </DIV>`;</script>
The HTML code embedded in JavaScript stays unformatted because the html parser hasn‚Äôt been loaded. Correct usage:
<script type="module">  import * as prettier from "https://unpkg.com/prettier@3.5.3/standalone.mjs";  import * as prettierPluginBabel from "https://unpkg.com/prettier@3.5.3/plugins/babel.mjs";  import * as prettierPluginEstree from "https://unpkg.com/prettier@3.5.3/plugins/estree.mjs";  import * as prettierPluginHtml from "https://unpkg.com/prettier@3.5.3/plugins/html.mjs";  console.log(    await prettier.format("const html=/* HTML */ `<DIV> </DIV>`", {      parser: "babel",      plugins: [prettierPluginBabel, prettierPluginEstree, prettierPluginHtml],    }),  );  // Output: const html = /* HTML */ `<div></div>`;</script>Edit this page\n\nOn this pageBrowserRun Prettier in the browser using its standalone version. This version doesn‚Äôt depend on Node.js. It only formats the code and has no support for config files, ignore files, CLI usage, or automatic loading of plugins.
The standalone version comes as:

ES modules: standalone.mjs, starting in version 3.0 (In version 2, esm/standalone.mjs.)
UMD: standalone.js, starting in version 1.13

The browser field in Prettier‚Äôs package.json points to standalone.js. That‚Äôs why you can just import or require the prettier module to access Prettier‚Äôs API, and your code can stay compatible with both Node and the browser as long as webpack or another bundler that supports the browser field is used. This is especially convenient for plugins.
prettier.format(code, options)‚Äã
Required options:


parser (or filepath): One of these options has to be specified for Prettier to know which parser to use.


plugins: Unlike the format function from the Node.js-based API, this function doesn‚Äôt load plugins automatically. The plugins option is required because all the parsers included in the Prettier package come as plugins (for reasons of file size). These plugins are files in https://unpkg.com/browse/prettier@3.5.3/plugins. Note that estree plugin should be loaded when printing JavaScript, TypeScript, Flow, or JSON.
You need to load the ones that you‚Äôre going to use and pass them to prettier.format using the plugins option.


See below for examples.
Usage‚Äã
Global‚Äã
<script src="https://unpkg.com/prettier@3.5.3/standalone.js"></script><script src="https://unpkg.com/prettier@3.5.3/plugins/graphql.js"></script><script>  (async () => {    const formatted = await prettier.format("type Query { hello: String }", {      parser: "graphql",      plugins: prettierPlugins,    });  })();</script>
Note that the unpkg field in Prettier‚Äôs package.json points to standalone.js, that‚Äôs why https://unpkg.com/prettier can also be used instead of https://unpkg.com/prettier/standalone.js.
ES Modules‚Äã
<script type="module">  import * as prettier from "https://unpkg.com/prettier@3.5.3/standalone.mjs";  import * as prettierPluginGraphql from "https://unpkg.com/prettier@3.5.3/plugins/graphql.mjs";  const formatted = await prettier.format("type Query { hello: String }", {    parser: "graphql",    plugins: [prettierPluginGraphql],  });</script>
AMD‚Äã
define([  "https://unpkg.com/prettier@3.5.3/standalone.js",  "https://unpkg.com/prettier@3.5.3/plugins/graphql.js",], async (prettier, ...plugins) => {  const formatted = await prettier.format("type Query { hello: String }", {    parser: "graphql",    plugins,  });});
CommonJS‚Äã
const prettier = require("prettier/standalone");const plugins = [require("prettier/plugins/graphql")];(async () => {  const formatted = await prettier.format("type Query { hello: String }", {    parser: "graphql",    plugins,  });})();
This syntax doesn‚Äôt necessarily work in the browser, but it can be used when bundling the code with browserify, Rollup, webpack, or another bundler.
Worker‚Äã
Module workerClassic workerimport * as prettier from "https://unpkg.com/prettier@3.5.3/standalone.mjs";import * as prettierPluginGraphql from "https://unpkg.com/prettier@3.5.31/plugins/graphql.mjs";const formatted = await prettier.format("type Query { hello: String }", {  parser: "graphql",  plugins: [prettierPluginGraphql],});importScripts(  "https://unpkg.com/prettier@3.5.3/standalone.js",  "https://unpkg.com/prettier@3.5.3/plugins/graphql.js",);(async () => {  const formatted = await prettier.format("type Query { hello: String }", {    parser: "graphql",    plugins: prettierPlugins,  });})();
Parser plugins for embedded code‚Äã
If you want to format embedded code, you need to load related plugins too. For example:
<script type="module">  import * as prettier from "https://unpkg.com/prettier@3.5.3/standalone.mjs";  import * as prettierPluginBabel from "https://unpkg.com/prettier@3.5.3/plugins/babel.mjs";  import * as prettierPluginEstree from "https://unpkg.com/prettier@3.5.3/plugins/estree.mjs";  console.log(    await prettier.format("const html=/* HTML */ `<DIV> </DIV>`", {      parser: "babel",      plugins: [prettierPluginBabel, prettierPluginEstree],    }),  );  // Output: const html = /* HTML */ `<DIV> </DIV>`;</script>
The HTML code embedded in JavaScript stays unformatted because the html parser hasn‚Äôt been loaded. Correct usage:
<script type="module">  import * as prettier from "https://unpkg.com/prettier@3.5.3/standalone.mjs";  import * as prettierPluginBabel from "https://unpkg.com/prettier@3.5.3/plugins/babel.mjs";  import * as prettierPluginEstree from "https://unpkg.com/prettier@3.5.3/plugins/estree.mjs";  import * as prettierPluginHtml from "https://unpkg.com/prettier@3.5.3/plugins/html.mjs";  console.log(    await prettier.format("const html=/* HTML */ `<DIV> </DIV>`", {      parser: "babel",      plugins: [prettierPluginBabel, prettierPluginEstree, prettierPluginHtml],    }),  );  // Output: const html = /* HTML */ `<div></div>`;</script>Edit this pagePreviousAPINextRun Prettier on CIprettier.format(code, options)UsageGlobalES ModulesAMDCommonJSWorkerParser plugins for embedded code\n\n\n\nOn this pageRun Prettier on CIGitHub Actions‚Äã
To apply autofix for Prettier from GitHub Actions, do the following:


Install the autofix.ci GitHub App.


Make sure you have a pinned version of Prettier installed in your repository.


Create .github/workflows/prettier.yml with following content:
.github/workflows/prettier.ymlname: autofix.cion:  pull_request:  push:permissions: {}jobs:  prettier:    runs-on: ubuntu-latest    steps:      - uses: actions/checkout@v4      - uses: actions/setup-node@v4      - run: |          yarn          yarn prettier . --write      - uses: autofix-ci/action@v1        with:          commit-message: "Apply Prettier format"


For more information see autofix.ci website.Edit this page\n\nOn this pageRun Prettier on CIGitHub Actions‚Äã
To apply autofix for Prettier from GitHub Actions, do the following:


Install the autofix.ci GitHub App.


Make sure you have a pinned version of Prettier installed in your repository.


Create .github/workflows/prettier.yml with following content:
.github/workflows/prettier.ymlname: autofix.cion:  pull_request:  push:permissions: {}jobs:  prettier:    runs-on: ubuntu-latest    steps:      - uses: actions/checkout@v4      - uses: actions/setup-node@v4      - run: |          yarn          yarn prettier . --write      - uses: autofix-ci/action@v1        with:          commit-message: "Apply Prettier format"


For more information see autofix.ci website.Edit this pagePreviousBrowserNextOptionsGitHub Actions\n\n\n\nOn this pageOptionsPrettier ships with a handful of format options.
To learn more about Prettier‚Äôs stance on options ‚Äì see the Option Philosophy.
If you change any options, it‚Äôs recommended to do it via a configuration file. This way the Prettier CLI, editor integrations and other tooling knows what options you use.
Experimental Ternaries‚Äã
Try prettier's new ternary formatting before it becomes the default behavior.
Valid options:

true - Use curious ternaries, with the question mark after the condition.
false - Retain the default behavior of ternaries; keep question marks on the same line as the consequent.

DefaultCLI OverrideAPI Overridefalse--experimental-ternariesexperimentalTernaries: <bool>
Experimental Operator Position‚Äã
Valid options:

"start" - When binary expressions wrap lines, print operators at the start of new lines.
"end" - Default behavior; when binary expressions wrap lines, print operators at the end of previous lines.

DefaultCLI OverrideAPI Override"end"--experimental-operator-position <start|end>experimentalOperatorPosition: "<start|end>"
Print Width‚Äã
Specify the line length that the printer will wrap on.
warningFor readability we recommend against using more than 80 characters:In code styleguides, maximum line length rules are often set to 100 or 120. However, when humans write code, they don‚Äôt strive to reach the maximum number of columns on every line. Developers often use whitespace to break up long lines for readability. In practice, the average line length often ends up well below the maximum.Prettier‚Äôs printWidth option does not work the same way. It is not the hard upper allowed line length limit. It is a way to say to Prettier roughly how long you‚Äôd like lines to be. Prettier will make both shorter and longer lines, but generally strive to meet the specified printWidth.Remember, computers are dumb. You need to explicitly tell them what to do, while humans can make their own (implicit) judgements, for example on when to break a line.In other words, don‚Äôt try to use printWidth as if it was ESLint‚Äôs max-len ‚Äì they‚Äôre not the same. max-len just says what the maximum allowed line length is, but not what the generally preferred length is ‚Äì which is what printWidth specifies.
DefaultCLI OverrideAPI Override80--print-width <int>printWidth: <int>
Setting max_line_length in an .editorconfig file will configure Prettier‚Äôs print width, unless overridden.
(If you don‚Äôt want line wrapping when formatting Markdown, you can set the Prose Wrap option to disable it.)
Tab Width‚Äã
Specify the number of spaces per indentation-level.
DefaultCLI OverrideAPI Override2--tab-width <int>tabWidth: <int>
Setting indent_size or tab_width in an .editorconfig file will configure Prettier‚Äôs tab width, unless overridden.
Tabs‚Äã
Indent lines with tabs instead of spaces.
DefaultCLI OverrideAPI Overridefalse--use-tabsuseTabs: <bool>
Setting indent_style in an .editorconfig file will configure Prettier‚Äôs tab usage, unless overridden.
(Tabs will be used for indentation but Prettier uses spaces to align things, such as in ternaries. This behavior is known as SmartTabs.)
Semicolons‚Äã
Print semicolons at the ends of statements.
Valid options:

true - Add a semicolon at the end of every statement.
false - Only add semicolons at the beginning of lines that may introduce ASI failures.

DefaultCLI OverrideAPI Overridetrue--no-semisemi: <bool>
Quotes‚Äã
Use single quotes instead of double quotes.
Notes:

JSX quotes ignore this option ‚Äì see jsx-single-quote.
If the number of quotes outweighs the other quote, the quote which is less used will be used to format the string - Example: "I'm double quoted" results in "I'm double quoted" and "This \"example\" is single quoted" results in 'This "example" is single quoted'.

See the strings rationale for more information.
DefaultCLI OverrideAPI Overridefalse--single-quotesingleQuote: <bool>
Quote Props‚Äã
Change when properties in objects are quoted.
Valid options:

"as-needed" - Only add quotes around object properties where required.
"consistent" - If at least one property in an object requires quotes, quote all properties.
"preserve" - Respect the input use of quotes in object properties.

DefaultCLI OverrideAPI Override"as-needed"--quote-props <as-needed|consistent|preserve>quoteProps: "<as-needed|consistent|preserve>"
Note that Prettier never unquotes numeric property names in Angular expressions, TypeScript, and Flow because the distinction between string and numeric keys is significant in these languages. See: Angular, TypeScript, Flow. Also Prettier doesn‚Äôt unquote numeric properties for Vue (see the issue about that).
JSX Quotes‚Äã
Use single quotes instead of double quotes in JSX.
DefaultCLI OverrideAPI Overridefalse--jsx-single-quotejsxSingleQuote: <bool>
Trailing Commas‚Äã
Default value changed from es5 to all in v3.0.0
Print trailing commas wherever possible in multi-line comma-separated syntactic structures. (A single-line array, for example, never gets trailing commas.)
Valid options:

"all" - Trailing commas wherever possible (including function parameters and calls). To run, JavaScript code formatted this way needs an engine that supports ES2017 (Node.js 8+ or a modern browser) or downlevel compilation. This also enables trailing commas in type parameters in TypeScript (supported since TypeScript 2.7 released in January 2018).
"es5" - Trailing commas where valid in ES5 (objects, arrays, etc.). Trailing commas in type parameters in TypeScript and Flow.
"none" - No trailing commas.

DefaultCLI OverrideAPI Override"all"--trailing-comma <all|es5|none>trailingComma: "<all|es5|none>"
Bracket Spacing‚Äã
Print spaces between brackets in object literals.
Valid options:

true - Example: { foo: bar }.
false - Example: {foo: bar}.

DefaultCLI OverrideAPI Overridetrue--no-bracket-spacingbracketSpacing: <bool>
Object Wrap‚Äã
First available in v3.5.0
Configure how Prettier wraps object literals when they could fit on one line or span multiple lines.
By default, Prettier formats objects as multi-line if there is a newline prior to the first property. Authors can use this heuristic to contextually improve readability, though it has some downsides. See Multi-line objects.
Valid options:

"preserve" - Keep as multi-line, if there is a newline between the opening brace and first property.
"collapse" - Fit to a single line when possible.

DefaultCLI OverrideAPI Override"preserve"--object-wrap <preserve|collapse>objectWrap: "<preserve|collapse>"
Bracket Line‚Äã
Put the > of a multi-line HTML (HTML, JSX, Vue, Angular) element at the end of the last line instead of being alone on the next line (does not apply to self closing elements).
Valid options:

true - Example:

<button  className="prettier-class"  id="prettier-id"  onClick={this.handleClick}>  Click Here</button>

false - Example:

<button  className="prettier-class"  id="prettier-id"  onClick={this.handleClick}>  Click Here</button>
DefaultCLI OverrideAPI Overridefalse--bracket-same-linebracketSameLine: <bool>
[Deprecated] JSX Brackets‚Äã
dangerThis option has been deprecated in v2.4.0, use --bracket-same-line instead.
Put the > of a multi-line JSX element at the end of the last line instead of being alone on the next line (does not apply to self closing elements).
Valid options:

true - Example:

<button  className="prettier-class"  id="prettier-id"  onClick={this.handleClick}>  Click Here</button>

false - Example:

<button  className="prettier-class"  id="prettier-id"  onClick={this.handleClick}>  Click Here</button>
DefaultCLI OverrideAPI Overridefalse--jsx-bracket-same-linejsxBracketSameLine: <bool>
Arrow Function Parentheses‚Äã
First available in v1.9.0, default value changed from avoid to always in v2.0.0
Include parentheses around a sole arrow function parameter.
Valid options:

"always" - Always include parens. Example: (x) => x
"avoid" - Omit parens when possible. Example: x => x

DefaultCLI OverrideAPI Override"always"--arrow-parens <always|avoid>arrowParens: "<always|avoid>"
At first glance, avoiding parentheses may look like a better choice because of less visual noise.
However, when Prettier removes parentheses, it becomes harder to add type annotations, extra arguments or default values as well as making other changes.
Consistent use of parentheses provides a better developer experience when editing real codebases, which justifies the default value for the option.
Range‚Äã
Format only a segment of a file.
These two options can be used to format code starting and ending at a given character offset (inclusive and exclusive, respectively). The range will extend:

Backwards to the start of the first line containing the selected statement.
Forwards to the end of the selected statement.

DefaultCLI OverrideAPI Override0--range-start <int>rangeStart: <int>Infinity--range-end <int>rangeEnd: <int>
Parser‚Äã
Specify which parser to use.
Prettier automatically infers the parser from the input file path, so you shouldn‚Äôt have to change this setting.
Both the babel and flow parsers support the same set of JavaScript features (including Flow type annotations). They might differ in some edge cases, so if you run into one of those you can try flow instead of babel. Almost the same applies to typescript and babel-ts. babel-ts might support JavaScript features (proposals) not yet supported by TypeScript, but it‚Äôs less permissive when it comes to invalid code and less battle-tested than the typescript parser.
Valid options:

"babel" (via @babel/parser) Named "babylon" until v1.16.0
"babel-flow" (same as "babel" but enables Flow parsing explicitly to avoid ambiguity) First available in v1.16.0
"babel-ts" (similar to "typescript" but uses Babel and its TypeScript plugin) First available in v2.0.0
"flow" (via flow-parser)
"typescript" (via @typescript-eslint/typescript-estree) First available in v1.4.0
"espree" (via espree) First available in v2.2.0
"meriyah" (via meriyah) First available in v2.2.0
"acorn" (via acorn) First available in v2.6.0
"css" (via postcss) First available in v1.7.1
"scss" (via postcss-scss) First available in v1.7.1
"less" (via postcss-less) First available in v1.7.1
"json" (via @babel/parser parseExpression) First available in v1.5.0
"json5" (same parser as "json", but outputs as json5) First available in v1.13.0
"jsonc" (same parser as "json", but outputs as "JSON with Comments") First available in v3.2.0
"json-stringify" (same parser as "json", but outputs like JSON.stringify) First available in v1.13.0
"graphql" (via graphql/language) First available in v1.5.0
"markdown" (via remark-parse) First available in v1.8.0
"mdx" (via remark-parse and @mdx-js/mdx) First available in v1.15.0
"html" (via angular-html-parser) First available in 1.15.0
"vue" (same parser as "html", but also formats vue-specific syntax) First available in 1.10.0
"angular" (same parser as "html", but also formats angular-specific syntax via angular-estree-parser) First available in 1.15.0
"lwc" (same parser as "html", but also formats LWC-specific syntax for unquoted template attributes) First available in 1.17.0
"yaml" (via yaml and yaml-unist-parser) First available in 1.14.0

DefaultCLI OverrideAPI OverrideNone--parser <string>parser: "<string>"
Note: the default value was "babylon" until v1.13.0.
Note: the Custom parser API has been removed in v3.0.0. Use plugins instead (how to migrate).

File Path‚Äã
Specify the file name to use to infer which parser to use.
For example, the following will use the CSS parser:
cat foo | prettier --stdin-filepath foo.css
This option is only useful in the CLI and API. It doesn‚Äôt make sense to use it in a configuration file.
DefaultCLI OverrideAPI OverrideNone--stdin-filepath <string>filepath: "<string>"
Require Pragma‚Äã
First available in v1.7.0
Prettier can restrict itself to only format files that contain a special comment, called a pragma, at the top of the file. This is very useful when gradually transitioning large, unformatted codebases to Prettier.
A file with the following as its first comment will be formatted when --require-pragma is supplied:
/** * @prettier */
or
/** * @format */
DefaultCLI OverrideAPI Overridefalse--require-pragmarequirePragma: <bool>
Insert Pragma‚Äã
First available in v1.8.0
Prettier can insert a special @format marker at the top of files specifying that the file has been formatted with Prettier. This works well when used in tandem with the --require-pragma option. If there is already a docblock at the top of the file then this option will add a newline to it with the @format marker.
Note that ‚Äúin tandem‚Äù doesn‚Äôt mean ‚Äúat the same time‚Äù. When the two options are used simultaneously, --require-pragma has priority, so --insert-pragma is ignored. The idea is that during an incremental adoption of Prettier in a big codebase, the developers participating in the transition process use --insert-pragma whereas --require-pragma is used by the rest of the team and automated tooling to process only files already transitioned. The feature has been inspired by Facebook‚Äôs adoption strategy.
DefaultCLI OverrideAPI Overridefalse--insert-pragmainsertPragma: <bool>
Prose Wrap‚Äã
First available in v1.8.2
By default, Prettier will not change wrapping in markdown text since some services use a linebreak-sensitive renderer, e.g. GitHub comments and BitBucket. To have Prettier wrap prose to the print width, change this option to "always". If you want Prettier to force all prose blocks to be on a single line and rely on editor/viewer soft wrapping instead, you can use "never".
Valid options:

"always" - Wrap prose if it exceeds the print width.
"never" - Un-wrap each block of prose into one line.
"preserve" - Do nothing, leave prose as-is. First available in v1.9.0

DefaultCLI OverrideAPI Override"preserve"--prose-wrap <always|never|preserve>proseWrap: "<always|never|preserve>"
HTML Whitespace Sensitivity‚Äã
First available in v1.15.0. First available for Handlebars in 2.3.0
Specify the global whitespace sensitivity for HTML, Vue, Angular, and Handlebars. See whitespace-sensitive formatting for more info.
Valid options:

"css" - Respect the default value of CSS display property. For Handlebars treated same as strict.
"strict" - Whitespace (or the lack of it) around all tags is considered significant.
"ignore" - Whitespace (or the lack of it) around all tags is considered insignificant.

DefaultCLI OverrideAPI Override"css"--html-whitespace-sensitivity <css|strict|ignore>htmlWhitespaceSensitivity: "<css|strict|ignore>"
Vue files script and style tags indentation‚Äã
First available in v1.19.0
Whether or not to indent the code inside <script> and <style> tags in Vue files.
Valid options:

false - Do not indent script and style tags in Vue files.
true - Indent script and style tags in Vue files.

DefaultCLI OverrideAPI Overridefalse--vue-indent-script-and-stylevueIndentScriptAndStyle: <bool>
End of Line‚Äã
First available in v1.15.0, default value changed from auto to lf in v2.0.0
For historical reasons, there exist two common flavors of line endings in text files.
That is \n (or LF for Line Feed) and \r\n (or CRLF for Carriage Return + Line Feed).
The former is common on Linux and macOS, while the latter is prevalent on Windows.
Some details explaining why it is so can be found on Wikipedia.
When people collaborate on a project from different operating systems, it becomes easy to end up with mixed line endings in a shared git repository.
It is also possible for Windows users to accidentally change line endings in a previously committed file from LF to CRLF.
Doing so produces a large git diff and thus makes the line-by-line history for a file (git blame) harder to explore.
If you want to make sure that your entire git repository only contains Linux-style line endings in files covered by Prettier:

Ensure Prettier‚Äôs endOfLine option is set to lf (this is a default value since v2.0.0)
Configure a pre-commit hook that will run Prettier
Configure Prettier to run in your CI pipeline using --check flag. If you use Travis CI, set the autocrlf option to input in .travis.yml.
Add * text=auto eol=lf to the repo‚Äôs .gitattributes file.
You may need to ask Windows users to re-clone your repo after this change to ensure git has not converted LF to CRLF on checkout.

All modern text editors in all operating systems are able to correctly display line endings when \n (LF) is used.
However, old versions of Notepad for Windows will visually squash such lines into one as they can only deal with \r\n (CRLF).
Valid options:

"lf" ‚Äì Line Feed only (\n), common on Linux and macOS as well as inside git repos
"crlf" - Carriage Return + Line Feed characters (\r\n), common on Windows
"cr" - Carriage Return character only (\r), used very rarely
"auto" - Maintain existing line endings
(mixed values within one file are normalised by looking at what‚Äôs used after the first line)

DefaultCLI OverrideAPI Override"lf"--end-of-line <lf|crlf|cr|auto>endOfLine: "<lf|crlf|cr|auto>"
Setting end_of_line in an .editorconfig file will configure Prettier‚Äôs end of line usage, unless overridden.
Embedded Language Formatting‚Äã
First available in v2.1.0
Control whether Prettier formats quoted code embedded in the file.
When Prettier identifies cases where it looks like you've placed some code it knows how to format within a string in another file, like in a tagged template in JavaScript with a tag named html or in code blocks in Markdown, it will by default try to format that code.
Sometimes this behavior is undesirable, particularly in cases where you might not have intended the string to be interpreted as code. This option allows you to switch between the default behavior (auto) and disabling this feature entirely (off).
Valid options:

"auto" ‚Äì Format embedded code if Prettier can automatically identify it.
"off" - Never automatically format embedded code.

DefaultCLI OverrideAPI Override"auto"--embedded-language-formatting=<off|auto>embeddedLanguageFormatting: "<off|auto>"
Single Attribute Per Line‚Äã
First available in v2.6.0
Enforce single attribute per line in HTML, Vue, and JSX.
Valid options:

false - Do not enforce single attribute per line.
true - Enforce single attribute per line.

DefaultCLI OverrideAPI Overridefalse--single-attribute-per-linesingleAttributePerLine: <bool>Edit this page\n\nOn this pageOptionsPrettier ships with a handful of format options.
To learn more about Prettier‚Äôs stance on options ‚Äì see the Option Philosophy.
If you change any options, it‚Äôs recommended to do it via a configuration file. This way the Prettier CLI, editor integrations and other tooling knows what options you use.
Experimental Ternaries‚Äã
Try prettier's new ternary formatting before it becomes the default behavior.
Valid options:

true - Use curious ternaries, with the question mark after the condition.
false - Retain the default behavior of ternaries; keep question marks on the same line as the consequent.

DefaultCLI OverrideAPI Overridefalse--experimental-ternariesexperimentalTernaries: <bool>
Experimental Operator Position‚Äã
Valid options:

"start" - When binary expressions wrap lines, print operators at the start of new lines.
"end" - Default behavior; when binary expressions wrap lines, print operators at the end of previous lines.

DefaultCLI OverrideAPI Override"end"--experimental-operator-position <start|end>experimentalOperatorPosition: "<start|end>"
Print Width‚Äã
Specify the line length that the printer will wrap on.
warningFor readability we recommend against using more than 80 characters:In code styleguides, maximum line length rules are often set to 100 or 120. However, when humans write code, they don‚Äôt strive to reach the maximum number of columns on every line. Developers often use whitespace to break up long lines for readability. In practice, the average line length often ends up well below the maximum.Prettier‚Äôs printWidth option does not work the same way. It is not the hard upper allowed line length limit. It is a way to say to Prettier roughly how long you‚Äôd like lines to be. Prettier will make both shorter and longer lines, but generally strive to meet the specified printWidth.Remember, computers are dumb. You need to explicitly tell them what to do, while humans can make their own (implicit) judgements, for example on when to break a line.In other words, don‚Äôt try to use printWidth as if it was ESLint‚Äôs max-len ‚Äì they‚Äôre not the same. max-len just says what the maximum allowed line length is, but not what the generally preferred length is ‚Äì which is what printWidth specifies.
DefaultCLI OverrideAPI Override80--print-width <int>printWidth: <int>
Setting max_line_length in an .editorconfig file will configure Prettier‚Äôs print width, unless overridden.
(If you don‚Äôt want line wrapping when formatting Markdown, you can set the Prose Wrap option to disable it.)
Tab Width‚Äã
Specify the number of spaces per indentation-level.
DefaultCLI OverrideAPI Override2--tab-width <int>tabWidth: <int>
Setting indent_size or tab_width in an .editorconfig file will configure Prettier‚Äôs tab width, unless overridden.
Tabs‚Äã
Indent lines with tabs instead of spaces.
DefaultCLI OverrideAPI Overridefalse--use-tabsuseTabs: <bool>
Setting indent_style in an .editorconfig file will configure Prettier‚Äôs tab usage, unless overridden.
(Tabs will be used for indentation but Prettier uses spaces to align things, such as in ternaries. This behavior is known as SmartTabs.)
Semicolons‚Äã
Print semicolons at the ends of statements.
Valid options:

true - Add a semicolon at the end of every statement.
false - Only add semicolons at the beginning of lines that may introduce ASI failures.

DefaultCLI OverrideAPI Overridetrue--no-semisemi: <bool>
Quotes‚Äã
Use single quotes instead of double quotes.
Notes:

JSX quotes ignore this option ‚Äì see jsx-single-quote.
If the number of quotes outweighs the other quote, the quote which is less used will be used to format the string - Example: "I'm double quoted" results in "I'm double quoted" and "This \"example\" is single quoted" results in 'This "example" is single quoted'.

See the strings rationale for more information.
DefaultCLI OverrideAPI Overridefalse--single-quotesingleQuote: <bool>
Quote Props‚Äã
Change when properties in objects are quoted.
Valid options:

"as-needed" - Only add quotes around object properties where required.
"consistent" - If at least one property in an object requires quotes, quote all properties.
"preserve" - Respect the input use of quotes in object properties.

DefaultCLI OverrideAPI Override"as-needed"--quote-props <as-needed|consistent|preserve>quoteProps: "<as-needed|consistent|preserve>"
Note that Prettier never unquotes numeric property names in Angular expressions, TypeScript, and Flow because the distinction between string and numeric keys is significant in these languages. See: Angular, TypeScript, Flow. Also Prettier doesn‚Äôt unquote numeric properties for Vue (see the issue about that).
JSX Quotes‚Äã
Use single quotes instead of double quotes in JSX.
DefaultCLI OverrideAPI Overridefalse--jsx-single-quotejsxSingleQuote: <bool>
Trailing Commas‚Äã
Default value changed from es5 to all in v3.0.0
Print trailing commas wherever possible in multi-line comma-separated syntactic structures. (A single-line array, for example, never gets trailing commas.)
Valid options:

"all" - Trailing commas wherever possible (including function parameters and calls). To run, JavaScript code formatted this way needs an engine that supports ES2017 (Node.js 8+ or a modern browser) or downlevel compilation. This also enables trailing commas in type parameters in TypeScript (supported since TypeScript 2.7 released in January 2018).
"es5" - Trailing commas where valid in ES5 (objects, arrays, etc.). Trailing commas in type parameters in TypeScript and Flow.
"none" - No trailing commas.

DefaultCLI OverrideAPI Override"all"--trailing-comma <all|es5|none>trailingComma: "<all|es5|none>"
Bracket Spacing‚Äã
Print spaces between brackets in object literals.
Valid options:

true - Example: { foo: bar }.
false - Example: {foo: bar}.

DefaultCLI OverrideAPI Overridetrue--no-bracket-spacingbracketSpacing: <bool>
Object Wrap‚Äã
First available in v3.5.0
Configure how Prettier wraps object literals when they could fit on one line or span multiple lines.
By default, Prettier formats objects as multi-line if there is a newline prior to the first property. Authors can use this heuristic to contextually improve readability, though it has some downsides. See Multi-line objects.
Valid options:

"preserve" - Keep as multi-line, if there is a newline between the opening brace and first property.
"collapse" - Fit to a single line when possible.

DefaultCLI OverrideAPI Override"preserve"--object-wrap <preserve|collapse>objectWrap: "<preserve|collapse>"
Bracket Line‚Äã
Put the > of a multi-line HTML (HTML, JSX, Vue, Angular) element at the end of the last line instead of being alone on the next line (does not apply to self closing elements).
Valid options:

true - Example:

<button  className="prettier-class"  id="prettier-id"  onClick={this.handleClick}>  Click Here</button>

false - Example:

<button  className="prettier-class"  id="prettier-id"  onClick={this.handleClick}>  Click Here</button>
DefaultCLI OverrideAPI Overridefalse--bracket-same-linebracketSameLine: <bool>
[Deprecated] JSX Brackets‚Äã
dangerThis option has been deprecated in v2.4.0, use --bracket-same-line instead.
Put the > of a multi-line JSX element at the end of the last line instead of being alone on the next line (does not apply to self closing elements).
Valid options:

true - Example:

<button  className="prettier-class"  id="prettier-id"  onClick={this.handleClick}>  Click Here</button>

false - Example:

<button  className="prettier-class"  id="prettier-id"  onClick={this.handleClick}>  Click Here</button>
DefaultCLI OverrideAPI Overridefalse--jsx-bracket-same-linejsxBracketSameLine: <bool>
Arrow Function Parentheses‚Äã
First available in v1.9.0, default value changed from avoid to always in v2.0.0
Include parentheses around a sole arrow function parameter.
Valid options:

"always" - Always include parens. Example: (x) => x
"avoid" - Omit parens when possible. Example: x => x

DefaultCLI OverrideAPI Override"always"--arrow-parens <always|avoid>arrowParens: "<always|avoid>"
At first glance, avoiding parentheses may look like a better choice because of less visual noise.
However, when Prettier removes parentheses, it becomes harder to add type annotations, extra arguments or default values as well as making other changes.
Consistent use of parentheses provides a better developer experience when editing real codebases, which justifies the default value for the option.
Range‚Äã
Format only a segment of a file.
These two options can be used to format code starting and ending at a given character offset (inclusive and exclusive, respectively). The range will extend:

Backwards to the start of the first line containing the selected statement.
Forwards to the end of the selected statement.

DefaultCLI OverrideAPI Override0--range-start <int>rangeStart: <int>Infinity--range-end <int>rangeEnd: <int>
Parser‚Äã
Specify which parser to use.
Prettier automatically infers the parser from the input file path, so you shouldn‚Äôt have to change this setting.
Both the babel and flow parsers support the same set of JavaScript features (including Flow type annotations). They might differ in some edge cases, so if you run into one of those you can try flow instead of babel. Almost the same applies to typescript and babel-ts. babel-ts might support JavaScript features (proposals) not yet supported by TypeScript, but it‚Äôs less permissive when it comes to invalid code and less battle-tested than the typescript parser.
Valid options:

"babel" (via @babel/parser) Named "babylon" until v1.16.0
"babel-flow" (same as "babel" but enables Flow parsing explicitly to avoid ambiguity) First available in v1.16.0
"babel-ts" (similar to "typescript" but uses Babel and its TypeScript plugin) First available in v2.0.0
"flow" (via flow-parser)
"typescript" (via @typescript-eslint/typescript-estree) First available in v1.4.0
"espree" (via espree) First available in v2.2.0
"meriyah" (via meriyah) First available in v2.2.0
"acorn" (via acorn) First available in v2.6.0
"css" (via postcss) First available in v1.7.1
"scss" (via postcss-scss) First available in v1.7.1
"less" (via postcss-less) First available in v1.7.1
"json" (via @babel/parser parseExpression) First available in v1.5.0
"json5" (same parser as "json", but outputs as json5) First available in v1.13.0
"jsonc" (same parser as "json", but outputs as "JSON with Comments") First available in v3.2.0
"json-stringify" (same parser as "json", but outputs like JSON.stringify) First available in v1.13.0
"graphql" (via graphql/language) First available in v1.5.0
"markdown" (via remark-parse) First available in v1.8.0
"mdx" (via remark-parse and @mdx-js/mdx) First available in v1.15.0
"html" (via angular-html-parser) First available in 1.15.0
"vue" (same parser as "html", but also formats vue-specific syntax) First available in 1.10.0
"angular" (same parser as "html", but also formats angular-specific syntax via angular-estree-parser) First available in 1.15.0
"lwc" (same parser as "html", but also formats LWC-specific syntax for unquoted template attributes) First available in 1.17.0
"yaml" (via yaml and yaml-unist-parser) First available in 1.14.0

DefaultCLI OverrideAPI OverrideNone--parser <string>parser: "<string>"
Note: the default value was "babylon" until v1.13.0.
Note: the Custom parser API has been removed in v3.0.0. Use plugins instead (how to migrate).

File Path‚Äã
Specify the file name to use to infer which parser to use.
For example, the following will use the CSS parser:
cat foo | prettier --stdin-filepath foo.css
This option is only useful in the CLI and API. It doesn‚Äôt make sense to use it in a configuration file.
DefaultCLI OverrideAPI OverrideNone--stdin-filepath <string>filepath: "<string>"
Require Pragma‚Äã
First available in v1.7.0
Prettier can restrict itself to only format files that contain a special comment, called a pragma, at the top of the file. This is very useful when gradually transitioning large, unformatted codebases to Prettier.
A file with the following as its first comment will be formatted when --require-pragma is supplied:
/** * @prettier */
or
/** * @format */
DefaultCLI OverrideAPI Overridefalse--require-pragmarequirePragma: <bool>
Insert Pragma‚Äã
First available in v1.8.0
Prettier can insert a special @format marker at the top of files specifying that the file has been formatted with Prettier. This works well when used in tandem with the --require-pragma option. If there is already a docblock at the top of the file then this option will add a newline to it with the @format marker.
Note that ‚Äúin tandem‚Äù doesn‚Äôt mean ‚Äúat the same time‚Äù. When the two options are used simultaneously, --require-pragma has priority, so --insert-pragma is ignored. The idea is that during an incremental adoption of Prettier in a big codebase, the developers participating in the transition process use --insert-pragma whereas --require-pragma is used by the rest of the team and automated tooling to process only files already transitioned. The feature has been inspired by Facebook‚Äôs adoption strategy.
DefaultCLI OverrideAPI Overridefalse--insert-pragmainsertPragma: <bool>
Prose Wrap‚Äã
First available in v1.8.2
By default, Prettier will not change wrapping in markdown text since some services use a linebreak-sensitive renderer, e.g. GitHub comments and BitBucket. To have Prettier wrap prose to the print width, change this option to "always". If you want Prettier to force all prose blocks to be on a single line and rely on editor/viewer soft wrapping instead, you can use "never".
Valid options:

"always" - Wrap prose if it exceeds the print width.
"never" - Un-wrap each block of prose into one line.
"preserve" - Do nothing, leave prose as-is. First available in v1.9.0

DefaultCLI OverrideAPI Override"preserve"--prose-wrap <always|never|preserve>proseWrap: "<always|never|preserve>"
HTML Whitespace Sensitivity‚Äã
First available in v1.15.0. First available for Handlebars in 2.3.0
Specify the global whitespace sensitivity for HTML, Vue, Angular, and Handlebars. See whitespace-sensitive formatting for more info.
Valid options:

"css" - Respect the default value of CSS display property. For Handlebars treated same as strict.
"strict" - Whitespace (or the lack of it) around all tags is considered significant.
"ignore" - Whitespace (or the lack of it) around all tags is considered insignificant.

DefaultCLI OverrideAPI Override"css"--html-whitespace-sensitivity <css|strict|ignore>htmlWhitespaceSensitivity: "<css|strict|ignore>"
Vue files script and style tags indentation‚Äã
First available in v1.19.0
Whether or not to indent the code inside <script> and <style> tags in Vue files.
Valid options:

false - Do not indent script and style tags in Vue files.
true - Indent script and style tags in Vue files.

DefaultCLI OverrideAPI Overridefalse--vue-indent-script-and-stylevueIndentScriptAndStyle: <bool>
End of Line‚Äã
First available in v1.15.0, default value changed from auto to lf in v2.0.0
For historical reasons, there exist two common flavors of line endings in text files.
That is \n (or LF for Line Feed) and \r\n (or CRLF for Carriage Return + Line Feed).
The former is common on Linux and macOS, while the latter is prevalent on Windows.
Some details explaining why it is so can be found on Wikipedia.
When people collaborate on a project from different operating systems, it becomes easy to end up with mixed line endings in a shared git repository.
It is also possible for Windows users to accidentally change line endings in a previously committed file from LF to CRLF.
Doing so produces a large git diff and thus makes the line-by-line history for a file (git blame) harder to explore.
If you want to make sure that your entire git repository only contains Linux-style line endings in files covered by Prettier:

Ensure Prettier‚Äôs endOfLine option is set to lf (this is a default value since v2.0.0)
Configure a pre-commit hook that will run Prettier
Configure Prettier to run in your CI pipeline using --check flag. If you use Travis CI, set the autocrlf option to input in .travis.yml.
Add * text=auto eol=lf to the repo‚Äôs .gitattributes file.
You may need to ask Windows users to re-clone your repo after this change to ensure git has not converted LF to CRLF on checkout.

All modern text editors in all operating systems are able to correctly display line endings when \n (LF) is used.
However, old versions of Notepad for Windows will visually squash such lines into one as they can only deal with \r\n (CRLF).
Valid options:

"lf" ‚Äì Line Feed only (\n), common on Linux and macOS as well as inside git repos
"crlf" - Carriage Return + Line Feed characters (\r\n), common on Windows
"cr" - Carriage Return character only (\r), used very rarely
"auto" - Maintain existing line endings
(mixed values within one file are normalised by looking at what‚Äôs used after the first line)

DefaultCLI OverrideAPI Override"lf"--end-of-line <lf|crlf|cr|auto>endOfLine: "<lf|crlf|cr|auto>"
Setting end_of_line in an .editorconfig file will configure Prettier‚Äôs end of line usage, unless overridden.
Embedded Language Formatting‚Äã
First available in v2.1.0
Control whether Prettier formats quoted code embedded in the file.
When Prettier identifies cases where it looks like you've placed some code it knows how to format within a string in another file, like in a tagged template in JavaScript with a tag named html or in code blocks in Markdown, it will by default try to format that code.
Sometimes this behavior is undesirable, particularly in cases where you might not have intended the string to be interpreted as code. This option allows you to switch between the default behavior (auto) and disabling this feature entirely (off).
Valid options:

"auto" ‚Äì Format embedded code if Prettier can automatically identify it.
"off" - Never automatically format embedded code.

DefaultCLI OverrideAPI Override"auto"--embedded-language-formatting=<off|auto>embeddedLanguageFormatting: "<off|auto>"
Single Attribute Per Line‚Äã
First available in v2.6.0
Enforce single attribute per line in HTML, Vue, and JSX.
Valid options:

false - Do not enforce single attribute per line.
true - Enforce single attribute per line.

DefaultCLI OverrideAPI Overridefalse--single-attribute-per-linesingleAttributePerLine: <bool>Edit this pagePreviousRun Prettier on CINextConfiguration FileExperimental TernariesExperimental Operator PositionPrint WidthTab WidthTabsSemicolonsQuotesQuote PropsJSX QuotesTrailing CommasBracket SpacingObject WrapBracket Line[Deprecated] JSX BracketsArrow Function ParenthesesRangeParserFile PathRequire PragmaInsert PragmaProse WrapHTML Whitespace SensitivityVue files script and style tags indentationEnd of LineEmbedded Language FormattingSingle Attribute Per Line\n\n\n\nOn this pageConfiguration FileYou can configure Prettier via (in order of precedence):

A "prettier" key in your package.json, or package.yaml file.
A .prettierrc file written in JSON or YAML.
A .prettierrc.json, .prettierrc.yml, .prettierrc.yaml, or .prettierrc.json5 file.
A .prettierrc.js, prettier.config.js, .prettierrc.ts, or prettier.config.ts file that exports an object using export default or module.exports (depends on the type value in your package.json).
A .prettierrc.mjs, prettier.config.mjs, .prettierrc.mts, or prettier.config.mts file that exports an object using export default.
A .prettierrc.cjs, prettier.config.cjs, .prettierrc.cts, or prettier.config.cts file that exports an object using module.exports.
A .prettierrc.toml file.

infoTypeScript configuration files support requires additional setup
The configuration file will be resolved starting from the location of the file being formatted, and searching up the file tree until a config file is (or isn‚Äôt) found.
Prettier intentionally doesn‚Äôt support any kind of global configuration. This is to make sure that when a project is copied to another computer, Prettier‚Äôs behavior stays the same. Otherwise, Prettier wouldn‚Äôt be able to guarantee that everybody in a team gets the same consistent results.
The options you can use in the configuration file are the same as the API options.
TypeScript Configuration Files‚Äã
TypeScript support for Node.js is currently experimental, Node.js>=22.6.0 is required and --experimental-strip-types is required to run Node.js.
node --experimental-strip-types node_modules/prettier/bin/prettier.cjs . --write
or
NODE_OPTIONS="--experimental-strip-types" prettier . --write
Basic Configuration‚Äã
JSON:
{  "trailingComma": "es5",  "tabWidth": 4,  "semi": false,  "singleQuote": true}
JS (ES Modules):
// prettier.config.js, .prettierrc.js, prettier.config.mjs, or .prettierrc.mjs/** * @see https://prettier.io/docs/configuration * @type {import("prettier").Config} */const config = {  trailingComma: "es5",  tabWidth: 4,  semi: false,  singleQuote: true,};export default config;
JS (CommonJS):
// prettier.config.js, .prettierrc.js, prettier.config.cjs, or .prettierrc.cjs/** * @see https://prettier.io/docs/configuration * @type {import("prettier").Config} */const config = {  trailingComma: "es5",  tabWidth: 4,  semi: false,  singleQuote: true,};module.exports = config;
TypeScript (ES Modules):
// prettier.config.ts, .prettierrc.ts, prettier.config.mts, or .prettierrc.mtsimport { type Config } from "prettier";const config: Config = {  trailingComma: "none",};export default config;
TypeScript (CommonJS):
// prettier.config.ts, .prettierrc.ts, prettier.config.cts, or .prettierrc.ctsimport { type Config } from "prettier";const config: Config = {  trailingComma: "none",};module.exports = config;
YAML:
# .prettierrc or .prettierrc.yamltrailingComma: "es5"tabWidth: 4semi: falsesingleQuote: true
TOML:
# .prettierrc.tomltrailingComma = "es5"tabWidth = 4semi = falsesingleQuote = true
Configuration Overrides‚Äã
Overrides let you have different configuration for certain file extensions, folders and specific files.
Prettier borrows ESLint‚Äôs override format.
JSON:
{  "semi": false,  "overrides": [    {      "files": "*.test.js",      "options": {        "semi": true      }    },    {      "files": ["*.html", "legacy/**/*.js"],      "options": {        "tabWidth": 4      }    }  ]}
YAML:
semi: falseoverrides:  - files: "*.test.js"    options:      semi: true  - files:      - "*.html"      - "legacy/**/*.js"    options:      tabWidth: 4
files is required for each override, and may be a string or array of strings. excludeFiles may be optionally provided to exclude files for a given rule, and may also be a string or array of strings.
Setting the parser option‚Äã
By default, Prettier automatically infers which parser to use based on the input file extension. Combined with overrides you can teach Prettier how to parse files it does not recognize.
For example, to get Prettier to format its own .prettierrc file, you can do:
{  "overrides": [    {      "files": ".prettierrc",      "options": { "parser": "json" }    }  ]}
You can also switch to the flow parser instead of the default babel for .js files:
{  "overrides": [    {      "files": "*.js",      "options": {        "parser": "flow"      }    }  ]}
Note: Never put the parser option at the top level of your configuration. Only use it inside overrides. Otherwise you effectively disable Prettier‚Äôs automatic file extension based parser inference. This forces Prettier to use the parser you specified for all types of files ‚Äì even when it doesn‚Äôt make sense, such as trying to parse a CSS file as JavaScript.
Configuration Schema‚Äã
If you‚Äôd like a JSON schema to validate your configuration, one is available here: https://json.schemastore.org/prettierrc.
EditorConfig‚Äã
If a .editorconfig file is in your project, Prettier will parse it and convert its properties to the corresponding Prettier configuration. This configuration will be overridden by .prettierrc, etc.
Here‚Äôs an annotated description of how different properties map to Prettier‚Äôs behavior:
# Stop the editor from looking for .editorconfig files in the parent directories# root = true[*]# Non-configurable Prettier behaviorscharset = utf-8insert_final_newline = true# Caveat: Prettier won‚Äôt trim trailing whitespace inside template strings, but your editor might.# trim_trailing_whitespace = true# Configurable Prettier behaviors# (change these if your Prettier config differs)end_of_line = lfindent_style = spaceindent_size = 2max_line_length = 80
Here‚Äôs a copy+paste-ready .editorconfig file if you use the default options:
[*]charset = utf-8insert_final_newline = trueend_of_line = lfindent_style = spaceindent_size = 2max_line_length = 80Edit this page\n\nOn this pageConfiguration FileYou can configure Prettier via (in order of precedence):

A "prettier" key in your package.json, or package.yaml file.
A .prettierrc file written in JSON or YAML.
A .prettierrc.json, .prettierrc.yml, .prettierrc.yaml, or .prettierrc.json5 file.
A .prettierrc.js, prettier.config.js, .prettierrc.ts, or prettier.config.ts file that exports an object using export default or module.exports (depends on the type value in your package.json).
A .prettierrc.mjs, prettier.config.mjs, .prettierrc.mts, or prettier.config.mts file that exports an object using export default.
A .prettierrc.cjs, prettier.config.cjs, .prettierrc.cts, or prettier.config.cts file that exports an object using module.exports.
A .prettierrc.toml file.

infoTypeScript configuration files support requires additional setup
The configuration file will be resolved starting from the location of the file being formatted, and searching up the file tree until a config file is (or isn‚Äôt) found.
Prettier intentionally doesn‚Äôt support any kind of global configuration. This is to make sure that when a project is copied to another computer, Prettier‚Äôs behavior stays the same. Otherwise, Prettier wouldn‚Äôt be able to guarantee that everybody in a team gets the same consistent results.
The options you can use in the configuration file are the same as the API options.
TypeScript Configuration Files‚Äã
TypeScript support for Node.js is currently experimental, Node.js>=22.6.0 is required and --experimental-strip-types is required to run Node.js.
node --experimental-strip-types node_modules/prettier/bin/prettier.cjs . --write
or
NODE_OPTIONS="--experimental-strip-types" prettier . --write
Basic Configuration‚Äã
JSON:
{  "trailingComma": "es5",  "tabWidth": 4,  "semi": false,  "singleQuote": true}
JS (ES Modules):
// prettier.config.js, .prettierrc.js, prettier.config.mjs, or .prettierrc.mjs/** * @see https://prettier.io/docs/configuration * @type {import("prettier").Config} */const config = {  trailingComma: "es5",  tabWidth: 4,  semi: false,  singleQuote: true,};export default config;
JS (CommonJS):
// prettier.config.js, .prettierrc.js, prettier.config.cjs, or .prettierrc.cjs/** * @see https://prettier.io/docs/configuration * @type {import("prettier").Config} */const config = {  trailingComma: "es5",  tabWidth: 4,  semi: false,  singleQuote: true,};module.exports = config;
TypeScript (ES Modules):
// prettier.config.ts, .prettierrc.ts, prettier.config.mts, or .prettierrc.mtsimport { type Config } from "prettier";const config: Config = {  trailingComma: "none",};export default config;
TypeScript (CommonJS):
// prettier.config.ts, .prettierrc.ts, prettier.config.cts, or .prettierrc.ctsimport { type Config } from "prettier";const config: Config = {  trailingComma: "none",};module.exports = config;
YAML:
# .prettierrc or .prettierrc.yamltrailingComma: "es5"tabWidth: 4semi: falsesingleQuote: true
TOML:
# .prettierrc.tomltrailingComma = "es5"tabWidth = 4semi = falsesingleQuote = true
Configuration Overrides‚Äã
Overrides let you have different configuration for certain file extensions, folders and specific files.
Prettier borrows ESLint‚Äôs override format.
JSON:
{  "semi": false,  "overrides": [    {      "files": "*.test.js",      "options": {        "semi": true      }    },    {      "files": ["*.html", "legacy/**/*.js"],      "options": {        "tabWidth": 4      }    }  ]}
YAML:
semi: falseoverrides:  - files: "*.test.js"    options:      semi: true  - files:      - "*.html"      - "legacy/**/*.js"    options:      tabWidth: 4
files is required for each override, and may be a string or array of strings. excludeFiles may be optionally provided to exclude files for a given rule, and may also be a string or array of strings.
Setting the parser option‚Äã
By default, Prettier automatically infers which parser to use based on the input file extension. Combined with overrides you can teach Prettier how to parse files it does not recognize.
For example, to get Prettier to format its own .prettierrc file, you can do:
{  "overrides": [    {      "files": ".prettierrc",      "options": { "parser": "json" }    }  ]}
You can also switch to the flow parser instead of the default babel for .js files:
{  "overrides": [    {      "files": "*.js",      "options": {        "parser": "flow"      }    }  ]}
Note: Never put the parser option at the top level of your configuration. Only use it inside overrides. Otherwise you effectively disable Prettier‚Äôs automatic file extension based parser inference. This forces Prettier to use the parser you specified for all types of files ‚Äì even when it doesn‚Äôt make sense, such as trying to parse a CSS file as JavaScript.
Configuration Schema‚Äã
If you‚Äôd like a JSON schema to validate your configuration, one is available here: https://json.schemastore.org/prettierrc.
EditorConfig‚Äã
If a .editorconfig file is in your project, Prettier will parse it and convert its properties to the corresponding Prettier configuration. This configuration will be overridden by .prettierrc, etc.
Here‚Äôs an annotated description of how different properties map to Prettier‚Äôs behavior:
# Stop the editor from looking for .editorconfig files in the parent directories# root = true[*]# Non-configurable Prettier behaviorscharset = utf-8insert_final_newline = true# Caveat: Prettier won‚Äôt trim trailing whitespace inside template strings, but your editor might.# trim_trailing_whitespace = true# Configurable Prettier behaviors# (change these if your Prettier config differs)end_of_line = lfindent_style = spaceindent_size = 2max_line_length = 80
Here‚Äôs a copy+paste-ready .editorconfig file if you use the default options:
[*]charset = utf-8insert_final_newline = trueend_of_line = lfindent_style = spaceindent_size = 2max_line_length = 80Edit this pagePreviousOptionsNextSharing configurationsTypeScript Configuration FilesBasic ConfigurationConfiguration OverridesSetting the parser optionConfiguration SchemaEditorConfig\n\n\n\nOn this pageSharing configurationsIn case you have many different projects, it can be helpful to have a shared configuration which can be used in all of them, instead of copy-pasting the same config for every project.
This page explains how to create, publish and consume a shareable config.
Creating a Shareable Config‚Äã
Sharable configs are just npm packages that export a single prettier config file.
Before we start, make sure you have:

An account for npmjs.com to publish the package
Basic understating about how to create a Node.js module

First, create a new package. We recommend creating a scoped package with the name @username/prettier-config.
A minimal package should have at least two files. A package.json for the package configuration and an index.js which holds the shared prettier configuration object:
prettier-config/‚îú‚îÄ‚îÄ index.js‚îî‚îÄ‚îÄ package.json
Example package.json:
{  "name": "@username/prettier-config",  "version": "1.0.0",  "description": "My personal Prettier config",  "type": "module",  "exports": "./index.js",  "license": "MIT",  "publishConfig": {    "access": "public"  },  "peerDependencies": {    "prettier": ">=3.0.0"  }}
index.js is where you put the shared configuration. This file just exports a regular prettier configuration with the same syntax and same options:
const config = {  trailingComma: "es5",  tabWidth: 4,  singleQuote: true,};export default config;
An example shared configuration repository is available here.
Publishing a Shareable Config‚Äã
Once you are ready, you can publish your package to npm:
npm publish
Using a Shareable Config‚Äã
You first need to install your published configuration, for example:
npmyarnpnpmbunnpm install --save-dev @username/prettier-configyarn add --dev @username/prettier-configpnpm add --save-dev @username/prettier-configbun add --dev @username/prettier-config
Then, you can reference it in your package.json:
{  "name": "my-cool-library",  "version": "1.0.0",  "prettier": "@username/prettier-config"}
If you don‚Äôt want to use package.json, you can use any of the supported extensions to export a string, e.g. .prettierrc:
"@company/prettier-config"
Extending a Sharable Config‚Äã
To extend the configuration to overwrite some properties from the shared configuration, import the file in a .prettierrc.mjs file and export the modifications, e.g:
import usernamePrettierConfig from "@username/prettier-config";/** * @type {import("prettier").Config} */const config = {  ...usernamePrettierConfig,  semi: false,};export default config;
Other examples‚Äã
Using Type Annotation in the Shared Config‚Äã
You can get type safety and autocomplete support in your shared configuration by using a jsdoc type annotation:
/** * @type {import("prettier").Config} */const config = {  trailingComma: "es5",  tabWidth: 4,  semi: false,  singleQuote: true,};export default config;
In order to make this work, you have to install prettier for the project.
After that, your package.json file should look like this:
{  "name": "@username/prettier-config",  "version": "1.0.0",  "description": "My personal Prettier config",  "type": "module",  "exports": "./index.js",  "license": "MIT",  "publishConfig": {    "access": "public"  },  "peerDependencies": {    "prettier": ">=3.0.0"  },+ "devDependencies": {+   "prettier": "^3.3.3"+ }}
Include Plugins in Shareable Configurations‚Äã
In case you want to use plugins in your shared configuration, you need to declare those plugins in the config file's plugin array and as dependencies in package.json:
// index.jsconst config = {  singleQuote: true,  plugins: ["prettier-plugin-xml"],};export default config;
// package.json{  "name": "@username/prettier-config",  "version": "1.0.0",  "description": "My personal Prettier config",  "type": "module",  "exports": "./index.js",  "license": "MIT",  "publishConfig": {    "access": "public"  },+  "dependencies": {+    "prettier-plugin-xml": "3.4.1"+  },  "peerDependencies": {    "prettier": ">=3.0.0"  }}
An example repository can be found here
Note: You can use peerDependencies instead of dependencies. To learn about their differences, you can read this blog post from Domenic Denicola about peer dependenciesEdit this page\n\nOn this pageSharing configurationsIn case you have many different projects, it can be helpful to have a shared configuration which can be used in all of them, instead of copy-pasting the same config for every project.
This page explains how to create, publish and consume a shareable config.
Creating a Shareable Config‚Äã
Sharable configs are just npm packages that export a single prettier config file.
Before we start, make sure you have:

An account for npmjs.com to publish the package
Basic understating about how to create a Node.js module

First, create a new package. We recommend creating a scoped package with the name @username/prettier-config.
A minimal package should have at least two files. A package.json for the package configuration and an index.js which holds the shared prettier configuration object:
prettier-config/‚îú‚îÄ‚îÄ index.js‚îî‚îÄ‚îÄ package.json
Example package.json:
{  "name": "@username/prettier-config",  "version": "1.0.0",  "description": "My personal Prettier config",  "type": "module",  "exports": "./index.js",  "license": "MIT",  "publishConfig": {    "access": "public"  },  "peerDependencies": {    "prettier": ">=3.0.0"  }}
index.js is where you put the shared configuration. This file just exports a regular prettier configuration with the same syntax and same options:
const config = {  trailingComma: "es5",  tabWidth: 4,  singleQuote: true,};export default config;
An example shared configuration repository is available here.
Publishing a Shareable Config‚Äã
Once you are ready, you can publish your package to npm:
npm publish
Using a Shareable Config‚Äã
You first need to install your published configuration, for example:
npmyarnpnpmbunnpm install --save-dev @username/prettier-configyarn add --dev @username/prettier-configpnpm add --save-dev @username/prettier-configbun add --dev @username/prettier-config
Then, you can reference it in your package.json:
{  "name": "my-cool-library",  "version": "1.0.0",  "prettier": "@username/prettier-config"}
If you don‚Äôt want to use package.json, you can use any of the supported extensions to export a string, e.g. .prettierrc:
"@company/prettier-config"
Extending a Sharable Config‚Äã
To extend the configuration to overwrite some properties from the shared configuration, import the file in a .prettierrc.mjs file and export the modifications, e.g:
import usernamePrettierConfig from "@username/prettier-config";/** * @type {import("prettier").Config} */const config = {  ...usernamePrettierConfig,  semi: false,};export default config;
Other examples‚Äã
Using Type Annotation in the Shared Config‚Äã
You can get type safety and autocomplete support in your shared configuration by using a jsdoc type annotation:
/** * @type {import("prettier").Config} */const config = {  trailingComma: "es5",  tabWidth: 4,  semi: false,  singleQuote: true,};export default config;
In order to make this work, you have to install prettier for the project.
After that, your package.json file should look like this:
{  "name": "@username/prettier-config",  "version": "1.0.0",  "description": "My personal Prettier config",  "type": "module",  "exports": "./index.js",  "license": "MIT",  "publishConfig": {    "access": "public"  },  "peerDependencies": {    "prettier": ">=3.0.0"  },+ "devDependencies": {+   "prettier": "^3.3.3"+ }}
Include Plugins in Shareable Configurations‚Äã
In case you want to use plugins in your shared configuration, you need to declare those plugins in the config file's plugin array and as dependencies in package.json:
// index.jsconst config = {  singleQuote: true,  plugins: ["prettier-plugin-xml"],};export default config;
// package.json{  "name": "@username/prettier-config",  "version": "1.0.0",  "description": "My personal Prettier config",  "type": "module",  "exports": "./index.js",  "license": "MIT",  "publishConfig": {    "access": "public"  },+  "dependencies": {+    "prettier-plugin-xml": "3.4.1"+  },  "peerDependencies": {    "prettier": ">=3.0.0"  }}
An example repository can be found here
Note: You can use peerDependencies instead of dependencies. To learn about their differences, you can read this blog post from Domenic Denicola about peer dependenciesEdit this pagePreviousConfiguration FileNextEditor IntegrationCreating a Shareable ConfigPublishing a Shareable ConfigUsing a Shareable ConfigExtending a Sharable ConfigOther examplesUsing Type Annotation in the Shared ConfigInclude Plugins in Shareable Configurations\n\n\n\nOn this pageEditor IntegrationTo get the most out of Prettier, it‚Äôs recommended to run it from your editor.
If your editor does not support Prettier, you can instead run Prettier with a file watcher.
Note! It‚Äôs important to install Prettier locally in every project, so each project gets the correct Prettier version.
Visual Studio Code‚Äã
prettier-vscode can be installed using the extension sidebar ‚Äì it‚Äôs called ‚ÄúPrettier - Code formatter.‚Äù Check its repository for configuration and shortcuts.
If you‚Äôd like to toggle the formatter on and off, install vscode-status-bar-format-toggle.
Emacs‚Äã
Check out the prettier-emacs repo, or prettier.el. The package Apheleia supports multiple code formatters, including Prettier.
Vim‚Äã
vim-prettier is a Prettier-specific Vim plugin. Neoformat, ALE, and coc-prettier are multi-language Vim linter/formatter plugins that support Prettier.
For more details see the Vim setup guide.
Helix‚Äã
A formatter can be specified in your Helix language configuration, which will take precedence over any language servers.
For more details see the Helix external binary formatter configuration for Prettier.
Sublime Text‚Äã
Sublime Text support is available through Package Control and the JsPrettier plug-in.
JetBrains WebStorm, PHPStorm, PyCharm...‚Äã
See the WebStorm setup guide.
Visual Studio‚Äã
Install the JavaScript Prettier extension.
Espresso‚Äã
Espresso users can install the espresso-prettier plugin.Edit this page\n\nOn this pageEditor IntegrationTo get the most out of Prettier, it‚Äôs recommended to run it from your editor.
If your editor does not support Prettier, you can instead run Prettier with a file watcher.
Note! It‚Äôs important to install Prettier locally in every project, so each project gets the correct Prettier version.
Visual Studio Code‚Äã
prettier-vscode can be installed using the extension sidebar ‚Äì it‚Äôs called ‚ÄúPrettier - Code formatter.‚Äù Check its repository for configuration and shortcuts.
If you‚Äôd like to toggle the formatter on and off, install vscode-status-bar-format-toggle.
Emacs‚Äã
Check out the prettier-emacs repo, or prettier.el. The package Apheleia supports multiple code formatters, including Prettier.
Vim‚Äã
vim-prettier is a Prettier-specific Vim plugin. Neoformat, ALE, and coc-prettier are multi-language Vim linter/formatter plugins that support Prettier.
For more details see the Vim setup guide.
Helix‚Äã
A formatter can be specified in your Helix language configuration, which will take precedence over any language servers.
For more details see the Helix external binary formatter configuration for Prettier.
Sublime Text‚Äã
Sublime Text support is available through Package Control and the JsPrettier plug-in.
JetBrains WebStorm, PHPStorm, PyCharm...‚Äã
See the WebStorm setup guide.
Visual Studio‚Äã
Install the JavaScript Prettier extension.
Espresso‚Äã
Espresso users can install the espresso-prettier plugin.Edit this pagePreviousSharing configurationsNextWebStorm SetupVisual Studio CodeEmacsVimHelixSublime TextJetBrains WebStorm, PHPStorm, PyCharm...Visual StudioEspresso\n\n\n\nOn this pageWebStorm SetupJetBrains IDEs (WebStorm, IntelliJ IDEA, PyCharm, etc.)‚Äã
WebStorm comes with built-in support for Prettier. If you‚Äôre using other JetBrains IDE like IntelliJ IDEA, PhpStorm, or PyCharm, make sure you have this plugin installed and enabled in Preferences / Settings | Plugins.
First, you need to install and configure Prettier. You can find instructions on how to do it here.
Once it‚Äôs done, you can do a few things in your IDE. You can use the Reformat with Prettier action (Opt+Shift+Cmd+P on macOS or Alt+Shift+Ctrl+P on Windows and Linux) to format the selected code, a file, or a whole directory.
You can also configure WebStorm to run Prettier on save (Cmd+S/Ctrl+S) or use it as the default formatter (Opt+Cmd+L/Ctrl+Alt+L). For this, open Preferences / Settings | Languages & Frameworks | JavaScript | Prettier and tick the corresponding checkbox: On save and/or On ‚ÄòReformat Code‚Äô action.

By default, WebStorm will apply formatting to all .js, .ts, .jsx, and .tsx files that you‚Äôve edited in your project. To apply the formatting to other file types, or to limit formatting to files located only in specific directories, you can customize the default configuration by using glob patterns.
For more information, see WebStorm online help.Edit this page\n\nOn this pageWebStorm SetupJetBrains IDEs (WebStorm, IntelliJ IDEA, PyCharm, etc.)‚Äã
WebStorm comes with built-in support for Prettier. If you‚Äôre using other JetBrains IDE like IntelliJ IDEA, PhpStorm, or PyCharm, make sure you have this plugin installed and enabled in Preferences / Settings | Plugins.
First, you need to install and configure Prettier. You can find instructions on how to do it here.
Once it‚Äôs done, you can do a few things in your IDE. You can use the Reformat with Prettier action (Opt+Shift+Cmd+P on macOS or Alt+Shift+Ctrl+P on Windows and Linux) to format the selected code, a file, or a whole directory.
You can also configure WebStorm to run Prettier on save (Cmd+S/Ctrl+S) or use it as the default formatter (Opt+Cmd+L/Ctrl+Alt+L). For this, open Preferences / Settings | Languages & Frameworks | JavaScript | Prettier and tick the corresponding checkbox: On save and/or On ‚ÄòReformat Code‚Äô action.

By default, WebStorm will apply formatting to all .js, .ts, .jsx, and .tsx files that you‚Äôve edited in your project. To apply the formatting to other file types, or to limit formatting to files located only in specific directories, you can customize the default configuration by using glob patterns.
For more information, see WebStorm online help.Edit this pagePreviousEditor IntegrationNextVim SetupJetBrains IDEs (WebStorm, IntelliJ IDEA, PyCharm, etc.)\n\n\n\nOn this pageVim SetupVim users can install either vim-prettier, which is Prettier specific, or Neoformat or ALE which are generalized lint/format engines with support for Prettier.
vim-prettier‚Äã
See the vim-prettier readme for installation and usage instructions.
Neoformat‚Äã
The best way to install Neoformat is with your favorite plugin manager for Vim, such as vim-plug:
Plug 'sbdchd/neoformat'
In order for Neoformat to use a project-local version of Prettier (i.e. to use node_modules/.bin/prettier instead of looking for prettier on $PATH), you must set the neoformat_try_node_exe option:
let g:neoformat_try_node_exe = 1
Run :Neoformat or :Neoformat prettier in a supported file to run Prettier.
To have Neoformat run Prettier on save:
autocmd BufWritePre *.js Neoformat
You can also make Vim format your code more frequently, by setting an autocmd for other events. Here are a couple of useful ones:

TextChanged: after a change was made to the text in Normal mode
InsertLeave: when leaving Insert mode

For example, you can format on both of the above events together with BufWritePre like this:
autocmd BufWritePre,TextChanged,InsertLeave *.js Neoformat
See :help autocmd-events in Vim for details.
It‚Äôs recommended to use a config file, but you can also add options in your .vimrc:
autocmd FileType javascript setlocal formatprg=prettier\ --single-quote\ --trailing-comma\ es5" Use formatprg when availablelet g:neoformat_try_formatprg = 1
Each space in Prettier options should be escaped with \.
ALE‚Äã
ALE requires either Vim 8 or Neovim as ALE makes use of the asynchronous abilities that both Vim 8 and Neovim provide.
The best way to install ALE is with your favorite plugin manager for Vim, such as vim-plug:
Plug 'dense-analysis/ale'
You can find further instructions on the ALE repository.
ALE will try to use Prettier installed locally before looking for a global installation.
Enable the Prettier fixer for the languages you use:
let g:ale_fixers = {\   'javascript': ['prettier'],\   'css': ['prettier'],\}
ALE supports both linters and fixers. If you don‚Äôt specify which linters to run, all available tools for all supported languages will be run, and you might get a correctly formatted file with a bunch of lint errors. To disable this behavior you can tell ALE to run only linters you've explicitly configured (more info in the FAQ):
let g:ale_linters_explicit = 1
You can then run :ALEFix in a JavaScript or CSS file to run Prettier.
To have ALE run Prettier on save:
let g:ale_fix_on_save = 1
It‚Äôs recommended to use a config file, but you can also add options in your .vimrc:
let g:ale_javascript_prettier_options = '--single-quote --trailing-comma all'
coc-prettier‚Äã
Prettier extension for coc.nvim which requires neovim or vim8.1.
Install coc.nvim with your favorite plugin manager, such as vim-plug:
Plug 'neoclide/coc.nvim', {'branch': 'release'}
And install coc-prettier by command:
CocInstall coc-prettier
Setup Prettier command in your init.vim or .vimrc
command! -nargs=0 Prettier :call CocAction('runCommand', 'prettier.formatFile')
Update your coc-settings.json for languages that you want format on save.
{  "coc.preferences.formatOnSaveFiletypes": ["css", "markdown"]}
coc-prettier have same configurations of prettier-vscode, open coc-settings.json by :CocConfig to get autocompletion support.
Running manually‚Äã
If you want something really bare-bones, you can create a custom key binding. In this example, gp (mnemonic: "get pretty") is used to run prettier (with options) in the currently active buffer:
nnoremap gp :silent %!prettier --stdin-filepath %<CR>
Note that if there‚Äôs a syntax error in your code, the whole buffer will be replaced with an error message. You‚Äôll need to press u to get your code back.
Another disadvantage of this approach is that the cursor position won‚Äôt be preserved.Edit this page\n\nOn this pageVim SetupVim users can install either vim-prettier, which is Prettier specific, or Neoformat or ALE which are generalized lint/format engines with support for Prettier.
vim-prettier‚Äã
See the vim-prettier readme for installation and usage instructions.
Neoformat‚Äã
The best way to install Neoformat is with your favorite plugin manager for Vim, such as vim-plug:
Plug 'sbdchd/neoformat'
In order for Neoformat to use a project-local version of Prettier (i.e. to use node_modules/.bin/prettier instead of looking for prettier on $PATH), you must set the neoformat_try_node_exe option:
let g:neoformat_try_node_exe = 1
Run :Neoformat or :Neoformat prettier in a supported file to run Prettier.
To have Neoformat run Prettier on save:
autocmd BufWritePre *.js Neoformat
You can also make Vim format your code more frequently, by setting an autocmd for other events. Here are a couple of useful ones:

TextChanged: after a change was made to the text in Normal mode
InsertLeave: when leaving Insert mode

For example, you can format on both of the above events together with BufWritePre like this:
autocmd BufWritePre,TextChanged,InsertLeave *.js Neoformat
See :help autocmd-events in Vim for details.
It‚Äôs recommended to use a config file, but you can also add options in your .vimrc:
autocmd FileType javascript setlocal formatprg=prettier\ --single-quote\ --trailing-comma\ es5" Use formatprg when availablelet g:neoformat_try_formatprg = 1
Each space in Prettier options should be escaped with \.
ALE‚Äã
ALE requires either Vim 8 or Neovim as ALE makes use of the asynchronous abilities that both Vim 8 and Neovim provide.
The best way to install ALE is with your favorite plugin manager for Vim, such as vim-plug:
Plug 'dense-analysis/ale'
You can find further instructions on the ALE repository.
ALE will try to use Prettier installed locally before looking for a global installation.
Enable the Prettier fixer for the languages you use:
let g:ale_fixers = {\   'javascript': ['prettier'],\   'css': ['prettier'],\}
ALE supports both linters and fixers. If you don‚Äôt specify which linters to run, all available tools for all supported languages will be run, and you might get a correctly formatted file with a bunch of lint errors. To disable this behavior you can tell ALE to run only linters you've explicitly configured (more info in the FAQ):
let g:ale_linters_explicit = 1
You can then run :ALEFix in a JavaScript or CSS file to run Prettier.
To have ALE run Prettier on save:
let g:ale_fix_on_save = 1
It‚Äôs recommended to use a config file, but you can also add options in your .vimrc:
let g:ale_javascript_prettier_options = '--single-quote --trailing-comma all'
coc-prettier‚Äã
Prettier extension for coc.nvim which requires neovim or vim8.1.
Install coc.nvim with your favorite plugin manager, such as vim-plug:
Plug 'neoclide/coc.nvim', {'branch': 'release'}
And install coc-prettier by command:
CocInstall coc-prettier
Setup Prettier command in your init.vim or .vimrc
command! -nargs=0 Prettier :call CocAction('runCommand', 'prettier.formatFile')
Update your coc-settings.json for languages that you want format on save.
{  "coc.preferences.formatOnSaveFiletypes": ["css", "markdown"]}
coc-prettier have same configurations of prettier-vscode, open coc-settings.json by :CocConfig to get autocompletion support.
Running manually‚Äã
If you want something really bare-bones, you can create a custom key binding. In this example, gp (mnemonic: "get pretty") is used to run prettier (with options) in the currently active buffer:
nnoremap gp :silent %!prettier --stdin-filepath %<CR>
Note that if there‚Äôs a syntax error in your code, the whole buffer will be replaced with an error message. You‚Äôll need to press u to get your code back.
Another disadvantage of this approach is that the cursor position won‚Äôt be preserved.Edit this pagePreviousWebStorm SetupNextWatching For Changesvim-prettierNeoformatALEcoc-prettierRunning manually\n\n\n\nWatching For ChangesYou can have Prettier watch for changes from the command line by using onchange. For example:
npx onchange "**/*" -- npx prettier --write --ignore-unknown {{changed}}
Or add the following to your package.json:
{  "scripts": {    "prettier-watch": "onchange \"**/*\" -- prettier --write --ignore-unknown {{changed}}"  }}Edit this page\n\nWatching For ChangesYou can have Prettier watch for changes from the command line by using onchange. For example:
npx onchange "**/*" -- npx prettier --write --ignore-unknown {{changed}}
Or add the following to your package.json:
{  "scripts": {    "prettier-watch": "onchange \"**/*\" -- prettier --write --ignore-unknown {{changed}}"  }}Edit this pagePreviousVim SetupNextTechnical Details\n\n\n\nTechnical DetailsThis printer is a fork of recast‚Äôs printer with its algorithm replaced by the one described by Wadler in "A prettier printer". There still may be leftover code from recast that needs to be cleaned up.
The basic idea is that the printer takes an AST and returns an intermediate representation of the output, and the printer uses that to generate a string. The advantage is that the printer can "measure" the IR and see if the output is going to fit on a line, and break if not.
This means that most of the logic of printing an AST involves generating an abstract representation of the output involving certain commands. For example, ["(", line, arg, line, ")"] would represent a concatenation of opening parens, an argument, and closing parens. But if that doesn‚Äôt fit on one line, the printer can break where line is specified.
The Playground has a special mode for exploring how Prettier‚Äôs intermediate representation is printed. To get there, open the sidebar (the "Show options" button) and set the parser option to the special value doc-explorer.
More (rough) details can be found in commands.md.Edit this page\n\nTechnical DetailsThis printer is a fork of recast‚Äôs printer with its algorithm replaced by the one described by Wadler in "A prettier printer". There still may be leftover code from recast that needs to be cleaned up.
The basic idea is that the printer takes an AST and returns an intermediate representation of the output, and the printer uses that to generate a string. The advantage is that the printer can "measure" the IR and see if the output is going to fit on a line, and break if not.
This means that most of the logic of printing an AST involves generating an abstract representation of the output involving certain commands. For example, ["(", line, arg, line, ")"] would represent a concatenation of opening parens, an argument, and closing parens. But if that doesn‚Äôt fit on one line, the printer can break where line is specified.
The Playground has a special mode for exploring how Prettier‚Äôs intermediate representation is printed. To get there, open the sidebar (the "Show options" button) and set the parser option to the special value doc-explorer.
More (rough) details can be found in commands.md.Edit this pagePreviousWatching For ChangesNextRelated Projects\n\n\n\nOn this pageRelated ProjectsESLint Integrations‚Äã

eslint-config-prettier turns off all ESLint rules that are unnecessary or might conflict with Prettier
eslint-plugin-prettier runs Prettier as an ESLint rule and reports differences as individual ESLint issues
prettier-eslint passes prettier output to eslint --fix
prettier-standard uses prettierx and prettier-eslint to format code with standard rules

stylelint Integrations‚Äã

stylelint-config-prettier turns off all rules that are unnecessary or might conflict with Prettier.
stylelint-prettier runs Prettier as a stylelint rule and reports differences as individual stylelint issues
prettier-stylelint passes prettier output to stylelint --fix

Forks‚Äã

prettierx less opinionated fork of Prettier

Misc‚Äã

parallel-prettier is an alternative CLI that formats files in parallel to speed up large projects
prettier_d runs Prettier as a server to avoid Node.js startup delay
pretty-quick formats changed files with Prettier
rollup-plugin-prettier allows you to use Prettier with Rollup
jest-runner-prettier is Prettier as a Jest runner
prettier-chrome is an extension that runs Prettier in the browser
spotless lets you run prettier from gradle or maven.
csharpier is a port of Prettier for C#
reviewdog-action-prettier runs Prettier in GitHub Actions CI/CD workflows
Edit this page\n\nOn this pageRelated ProjectsESLint Integrations‚Äã

eslint-config-prettier turns off all ESLint rules that are unnecessary or might conflict with Prettier
eslint-plugin-prettier runs Prettier as an ESLint rule and reports differences as individual ESLint issues
prettier-eslint passes prettier output to eslint --fix
prettier-standard uses prettierx and prettier-eslint to format code with standard rules

stylelint Integrations‚Äã

stylelint-config-prettier turns off all rules that are unnecessary or might conflict with Prettier.
stylelint-prettier runs Prettier as a stylelint rule and reports differences as individual stylelint issues
prettier-stylelint passes prettier output to stylelint --fix

Forks‚Äã

prettierx less opinionated fork of Prettier

Misc‚Äã

parallel-prettier is an alternative CLI that formats files in parallel to speed up large projects
prettier_d runs Prettier as a server to avoid Node.js startup delay
pretty-quick formats changed files with Prettier
rollup-plugin-prettier allows you to use Prettier with Rollup
jest-runner-prettier is Prettier as a Jest runner
prettier-chrome is an extension that runs Prettier in the browser
spotless lets you run prettier from gradle or maven.
csharpier is a port of Prettier for C#
reviewdog-action-prettier runs Prettier in GitHub Actions CI/CD workflows
Edit this pagePreviousTechnical DetailsNextFor EnterpriseESLint Integrationsstylelint IntegrationsForksMisc\n\n\n\nOn this pageFor EnterpriseAvailable as part of the Tidelift Subscription‚Äã
Tidelift is working with the maintainers of Prettier and thousands of other open source projects to deliver commercial support and maintenance for the open source dependencies you use to build your applications. Save time, reduce risk, and improve code health, while paying the maintainers of the exact dependencies you use.
Learn more
Request a demo

Enterprise-ready open source software‚Äîmanaged for you‚Äã
The Tidelift Subscription is a managed open source subscription for application dependencies covering millions of open source projects across JavaScript, Python, Java, PHP, Ruby, .NET, and more.
Your subscription includes:
Security updates
Tidelift‚Äôs security response team coordinates patches for new breaking security vulnerabilities and alerts immediately through a private channel, so your software supply chain is always secure.
Licensing verification and indemnification
Tidelift verifies license information to enable easy policy enforcement and adds intellectual property indemnification to cover creators and users in case something goes wrong. You always have a 100% up-to-date bill of materials for your dependencies to share with your legal team, customers, or partners.
Maintenance and code improvement
Tidelift ensures the software you rely on keeps working as long as you need it to work. Your managed dependencies are actively maintained and we recruit additional maintainers where required.
Package selection and version guidance
We help you choose the best open source packages from the start‚Äîand then guide you through updates to stay on the best releases as new issues arise.
Roadmap input
Take a seat at the table with the creators behind the software you use. Tidelift‚Äôs participating maintainers earn more income as their software is used by more subscribers, so they‚Äôre interested in knowing what you need.
Tooling and cloud integration
Tidelift works with GitHub, GitLab, BitBucket, and more. We support every cloud platform (and other deployment targets, too).
The end result? All of the capabilities you expect from commercial-grade software, for the full breadth of open source you use. That means less time grappling with esoteric open source trivia, and more time building your own applications‚Äîand your business.
Learn more
Request a demoEdit this page\n\nOn this pageFor EnterpriseAvailable as part of the Tidelift Subscription‚Äã
Tidelift is working with the maintainers of Prettier and thousands of other open source projects to deliver commercial support and maintenance for the open source dependencies you use to build your applications. Save time, reduce risk, and improve code health, while paying the maintainers of the exact dependencies you use.
Learn more
Request a demo

Enterprise-ready open source software‚Äîmanaged for you‚Äã
The Tidelift Subscription is a managed open source subscription for application dependencies covering millions of open source projects across JavaScript, Python, Java, PHP, Ruby, .NET, and more.
Your subscription includes:
Security updates
Tidelift‚Äôs security response team coordinates patches for new breaking security vulnerabilities and alerts immediately through a private channel, so your software supply chain is always secure.
Licensing verification and indemnification
Tidelift verifies license information to enable easy policy enforcement and adds intellectual property indemnification to cover creators and users in case something goes wrong. You always have a 100% up-to-date bill of materials for your dependencies to share with your legal team, customers, or partners.
Maintenance and code improvement
Tidelift ensures the software you rely on keeps working as long as you need it to work. Your managed dependencies are actively maintained and we recruit additional maintainers where required.
Package selection and version guidance
We help you choose the best open source packages from the start‚Äîand then guide you through updates to stay on the best releases as new issues arise.
Roadmap input
Take a seat at the table with the creators behind the software you use. Tidelift‚Äôs participating maintainers earn more income as their software is used by more subscribers, so they‚Äôre interested in knowing what you need.
Tooling and cloud integration
Tidelift works with GitHub, GitLab, BitBucket, and more. We support every cloud platform (and other deployment targets, too).
The end result? All of the capabilities you expect from commercial-grade software, for the full breadth of open source you use. That means less time grappling with esoteric open source trivia, and more time building your own applications‚Äîand your business.
Learn more
Request a demoEdit this pagePreviousRelated ProjectsAvailable as part of the Tidelift SubscriptionEnterprise-ready open source software‚Äîmanaged for you\n\n\n\nOn this pageWhat is Prettier?Prettier is an opinionated code formatter with support for:

JavaScript (including experimental features)
JSX
Angular
Vue
Flow
TypeScript
CSS, Less, and SCSS
HTML
Ember/Handlebars
JSON
GraphQL
Markdown, including GFM and MDX v1
YAML

It removes all original styling* and ensures that all outputted code conforms to a consistent style. (See this blog post)
Prettier takes your code and reprints it from scratch by taking the line length into account.
For example, take the following code:
foo(arg1, arg2, arg3, arg4);
It fits in a single line so it‚Äôs going to stay as is. However, we've all run into this situation:
foo(reallyLongArg(), omgSoManyParameters(), IShouldRefactorThis(), isThereSeriouslyAnotherOne());
Suddenly our previous format for calling function breaks down because this is too long. Prettier is going to do the painstaking work of reprinting it like that for you:
foo(  reallyLongArg(),  omgSoManyParameters(),  IShouldRefactorThis(),  isThereSeriouslyAnotherOne(),);
Prettier enforces a consistent code style (i.e. code formatting that won‚Äôt affect the AST) across your entire codebase because it disregards the original styling* by parsing it away and re-printing the parsed AST with its own rules that take the maximum line length into account, wrapping code when necessary.
If you want to learn more, these two conference talks are great introductions:


Footnotes‚Äã
* Well actually, some original styling is preserved when practical‚Äîsee empty lines and multi-line objects.Edit this page\n\nOn this pageWhat is Prettier?Prettier is an opinionated code formatter with support for:

JavaScript (including experimental features)
JSX
Angular
Vue
Flow
TypeScript
CSS, Less, and SCSS
HTML
Ember/Handlebars
JSON
GraphQL
Markdown, including GFM and MDX v1
YAML

It removes all original styling* and ensures that all outputted code conforms to a consistent style. (See this blog post)
Prettier takes your code and reprints it from scratch by taking the line length into account.
For example, take the following code:
foo(arg1, arg2, arg3, arg4);
It fits in a single line so it‚Äôs going to stay as is. However, we've all run into this situation:
foo(reallyLongArg(), omgSoManyParameters(), IShouldRefactorThis(), isThereSeriouslyAnotherOne());
Suddenly our previous format for calling function breaks down because this is too long. Prettier is going to do the painstaking work of reprinting it like that for you:
foo(  reallyLongArg(),  omgSoManyParameters(),  IShouldRefactorThis(),  isThereSeriouslyAnotherOne(),);
Prettier enforces a consistent code style (i.e. code formatting that won‚Äôt affect the AST) across your entire codebase because it disregards the original styling* by parsing it away and re-printing the parsed AST with its own rules that take the maximum line length into account, wrapping code when necessary.
If you want to learn more, these two conference talks are great introductions:


Footnotes‚Äã
* Well actually, some original styling is preserved when practical‚Äîsee empty lines and multi-line objects.Edit this pageNextWhy Prettier?\n\n\n\nOn this pageRationalePrettier is an opinionated code formatter. This document explains some of its choices.
What Prettier is concerned about‚Äã
Correctness‚Äã
The first requirement of Prettier is to output valid code that has the exact same behavior as before formatting. Please report any code where Prettier fails to follow these correctness rules ‚Äî that‚Äôs a bug which needs to be fixed!
Strings‚Äã
Double or single quotes? Prettier chooses the one which results in the fewest number of escapes. "It's gettin' better!", not 'It\'s gettin\' better!'. In case of a tie or the string not containing any quotes, Prettier defaults to double quotes (but that can be changed via the singleQuote option).
JSX has its own option for quotes: jsxSingleQuote.
JSX takes its roots from HTML, where the dominant use of quotes for attributes is double quotes. Browser developer tools also follow this convention by always displaying HTML with double quotes, even if the source code uses single quotes. A separate option allows using single quotes for JS and double quotes for "HTML" (JSX).
Prettier maintains the way your string is escaped. For example, "üôÇ" won‚Äôt be formatted into "\uD83D\uDE42" and vice versa.
Empty lines‚Äã
It turns out that empty lines are very hard to automatically generate. The approach that Prettier takes is to preserve empty lines the way they were in the original source code. There are two additional rules:

Prettier collapses multiple blank lines into a single blank line.
Empty lines at the start and end of blocks (and whole files) are removed. (Files always end with a single newline, though.)

Multi-line objects‚Äã
By default, Prettier‚Äôs printing algorithm prints expressions on a single line if they fit. Objects are used for a lot of different things in JavaScript, though, and sometimes it really helps readability if they stay multiline. See object lists, nested configs, stylesheets and keyed methods, for example. We haven‚Äôt been able to find a good rule for all those cases, so by default Prettier keeps objects multi-line if there‚Äôs a newline between the { and the first key in the original source code. Consequently, long single-line objects are automatically expanded, but short multi-line objects are never collapsed.
You can disable this conditional behavior with the objectWrap option.
Tip: If you have a multi-line object that you‚Äôd like to join up into a single line:
const user = {  name: "John Doe",  age: 30,};
‚Ä¶all you need to do is remove the newline after {:
const user = {  name: "John Doe",  age: 30};
‚Ä¶and then run Prettier:
const user = { name: "John Doe", age: 30 };
And if you‚Äôd like to go multi-line again, add in a newline after {:
const user = { name: "John Doe", age: 30 };
‚Ä¶and run Prettier:
const user = {  name: "John Doe",  age: 30,};
A note on formatting reversibilityThe semi-manual formatting for object literals is in fact a workaround, not a feature. It was implemented only because at the time a good heuristic wasn‚Äôt found and an urgent fix was needed. However, as a general strategy, Prettier avoids non-reversible formatting like that, so the team is still looking for heuristics that would allow either to remove this behavior completely or at least to reduce the number of situations where it‚Äôs applied.What does reversible mean? Once an object literal becomes multiline, Prettier won‚Äôt collapse it back. If in Prettier-formatted code, we add a property to an object literal, run Prettier, then change our mind, remove the added property, and then run Prettier again, we might end up with a formatting not identical to the initial one. This useless change might even get included in a commit, which is exactly the kind of situation Prettier was created to prevent.
Decorators‚Äã
Just like with objects, decorators are used for a lot of different things. Sometimes it makes sense to write decorators above the line they're decorating, sometimes it‚Äôs nicer if they're on the same line. We haven‚Äôt been able to find a good rule for this, so Prettier keeps your decorator positioned like you wrote them (if they fit on the line). This isn‚Äôt ideal, but a pragmatic solution to a difficult problem.
@Component({  selector: "hero-button",  template: `<button>{{ label }}</button>`,})class HeroButtonComponent {  // These decorators were written inline and fit on the line so they stay  // inline.  @Output() change = new EventEmitter();  @Input() label: string;  // These were written multiline, so they stay multiline.  @readonly  @nonenumerable  NODE_TYPE: 2;}
There‚Äôs one exception: classes. We don‚Äôt think it ever makes sense to inline the decorators for them, so they are always moved to their own line.
// Before running Prettier:@observer class OrderLine {  @observable price: number = 0;}
// After running Prettier:@observerclass OrderLine {  @observable price: number = 0;}
Note: Prettier 1.14.x and older tried to automatically move your decorators, so if you've run an older Prettier version on your code you might need to manually join up some decorators here and there to avoid inconsistencies:
@observerclass OrderLine {  @observable price: number = 0;  @observable  amount: number = 0;}
One final thing: TC39 has not yet decided if decorators come before or after export. In the meantime, Prettier supports both:
@decorator export class Foo {}export @decorator class Foo {}
Template literals‚Äã
Template literals can contain interpolations. Deciding whether it's appropriate to insert a linebreak within an interpolation unfortunately depends on the semantic content of the template - for example, introducing a linebreak in the middle of a natural-language sentence is usually undesirable. Since Prettier doesn't have enough information to make this decision itself, it uses a heuristic similar to that used for objects: it will only split an interpolation expression across multiple lines if there was already a linebreak within that interpolation.
This means that a literal like the following will not be broken onto multiple lines, even if it exceeds the print width:
`this is a long message which contains an interpolation: ${format(data)} <- like this`;
If you want Prettier to split up an interpolation, you'll need to ensure there's a linebreak somewhere within the ${...}. Otherwise it will keep everything on a single line, no matter how long it is.
The team would prefer not to depend on the original formatting in this way, but it's the best heuristic we have at the moment.
Semicolons‚Äã
This is about using the noSemi option.
Consider this piece of code:
if (shouldAddLines) {  [-1, 1].forEach(delta => addLine(delta * 20))}
While the above code works just fine without semicolons, Prettier actually turns it into:
if (shouldAddLines) {  ;[-1, 1].forEach(delta => addLine(delta * 20))}
This is to help you avoid mistakes. Imagine Prettier not inserting that semicolon and adding this line:
 if (shouldAddLines) {+  console.log('Do we even get here??')   [-1, 1].forEach(delta => addLine(delta * 20)) }
Oops! The above actually means:
if (shouldAddLines) {  console.log('Do we even get here??')[-1, 1].forEach(delta => addLine(delta * 20))}
With a semicolon in front of that [ such issues never happen. It makes the line independent of other lines so you can move and add lines without having to think about ASI rules.
This practice is also common in standard which uses a semicolon-free style.
Note that if your program currently has a semicolon-related bug in it, Prettier will not auto-fix the bug for you. Remember, Prettier only reformats code, it does not change the behavior of the code. Take this buggy piece of code as an example, where the developer forgot to place a semicolon before the (:
console.log('Running a background task')(async () => {  await doBackgroundWork()})()
If you feed this into Prettier, it will not alter the behavior of this code, instead, it will reformat it in a way that shows how this code will actually behave when ran.
console.log("Running a background task")(async () => {  await doBackgroundWork();})();
Print width‚Äã
The printWidth option is more of a guideline to Prettier than a hard rule. It is not the upper allowed line length limit. It is a way to say to Prettier roughly how long you‚Äôd like lines to be. Prettier will make both shorter and longer lines, but generally strive to meet the specified print width.
There are some edge cases, such as really long string literals, regexps, comments and variable names, which cannot be broken across lines (without using code transforms which Prettier doesn‚Äôt do). Or if you nest your code 50 levels deep your lines are of course going to be mostly indentation :)
Apart from that, there are a few cases where Prettier intentionally exceeds the print width.
Imports‚Äã
Prettier can break long import statements across several lines:
import {  CollectionDashboard,  DashboardPlaceholder,} from "../components/collections/collection-dashboard/main";
The following example doesn‚Äôt fit within the print width, but Prettier prints it in a single line anyway:
import { CollectionDashboard } from "../components/collections/collection-dashboard/main";
This might be unexpected by some, but we do it this way since it was a common request to keep imports with single elements in a single line. The same applies for require calls.
Testing functions‚Äã
Another common request was to keep lengthy test descriptions in one line, even if it gets too long. In such cases, wrapping the arguments to new lines doesn‚Äôt help much.
describe("NodeRegistry", () => {  it("makes no request if there are no nodes to prefetch, even if the cache is stale", async () => {    // The above line exceeds the print width but stayed on one line anyway.  });});
Prettier has special cases for common testing framework functions such as describe, it and test.
JSX‚Äã
Prettier prints things a little differently compared to other JS when JSX is involved:
function greet(user) {  return user    ? `Welcome back, ${user.name}!`    : "Greetings, traveler! Sign up today!";}function Greet({ user }) {  return (    <div>      {user ? (        <p>Welcome back, {user.name}!</p>      ) : (        <p>Greetings, traveler! Sign up today!</p>      )}    </div>  );}
There are two reasons.
First off, lots of people already wrapped their JSX in parentheses, especially in return statements. Prettier follows this common style.
Secondly, the alternate formatting makes it easier to edit the JSX. It is easy to leave a semicolon behind. As opposed to normal JS, a leftover semicolon in JSX can end up as plain text showing on your page.
<div>  <p>Greetings, traveler! Sign up today!</p>; {/* <-- Oops! */}</div>
Comments‚Äã
When it comes to the content of comments, Prettier can‚Äôt do much really. Comments can contain everything from prose to commented out code and ASCII diagrams. Since they can contain anything, Prettier can‚Äôt know how to format or wrap them. So they are left as-is. The only exception to this are JSDoc-style comments (block comments where every line starts with a *), which Prettier can fix the indentation of.
Then there‚Äôs the question of where to put the comments. Turns out this is a really difficult problem. Prettier tries its best to keep your comments roughly where they were, but it‚Äôs no easy task because comments can be placed almost anywhere.
Generally, you get the best results when placing comments on their own lines, instead of at the end of lines. Prefer // eslint-disable-next-line over // eslint-disable-line.
Note that ‚Äúmagic comments‚Äù such as eslint-disable-next-line and $FlowFixMe might sometimes need to be manually moved due to Prettier breaking an expression into multiple lines.
Imagine this piece of code:
// eslint-disable-next-line no-evalconst result = safeToEval ? eval(input) : fallback(input);
Then you need to add another condition:
// eslint-disable-next-line no-evalconst result = safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);
Prettier will turn the above into:
// eslint-disable-next-line no-evalconst result =  safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);
Which means that the eslint-disable-next-line comment is no longer effective. In this case you need to move the comment:
const result =  // eslint-disable-next-line no-eval  safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);
If possible, prefer comments that operate on line ranges (e.g. eslint-disable and eslint-enable) or on the statement level (e.g. /* istanbul ignore next */), they are even safer. It‚Äôs possible to disallow using eslint-disable-line and eslint-disable-next-line comments using eslint-plugin-eslint-comments.
Disclaimer about non-standard syntax‚Äã
Prettier is often able to recognize and format non-standard syntax such as ECMAScript early-stage proposals and Markdown syntax extensions not defined by any specification. The support for such syntax is considered best-effort and experimental. Incompatibilities may be introduced in any release and should not be viewed as breaking changes.
Disclaimer about machine-generated files‚Äã
Some files, like package.json or composer.lock, are machine-generated and regularly updated by the package manager. If Prettier were to use the same JSON formatting rules as with other files, it would regularly conflict with these other tools. To avoid this inconvenience, Prettier will use a formatter based on JSON.stringify on such files instead. You may notice these differences, such as the removal of vertical whitespace, but this is an intended behavior.
What Prettier is not concerned about‚Äã
Prettier only prints code. It does not transform it. This is to limit the scope of Prettier. Let‚Äôs focus on the printing and do it really well!
Here are a few examples of things that are out of scope for Prettier:

Turning single- or double-quoted strings into template literals or vice versa.
Using + to break long string literals into parts that fit the print width.
Adding/removing {} and return where they are optional.
Turning ?: into if-else statements.
Sorting/moving imports, object keys, class members, JSX keys, CSS properties or anything else. Apart from being a transform rather than just printing (as mentioned above), sorting is potentially unsafe because of side effects (for imports, as an example) and makes it difficult to verify the most important correctness goal.
Edit this page\n\nOn this pageRationalePrettier is an opinionated code formatter. This document explains some of its choices.
What Prettier is concerned about‚Äã
Correctness‚Äã
The first requirement of Prettier is to output valid code that has the exact same behavior as before formatting. Please report any code where Prettier fails to follow these correctness rules ‚Äî that‚Äôs a bug which needs to be fixed!
Strings‚Äã
Double or single quotes? Prettier chooses the one which results in the fewest number of escapes. "It's gettin' better!", not 'It\'s gettin\' better!'. In case of a tie or the string not containing any quotes, Prettier defaults to double quotes (but that can be changed via the singleQuote option).
JSX has its own option for quotes: jsxSingleQuote.
JSX takes its roots from HTML, where the dominant use of quotes for attributes is double quotes. Browser developer tools also follow this convention by always displaying HTML with double quotes, even if the source code uses single quotes. A separate option allows using single quotes for JS and double quotes for "HTML" (JSX).
Prettier maintains the way your string is escaped. For example, "üôÇ" won‚Äôt be formatted into "\uD83D\uDE42" and vice versa.
Empty lines‚Äã
It turns out that empty lines are very hard to automatically generate. The approach that Prettier takes is to preserve empty lines the way they were in the original source code. There are two additional rules:

Prettier collapses multiple blank lines into a single blank line.
Empty lines at the start and end of blocks (and whole files) are removed. (Files always end with a single newline, though.)

Multi-line objects‚Äã
By default, Prettier‚Äôs printing algorithm prints expressions on a single line if they fit. Objects are used for a lot of different things in JavaScript, though, and sometimes it really helps readability if they stay multiline. See object lists, nested configs, stylesheets and keyed methods, for example. We haven‚Äôt been able to find a good rule for all those cases, so by default Prettier keeps objects multi-line if there‚Äôs a newline between the { and the first key in the original source code. Consequently, long single-line objects are automatically expanded, but short multi-line objects are never collapsed.
You can disable this conditional behavior with the objectWrap option.
Tip: If you have a multi-line object that you‚Äôd like to join up into a single line:
const user = {  name: "John Doe",  age: 30,};
‚Ä¶all you need to do is remove the newline after {:
const user = {  name: "John Doe",  age: 30};
‚Ä¶and then run Prettier:
const user = { name: "John Doe", age: 30 };
And if you‚Äôd like to go multi-line again, add in a newline after {:
const user = { name: "John Doe", age: 30 };
‚Ä¶and run Prettier:
const user = {  name: "John Doe",  age: 30,};
A note on formatting reversibilityThe semi-manual formatting for object literals is in fact a workaround, not a feature. It was implemented only because at the time a good heuristic wasn‚Äôt found and an urgent fix was needed. However, as a general strategy, Prettier avoids non-reversible formatting like that, so the team is still looking for heuristics that would allow either to remove this behavior completely or at least to reduce the number of situations where it‚Äôs applied.What does reversible mean? Once an object literal becomes multiline, Prettier won‚Äôt collapse it back. If in Prettier-formatted code, we add a property to an object literal, run Prettier, then change our mind, remove the added property, and then run Prettier again, we might end up with a formatting not identical to the initial one. This useless change might even get included in a commit, which is exactly the kind of situation Prettier was created to prevent.
Decorators‚Äã
Just like with objects, decorators are used for a lot of different things. Sometimes it makes sense to write decorators above the line they're decorating, sometimes it‚Äôs nicer if they're on the same line. We haven‚Äôt been able to find a good rule for this, so Prettier keeps your decorator positioned like you wrote them (if they fit on the line). This isn‚Äôt ideal, but a pragmatic solution to a difficult problem.
@Component({  selector: "hero-button",  template: `<button>{{ label }}</button>`,})class HeroButtonComponent {  // These decorators were written inline and fit on the line so they stay  // inline.  @Output() change = new EventEmitter();  @Input() label: string;  // These were written multiline, so they stay multiline.  @readonly  @nonenumerable  NODE_TYPE: 2;}
There‚Äôs one exception: classes. We don‚Äôt think it ever makes sense to inline the decorators for them, so they are always moved to their own line.
// Before running Prettier:@observer class OrderLine {  @observable price: number = 0;}
// After running Prettier:@observerclass OrderLine {  @observable price: number = 0;}
Note: Prettier 1.14.x and older tried to automatically move your decorators, so if you've run an older Prettier version on your code you might need to manually join up some decorators here and there to avoid inconsistencies:
@observerclass OrderLine {  @observable price: number = 0;  @observable  amount: number = 0;}
One final thing: TC39 has not yet decided if decorators come before or after export. In the meantime, Prettier supports both:
@decorator export class Foo {}export @decorator class Foo {}
Template literals‚Äã
Template literals can contain interpolations. Deciding whether it's appropriate to insert a linebreak within an interpolation unfortunately depends on the semantic content of the template - for example, introducing a linebreak in the middle of a natural-language sentence is usually undesirable. Since Prettier doesn't have enough information to make this decision itself, it uses a heuristic similar to that used for objects: it will only split an interpolation expression across multiple lines if there was already a linebreak within that interpolation.
This means that a literal like the following will not be broken onto multiple lines, even if it exceeds the print width:
`this is a long message which contains an interpolation: ${format(data)} <- like this`;
If you want Prettier to split up an interpolation, you'll need to ensure there's a linebreak somewhere within the ${...}. Otherwise it will keep everything on a single line, no matter how long it is.
The team would prefer not to depend on the original formatting in this way, but it's the best heuristic we have at the moment.
Semicolons‚Äã
This is about using the noSemi option.
Consider this piece of code:
if (shouldAddLines) {  [-1, 1].forEach(delta => addLine(delta * 20))}
While the above code works just fine without semicolons, Prettier actually turns it into:
if (shouldAddLines) {  ;[-1, 1].forEach(delta => addLine(delta * 20))}
This is to help you avoid mistakes. Imagine Prettier not inserting that semicolon and adding this line:
 if (shouldAddLines) {+  console.log('Do we even get here??')   [-1, 1].forEach(delta => addLine(delta * 20)) }
Oops! The above actually means:
if (shouldAddLines) {  console.log('Do we even get here??')[-1, 1].forEach(delta => addLine(delta * 20))}
With a semicolon in front of that [ such issues never happen. It makes the line independent of other lines so you can move and add lines without having to think about ASI rules.
This practice is also common in standard which uses a semicolon-free style.
Note that if your program currently has a semicolon-related bug in it, Prettier will not auto-fix the bug for you. Remember, Prettier only reformats code, it does not change the behavior of the code. Take this buggy piece of code as an example, where the developer forgot to place a semicolon before the (:
console.log('Running a background task')(async () => {  await doBackgroundWork()})()
If you feed this into Prettier, it will not alter the behavior of this code, instead, it will reformat it in a way that shows how this code will actually behave when ran.
console.log("Running a background task")(async () => {  await doBackgroundWork();})();
Print width‚Äã
The printWidth option is more of a guideline to Prettier than a hard rule. It is not the upper allowed line length limit. It is a way to say to Prettier roughly how long you‚Äôd like lines to be. Prettier will make both shorter and longer lines, but generally strive to meet the specified print width.
There are some edge cases, such as really long string literals, regexps, comments and variable names, which cannot be broken across lines (without using code transforms which Prettier doesn‚Äôt do). Or if you nest your code 50 levels deep your lines are of course going to be mostly indentation :)
Apart from that, there are a few cases where Prettier intentionally exceeds the print width.
Imports‚Äã
Prettier can break long import statements across several lines:
import {  CollectionDashboard,  DashboardPlaceholder,} from "../components/collections/collection-dashboard/main";
The following example doesn‚Äôt fit within the print width, but Prettier prints it in a single line anyway:
import { CollectionDashboard } from "../components/collections/collection-dashboard/main";
This might be unexpected by some, but we do it this way since it was a common request to keep imports with single elements in a single line. The same applies for require calls.
Testing functions‚Äã
Another common request was to keep lengthy test descriptions in one line, even if it gets too long. In such cases, wrapping the arguments to new lines doesn‚Äôt help much.
describe("NodeRegistry", () => {  it("makes no request if there are no nodes to prefetch, even if the cache is stale", async () => {    // The above line exceeds the print width but stayed on one line anyway.  });});
Prettier has special cases for common testing framework functions such as describe, it and test.
JSX‚Äã
Prettier prints things a little differently compared to other JS when JSX is involved:
function greet(user) {  return user    ? `Welcome back, ${user.name}!`    : "Greetings, traveler! Sign up today!";}function Greet({ user }) {  return (    <div>      {user ? (        <p>Welcome back, {user.name}!</p>      ) : (        <p>Greetings, traveler! Sign up today!</p>      )}    </div>  );}
There are two reasons.
First off, lots of people already wrapped their JSX in parentheses, especially in return statements. Prettier follows this common style.
Secondly, the alternate formatting makes it easier to edit the JSX. It is easy to leave a semicolon behind. As opposed to normal JS, a leftover semicolon in JSX can end up as plain text showing on your page.
<div>  <p>Greetings, traveler! Sign up today!</p>; {/* <-- Oops! */}</div>
Comments‚Äã
When it comes to the content of comments, Prettier can‚Äôt do much really. Comments can contain everything from prose to commented out code and ASCII diagrams. Since they can contain anything, Prettier can‚Äôt know how to format or wrap them. So they are left as-is. The only exception to this are JSDoc-style comments (block comments where every line starts with a *), which Prettier can fix the indentation of.
Then there‚Äôs the question of where to put the comments. Turns out this is a really difficult problem. Prettier tries its best to keep your comments roughly where they were, but it‚Äôs no easy task because comments can be placed almost anywhere.
Generally, you get the best results when placing comments on their own lines, instead of at the end of lines. Prefer // eslint-disable-next-line over // eslint-disable-line.
Note that ‚Äúmagic comments‚Äù such as eslint-disable-next-line and $FlowFixMe might sometimes need to be manually moved due to Prettier breaking an expression into multiple lines.
Imagine this piece of code:
// eslint-disable-next-line no-evalconst result = safeToEval ? eval(input) : fallback(input);
Then you need to add another condition:
// eslint-disable-next-line no-evalconst result = safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);
Prettier will turn the above into:
// eslint-disable-next-line no-evalconst result =  safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);
Which means that the eslint-disable-next-line comment is no longer effective. In this case you need to move the comment:
const result =  // eslint-disable-next-line no-eval  safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);
If possible, prefer comments that operate on line ranges (e.g. eslint-disable and eslint-enable) or on the statement level (e.g. /* istanbul ignore next */), they are even safer. It‚Äôs possible to disallow using eslint-disable-line and eslint-disable-next-line comments using eslint-plugin-eslint-comments.
Disclaimer about non-standard syntax‚Äã
Prettier is often able to recognize and format non-standard syntax such as ECMAScript early-stage proposals and Markdown syntax extensions not defined by any specification. The support for such syntax is considered best-effort and experimental. Incompatibilities may be introduced in any release and should not be viewed as breaking changes.
Disclaimer about machine-generated files‚Äã
Some files, like package.json or composer.lock, are machine-generated and regularly updated by the package manager. If Prettier were to use the same JSON formatting rules as with other files, it would regularly conflict with these other tools. To avoid this inconvenience, Prettier will use a formatter based on JSON.stringify on such files instead. You may notice these differences, such as the removal of vertical whitespace, but this is an intended behavior.
What Prettier is not concerned about‚Äã
Prettier only prints code. It does not transform it. This is to limit the scope of Prettier. Let‚Äôs focus on the printing and do it really well!
Here are a few examples of things that are out of scope for Prettier:

Turning single- or double-quoted strings into template literals or vice versa.
Using + to break long string literals into parts that fit the print width.
Adding/removing {} and return where they are optional.
Turning ?: into if-else statements.
Sorting/moving imports, object keys, class members, JSX keys, CSS properties or anything else. Apart from being a transform rather than just printing (as mentioned above), sorting is potentially unsafe because of side effects (for imports, as an example) and makes it difficult to verify the most important correctness goal.
Edit this pagePreviousOption PhilosophyNextInstallWhat Prettier is concerned aboutCorrectnessStringsEmpty linesMulti-line objectsDecoratorsTemplate literalsSemicolonsPrint widthJSXCommentsDisclaimer about non-standard syntaxDisclaimer about machine-generated filesWhat Prettier is not concerned about\n\n\n\nOn this pageRationalePrettier is an opinionated code formatter. This document explains some of its choices.
What Prettier is concerned about‚Äã
Correctness‚Äã
The first requirement of Prettier is to output valid code that has the exact same behavior as before formatting. Please report any code where Prettier fails to follow these correctness rules ‚Äî that‚Äôs a bug which needs to be fixed!
Strings‚Äã
Double or single quotes? Prettier chooses the one which results in the fewest number of escapes. "It's gettin' better!", not 'It\'s gettin\' better!'. In case of a tie or the string not containing any quotes, Prettier defaults to double quotes (but that can be changed via the singleQuote option).
JSX has its own option for quotes: jsxSingleQuote.
JSX takes its roots from HTML, where the dominant use of quotes for attributes is double quotes. Browser developer tools also follow this convention by always displaying HTML with double quotes, even if the source code uses single quotes. A separate option allows using single quotes for JS and double quotes for "HTML" (JSX).
Prettier maintains the way your string is escaped. For example, "üôÇ" won‚Äôt be formatted into "\uD83D\uDE42" and vice versa.
Empty lines‚Äã
It turns out that empty lines are very hard to automatically generate. The approach that Prettier takes is to preserve empty lines the way they were in the original source code. There are two additional rules:

Prettier collapses multiple blank lines into a single blank line.
Empty lines at the start and end of blocks (and whole files) are removed. (Files always end with a single newline, though.)

Multi-line objects‚Äã
By default, Prettier‚Äôs printing algorithm prints expressions on a single line if they fit. Objects are used for a lot of different things in JavaScript, though, and sometimes it really helps readability if they stay multiline. See object lists, nested configs, stylesheets and keyed methods, for example. We haven‚Äôt been able to find a good rule for all those cases, so by default Prettier keeps objects multi-line if there‚Äôs a newline between the { and the first key in the original source code. Consequently, long single-line objects are automatically expanded, but short multi-line objects are never collapsed.
You can disable this conditional behavior with the objectWrap option.
Tip: If you have a multi-line object that you‚Äôd like to join up into a single line:
const user = {  name: "John Doe",  age: 30,};
‚Ä¶all you need to do is remove the newline after {:
const user = {  name: "John Doe",  age: 30};
‚Ä¶and then run Prettier:
const user = { name: "John Doe", age: 30 };
And if you‚Äôd like to go multi-line again, add in a newline after {:
const user = { name: "John Doe", age: 30 };
‚Ä¶and run Prettier:
const user = {  name: "John Doe",  age: 30,};
A note on formatting reversibilityThe semi-manual formatting for object literals is in fact a workaround, not a feature. It was implemented only because at the time a good heuristic wasn‚Äôt found and an urgent fix was needed. However, as a general strategy, Prettier avoids non-reversible formatting like that, so the team is still looking for heuristics that would allow either to remove this behavior completely or at least to reduce the number of situations where it‚Äôs applied.What does reversible mean? Once an object literal becomes multiline, Prettier won‚Äôt collapse it back. If in Prettier-formatted code, we add a property to an object literal, run Prettier, then change our mind, remove the added property, and then run Prettier again, we might end up with a formatting not identical to the initial one. This useless change might even get included in a commit, which is exactly the kind of situation Prettier was created to prevent.
Decorators‚Äã
Just like with objects, decorators are used for a lot of different things. Sometimes it makes sense to write decorators above the line they're decorating, sometimes it‚Äôs nicer if they're on the same line. We haven‚Äôt been able to find a good rule for this, so Prettier keeps your decorator positioned like you wrote them (if they fit on the line). This isn‚Äôt ideal, but a pragmatic solution to a difficult problem.
@Component({  selector: "hero-button",  template: `<button>{{ label }}</button>`,})class HeroButtonComponent {  // These decorators were written inline and fit on the line so they stay  // inline.  @Output() change = new EventEmitter();  @Input() label: string;  // These were written multiline, so they stay multiline.  @readonly  @nonenumerable  NODE_TYPE: 2;}
There‚Äôs one exception: classes. We don‚Äôt think it ever makes sense to inline the decorators for them, so they are always moved to their own line.
// Before running Prettier:@observer class OrderLine {  @observable price: number = 0;}
// After running Prettier:@observerclass OrderLine {  @observable price: number = 0;}
Note: Prettier 1.14.x and older tried to automatically move your decorators, so if you've run an older Prettier version on your code you might need to manually join up some decorators here and there to avoid inconsistencies:
@observerclass OrderLine {  @observable price: number = 0;  @observable  amount: number = 0;}
One final thing: TC39 has not yet decided if decorators come before or after export. In the meantime, Prettier supports both:
@decorator export class Foo {}export @decorator class Foo {}
Template literals‚Äã
Template literals can contain interpolations. Deciding whether it's appropriate to insert a linebreak within an interpolation unfortunately depends on the semantic content of the template - for example, introducing a linebreak in the middle of a natural-language sentence is usually undesirable. Since Prettier doesn't have enough information to make this decision itself, it uses a heuristic similar to that used for objects: it will only split an interpolation expression across multiple lines if there was already a linebreak within that interpolation.
This means that a literal like the following will not be broken onto multiple lines, even if it exceeds the print width:
`this is a long message which contains an interpolation: ${format(data)} <- like this`;
If you want Prettier to split up an interpolation, you'll need to ensure there's a linebreak somewhere within the ${...}. Otherwise it will keep everything on a single line, no matter how long it is.
The team would prefer not to depend on the original formatting in this way, but it's the best heuristic we have at the moment.
Semicolons‚Äã
This is about using the noSemi option.
Consider this piece of code:
if (shouldAddLines) {  [-1, 1].forEach(delta => addLine(delta * 20))}
While the above code works just fine without semicolons, Prettier actually turns it into:
if (shouldAddLines) {  ;[-1, 1].forEach(delta => addLine(delta * 20))}
This is to help you avoid mistakes. Imagine Prettier not inserting that semicolon and adding this line:
 if (shouldAddLines) {+  console.log('Do we even get here??')   [-1, 1].forEach(delta => addLine(delta * 20)) }
Oops! The above actually means:
if (shouldAddLines) {  console.log('Do we even get here??')[-1, 1].forEach(delta => addLine(delta * 20))}
With a semicolon in front of that [ such issues never happen. It makes the line independent of other lines so you can move and add lines without having to think about ASI rules.
This practice is also common in standard which uses a semicolon-free style.
Note that if your program currently has a semicolon-related bug in it, Prettier will not auto-fix the bug for you. Remember, Prettier only reformats code, it does not change the behavior of the code. Take this buggy piece of code as an example, where the developer forgot to place a semicolon before the (:
console.log('Running a background task')(async () => {  await doBackgroundWork()})()
If you feed this into Prettier, it will not alter the behavior of this code, instead, it will reformat it in a way that shows how this code will actually behave when ran.
console.log("Running a background task")(async () => {  await doBackgroundWork();})();
Print width‚Äã
The printWidth option is more of a guideline to Prettier than a hard rule. It is not the upper allowed line length limit. It is a way to say to Prettier roughly how long you‚Äôd like lines to be. Prettier will make both shorter and longer lines, but generally strive to meet the specified print width.
There are some edge cases, such as really long string literals, regexps, comments and variable names, which cannot be broken across lines (without using code transforms which Prettier doesn‚Äôt do). Or if you nest your code 50 levels deep your lines are of course going to be mostly indentation :)
Apart from that, there are a few cases where Prettier intentionally exceeds the print width.
Imports‚Äã
Prettier can break long import statements across several lines:
import {  CollectionDashboard,  DashboardPlaceholder,} from "../components/collections/collection-dashboard/main";
The following example doesn‚Äôt fit within the print width, but Prettier prints it in a single line anyway:
import { CollectionDashboard } from "../components/collections/collection-dashboard/main";
This might be unexpected by some, but we do it this way since it was a common request to keep imports with single elements in a single line. The same applies for require calls.
Testing functions‚Äã
Another common request was to keep lengthy test descriptions in one line, even if it gets too long. In such cases, wrapping the arguments to new lines doesn‚Äôt help much.
describe("NodeRegistry", () => {  it("makes no request if there are no nodes to prefetch, even if the cache is stale", async () => {    // The above line exceeds the print width but stayed on one line anyway.  });});
Prettier has special cases for common testing framework functions such as describe, it and test.
JSX‚Äã
Prettier prints things a little differently compared to other JS when JSX is involved:
function greet(user) {  return user    ? `Welcome back, ${user.name}!`    : "Greetings, traveler! Sign up today!";}function Greet({ user }) {  return (    <div>      {user ? (        <p>Welcome back, {user.name}!</p>      ) : (        <p>Greetings, traveler! Sign up today!</p>      )}    </div>  );}
There are two reasons.
First off, lots of people already wrapped their JSX in parentheses, especially in return statements. Prettier follows this common style.
Secondly, the alternate formatting makes it easier to edit the JSX. It is easy to leave a semicolon behind. As opposed to normal JS, a leftover semicolon in JSX can end up as plain text showing on your page.
<div>  <p>Greetings, traveler! Sign up today!</p>; {/* <-- Oops! */}</div>
Comments‚Äã
When it comes to the content of comments, Prettier can‚Äôt do much really. Comments can contain everything from prose to commented out code and ASCII diagrams. Since they can contain anything, Prettier can‚Äôt know how to format or wrap them. So they are left as-is. The only exception to this are JSDoc-style comments (block comments where every line starts with a *), which Prettier can fix the indentation of.
Then there‚Äôs the question of where to put the comments. Turns out this is a really difficult problem. Prettier tries its best to keep your comments roughly where they were, but it‚Äôs no easy task because comments can be placed almost anywhere.
Generally, you get the best results when placing comments on their own lines, instead of at the end of lines. Prefer // eslint-disable-next-line over // eslint-disable-line.
Note that ‚Äúmagic comments‚Äù such as eslint-disable-next-line and $FlowFixMe might sometimes need to be manually moved due to Prettier breaking an expression into multiple lines.
Imagine this piece of code:
// eslint-disable-next-line no-evalconst result = safeToEval ? eval(input) : fallback(input);
Then you need to add another condition:
// eslint-disable-next-line no-evalconst result = safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);
Prettier will turn the above into:
// eslint-disable-next-line no-evalconst result =  safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);
Which means that the eslint-disable-next-line comment is no longer effective. In this case you need to move the comment:
const result =  // eslint-disable-next-line no-eval  safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);
If possible, prefer comments that operate on line ranges (e.g. eslint-disable and eslint-enable) or on the statement level (e.g. /* istanbul ignore next */), they are even safer. It‚Äôs possible to disallow using eslint-disable-line and eslint-disable-next-line comments using eslint-plugin-eslint-comments.
Disclaimer about non-standard syntax‚Äã
Prettier is often able to recognize and format non-standard syntax such as ECMAScript early-stage proposals and Markdown syntax extensions not defined by any specification. The support for such syntax is considered best-effort and experimental. Incompatibilities may be introduced in any release and should not be viewed as breaking changes.
Disclaimer about machine-generated files‚Äã
Some files, like package.json or composer.lock, are machine-generated and regularly updated by the package manager. If Prettier were to use the same JSON formatting rules as with other files, it would regularly conflict with these other tools. To avoid this inconvenience, Prettier will use a formatter based on JSON.stringify on such files instead. You may notice these differences, such as the removal of vertical whitespace, but this is an intended behavior.
What Prettier is not concerned about‚Äã
Prettier only prints code. It does not transform it. This is to limit the scope of Prettier. Let‚Äôs focus on the printing and do it really well!
Here are a few examples of things that are out of scope for Prettier:

Turning single- or double-quoted strings into template literals or vice versa.
Using + to break long string literals into parts that fit the print width.
Adding/removing {} and return where they are optional.
Turning ?: into if-else statements.
Sorting/moving imports, object keys, class members, JSX keys, CSS properties or anything else. Apart from being a transform rather than just printing (as mentioned above), sorting is potentially unsafe because of side effects (for imports, as an example) and makes it difficult to verify the most important correctness goal.
Edit this page\n\nOn this pageRationalePrettier is an opinionated code formatter. This document explains some of its choices.
What Prettier is concerned about‚Äã
Correctness‚Äã
The first requirement of Prettier is to output valid code that has the exact same behavior as before formatting. Please report any code where Prettier fails to follow these correctness rules ‚Äî that‚Äôs a bug which needs to be fixed!
Strings‚Äã
Double or single quotes? Prettier chooses the one which results in the fewest number of escapes. "It's gettin' better!", not 'It\'s gettin\' better!'. In case of a tie or the string not containing any quotes, Prettier defaults to double quotes (but that can be changed via the singleQuote option).
JSX has its own option for quotes: jsxSingleQuote.
JSX takes its roots from HTML, where the dominant use of quotes for attributes is double quotes. Browser developer tools also follow this convention by always displaying HTML with double quotes, even if the source code uses single quotes. A separate option allows using single quotes for JS and double quotes for "HTML" (JSX).
Prettier maintains the way your string is escaped. For example, "üôÇ" won‚Äôt be formatted into "\uD83D\uDE42" and vice versa.
Empty lines‚Äã
It turns out that empty lines are very hard to automatically generate. The approach that Prettier takes is to preserve empty lines the way they were in the original source code. There are two additional rules:

Prettier collapses multiple blank lines into a single blank line.
Empty lines at the start and end of blocks (and whole files) are removed. (Files always end with a single newline, though.)

Multi-line objects‚Äã
By default, Prettier‚Äôs printing algorithm prints expressions on a single line if they fit. Objects are used for a lot of different things in JavaScript, though, and sometimes it really helps readability if they stay multiline. See object lists, nested configs, stylesheets and keyed methods, for example. We haven‚Äôt been able to find a good rule for all those cases, so by default Prettier keeps objects multi-line if there‚Äôs a newline between the { and the first key in the original source code. Consequently, long single-line objects are automatically expanded, but short multi-line objects are never collapsed.
You can disable this conditional behavior with the objectWrap option.
Tip: If you have a multi-line object that you‚Äôd like to join up into a single line:
const user = {  name: "John Doe",  age: 30,};
‚Ä¶all you need to do is remove the newline after {:
const user = {  name: "John Doe",  age: 30};
‚Ä¶and then run Prettier:
const user = { name: "John Doe", age: 30 };
And if you‚Äôd like to go multi-line again, add in a newline after {:
const user = { name: "John Doe", age: 30 };
‚Ä¶and run Prettier:
const user = {  name: "John Doe",  age: 30,};
A note on formatting reversibilityThe semi-manual formatting for object literals is in fact a workaround, not a feature. It was implemented only because at the time a good heuristic wasn‚Äôt found and an urgent fix was needed. However, as a general strategy, Prettier avoids non-reversible formatting like that, so the team is still looking for heuristics that would allow either to remove this behavior completely or at least to reduce the number of situations where it‚Äôs applied.What does reversible mean? Once an object literal becomes multiline, Prettier won‚Äôt collapse it back. If in Prettier-formatted code, we add a property to an object literal, run Prettier, then change our mind, remove the added property, and then run Prettier again, we might end up with a formatting not identical to the initial one. This useless change might even get included in a commit, which is exactly the kind of situation Prettier was created to prevent.
Decorators‚Äã
Just like with objects, decorators are used for a lot of different things. Sometimes it makes sense to write decorators above the line they're decorating, sometimes it‚Äôs nicer if they're on the same line. We haven‚Äôt been able to find a good rule for this, so Prettier keeps your decorator positioned like you wrote them (if they fit on the line). This isn‚Äôt ideal, but a pragmatic solution to a difficult problem.
@Component({  selector: "hero-button",  template: `<button>{{ label }}</button>`,})class HeroButtonComponent {  // These decorators were written inline and fit on the line so they stay  // inline.  @Output() change = new EventEmitter();  @Input() label: string;  // These were written multiline, so they stay multiline.  @readonly  @nonenumerable  NODE_TYPE: 2;}
There‚Äôs one exception: classes. We don‚Äôt think it ever makes sense to inline the decorators for them, so they are always moved to their own line.
// Before running Prettier:@observer class OrderLine {  @observable price: number = 0;}
// After running Prettier:@observerclass OrderLine {  @observable price: number = 0;}
Note: Prettier 1.14.x and older tried to automatically move your decorators, so if you've run an older Prettier version on your code you might need to manually join up some decorators here and there to avoid inconsistencies:
@observerclass OrderLine {  @observable price: number = 0;  @observable  amount: number = 0;}
One final thing: TC39 has not yet decided if decorators come before or after export. In the meantime, Prettier supports both:
@decorator export class Foo {}export @decorator class Foo {}
Template literals‚Äã
Template literals can contain interpolations. Deciding whether it's appropriate to insert a linebreak within an interpolation unfortunately depends on the semantic content of the template - for example, introducing a linebreak in the middle of a natural-language sentence is usually undesirable. Since Prettier doesn't have enough information to make this decision itself, it uses a heuristic similar to that used for objects: it will only split an interpolation expression across multiple lines if there was already a linebreak within that interpolation.
This means that a literal like the following will not be broken onto multiple lines, even if it exceeds the print width:
`this is a long message which contains an interpolation: ${format(data)} <- like this`;
If you want Prettier to split up an interpolation, you'll need to ensure there's a linebreak somewhere within the ${...}. Otherwise it will keep everything on a single line, no matter how long it is.
The team would prefer not to depend on the original formatting in this way, but it's the best heuristic we have at the moment.
Semicolons‚Äã
This is about using the noSemi option.
Consider this piece of code:
if (shouldAddLines) {  [-1, 1].forEach(delta => addLine(delta * 20))}
While the above code works just fine without semicolons, Prettier actually turns it into:
if (shouldAddLines) {  ;[-1, 1].forEach(delta => addLine(delta * 20))}
This is to help you avoid mistakes. Imagine Prettier not inserting that semicolon and adding this line:
 if (shouldAddLines) {+  console.log('Do we even get here??')   [-1, 1].forEach(delta => addLine(delta * 20)) }
Oops! The above actually means:
if (shouldAddLines) {  console.log('Do we even get here??')[-1, 1].forEach(delta => addLine(delta * 20))}
With a semicolon in front of that [ such issues never happen. It makes the line independent of other lines so you can move and add lines without having to think about ASI rules.
This practice is also common in standard which uses a semicolon-free style.
Note that if your program currently has a semicolon-related bug in it, Prettier will not auto-fix the bug for you. Remember, Prettier only reformats code, it does not change the behavior of the code. Take this buggy piece of code as an example, where the developer forgot to place a semicolon before the (:
console.log('Running a background task')(async () => {  await doBackgroundWork()})()
If you feed this into Prettier, it will not alter the behavior of this code, instead, it will reformat it in a way that shows how this code will actually behave when ran.
console.log("Running a background task")(async () => {  await doBackgroundWork();})();
Print width‚Äã
The printWidth option is more of a guideline to Prettier than a hard rule. It is not the upper allowed line length limit. It is a way to say to Prettier roughly how long you‚Äôd like lines to be. Prettier will make both shorter and longer lines, but generally strive to meet the specified print width.
There are some edge cases, such as really long string literals, regexps, comments and variable names, which cannot be broken across lines (without using code transforms which Prettier doesn‚Äôt do). Or if you nest your code 50 levels deep your lines are of course going to be mostly indentation :)
Apart from that, there are a few cases where Prettier intentionally exceeds the print width.
Imports‚Äã
Prettier can break long import statements across several lines:
import {  CollectionDashboard,  DashboardPlaceholder,} from "../components/collections/collection-dashboard/main";
The following example doesn‚Äôt fit within the print width, but Prettier prints it in a single line anyway:
import { CollectionDashboard } from "../components/collections/collection-dashboard/main";
This might be unexpected by some, but we do it this way since it was a common request to keep imports with single elements in a single line. The same applies for require calls.
Testing functions‚Äã
Another common request was to keep lengthy test descriptions in one line, even if it gets too long. In such cases, wrapping the arguments to new lines doesn‚Äôt help much.
describe("NodeRegistry", () => {  it("makes no request if there are no nodes to prefetch, even if the cache is stale", async () => {    // The above line exceeds the print width but stayed on one line anyway.  });});
Prettier has special cases for common testing framework functions such as describe, it and test.
JSX‚Äã
Prettier prints things a little differently compared to other JS when JSX is involved:
function greet(user) {  return user    ? `Welcome back, ${user.name}!`    : "Greetings, traveler! Sign up today!";}function Greet({ user }) {  return (    <div>      {user ? (        <p>Welcome back, {user.name}!</p>      ) : (        <p>Greetings, traveler! Sign up today!</p>      )}    </div>  );}
There are two reasons.
First off, lots of people already wrapped their JSX in parentheses, especially in return statements. Prettier follows this common style.
Secondly, the alternate formatting makes it easier to edit the JSX. It is easy to leave a semicolon behind. As opposed to normal JS, a leftover semicolon in JSX can end up as plain text showing on your page.
<div>  <p>Greetings, traveler! Sign up today!</p>; {/* <-- Oops! */}</div>
Comments‚Äã
When it comes to the content of comments, Prettier can‚Äôt do much really. Comments can contain everything from prose to commented out code and ASCII diagrams. Since they can contain anything, Prettier can‚Äôt know how to format or wrap them. So they are left as-is. The only exception to this are JSDoc-style comments (block comments where every line starts with a *), which Prettier can fix the indentation of.
Then there‚Äôs the question of where to put the comments. Turns out this is a really difficult problem. Prettier tries its best to keep your comments roughly where they were, but it‚Äôs no easy task because comments can be placed almost anywhere.
Generally, you get the best results when placing comments on their own lines, instead of at the end of lines. Prefer // eslint-disable-next-line over // eslint-disable-line.
Note that ‚Äúmagic comments‚Äù such as eslint-disable-next-line and $FlowFixMe might sometimes need to be manually moved due to Prettier breaking an expression into multiple lines.
Imagine this piece of code:
// eslint-disable-next-line no-evalconst result = safeToEval ? eval(input) : fallback(input);
Then you need to add another condition:
// eslint-disable-next-line no-evalconst result = safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);
Prettier will turn the above into:
// eslint-disable-next-line no-evalconst result =  safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);
Which means that the eslint-disable-next-line comment is no longer effective. In this case you need to move the comment:
const result =  // eslint-disable-next-line no-eval  safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);
If possible, prefer comments that operate on line ranges (e.g. eslint-disable and eslint-enable) or on the statement level (e.g. /* istanbul ignore next */), they are even safer. It‚Äôs possible to disallow using eslint-disable-line and eslint-disable-next-line comments using eslint-plugin-eslint-comments.
Disclaimer about non-standard syntax‚Äã
Prettier is often able to recognize and format non-standard syntax such as ECMAScript early-stage proposals and Markdown syntax extensions not defined by any specification. The support for such syntax is considered best-effort and experimental. Incompatibilities may be introduced in any release and should not be viewed as breaking changes.
Disclaimer about machine-generated files‚Äã
Some files, like package.json or composer.lock, are machine-generated and regularly updated by the package manager. If Prettier were to use the same JSON formatting rules as with other files, it would regularly conflict with these other tools. To avoid this inconvenience, Prettier will use a formatter based on JSON.stringify on such files instead. You may notice these differences, such as the removal of vertical whitespace, but this is an intended behavior.
What Prettier is not concerned about‚Äã
Prettier only prints code. It does not transform it. This is to limit the scope of Prettier. Let‚Äôs focus on the printing and do it really well!
Here are a few examples of things that are out of scope for Prettier:

Turning single- or double-quoted strings into template literals or vice versa.
Using + to break long string literals into parts that fit the print width.
Adding/removing {} and return where they are optional.
Turning ?: into if-else statements.
Sorting/moving imports, object keys, class members, JSX keys, CSS properties or anything else. Apart from being a transform rather than just printing (as mentioned above), sorting is potentially unsafe because of side effects (for imports, as an example) and makes it difficult to verify the most important correctness goal.
Edit this pagePreviousOption PhilosophyNextInstallWhat Prettier is concerned aboutCorrectnessStringsEmpty linesMulti-line objectsDecoratorsTemplate literalsSemicolonsPrint widthJSXCommentsDisclaimer about non-standard syntaxDisclaimer about machine-generated filesWhat Prettier is not concerned about\n\n\n\nOn this pageWhat is Prettier?Prettier is an opinionated code formatter with support for:

JavaScript (including experimental features)
JSX
Angular
Vue
Flow
TypeScript
CSS, Less, and SCSS
HTML
Ember/Handlebars
JSON
GraphQL
Markdown, including GFM and MDX v1
YAML

It removes all original styling* and ensures that all outputted code conforms to a consistent style. (See this blog post)
Prettier takes your code and reprints it from scratch by taking the line length into account.
For example, take the following code:
foo(arg1, arg2, arg3, arg4);
It fits in a single line so it‚Äôs going to stay as is. However, we've all run into this situation:
foo(reallyLongArg(), omgSoManyParameters(), IShouldRefactorThis(), isThereSeriouslyAnotherOne());
Suddenly our previous format for calling function breaks down because this is too long. Prettier is going to do the painstaking work of reprinting it like that for you:
foo(  reallyLongArg(),  omgSoManyParameters(),  IShouldRefactorThis(),  isThereSeriouslyAnotherOne(),);
Prettier enforces a consistent code style (i.e. code formatting that won‚Äôt affect the AST) across your entire codebase because it disregards the original styling* by parsing it away and re-printing the parsed AST with its own rules that take the maximum line length into account, wrapping code when necessary.
If you want to learn more, these two conference talks are great introductions:


Footnotes‚Äã
* Well actually, some original styling is preserved when practical‚Äîsee empty lines and multi-line objects.Edit this page\n\nOn this pageWhat is Prettier?Prettier is an opinionated code formatter with support for:

JavaScript (including experimental features)
JSX
Angular
Vue
Flow
TypeScript
CSS, Less, and SCSS
HTML
Ember/Handlebars
JSON
GraphQL
Markdown, including GFM and MDX v1
YAML

It removes all original styling* and ensures that all outputted code conforms to a consistent style. (See this blog post)
Prettier takes your code and reprints it from scratch by taking the line length into account.
For example, take the following code:
foo(arg1, arg2, arg3, arg4);
It fits in a single line so it‚Äôs going to stay as is. However, we've all run into this situation:
foo(reallyLongArg(), omgSoManyParameters(), IShouldRefactorThis(), isThereSeriouslyAnotherOne());
Suddenly our previous format for calling function breaks down because this is too long. Prettier is going to do the painstaking work of reprinting it like that for you:
foo(  reallyLongArg(),  omgSoManyParameters(),  IShouldRefactorThis(),  isThereSeriouslyAnotherOne(),);
Prettier enforces a consistent code style (i.e. code formatting that won‚Äôt affect the AST) across your entire codebase because it disregards the original styling* by parsing it away and re-printing the parsed AST with its own rules that take the maximum line length into account, wrapping code when necessary.
If you want to learn more, these two conference talks are great introductions:


Footnotes‚Äã
* Well actually, some original styling is preserved when practical‚Äîsee empty lines and multi-line objects.Edit this pageNextWhy Prettier?\n\n\n\nWho‚Äôs Using This?Prettier is regularly used by:More than 83% of respondents to State of JS 2021 (10282 developers out of 12360).More than 70% of respondents to State of JS 2020 (14880 developers out of 20974)....and many more projects\n\n\n\nSkip to main contentPrettierstablenextstablePlaygroundDocsBlogDonateSearchPRETTIER FOR ENTERPRISETry It OnlineInstall PrettierLimited edition tshirts are now available to buy! $10 per tshirt goes to maintain the project.What is Prettier?An opinionated code formatterSupports many languagesIntegrates with most editorsHas few options ¬ªWhy?Your code is formatted on saveNo need to discuss style in code reviewSaves you time and energyAnd more ¬ªWorks with the Tools You UseJavaScriptJSXFlowTypeScriptJSONHTMLVueAngularEmber / HandlebarsCSSLessSCSSstyled-components üíÖstyled-jsxGraphQLGraphQL SchemasMarkdownCommonMarkGitHub-Flavored MarkdownMDX v1YAMLCommunity PluginsApexElm (via elm-format)JavaPHPRubyRustTOMLXMLAnd more...Editor SupportEmacsprettier-js
prettier.el
ApheleiaEspressoespresso-prettierNovaPrettier
Prettier‚Å∫Sublime TextJsPrettierVimvim-prettier
neoformat
ALE
coc-prettierVisual StudioJavaScriptPrettierVS Codeprettier-vscodeWebStormBuilt-in supportGot more?Send a PRUsed By People You Rely OnSee othersEstablished in the EcosystemRegularly used by:More than 83% of respondents to State of JS 2021.More than 70% of respondents to State of JS 2020.More than 9.3 million dependent repositories on GitHubCheck Them OutMore than 19.3k dependent packages on npmSee them allDocsAboutUsage
                  
                    
                  
                CommunityUser ShowcaseStack Overflow@PrettierCode on TwitterMoreBlogGitHubIssues\nSkip to main contentPrettierstablenextstablePlaygroundDocsBlogDonateSearchPRETTIER FOR ENTERPRISETry It OnlineInstall PrettierLimited edition tshirts are now available to buy! $10 per tshirt goes to maintain the project.What is Prettier?An opinionated code formatterSupports many languagesIntegrates with most editorsHas few options ¬ªWhy?Your code is formatted on saveNo need to discuss style in code reviewSaves you time and energyAnd more ¬ªWorks with the Tools You UseJavaScriptJSXFlowTypeScriptJSONHTMLVueAngularEmber / HandlebarsCSSLessSCSSstyled-components üíÖstyled-jsxGraphQLGraphQL SchemasMarkdownCommonMarkGitHub-Flavored MarkdownMDX v1YAMLCommunity PluginsApexElm (via elm-format)JavaPHPRubyRustTOMLXMLAnd more...Editor SupportEmacsprettier-js
prettier.el
ApheleiaEspressoespresso-prettierNovaPrettier
Prettier‚Å∫Sublime TextJsPrettierVimvim-prettier
neoformat
ALE
coc-prettierVisual StudioJavaScriptPrettierVS Codeprettier-vscodeWebStormBuilt-in supportGot more?Send a PRUsed By People You Rely OnSee othersEstablished in the EcosystemRegularly used by:More than 83% of respondents to State of JS 2021.More than 70% of respondents to State of JS 2020.More than 9.3 million dependent repositories on GitHubCheck Them OutMore than 19.3k dependent packages on npmSee them allDocsAboutUsage
                  
                    
                  
                CommunityUser ShowcaseStack Overflow@PrettierCode on TwitterMoreBlogGitHubIssues\nPrettierstablenextstablePlaygroundDocsBlogDonateSearch\nPrettierstablenextstable\nPlaygroundDocsBlogDonateSearch\nPRETTIER FOR ENTERPRISETry It OnlineInstall PrettierLimited edition tshirts are now available to buy! $10 per tshirt goes to maintain the project.What is Prettier?An opinionated code formatterSupports many languagesIntegrates with most editorsHas few options ¬ªWhy?Your code is formatted on saveNo need to discuss style in code reviewSaves you time and energyAnd more ¬ªWorks with the Tools You UseJavaScriptJSXFlowTypeScriptJSONHTMLVueAngularEmber / HandlebarsCSSLessSCSSstyled-components üíÖstyled-jsxGraphQLGraphQL SchemasMarkdownCommonMarkGitHub-Flavored MarkdownMDX v1YAMLCommunity PluginsApexElm (via elm-format)JavaPHPRubyRustTOMLXMLAnd more...Editor SupportEmacsprettier-js
prettier.el
ApheleiaEspressoespresso-prettierNovaPrettier
Prettier‚Å∫Sublime TextJsPrettierVimvim-prettier
neoformat
ALE
coc-prettierVisual StudioJavaScriptPrettierVS Codeprettier-vscodeWebStormBuilt-in supportGot more?Send a PRUsed By People You Rely OnSee othersEstablished in the EcosystemRegularly used by:More than 83% of respondents to State of JS 2021.More than 70% of respondents to State of JS 2020.More than 9.3 million dependent repositories on GitHubCheck Them OutMore than 19.3k dependent packages on npmSee them all\nPRETTIER FOR ENTERPRISE\nTry It OnlineInstall Prettier\nTry It OnlineInstall Prettier\nLimited edition tshirts are now available to buy! $10 per tshirt goes to maintain the project.\nLimited edition tshirts are now available to buy! $10 per tshirt goes to maintain the project.\nWhat is Prettier?An opinionated code formatterSupports many languagesIntegrates with most editorsHas few options ¬ªWhy?Your code is formatted on saveNo need to discuss style in code reviewSaves you time and energyAnd more ¬ª\nWhat is Prettier?An opinionated code formatterSupports many languagesIntegrates with most editorsHas few options ¬ªWhy?Your code is formatted on saveNo need to discuss style in code reviewSaves you time and energyAnd more ¬ª\nWhat is Prettier?An opinionated code formatterSupports many languagesIntegrates with most editorsHas few options ¬ª\nAn opinionated code formatter\nSupports many languages\nIntegrates with most editors\nWhy?Your code is formatted on saveNo need to discuss style in code reviewSaves you time and energyAnd more ¬ª\nYour code is formatted on save\nNo need to discuss style in code review\nSaves you time and energy\nWorks with the Tools You UseJavaScriptJSXFlowTypeScriptJSONHTMLVueAngularEmber / HandlebarsCSSLessSCSSstyled-components üíÖstyled-jsxGraphQLGraphQL SchemasMarkdownCommonMarkGitHub-Flavored MarkdownMDX v1YAMLCommunity PluginsApexElm (via elm-format)JavaPHPRubyRustTOMLXMLAnd more...\nWorks with the Tools You Use\nJavaScriptJSXFlowTypeScriptJSONHTMLVueAngularEmber / HandlebarsCSSLessSCSSstyled-components üíÖstyled-jsxGraphQLGraphQL SchemasMarkdownCommonMarkGitHub-Flavored MarkdownMDX v1YAMLCommunity PluginsApexElm (via elm-format)JavaPHPRubyRustTOMLXMLAnd more...\nJavaScriptJSXFlowTypeScriptJSONHTMLVueAngularEmber / Handlebars\nJavaScriptJSXFlowTypeScriptJSON\nHTMLVueAngularEmber / Handlebars\nCSSLessSCSSstyled-components üíÖstyled-jsxGraphQLGraphQL Schemas\nCSSLessSCSSstyled-components üíÖstyled-jsx\nGraphQLGraphQL Schemas\nMarkdownCommonMarkGitHub-Flavored MarkdownMDX v1YAML\nMarkdownCommonMarkGitHub-Flavored MarkdownMDX v1\nGitHub-Flavored Markdown\nGitHub-Flavored Markdown\nGitHub-Flavored Markdown\nCommunity PluginsApexElm (via elm-format)JavaPHPRubyRustTOMLXMLAnd more...\nCommunity PluginsApexElm (via elm-format)JavaPHPRubyRustTOMLXMLAnd more...\nEditor SupportEmacsprettier-js
prettier.el
ApheleiaEspressoespresso-prettierNovaPrettier
Prettier‚Å∫Sublime TextJsPrettierVimvim-prettier
neoformat
ALE
coc-prettierVisual StudioJavaScriptPrettierVS Codeprettier-vscodeWebStormBuilt-in supportGot more?Send a PR\nEditor SupportEmacsprettier-js
prettier.el
ApheleiaEspressoespresso-prettierNovaPrettier
Prettier‚Å∫Sublime TextJsPrettierVimvim-prettier
neoformat
ALE
coc-prettierVisual StudioJavaScriptPrettierVS Codeprettier-vscodeWebStormBuilt-in supportGot more?Send a PR\nEmacsprettier-js
prettier.el
ApheleiaEspressoespresso-prettierNovaPrettier
Prettier‚Å∫Sublime TextJsPrettierVimvim-prettier
neoformat
ALE
coc-prettierVisual StudioJavaScriptPrettierVS Codeprettier-vscodeWebStormBuilt-in support\nEmacsprettier-js
prettier.el
Apheleia\nEmacsprettier-js
prettier.el
Apheleia\nprettier-js
prettier.el
Apheleia\nEspressoespresso-prettier\nEspressoespresso-prettier\nNovaPrettier
Prettier‚Å∫\nNovaPrettier
Prettier‚Å∫\nSublime TextJsPrettier\nSublime TextJsPrettier\nVimvim-prettier
neoformat
ALE
coc-prettier\nVimvim-prettier
neoformat
ALE
coc-prettier\nvim-prettier
neoformat
ALE
coc-prettier\nVisual StudioJavaScriptPrettier\nVisual StudioJavaScriptPrettier\nVS Codeprettier-vscode\nVS Codeprettier-vscode\nWebStormBuilt-in support\nWebStormBuilt-in support\nUsed By People You Rely OnSee othersEstablished in the EcosystemRegularly used by:More than 83% of respondents to State of JS 2021.More than 70% of respondents to State of JS 2020.More than 9.3 million dependent repositories on GitHubCheck Them OutMore than 19.3k dependent packages on npmSee them all\nUsed By People You Rely OnSee others\nUsed By People You Rely On\nEstablished in the EcosystemRegularly used by:More than 83% of respondents to State of JS 2021.More than 70% of respondents to State of JS 2020.More than 9.3 million dependent repositories on GitHubCheck Them OutMore than 19.3k dependent packages on npmSee them all\nEstablished in the Ecosystem\nRegularly used by:More than 83% of respondents to State of JS 2021.More than 70% of respondents to State of JS 2020.More than 9.3 million dependent repositories on GitHubCheck Them OutMore than 19.3k dependent packages on npmSee them all\nRegularly used by:More than 83% of respondents to State of JS 2021.More than 70% of respondents to State of JS 2020.\nRegularly used by:More than 83% of respondents to State of JS 2021.More than 70% of respondents to State of JS 2020.\nMore than 83% of respondents to State of JS 2021.\nMore than 83% of respondents to State of JS 2021.\nMore than 70% of respondents to State of JS 2020.\nMore than 70% of respondents to State of JS 2020.\nMore than 9.3 million dependent repositories on GitHubCheck Them Out\nMore than 9.3 million dependent repositories on GitHubCheck Them Out\nMore than 9.3 million dependent repositories on GitHub\nMore than 19.3k dependent packages on npmSee them all\nMore than 19.3k dependent packages on npmSee them all\nMore than 19.3k dependent packages on npm\nDocsAboutUsage
                  
                    
                  
                CommunityUser ShowcaseStack Overflow@PrettierCode on TwitterMoreBlogGitHubIssues\nDocsAboutUsage
                  
                    
                  
                CommunityUser ShowcaseStack Overflow@PrettierCode on TwitterMoreBlogGitHubIssues\nCommunityUser ShowcaseStack Overflow@PrettierCode on Twitter\n@PrettierCode on Twitter\n@PrettierCode on Twitter\n\n\nOn this pagePluginsPlugins are ways of adding new languages or formatting rules to Prettier. Prettier‚Äôs own implementations of all languages are expressed using the plugin API. The core prettier package contains JavaScript and other web-focused languages built in. For additional languages you‚Äôll need to install a plugin.
Using Plugins‚Äã
You can load plugins with:


The CLI, via --plugin:
prettier --write main.foo --plugin=prettier-plugin-foo
tipYou can set --plugin options multiple times.


The API, via the plugins options:
await prettier.format("code", {  parser: "foo",  plugins: ["prettier-plugin-foo"],});


The Configuration File:
{  "plugins": ["prettier-plugin-foo"]}


Strings provided to plugins are ultimately passed to import() expression, so you can provide a module/package name, a path, or anything else import() takes.
Official Plugins‚Äã

@prettier/plugin-php
@prettier/plugin-pug by @Shinigami92
@prettier/plugin-ruby
@prettier/plugin-xml

Community Plugins‚Äã

prettier-plugin-apex by @dangmai
prettier-plugin-astro by @withastro contributors
prettier-plugin-elm by @giCentre
prettier-plugin-erb by @adamzapasnik
prettier-plugin-gherkin by @mapado
prettier-plugin-glsl by @NaridaL
prettier-plugin-go-template by @NiklasPor
prettier-plugin-java by @JHipster
prettier-plugin-jinja-template by @davidodenwald
prettier-plugin-jsonata by @Stedi
prettier-plugin-kotlin by @Angry-Potato
prettier-plugin-motoko by @dfinity
prettier-plugin-nginx by @joedeandev
prettier-plugin-prisma by @umidbekk
prettier-plugin-properties by @eemeli
prettier-plugin-rust by @jinxdash
prettier-plugin-sh by @JounQin
prettier-plugin-sql by @JounQin
prettier-plugin-sql-cst by @nene
prettier-plugin-solidity by @mattiaerre
prettier-plugin-svelte by @sveltejs
prettier-plugin-toml by @bd82

Developing Plugins‚Äã
Prettier plugins are regular JavaScript modules with the following five exports or default export with the following properties:

languages
parsers
printers
options
defaultOptions

languages‚Äã
Languages is an array of language definitions that your plugin will contribute to Prettier. It can include all of the fields specified in prettier.getSupportInfo().
It must include name and parsers.
export const languages = [  {    // The language name    name: "InterpretedDanceScript",    // Parsers that can parse this language.    // This can be built-in parsers, or parsers you have contributed via this plugin.    parsers: ["dance-parse"],  },];
parsers‚Äã
Parsers convert code as a string into an AST.
The key must match the name in the parsers array from languages. The value contains a parse function, an AST format name, and two location extraction functions (locStart and locEnd).
export const parsers = {  "dance-parse": {    parse,    // The name of the AST that the parser produces.    astFormat: "dance-ast",    hasPragma,    locStart,    locEnd,    preprocess,  },};
The signature of the parse function is:
function parse(text: string, options: object): Promise<AST> | AST;
The location extraction functions (locStart and locEnd) return the starting and ending locations of a given AST node:
function locStart(node: object): number;
(Optional) The pragma detection function (hasPragma) should return if the text contains the pragma comment.
function hasPragma(text: string): boolean;
(Optional) The preprocess function can process the input text before passing into parse function.
function preprocess(text: string, options: object): string;
printers‚Äã
Printers convert ASTs into a Prettier intermediate representation, also known as a Doc.
The key must match the astFormat that the parser produces. The value contains an object with a print function. All other properties (embed, preprocess, etc.) are optional.
export const printers = {  "dance-ast": {    print,    embed,    preprocess,    getVisitorKeys,    insertPragma,    canAttachComment,    isBlockComment,    printComment,    getCommentChildNodes,    handleComments: {      ownLine,      endOfLine,      remaining,    },  },};
The printing process‚Äã
Prettier uses an intermediate representation, called a Doc, which Prettier then turns into a string (based on options like printWidth). A printer's job is to take the AST generated by parsers[<parser name>].parse and return a Doc. A Doc is constructed using builder commands:
import { doc } from "prettier";const { join, line, ifBreak, group } = doc.builders;
The printing process consists of the following steps:

AST preprocessing (optional). See preprocess.
Comment attachment (optional). See Handling comments in a printer.
Processing embedded languages (optional). The embed method, if defined, is called for each node, depth-first. While, for performance reasons, the recursion itself is synchronous, embed may return asynchronous functions that can call other parsers and printers to compose docs for embedded syntaxes like CSS-in-JS. These returned functions are queued up and sequentially executed before the next step.
Recursive printing. A doc is recursively constructed from the AST. Starting from the root node:

If, from the step 3, there is an embedded language doc associated with the current node, this doc is used.
Otherwise, the print(path, options, print): Doc method is called. It composes a doc for the current node, often by printing child nodes using the print callback.



print‚Äã
Most of the work of a plugin's printer will take place in its print function, whose signature is:
function print(  // Path to the AST node to print  path: AstPath,  options: object,  // Recursively print a child node  print: (selector?: string | number | Array<string | number> | AstPath) => Doc,): Doc;
The print function is passed the following parameters:

path: An object, which can be used to access nodes in the AST. It‚Äôs a stack-like data structure that maintains the current state of the recursion. It is called ‚Äúpath‚Äù because it represents the path to the current node from the root of the AST. The current node is returned by path.node.
options: A persistent object, which contains global options and which a plugin may mutate to store contextual data.
print: A callback for printing sub-nodes. This function contains the core printing logic that consists of steps whose implementation is provided by plugins. In particular, it calls the printer‚Äôs print function and passes itself to it. Thus, the two print functions ‚Äì the one from the core and the one from the plugin ‚Äì call each other while descending down the AST recursively.

Here‚Äôs a simplified example to give an idea of what a typical implementation of print looks like:
import { doc } from "prettier";const { group, indent, join, line, softline } = doc.builders;function print(path, options, print) {  const node = path.node;  switch (node.type) {    case "list":      return group([        "(",        indent([softline, join(line, path.map(print, "elements"))]),        softline,        ")",      ]);    case "pair":      return group([        "(",        indent([softline, print("left"), line, ". ", print("right")]),        softline,        ")",      ]);    case "symbol":      return node.name;  }  throw new Error(`Unknown node type: ${node.type}`);}
Check out prettier-python's printer for some examples of what is possible.
(optional) embed‚Äã
A printer can have the embed method to print one language inside another. Examples of this are printing CSS-in-JS or fenced code blocks in Markdown. The signature is:
function embed(  // Path to the current AST node  path: AstPath,  // Current options  options: Options,):  | ((      // Parses and prints the passed text using a different parser.      // You should set `options.parser` to specify which parser to use.      textToDoc: (text: string, options: Options) => Promise<Doc>,      // Prints the current node or its descendant node with the current printer      print: (        selector?: string | number | Array<string | number> | AstPath,      ) => Doc,      // The following two arguments are passed for convenience.      // They're the same `path` and `options` that are passed to `embed`.      path: AstPath,      options: Options,    ) => Promise<Doc | undefined> | Doc | undefined)  | Doc  | undefined;
The embed method is similar to the print method in that it maps AST nodes to docs, but unlike print, it has power to do async work by returning an async function. That function's first parameter, the textToDoc async function, can be used to render a doc using a different plugin.
If a function returned from embed returns a doc or a promise that resolves to a doc, that doc will be used in printing, and the print method won‚Äôt be called for this node. It's also possible and, in rare situations, might be convenient to return a doc synchronously directly from embed, however textToDoc and the print callback aren‚Äôt available at that case. Return a function to get them.
If embed returns undefined, or if a function it returned returns undefined or a promise that resolves to undefined, the node will be printed normally with the print method. Same will happen if a returned function throws an error or returns a promise that rejects (e.g., if a parsing error has happened). Set the PRETTIER_DEBUG environment variable to a non-empty value if you want Prettier to rethrow these errors.
For example, a plugin that has nodes with embedded JavaScript might have the following embed method:
function embed(path, options) {  const node = path.node;  if (node.type === "javascript") {    return async (textToDoc) => {      return [        "<script>",        hardline,        await textToDoc(node.javaScriptCode, { parser: "babel" }),        hardline,        "</script>",      ];    };  }}
If the --embedded-language-formatting option is set to off, the embedding step is entirely skipped, embed isn‚Äôt called, and all nodes are printed with the print method.
(optional) preprocess‚Äã
The preprocess method can process the AST from the parser before passing it into the print method.
function preprocess(ast: AST, options: Options): AST | Promise<AST>;
(optional) getVisitorKeys‚Äã
This property might come in handy if the plugin uses comment attachment or embedded languages. These features traverse the AST iterating through all the own enumerable properties of each node starting from the root. If the AST has cycles, such a traverse ends up in an infinite loop. Also, nodes might contain non-node objects (e.g., location data), iterating through which is a waste of resources. To solve these issues, the printer can define a function to return property names that should be traversed.
Its signature is:
function getVisitorKeys(node, nonTraversableKeys: Set<string>): string[];
The default getVisitorKeys:
function getVisitorKeys(node, nonTraversableKeys) {  return Object.keys(node).filter((key) => !nonTraversableKeys.has(key));}
The second argument nonTraversableKeys is a set of common keys and keys that prettier used internal.
If you have full list of visitor keys
const visitorKeys = {  Program: ["body"],  Identifier: [],  // ...};function getVisitorKeys(node /* , nonTraversableKeys*/) {  // Return `[]` for unknown node to prevent Prettier fallback to use `Object.keys()`  return visitorKeys[node.type] ?? [];}
If you only need exclude a small set of keys
const ignoredKeys = new Set(["prev", "next", "range"]);function getVisitorKeys(node, nonTraversableKeys) {  return Object.keys(node).filter(    (key) => !nonTraversableKeys.has(key) && !ignoredKeys.has(key),  );}
(optional) insertPragma‚Äã
A plugin can implement how a pragma comment is inserted in the resulting code when the --insert-pragma option is used, in the insertPragma function. Its signature is:
function insertPragma(text: string): string;
Handling comments in a printer‚Äã
Comments are often not part of a language's AST and present a challenge for pretty printers. A Prettier plugin can either print comments itself in its print function or rely on Prettier's comment algorithm.
By default, if the AST has a top-level comments property, Prettier assumes that comments stores an array of comment nodes. Prettier will then use the provided parsers[<plugin>].locStart/locEnd functions to search for the AST node that each comment "belongs" to. Comments are then attached to these nodes mutating the AST in the process, and the comments property is deleted from the AST root. The *Comment functions are used to adjust Prettier's algorithm. Once the comments are attached to the AST, Prettier will automatically call the printComment(path, options): Doc function and insert the returned doc into the (hopefully) correct place.
(optional) getCommentChildNodes‚Äã
By default, Prettier searches all object properties (except for a few predefined ones) of each node recursively. This function can be provided to override that behavior. It has the signature:
function getCommentChildNodes(  // The node whose children should be returned.  node: AST,  // Current options  options: object,): AST[] | undefined;
Return [] if the node has no children or undefined to fall back on the default behavior.
(optional) printComment‚Äã
Called whenever a comment node needs to be printed. It has the signature:
function printComment(  // Path to the current comment node  commentPath: AstPath,  // Current options  options: object,): Doc;
(optional) canAttachComment‚Äã
function canAttachComment(node: AST): boolean;
This function is used for deciding whether a comment can be attached to a particular AST node. By default, all AST properties are traversed searching for nodes that comments can be attached to. This function is used to prevent comments from being attached to a particular node. A typical implementation looks like
function canAttachComment(node) {  return node.type && node.type !== "comment";}
(optional) isBlockComment‚Äã
function isBlockComment(node: AST): boolean;
Returns whether or not the AST node is a block comment.
(optional) handleComments‚Äã
The handleComments object contains three optional functions, each with signature
(  // The AST node corresponding to the comment  comment: AST,  // The full source code text  text: string,  // The global options object  options: object,  // The AST  ast: AST,  // Whether this comment is the last comment  isLastComment: boolean,) => boolean;
These functions are used to override Prettier's default comment attachment algorithm. ownLine/endOfLine/remaining is expected to either manually attach a comment to a node and return true, or return false and let Prettier attach the comment.
Based on the text surrounding a comment node, Prettier dispatches:

ownLine if a comment has only whitespace preceding it and a newline afterwards,
endOfLine if a comment has a newline afterwards but some non-whitespace preceding it,
remaining in all other cases.

At the time of dispatching, Prettier will have annotated each AST comment node (i.e., created new properties) with at least one of enclosingNode, precedingNode, or followingNode. These can be used to aid a plugin's decision process (of course the entire AST and original text is also passed in for making more complicated decisions).
Manually attaching a comment‚Äã
The util.addTrailingComment/addLeadingComment/addDanglingComment functions can be used to manually attach a comment to an AST node. An example ownLine function that ensures a comment does not follow a "punctuation" node (made up for demonstration purposes) might look like:
import { util } from "prettier";function ownLine(comment, text, options, ast, isLastComment) {  const { precedingNode } = comment;  if (precedingNode && precedingNode.type === "punctuation") {    util.addTrailingComment(precedingNode, comment);    return true;  }  return false;}
Nodes with comments are expected to have a comments property containing an array of comments. Each comment is expected to have the following properties: leading, trailing, printed.
The example above uses util.addTrailingComment, which automatically sets comment.leading/trailing/printed to appropriate values and adds the comment to the AST node's comments array.
The --debug-print-comments CLI flag can help with debugging comment attachment issues. It prints a detailed list of comments, which includes information on how every comment was classified (ownLine/endOfLine/remaining, leading/trailing/dangling) and to which node it was attached. For Prettier‚Äôs built-in languages, this information is also available on the Playground (the 'show comments' checkbox in the Debug section).
options‚Äã
options is an object containing the custom options your plugin supports.
Example:
export default {  // ... plugin implementation  options: {    openingBraceNewLine: {      type: "boolean",      category: "Global",      default: true,      description: "Move open brace for code blocks onto new line.",    },  },};
defaultOptions‚Äã
If your plugin requires different default values for some of Prettier‚Äôs core options, you can specify them in defaultOptions:
export default {  // ... plugin implementation  defaultOptions: {    tabWidth: 4,  },};
Utility functions‚Äã
A util module from Prettier core is considered a private API and is not meant to be consumed by plugins. Instead, the util-shared module provides the following limited set of utility functions for plugins:
type Quote = '"' | "'";type SkipOptions = { backwards?: boolean };function getMaxContinuousCount(text: string, searchString: string): number;function getStringWidth(text: string): number;function getAlignmentSize(  text: string,  tabWidth: number,  startIndex?: number,): number;function getIndentSize(value: string, tabWidth: number): number;function skip(  characters: string | RegExp,): (  text: string,  startIndex: number | false,  options?: SkipOptions,) => number | false;function skipWhitespace(  text: string,  startIndex: number | false,  options?: SkipOptions,): number | false;function skipSpaces(  text: string,  startIndex: number | false,  options?: SkipOptions,): number | false;function skipToLineEnd(  text: string,  startIndex: number | false,  options?: SkipOptions,): number | false;function skipEverythingButNewLine(  text: string,  startIndex: number | false,  options?: SkipOptions,): number | false;function skipInlineComment(  text: string,  startIndex: number | false,): number | false;function skipTrailingComment(  text: string,  startIndex: number | false,): number | false;function skipNewline(  text: string,  startIndex: number | false,  options?: SkipOptions,): number | false;function hasNewline(  text: string,  startIndex: number,  options?: SkipOptions,): boolean;function hasNewlineInRange(  text: string,  startIndex: number,  startIndex: number,): boolean;function hasSpaces(  text: string,  startIndex: number,  options?: SkipOptions,): boolean;function getPreferredQuote(  text: string,  preferredQuoteOrPreferSingleQuote: Quote | boolean,): Quote;function makeString(  rawText: string,  enclosingQuote: Quote,  unescapeUnnecessaryEscapes?: boolean,): string;function getNextNonSpaceNonCommentCharacter(  text: string,  startIndex: number,): string;function getNextNonSpaceNonCommentCharacterIndex(  text: string,  startIndex: number,): number | false;function isNextLineEmpty(text: string, startIndex: number): boolean;function isPreviousLineEmpty(text: string, startIndex: number): boolean;
Tutorials‚Äã

How to write a plugin for Prettier: Teaches you how to write a very basic Prettier plugin for TOML.

Testing Plugins‚Äã
Since plugins can be resolved using relative paths, when working on one you can do:
import * as prettier from "prettier";const code = "(add 1 2)";await prettier.format(code, {  parser: "lisp",  plugins: ["."],});
This will resolve a plugin relative to the current working directory.Edit this page\n\nOn this pagePluginsPlugins are ways of adding new languages or formatting rules to Prettier. Prettier‚Äôs own implementations of all languages are expressed using the plugin API. The core prettier package contains JavaScript and other web-focused languages built in. For additional languages you‚Äôll need to install a plugin.
Using Plugins‚Äã
You can load plugins with:


The CLI, via --plugin:
prettier --write main.foo --plugin=prettier-plugin-foo
tipYou can set --plugin options multiple times.


The API, via the plugins options:
await prettier.format("code", {  parser: "foo",  plugins: ["prettier-plugin-foo"],});


The Configuration File:
{  "plugins": ["prettier-plugin-foo"]}


Strings provided to plugins are ultimately passed to import() expression, so you can provide a module/package name, a path, or anything else import() takes.
Official Plugins‚Äã

@prettier/plugin-php
@prettier/plugin-pug by @Shinigami92
@prettier/plugin-ruby
@prettier/plugin-xml

Community Plugins‚Äã

prettier-plugin-apex by @dangmai
prettier-plugin-astro by @withastro contributors
prettier-plugin-elm by @giCentre
prettier-plugin-erb by @adamzapasnik
prettier-plugin-gherkin by @mapado
prettier-plugin-glsl by @NaridaL
prettier-plugin-go-template by @NiklasPor
prettier-plugin-java by @JHipster
prettier-plugin-jinja-template by @davidodenwald
prettier-plugin-jsonata by @Stedi
prettier-plugin-kotlin by @Angry-Potato
prettier-plugin-motoko by @dfinity
prettier-plugin-nginx by @joedeandev
prettier-plugin-prisma by @umidbekk
prettier-plugin-properties by @eemeli
prettier-plugin-rust by @jinxdash
prettier-plugin-sh by @JounQin
prettier-plugin-sql by @JounQin
prettier-plugin-sql-cst by @nene
prettier-plugin-solidity by @mattiaerre
prettier-plugin-svelte by @sveltejs
prettier-plugin-toml by @bd82

Developing Plugins‚Äã
Prettier plugins are regular JavaScript modules with the following five exports or default export with the following properties:

languages
parsers
printers
options
defaultOptions

languages‚Äã
Languages is an array of language definitions that your plugin will contribute to Prettier. It can include all of the fields specified in prettier.getSupportInfo().
It must include name and parsers.
export const languages = [  {    // The language name    name: "InterpretedDanceScript",    // Parsers that can parse this language.    // This can be built-in parsers, or parsers you have contributed via this plugin.    parsers: ["dance-parse"],  },];
parsers‚Äã
Parsers convert code as a string into an AST.
The key must match the name in the parsers array from languages. The value contains a parse function, an AST format name, and two location extraction functions (locStart and locEnd).
export const parsers = {  "dance-parse": {    parse,    // The name of the AST that the parser produces.    astFormat: "dance-ast",    hasPragma,    locStart,    locEnd,    preprocess,  },};
The signature of the parse function is:
function parse(text: string, options: object): Promise<AST> | AST;
The location extraction functions (locStart and locEnd) return the starting and ending locations of a given AST node:
function locStart(node: object): number;
(Optional) The pragma detection function (hasPragma) should return if the text contains the pragma comment.
function hasPragma(text: string): boolean;
(Optional) The preprocess function can process the input text before passing into parse function.
function preprocess(text: string, options: object): string;
printers‚Äã
Printers convert ASTs into a Prettier intermediate representation, also known as a Doc.
The key must match the astFormat that the parser produces. The value contains an object with a print function. All other properties (embed, preprocess, etc.) are optional.
export const printers = {  "dance-ast": {    print,    embed,    preprocess,    getVisitorKeys,    insertPragma,    canAttachComment,    isBlockComment,    printComment,    getCommentChildNodes,    handleComments: {      ownLine,      endOfLine,      remaining,    },  },};
The printing process‚Äã
Prettier uses an intermediate representation, called a Doc, which Prettier then turns into a string (based on options like printWidth). A printer's job is to take the AST generated by parsers[<parser name>].parse and return a Doc. A Doc is constructed using builder commands:
import { doc } from "prettier";const { join, line, ifBreak, group } = doc.builders;
The printing process consists of the following steps:

AST preprocessing (optional). See preprocess.
Comment attachment (optional). See Handling comments in a printer.
Processing embedded languages (optional). The embed method, if defined, is called for each node, depth-first. While, for performance reasons, the recursion itself is synchronous, embed may return asynchronous functions that can call other parsers and printers to compose docs for embedded syntaxes like CSS-in-JS. These returned functions are queued up and sequentially executed before the next step.
Recursive printing. A doc is recursively constructed from the AST. Starting from the root node:

If, from the step 3, there is an embedded language doc associated with the current node, this doc is used.
Otherwise, the print(path, options, print): Doc method is called. It composes a doc for the current node, often by printing child nodes using the print callback.



print‚Äã
Most of the work of a plugin's printer will take place in its print function, whose signature is:
function print(  // Path to the AST node to print  path: AstPath,  options: object,  // Recursively print a child node  print: (selector?: string | number | Array<string | number> | AstPath) => Doc,): Doc;
The print function is passed the following parameters:

path: An object, which can be used to access nodes in the AST. It‚Äôs a stack-like data structure that maintains the current state of the recursion. It is called ‚Äúpath‚Äù because it represents the path to the current node from the root of the AST. The current node is returned by path.node.
options: A persistent object, which contains global options and which a plugin may mutate to store contextual data.
print: A callback for printing sub-nodes. This function contains the core printing logic that consists of steps whose implementation is provided by plugins. In particular, it calls the printer‚Äôs print function and passes itself to it. Thus, the two print functions ‚Äì the one from the core and the one from the plugin ‚Äì call each other while descending down the AST recursively.

Here‚Äôs a simplified example to give an idea of what a typical implementation of print looks like:
import { doc } from "prettier";const { group, indent, join, line, softline } = doc.builders;function print(path, options, print) {  const node = path.node;  switch (node.type) {    case "list":      return group([        "(",        indent([softline, join(line, path.map(print, "elements"))]),        softline,        ")",      ]);    case "pair":      return group([        "(",        indent([softline, print("left"), line, ". ", print("right")]),        softline,        ")",      ]);    case "symbol":      return node.name;  }  throw new Error(`Unknown node type: ${node.type}`);}
Check out prettier-python's printer for some examples of what is possible.
(optional) embed‚Äã
A printer can have the embed method to print one language inside another. Examples of this are printing CSS-in-JS or fenced code blocks in Markdown. The signature is:
function embed(  // Path to the current AST node  path: AstPath,  // Current options  options: Options,):  | ((      // Parses and prints the passed text using a different parser.      // You should set `options.parser` to specify which parser to use.      textToDoc: (text: string, options: Options) => Promise<Doc>,      // Prints the current node or its descendant node with the current printer      print: (        selector?: string | number | Array<string | number> | AstPath,      ) => Doc,      // The following two arguments are passed for convenience.      // They're the same `path` and `options` that are passed to `embed`.      path: AstPath,      options: Options,    ) => Promise<Doc | undefined> | Doc | undefined)  | Doc  | undefined;
The embed method is similar to the print method in that it maps AST nodes to docs, but unlike print, it has power to do async work by returning an async function. That function's first parameter, the textToDoc async function, can be used to render a doc using a different plugin.
If a function returned from embed returns a doc or a promise that resolves to a doc, that doc will be used in printing, and the print method won‚Äôt be called for this node. It's also possible and, in rare situations, might be convenient to return a doc synchronously directly from embed, however textToDoc and the print callback aren‚Äôt available at that case. Return a function to get them.
If embed returns undefined, or if a function it returned returns undefined or a promise that resolves to undefined, the node will be printed normally with the print method. Same will happen if a returned function throws an error or returns a promise that rejects (e.g., if a parsing error has happened). Set the PRETTIER_DEBUG environment variable to a non-empty value if you want Prettier to rethrow these errors.
For example, a plugin that has nodes with embedded JavaScript might have the following embed method:
function embed(path, options) {  const node = path.node;  if (node.type === "javascript") {    return async (textToDoc) => {      return [        "<script>",        hardline,        await textToDoc(node.javaScriptCode, { parser: "babel" }),        hardline,        "</script>",      ];    };  }}
If the --embedded-language-formatting option is set to off, the embedding step is entirely skipped, embed isn‚Äôt called, and all nodes are printed with the print method.
(optional) preprocess‚Äã
The preprocess method can process the AST from the parser before passing it into the print method.
function preprocess(ast: AST, options: Options): AST | Promise<AST>;
(optional) getVisitorKeys‚Äã
This property might come in handy if the plugin uses comment attachment or embedded languages. These features traverse the AST iterating through all the own enumerable properties of each node starting from the root. If the AST has cycles, such a traverse ends up in an infinite loop. Also, nodes might contain non-node objects (e.g., location data), iterating through which is a waste of resources. To solve these issues, the printer can define a function to return property names that should be traversed.
Its signature is:
function getVisitorKeys(node, nonTraversableKeys: Set<string>): string[];
The default getVisitorKeys:
function getVisitorKeys(node, nonTraversableKeys) {  return Object.keys(node).filter((key) => !nonTraversableKeys.has(key));}
The second argument nonTraversableKeys is a set of common keys and keys that prettier used internal.
If you have full list of visitor keys
const visitorKeys = {  Program: ["body"],  Identifier: [],  // ...};function getVisitorKeys(node /* , nonTraversableKeys*/) {  // Return `[]` for unknown node to prevent Prettier fallback to use `Object.keys()`  return visitorKeys[node.type] ?? [];}
If you only need exclude a small set of keys
const ignoredKeys = new Set(["prev", "next", "range"]);function getVisitorKeys(node, nonTraversableKeys) {  return Object.keys(node).filter(    (key) => !nonTraversableKeys.has(key) && !ignoredKeys.has(key),  );}
(optional) insertPragma‚Äã
A plugin can implement how a pragma comment is inserted in the resulting code when the --insert-pragma option is used, in the insertPragma function. Its signature is:
function insertPragma(text: string): string;
Handling comments in a printer‚Äã
Comments are often not part of a language's AST and present a challenge for pretty printers. A Prettier plugin can either print comments itself in its print function or rely on Prettier's comment algorithm.
By default, if the AST has a top-level comments property, Prettier assumes that comments stores an array of comment nodes. Prettier will then use the provided parsers[<plugin>].locStart/locEnd functions to search for the AST node that each comment "belongs" to. Comments are then attached to these nodes mutating the AST in the process, and the comments property is deleted from the AST root. The *Comment functions are used to adjust Prettier's algorithm. Once the comments are attached to the AST, Prettier will automatically call the printComment(path, options): Doc function and insert the returned doc into the (hopefully) correct place.
(optional) getCommentChildNodes‚Äã
By default, Prettier searches all object properties (except for a few predefined ones) of each node recursively. This function can be provided to override that behavior. It has the signature:
function getCommentChildNodes(  // The node whose children should be returned.  node: AST,  // Current options  options: object,): AST[] | undefined;
Return [] if the node has no children or undefined to fall back on the default behavior.
(optional) printComment‚Äã
Called whenever a comment node needs to be printed. It has the signature:
function printComment(  // Path to the current comment node  commentPath: AstPath,  // Current options  options: object,): Doc;
(optional) canAttachComment‚Äã
function canAttachComment(node: AST): boolean;
This function is used for deciding whether a comment can be attached to a particular AST node. By default, all AST properties are traversed searching for nodes that comments can be attached to. This function is used to prevent comments from being attached to a particular node. A typical implementation looks like
function canAttachComment(node) {  return node.type && node.type !== "comment";}
(optional) isBlockComment‚Äã
function isBlockComment(node: AST): boolean;
Returns whether or not the AST node is a block comment.
(optional) handleComments‚Äã
The handleComments object contains three optional functions, each with signature
(  // The AST node corresponding to the comment  comment: AST,  // The full source code text  text: string,  // The global options object  options: object,  // The AST  ast: AST,  // Whether this comment is the last comment  isLastComment: boolean,) => boolean;
These functions are used to override Prettier's default comment attachment algorithm. ownLine/endOfLine/remaining is expected to either manually attach a comment to a node and return true, or return false and let Prettier attach the comment.
Based on the text surrounding a comment node, Prettier dispatches:

ownLine if a comment has only whitespace preceding it and a newline afterwards,
endOfLine if a comment has a newline afterwards but some non-whitespace preceding it,
remaining in all other cases.

At the time of dispatching, Prettier will have annotated each AST comment node (i.e., created new properties) with at least one of enclosingNode, precedingNode, or followingNode. These can be used to aid a plugin's decision process (of course the entire AST and original text is also passed in for making more complicated decisions).
Manually attaching a comment‚Äã
The util.addTrailingComment/addLeadingComment/addDanglingComment functions can be used to manually attach a comment to an AST node. An example ownLine function that ensures a comment does not follow a "punctuation" node (made up for demonstration purposes) might look like:
import { util } from "prettier";function ownLine(comment, text, options, ast, isLastComment) {  const { precedingNode } = comment;  if (precedingNode && precedingNode.type === "punctuation") {    util.addTrailingComment(precedingNode, comment);    return true;  }  return false;}
Nodes with comments are expected to have a comments property containing an array of comments. Each comment is expected to have the following properties: leading, trailing, printed.
The example above uses util.addTrailingComment, which automatically sets comment.leading/trailing/printed to appropriate values and adds the comment to the AST node's comments array.
The --debug-print-comments CLI flag can help with debugging comment attachment issues. It prints a detailed list of comments, which includes information on how every comment was classified (ownLine/endOfLine/remaining, leading/trailing/dangling) and to which node it was attached. For Prettier‚Äôs built-in languages, this information is also available on the Playground (the 'show comments' checkbox in the Debug section).
options‚Äã
options is an object containing the custom options your plugin supports.
Example:
export default {  // ... plugin implementation  options: {    openingBraceNewLine: {      type: "boolean",      category: "Global",      default: true,      description: "Move open brace for code blocks onto new line.",    },  },};
defaultOptions‚Äã
If your plugin requires different default values for some of Prettier‚Äôs core options, you can specify them in defaultOptions:
export default {  // ... plugin implementation  defaultOptions: {    tabWidth: 4,  },};
Utility functions‚Äã
A util module from Prettier core is considered a private API and is not meant to be consumed by plugins. Instead, the util-shared module provides the following limited set of utility functions for plugins:
type Quote = '"' | "'";type SkipOptions = { backwards?: boolean };function getMaxContinuousCount(text: string, searchString: string): number;function getStringWidth(text: string): number;function getAlignmentSize(  text: string,  tabWidth: number,  startIndex?: number,): number;function getIndentSize(value: string, tabWidth: number): number;function skip(  characters: string | RegExp,): (  text: string,  startIndex: number | false,  options?: SkipOptions,) => number | false;function skipWhitespace(  text: string,  startIndex: number | false,  options?: SkipOptions,): number | false;function skipSpaces(  text: string,  startIndex: number | false,  options?: SkipOptions,): number | false;function skipToLineEnd(  text: string,  startIndex: number | false,  options?: SkipOptions,): number | false;function skipEverythingButNewLine(  text: string,  startIndex: number | false,  options?: SkipOptions,): number | false;function skipInlineComment(  text: string,  startIndex: number | false,): number | false;function skipTrailingComment(  text: string,  startIndex: number | false,): number | false;function skipNewline(  text: string,  startIndex: number | false,  options?: SkipOptions,): number | false;function hasNewline(  text: string,  startIndex: number,  options?: SkipOptions,): boolean;function hasNewlineInRange(  text: string,  startIndex: number,  startIndex: number,): boolean;function hasSpaces(  text: string,  startIndex: number,  options?: SkipOptions,): boolean;function getPreferredQuote(  text: string,  preferredQuoteOrPreferSingleQuote: Quote | boolean,): Quote;function makeString(  rawText: string,  enclosingQuote: Quote,  unescapeUnnecessaryEscapes?: boolean,): string;function getNextNonSpaceNonCommentCharacter(  text: string,  startIndex: number,): string;function getNextNonSpaceNonCommentCharacterIndex(  text: string,  startIndex: number,): number | false;function isNextLineEmpty(text: string, startIndex: number): boolean;function isPreviousLineEmpty(text: string, startIndex: number): boolean;
Tutorials‚Äã

How to write a plugin for Prettier: Teaches you how to write a very basic Prettier plugin for TOML.

Testing Plugins‚Äã
Since plugins can be resolved using relative paths, when working on one you can do:
import * as prettier from "prettier";const code = "(add 1 2)";await prettier.format(code, {  parser: "lisp",  plugins: ["."],});
This will resolve a plugin relative to the current working directory.Edit this pagePreviousPre-commit HookNextCLIUsing PluginsOfficial PluginsCommunity PluginsDeveloping PluginslanguagesparsersprintersoptionsdefaultOptionsUtility functionsTutorialsTesting Plugins\n\n\n\nOn this pageWhat is Prettier?Prettier is an opinionated code formatter with support for:

JavaScript (including experimental features)
JSX
Angular
Vue
Flow
TypeScript
CSS, Less, and SCSS
HTML
Ember/Handlebars
JSON
GraphQL
Markdown, including GFM and MDX v1
YAML

It removes all original styling* and ensures that all outputted code conforms to a consistent style. (See this blog post)
Prettier takes your code and reprints it from scratch by taking the line length into account.
For example, take the following code:
foo(arg1, arg2, arg3, arg4);
It fits in a single line so it‚Äôs going to stay as is. However, we've all run into this situation:
foo(reallyLongArg(), omgSoManyParameters(), IShouldRefactorThis(), isThereSeriouslyAnotherOne());
Suddenly our previous format for calling function breaks down because this is too long. Prettier is going to do the painstaking work of reprinting it like that for you:
foo(  reallyLongArg(),  omgSoManyParameters(),  IShouldRefactorThis(),  isThereSeriouslyAnotherOne(),);
Prettier enforces a consistent code style (i.e. code formatting that won‚Äôt affect the AST) across your entire codebase because it disregards the original styling* by parsing it away and re-printing the parsed AST with its own rules that take the maximum line length into account, wrapping code when necessary.
If you want to learn more, these two conference talks are great introductions:


Footnotes‚Äã
* Well actually, some original styling is preserved when practical‚Äîsee empty lines and multi-line objects.Edit this page\n\nOn this pageWhat is Prettier?Prettier is an opinionated code formatter with support for:

JavaScript (including experimental features)
JSX
Angular
Vue
Flow
TypeScript
CSS, Less, and SCSS
HTML
Ember/Handlebars
JSON
GraphQL
Markdown, including GFM and MDX v1
YAML

It removes all original styling* and ensures that all outputted code conforms to a consistent style. (See this blog post)
Prettier takes your code and reprints it from scratch by taking the line length into account.
For example, take the following code:
foo(arg1, arg2, arg3, arg4);
It fits in a single line so it‚Äôs going to stay as is. However, we've all run into this situation:
foo(reallyLongArg(), omgSoManyParameters(), IShouldRefactorThis(), isThereSeriouslyAnotherOne());
Suddenly our previous format for calling function breaks down because this is too long. Prettier is going to do the painstaking work of reprinting it like that for you:
foo(  reallyLongArg(),  omgSoManyParameters(),  IShouldRefactorThis(),  isThereSeriouslyAnotherOne(),);
Prettier enforces a consistent code style (i.e. code formatting that won‚Äôt affect the AST) across your entire codebase because it disregards the original styling* by parsing it away and re-printing the parsed AST with its own rules that take the maximum line length into account, wrapping code when necessary.
If you want to learn more, these two conference talks are great introductions:


Footnotes‚Äã
* Well actually, some original styling is preserved when practical‚Äîsee empty lines and multi-line objects.Edit this pageNextWhy Prettier?\n\n\n\nOn this pageWhat is Prettier?Prettier is an opinionated code formatter with support for:

JavaScript (including experimental features)
JSX
Angular
Vue
Flow
TypeScript
CSS, Less, and SCSS
HTML
Ember/Handlebars
JSON
GraphQL
Markdown, including GFM and MDX v1
YAML

It removes all original styling* and ensures that all outputted code conforms to a consistent style. (See this blog post)
Prettier takes your code and reprints it from scratch by taking the line length into account.
For example, take the following code:
foo(arg1, arg2, arg3, arg4);
It fits in a single line so it‚Äôs going to stay as is. However, we've all run into this situation:
foo(reallyLongArg(), omgSoManyParameters(), IShouldRefactorThis(), isThereSeriouslyAnotherOne());
Suddenly our previous format for calling function breaks down because this is too long. Prettier is going to do the painstaking work of reprinting it like that for you:
foo(  reallyLongArg(),  omgSoManyParameters(),  IShouldRefactorThis(),  isThereSeriouslyAnotherOne(),);
Prettier enforces a consistent code style (i.e. code formatting that won‚Äôt affect the AST) across your entire codebase because it disregards the original styling* by parsing it away and re-printing the parsed AST with its own rules that take the maximum line length into account, wrapping code when necessary.
If you want to learn more, these two conference talks are great introductions:


Footnotes‚Äã
* Well actually, some original styling is preserved when practical‚Äîsee empty lines and multi-line objects.Edit this page\n\nOn this pageWhat is Prettier?Prettier is an opinionated code formatter with support for:

JavaScript (including experimental features)
JSX
Angular
Vue
Flow
TypeScript
CSS, Less, and SCSS
HTML
Ember/Handlebars
JSON
GraphQL
Markdown, including GFM and MDX v1
YAML

It removes all original styling* and ensures that all outputted code conforms to a consistent style. (See this blog post)
Prettier takes your code and reprints it from scratch by taking the line length into account.
For example, take the following code:
foo(arg1, arg2, arg3, arg4);
It fits in a single line so it‚Äôs going to stay as is. However, we've all run into this situation:
foo(reallyLongArg(), omgSoManyParameters(), IShouldRefactorThis(), isThereSeriouslyAnotherOne());
Suddenly our previous format for calling function breaks down because this is too long. Prettier is going to do the painstaking work of reprinting it like that for you:
foo(  reallyLongArg(),  omgSoManyParameters(),  IShouldRefactorThis(),  isThereSeriouslyAnotherOne(),);
Prettier enforces a consistent code style (i.e. code formatting that won‚Äôt affect the AST) across your entire codebase because it disregards the original styling* by parsing it away and re-printing the parsed AST with its own rules that take the maximum line length into account, wrapping code when necessary.
If you want to learn more, these two conference talks are great introductions:


Footnotes‚Äã
* Well actually, some original styling is preserved when practical‚Äîsee empty lines and multi-line objects.Edit this pageNextWhy Prettier?\n\n\n\nOn this pageWhat is Prettier?Prettier is an opinionated code formatter with support for:

JavaScript (including experimental features)
JSX
Angular
Vue
Flow
TypeScript
CSS, Less, and SCSS
HTML
Ember/Handlebars
JSON
GraphQL
Markdown, including GFM and MDX v1
YAML

It removes all original styling* and ensures that all outputted code conforms to a consistent style. (See this blog post)
Prettier takes your code and reprints it from scratch by taking the line length into account.
For example, take the following code:
foo(arg1, arg2, arg3, arg4);
It fits in a single line so it‚Äôs going to stay as is. However, we've all run into this situation:
foo(reallyLongArg(), omgSoManyParameters(), IShouldRefactorThis(), isThereSeriouslyAnotherOne());
Suddenly our previous format for calling function breaks down because this is too long. Prettier is going to do the painstaking work of reprinting it like that for you:
foo(  reallyLongArg(),  omgSoManyParameters(),  IShouldRefactorThis(),  isThereSeriouslyAnotherOne(),);
Prettier enforces a consistent code style (i.e. code formatting that won‚Äôt affect the AST) across your entire codebase because it disregards the original styling* by parsing it away and re-printing the parsed AST with its own rules that take the maximum line length into account, wrapping code when necessary.
If you want to learn more, these two conference talks are great introductions:


Footnotes‚Äã
* Well actually, some original styling is preserved when practical‚Äîsee empty lines and multi-line objects.Edit this page\n\nThis is unreleased documentation for Prettier next version.For up-to-date documentation, see the latest version (stable).On this pageWhat is Prettier?Prettier is an opinionated code formatter with support for:

JavaScript (including experimental features)
JSX
Angular
Vue
Flow
TypeScript
CSS, Less, and SCSS
HTML
Ember/Handlebars
JSON
GraphQL
Markdown, including GFM and MDX v1
YAML

It removes all original styling* and ensures that all outputted code conforms to a consistent style. (See this blog post)
Prettier takes your code and reprints it from scratch by taking the line length into account.
For example, take the following code:
foo(arg1, arg2, arg3, arg4);
It fits in a single line so it‚Äôs going to stay as is. However, we've all run into this situation:
foo(reallyLongArg(), omgSoManyParameters(), IShouldRefactorThis(), isThereSeriouslyAnotherOne());
Suddenly our previous format for calling function breaks down because this is too long. Prettier is going to do the painstaking work of reprinting it like that for you:
foo(  reallyLongArg(),  omgSoManyParameters(),  IShouldRefactorThis(),  isThereSeriouslyAnotherOne(),);
Prettier enforces a consistent code style (i.e. code formatting that won‚Äôt affect the AST) across your entire codebase because it disregards the original styling* by parsing it away and re-printing the parsed AST with its own rules that take the maximum line length into account, wrapping code when necessary.
If you want to learn more, these two conference talks are great introductions:


Footnotes‚Äã
* Well actually, some original styling is preserved when practical‚Äîsee empty lines and multi-line objects.Edit this pageNextWhy Prettier?\n\n\n\nOn this pageWhy Prettier?Building and enforcing a style guide‚Äã
By far the biggest reason for adopting Prettier is to stop all the on-going debates over styles. It is generally accepted that having a common style guide is valuable for a project and team but getting there is a very painful and unrewarding process. People get very emotional around particular ways of writing code and nobody likes spending time writing and receiving nits.
So why choose the ‚ÄúPrettier style guide‚Äù over any other random style guide? Because Prettier is the only ‚Äústyle guide‚Äù that is fully automatic. Even if Prettier does not format all code 100% the way you‚Äôd like, it‚Äôs worth the ‚Äúsacrifice‚Äù given the unique benefits of Prettier, don‚Äôt you think?

‚ÄúWe want to free mental threads and end discussions around style. While sometimes fruitful, these discussions are for the most part wasteful.‚Äù
‚ÄúLiterally had an engineer go through a huge effort of cleaning up all of our code because we were debating ternary style for the longest time and were inconsistent about it. It was dumb, but it was a weird on-going ‚Äúgreat debate‚Äù that wasted lots of little back and forth bits. It‚Äôs far easier for us all to agree now: just run Prettier, and go with that style.‚Äù
‚ÄúGetting tired telling people how to style their product code.‚Äù
‚ÄúOur top reason was to stop wasting our time debating style nits.‚Äù
‚ÄúHaving a githook set up has reduced the amount of style issues in PRs that result in broken builds due to ESLint rules or things I have to nit-pick or clean up later.‚Äù
‚ÄúI don‚Äôt want anybody to nitpick any other person ever again.‚Äù
‚ÄúIt reminds me of how Steve Jobs used to wear the same clothes every day because he has a million decisions to make and he didn‚Äôt want to be bothered to make trivial ones like picking out clothes. I think Prettier is like that.‚Äù

Helping Newcomers‚Äã
Prettier is usually introduced by people with experience in the current codebase and JavaScript but the people that disproportionally benefit from it are newcomers to the codebase. One may think that it‚Äôs only useful for people with very limited programming experience, but we've seen it quicken the ramp up time from experienced engineers joining the company, as they likely used a different coding style before, and developers coming from a different programming language.

‚ÄúMy motivations for using Prettier are: appearing that I know how to write JavaScript well.‚Äù
‚ÄúI always put spaces in the wrong place, now I don‚Äôt have to worry about it anymore.‚Äù
‚ÄúWhen you're a beginner you're making a lot of mistakes caused by the syntax. Thanks to Prettier, you can reduce these mistakes and save a lot of time to focus on what really matters.‚Äù
‚ÄúAs a teacher, I will also tell to my students to install Prettier to help them to learn the JS syntax and have readable files.‚Äù

Writing code‚Äã
What usually happens once people are using Prettier is that they realize that they actually spend a lot of time and mental energy formatting their code. With Prettier editor integration, you can just press that magic key binding and poof, the code is formatted. This is an eye opening experience if anything else.

‚ÄúI want to write code. Not spend cycles on formatting.‚Äù
‚ÄúIt removed 5% that sucks in our daily life - aka formatting‚Äù
‚ÄúWe're in 2017 and it‚Äôs still painful to break a call into multiple lines when you happen to add an argument that makes it go over the 80 columns limit :(‚Äú

Easy to adopt‚Äã
We've worked very hard to use the least controversial coding styles, went through many rounds of fixing all the edge cases and polished the getting started experience. When you're ready to push Prettier into your codebase, not only should it be painless for you to do it technically but the newly formatted codebase should not generate major controversy and be accepted painlessly by your co-workers.

‚ÄúIt‚Äôs low overhead. We were able to throw Prettier at very different kinds of repos without much work.‚Äù
‚ÄúIt‚Äôs been mostly bug free. Had there been major styling issues during the course of implementation we would have been wary about throwing this at our JS codebase. I‚Äôm happy to say that‚Äôs not the case.‚Äù
‚ÄúEveryone runs it as part of their pre commit scripts, a couple of us use the editor on save extensions as well.‚Äù
‚ÄúIt‚Äôs fast, against one of our larger JS codebases we were able to run Prettier in under 13 seconds.‚Äù
‚ÄúThe biggest benefit for Prettier for us was being able to format the entire code base at once.‚Äù

Clean up an existing codebase‚Äã
Since coming up with a coding style and enforcing it is a big undertaking, it often slips through the cracks and you are left working on inconsistent codebases. Running Prettier in this case is a quick win, the codebase is now uniform and easier to read without spending hardly any time.

‚ÄúTake a look at the code :) I just need to restore sanity.‚Äù
‚ÄúWe inherited a ~2000 module ES6 code base, developed by 20 different developers over 18 months, in a global team. Felt like such a win without much research.‚Äù

Ride the hype train‚Äã
Purely technical aspects of the projects aren‚Äôt the only thing people look into when choosing to adopt Prettier. Who built and uses it and how quickly it spreads through the community has a non-trivial impact.

‚ÄúThe amazing thing, for me, is: 1) Announced 2 months ago. 2) Already adopted by, it seems, every major JS project. 3) 7000 stars, 100,000 npm downloads/mo‚Äù
‚ÄúWas built by the same people as React & React Native.‚Äù
‚ÄúI like to be part of the hot new things.‚Äù
‚ÄúBecause soon enough people are gonna ask for it.‚Äù
Edit this page\n\nThis is unreleased documentation for Prettier next version.For up-to-date documentation, see the latest version (stable).On this pageWhy Prettier?Building and enforcing a style guide‚Äã
By far the biggest reason for adopting Prettier is to stop all the on-going debates over styles. It is generally accepted that having a common style guide is valuable for a project and team but getting there is a very painful and unrewarding process. People get very emotional around particular ways of writing code and nobody likes spending time writing and receiving nits.
So why choose the ‚ÄúPrettier style guide‚Äù over any other random style guide? Because Prettier is the only ‚Äústyle guide‚Äù that is fully automatic. Even if Prettier does not format all code 100% the way you‚Äôd like, it‚Äôs worth the ‚Äúsacrifice‚Äù given the unique benefits of Prettier, don‚Äôt you think?

‚ÄúWe want to free mental threads and end discussions around style. While sometimes fruitful, these discussions are for the most part wasteful.‚Äù
‚ÄúLiterally had an engineer go through a huge effort of cleaning up all of our code because we were debating ternary style for the longest time and were inconsistent about it. It was dumb, but it was a weird on-going ‚Äúgreat debate‚Äù that wasted lots of little back and forth bits. It‚Äôs far easier for us all to agree now: just run Prettier, and go with that style.‚Äù
‚ÄúGetting tired telling people how to style their product code.‚Äù
‚ÄúOur top reason was to stop wasting our time debating style nits.‚Äù
‚ÄúHaving a githook set up has reduced the amount of style issues in PRs that result in broken builds due to ESLint rules or things I have to nit-pick or clean up later.‚Äù
‚ÄúI don‚Äôt want anybody to nitpick any other person ever again.‚Äù
‚ÄúIt reminds me of how Steve Jobs used to wear the same clothes every day because he has a million decisions to make and he didn‚Äôt want to be bothered to make trivial ones like picking out clothes. I think Prettier is like that.‚Äù

Helping Newcomers‚Äã
Prettier is usually introduced by people with experience in the current codebase and JavaScript but the people that disproportionally benefit from it are newcomers to the codebase. One may think that it‚Äôs only useful for people with very limited programming experience, but we've seen it quicken the ramp up time from experienced engineers joining the company, as they likely used a different coding style before, and developers coming from a different programming language.

‚ÄúMy motivations for using Prettier are: appearing that I know how to write JavaScript well.‚Äù
‚ÄúI always put spaces in the wrong place, now I don‚Äôt have to worry about it anymore.‚Äù
‚ÄúWhen you're a beginner you're making a lot of mistakes caused by the syntax. Thanks to Prettier, you can reduce these mistakes and save a lot of time to focus on what really matters.‚Äù
‚ÄúAs a teacher, I will also tell to my students to install Prettier to help them to learn the JS syntax and have readable files.‚Äù

Writing code‚Äã
What usually happens once people are using Prettier is that they realize that they actually spend a lot of time and mental energy formatting their code. With Prettier editor integration, you can just press that magic key binding and poof, the code is formatted. This is an eye opening experience if anything else.

‚ÄúI want to write code. Not spend cycles on formatting.‚Äù
‚ÄúIt removed 5% that sucks in our daily life - aka formatting‚Äù
‚ÄúWe're in 2017 and it‚Äôs still painful to break a call into multiple lines when you happen to add an argument that makes it go over the 80 columns limit :(‚Äú

Easy to adopt‚Äã
We've worked very hard to use the least controversial coding styles, went through many rounds of fixing all the edge cases and polished the getting started experience. When you're ready to push Prettier into your codebase, not only should it be painless for you to do it technically but the newly formatted codebase should not generate major controversy and be accepted painlessly by your co-workers.

‚ÄúIt‚Äôs low overhead. We were able to throw Prettier at very different kinds of repos without much work.‚Äù
‚ÄúIt‚Äôs been mostly bug free. Had there been major styling issues during the course of implementation we would have been wary about throwing this at our JS codebase. I‚Äôm happy to say that‚Äôs not the case.‚Äù
‚ÄúEveryone runs it as part of their pre commit scripts, a couple of us use the editor on save extensions as well.‚Äù
‚ÄúIt‚Äôs fast, against one of our larger JS codebases we were able to run Prettier in under 13 seconds.‚Äù
‚ÄúThe biggest benefit for Prettier for us was being able to format the entire code base at once.‚Äù

Clean up an existing codebase‚Äã
Since coming up with a coding style and enforcing it is a big undertaking, it often slips through the cracks and you are left working on inconsistent codebases. Running Prettier in this case is a quick win, the codebase is now uniform and easier to read without spending hardly any time.

‚ÄúTake a look at the code :) I just need to restore sanity.‚Äù
‚ÄúWe inherited a ~2000 module ES6 code base, developed by 20 different developers over 18 months, in a global team. Felt like such a win without much research.‚Äù

Ride the hype train‚Äã
Purely technical aspects of the projects aren‚Äôt the only thing people look into when choosing to adopt Prettier. Who built and uses it and how quickly it spreads through the community has a non-trivial impact.

‚ÄúThe amazing thing, for me, is: 1) Announced 2 months ago. 2) Already adopted by, it seems, every major JS project. 3) 7000 stars, 100,000 npm downloads/mo‚Äù
‚ÄúWas built by the same people as React & React Native.‚Äù
‚ÄúI like to be part of the hot new things.‚Äù
‚ÄúBecause soon enough people are gonna ask for it.‚Äù
Edit this pagePreviousWhat is Prettier?NextPrettier vs. LintersBuilding and enforcing a style guideHelping NewcomersWriting codeEasy to adoptClean up an existing codebaseRide the hype train\n\n\n\nOn this pagePrettier vs. LintersHow does it compare to ESLint/TSLint/stylelint, etc.?‚Äã
Linters have two categories of rules:
Formatting rules: eg: max-len, no-mixed-spaces-and-tabs, keyword-spacing, comma-style‚Ä¶
Prettier alleviates the need for this whole category of rules! Prettier is going to reprint the entire program from scratch in a consistent way, so it‚Äôs not possible for the programmer to make a mistake there anymore :)
Code-quality rules: eg no-unused-vars, no-extra-bind, no-implicit-globals, prefer-promise-reject-errors‚Ä¶
Prettier does nothing to help with those kind of rules. They are also the most important ones provided by linters as they are likely to catch real bugs with your code!
In other words, use Prettier for formatting and linters for catching bugs!Edit this page\n\nThis is unreleased documentation for Prettier next version.For up-to-date documentation, see the latest version (stable).On this pagePrettier vs. LintersHow does it compare to ESLint/TSLint/stylelint, etc.?‚Äã
Linters have two categories of rules:
Formatting rules: eg: max-len, no-mixed-spaces-and-tabs, keyword-spacing, comma-style‚Ä¶
Prettier alleviates the need for this whole category of rules! Prettier is going to reprint the entire program from scratch in a consistent way, so it‚Äôs not possible for the programmer to make a mistake there anymore :)
Code-quality rules: eg no-unused-vars, no-extra-bind, no-implicit-globals, prefer-promise-reject-errors‚Ä¶
Prettier does nothing to help with those kind of rules. They are also the most important ones provided by linters as they are likely to catch real bugs with your code!
In other words, use Prettier for formatting and linters for catching bugs!Edit this pagePreviousWhy Prettier?NextOption PhilosophyHow does it compare to ESLint/TSLint/stylelint, etc.?\n\n\n\nOption PhilosophyinfoPrettier has a few options because of history. But we won‚Äôt add more of them.Read on to learn more.
Prettier is not a kitchen-sink code formatter that attempts to print your code in any way you wish. It is opinionated. Quoting the Why Prettier? page:

By far the biggest reason for adopting Prettier is to stop all the ongoing debates over styles.

Yet the more options Prettier has, the further from the above goal it gets. The debates over styles just turn into debates over which Prettier options to use. Formatting wars break out with renewed vigour: ‚ÄúWhich option values are better? Why? Did we make the right choices?‚Äù
And it‚Äôs not the only cost options have. To learn more about their downsides, see the issue about resisting adding configuration, which has more üëçs than any option request issue.
So why are there any options at all?

A few were added during Prettier‚Äôs infancy to make it take off at all. üöÄ
A couple were added after ‚Äúgreat demand.‚Äù ü§î
Some were added for compatibility reasons. üëç

Options that are easier to motivate include:

--trailing-comma es5 lets you use trailing commas in most environments without having to transpile (trailing function commas were added in ES2017).
--prose-wrap is important to support all quirky Markdown renderers in the wild.
--html-whitespace-sensitivity is needed due to the unfortunate whitespace rules of HTML.
--end-of-line makes it easier for teams to keep CRLFs out of their git repositories.
--quote-props is important for advanced usage of the Google Closure Compiler.

But other options are harder to motivate in hindsight: --arrow-parens, --jsx-single-quote, --bracket-same-line and --no-bracket-spacing are not the type of options we‚Äôre happy to have. They cause a lot of bike-shedding in teams, and we‚Äôre sorry for that. Difficult to remove now, these options exist as a historical artifact and should not motivate adding more options (‚ÄúIf those options exist, why can‚Äôt this one?‚Äù).
For a long time, we left option requests open in order to let discussions play out and collect feedback. What we‚Äôve learned during those years is that it‚Äôs really hard to measure demand. Prettier has grown a lot in usage. What was ‚Äúgreat demand‚Äù back in the day is not as much today. GitHub reactions and Twitter polls became unrepresentative. What about all silent users? It looked easy to add ‚Äújust one more‚Äù option. But where should we have stopped? When is one too many? Even after adding ‚Äúthat one final option‚Äù, there would always be a ‚Äútop issue‚Äù in the issue tracker.
However, the time to stop has come. Now that Prettier is mature enough and we see it adopted by so many organizations and projects, the research phase is over. We have enough confidence to conclude that Prettier reached a point where the set of options should be ‚Äúfrozen‚Äù. Option requests aren‚Äôt accepted anymore. We‚Äôre thankful to everyone who participated in this difficult journey.
Please note that as option requests are out of scope for Prettier, they will be closed without discussion. The same applies to requests to preserve elements of input formatting (e.g. line breaks) since that‚Äôs nothing else but an option in disguise with all the downsides of ‚Äúreal‚Äù options. There may be situations where adding an option can‚Äôt be avoided because of technical necessity (e.g. compatibility), but for formatting-related options, this is final.Edit this page\n\nThis is unreleased documentation for Prettier next version.For up-to-date documentation, see the latest version (stable).Option PhilosophyinfoPrettier has a few options because of history. But we won‚Äôt add more of them.Read on to learn more.
Prettier is not a kitchen-sink code formatter that attempts to print your code in any way you wish. It is opinionated. Quoting the Why Prettier? page:

By far the biggest reason for adopting Prettier is to stop all the ongoing debates over styles.

Yet the more options Prettier has, the further from the above goal it gets. The debates over styles just turn into debates over which Prettier options to use. Formatting wars break out with renewed vigour: ‚ÄúWhich option values are better? Why? Did we make the right choices?‚Äù
And it‚Äôs not the only cost options have. To learn more about their downsides, see the issue about resisting adding configuration, which has more üëçs than any option request issue.
So why are there any options at all?

A few were added during Prettier‚Äôs infancy to make it take off at all. üöÄ
A couple were added after ‚Äúgreat demand.‚Äù ü§î
Some were added for compatibility reasons. üëç

Options that are easier to motivate include:

--trailing-comma es5 lets you use trailing commas in most environments without having to transpile (trailing function commas were added in ES2017).
--prose-wrap is important to support all quirky Markdown renderers in the wild.
--html-whitespace-sensitivity is needed due to the unfortunate whitespace rules of HTML.
--end-of-line makes it easier for teams to keep CRLFs out of their git repositories.
--quote-props is important for advanced usage of the Google Closure Compiler.

But other options are harder to motivate in hindsight: --arrow-parens, --jsx-single-quote, --bracket-same-line and --no-bracket-spacing are not the type of options we‚Äôre happy to have. They cause a lot of bike-shedding in teams, and we‚Äôre sorry for that. Difficult to remove now, these options exist as a historical artifact and should not motivate adding more options (‚ÄúIf those options exist, why can‚Äôt this one?‚Äù).
For a long time, we left option requests open in order to let discussions play out and collect feedback. What we‚Äôve learned during those years is that it‚Äôs really hard to measure demand. Prettier has grown a lot in usage. What was ‚Äúgreat demand‚Äù back in the day is not as much today. GitHub reactions and Twitter polls became unrepresentative. What about all silent users? It looked easy to add ‚Äújust one more‚Äù option. But where should we have stopped? When is one too many? Even after adding ‚Äúthat one final option‚Äù, there would always be a ‚Äútop issue‚Äù in the issue tracker.
However, the time to stop has come. Now that Prettier is mature enough and we see it adopted by so many organizations and projects, the research phase is over. We have enough confidence to conclude that Prettier reached a point where the set of options should be ‚Äúfrozen‚Äù. Option requests aren‚Äôt accepted anymore. We‚Äôre thankful to everyone who participated in this difficult journey.
Please note that as option requests are out of scope for Prettier, they will be closed without discussion. The same applies to requests to preserve elements of input formatting (e.g. line breaks) since that‚Äôs nothing else but an option in disguise with all the downsides of ‚Äúreal‚Äù options. There may be situations where adding an option can‚Äôt be avoided because of technical necessity (e.g. compatibility), but for formatting-related options, this is final.Edit this pagePreviousPrettier vs. LintersNextRationale\n\n\n\nOn this pageRationalePrettier is an opinionated code formatter. This document explains some of its choices.
What Prettier is concerned about‚Äã
Correctness‚Äã
The first requirement of Prettier is to output valid code that has the exact same behavior as before formatting. Please report any code where Prettier fails to follow these correctness rules ‚Äî that‚Äôs a bug which needs to be fixed!
Strings‚Äã
Double or single quotes? Prettier chooses the one which results in the fewest number of escapes. "It's gettin' better!", not 'It\'s gettin\' better!'. In case of a tie or the string not containing any quotes, Prettier defaults to double quotes (but that can be changed via the singleQuote option).
JSX has its own option for quotes: jsxSingleQuote.
JSX takes its roots from HTML, where the dominant use of quotes for attributes is double quotes. Browser developer tools also follow this convention by always displaying HTML with double quotes, even if the source code uses single quotes. A separate option allows using single quotes for JS and double quotes for "HTML" (JSX).
Prettier maintains the way your string is escaped. For example, "üôÇ" won‚Äôt be formatted into "\uD83D\uDE42" and vice versa.
Empty lines‚Äã
It turns out that empty lines are very hard to automatically generate. The approach that Prettier takes is to preserve empty lines the way they were in the original source code. There are two additional rules:

Prettier collapses multiple blank lines into a single blank line.
Empty lines at the start and end of blocks (and whole files) are removed. (Files always end with a single newline, though.)

Multi-line objects‚Äã
By default, Prettier‚Äôs printing algorithm prints expressions on a single line if they fit. Objects are used for a lot of different things in JavaScript, though, and sometimes it really helps readability if they stay multiline. See object lists, nested configs, stylesheets and keyed methods, for example. We haven‚Äôt been able to find a good rule for all those cases, so by default Prettier keeps objects multi-line if there‚Äôs a newline between the { and the first key in the original source code. Consequently, long single-line objects are automatically expanded, but short multi-line objects are never collapsed.
You can disable this conditional behavior with the objectWrap option.
Tip: If you have a multi-line object that you‚Äôd like to join up into a single line:
const user = {  name: "John Doe",  age: 30,};
‚Ä¶all you need to do is remove the newline after {:
const user = {  name: "John Doe",  age: 30};
‚Ä¶and then run Prettier:
const user = { name: "John Doe", age: 30 };
And if you‚Äôd like to go multi-line again, add in a newline after {:
const user = { name: "John Doe", age: 30 };
‚Ä¶and run Prettier:
const user = {  name: "John Doe",  age: 30,};
A note on formatting reversibilityThe semi-manual formatting for object literals is in fact a workaround, not a feature. It was implemented only because at the time a good heuristic wasn‚Äôt found and an urgent fix was needed. However, as a general strategy, Prettier avoids non-reversible formatting like that, so the team is still looking for heuristics that would allow either to remove this behavior completely or at least to reduce the number of situations where it‚Äôs applied.What does reversible mean? Once an object literal becomes multiline, Prettier won‚Äôt collapse it back. If in Prettier-formatted code, we add a property to an object literal, run Prettier, then change our mind, remove the added property, and then run Prettier again, we might end up with a formatting not identical to the initial one. This useless change might even get included in a commit, which is exactly the kind of situation Prettier was created to prevent.
Decorators‚Äã
Just like with objects, decorators are used for a lot of different things. Sometimes it makes sense to write decorators above the line they're decorating, sometimes it‚Äôs nicer if they're on the same line. We haven‚Äôt been able to find a good rule for this, so Prettier keeps your decorator positioned like you wrote them (if they fit on the line). This isn‚Äôt ideal, but a pragmatic solution to a difficult problem.
@Component({  selector: "hero-button",  template: `<button>{{ label }}</button>`,})class HeroButtonComponent {  // These decorators were written inline and fit on the line so they stay  // inline.  @Output() change = new EventEmitter();  @Input() label: string;  // These were written multiline, so they stay multiline.  @readonly  @nonenumerable  NODE_TYPE: 2;}
There‚Äôs one exception: classes. We don‚Äôt think it ever makes sense to inline the decorators for them, so they are always moved to their own line.
// Before running Prettier:@observer class OrderLine {  @observable price: number = 0;}
// After running Prettier:@observerclass OrderLine {  @observable price: number = 0;}
Note: Prettier 1.14.x and older tried to automatically move your decorators, so if you've run an older Prettier version on your code you might need to manually join up some decorators here and there to avoid inconsistencies:
@observerclass OrderLine {  @observable price: number = 0;  @observable  amount: number = 0;}
One final thing: TC39 has not yet decided if decorators come before or after export. In the meantime, Prettier supports both:
@decorator export class Foo {}export @decorator class Foo {}
Template literals‚Äã
Template literals can contain interpolations. Deciding whether it's appropriate to insert a linebreak within an interpolation unfortunately depends on the semantic content of the template - for example, introducing a linebreak in the middle of a natural-language sentence is usually undesirable. Since Prettier doesn't have enough information to make this decision itself, it uses a heuristic similar to that used for objects: it will only split an interpolation expression across multiple lines if there was already a linebreak within that interpolation.
This means that a literal like the following will not be broken onto multiple lines, even if it exceeds the print width:
`this is a long message which contains an interpolation: ${format(data)} <- like this`;
If you want Prettier to split up an interpolation, you'll need to ensure there's a linebreak somewhere within the ${...}. Otherwise it will keep everything on a single line, no matter how long it is.
The team would prefer not to depend on the original formatting in this way, but it's the best heuristic we have at the moment.
Semicolons‚Äã
This is about using the noSemi option.
Consider this piece of code:
if (shouldAddLines) {  [-1, 1].forEach(delta => addLine(delta * 20))}
While the above code works just fine without semicolons, Prettier actually turns it into:
if (shouldAddLines) {  ;[-1, 1].forEach(delta => addLine(delta * 20))}
This is to help you avoid mistakes. Imagine Prettier not inserting that semicolon and adding this line:
 if (shouldAddLines) {+  console.log('Do we even get here??')   [-1, 1].forEach(delta => addLine(delta * 20)) }
Oops! The above actually means:
if (shouldAddLines) {  console.log('Do we even get here??')[-1, 1].forEach(delta => addLine(delta * 20))}
With a semicolon in front of that [ such issues never happen. It makes the line independent of other lines so you can move and add lines without having to think about ASI rules.
This practice is also common in standard which uses a semicolon-free style.
Note that if your program currently has a semicolon-related bug in it, Prettier will not auto-fix the bug for you. Remember, Prettier only reformats code, it does not change the behavior of the code. Take this buggy piece of code as an example, where the developer forgot to place a semicolon before the (:
console.log('Running a background task')(async () => {  await doBackgroundWork()})()
If you feed this into Prettier, it will not alter the behavior of this code, instead, it will reformat it in a way that shows how this code will actually behave when ran.
console.log("Running a background task")(async () => {  await doBackgroundWork();})();
Print width‚Äã
The printWidth option is more of a guideline to Prettier than a hard rule. It is not the upper allowed line length limit. It is a way to say to Prettier roughly how long you‚Äôd like lines to be. Prettier will make both shorter and longer lines, but generally strive to meet the specified print width.
There are some edge cases, such as really long string literals, regexps, comments and variable names, which cannot be broken across lines (without using code transforms which Prettier doesn‚Äôt do). Or if you nest your code 50 levels deep your lines are of course going to be mostly indentation :)
Apart from that, there are a few cases where Prettier intentionally exceeds the print width.
Imports‚Äã
Prettier can break long import statements across several lines:
import {  CollectionDashboard,  DashboardPlaceholder,} from "../components/collections/collection-dashboard/main";
The following example doesn‚Äôt fit within the print width, but Prettier prints it in a single line anyway:
import { CollectionDashboard } from "../components/collections/collection-dashboard/main";
This might be unexpected by some, but we do it this way since it was a common request to keep imports with single elements in a single line. The same applies for require calls.
Testing functions‚Äã
Another common request was to keep lengthy test descriptions in one line, even if it gets too long. In such cases, wrapping the arguments to new lines doesn‚Äôt help much.
describe("NodeRegistry", () => {  it("makes no request if there are no nodes to prefetch, even if the cache is stale", async () => {    // The above line exceeds the print width but stayed on one line anyway.  });});
Prettier has special cases for common testing framework functions such as describe, it and test.
JSX‚Äã
Prettier prints things a little differently compared to other JS when JSX is involved:
function greet(user) {  return user    ? `Welcome back, ${user.name}!`    : "Greetings, traveler! Sign up today!";}function Greet({ user }) {  return (    <div>      {user ? (        <p>Welcome back, {user.name}!</p>      ) : (        <p>Greetings, traveler! Sign up today!</p>      )}    </div>  );}
There are two reasons.
First off, lots of people already wrapped their JSX in parentheses, especially in return statements. Prettier follows this common style.
Secondly, the alternate formatting makes it easier to edit the JSX. It is easy to leave a semicolon behind. As opposed to normal JS, a leftover semicolon in JSX can end up as plain text showing on your page.
<div>  <p>Greetings, traveler! Sign up today!</p>; {/* <-- Oops! */}</div>
Comments‚Äã
When it comes to the content of comments, Prettier can‚Äôt do much really. Comments can contain everything from prose to commented out code and ASCII diagrams. Since they can contain anything, Prettier can‚Äôt know how to format or wrap them. So they are left as-is. The only exception to this are JSDoc-style comments (block comments where every line starts with a *), which Prettier can fix the indentation of.
Then there‚Äôs the question of where to put the comments. Turns out this is a really difficult problem. Prettier tries its best to keep your comments roughly where they were, but it‚Äôs no easy task because comments can be placed almost anywhere.
Generally, you get the best results when placing comments on their own lines, instead of at the end of lines. Prefer // eslint-disable-next-line over // eslint-disable-line.
Note that ‚Äúmagic comments‚Äù such as eslint-disable-next-line and $FlowFixMe might sometimes need to be manually moved due to Prettier breaking an expression into multiple lines.
Imagine this piece of code:
// eslint-disable-next-line no-evalconst result = safeToEval ? eval(input) : fallback(input);
Then you need to add another condition:
// eslint-disable-next-line no-evalconst result = safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);
Prettier will turn the above into:
// eslint-disable-next-line no-evalconst result =  safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);
Which means that the eslint-disable-next-line comment is no longer effective. In this case you need to move the comment:
const result =  // eslint-disable-next-line no-eval  safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);
If possible, prefer comments that operate on line ranges (e.g. eslint-disable and eslint-enable) or on the statement level (e.g. /* istanbul ignore next */), they are even safer. It‚Äôs possible to disallow using eslint-disable-line and eslint-disable-next-line comments using eslint-plugin-eslint-comments.
Disclaimer about non-standard syntax‚Äã
Prettier is often able to recognize and format non-standard syntax such as ECMAScript early-stage proposals and Markdown syntax extensions not defined by any specification. The support for such syntax is considered best-effort and experimental. Incompatibilities may be introduced in any release and should not be viewed as breaking changes.
Disclaimer about machine-generated files‚Äã
Some files, like package.json or composer.lock, are machine-generated and regularly updated by the package manager. If Prettier were to use the same JSON formatting rules as with other files, it would regularly conflict with these other tools. To avoid this inconvenience, Prettier will use a formatter based on JSON.stringify on such files instead. You may notice these differences, such as the removal of vertical whitespace, but this is an intended behavior.
What Prettier is not concerned about‚Äã
Prettier only prints code. It does not transform it. This is to limit the scope of Prettier. Let‚Äôs focus on the printing and do it really well!
Here are a few examples of things that are out of scope for Prettier:

Turning single- or double-quoted strings into template literals or vice versa.
Using + to break long string literals into parts that fit the print width.
Adding/removing {} and return where they are optional.
Turning ?: into if-else statements.
Sorting/moving imports, object keys, class members, JSX keys, CSS properties or anything else. Apart from being a transform rather than just printing (as mentioned above), sorting is potentially unsafe because of side effects (for imports, as an example) and makes it difficult to verify the most important correctness goal.
Edit this page\n\nThis is unreleased documentation for Prettier next version.For up-to-date documentation, see the latest version (stable).On this pageRationalePrettier is an opinionated code formatter. This document explains some of its choices.
What Prettier is concerned about‚Äã
Correctness‚Äã
The first requirement of Prettier is to output valid code that has the exact same behavior as before formatting. Please report any code where Prettier fails to follow these correctness rules ‚Äî that‚Äôs a bug which needs to be fixed!
Strings‚Äã
Double or single quotes? Prettier chooses the one which results in the fewest number of escapes. "It's gettin' better!", not 'It\'s gettin\' better!'. In case of a tie or the string not containing any quotes, Prettier defaults to double quotes (but that can be changed via the singleQuote option).
JSX has its own option for quotes: jsxSingleQuote.
JSX takes its roots from HTML, where the dominant use of quotes for attributes is double quotes. Browser developer tools also follow this convention by always displaying HTML with double quotes, even if the source code uses single quotes. A separate option allows using single quotes for JS and double quotes for "HTML" (JSX).
Prettier maintains the way your string is escaped. For example, "üôÇ" won‚Äôt be formatted into "\uD83D\uDE42" and vice versa.
Empty lines‚Äã
It turns out that empty lines are very hard to automatically generate. The approach that Prettier takes is to preserve empty lines the way they were in the original source code. There are two additional rules:

Prettier collapses multiple blank lines into a single blank line.
Empty lines at the start and end of blocks (and whole files) are removed. (Files always end with a single newline, though.)

Multi-line objects‚Äã
By default, Prettier‚Äôs printing algorithm prints expressions on a single line if they fit. Objects are used for a lot of different things in JavaScript, though, and sometimes it really helps readability if they stay multiline. See object lists, nested configs, stylesheets and keyed methods, for example. We haven‚Äôt been able to find a good rule for all those cases, so by default Prettier keeps objects multi-line if there‚Äôs a newline between the { and the first key in the original source code. Consequently, long single-line objects are automatically expanded, but short multi-line objects are never collapsed.
You can disable this conditional behavior with the objectWrap option.
Tip: If you have a multi-line object that you‚Äôd like to join up into a single line:
const user = {  name: "John Doe",  age: 30,};
‚Ä¶all you need to do is remove the newline after {:
const user = {  name: "John Doe",  age: 30};
‚Ä¶and then run Prettier:
const user = { name: "John Doe", age: 30 };
And if you‚Äôd like to go multi-line again, add in a newline after {:
const user = { name: "John Doe", age: 30 };
‚Ä¶and run Prettier:
const user = {  name: "John Doe",  age: 30,};
A note on formatting reversibilityThe semi-manual formatting for object literals is in fact a workaround, not a feature. It was implemented only because at the time a good heuristic wasn‚Äôt found and an urgent fix was needed. However, as a general strategy, Prettier avoids non-reversible formatting like that, so the team is still looking for heuristics that would allow either to remove this behavior completely or at least to reduce the number of situations where it‚Äôs applied.What does reversible mean? Once an object literal becomes multiline, Prettier won‚Äôt collapse it back. If in Prettier-formatted code, we add a property to an object literal, run Prettier, then change our mind, remove the added property, and then run Prettier again, we might end up with a formatting not identical to the initial one. This useless change might even get included in a commit, which is exactly the kind of situation Prettier was created to prevent.
Decorators‚Äã
Just like with objects, decorators are used for a lot of different things. Sometimes it makes sense to write decorators above the line they're decorating, sometimes it‚Äôs nicer if they're on the same line. We haven‚Äôt been able to find a good rule for this, so Prettier keeps your decorator positioned like you wrote them (if they fit on the line). This isn‚Äôt ideal, but a pragmatic solution to a difficult problem.
@Component({  selector: "hero-button",  template: `<button>{{ label }}</button>`,})class HeroButtonComponent {  // These decorators were written inline and fit on the line so they stay  // inline.  @Output() change = new EventEmitter();  @Input() label: string;  // These were written multiline, so they stay multiline.  @readonly  @nonenumerable  NODE_TYPE: 2;}
There‚Äôs one exception: classes. We don‚Äôt think it ever makes sense to inline the decorators for them, so they are always moved to their own line.
// Before running Prettier:@observer class OrderLine {  @observable price: number = 0;}
// After running Prettier:@observerclass OrderLine {  @observable price: number = 0;}
Note: Prettier 1.14.x and older tried to automatically move your decorators, so if you've run an older Prettier version on your code you might need to manually join up some decorators here and there to avoid inconsistencies:
@observerclass OrderLine {  @observable price: number = 0;  @observable  amount: number = 0;}
One final thing: TC39 has not yet decided if decorators come before or after export. In the meantime, Prettier supports both:
@decorator export class Foo {}export @decorator class Foo {}
Template literals‚Äã
Template literals can contain interpolations. Deciding whether it's appropriate to insert a linebreak within an interpolation unfortunately depends on the semantic content of the template - for example, introducing a linebreak in the middle of a natural-language sentence is usually undesirable. Since Prettier doesn't have enough information to make this decision itself, it uses a heuristic similar to that used for objects: it will only split an interpolation expression across multiple lines if there was already a linebreak within that interpolation.
This means that a literal like the following will not be broken onto multiple lines, even if it exceeds the print width:
`this is a long message which contains an interpolation: ${format(data)} <- like this`;
If you want Prettier to split up an interpolation, you'll need to ensure there's a linebreak somewhere within the ${...}. Otherwise it will keep everything on a single line, no matter how long it is.
The team would prefer not to depend on the original formatting in this way, but it's the best heuristic we have at the moment.
Semicolons‚Äã
This is about using the noSemi option.
Consider this piece of code:
if (shouldAddLines) {  [-1, 1].forEach(delta => addLine(delta * 20))}
While the above code works just fine without semicolons, Prettier actually turns it into:
if (shouldAddLines) {  ;[-1, 1].forEach(delta => addLine(delta * 20))}
This is to help you avoid mistakes. Imagine Prettier not inserting that semicolon and adding this line:
 if (shouldAddLines) {+  console.log('Do we even get here??')   [-1, 1].forEach(delta => addLine(delta * 20)) }
Oops! The above actually means:
if (shouldAddLines) {  console.log('Do we even get here??')[-1, 1].forEach(delta => addLine(delta * 20))}
With a semicolon in front of that [ such issues never happen. It makes the line independent of other lines so you can move and add lines without having to think about ASI rules.
This practice is also common in standard which uses a semicolon-free style.
Note that if your program currently has a semicolon-related bug in it, Prettier will not auto-fix the bug for you. Remember, Prettier only reformats code, it does not change the behavior of the code. Take this buggy piece of code as an example, where the developer forgot to place a semicolon before the (:
console.log('Running a background task')(async () => {  await doBackgroundWork()})()
If you feed this into Prettier, it will not alter the behavior of this code, instead, it will reformat it in a way that shows how this code will actually behave when ran.
console.log("Running a background task")(async () => {  await doBackgroundWork();})();
Print width‚Äã
The printWidth option is more of a guideline to Prettier than a hard rule. It is not the upper allowed line length limit. It is a way to say to Prettier roughly how long you‚Äôd like lines to be. Prettier will make both shorter and longer lines, but generally strive to meet the specified print width.
There are some edge cases, such as really long string literals, regexps, comments and variable names, which cannot be broken across lines (without using code transforms which Prettier doesn‚Äôt do). Or if you nest your code 50 levels deep your lines are of course going to be mostly indentation :)
Apart from that, there are a few cases where Prettier intentionally exceeds the print width.
Imports‚Äã
Prettier can break long import statements across several lines:
import {  CollectionDashboard,  DashboardPlaceholder,} from "../components/collections/collection-dashboard/main";
The following example doesn‚Äôt fit within the print width, but Prettier prints it in a single line anyway:
import { CollectionDashboard } from "../components/collections/collection-dashboard/main";
This might be unexpected by some, but we do it this way since it was a common request to keep imports with single elements in a single line. The same applies for require calls.
Testing functions‚Äã
Another common request was to keep lengthy test descriptions in one line, even if it gets too long. In such cases, wrapping the arguments to new lines doesn‚Äôt help much.
describe("NodeRegistry", () => {  it("makes no request if there are no nodes to prefetch, even if the cache is stale", async () => {    // The above line exceeds the print width but stayed on one line anyway.  });});
Prettier has special cases for common testing framework functions such as describe, it and test.
JSX‚Äã
Prettier prints things a little differently compared to other JS when JSX is involved:
function greet(user) {  return user    ? `Welcome back, ${user.name}!`    : "Greetings, traveler! Sign up today!";}function Greet({ user }) {  return (    <div>      {user ? (        <p>Welcome back, {user.name}!</p>      ) : (        <p>Greetings, traveler! Sign up today!</p>      )}    </div>  );}
There are two reasons.
First off, lots of people already wrapped their JSX in parentheses, especially in return statements. Prettier follows this common style.
Secondly, the alternate formatting makes it easier to edit the JSX. It is easy to leave a semicolon behind. As opposed to normal JS, a leftover semicolon in JSX can end up as plain text showing on your page.
<div>  <p>Greetings, traveler! Sign up today!</p>; {/* <-- Oops! */}</div>
Comments‚Äã
When it comes to the content of comments, Prettier can‚Äôt do much really. Comments can contain everything from prose to commented out code and ASCII diagrams. Since they can contain anything, Prettier can‚Äôt know how to format or wrap them. So they are left as-is. The only exception to this are JSDoc-style comments (block comments where every line starts with a *), which Prettier can fix the indentation of.
Then there‚Äôs the question of where to put the comments. Turns out this is a really difficult problem. Prettier tries its best to keep your comments roughly where they were, but it‚Äôs no easy task because comments can be placed almost anywhere.
Generally, you get the best results when placing comments on their own lines, instead of at the end of lines. Prefer // eslint-disable-next-line over // eslint-disable-line.
Note that ‚Äúmagic comments‚Äù such as eslint-disable-next-line and $FlowFixMe might sometimes need to be manually moved due to Prettier breaking an expression into multiple lines.
Imagine this piece of code:
// eslint-disable-next-line no-evalconst result = safeToEval ? eval(input) : fallback(input);
Then you need to add another condition:
// eslint-disable-next-line no-evalconst result = safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);
Prettier will turn the above into:
// eslint-disable-next-line no-evalconst result =  safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);
Which means that the eslint-disable-next-line comment is no longer effective. In this case you need to move the comment:
const result =  // eslint-disable-next-line no-eval  safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);
If possible, prefer comments that operate on line ranges (e.g. eslint-disable and eslint-enable) or on the statement level (e.g. /* istanbul ignore next */), they are even safer. It‚Äôs possible to disallow using eslint-disable-line and eslint-disable-next-line comments using eslint-plugin-eslint-comments.
Disclaimer about non-standard syntax‚Äã
Prettier is often able to recognize and format non-standard syntax such as ECMAScript early-stage proposals and Markdown syntax extensions not defined by any specification. The support for such syntax is considered best-effort and experimental. Incompatibilities may be introduced in any release and should not be viewed as breaking changes.
Disclaimer about machine-generated files‚Äã
Some files, like package.json or composer.lock, are machine-generated and regularly updated by the package manager. If Prettier were to use the same JSON formatting rules as with other files, it would regularly conflict with these other tools. To avoid this inconvenience, Prettier will use a formatter based on JSON.stringify on such files instead. You may notice these differences, such as the removal of vertical whitespace, but this is an intended behavior.
What Prettier is not concerned about‚Äã
Prettier only prints code. It does not transform it. This is to limit the scope of Prettier. Let‚Äôs focus on the printing and do it really well!
Here are a few examples of things that are out of scope for Prettier:

Turning single- or double-quoted strings into template literals or vice versa.
Using + to break long string literals into parts that fit the print width.
Adding/removing {} and return where they are optional.
Turning ?: into if-else statements.
Sorting/moving imports, object keys, class members, JSX keys, CSS properties or anything else. Apart from being a transform rather than just printing (as mentioned above), sorting is potentially unsafe because of side effects (for imports, as an example) and makes it difficult to verify the most important correctness goal.
Edit this pagePreviousOption PhilosophyNextInstallWhat Prettier is concerned aboutCorrectnessStringsEmpty linesMulti-line objectsDecoratorsTemplate literalsSemicolonsPrint widthJSXCommentsDisclaimer about non-standard syntaxDisclaimer about machine-generated filesWhat Prettier is not concerned about\n\n\n\nOn this pageInstallFirst, install Prettier locally:
npmyarnpnpmbunnpm install --save-dev --save-exact prettieryarn add --dev --exact prettierpnpm add --save-dev --save-exact prettierbun add --dev --exact prettier
Then, create an empty config file to let editors and other tools know you are using Prettier:
node --eval "fs.writeFileSync('.prettierrc','{}\n')"
Next, create a .prettierignore file to let the Prettier CLI and editors know which files to not format. Here‚Äôs an example:
node --eval "fs.writeFileSync('.prettierignore','# Ignore artifacts:\nbuild\ncoverage\n')"
tipPrettier will follow rules specified in .gitignore if it exists in the same directory from which it is run. You can also base your .prettierignore on .eslintignore (if you have one).
Another tipIf your project isn‚Äôt ready to format, say, HTML files yet, add *.html.
Now, format all files with Prettier:
npmyarnpnpmbunnpx prettier . --writeinfoWhat is that npx thing? npx ships with npm and lets you run locally installed tools. We‚Äôll leave off the npx part for brevity throughout the rest of this file!warningIf you forget to install Prettier first, npx will temporarily download the latest version. That‚Äôs not a good idea when using Prettier, because we change how code is formatted in each release! It‚Äôs important to have a locked down version of Prettier in your package.json. And it‚Äôs faster, too.yarn exec prettier . --writeinfoWhat is yarn exec doing at the start? yarn exec prettier runs the locally installed version of Prettier. We‚Äôll leave off the yarn exec part for brevity throughout the rest of this file!pnpm exec prettier . --writeinfoWhat is pnpm exec doing at the start? pnpm exec prettier runs the locally installed version of Prettier. We‚Äôll leave off the pnpm exec part for brevity throughout the rest of this file!bun exec prettier . --writeinfoWhat is bun exec doing at the start? bun exec prettier runs the locally installed version of Prettier. We‚Äôll leave off the bun exec part for brevity throughout the rest of this file!
prettier --write . is great for formatting everything, but for a big project it might take a little while. You may run prettier --write app/ to format a certain directory, or prettier --write app/components/Button.js to format a certain file. Or use a glob like prettier --write "app/**/*.test.js" to format all tests in a directory (see fast-glob for supported glob syntax).
If you have a CI setup, run the following as part of it to make sure that everyone runs Prettier. This avoids merge conflicts and other collaboration issues!
npx prettier . --check
--check is like --write, but only checks that files are already formatted, rather than overwriting them. prettier --write and prettier --check are the most common ways to run Prettier.
Set up your editor‚Äã
Formatting from the command line is a good way to get started, but you get the most from Prettier by running it from your editor, either via a keyboard shortcut or automatically whenever you save a file. When a line has gotten so long while coding that it won‚Äôt fit your screen, just hit a key and watch it magically be wrapped into multiple lines! Or when you paste some code and the indentation gets all messed up, let Prettier fix it up for you without leaving your editor.
See Editor Integration for how to set up your editor. If your editor does not support Prettier, you can instead run Prettier with a file watcher.
noteDon‚Äôt skip the regular local install! Editor plugins will pick up your local version of Prettier, making sure you use the correct version in every project. (You wouldn‚Äôt want your editor accidentally causing lots of changes because it‚Äôs using a newer version of Prettier than your project!)And being able to run Prettier from the command line is still a good fallback, and needed for CI setups.
ESLint (and other linters)‚Äã
If you use ESLint, install eslint-config-prettier to make ESLint and Prettier play nice with each other. It turns off all ESLint rules that are unnecessary or might conflict with Prettier. There‚Äôs a similar config for Stylelint: stylelint-config-prettier
(See Prettier vs. Linters to learn more about formatting vs linting, Integrating with Linters for more in-depth information on configuring your linters, and Related projects for even more integration possibilities, if needed.)
Git hooks‚Äã
In addition to running Prettier from the command line (prettier --write), checking formatting in CI, and running Prettier from your editor, many people like to run Prettier as a pre-commit hook as well. This makes sure all your commits are formatted, without having to wait for your CI build to finish.
For example, you can do the following to have Prettier run before each commit:

Install husky and lint-staged:

npmyarnpnpmbunnpm install --save-dev husky lint-stagednpx husky initnode --eval "fs.writeFileSync('.husky/pre-commit','npx lint-staged\n')"yarn add --dev husky lint-stagednpx husky initnode --eval "fs.writeFileSync('.husky/pre-commit','yarn lint-staged\n')"noteIf you use Yarn 2, see https://typicode.github.io/husky/#/?id=yarn-2pnpm add --save-dev husky lint-stagedpnpm exec husky initnode --eval "fs.writeFileSync('.husky/pre-commit','pnpm exec lint-staged\n')"bun add --dev husky lint-stagedbunx husky initbun --eval "fs.writeFileSync('.husky/pre-commit','bunx lint-staged\n')"

Add the following to your package.json:

{  "lint-staged": {    "**/*": "prettier --write --ignore-unknown"  }}
noteIf you use ESLint, make sure lint-staged runs it before Prettier, not after.
See Pre-commit Hook for more information.
Summary‚Äã
To summarize, we have learned to:

Install an exact version of Prettier locally in your project. This makes sure that everyone in the project gets the exact same version of Prettier. Even a patch release of Prettier can result in slightly different formatting, so you wouldn‚Äôt want different team members using different versions and formatting each other‚Äôs changes back and forth.
Add a .prettierrc to let your editor know that you are using Prettier.
Add a .prettierignore to let your editor know which files not to touch, as well as for being able to run prettier --write . to format the entire project (without mangling files you don‚Äôt want, or choking on generated files).
Run prettier --check . in CI to make sure that your project stays formatted.
Run Prettier from your editor for the best experience.
Use eslint-config-prettier to make Prettier and ESLint play nice together.
Set up a pre-commit hook to make sure that every commit is formatted.
Edit this page\n\nThis is unreleased documentation for Prettier next version.For up-to-date documentation, see the latest version (stable).On this pageInstallFirst, install Prettier locally:
npmyarnpnpmbunnpm install --save-dev --save-exact prettieryarn add --dev --exact prettierpnpm add --save-dev --save-exact prettierbun add --dev --exact prettier
Then, create an empty config file to let editors and other tools know you are using Prettier:
node --eval "fs.writeFileSync('.prettierrc','{}\n')"
Next, create a .prettierignore file to let the Prettier CLI and editors know which files to not format. Here‚Äôs an example:
node --eval "fs.writeFileSync('.prettierignore','# Ignore artifacts:\nbuild\ncoverage\n')"
tipPrettier will follow rules specified in .gitignore if it exists in the same directory from which it is run. You can also base your .prettierignore on .eslintignore (if you have one).
Another tipIf your project isn‚Äôt ready to format, say, HTML files yet, add *.html.
Now, format all files with Prettier:
npmyarnpnpmbunnpx prettier . --writeinfoWhat is that npx thing? npx ships with npm and lets you run locally installed tools. We‚Äôll leave off the npx part for brevity throughout the rest of this file!warningIf you forget to install Prettier first, npx will temporarily download the latest version. That‚Äôs not a good idea when using Prettier, because we change how code is formatted in each release! It‚Äôs important to have a locked down version of Prettier in your package.json. And it‚Äôs faster, too.yarn exec prettier . --writeinfoWhat is yarn exec doing at the start? yarn exec prettier runs the locally installed version of Prettier. We‚Äôll leave off the yarn exec part for brevity throughout the rest of this file!pnpm exec prettier . --writeinfoWhat is pnpm exec doing at the start? pnpm exec prettier runs the locally installed version of Prettier. We‚Äôll leave off the pnpm exec part for brevity throughout the rest of this file!bun exec prettier . --writeinfoWhat is bun exec doing at the start? bun exec prettier runs the locally installed version of Prettier. We‚Äôll leave off the bun exec part for brevity throughout the rest of this file!
prettier --write . is great for formatting everything, but for a big project it might take a little while. You may run prettier --write app/ to format a certain directory, or prettier --write app/components/Button.js to format a certain file. Or use a glob like prettier --write "app/**/*.test.js" to format all tests in a directory (see fast-glob for supported glob syntax).
If you have a CI setup, run the following as part of it to make sure that everyone runs Prettier. This avoids merge conflicts and other collaboration issues!
npx prettier . --check
--check is like --write, but only checks that files are already formatted, rather than overwriting them. prettier --write and prettier --check are the most common ways to run Prettier.
Set up your editor‚Äã
Formatting from the command line is a good way to get started, but you get the most from Prettier by running it from your editor, either via a keyboard shortcut or automatically whenever you save a file. When a line has gotten so long while coding that it won‚Äôt fit your screen, just hit a key and watch it magically be wrapped into multiple lines! Or when you paste some code and the indentation gets all messed up, let Prettier fix it up for you without leaving your editor.
See Editor Integration for how to set up your editor. If your editor does not support Prettier, you can instead run Prettier with a file watcher.
noteDon‚Äôt skip the regular local install! Editor plugins will pick up your local version of Prettier, making sure you use the correct version in every project. (You wouldn‚Äôt want your editor accidentally causing lots of changes because it‚Äôs using a newer version of Prettier than your project!)And being able to run Prettier from the command line is still a good fallback, and needed for CI setups.
ESLint (and other linters)‚Äã
If you use ESLint, install eslint-config-prettier to make ESLint and Prettier play nice with each other. It turns off all ESLint rules that are unnecessary or might conflict with Prettier. There‚Äôs a similar config for Stylelint: stylelint-config-prettier
(See Prettier vs. Linters to learn more about formatting vs linting, Integrating with Linters for more in-depth information on configuring your linters, and Related projects for even more integration possibilities, if needed.)
Git hooks‚Äã
In addition to running Prettier from the command line (prettier --write), checking formatting in CI, and running Prettier from your editor, many people like to run Prettier as a pre-commit hook as well. This makes sure all your commits are formatted, without having to wait for your CI build to finish.
For example, you can do the following to have Prettier run before each commit:

Install husky and lint-staged:

npmyarnpnpmbunnpm install --save-dev husky lint-stagednpx husky initnode --eval "fs.writeFileSync('.husky/pre-commit','npx lint-staged\n')"yarn add --dev husky lint-stagednpx husky initnode --eval "fs.writeFileSync('.husky/pre-commit','yarn lint-staged\n')"noteIf you use Yarn 2, see https://typicode.github.io/husky/#/?id=yarn-2pnpm add --save-dev husky lint-stagedpnpm exec husky initnode --eval "fs.writeFileSync('.husky/pre-commit','pnpm exec lint-staged\n')"bun add --dev husky lint-stagedbunx husky initbun --eval "fs.writeFileSync('.husky/pre-commit','bunx lint-staged\n')"

Add the following to your package.json:

{  "lint-staged": {    "**/*": "prettier --write --ignore-unknown"  }}
noteIf you use ESLint, make sure lint-staged runs it before Prettier, not after.
See Pre-commit Hook for more information.
Summary‚Äã
To summarize, we have learned to:

Install an exact version of Prettier locally in your project. This makes sure that everyone in the project gets the exact same version of Prettier. Even a patch release of Prettier can result in slightly different formatting, so you wouldn‚Äôt want different team members using different versions and formatting each other‚Äôs changes back and forth.
Add a .prettierrc to let your editor know that you are using Prettier.
Add a .prettierignore to let your editor know which files not to touch, as well as for being able to run prettier --write . to format the entire project (without mangling files you don‚Äôt want, or choking on generated files).
Run prettier --check . in CI to make sure that your project stays formatted.
Run Prettier from your editor for the best experience.
Use eslint-config-prettier to make Prettier and ESLint play nice together.
Set up a pre-commit hook to make sure that every commit is formatted.
Edit this pagePreviousRationaleNextIgnoring CodeSet up your editorESLint (and other linters)Git hooksSummary\n\n\n\nOn this pageIgnoring CodeUse .prettierignore to ignore (i.e. not reformat) certain files and folders completely.
Use ‚Äúprettier-ignore‚Äù comments to ignore parts of files.
Ignoring Files: .prettierignore‚Äã
To exclude files from formatting, create a .prettierignore file in the root of your project. .prettierignore uses gitignore syntax.
Example:
# Ignore artifacts:buildcoverage# Ignore all HTML files:**/*.html
It‚Äôs recommended to have a .prettierignore in your project! This way you can run prettier --write . to make sure that everything is formatted (without mangling files you don‚Äôt want, or choking on generated files). And ‚Äì your editor will know which files not to format!
By default prettier ignores files in version control systems directories (".git", ".jj", ".sl", ".svn" and ".hg") and node_modules (unless the --with-node-modules CLI option is specified). Prettier will also follow rules specified in the ".gitignore" file if it exists in the same directory from which it is run.
So by default it will be
**/.git**/.svn**/.hg**/node_modules
and
**/.git**/.svn**/.hg
if --with-node-modules CLI option provided
(See also the --ignore-path CLI option.)
JavaScript‚Äã
A JavaScript comment of // prettier-ignore will exclude the next node in the abstract syntax tree from formatting.
For example:
matrix(  1, 0, 0,  0, 1, 0,  0, 0, 1)// prettier-ignorematrix(  1, 0, 0,  0, 1, 0,  0, 0, 1)
will be transformed to:
matrix(1, 0, 0, 0, 1, 0, 0, 0, 1);// prettier-ignorematrix(  1, 0, 0,  0, 1, 0,  0, 0, 1)
JSX‚Äã
<div>  {/* prettier-ignore */}  <span     ugly  format=''   /></div>
HTML‚Äã
<!-- prettier-ignore --><div         class="x"       >hello world</div            ><!-- prettier-ignore-attribute --><div  (mousedown)="       onStart    (    )         "  (mouseup)="         onEnd      (    )         "></div><!-- prettier-ignore-attribute (mouseup) --><div  (mousedown)="onStart()"  (mouseup)="         onEnd      (    )         "></div>
CSS‚Äã
/* prettier-ignore */.my    ugly rule{}
Markdown‚Äã
<!-- prettier-ignore -->Do   not    format   this
Range Ignore‚Äã
available in v1.12.0+
This type of ignore is only allowed to be used in top-level and aimed to disable formatting for auto-generated content, e.g. all-contributors, markdown-toc, etc.
<!-- prettier-ignore-start --><!-- SOMETHING AUTO-GENERATED BY TOOLS - START -->| MY | AWESOME | AUTO-GENERATED | TABLE ||-|-|-|-|| a | b | c | d |<!-- SOMETHING AUTO-GENERATED BY TOOLS - END --><!-- prettier-ignore-end -->
Important: You must have a blank line before <!-- prettier-ignore-start --> and <!-- prettier-ignore-end --> for Prettier to recognize the comments.
YAML‚Äã
To ignore a part of a YAML file, # prettier-ignore should be placed on the line immediately above the ignored node:
# prettier-ignorekey  : valuehello: world
GraphQL‚Äã
{  # prettier-ignore  addReaction(input:{superLongInputFieldName:"MDU6SXNzdWUyMzEzOTE1NTE=",content:HOORAY}) {    reaction {content}  }}
Handlebars‚Äã
{{! prettier-ignore }}<div>  "hello! my parent was ignored"  {{#my-crazy-component     "shall"     be="preserved"}}    <This      is  =  "also preserved as is"    />  {{/my-crazy-component}}</div>
Command Line File Patterns‚Äã
For one-off commands, when you want to exclude some files without adding them to .prettierignore, negative patterns can come in handy:
prettier . "!**/*.{js,jsx,vue}" --write
See fast-glob to learn more about advanced glob syntax.Edit this page\n\nThis is unreleased documentation for Prettier next version.For up-to-date documentation, see the latest version (stable).On this pageIgnoring CodeUse .prettierignore to ignore (i.e. not reformat) certain files and folders completely.
Use ‚Äúprettier-ignore‚Äù comments to ignore parts of files.
Ignoring Files: .prettierignore‚Äã
To exclude files from formatting, create a .prettierignore file in the root of your project. .prettierignore uses gitignore syntax.
Example:
# Ignore artifacts:buildcoverage# Ignore all HTML files:**/*.html
It‚Äôs recommended to have a .prettierignore in your project! This way you can run prettier --write . to make sure that everything is formatted (without mangling files you don‚Äôt want, or choking on generated files). And ‚Äì your editor will know which files not to format!
By default prettier ignores files in version control systems directories (".git", ".jj", ".sl", ".svn" and ".hg") and node_modules (unless the --with-node-modules CLI option is specified). Prettier will also follow rules specified in the ".gitignore" file if it exists in the same directory from which it is run.
So by default it will be
**/.git**/.svn**/.hg**/node_modules
and
**/.git**/.svn**/.hg
if --with-node-modules CLI option provided
(See also the --ignore-path CLI option.)
JavaScript‚Äã
A JavaScript comment of // prettier-ignore will exclude the next node in the abstract syntax tree from formatting.
For example:
matrix(  1, 0, 0,  0, 1, 0,  0, 0, 1)// prettier-ignorematrix(  1, 0, 0,  0, 1, 0,  0, 0, 1)
will be transformed to:
matrix(1, 0, 0, 0, 1, 0, 0, 0, 1);// prettier-ignorematrix(  1, 0, 0,  0, 1, 0,  0, 0, 1)
JSX‚Äã
<div>  {/* prettier-ignore */}  <span     ugly  format=''   /></div>
HTML‚Äã
<!-- prettier-ignore --><div         class="x"       >hello world</div            ><!-- prettier-ignore-attribute --><div  (mousedown)="       onStart    (    )         "  (mouseup)="         onEnd      (    )         "></div><!-- prettier-ignore-attribute (mouseup) --><div  (mousedown)="onStart()"  (mouseup)="         onEnd      (    )         "></div>
CSS‚Äã
/* prettier-ignore */.my    ugly rule{}
Markdown‚Äã
<!-- prettier-ignore -->Do   not    format   this
Range Ignore‚Äã
available in v1.12.0+
This type of ignore is only allowed to be used in top-level and aimed to disable formatting for auto-generated content, e.g. all-contributors, markdown-toc, etc.
<!-- prettier-ignore-start --><!-- SOMETHING AUTO-GENERATED BY TOOLS - START -->| MY | AWESOME | AUTO-GENERATED | TABLE ||-|-|-|-|| a | b | c | d |<!-- SOMETHING AUTO-GENERATED BY TOOLS - END --><!-- prettier-ignore-end -->
Important: You must have a blank line before <!-- prettier-ignore-start --> and <!-- prettier-ignore-end --> for Prettier to recognize the comments.
YAML‚Äã
To ignore a part of a YAML file, # prettier-ignore should be placed on the line immediately above the ignored node:
# prettier-ignorekey  : valuehello: world
GraphQL‚Äã
{  # prettier-ignore  addReaction(input:{superLongInputFieldName:"MDU6SXNzdWUyMzEzOTE1NTE=",content:HOORAY}) {    reaction {content}  }}
Handlebars‚Äã
{{! prettier-ignore }}<div>  "hello! my parent was ignored"  {{#my-crazy-component     "shall"     be="preserved"}}    <This      is  =  "also preserved as is"    />  {{/my-crazy-component}}</div>
Command Line File Patterns‚Äã
For one-off commands, when you want to exclude some files without adding them to .prettierignore, negative patterns can come in handy:
prettier . "!**/*.{js,jsx,vue}" --write
See fast-glob to learn more about advanced glob syntax.Edit this pagePreviousInstallNextIntegrating with LintersIgnoring Files: .prettierignoreJavaScriptJSXHTMLCSSMarkdownRange IgnoreYAMLGraphQLHandlebarsCommand Line File Patterns\n\n\n\nOn this pageIntegrating with LintersLinters usually contain not only code quality rules, but also stylistic rules. Most stylistic rules are unnecessary when using Prettier, but worse ‚Äì they might conflict with Prettier! Use Prettier for code formatting concerns, and linters for code-quality concerns, as outlined in Prettier vs. Linters.
Luckily it‚Äôs easy to turn off rules that conflict or are unnecessary with Prettier, by using these pre-made configs:

eslint-config-prettier

Check out the above links for instructions on how to install and set things up.
Notes‚Äã
When searching for both Prettier and your linter on the Internet you‚Äôll probably find more related projects. These are generally not recommended, but can be useful in certain circumstances.
First, we have plugins that let you run Prettier as if it was a linter rule:

eslint-plugin-prettier
stylelint-prettier

These plugins were especially useful when Prettier was new. By running Prettier inside your linters, you didn‚Äôt have to set up any new infrastructure and you could re-use your editor integrations for the linters. But these days you can run prettier --check . and most editors have Prettier support.
The downsides of those plugins are:

You end up with a lot of red squiggly lines in your editor, which gets annoying. Prettier is supposed to make you forget about formatting ‚Äì and not be in your face about it!
They are slower than running Prettier directly.
They‚Äôre yet one layer of indirection where things may break.

Finally, we have tools that run prettier and then immediately lint files by running, for example, eslint --fix on them.

prettier-eslint
prettier-stylelint

Those are useful if some aspect of Prettier‚Äôs output makes Prettier completely unusable to you. Then you can have for example eslint --fix fix that up for you. The downside is that these tools are much slower than just running Prettier.Edit this page\n\nThis is unreleased documentation for Prettier next version.For up-to-date documentation, see the latest version (stable).On this pageIntegrating with LintersLinters usually contain not only code quality rules, but also stylistic rules. Most stylistic rules are unnecessary when using Prettier, but worse ‚Äì they might conflict with Prettier! Use Prettier for code formatting concerns, and linters for code-quality concerns, as outlined in Prettier vs. Linters.
Luckily it‚Äôs easy to turn off rules that conflict or are unnecessary with Prettier, by using these pre-made configs:

eslint-config-prettier

Check out the above links for instructions on how to install and set things up.
Notes‚Äã
When searching for both Prettier and your linter on the Internet you‚Äôll probably find more related projects. These are generally not recommended, but can be useful in certain circumstances.
First, we have plugins that let you run Prettier as if it was a linter rule:

eslint-plugin-prettier
stylelint-prettier

These plugins were especially useful when Prettier was new. By running Prettier inside your linters, you didn‚Äôt have to set up any new infrastructure and you could re-use your editor integrations for the linters. But these days you can run prettier --check . and most editors have Prettier support.
The downsides of those plugins are:

You end up with a lot of red squiggly lines in your editor, which gets annoying. Prettier is supposed to make you forget about formatting ‚Äì and not be in your face about it!
They are slower than running Prettier directly.
They‚Äôre yet one layer of indirection where things may break.

Finally, we have tools that run prettier and then immediately lint files by running, for example, eslint --fix on them.

prettier-eslint
prettier-stylelint

Those are useful if some aspect of Prettier‚Äôs output makes Prettier completely unusable to you. Then you can have for example eslint --fix fix that up for you. The downside is that these tools are much slower than just running Prettier.Edit this pagePreviousIgnoring CodeNextPre-commit HookNotes\n\n\n\nOn this pagePre-commit HookYou can use Prettier with a pre-commit tool. This can re-format your files that are marked as ‚Äústaged‚Äù via git add before you commit.
Option 1. lint-staged‚Äã
Use Case: Useful for when you want to use other code quality tools along with Prettier (e.g. ESLint, Stylelint, etc.) or if you need support for partially staged files (git add --patch).
Make sure Prettier is installed and is in your devDependencies before you proceed.
npx mrm@2 lint-staged
This will install husky and lint-staged, then add a configuration to the project‚Äôs package.json that will automatically format supported files in a pre-commit hook.
Read more at the lint-staged repo.
Option 2. pretty-quick‚Äã
Use Case: Great for when you want an entire file formatting on your changed/staged files.
Install it along with simple-git-hooks:
npmyarnpnpmbunnpm install --save-dev simple-git-hooks pretty-quickecho '{\n  "pre-commit": "npx pretty-quick --staged"\n}\n' > .simple-git-hooks.jsonnpx simple-git-hooksyarn add --dev simple-git-hooks pretty-quickecho '{\n  "pre-commit": "yarn pretty-quick --staged"\n}\n' > .simple-git-hooks.jsonyarn simple-git-hookspnpm add --save-dev simple-git-hooks pretty-quickecho '{\n  "pre-commit": "pnpm pretty-quick --staged"\n}\n' > .simple-git-hooks.jsonpnpm simple-git-hooksbun add --dev simple-git-hooks pretty-quickecho '{\n  "pre-commit": "bun pretty-quick --staged"\n}\n' > .simple-git-hooks.jsonbun simple-git-hooks
Read more at the pretty-quick repo.
Option 3. Husky.Net‚Äã
Use Case: A dotnet solution to use Prettier along with other code quality tools (e.g. dotnet-format, ESLint, Stylelint, etc.). It supports multiple file states (staged - last-commit, git-files etc.)
dotnet new tool-manifestdotnet tool install huskydotnet husky installdotnet husky add pre-commit
after installation you can add prettier task to the task-runner.json.
{  "command": "npx",  "args": ["prettier", "--ignore-unknown", "--write", "${staged}"],  "pathMode": "absolute"}
Option 4. git-format-staged‚Äã
Use Case: Great for when you want to format partially-staged files, and other options do not provide a good fit for your project.
Git-format-staged is used to run any formatter that can accept file content via stdin. It operates differently than other tools that format partially-staged files: it applies the formatter directly to objects in the git object database, and merges changes back to the working tree. This procedure provides several guarantees:

Changes in commits are always formatted.
Unstaged changes are never, under any circumstances staged during the formatting process.
If there are conflicts between formatted, staged changes and unstaged changes then your working tree files are left untouched - your work won‚Äôt be overwritten, and there are no stashes to clean up.
Unstaged changes are not formatted.

Git-format-staged requires Python v3 or v2.7. Python is usually pre-installed on Linux and macOS, but not on Windows. Use git-format-staged with husky:
npmyarnpnpmbunnpx husky initnpm install --save-dev git-format-stagednode --eval "fs.writeFileSync('.husky/pre-commit', 'git-format-staged -f \'prettier --ignore-unknown --stdin --stdin-filepath \"{}\"\' .\n')"yarn husky inityarn add --dev git-format-stagednode --eval "fs.writeFileSync('.husky/pre-commit', 'git-format-staged -f \'prettier --ignore-unknown --stdin --stdin-filepath \"{}\"\' .\n')"pnpm exec husky initpnpm add --save-dev git-format-stagednode --eval "fs.writeFileSync('.husky/pre-commit', 'git-format-staged -f \'prettier --ignore-unknown --stdin --stdin-filepath \"{}\"\' .\n')"bunx husky initbun add --dev git-format-stagedbun --eval "fs.writeFileSync('.husky/pre-commit', 'git-format-staged -f \'prettier --ignore-unknown --stdin --stdin-filepath \"{}\"\' .\n')"
Add or remove file extensions to suit your project. Note that regardless of which extensions you list formatting will respect any .prettierignore files in your project.
To read about how git-format-staged works see Automatic Code Formatting for Partially-Staged Files.
Option 5. Shell script‚Äã
Alternately you can save this script as .git/hooks/pre-commit and give it execute permission:
#!/bin/shFILES=$(git diff --cached --name-only --diff-filter=ACMR | sed 's| |\\ |g')[ -z "$FILES" ] && exit 0# Prettify all selected filesecho "$FILES" | xargs ./node_modules/.bin/prettier --ignore-unknown --write# Add back the modified/prettified files to stagingecho "$FILES" | xargs git addexit 0
If git is reporting that your prettified files are still modified after committing, you may need to add a post-commit script to update git‚Äôs index.
Add something like the following to .git/hooks/post-commit:
#!/bin/shgit update-index -gEdit this page\n\nThis is unreleased documentation for Prettier next version.For up-to-date documentation, see the latest version (stable).On this pagePre-commit HookYou can use Prettier with a pre-commit tool. This can re-format your files that are marked as ‚Äústaged‚Äù via git add before you commit.
Option 1. lint-staged‚Äã
Use Case: Useful for when you want to use other code quality tools along with Prettier (e.g. ESLint, Stylelint, etc.) or if you need support for partially staged files (git add --patch).
Make sure Prettier is installed and is in your devDependencies before you proceed.
npx mrm@2 lint-staged
This will install husky and lint-staged, then add a configuration to the project‚Äôs package.json that will automatically format supported files in a pre-commit hook.
Read more at the lint-staged repo.
Option 2. pretty-quick‚Äã
Use Case: Great for when you want an entire file formatting on your changed/staged files.
Install it along with simple-git-hooks:
npmyarnpnpmbunnpm install --save-dev simple-git-hooks pretty-quickecho '{\n  "pre-commit": "npx pretty-quick --staged"\n}\n' > .simple-git-hooks.jsonnpx simple-git-hooksyarn add --dev simple-git-hooks pretty-quickecho '{\n  "pre-commit": "yarn pretty-quick --staged"\n}\n' > .simple-git-hooks.jsonyarn simple-git-hookspnpm add --save-dev simple-git-hooks pretty-quickecho '{\n  "pre-commit": "pnpm pretty-quick --staged"\n}\n' > .simple-git-hooks.jsonpnpm simple-git-hooksbun add --dev simple-git-hooks pretty-quickecho '{\n  "pre-commit": "bun pretty-quick --staged"\n}\n' > .simple-git-hooks.jsonbun simple-git-hooks
Read more at the pretty-quick repo.
Option 3. Husky.Net‚Äã
Use Case: A dotnet solution to use Prettier along with other code quality tools (e.g. dotnet-format, ESLint, Stylelint, etc.). It supports multiple file states (staged - last-commit, git-files etc.)
dotnet new tool-manifestdotnet tool install huskydotnet husky installdotnet husky add pre-commit
after installation you can add prettier task to the task-runner.json.
{  "command": "npx",  "args": ["prettier", "--ignore-unknown", "--write", "${staged}"],  "pathMode": "absolute"}
Option 4. git-format-staged‚Äã
Use Case: Great for when you want to format partially-staged files, and other options do not provide a good fit for your project.
Git-format-staged is used to run any formatter that can accept file content via stdin. It operates differently than other tools that format partially-staged files: it applies the formatter directly to objects in the git object database, and merges changes back to the working tree. This procedure provides several guarantees:

Changes in commits are always formatted.
Unstaged changes are never, under any circumstances staged during the formatting process.
If there are conflicts between formatted, staged changes and unstaged changes then your working tree files are left untouched - your work won‚Äôt be overwritten, and there are no stashes to clean up.
Unstaged changes are not formatted.

Git-format-staged requires Python v3 or v2.7. Python is usually pre-installed on Linux and macOS, but not on Windows. Use git-format-staged with husky:
npmyarnpnpmbunnpx husky initnpm install --save-dev git-format-stagednode --eval "fs.writeFileSync('.husky/pre-commit', 'git-format-staged -f \'prettier --ignore-unknown --stdin --stdin-filepath \"{}\"\' .\n')"yarn husky inityarn add --dev git-format-stagednode --eval "fs.writeFileSync('.husky/pre-commit', 'git-format-staged -f \'prettier --ignore-unknown --stdin --stdin-filepath \"{}\"\' .\n')"pnpm exec husky initpnpm add --save-dev git-format-stagednode --eval "fs.writeFileSync('.husky/pre-commit', 'git-format-staged -f \'prettier --ignore-unknown --stdin --stdin-filepath \"{}\"\' .\n')"bunx husky initbun add --dev git-format-stagedbun --eval "fs.writeFileSync('.husky/pre-commit', 'git-format-staged -f \'prettier --ignore-unknown --stdin --stdin-filepath \"{}\"\' .\n')"
Add or remove file extensions to suit your project. Note that regardless of which extensions you list formatting will respect any .prettierignore files in your project.
To read about how git-format-staged works see Automatic Code Formatting for Partially-Staged Files.
Option 5. Shell script‚Äã
Alternately you can save this script as .git/hooks/pre-commit and give it execute permission:
#!/bin/shFILES=$(git diff --cached --name-only --diff-filter=ACMR | sed 's| |\\ |g')[ -z "$FILES" ] && exit 0# Prettify all selected filesecho "$FILES" | xargs ./node_modules/.bin/prettier --ignore-unknown --write# Add back the modified/prettified files to stagingecho "$FILES" | xargs git addexit 0
If git is reporting that your prettified files are still modified after committing, you may need to add a post-commit script to update git‚Äôs index.
Add something like the following to .git/hooks/post-commit:
#!/bin/shgit update-index -gEdit this pagePreviousIntegrating with LintersNextPluginsOption 1. lint-stagedOption 2. pretty-quickOption 3. Husky.NetOption 4. git-format-stagedOption 5. Shell script\n\n\n\nOn this pagePluginsPlugins are ways of adding new languages or formatting rules to Prettier. Prettier‚Äôs own implementations of all languages are expressed using the plugin API. The core prettier package contains JavaScript and other web-focused languages built in. For additional languages you‚Äôll need to install a plugin.
Using Plugins‚Äã
You can load plugins with:


The CLI, via --plugin:
prettier --write main.foo --plugin=prettier-plugin-foo
tipYou can set --plugin options multiple times.


The API, via the plugins options:
await prettier.format("code", {  parser: "foo",  plugins: ["prettier-plugin-foo"],});


The Configuration File:
{  "plugins": ["prettier-plugin-foo"]}


Strings provided to plugins are ultimately passed to import() expression, so you can provide a module/package name, a path, or anything else import() takes.
Official Plugins‚Äã

@prettier/plugin-php
@prettier/plugin-pug by @Shinigami92
@prettier/plugin-ruby
@prettier/plugin-xml

Community Plugins‚Äã

prettier-plugin-apex by @dangmai
prettier-plugin-astro by @withastro contributors
prettier-plugin-elm by @giCentre
prettier-plugin-erb by @adamzapasnik
prettier-plugin-gherkin by @mapado
prettier-plugin-glsl by @NaridaL
prettier-plugin-go-template by @NiklasPor
prettier-plugin-java by @JHipster
prettier-plugin-jinja-template by @davidodenwald
prettier-plugin-jsonata by @Stedi
prettier-plugin-kotlin by @Angry-Potato
prettier-plugin-motoko by @dfinity
prettier-plugin-nginx by @joedeandev
prettier-plugin-prisma by @umidbekk
prettier-plugin-properties by @eemeli
prettier-plugin-rust by @jinxdash
prettier-plugin-sh by @JounQin
prettier-plugin-sql by @JounQin
prettier-plugin-sql-cst by @nene
prettier-plugin-solidity by @mattiaerre
prettier-plugin-svelte by @sveltejs
prettier-plugin-toml by @JounQin and @so1ve

Developing Plugins‚Äã
Prettier plugins are regular JavaScript modules with the following five exports or default export with the following properties:

languages
parsers
printers
options
defaultOptions

languages‚Äã
Languages is an array of language definitions that your plugin will contribute to Prettier. It can include all of the fields specified in prettier.getSupportInfo().
It must include name and parsers.
export const languages = [  {    // The language name    name: "InterpretedDanceScript",    // Parsers that can parse this language.    // This can be built-in parsers, or parsers you have contributed via this plugin.    parsers: ["dance-parse"],  },];
parsers‚Äã
Parsers convert code as a string into an AST.
The key must match the name in the parsers array from languages. The value contains a parse function, an AST format name, and two location extraction functions (locStart and locEnd).
export const parsers = {  "dance-parse": {    parse,    // The name of the AST that the parser produces.    astFormat: "dance-ast",    hasPragma,    hasIgnorePragma,    locStart,    locEnd,    preprocess,  },};
The signature of the parse function is:
function parse(text: string, options: object): Promise<AST> | AST;
The location extraction functions (locStart and locEnd) return the starting and ending locations of a given AST node:
function locStart(node: object): number;
(Optional) The pragma detection function (hasPragma) should return if the text contains the pragma comment.
function hasPragma(text: string): boolean;
(Optional) The "ignore pragma" detection function (hasIgnorePragma) should return if the text contains a pragma indicating the text should not be formatted.
function hasIgnorePragma(text: string): boolean;
(Optional) The preprocess function can process the input text before passing into parse function.
function preprocess(text: string, options: object): string;
printers‚Äã
Printers convert ASTs into a Prettier intermediate representation, also known as a Doc.
The key must match the astFormat that the parser produces. The value contains an object with a print function. All other properties (embed, preprocess, etc.) are optional.
export const printers = {  "dance-ast": {    print,    embed,    preprocess,    getVisitorKeys,    insertPragma,    canAttachComment,    isBlockComment,    printComment,    getCommentChildNodes,    handleComments: {      ownLine,      endOfLine,      remaining,    },  },};
The printing process‚Äã
Prettier uses an intermediate representation, called a Doc, which Prettier then turns into a string (based on options like printWidth). A printer's job is to take the AST generated by parsers[<parser name>].parse and return a Doc. A Doc is constructed using builder commands:
import { doc } from "prettier";const { join, line, ifBreak, group } = doc.builders;
The printing process consists of the following steps:

AST preprocessing (optional). See preprocess.
Comment attachment (optional). See Handling comments in a printer.
Processing embedded languages (optional). The embed method, if defined, is called for each node, depth-first. While, for performance reasons, the recursion itself is synchronous, embed may return asynchronous functions that can call other parsers and printers to compose docs for embedded syntaxes like CSS-in-JS. These returned functions are queued up and sequentially executed before the next step.
Recursive printing. A doc is recursively constructed from the AST. Starting from the root node:

If, from the step 3, there is an embedded language doc associated with the current node, this doc is used.
Otherwise, the print(path, options, print): Doc method is called. It composes a doc for the current node, often by printing child nodes using the print callback.



print‚Äã
Most of the work of a plugin's printer will take place in its print function, whose signature is:
function print(  // Path to the AST node to print  path: AstPath,  options: object,  // Recursively print a child node  print: (selector?: string | number | Array<string | number> | AstPath) => Doc,): Doc;
The print function is passed the following parameters:

path: An object, which can be used to access nodes in the AST. It‚Äôs a stack-like data structure that maintains the current state of the recursion. It is called ‚Äúpath‚Äù because it represents the path to the current node from the root of the AST. The current node is returned by path.node.
options: A persistent object, which contains global options and which a plugin may mutate to store contextual data.
print: A callback for printing sub-nodes. This function contains the core printing logic that consists of steps whose implementation is provided by plugins. In particular, it calls the printer‚Äôs print function and passes itself to it. Thus, the two print functions ‚Äì the one from the core and the one from the plugin ‚Äì call each other while descending down the AST recursively.

Here‚Äôs a simplified example to give an idea of what a typical implementation of print looks like:
import { doc } from "prettier";const { group, indent, join, line, softline } = doc.builders;function print(path, options, print) {  const node = path.node;  switch (node.type) {    case "list":      return group([        "(",        indent([softline, join(line, path.map(print, "elements"))]),        softline,        ")",      ]);    case "pair":      return group([        "(",        indent([softline, print("left"), line, ". ", print("right")]),        softline,        ")",      ]);    case "symbol":      return node.name;  }  throw new Error(`Unknown node type: ${node.type}`);}
Check out prettier-python's printer for some examples of what is possible.
(optional) embed‚Äã
A printer can have the embed method to print one language inside another. Examples of this are printing CSS-in-JS or fenced code blocks in Markdown. The signature is:
function embed(  // Path to the current AST node  path: AstPath,  // Current options  options: Options,):  | ((      // Parses and prints the passed text using a different parser.      // You should set `options.parser` to specify which parser to use.      textToDoc: (text: string, options: Options) => Promise<Doc>,      // Prints the current node or its descendant node with the current printer      print: (        selector?: string | number | Array<string | number> | AstPath,      ) => Doc,      // The following two arguments are passed for convenience.      // They're the same `path` and `options` that are passed to `embed`.      path: AstPath,      options: Options,    ) => Promise<Doc | undefined> | Doc | undefined)  | Doc  | undefined;
The embed method is similar to the print method in that it maps AST nodes to docs, but unlike print, it has power to do async work by returning an async function. That function's first parameter, the textToDoc async function, can be used to render a doc using a different plugin.
If a function returned from embed returns a doc or a promise that resolves to a doc, that doc will be used in printing, and the print method won‚Äôt be called for this node. It's also possible and, in rare situations, might be convenient to return a doc synchronously directly from embed, however textToDoc and the print callback aren‚Äôt available at that case. Return a function to get them.
If embed returns undefined, or if a function it returned returns undefined or a promise that resolves to undefined, the node will be printed normally with the print method. Same will happen if a returned function throws an error or returns a promise that rejects (e.g., if a parsing error has happened). Set the PRETTIER_DEBUG environment variable to a non-empty value if you want Prettier to rethrow these errors.
For example, a plugin that has nodes with embedded JavaScript might have the following embed method:
function embed(path, options) {  const node = path.node;  if (node.type === "javascript") {    return async (textToDoc) => {      return [        "<script>",        hardline,        await textToDoc(node.javaScriptCode, { parser: "babel" }),        hardline,        "</script>",      ];    };  }}
If the --embedded-language-formatting option is set to off, the embedding step is entirely skipped, embed isn‚Äôt called, and all nodes are printed with the print method.
(optional) preprocess‚Äã
The preprocess method can process the AST from the parser before passing it into the print method.
function preprocess(ast: AST, options: Options): AST | Promise<AST>;
(optional) getVisitorKeys‚Äã
This property might come in handy if the plugin uses comment attachment or embedded languages. These features traverse the AST iterating through all the own enumerable properties of each node starting from the root. If the AST has cycles, such a traverse ends up in an infinite loop. Also, nodes might contain non-node objects (e.g., location data), iterating through which is a waste of resources. To solve these issues, the printer can define a function to return property names that should be traversed.
Its signature is:
function getVisitorKeys(node, nonTraversableKeys: Set<string>): string[];
The default getVisitorKeys:
function getVisitorKeys(node, nonTraversableKeys) {  return Object.keys(node).filter((key) => !nonTraversableKeys.has(key));}
The second argument nonTraversableKeys is a set of common keys and keys that prettier used internal.
If you have full list of visitor keys
const visitorKeys = {  Program: ["body"],  Identifier: [],  // ...};function getVisitorKeys(node /* , nonTraversableKeys*/) {  // Return `[]` for unknown node to prevent Prettier fallback to use `Object.keys()`  return visitorKeys[node.type] ?? [];}
If you only need exclude a small set of keys
const ignoredKeys = new Set(["prev", "next", "range"]);function getVisitorKeys(node, nonTraversableKeys) {  return Object.keys(node).filter(    (key) => !nonTraversableKeys.has(key) && !ignoredKeys.has(key),  );}
(optional) insertPragma‚Äã
A plugin can implement how a pragma comment is inserted in the resulting code when the --insert-pragma option is used, in the insertPragma function. Its signature is:
function insertPragma(text: string): string;
Handling comments in a printer‚Äã
Comments are often not part of a language's AST and present a challenge for pretty printers. A Prettier plugin can either print comments itself in its print function or rely on Prettier's comment algorithm.
By default, if the AST has a top-level comments property, Prettier assumes that comments stores an array of comment nodes. Prettier will then use the provided parsers[<plugin>].locStart/locEnd functions to search for the AST node that each comment "belongs" to. Comments are then attached to these nodes mutating the AST in the process, and the comments property is deleted from the AST root. The *Comment functions are used to adjust Prettier's algorithm. Once the comments are attached to the AST, Prettier will automatically call the printComment(path, options): Doc function and insert the returned doc into the (hopefully) correct place.
(optional) getCommentChildNodes‚Äã
By default, Prettier searches all object properties (except for a few predefined ones) of each node recursively. This function can be provided to override that behavior. It has the signature:
function getCommentChildNodes(  // The node whose children should be returned.  node: AST,  // Current options  options: object,): AST[] | undefined;
Return [] if the node has no children or undefined to fall back on the default behavior.
(optional) printComment‚Äã
Called whenever a comment node needs to be printed. It has the signature:
function printComment(  // Path to the current comment node  commentPath: AstPath,  // Current options  options: object,): Doc;
(optional) canAttachComment‚Äã
function canAttachComment(node: AST): boolean;
This function is used for deciding whether a comment can be attached to a particular AST node. By default, all AST properties are traversed searching for nodes that comments can be attached to. This function is used to prevent comments from being attached to a particular node. A typical implementation looks like
function canAttachComment(node) {  return node.type && node.type !== "comment";}
(optional) isBlockComment‚Äã
function isBlockComment(node: AST): boolean;
Returns whether or not the AST node is a block comment.
(optional) handleComments‚Äã
The handleComments object contains three optional functions, each with signature
(  // The AST node corresponding to the comment  comment: AST,  // The full source code text  text: string,  // The global options object  options: object,  // The AST  ast: AST,  // Whether this comment is the last comment  isLastComment: boolean,) => boolean;
These functions are used to override Prettier's default comment attachment algorithm. ownLine/endOfLine/remaining is expected to either manually attach a comment to a node and return true, or return false and let Prettier attach the comment.
Based on the text surrounding a comment node, Prettier dispatches:

ownLine if a comment has only whitespace preceding it and a newline afterwards,
endOfLine if a comment has a newline afterwards but some non-whitespace preceding it,
remaining in all other cases.

At the time of dispatching, Prettier will have annotated each AST comment node (i.e., created new properties) with at least one of enclosingNode, precedingNode, or followingNode. These can be used to aid a plugin's decision process (of course the entire AST and original text is also passed in for making more complicated decisions).
Manually attaching a comment‚Äã
The util.addTrailingComment/addLeadingComment/addDanglingComment functions can be used to manually attach a comment to an AST node. An example ownLine function that ensures a comment does not follow a "punctuation" node (made up for demonstration purposes) might look like:
import { util } from "prettier";function ownLine(comment, text, options, ast, isLastComment) {  const { precedingNode } = comment;  if (precedingNode && precedingNode.type === "punctuation") {    util.addTrailingComment(precedingNode, comment);    return true;  }  return false;}
Nodes with comments are expected to have a comments property containing an array of comments. Each comment is expected to have the following properties: leading, trailing, printed.
The example above uses util.addTrailingComment, which automatically sets comment.leading/trailing/printed to appropriate values and adds the comment to the AST node's comments array.
The --debug-print-comments CLI flag can help with debugging comment attachment issues. It prints a detailed list of comments, which includes information on how every comment was classified (ownLine/endOfLine/remaining, leading/trailing/dangling) and to which node it was attached. For Prettier‚Äôs built-in languages, this information is also available on the Playground (the 'show comments' checkbox in the Debug section).
options‚Äã
options is an object containing the custom options your plugin supports.
Example:
export default {  // ... plugin implementation  options: {    openingBraceNewLine: {      type: "boolean",      category: "Global",      default: true,      description: "Move open brace for code blocks onto new line.",    },  },};
defaultOptions‚Äã
If your plugin requires different default values for some of Prettier‚Äôs core options, you can specify them in defaultOptions:
export default {  // ... plugin implementation  defaultOptions: {    tabWidth: 4,  },};
Utility functions‚Äã
A util module from Prettier core is considered a private API and is not meant to be consumed by plugins. Instead, the util-shared module provides the following limited set of utility functions for plugins:
type Quote = '"' | "'";type SkipOptions = { backwards?: boolean };function getMaxContinuousCount(text: string, searchString: string): number;function getStringWidth(text: string): number;function getAlignmentSize(  text: string,  tabWidth: number,  startIndex?: number,): number;function getIndentSize(value: string, tabWidth: number): number;function skip(  characters: string | RegExp,): (  text: string,  startIndex: number | false,  options?: SkipOptions,) => number | false;function skipWhitespace(  text: string,  startIndex: number | false,  options?: SkipOptions,): number | false;function skipSpaces(  text: string,  startIndex: number | false,  options?: SkipOptions,): number | false;function skipToLineEnd(  text: string,  startIndex: number | false,  options?: SkipOptions,): number | false;function skipEverythingButNewLine(  text: string,  startIndex: number | false,  options?: SkipOptions,): number | false;function skipInlineComment(  text: string,  startIndex: number | false,): number | false;function skipTrailingComment(  text: string,  startIndex: number | false,): number | false;function skipNewline(  text: string,  startIndex: number | false,  options?: SkipOptions,): number | false;function hasNewline(  text: string,  startIndex: number,  options?: SkipOptions,): boolean;function hasNewlineInRange(  text: string,  startIndex: number,  startIndex: number,): boolean;function hasSpaces(  text: string,  startIndex: number,  options?: SkipOptions,): boolean;function getPreferredQuote(  text: string,  preferredQuoteOrPreferSingleQuote: Quote | boolean,): Quote;function makeString(  rawText: string,  enclosingQuote: Quote,  unescapeUnnecessaryEscapes?: boolean,): string;function getNextNonSpaceNonCommentCharacter(  text: string,  startIndex: number,): string;function getNextNonSpaceNonCommentCharacterIndex(  text: string,  startIndex: number,): number | false;function isNextLineEmpty(text: string, startIndex: number): boolean;function isPreviousLineEmpty(text: string, startIndex: number): boolean;
Tutorials‚Äã

How to write a plugin for Prettier: Teaches you how to write a very basic Prettier plugin for TOML.

Testing Plugins‚Äã
Since plugins can be resolved using relative paths, when working on one you can do:
import * as prettier from "prettier";const code = "(add 1 2)";await prettier.format(code, {  parser: "lisp",  plugins: ["."],});
This will resolve a plugin relative to the current working directory.Edit this page\n\nThis is unreleased documentation for Prettier next version.For up-to-date documentation, see the latest version (stable).On this pagePluginsPlugins are ways of adding new languages or formatting rules to Prettier. Prettier‚Äôs own implementations of all languages are expressed using the plugin API. The core prettier package contains JavaScript and other web-focused languages built in. For additional languages you‚Äôll need to install a plugin.
Using Plugins‚Äã
You can load plugins with:


The CLI, via --plugin:
prettier --write main.foo --plugin=prettier-plugin-foo
tipYou can set --plugin options multiple times.


The API, via the plugins options:
await prettier.format("code", {  parser: "foo",  plugins: ["prettier-plugin-foo"],});


The Configuration File:
{  "plugins": ["prettier-plugin-foo"]}


Strings provided to plugins are ultimately passed to import() expression, so you can provide a module/package name, a path, or anything else import() takes.
Official Plugins‚Äã

@prettier/plugin-php
@prettier/plugin-pug by @Shinigami92
@prettier/plugin-ruby
@prettier/plugin-xml

Community Plugins‚Äã

prettier-plugin-apex by @dangmai
prettier-plugin-astro by @withastro contributors
prettier-plugin-elm by @giCentre
prettier-plugin-erb by @adamzapasnik
prettier-plugin-gherkin by @mapado
prettier-plugin-glsl by @NaridaL
prettier-plugin-go-template by @NiklasPor
prettier-plugin-java by @JHipster
prettier-plugin-jinja-template by @davidodenwald
prettier-plugin-jsonata by @Stedi
prettier-plugin-kotlin by @Angry-Potato
prettier-plugin-motoko by @dfinity
prettier-plugin-nginx by @joedeandev
prettier-plugin-prisma by @umidbekk
prettier-plugin-properties by @eemeli
prettier-plugin-rust by @jinxdash
prettier-plugin-sh by @JounQin
prettier-plugin-sql by @JounQin
prettier-plugin-sql-cst by @nene
prettier-plugin-solidity by @mattiaerre
prettier-plugin-svelte by @sveltejs
prettier-plugin-toml by @JounQin and @so1ve

Developing Plugins‚Äã
Prettier plugins are regular JavaScript modules with the following five exports or default export with the following properties:

languages
parsers
printers
options
defaultOptions

languages‚Äã
Languages is an array of language definitions that your plugin will contribute to Prettier. It can include all of the fields specified in prettier.getSupportInfo().
It must include name and parsers.
export const languages = [  {    // The language name    name: "InterpretedDanceScript",    // Parsers that can parse this language.    // This can be built-in parsers, or parsers you have contributed via this plugin.    parsers: ["dance-parse"],  },];
parsers‚Äã
Parsers convert code as a string into an AST.
The key must match the name in the parsers array from languages. The value contains a parse function, an AST format name, and two location extraction functions (locStart and locEnd).
export const parsers = {  "dance-parse": {    parse,    // The name of the AST that the parser produces.    astFormat: "dance-ast",    hasPragma,    hasIgnorePragma,    locStart,    locEnd,    preprocess,  },};
The signature of the parse function is:
function parse(text: string, options: object): Promise<AST> | AST;
The location extraction functions (locStart and locEnd) return the starting and ending locations of a given AST node:
function locStart(node: object): number;
(Optional) The pragma detection function (hasPragma) should return if the text contains the pragma comment.
function hasPragma(text: string): boolean;
(Optional) The "ignore pragma" detection function (hasIgnorePragma) should return if the text contains a pragma indicating the text should not be formatted.
function hasIgnorePragma(text: string): boolean;
(Optional) The preprocess function can process the input text before passing into parse function.
function preprocess(text: string, options: object): string;
printers‚Äã
Printers convert ASTs into a Prettier intermediate representation, also known as a Doc.
The key must match the astFormat that the parser produces. The value contains an object with a print function. All other properties (embed, preprocess, etc.) are optional.
export const printers = {  "dance-ast": {    print,    embed,    preprocess,    getVisitorKeys,    insertPragma,    canAttachComment,    isBlockComment,    printComment,    getCommentChildNodes,    handleComments: {      ownLine,      endOfLine,      remaining,    },  },};
The printing process‚Äã
Prettier uses an intermediate representation, called a Doc, which Prettier then turns into a string (based on options like printWidth). A printer's job is to take the AST generated by parsers[<parser name>].parse and return a Doc. A Doc is constructed using builder commands:
import { doc } from "prettier";const { join, line, ifBreak, group } = doc.builders;
The printing process consists of the following steps:

AST preprocessing (optional). See preprocess.
Comment attachment (optional). See Handling comments in a printer.
Processing embedded languages (optional). The embed method, if defined, is called for each node, depth-first. While, for performance reasons, the recursion itself is synchronous, embed may return asynchronous functions that can call other parsers and printers to compose docs for embedded syntaxes like CSS-in-JS. These returned functions are queued up and sequentially executed before the next step.
Recursive printing. A doc is recursively constructed from the AST. Starting from the root node:

If, from the step 3, there is an embedded language doc associated with the current node, this doc is used.
Otherwise, the print(path, options, print): Doc method is called. It composes a doc for the current node, often by printing child nodes using the print callback.



print‚Äã
Most of the work of a plugin's printer will take place in its print function, whose signature is:
function print(  // Path to the AST node to print  path: AstPath,  options: object,  // Recursively print a child node  print: (selector?: string | number | Array<string | number> | AstPath) => Doc,): Doc;
The print function is passed the following parameters:

path: An object, which can be used to access nodes in the AST. It‚Äôs a stack-like data structure that maintains the current state of the recursion. It is called ‚Äúpath‚Äù because it represents the path to the current node from the root of the AST. The current node is returned by path.node.
options: A persistent object, which contains global options and which a plugin may mutate to store contextual data.
print: A callback for printing sub-nodes. This function contains the core printing logic that consists of steps whose implementation is provided by plugins. In particular, it calls the printer‚Äôs print function and passes itself to it. Thus, the two print functions ‚Äì the one from the core and the one from the plugin ‚Äì call each other while descending down the AST recursively.

Here‚Äôs a simplified example to give an idea of what a typical implementation of print looks like:
import { doc } from "prettier";const { group, indent, join, line, softline } = doc.builders;function print(path, options, print) {  const node = path.node;  switch (node.type) {    case "list":      return group([        "(",        indent([softline, join(line, path.map(print, "elements"))]),        softline,        ")",      ]);    case "pair":      return group([        "(",        indent([softline, print("left"), line, ". ", print("right")]),        softline,        ")",      ]);    case "symbol":      return node.name;  }  throw new Error(`Unknown node type: ${node.type}`);}
Check out prettier-python's printer for some examples of what is possible.
(optional) embed‚Äã
A printer can have the embed method to print one language inside another. Examples of this are printing CSS-in-JS or fenced code blocks in Markdown. The signature is:
function embed(  // Path to the current AST node  path: AstPath,  // Current options  options: Options,):  | ((      // Parses and prints the passed text using a different parser.      // You should set `options.parser` to specify which parser to use.      textToDoc: (text: string, options: Options) => Promise<Doc>,      // Prints the current node or its descendant node with the current printer      print: (        selector?: string | number | Array<string | number> | AstPath,      ) => Doc,      // The following two arguments are passed for convenience.      // They're the same `path` and `options` that are passed to `embed`.      path: AstPath,      options: Options,    ) => Promise<Doc | undefined> | Doc | undefined)  | Doc  | undefined;
The embed method is similar to the print method in that it maps AST nodes to docs, but unlike print, it has power to do async work by returning an async function. That function's first parameter, the textToDoc async function, can be used to render a doc using a different plugin.
If a function returned from embed returns a doc or a promise that resolves to a doc, that doc will be used in printing, and the print method won‚Äôt be called for this node. It's also possible and, in rare situations, might be convenient to return a doc synchronously directly from embed, however textToDoc and the print callback aren‚Äôt available at that case. Return a function to get them.
If embed returns undefined, or if a function it returned returns undefined or a promise that resolves to undefined, the node will be printed normally with the print method. Same will happen if a returned function throws an error or returns a promise that rejects (e.g., if a parsing error has happened). Set the PRETTIER_DEBUG environment variable to a non-empty value if you want Prettier to rethrow these errors.
For example, a plugin that has nodes with embedded JavaScript might have the following embed method:
function embed(path, options) {  const node = path.node;  if (node.type === "javascript") {    return async (textToDoc) => {      return [        "<script>",        hardline,        await textToDoc(node.javaScriptCode, { parser: "babel" }),        hardline,        "</script>",      ];    };  }}
If the --embedded-language-formatting option is set to off, the embedding step is entirely skipped, embed isn‚Äôt called, and all nodes are printed with the print method.
(optional) preprocess‚Äã
The preprocess method can process the AST from the parser before passing it into the print method.
function preprocess(ast: AST, options: Options): AST | Promise<AST>;
(optional) getVisitorKeys‚Äã
This property might come in handy if the plugin uses comment attachment or embedded languages. These features traverse the AST iterating through all the own enumerable properties of each node starting from the root. If the AST has cycles, such a traverse ends up in an infinite loop. Also, nodes might contain non-node objects (e.g., location data), iterating through which is a waste of resources. To solve these issues, the printer can define a function to return property names that should be traversed.
Its signature is:
function getVisitorKeys(node, nonTraversableKeys: Set<string>): string[];
The default getVisitorKeys:
function getVisitorKeys(node, nonTraversableKeys) {  return Object.keys(node).filter((key) => !nonTraversableKeys.has(key));}
The second argument nonTraversableKeys is a set of common keys and keys that prettier used internal.
If you have full list of visitor keys
const visitorKeys = {  Program: ["body"],  Identifier: [],  // ...};function getVisitorKeys(node /* , nonTraversableKeys*/) {  // Return `[]` for unknown node to prevent Prettier fallback to use `Object.keys()`  return visitorKeys[node.type] ?? [];}
If you only need exclude a small set of keys
const ignoredKeys = new Set(["prev", "next", "range"]);function getVisitorKeys(node, nonTraversableKeys) {  return Object.keys(node).filter(    (key) => !nonTraversableKeys.has(key) && !ignoredKeys.has(key),  );}
(optional) insertPragma‚Äã
A plugin can implement how a pragma comment is inserted in the resulting code when the --insert-pragma option is used, in the insertPragma function. Its signature is:
function insertPragma(text: string): string;
Handling comments in a printer‚Äã
Comments are often not part of a language's AST and present a challenge for pretty printers. A Prettier plugin can either print comments itself in its print function or rely on Prettier's comment algorithm.
By default, if the AST has a top-level comments property, Prettier assumes that comments stores an array of comment nodes. Prettier will then use the provided parsers[<plugin>].locStart/locEnd functions to search for the AST node that each comment "belongs" to. Comments are then attached to these nodes mutating the AST in the process, and the comments property is deleted from the AST root. The *Comment functions are used to adjust Prettier's algorithm. Once the comments are attached to the AST, Prettier will automatically call the printComment(path, options): Doc function and insert the returned doc into the (hopefully) correct place.
(optional) getCommentChildNodes‚Äã
By default, Prettier searches all object properties (except for a few predefined ones) of each node recursively. This function can be provided to override that behavior. It has the signature:
function getCommentChildNodes(  // The node whose children should be returned.  node: AST,  // Current options  options: object,): AST[] | undefined;
Return [] if the node has no children or undefined to fall back on the default behavior.
(optional) printComment‚Äã
Called whenever a comment node needs to be printed. It has the signature:
function printComment(  // Path to the current comment node  commentPath: AstPath,  // Current options  options: object,): Doc;
(optional) canAttachComment‚Äã
function canAttachComment(node: AST): boolean;
This function is used for deciding whether a comment can be attached to a particular AST node. By default, all AST properties are traversed searching for nodes that comments can be attached to. This function is used to prevent comments from being attached to a particular node. A typical implementation looks like
function canAttachComment(node) {  return node.type && node.type !== "comment";}
(optional) isBlockComment‚Äã
function isBlockComment(node: AST): boolean;
Returns whether or not the AST node is a block comment.
(optional) handleComments‚Äã
The handleComments object contains three optional functions, each with signature
(  // The AST node corresponding to the comment  comment: AST,  // The full source code text  text: string,  // The global options object  options: object,  // The AST  ast: AST,  // Whether this comment is the last comment  isLastComment: boolean,) => boolean;
These functions are used to override Prettier's default comment attachment algorithm. ownLine/endOfLine/remaining is expected to either manually attach a comment to a node and return true, or return false and let Prettier attach the comment.
Based on the text surrounding a comment node, Prettier dispatches:

ownLine if a comment has only whitespace preceding it and a newline afterwards,
endOfLine if a comment has a newline afterwards but some non-whitespace preceding it,
remaining in all other cases.

At the time of dispatching, Prettier will have annotated each AST comment node (i.e., created new properties) with at least one of enclosingNode, precedingNode, or followingNode. These can be used to aid a plugin's decision process (of course the entire AST and original text is also passed in for making more complicated decisions).
Manually attaching a comment‚Äã
The util.addTrailingComment/addLeadingComment/addDanglingComment functions can be used to manually attach a comment to an AST node. An example ownLine function that ensures a comment does not follow a "punctuation" node (made up for demonstration purposes) might look like:
import { util } from "prettier";function ownLine(comment, text, options, ast, isLastComment) {  const { precedingNode } = comment;  if (precedingNode && precedingNode.type === "punctuation") {    util.addTrailingComment(precedingNode, comment);    return true;  }  return false;}
Nodes with comments are expected to have a comments property containing an array of comments. Each comment is expected to have the following properties: leading, trailing, printed.
The example above uses util.addTrailingComment, which automatically sets comment.leading/trailing/printed to appropriate values and adds the comment to the AST node's comments array.
The --debug-print-comments CLI flag can help with debugging comment attachment issues. It prints a detailed list of comments, which includes information on how every comment was classified (ownLine/endOfLine/remaining, leading/trailing/dangling) and to which node it was attached. For Prettier‚Äôs built-in languages, this information is also available on the Playground (the 'show comments' checkbox in the Debug section).
options‚Äã
options is an object containing the custom options your plugin supports.
Example:
export default {  // ... plugin implementation  options: {    openingBraceNewLine: {      type: "boolean",      category: "Global",      default: true,      description: "Move open brace for code blocks onto new line.",    },  },};
defaultOptions‚Äã
If your plugin requires different default values for some of Prettier‚Äôs core options, you can specify them in defaultOptions:
export default {  // ... plugin implementation  defaultOptions: {    tabWidth: 4,  },};
Utility functions‚Äã
A util module from Prettier core is considered a private API and is not meant to be consumed by plugins. Instead, the util-shared module provides the following limited set of utility functions for plugins:
type Quote = '"' | "'";type SkipOptions = { backwards?: boolean };function getMaxContinuousCount(text: string, searchString: string): number;function getStringWidth(text: string): number;function getAlignmentSize(  text: string,  tabWidth: number,  startIndex?: number,): number;function getIndentSize(value: string, tabWidth: number): number;function skip(  characters: string | RegExp,): (  text: string,  startIndex: number | false,  options?: SkipOptions,) => number | false;function skipWhitespace(  text: string,  startIndex: number | false,  options?: SkipOptions,): number | false;function skipSpaces(  text: string,  startIndex: number | false,  options?: SkipOptions,): number | false;function skipToLineEnd(  text: string,  startIndex: number | false,  options?: SkipOptions,): number | false;function skipEverythingButNewLine(  text: string,  startIndex: number | false,  options?: SkipOptions,): number | false;function skipInlineComment(  text: string,  startIndex: number | false,): number | false;function skipTrailingComment(  text: string,  startIndex: number | false,): number | false;function skipNewline(  text: string,  startIndex: number | false,  options?: SkipOptions,): number | false;function hasNewline(  text: string,  startIndex: number,  options?: SkipOptions,): boolean;function hasNewlineInRange(  text: string,  startIndex: number,  startIndex: number,): boolean;function hasSpaces(  text: string,  startIndex: number,  options?: SkipOptions,): boolean;function getPreferredQuote(  text: string,  preferredQuoteOrPreferSingleQuote: Quote | boolean,): Quote;function makeString(  rawText: string,  enclosingQuote: Quote,  unescapeUnnecessaryEscapes?: boolean,): string;function getNextNonSpaceNonCommentCharacter(  text: string,  startIndex: number,): string;function getNextNonSpaceNonCommentCharacterIndex(  text: string,  startIndex: number,): number | false;function isNextLineEmpty(text: string, startIndex: number): boolean;function isPreviousLineEmpty(text: string, startIndex: number): boolean;
Tutorials‚Äã

How to write a plugin for Prettier: Teaches you how to write a very basic Prettier plugin for TOML.

Testing Plugins‚Äã
Since plugins can be resolved using relative paths, when working on one you can do:
import * as prettier from "prettier";const code = "(add 1 2)";await prettier.format(code, {  parser: "lisp",  plugins: ["."],});
This will resolve a plugin relative to the current working directory.Edit this pagePreviousPre-commit HookNextCLIUsing PluginsOfficial PluginsCommunity PluginsDeveloping PluginslanguagesparsersprintersoptionsdefaultOptionsUtility functionsTutorialsTesting Plugins\n\n\n\nOn this pageCLIUse the prettier command to run Prettier from the command line.
prettier [options] [file/dir/glob ...]
noteTo run your locally installed version of Prettier, prefix the command with npx, yarn exec, pnpm exec, or bun exec, i.e. npx prettier --help, yarn exec prettier --help, pnpm exec prettier --help, or bun exec prettier --help.
To format a file in-place, use --write. (Note: This overwrites your files!)
In practice, this may look something like:
prettier . --write
This command formats all files supported by Prettier in the current directory and its subdirectories.
It‚Äôs recommended to always make sure that prettier --write . only formats what you want in your project. Use a .prettierignore file to ignore things that should not be formatted.
A more complicated example:
prettier docs package.json "{app,__{tests,mocks}__}/**/*.js" --write --single-quote --trailing-comma all
warningDon‚Äôt forget the quotes around the globs! The quotes make sure that Prettier CLI expands the globs rather than your shell, which is important for cross-platform usage.
noteIt‚Äôs better to use a configuration file for formatting options like --single-quote and --trailing-comma instead of passing them as CLI flags. This way the Prettier CLI, editor integrations, and other tooling can all know what options you use.
File patterns‚Äã
Given a list of paths/patterns, the Prettier CLI first treats every entry in it as a literal path.


If the path points to an existing file, Prettier CLI proceeds with that file and doesn‚Äôt resolve the path as a glob pattern.


If the path points to an existing directory, Prettier CLI recursively finds supported files in that directory. This resolution process is based on file extensions and well-known file names that Prettier and its plugins associate with supported languages.


Otherwise, the entry is resolved as a glob pattern using the glob syntax from the fast-glob module.


Prettier CLI will ignore files located in node_modules directory. To opt out from this behavior, use --with-node-modules flag.
Prettier CLI will not follow symbolic links when expanding arguments.
To escape special characters in globs, one of the two escaping syntaxes can be used: prettier "\[my-dir]/*.js" or prettier "[[]my-dir]/*.js". Both match all JS files in a directory named [my-dir], however the latter syntax is preferable as the former doesn‚Äôt work on Windows, where backslashes are treated as path separators.
--check‚Äã
When you want to check if your files are formatted, you can run Prettier with the --check flag (or -c).
This will output a human-friendly message and a list of unformatted files, if any.
prettier . --check
Console output if all files are formatted:
Checking formatting...All matched files use Prettier code style!
Console output if some of the files require re-formatting:
Checking formatting...[warn] src/fileA.js[warn] src/fileB.js[warn] Code style issues found in 2 files. Run Prettier with --write to fix.
The command will return exit code 1 in the second case, which is helpful inside the CI pipelines.
Human-friendly status messages help project contributors react on possible problems.
To minimise the number of times prettier --check finds unformatted files, you may be interested in configuring a pre-commit hook in your repo.
Applying this practice will minimise the number of times the CI fails because of code formatting problems.
If you need to pipe the list of unformatted files to another command,¬†you can use --list-different flag instead of --check.
Exit codes‚Äã
CodeInformation0Everything formatted properly1Something wasn‚Äôt formatted properly2Something‚Äôs wrong with Prettier
--debug-check‚Äã
If you're worried that Prettier will change the correctness of your code, add --debug-check to the command. This will cause Prettier to print an error message if it detects that code correctness might have changed. Note that --write cannot be used with --debug-check.
--find-config-path and --config‚Äã
If you are repeatedly formatting individual files with prettier, you will incur a small performance cost when Prettier attempts to look up a configuration file. In order to skip this, you may ask Prettier to find the config file once, and re-use it later on.
$ prettier --find-config-path path/to/file.jspath/to/.prettierrc
This will provide you with a path to the configuration file, which you can pass to --config:
prettier path/to/file.js --write --config path/to/.prettierrc
You can also use --config if your configuration file lives somewhere where Prettier cannot find it, such as a config/ directory.
If you don‚Äôt have a configuration file, or want to ignore it if it does exist, you can pass --no-config instead.
--ignore-path‚Äã
Path to a file containing patterns that describe files to ignore. By default, Prettier looks for ./.gitignore and ./.prettierignore.
Multiple values are accepted.
--list-different‚Äã
Another useful flag is --list-different (or -l) which prints the filenames of files that are different from Prettier formatting. If there are differences the script errors out, which is useful in a CI scenario.
prettier . --single-quote --list-different
You can also use --check flag, which works the same way as --list-different, but also prints a human-friendly summary message to stdout.
--no-config‚Äã
Do not look for a configuration file. The default settings will be used.
--config-precedence‚Äã
Defines how config file should be evaluated in combination of CLI options.
cli-override (default)
CLI options take precedence over config file
file-override
Config file take precedence over CLI options
prefer-file
If a config file is found will evaluate it and ignore other CLI options. If no config file is found, CLI options will evaluate as normal.
This option adds support to editor integrations where users define their default configuration but want to respect project specific configuration.
--no-editorconfig‚Äã
Don‚Äôt take .editorconfig into account when parsing configuration. See the prettier.resolveConfig docs for details.
--with-node-modules‚Äã
Prettier CLI will ignore files located in node_modules directory. To opt out from this behavior, use --with-node-modules flag.
--write‚Äã
This rewrites all processed files in place. This is comparable to the eslint --fix workflow. You can also use -w alias.
--log-level‚Äã
Change the level of logging for the CLI. Valid options are:

error
warn
log (default)
debug
silent

--stdin-filepath‚Äã
A path to the file that the Prettier CLI will treat like stdin. For example:
abc.css
.name {  display: none;}
shell
$ cat abc.css | prettier --stdin-filepath abc.css.name {  display: none;}
--ignore-unknown‚Äã
With --ignore-unknown (or -u), prettier will ignore unknown files matched by patterns.
prettier "**/*" --write --ignore-unknown
--no-error-on-unmatched-pattern‚Äã
Prevent errors when pattern is unmatched.
--cache‚Äã
If this option is enabled, the following values are used as cache keys and the file is formatted only if one of them is changed.

Prettier version
Options
Node.js version
(if --cache-strategy is metadata) file metadata, such as timestamps
(if --cache-strategy is content) content of the file

prettier . --write --cache
Running Prettier without --cache will delete the cache.
Also, since the cache file is stored in ./node_modules/.cache/prettier/.prettier-cache, so you can use rm ./node_modules/.cache/prettier/.prettier-cache to remove it manually.
warningPlugins version and implementation are not used as cache keys. We recommend that you delete the cache when updating plugins.
--cache-location‚Äã
Path to the cache file location used by --cache flag. If you don't explicit --cache-location, Prettier saves cache file at ./node_modules/.cache/prettier/.prettier-cache.
If a file path is passed, that file is used as the cache file.
prettier . --write --cache --cache-location=path/to/cache-file
--cache-strategy‚Äã
Strategy for the cache to use for detecting changed files. Can be either metadata or content.
In general, metadata is faster. However, content is useful for updating the timestamp without changing the file content. This can happen, for example, during git operations such as git clone, because it does not track file modification times.
If no strategy is specified, content will be used.
prettier . --write --cache --cache-strategy metadataEdit this page\n\nThis is unreleased documentation for Prettier next version.For up-to-date documentation, see the latest version (stable).On this pageCLIUse the prettier command to run Prettier from the command line.
prettier [options] [file/dir/glob ...]
noteTo run your locally installed version of Prettier, prefix the command with npx, yarn exec, pnpm exec, or bun exec, i.e. npx prettier --help, yarn exec prettier --help, pnpm exec prettier --help, or bun exec prettier --help.
To format a file in-place, use --write. (Note: This overwrites your files!)
In practice, this may look something like:
prettier . --write
This command formats all files supported by Prettier in the current directory and its subdirectories.
It‚Äôs recommended to always make sure that prettier --write . only formats what you want in your project. Use a .prettierignore file to ignore things that should not be formatted.
A more complicated example:
prettier docs package.json "{app,__{tests,mocks}__}/**/*.js" --write --single-quote --trailing-comma all
warningDon‚Äôt forget the quotes around the globs! The quotes make sure that Prettier CLI expands the globs rather than your shell, which is important for cross-platform usage.
noteIt‚Äôs better to use a configuration file for formatting options like --single-quote and --trailing-comma instead of passing them as CLI flags. This way the Prettier CLI, editor integrations, and other tooling can all know what options you use.
File patterns‚Äã
Given a list of paths/patterns, the Prettier CLI first treats every entry in it as a literal path.


If the path points to an existing file, Prettier CLI proceeds with that file and doesn‚Äôt resolve the path as a glob pattern.


If the path points to an existing directory, Prettier CLI recursively finds supported files in that directory. This resolution process is based on file extensions and well-known file names that Prettier and its plugins associate with supported languages.


Otherwise, the entry is resolved as a glob pattern using the glob syntax from the fast-glob module.


Prettier CLI will ignore files located in node_modules directory. To opt out from this behavior, use --with-node-modules flag.
Prettier CLI will not follow symbolic links when expanding arguments.
To escape special characters in globs, one of the two escaping syntaxes can be used: prettier "\[my-dir]/*.js" or prettier "[[]my-dir]/*.js". Both match all JS files in a directory named [my-dir], however the latter syntax is preferable as the former doesn‚Äôt work on Windows, where backslashes are treated as path separators.
--check‚Äã
When you want to check if your files are formatted, you can run Prettier with the --check flag (or -c).
This will output a human-friendly message and a list of unformatted files, if any.
prettier . --check
Console output if all files are formatted:
Checking formatting...All matched files use Prettier code style!
Console output if some of the files require re-formatting:
Checking formatting...[warn] src/fileA.js[warn] src/fileB.js[warn] Code style issues found in 2 files. Run Prettier with --write to fix.
The command will return exit code 1 in the second case, which is helpful inside the CI pipelines.
Human-friendly status messages help project contributors react on possible problems.
To minimise the number of times prettier --check finds unformatted files, you may be interested in configuring a pre-commit hook in your repo.
Applying this practice will minimise the number of times the CI fails because of code formatting problems.
If you need to pipe the list of unformatted files to another command,¬†you can use --list-different flag instead of --check.
Exit codes‚Äã
CodeInformation0Everything formatted properly1Something wasn‚Äôt formatted properly2Something‚Äôs wrong with Prettier
--debug-check‚Äã
If you're worried that Prettier will change the correctness of your code, add --debug-check to the command. This will cause Prettier to print an error message if it detects that code correctness might have changed. Note that --write cannot be used with --debug-check.
--find-config-path and --config‚Äã
If you are repeatedly formatting individual files with prettier, you will incur a small performance cost when Prettier attempts to look up a configuration file. In order to skip this, you may ask Prettier to find the config file once, and re-use it later on.
$ prettier --find-config-path path/to/file.jspath/to/.prettierrc
This will provide you with a path to the configuration file, which you can pass to --config:
prettier path/to/file.js --write --config path/to/.prettierrc
You can also use --config if your configuration file lives somewhere where Prettier cannot find it, such as a config/ directory.
If you don‚Äôt have a configuration file, or want to ignore it if it does exist, you can pass --no-config instead.
--ignore-path‚Äã
Path to a file containing patterns that describe files to ignore. By default, Prettier looks for ./.gitignore and ./.prettierignore.
Multiple values are accepted.
--list-different‚Äã
Another useful flag is --list-different (or -l) which prints the filenames of files that are different from Prettier formatting. If there are differences the script errors out, which is useful in a CI scenario.
prettier . --single-quote --list-different
You can also use --check flag, which works the same way as --list-different, but also prints a human-friendly summary message to stdout.
--no-config‚Äã
Do not look for a configuration file. The default settings will be used.
--config-precedence‚Äã
Defines how config file should be evaluated in combination of CLI options.
cli-override (default)
CLI options take precedence over config file
file-override
Config file take precedence over CLI options
prefer-file
If a config file is found will evaluate it and ignore other CLI options. If no config file is found, CLI options will evaluate as normal.
This option adds support to editor integrations where users define their default configuration but want to respect project specific configuration.
--no-editorconfig‚Äã
Don‚Äôt take .editorconfig into account when parsing configuration. See the prettier.resolveConfig docs for details.
--with-node-modules‚Äã
Prettier CLI will ignore files located in node_modules directory. To opt out from this behavior, use --with-node-modules flag.
--write‚Äã
This rewrites all processed files in place. This is comparable to the eslint --fix workflow. You can also use -w alias.
--log-level‚Äã
Change the level of logging for the CLI. Valid options are:

error
warn
log (default)
debug
silent

--stdin-filepath‚Äã
A path to the file that the Prettier CLI will treat like stdin. For example:
abc.css
.name {  display: none;}
shell
$ cat abc.css | prettier --stdin-filepath abc.css.name {  display: none;}
--ignore-unknown‚Äã
With --ignore-unknown (or -u), prettier will ignore unknown files matched by patterns.
prettier "**/*" --write --ignore-unknown
--no-error-on-unmatched-pattern‚Äã
Prevent errors when pattern is unmatched.
--cache‚Äã
If this option is enabled, the following values are used as cache keys and the file is formatted only if one of them is changed.

Prettier version
Options
Node.js version
(if --cache-strategy is metadata) file metadata, such as timestamps
(if --cache-strategy is content) content of the file

prettier . --write --cache
Running Prettier without --cache will delete the cache.
Also, since the cache file is stored in ./node_modules/.cache/prettier/.prettier-cache, so you can use rm ./node_modules/.cache/prettier/.prettier-cache to remove it manually.
warningPlugins version and implementation are not used as cache keys. We recommend that you delete the cache when updating plugins.
--cache-location‚Äã
Path to the cache file location used by --cache flag. If you don't explicit --cache-location, Prettier saves cache file at ./node_modules/.cache/prettier/.prettier-cache.
If a file path is passed, that file is used as the cache file.
prettier . --write --cache --cache-location=path/to/cache-file
--cache-strategy‚Äã
Strategy for the cache to use for detecting changed files. Can be either metadata or content.
In general, metadata is faster. However, content is useful for updating the timestamp without changing the file content. This can happen, for example, during git operations such as git clone, because it does not track file modification times.
If no strategy is specified, content will be used.
prettier . --write --cache --cache-strategy metadataEdit this pagePreviousPluginsNextAPIFile patterns--checkExit codes--debug-check--find-config-path and --config--ignore-path--list-different--no-config--config-precedence--no-editorconfig--with-node-modules--write--log-level--stdin-filepath--ignore-unknown--no-error-on-unmatched-pattern--cache--cache-location--cache-strategy\n\n\n\nOn this pageAPIIf you want to run Prettier programmatically, check this page out.
import * as prettier from "prettier";
Our public APIs are all asynchronous, if you must use synchronous version for some reason, you can try @prettier/sync.
prettier.format(source, options)‚Äã
format is used to format text using Prettier. options.parser must be set according to the language you are formatting (see the list of available parsers). Alternatively, options.filepath can be specified for Prettier to infer the parser from the file extension. Other options may be provided to override the defaults.
await prettier.format("foo ( );", { semi: false, parser: "babel" });// -> 'foo()\n'
prettier.check(source [, options])‚Äã
check checks to see if the file has been formatted with Prettier given those options and returns a Promise<boolean>. This is similar to the --check or --list-different parameter in the CLI and is useful for running Prettier in CI scenarios.
prettier.formatWithCursor(source [, options])‚Äã
formatWithCursor both formats the code, and translates a cursor position from unformatted code to formatted code. This is useful for editor integrations, to prevent the cursor from moving when code is formatted.
The cursorOffset option should be provided, to specify where the cursor is.
await prettier.formatWithCursor(" 1", { cursorOffset: 2, parser: "babel" });// -> { formatted: '1;\n', cursorOffset: 1 }
prettier.resolveConfig(fileUrlOrPath [, options])‚Äã
resolveConfig can be used to resolve configuration for a given source file, passing its path or url as the first argument. The config search will start at the directory of the file location and continue to search up the directory. Or you can pass directly the path of the config file as options.config if you don‚Äôt wish to search for it. A promise is returned which will resolve to:

An options object, providing a config file was found.
null, if no file was found.

The promise will be rejected if there was an error parsing the configuration file.
If options.useCache is false, all caching will be bypassed.
const text = await fs.readFile(filePath, "utf8");const options = await prettier.resolveConfig(filePath);const formatted = await prettier.format(text, {  ...options,  filepath: filePath,});
If options.editorconfig is true and an .editorconfig file is in your project, Prettier will parse it and convert its properties to the corresponding Prettier configuration. This configuration will be overridden by .prettierrc, etc. Currently, the following EditorConfig properties are supported:

end_of_line
indent_style
indent_size/tab_width
max_line_length

prettier.resolveConfigFile([fileUrlOrPath])‚Äã
resolveConfigFile can be used to find the path of the Prettier configuration file that will be used when resolving the config (i.e. when calling resolveConfig). A promise is returned which will resolve to:

The path of the configuration file.
null, if no file was found.

The promise will be rejected if there was an error parsing the configuration file.
The search starts at process.cwd(), or at the directory of fileUrlOrPath if provided.
const configFile = await prettier.resolveConfigFile(filePath);// you got the path of the configuration file
prettier.clearConfigCache()‚Äã
When Prettier loads configuration files and plugins, the file system structure is cached for performance. This function will clear the cache. Generally this is only needed for editor integrations that know that the file system has changed since the last format took place.
prettier.getFileInfo(fileUrlOrPath [, options])‚Äã
getFileInfo can be used by editor extensions to decide if a particular file needs to be formatted. This method returns a promise, which resolves to an object with the following properties:
{  ignored: boolean;  inferredParser: string | null;}
The promise will be rejected if the type of fileUrlOrPath is not string or URL.
Setting options.ignorePath (string | URL | (string | URL)[]) and options.withNodeModules (boolean) influence the value of ignored (false by default).
If the given fileUrlOrPath is ignored, the inferredParser is always null.
Providing plugin paths in options.plugins ((string | URL | Plugin)[]) helps extract inferredParser for files that are not supported by Prettier core.
When setting options.resolveConfig (boolean, default true) to false, Prettier will not search for configuration file. This can be useful if this function is only used to check if file is ignored.
prettier.getSupportInfo()‚Äã
Returns a promise which resolves to an object representing the options, parsers, languages and file types Prettier supports.
The support information looks like this:
{  languages: Array<{    name: string;    parsers: string[];    group?: string;    tmScope?: string;    aceMode?: string;    codemirrorMode?: string;    codemirrorMimeType?: string;    aliases?: string[];    extensions?: string[];    filenames?: string[];    linguistLanguageId?: number;    vscodeLanguageIds?: string[];    isSupported?(file: string): boolean;  }>;}

Custom Parser API (removed)‚Äã
Removed in v3.0.0 (superseded by the Plugin API)
Before plugins were a thing, Prettier had a similar but more limited feature called custom parsers. It‚Äôs been removed in v3.0.0 as its functionality was a subset of what the Plugin API did. If you used it, please check the example below on how to migrate.
‚ùå Custom parser API (removed):
import { format } from "prettier";format("lodash ( )", {  parser(text, { babel }) {    const ast = babel(text);    ast.program.body[0].expression.callee.name = "_";    return ast;  },});// -> "_();\n"
‚úîÔ∏è Plugin API:
import { format } from "prettier";import * as prettierPluginBabel from "prettier/plugins/babel";const myCustomPlugin = {  parsers: {    "my-custom-parser": {      async parse(text) {        const ast = await prettierPluginBabel.parsers.babel.parse(text);        ast.program.body[0].expression.callee.name = "_";        return ast;      },      astFormat: "estree",    },  },};await format("lodash ( )", {  parser: "my-custom-parser",  plugins: [myCustomPlugin],});// -> "_();\n"
noteOverall, doing codemods this way isn‚Äôt recommended. Prettier uses the location data of AST nodes for many things like preserving blank lines and attaching comments. When the AST is modified after the parsing, the location data often gets out of sync, which may lead to unpredictable results. Consider using jscodeshift if you need codemods.
As part of the removed Custom parser API, it was previously possible to pass a path to a module exporting a parse function via the --parser option. Use the --plugin CLI option or the plugins API option instead to load plugins.Edit this page\n\nThis is unreleased documentation for Prettier next version.For up-to-date documentation, see the latest version (stable).On this pageAPIIf you want to run Prettier programmatically, check this page out.
import * as prettier from "prettier";
Our public APIs are all asynchronous, if you must use synchronous version for some reason, you can try @prettier/sync.
prettier.format(source, options)‚Äã
format is used to format text using Prettier. options.parser must be set according to the language you are formatting (see the list of available parsers). Alternatively, options.filepath can be specified for Prettier to infer the parser from the file extension. Other options may be provided to override the defaults.
await prettier.format("foo ( );", { semi: false, parser: "babel" });// -> 'foo()\n'
prettier.check(source [, options])‚Äã
check checks to see if the file has been formatted with Prettier given those options and returns a Promise<boolean>. This is similar to the --check or --list-different parameter in the CLI and is useful for running Prettier in CI scenarios.
prettier.formatWithCursor(source [, options])‚Äã
formatWithCursor both formats the code, and translates a cursor position from unformatted code to formatted code. This is useful for editor integrations, to prevent the cursor from moving when code is formatted.
The cursorOffset option should be provided, to specify where the cursor is.
await prettier.formatWithCursor(" 1", { cursorOffset: 2, parser: "babel" });// -> { formatted: '1;\n', cursorOffset: 1 }
prettier.resolveConfig(fileUrlOrPath [, options])‚Äã
resolveConfig can be used to resolve configuration for a given source file, passing its path or url as the first argument. The config search will start at the directory of the file location and continue to search up the directory. Or you can pass directly the path of the config file as options.config if you don‚Äôt wish to search for it. A promise is returned which will resolve to:

An options object, providing a config file was found.
null, if no file was found.

The promise will be rejected if there was an error parsing the configuration file.
If options.useCache is false, all caching will be bypassed.
const text = await fs.readFile(filePath, "utf8");const options = await prettier.resolveConfig(filePath);const formatted = await prettier.format(text, {  ...options,  filepath: filePath,});
If options.editorconfig is true and an .editorconfig file is in your project, Prettier will parse it and convert its properties to the corresponding Prettier configuration. This configuration will be overridden by .prettierrc, etc. Currently, the following EditorConfig properties are supported:

end_of_line
indent_style
indent_size/tab_width
max_line_length

prettier.resolveConfigFile([fileUrlOrPath])‚Äã
resolveConfigFile can be used to find the path of the Prettier configuration file that will be used when resolving the config (i.e. when calling resolveConfig). A promise is returned which will resolve to:

The path of the configuration file.
null, if no file was found.

The promise will be rejected if there was an error parsing the configuration file.
The search starts at process.cwd(), or at the directory of fileUrlOrPath if provided.
const configFile = await prettier.resolveConfigFile(filePath);// you got the path of the configuration file
prettier.clearConfigCache()‚Äã
When Prettier loads configuration files and plugins, the file system structure is cached for performance. This function will clear the cache. Generally this is only needed for editor integrations that know that the file system has changed since the last format took place.
prettier.getFileInfo(fileUrlOrPath [, options])‚Äã
getFileInfo can be used by editor extensions to decide if a particular file needs to be formatted. This method returns a promise, which resolves to an object with the following properties:
{  ignored: boolean;  inferredParser: string | null;}
The promise will be rejected if the type of fileUrlOrPath is not string or URL.
Setting options.ignorePath (string | URL | (string | URL)[]) and options.withNodeModules (boolean) influence the value of ignored (false by default).
If the given fileUrlOrPath is ignored, the inferredParser is always null.
Providing plugin paths in options.plugins ((string | URL | Plugin)[]) helps extract inferredParser for files that are not supported by Prettier core.
When setting options.resolveConfig (boolean, default true) to false, Prettier will not search for configuration file. This can be useful if this function is only used to check if file is ignored.
prettier.getSupportInfo()‚Äã
Returns a promise which resolves to an object representing the options, parsers, languages and file types Prettier supports.
The support information looks like this:
{  languages: Array<{    name: string;    parsers: string[];    group?: string;    tmScope?: string;    aceMode?: string;    codemirrorMode?: string;    codemirrorMimeType?: string;    aliases?: string[];    extensions?: string[];    filenames?: string[];    linguistLanguageId?: number;    vscodeLanguageIds?: string[];    isSupported?(file: string): boolean;  }>;}

Custom Parser API (removed)‚Äã
Removed in v3.0.0 (superseded by the Plugin API)
Before plugins were a thing, Prettier had a similar but more limited feature called custom parsers. It‚Äôs been removed in v3.0.0 as its functionality was a subset of what the Plugin API did. If you used it, please check the example below on how to migrate.
‚ùå Custom parser API (removed):
import { format } from "prettier";format("lodash ( )", {  parser(text, { babel }) {    const ast = babel(text);    ast.program.body[0].expression.callee.name = "_";    return ast;  },});// -> "_();\n"
‚úîÔ∏è Plugin API:
import { format } from "prettier";import * as prettierPluginBabel from "prettier/plugins/babel";const myCustomPlugin = {  parsers: {    "my-custom-parser": {      async parse(text) {        const ast = await prettierPluginBabel.parsers.babel.parse(text);        ast.program.body[0].expression.callee.name = "_";        return ast;      },      astFormat: "estree",    },  },};await format("lodash ( )", {  parser: "my-custom-parser",  plugins: [myCustomPlugin],});// -> "_();\n"
noteOverall, doing codemods this way isn‚Äôt recommended. Prettier uses the location data of AST nodes for many things like preserving blank lines and attaching comments. When the AST is modified after the parsing, the location data often gets out of sync, which may lead to unpredictable results. Consider using jscodeshift if you need codemods.
As part of the removed Custom parser API, it was previously possible to pass a path to a module exporting a parse function via the --parser option. Use the --plugin CLI option or the plugins API option instead to load plugins.Edit this pagePreviousCLINextBrowserprettier.format(source, options)prettier.check(source [, options])prettier.formatWithCursor(source [, options])prettier.resolveConfig(fileUrlOrPath [, options])prettier.resolveConfigFile([fileUrlOrPath])prettier.clearConfigCache()prettier.getFileInfo(fileUrlOrPath [, options])prettier.getSupportInfo()Custom Parser API (removed)\n\n\n\nOn this pageBrowserRun Prettier in the browser using its standalone version. This version doesn‚Äôt depend on Node.js. It only formats the code and has no support for config files, ignore files, CLI usage, or automatic loading of plugins.
The standalone version comes as:

ES modules: standalone.mjs, starting in version 3.0 (In version 2, esm/standalone.mjs.)
UMD: standalone.js, starting in version 1.13

The browser field in Prettier‚Äôs package.json points to standalone.js. That‚Äôs why you can just import or require the prettier module to access Prettier‚Äôs API, and your code can stay compatible with both Node and the browser as long as webpack or another bundler that supports the browser field is used. This is especially convenient for plugins.
prettier.format(code, options)‚Äã
Required options:


parser (or filepath): One of these options has to be specified for Prettier to know which parser to use.


plugins: Unlike the format function from the Node.js-based API, this function doesn‚Äôt load plugins automatically. The plugins option is required because all the parsers included in the Prettier package come as plugins (for reasons of file size). These plugins are files in https://unpkg.com/browse/prettier@%PRETTIER_VERSION%/plugins. Note that estree plugin should be loaded when printing JavaScript, TypeScript, Flow, or JSON.
You need to load the ones that you‚Äôre going to use and pass them to prettier.format using the plugins option.


See below for examples.
Usage‚Äã
Global‚Äã
<script src="https://unpkg.com/prettier@%PRETTIER_VERSION%/standalone.js"></script><script src="https://unpkg.com/prettier@%PRETTIER_VERSION%/plugins/graphql.js"></script><script>  (async () => {    const formatted = await prettier.format("type Query { hello: String }", {      parser: "graphql",      plugins: prettierPlugins,    });  })();</script>
Note that the unpkg field in Prettier‚Äôs package.json points to standalone.js, that‚Äôs why https://unpkg.com/prettier can also be used instead of https://unpkg.com/prettier/standalone.js.
ES Modules‚Äã
<script type="module">  import * as prettier from "https://unpkg.com/prettier@%PRETTIER_VERSION%/standalone.mjs";  import * as prettierPluginGraphql from "https://unpkg.com/prettier@%PRETTIER_VERSION%/plugins/graphql.mjs";  const formatted = await prettier.format("type Query { hello: String }", {    parser: "graphql",    plugins: [prettierPluginGraphql],  });</script>
AMD‚Äã
define([  "https://unpkg.com/prettier@%PRETTIER_VERSION%/standalone.js",  "https://unpkg.com/prettier@%PRETTIER_VERSION%/plugins/graphql.js",], async (prettier, ...plugins) => {  const formatted = await prettier.format("type Query { hello: String }", {    parser: "graphql",    plugins,  });});
CommonJS‚Äã
const prettier = require("prettier/standalone");const plugins = [require("prettier/plugins/graphql")];(async () => {  const formatted = await prettier.format("type Query { hello: String }", {    parser: "graphql",    plugins,  });})();
This syntax doesn‚Äôt necessarily work in the browser, but it can be used when bundling the code with browserify, Rollup, webpack, or another bundler.
Worker‚Äã
Module workerClassic workerimport * as prettier from "https://unpkg.com/prettier@%PRETTIER_VERSION%/standalone.mjs";import * as prettierPluginGraphql from "https://unpkg.com/prettier@%PRETTIER_VERSION%1/plugins/graphql.mjs";const formatted = await prettier.format("type Query { hello: String }", {  parser: "graphql",  plugins: [prettierPluginGraphql],});importScripts(  "https://unpkg.com/prettier@%PRETTIER_VERSION%/standalone.js",  "https://unpkg.com/prettier@%PRETTIER_VERSION%/plugins/graphql.js",);(async () => {  const formatted = await prettier.format("type Query { hello: String }", {    parser: "graphql",    plugins: prettierPlugins,  });})();
Parser plugins for embedded code‚Äã
If you want to format embedded code, you need to load related plugins too. For example:
<script type="module">  import * as prettier from "https://unpkg.com/prettier@%PRETTIER_VERSION%/standalone.mjs";  import * as prettierPluginBabel from "https://unpkg.com/prettier@%PRETTIER_VERSION%/plugins/babel.mjs";  import * as prettierPluginEstree from "https://unpkg.com/prettier@%PRETTIER_VERSION%/plugins/estree.mjs";  console.log(    await prettier.format("const html=/* HTML */ `<DIV> </DIV>`", {      parser: "babel",      plugins: [prettierPluginBabel, prettierPluginEstree],    }),  );  // Output: const html = /* HTML */ `<DIV> </DIV>`;</script>
The HTML code embedded in JavaScript stays unformatted because the html parser hasn‚Äôt been loaded. Correct usage:
<script type="module">  import * as prettier from "https://unpkg.com/prettier@%PRETTIER_VERSION%/standalone.mjs";  import * as prettierPluginBabel from "https://unpkg.com/prettier@%PRETTIER_VERSION%/plugins/babel.mjs";  import * as prettierPluginEstree from "https://unpkg.com/prettier@%PRETTIER_VERSION%/plugins/estree.mjs";  import * as prettierPluginHtml from "https://unpkg.com/prettier@%PRETTIER_VERSION%/plugins/html.mjs";  console.log(    await prettier.format("const html=/* HTML */ `<DIV> </DIV>`", {      parser: "babel",      plugins: [prettierPluginBabel, prettierPluginEstree, prettierPluginHtml],    }),  );  // Output: const html = /* HTML */ `<div></div>`;</script>Edit this page\n\nThis is unreleased documentation for Prettier next version.For up-to-date documentation, see the latest version (stable).On this pageBrowserRun Prettier in the browser using its standalone version. This version doesn‚Äôt depend on Node.js. It only formats the code and has no support for config files, ignore files, CLI usage, or automatic loading of plugins.
The standalone version comes as:

ES modules: standalone.mjs, starting in version 3.0 (In version 2, esm/standalone.mjs.)
UMD: standalone.js, starting in version 1.13

The browser field in Prettier‚Äôs package.json points to standalone.js. That‚Äôs why you can just import or require the prettier module to access Prettier‚Äôs API, and your code can stay compatible with both Node and the browser as long as webpack or another bundler that supports the browser field is used. This is especially convenient for plugins.
prettier.format(code, options)‚Äã
Required options:


parser (or filepath): One of these options has to be specified for Prettier to know which parser to use.


plugins: Unlike the format function from the Node.js-based API, this function doesn‚Äôt load plugins automatically. The plugins option is required because all the parsers included in the Prettier package come as plugins (for reasons of file size). These plugins are files in https://unpkg.com/browse/prettier@%PRETTIER_VERSION%/plugins. Note that estree plugin should be loaded when printing JavaScript, TypeScript, Flow, or JSON.
You need to load the ones that you‚Äôre going to use and pass them to prettier.format using the plugins option.


See below for examples.
Usage‚Äã
Global‚Äã
<script src="https://unpkg.com/prettier@%PRETTIER_VERSION%/standalone.js"></script><script src="https://unpkg.com/prettier@%PRETTIER_VERSION%/plugins/graphql.js"></script><script>  (async () => {    const formatted = await prettier.format("type Query { hello: String }", {      parser: "graphql",      plugins: prettierPlugins,    });  })();</script>
Note that the unpkg field in Prettier‚Äôs package.json points to standalone.js, that‚Äôs why https://unpkg.com/prettier can also be used instead of https://unpkg.com/prettier/standalone.js.
ES Modules‚Äã
<script type="module">  import * as prettier from "https://unpkg.com/prettier@%PRETTIER_VERSION%/standalone.mjs";  import * as prettierPluginGraphql from "https://unpkg.com/prettier@%PRETTIER_VERSION%/plugins/graphql.mjs";  const formatted = await prettier.format("type Query { hello: String }", {    parser: "graphql",    plugins: [prettierPluginGraphql],  });</script>
AMD‚Äã
define([  "https://unpkg.com/prettier@%PRETTIER_VERSION%/standalone.js",  "https://unpkg.com/prettier@%PRETTIER_VERSION%/plugins/graphql.js",], async (prettier, ...plugins) => {  const formatted = await prettier.format("type Query { hello: String }", {    parser: "graphql",    plugins,  });});
CommonJS‚Äã
const prettier = require("prettier/standalone");const plugins = [require("prettier/plugins/graphql")];(async () => {  const formatted = await prettier.format("type Query { hello: String }", {    parser: "graphql",    plugins,  });})();
This syntax doesn‚Äôt necessarily work in the browser, but it can be used when bundling the code with browserify, Rollup, webpack, or another bundler.
Worker‚Äã
Module workerClassic workerimport * as prettier from "https://unpkg.com/prettier@%PRETTIER_VERSION%/standalone.mjs";import * as prettierPluginGraphql from "https://unpkg.com/prettier@%PRETTIER_VERSION%1/plugins/graphql.mjs";const formatted = await prettier.format("type Query { hello: String }", {  parser: "graphql",  plugins: [prettierPluginGraphql],});importScripts(  "https://unpkg.com/prettier@%PRETTIER_VERSION%/standalone.js",  "https://unpkg.com/prettier@%PRETTIER_VERSION%/plugins/graphql.js",);(async () => {  const formatted = await prettier.format("type Query { hello: String }", {    parser: "graphql",    plugins: prettierPlugins,  });})();
Parser plugins for embedded code‚Äã
If you want to format embedded code, you need to load related plugins too. For example:
<script type="module">  import * as prettier from "https://unpkg.com/prettier@%PRETTIER_VERSION%/standalone.mjs";  import * as prettierPluginBabel from "https://unpkg.com/prettier@%PRETTIER_VERSION%/plugins/babel.mjs";  import * as prettierPluginEstree from "https://unpkg.com/prettier@%PRETTIER_VERSION%/plugins/estree.mjs";  console.log(    await prettier.format("const html=/* HTML */ `<DIV> </DIV>`", {      parser: "babel",      plugins: [prettierPluginBabel, prettierPluginEstree],    }),  );  // Output: const html = /* HTML */ `<DIV> </DIV>`;</script>
The HTML code embedded in JavaScript stays unformatted because the html parser hasn‚Äôt been loaded. Correct usage:
<script type="module">  import * as prettier from "https://unpkg.com/prettier@%PRETTIER_VERSION%/standalone.mjs";  import * as prettierPluginBabel from "https://unpkg.com/prettier@%PRETTIER_VERSION%/plugins/babel.mjs";  import * as prettierPluginEstree from "https://unpkg.com/prettier@%PRETTIER_VERSION%/plugins/estree.mjs";  import * as prettierPluginHtml from "https://unpkg.com/prettier@%PRETTIER_VERSION%/plugins/html.mjs";  console.log(    await prettier.format("const html=/* HTML */ `<DIV> </DIV>`", {      parser: "babel",      plugins: [prettierPluginBabel, prettierPluginEstree, prettierPluginHtml],    }),  );  // Output: const html = /* HTML */ `<div></div>`;</script>Edit this pagePreviousAPINextRun Prettier on CIprettier.format(code, options)UsageGlobalES ModulesAMDCommonJSWorkerParser plugins for embedded code\n\n\n\nOn this pageRun Prettier on CIGitHub Actions‚Äã
To apply autofix for Prettier from GitHub Actions, do the following:


Install the autofix.ci GitHub App.


Make sure you have a pinned version of Prettier installed in your repository.


Create .github/workflows/prettier.yml with following content:
.github/workflows/prettier.ymlname: autofix.cion:  pull_request:  push:permissions: {}jobs:  prettier:    runs-on: ubuntu-latest    steps:      - uses: actions/checkout@v4      - uses: actions/setup-node@v4      - run: |          yarn          yarn prettier . --write      - uses: autofix-ci/action@v1        with:          commit-message: "Apply Prettier format"


For more information see autofix.ci website.Edit this page\n\nThis is unreleased documentation for Prettier next version.For up-to-date documentation, see the latest version (stable).On this pageRun Prettier on CIGitHub Actions‚Äã
To apply autofix for Prettier from GitHub Actions, do the following:


Install the autofix.ci GitHub App.


Make sure you have a pinned version of Prettier installed in your repository.


Create .github/workflows/prettier.yml with following content:
.github/workflows/prettier.ymlname: autofix.cion:  pull_request:  push:permissions: {}jobs:  prettier:    runs-on: ubuntu-latest    steps:      - uses: actions/checkout@v4      - uses: actions/setup-node@v4      - run: |          yarn          yarn prettier . --write      - uses: autofix-ci/action@v1        with:          commit-message: "Apply Prettier format"


For more information see autofix.ci website.Edit this pagePreviousBrowserNextOptionsGitHub Actions\n\n\n\nOn this pageOptionsPrettier ships with a handful of format options.
To learn more about Prettier‚Äôs stance on options ‚Äì see the Option Philosophy.
If you change any options, it‚Äôs recommended to do it via a configuration file. This way the Prettier CLI, editor integrations and other tooling knows what options you use.
Experimental Ternaries‚Äã
Try prettier's new ternary formatting before it becomes the default behavior.
Valid options:

true - Use curious ternaries, with the question mark after the condition.
false - Retain the default behavior of ternaries; keep question marks on the same line as the consequent.

DefaultCLI OverrideAPI Overridefalse--experimental-ternariesexperimentalTernaries: <bool>
Experimental Operator Position‚Äã
Valid options:

"start" - When binary expressions wrap lines, print operators at the start of new lines.
"end" - Default behavior; when binary expressions wrap lines, print operators at the end of previous lines.

DefaultCLI OverrideAPI Override"end"--experimental-operator-position <start|end>experimentalOperatorPosition: "<start|end>"
Print Width‚Äã
Specify the line length that the printer will wrap on.
warningFor readability we recommend against using more than 80 characters:In code styleguides, maximum line length rules are often set to 100 or 120. However, when humans write code, they don‚Äôt strive to reach the maximum number of columns on every line. Developers often use whitespace to break up long lines for readability. In practice, the average line length often ends up well below the maximum.Prettier‚Äôs printWidth option does not work the same way. It is not the hard upper allowed line length limit. It is a way to say to Prettier roughly how long you‚Äôd like lines to be. Prettier will make both shorter and longer lines, but generally strive to meet the specified printWidth.Remember, computers are dumb. You need to explicitly tell them what to do, while humans can make their own (implicit) judgements, for example on when to break a line.In other words, don‚Äôt try to use printWidth as if it was ESLint‚Äôs max-len ‚Äì they‚Äôre not the same. max-len just says what the maximum allowed line length is, but not what the generally preferred length is ‚Äì which is what printWidth specifies.
DefaultCLI OverrideAPI Override80--print-width <int>printWidth: <int>
Setting max_line_length in an .editorconfig file will configure Prettier‚Äôs print width, unless overridden.
(If you don‚Äôt want line wrapping when formatting Markdown, you can set the Prose Wrap option to disable it.)
Tab Width‚Äã
Specify the number of spaces per indentation-level.
DefaultCLI OverrideAPI Override2--tab-width <int>tabWidth: <int>
Setting indent_size or tab_width in an .editorconfig file will configure Prettier‚Äôs tab width, unless overridden.
Tabs‚Äã
Indent lines with tabs instead of spaces.
DefaultCLI OverrideAPI Overridefalse--use-tabsuseTabs: <bool>
Setting indent_style in an .editorconfig file will configure Prettier‚Äôs tab usage, unless overridden.
(Tabs will be used for indentation but Prettier uses spaces to align things, such as in ternaries. This behavior is known as SmartTabs.)
Semicolons‚Äã
Print semicolons at the ends of statements.
Valid options:

true - Add a semicolon at the end of every statement.
false - Only add semicolons at the beginning of lines that may introduce ASI failures.

DefaultCLI OverrideAPI Overridetrue--no-semisemi: <bool>
Quotes‚Äã
Use single quotes instead of double quotes.
Notes:

JSX quotes ignore this option ‚Äì see jsx-single-quote.
If the number of quotes outweighs the other quote, the quote which is less used will be used to format the string - Example: "I'm double quoted" results in "I'm double quoted" and "This \"example\" is single quoted" results in 'This "example" is single quoted'.

See the strings rationale for more information.
DefaultCLI OverrideAPI Overridefalse--single-quotesingleQuote: <bool>
Quote Props‚Äã
Change when properties in objects are quoted.
Valid options:

"as-needed" - Only add quotes around object properties where required.
"consistent" - If at least one property in an object requires quotes, quote all properties.
"preserve" - Respect the input use of quotes in object properties.

DefaultCLI OverrideAPI Override"as-needed"--quote-props <as-needed|consistent|preserve>quoteProps: "<as-needed|consistent|preserve>"
Note that Prettier never unquotes numeric property names in Angular expressions, TypeScript, and Flow because the distinction between string and numeric keys is significant in these languages. See: Angular, TypeScript, Flow. Also Prettier doesn‚Äôt unquote numeric properties for Vue (see the issue about that).
JSX Quotes‚Äã
Use single quotes instead of double quotes in JSX.
DefaultCLI OverrideAPI Overridefalse--jsx-single-quotejsxSingleQuote: <bool>
Trailing Commas‚Äã
Default value changed from es5 to all in v3.0.0
Print trailing commas wherever possible in multi-line comma-separated syntactic structures. (A single-line array, for example, never gets trailing commas.)
Valid options:

"all" - Trailing commas wherever possible (including function parameters and calls). To run, JavaScript code formatted this way needs an engine that supports ES2017 (Node.js 8+ or a modern browser) or downlevel compilation. This also enables trailing commas in type parameters in TypeScript (supported since TypeScript 2.7 released in January 2018).
"es5" - Trailing commas where valid in ES5 (objects, arrays, etc.). Trailing commas in type parameters in TypeScript and Flow.
"none" - No trailing commas.

DefaultCLI OverrideAPI Override"all"--trailing-comma <all|es5|none>trailingComma: "<all|es5|none>"
Bracket Spacing‚Äã
Print spaces between brackets in object literals.
Valid options:

true - Example: { foo: bar }.
false - Example: {foo: bar}.

DefaultCLI OverrideAPI Overridetrue--no-bracket-spacingbracketSpacing: <bool>
Object Wrap‚Äã
First available in v3.5.0
Configure how Prettier wraps object literals when they could fit on one line or span multiple lines.
By default, Prettier formats objects as multi-line if there is a newline prior to the first property. Authors can use this heuristic to contextually improve readability, though it has some downsides. See Multi-line objects.
Valid options:

"preserve" - Keep as multi-line, if there is a newline between the opening brace and first property.
"collapse" - Fit to a single line when possible.

DefaultCLI OverrideAPI Override"preserve"--object-wrap <preserve|collapse>objectWrap: "<preserve|collapse>"
Bracket Line‚Äã
Put the > of a multi-line HTML (HTML, JSX, Vue, Angular) element at the end of the last line instead of being alone on the next line (does not apply to self closing elements).
Valid options:

true - Example:

<button  className="prettier-class"  id="prettier-id"  onClick={this.handleClick}>  Click Here</button>

false - Example:

<button  className="prettier-class"  id="prettier-id"  onClick={this.handleClick}>  Click Here</button>
DefaultCLI OverrideAPI Overridefalse--bracket-same-linebracketSameLine: <bool>
[Deprecated] JSX Brackets‚Äã
dangerThis option has been deprecated in v2.4.0, use --bracket-same-line instead.
Put the > of a multi-line JSX element at the end of the last line instead of being alone on the next line (does not apply to self closing elements).
Valid options:

true - Example:

<button  className="prettier-class"  id="prettier-id"  onClick={this.handleClick}>  Click Here</button>

false - Example:

<button  className="prettier-class"  id="prettier-id"  onClick={this.handleClick}>  Click Here</button>
DefaultCLI OverrideAPI Overridefalse--jsx-bracket-same-linejsxBracketSameLine: <bool>
Arrow Function Parentheses‚Äã
First available in v1.9.0, default value changed from avoid to always in v2.0.0
Include parentheses around a sole arrow function parameter.
Valid options:

"always" - Always include parens. Example: (x) => x
"avoid" - Omit parens when possible. Example: x => x

DefaultCLI OverrideAPI Override"always"--arrow-parens <always|avoid>arrowParens: "<always|avoid>"
At first glance, avoiding parentheses may look like a better choice because of less visual noise.
However, when Prettier removes parentheses, it becomes harder to add type annotations, extra arguments or default values as well as making other changes.
Consistent use of parentheses provides a better developer experience when editing real codebases, which justifies the default value for the option.
Range‚Äã
Format only a segment of a file.
These two options can be used to format code starting and ending at a given character offset (inclusive and exclusive, respectively). The range will extend:

Backwards to the start of the first line containing the selected statement.
Forwards to the end of the selected statement.

DefaultCLI OverrideAPI Override0--range-start <int>rangeStart: <int>Infinity--range-end <int>rangeEnd: <int>
Parser‚Äã
Specify which parser to use.
Prettier automatically infers the parser from the input file path, so you shouldn‚Äôt have to change this setting.
Both the babel and flow parsers support the same set of JavaScript features (including Flow type annotations). They might differ in some edge cases, so if you run into one of those you can try flow instead of babel. Almost the same applies to typescript and babel-ts. babel-ts might support JavaScript features (proposals) not yet supported by TypeScript, but it‚Äôs less permissive when it comes to invalid code and less battle-tested than the typescript parser.
Valid options:

"babel" (via @babel/parser) Named "babylon" until v1.16.0
"babel-flow" (same as "babel" but enables Flow parsing explicitly to avoid ambiguity) First available in v1.16.0
"babel-ts" (similar to "typescript" but uses Babel and its TypeScript plugin) First available in v2.0.0
"flow" (via flow-parser)
"typescript" (via @typescript-eslint/typescript-estree) First available in v1.4.0
"espree" (via espree) First available in v2.2.0
"meriyah" (via meriyah) First available in v2.2.0
"acorn" (via acorn) First available in v2.6.0
"css" (via postcss) First available in v1.7.1
"scss" (via postcss-scss) First available in v1.7.1
"less" (via postcss-less) First available in v1.7.1
"json" (via @babel/parser parseExpression) First available in v1.5.0
"json5" (same parser as "json", but outputs as json5) First available in v1.13.0
"jsonc" (same parser as "json", but outputs as "JSON with Comments") First available in v3.2.0
"json-stringify" (same parser as "json", but outputs like JSON.stringify) First available in v1.13.0
"graphql" (via graphql/language) First available in v1.5.0
"markdown" (via remark-parse) First available in v1.8.0
"mdx" (via remark-parse and @mdx-js/mdx) First available in v1.15.0
"html" (via angular-html-parser) First available in 1.15.0
"vue" (same parser as "html", but also formats vue-specific syntax) First available in 1.10.0
"angular" (same parser as "html", but also formats angular-specific syntax via angular-estree-parser) First available in 1.15.0
"lwc" (same parser as "html", but also formats LWC-specific syntax for unquoted template attributes) First available in 1.17.0
"mjml" (same parser as "html", but also formats MJML-specific syntax) First available in 3.6.0
"yaml" (via yaml and yaml-unist-parser) First available in 1.14.0

DefaultCLI OverrideAPI OverrideNone--parser <string>parser: "<string>"
Note: the default value was "babylon" until v1.13.0.
Note: the Custom parser API has been removed in v3.0.0. Use plugins instead (how to migrate).

File Path‚Äã
Specify the file name to use to infer which parser to use.
For example, the following will use the CSS parser:
cat foo | prettier --stdin-filepath foo.css
This option is only useful in the CLI and API. It doesn‚Äôt make sense to use it in a configuration file.
DefaultCLI OverrideAPI OverrideNone--stdin-filepath <string>filepath: "<string>"
Require Pragma‚Äã
First available in v1.7.0
Prettier can restrict itself to only format files that contain a special comment, called a pragma, at the top of the file. This is very useful when gradually transitioning large, unformatted codebases to Prettier.
A file with the following as its first comment will be formatted when --require-pragma is supplied:
/** * @prettier */
or
/** * @format */
DefaultCLI OverrideAPI Overridefalse--require-pragmarequirePragma: <bool>
Insert Pragma‚Äã
First available in v1.8.0
Prettier can insert a special @format marker at the top of files specifying that the file has been formatted with Prettier. This works well when used in tandem with the --require-pragma option. If there is already a docblock at the top of the file then this option will add a newline to it with the @format marker.
Note that ‚Äúin tandem‚Äù doesn‚Äôt mean ‚Äúat the same time‚Äù. When the two options are used simultaneously, --require-pragma has priority, so --insert-pragma is ignored. The idea is that during an incremental adoption of Prettier in a big codebase, the developers participating in the transition process use --insert-pragma whereas --require-pragma is used by the rest of the team and automated tooling to process only files already transitioned. The feature has been inspired by Facebook‚Äôs adoption strategy.
DefaultCLI OverrideAPI Overridefalse--insert-pragmainsertPragma: <bool>
Check Ignore Pragma‚Äã
First available in v3.6.0
Prettier can allow individual files to opt out of formatting if they contain a special comment, called a pragma, at the top of the file.
Checking for these markers incurs a small upfront cost during formatting, so it's not enabled by default.
A file with the following as its first comment will not be formatted when --check-ignore-pragma is supplied:
/** * @noprettier */
or
/** * @noformat */
DefaultCLI OverrideAPI Overridefalse--check-ignore-pragmacheckIgnorePragma: <bool>
Prose Wrap‚Äã
First available in v1.8.2
By default, Prettier will not change wrapping in markdown text since some services use a linebreak-sensitive renderer, e.g. GitHub comments and BitBucket. To have Prettier wrap prose to the print width, change this option to "always". If you want Prettier to force all prose blocks to be on a single line and rely on editor/viewer soft wrapping instead, you can use "never".
Valid options:

"always" - Wrap prose if it exceeds the print width.
"never" - Un-wrap each block of prose into one line.
"preserve" - Do nothing, leave prose as-is. First available in v1.9.0

DefaultCLI OverrideAPI Override"preserve"--prose-wrap <always|never|preserve>proseWrap: "<always|never|preserve>"
HTML Whitespace Sensitivity‚Äã
First available in v1.15.0. First available for Handlebars in 2.3.0
Specify the global whitespace sensitivity for HTML, Vue, Angular, and Handlebars. See whitespace-sensitive formatting for more info.
Valid options:

"css" - Respect the default value of CSS display property. For Handlebars treated same as strict.
"strict" - Whitespace (or the lack of it) around all tags is considered significant.
"ignore" - Whitespace (or the lack of it) around all tags is considered insignificant.

DefaultCLI OverrideAPI Override"css"--html-whitespace-sensitivity <css|strict|ignore>htmlWhitespaceSensitivity: "<css|strict|ignore>"
Vue files script and style tags indentation‚Äã
First available in v1.19.0
Whether or not to indent the code inside <script> and <style> tags in Vue files.
Valid options:

false - Do not indent script and style tags in Vue files.
true - Indent script and style tags in Vue files.

DefaultCLI OverrideAPI Overridefalse--vue-indent-script-and-stylevueIndentScriptAndStyle: <bool>
End of Line‚Äã
First available in v1.15.0, default value changed from auto to lf in v2.0.0
For historical reasons, there exist two common flavors of line endings in text files.
That is \n (or LF for Line Feed) and \r\n (or CRLF for Carriage Return + Line Feed).
The former is common on Linux and macOS, while the latter is prevalent on Windows.
Some details explaining why it is so can be found on Wikipedia.
When people collaborate on a project from different operating systems, it becomes easy to end up with mixed line endings in a shared git repository.
It is also possible for Windows users to accidentally change line endings in a previously committed file from LF to CRLF.
Doing so produces a large git diff and thus makes the line-by-line history for a file (git blame) harder to explore.
If you want to make sure that your entire git repository only contains Linux-style line endings in files covered by Prettier:

Ensure Prettier‚Äôs endOfLine option is set to lf (this is a default value since v2.0.0)
Configure a pre-commit hook that will run Prettier
Configure Prettier to run in your CI pipeline using --check flag. If you use Travis CI, set the autocrlf option to input in .travis.yml.
Add * text=auto eol=lf to the repo‚Äôs .gitattributes file.
You may need to ask Windows users to re-clone your repo after this change to ensure git has not converted LF to CRLF on checkout.

All modern text editors in all operating systems are able to correctly display line endings when \n (LF) is used.
However, old versions of Notepad for Windows will visually squash such lines into one as they can only deal with \r\n (CRLF).
Valid options:

"lf" ‚Äì Line Feed only (\n), common on Linux and macOS as well as inside git repos
"crlf" - Carriage Return + Line Feed characters (\r\n), common on Windows
"cr" - Carriage Return character only (\r), used very rarely
"auto" - Maintain existing line endings
(mixed values within one file are normalised by looking at what‚Äôs used after the first line)

DefaultCLI OverrideAPI Override"lf"--end-of-line <lf|crlf|cr|auto>endOfLine: "<lf|crlf|cr|auto>"
Setting end_of_line in an .editorconfig file will configure Prettier‚Äôs end of line usage, unless overridden.
Embedded Language Formatting‚Äã
First available in v2.1.0
Control whether Prettier formats quoted code embedded in the file.
When Prettier identifies cases where it looks like you've placed some code it knows how to format within a string in another file, like in a tagged template in JavaScript with a tag named html or in code blocks in Markdown, it will by default try to format that code.
Sometimes this behavior is undesirable, particularly in cases where you might not have intended the string to be interpreted as code. This option allows you to switch between the default behavior (auto) and disabling this feature entirely (off).
Valid options:

"auto" ‚Äì Format embedded code if Prettier can automatically identify it.
"off" - Never automatically format embedded code.

DefaultCLI OverrideAPI Override"auto"--embedded-language-formatting=<off|auto>embeddedLanguageFormatting: "<off|auto>"
Single Attribute Per Line‚Äã
First available in v2.6.0
Enforce single attribute per line in HTML, Vue, and JSX.
Valid options:

false - Do not enforce single attribute per line.
true - Enforce single attribute per line.

DefaultCLI OverrideAPI Overridefalse--single-attribute-per-linesingleAttributePerLine: <bool>Edit this page\n\nThis is unreleased documentation for Prettier next version.For up-to-date documentation, see the latest version (stable).On this pageOptionsPrettier ships with a handful of format options.
To learn more about Prettier‚Äôs stance on options ‚Äì see the Option Philosophy.
If you change any options, it‚Äôs recommended to do it via a configuration file. This way the Prettier CLI, editor integrations and other tooling knows what options you use.
Experimental Ternaries‚Äã
Try prettier's new ternary formatting before it becomes the default behavior.
Valid options:

true - Use curious ternaries, with the question mark after the condition.
false - Retain the default behavior of ternaries; keep question marks on the same line as the consequent.

DefaultCLI OverrideAPI Overridefalse--experimental-ternariesexperimentalTernaries: <bool>
Experimental Operator Position‚Äã
Valid options:

"start" - When binary expressions wrap lines, print operators at the start of new lines.
"end" - Default behavior; when binary expressions wrap lines, print operators at the end of previous lines.

DefaultCLI OverrideAPI Override"end"--experimental-operator-position <start|end>experimentalOperatorPosition: "<start|end>"
Print Width‚Äã
Specify the line length that the printer will wrap on.
warningFor readability we recommend against using more than 80 characters:In code styleguides, maximum line length rules are often set to 100 or 120. However, when humans write code, they don‚Äôt strive to reach the maximum number of columns on every line. Developers often use whitespace to break up long lines for readability. In practice, the average line length often ends up well below the maximum.Prettier‚Äôs printWidth option does not work the same way. It is not the hard upper allowed line length limit. It is a way to say to Prettier roughly how long you‚Äôd like lines to be. Prettier will make both shorter and longer lines, but generally strive to meet the specified printWidth.Remember, computers are dumb. You need to explicitly tell them what to do, while humans can make their own (implicit) judgements, for example on when to break a line.In other words, don‚Äôt try to use printWidth as if it was ESLint‚Äôs max-len ‚Äì they‚Äôre not the same. max-len just says what the maximum allowed line length is, but not what the generally preferred length is ‚Äì which is what printWidth specifies.
DefaultCLI OverrideAPI Override80--print-width <int>printWidth: <int>
Setting max_line_length in an .editorconfig file will configure Prettier‚Äôs print width, unless overridden.
(If you don‚Äôt want line wrapping when formatting Markdown, you can set the Prose Wrap option to disable it.)
Tab Width‚Äã
Specify the number of spaces per indentation-level.
DefaultCLI OverrideAPI Override2--tab-width <int>tabWidth: <int>
Setting indent_size or tab_width in an .editorconfig file will configure Prettier‚Äôs tab width, unless overridden.
Tabs‚Äã
Indent lines with tabs instead of spaces.
DefaultCLI OverrideAPI Overridefalse--use-tabsuseTabs: <bool>
Setting indent_style in an .editorconfig file will configure Prettier‚Äôs tab usage, unless overridden.
(Tabs will be used for indentation but Prettier uses spaces to align things, such as in ternaries. This behavior is known as SmartTabs.)
Semicolons‚Äã
Print semicolons at the ends of statements.
Valid options:

true - Add a semicolon at the end of every statement.
false - Only add semicolons at the beginning of lines that may introduce ASI failures.

DefaultCLI OverrideAPI Overridetrue--no-semisemi: <bool>
Quotes‚Äã
Use single quotes instead of double quotes.
Notes:

JSX quotes ignore this option ‚Äì see jsx-single-quote.
If the number of quotes outweighs the other quote, the quote which is less used will be used to format the string - Example: "I'm double quoted" results in "I'm double quoted" and "This \"example\" is single quoted" results in 'This "example" is single quoted'.

See the strings rationale for more information.
DefaultCLI OverrideAPI Overridefalse--single-quotesingleQuote: <bool>
Quote Props‚Äã
Change when properties in objects are quoted.
Valid options:

"as-needed" - Only add quotes around object properties where required.
"consistent" - If at least one property in an object requires quotes, quote all properties.
"preserve" - Respect the input use of quotes in object properties.

DefaultCLI OverrideAPI Override"as-needed"--quote-props <as-needed|consistent|preserve>quoteProps: "<as-needed|consistent|preserve>"
Note that Prettier never unquotes numeric property names in Angular expressions, TypeScript, and Flow because the distinction between string and numeric keys is significant in these languages. See: Angular, TypeScript, Flow. Also Prettier doesn‚Äôt unquote numeric properties for Vue (see the issue about that).
JSX Quotes‚Äã
Use single quotes instead of double quotes in JSX.
DefaultCLI OverrideAPI Overridefalse--jsx-single-quotejsxSingleQuote: <bool>
Trailing Commas‚Äã
Default value changed from es5 to all in v3.0.0
Print trailing commas wherever possible in multi-line comma-separated syntactic structures. (A single-line array, for example, never gets trailing commas.)
Valid options:

"all" - Trailing commas wherever possible (including function parameters and calls). To run, JavaScript code formatted this way needs an engine that supports ES2017 (Node.js 8+ or a modern browser) or downlevel compilation. This also enables trailing commas in type parameters in TypeScript (supported since TypeScript 2.7 released in January 2018).
"es5" - Trailing commas where valid in ES5 (objects, arrays, etc.). Trailing commas in type parameters in TypeScript and Flow.
"none" - No trailing commas.

DefaultCLI OverrideAPI Override"all"--trailing-comma <all|es5|none>trailingComma: "<all|es5|none>"
Bracket Spacing‚Äã
Print spaces between brackets in object literals.
Valid options:

true - Example: { foo: bar }.
false - Example: {foo: bar}.

DefaultCLI OverrideAPI Overridetrue--no-bracket-spacingbracketSpacing: <bool>
Object Wrap‚Äã
First available in v3.5.0
Configure how Prettier wraps object literals when they could fit on one line or span multiple lines.
By default, Prettier formats objects as multi-line if there is a newline prior to the first property. Authors can use this heuristic to contextually improve readability, though it has some downsides. See Multi-line objects.
Valid options:

"preserve" - Keep as multi-line, if there is a newline between the opening brace and first property.
"collapse" - Fit to a single line when possible.

DefaultCLI OverrideAPI Override"preserve"--object-wrap <preserve|collapse>objectWrap: "<preserve|collapse>"
Bracket Line‚Äã
Put the > of a multi-line HTML (HTML, JSX, Vue, Angular) element at the end of the last line instead of being alone on the next line (does not apply to self closing elements).
Valid options:

true - Example:

<button  className="prettier-class"  id="prettier-id"  onClick={this.handleClick}>  Click Here</button>

false - Example:

<button  className="prettier-class"  id="prettier-id"  onClick={this.handleClick}>  Click Here</button>
DefaultCLI OverrideAPI Overridefalse--bracket-same-linebracketSameLine: <bool>
[Deprecated] JSX Brackets‚Äã
dangerThis option has been deprecated in v2.4.0, use --bracket-same-line instead.
Put the > of a multi-line JSX element at the end of the last line instead of being alone on the next line (does not apply to self closing elements).
Valid options:

true - Example:

<button  className="prettier-class"  id="prettier-id"  onClick={this.handleClick}>  Click Here</button>

false - Example:

<button  className="prettier-class"  id="prettier-id"  onClick={this.handleClick}>  Click Here</button>
DefaultCLI OverrideAPI Overridefalse--jsx-bracket-same-linejsxBracketSameLine: <bool>
Arrow Function Parentheses‚Äã
First available in v1.9.0, default value changed from avoid to always in v2.0.0
Include parentheses around a sole arrow function parameter.
Valid options:

"always" - Always include parens. Example: (x) => x
"avoid" - Omit parens when possible. Example: x => x

DefaultCLI OverrideAPI Override"always"--arrow-parens <always|avoid>arrowParens: "<always|avoid>"
At first glance, avoiding parentheses may look like a better choice because of less visual noise.
However, when Prettier removes parentheses, it becomes harder to add type annotations, extra arguments or default values as well as making other changes.
Consistent use of parentheses provides a better developer experience when editing real codebases, which justifies the default value for the option.
Range‚Äã
Format only a segment of a file.
These two options can be used to format code starting and ending at a given character offset (inclusive and exclusive, respectively). The range will extend:

Backwards to the start of the first line containing the selected statement.
Forwards to the end of the selected statement.

DefaultCLI OverrideAPI Override0--range-start <int>rangeStart: <int>Infinity--range-end <int>rangeEnd: <int>
Parser‚Äã
Specify which parser to use.
Prettier automatically infers the parser from the input file path, so you shouldn‚Äôt have to change this setting.
Both the babel and flow parsers support the same set of JavaScript features (including Flow type annotations). They might differ in some edge cases, so if you run into one of those you can try flow instead of babel. Almost the same applies to typescript and babel-ts. babel-ts might support JavaScript features (proposals) not yet supported by TypeScript, but it‚Äôs less permissive when it comes to invalid code and less battle-tested than the typescript parser.
Valid options:

"babel" (via @babel/parser) Named "babylon" until v1.16.0
"babel-flow" (same as "babel" but enables Flow parsing explicitly to avoid ambiguity) First available in v1.16.0
"babel-ts" (similar to "typescript" but uses Babel and its TypeScript plugin) First available in v2.0.0
"flow" (via flow-parser)
"typescript" (via @typescript-eslint/typescript-estree) First available in v1.4.0
"espree" (via espree) First available in v2.2.0
"meriyah" (via meriyah) First available in v2.2.0
"acorn" (via acorn) First available in v2.6.0
"css" (via postcss) First available in v1.7.1
"scss" (via postcss-scss) First available in v1.7.1
"less" (via postcss-less) First available in v1.7.1
"json" (via @babel/parser parseExpression) First available in v1.5.0
"json5" (same parser as "json", but outputs as json5) First available in v1.13.0
"jsonc" (same parser as "json", but outputs as "JSON with Comments") First available in v3.2.0
"json-stringify" (same parser as "json", but outputs like JSON.stringify) First available in v1.13.0
"graphql" (via graphql/language) First available in v1.5.0
"markdown" (via remark-parse) First available in v1.8.0
"mdx" (via remark-parse and @mdx-js/mdx) First available in v1.15.0
"html" (via angular-html-parser) First available in 1.15.0
"vue" (same parser as "html", but also formats vue-specific syntax) First available in 1.10.0
"angular" (same parser as "html", but also formats angular-specific syntax via angular-estree-parser) First available in 1.15.0
"lwc" (same parser as "html", but also formats LWC-specific syntax for unquoted template attributes) First available in 1.17.0
"mjml" (same parser as "html", but also formats MJML-specific syntax) First available in 3.6.0
"yaml" (via yaml and yaml-unist-parser) First available in 1.14.0

DefaultCLI OverrideAPI OverrideNone--parser <string>parser: "<string>"
Note: the default value was "babylon" until v1.13.0.
Note: the Custom parser API has been removed in v3.0.0. Use plugins instead (how to migrate).

File Path‚Äã
Specify the file name to use to infer which parser to use.
For example, the following will use the CSS parser:
cat foo | prettier --stdin-filepath foo.css
This option is only useful in the CLI and API. It doesn‚Äôt make sense to use it in a configuration file.
DefaultCLI OverrideAPI OverrideNone--stdin-filepath <string>filepath: "<string>"
Require Pragma‚Äã
First available in v1.7.0
Prettier can restrict itself to only format files that contain a special comment, called a pragma, at the top of the file. This is very useful when gradually transitioning large, unformatted codebases to Prettier.
A file with the following as its first comment will be formatted when --require-pragma is supplied:
/** * @prettier */
or
/** * @format */
DefaultCLI OverrideAPI Overridefalse--require-pragmarequirePragma: <bool>
Insert Pragma‚Äã
First available in v1.8.0
Prettier can insert a special @format marker at the top of files specifying that the file has been formatted with Prettier. This works well when used in tandem with the --require-pragma option. If there is already a docblock at the top of the file then this option will add a newline to it with the @format marker.
Note that ‚Äúin tandem‚Äù doesn‚Äôt mean ‚Äúat the same time‚Äù. When the two options are used simultaneously, --require-pragma has priority, so --insert-pragma is ignored. The idea is that during an incremental adoption of Prettier in a big codebase, the developers participating in the transition process use --insert-pragma whereas --require-pragma is used by the rest of the team and automated tooling to process only files already transitioned. The feature has been inspired by Facebook‚Äôs adoption strategy.
DefaultCLI OverrideAPI Overridefalse--insert-pragmainsertPragma: <bool>
Check Ignore Pragma‚Äã
First available in v3.6.0
Prettier can allow individual files to opt out of formatting if they contain a special comment, called a pragma, at the top of the file.
Checking for these markers incurs a small upfront cost during formatting, so it's not enabled by default.
A file with the following as its first comment will not be formatted when --check-ignore-pragma is supplied:
/** * @noprettier */
or
/** * @noformat */
DefaultCLI OverrideAPI Overridefalse--check-ignore-pragmacheckIgnorePragma: <bool>
Prose Wrap‚Äã
First available in v1.8.2
By default, Prettier will not change wrapping in markdown text since some services use a linebreak-sensitive renderer, e.g. GitHub comments and BitBucket. To have Prettier wrap prose to the print width, change this option to "always". If you want Prettier to force all prose blocks to be on a single line and rely on editor/viewer soft wrapping instead, you can use "never".
Valid options:

"always" - Wrap prose if it exceeds the print width.
"never" - Un-wrap each block of prose into one line.
"preserve" - Do nothing, leave prose as-is. First available in v1.9.0

DefaultCLI OverrideAPI Override"preserve"--prose-wrap <always|never|preserve>proseWrap: "<always|never|preserve>"
HTML Whitespace Sensitivity‚Äã
First available in v1.15.0. First available for Handlebars in 2.3.0
Specify the global whitespace sensitivity for HTML, Vue, Angular, and Handlebars. See whitespace-sensitive formatting for more info.
Valid options:

"css" - Respect the default value of CSS display property. For Handlebars treated same as strict.
"strict" - Whitespace (or the lack of it) around all tags is considered significant.
"ignore" - Whitespace (or the lack of it) around all tags is considered insignificant.

DefaultCLI OverrideAPI Override"css"--html-whitespace-sensitivity <css|strict|ignore>htmlWhitespaceSensitivity: "<css|strict|ignore>"
Vue files script and style tags indentation‚Äã
First available in v1.19.0
Whether or not to indent the code inside <script> and <style> tags in Vue files.
Valid options:

false - Do not indent script and style tags in Vue files.
true - Indent script and style tags in Vue files.

DefaultCLI OverrideAPI Overridefalse--vue-indent-script-and-stylevueIndentScriptAndStyle: <bool>
End of Line‚Äã
First available in v1.15.0, default value changed from auto to lf in v2.0.0
For historical reasons, there exist two common flavors of line endings in text files.
That is \n (or LF for Line Feed) and \r\n (or CRLF for Carriage Return + Line Feed).
The former is common on Linux and macOS, while the latter is prevalent on Windows.
Some details explaining why it is so can be found on Wikipedia.
When people collaborate on a project from different operating systems, it becomes easy to end up with mixed line endings in a shared git repository.
It is also possible for Windows users to accidentally change line endings in a previously committed file from LF to CRLF.
Doing so produces a large git diff and thus makes the line-by-line history for a file (git blame) harder to explore.
If you want to make sure that your entire git repository only contains Linux-style line endings in files covered by Prettier:

Ensure Prettier‚Äôs endOfLine option is set to lf (this is a default value since v2.0.0)
Configure a pre-commit hook that will run Prettier
Configure Prettier to run in your CI pipeline using --check flag. If you use Travis CI, set the autocrlf option to input in .travis.yml.
Add * text=auto eol=lf to the repo‚Äôs .gitattributes file.
You may need to ask Windows users to re-clone your repo after this change to ensure git has not converted LF to CRLF on checkout.

All modern text editors in all operating systems are able to correctly display line endings when \n (LF) is used.
However, old versions of Notepad for Windows will visually squash such lines into one as they can only deal with \r\n (CRLF).
Valid options:

"lf" ‚Äì Line Feed only (\n), common on Linux and macOS as well as inside git repos
"crlf" - Carriage Return + Line Feed characters (\r\n), common on Windows
"cr" - Carriage Return character only (\r), used very rarely
"auto" - Maintain existing line endings
(mixed values within one file are normalised by looking at what‚Äôs used after the first line)

DefaultCLI OverrideAPI Override"lf"--end-of-line <lf|crlf|cr|auto>endOfLine: "<lf|crlf|cr|auto>"
Setting end_of_line in an .editorconfig file will configure Prettier‚Äôs end of line usage, unless overridden.
Embedded Language Formatting‚Äã
First available in v2.1.0
Control whether Prettier formats quoted code embedded in the file.
When Prettier identifies cases where it looks like you've placed some code it knows how to format within a string in another file, like in a tagged template in JavaScript with a tag named html or in code blocks in Markdown, it will by default try to format that code.
Sometimes this behavior is undesirable, particularly in cases where you might not have intended the string to be interpreted as code. This option allows you to switch between the default behavior (auto) and disabling this feature entirely (off).
Valid options:

"auto" ‚Äì Format embedded code if Prettier can automatically identify it.
"off" - Never automatically format embedded code.

DefaultCLI OverrideAPI Override"auto"--embedded-language-formatting=<off|auto>embeddedLanguageFormatting: "<off|auto>"
Single Attribute Per Line‚Äã
First available in v2.6.0
Enforce single attribute per line in HTML, Vue, and JSX.
Valid options:

false - Do not enforce single attribute per line.
true - Enforce single attribute per line.

DefaultCLI OverrideAPI Overridefalse--single-attribute-per-linesingleAttributePerLine: <bool>Edit this pagePreviousRun Prettier on CINextConfiguration FileExperimental TernariesExperimental Operator PositionPrint WidthTab WidthTabsSemicolonsQuotesQuote PropsJSX QuotesTrailing CommasBracket SpacingObject WrapBracket Line[Deprecated] JSX BracketsArrow Function ParenthesesRangeParserFile PathRequire PragmaInsert PragmaCheck Ignore PragmaProse WrapHTML Whitespace SensitivityVue files script and style tags indentationEnd of LineEmbedded Language FormattingSingle Attribute Per Line\n\n\n\nOn this pageConfiguration FileYou can configure Prettier via (in order of precedence):

A "prettier" key in your package.json, or package.yaml file.
A .prettierrc file written in JSON or YAML.
A .prettierrc.json, .prettierrc.yml, .prettierrc.yaml, or .prettierrc.json5 file.
A .prettierrc.js, prettier.config.js, .prettierrc.ts, or prettier.config.ts file that exports an object using export default or module.exports (depends on the type value in your package.json).
A .prettierrc.mjs, prettier.config.mjs, .prettierrc.mts, or prettier.config.mts file that exports an object using export default.
A .prettierrc.cjs, prettier.config.cjs, .prettierrc.cts, or prettier.config.cts file that exports an object using module.exports.
A .prettierrc.toml file.

infoTypeScript configuration files support requires additional setup
The configuration file will be resolved starting from the location of the file being formatted, and searching up the file tree until a config file is (or isn‚Äôt) found.
Prettier intentionally doesn‚Äôt support any kind of global configuration. This is to make sure that when a project is copied to another computer, Prettier‚Äôs behavior stays the same. Otherwise, Prettier wouldn‚Äôt be able to guarantee that everybody in a team gets the same consistent results.
The options you can use in the configuration file are the same as the API options.
TypeScript Configuration Files‚Äã
TypeScript support for Node.js is currently experimental, Node.js>=22.6.0 is required and --experimental-strip-types is required to run Node.js.
node --experimental-strip-types node_modules/prettier/bin/prettier.cjs . --write
or
NODE_OPTIONS="--experimental-strip-types" prettier . --write
Basic Configuration‚Äã
JSON:
{  "trailingComma": "es5",  "tabWidth": 4,  "semi": false,  "singleQuote": true}
JS (ES Modules):
// prettier.config.js, .prettierrc.js, prettier.config.mjs, or .prettierrc.mjs/** * @see https://prettier.io/docs/configuration * @type {import("prettier").Config} */const config = {  trailingComma: "es5",  tabWidth: 4,  semi: false,  singleQuote: true,};export default config;
JS (CommonJS):
// prettier.config.js, .prettierrc.js, prettier.config.cjs, or .prettierrc.cjs/** * @see https://prettier.io/docs/configuration * @type {import("prettier").Config} */const config = {  trailingComma: "es5",  tabWidth: 4,  semi: false,  singleQuote: true,};module.exports = config;
TypeScript (ES Modules):
// prettier.config.ts, .prettierrc.ts, prettier.config.mts, or .prettierrc.mtsimport { type Config } from "prettier";const config: Config = {  trailingComma: "none",};export default config;
TypeScript (CommonJS):
// prettier.config.ts, .prettierrc.ts, prettier.config.cts, or .prettierrc.ctsimport { type Config } from "prettier";const config: Config = {  trailingComma: "none",};module.exports = config;
YAML:
# .prettierrc or .prettierrc.yamltrailingComma: "es5"tabWidth: 4semi: falsesingleQuote: true
TOML:
# .prettierrc.tomltrailingComma = "es5"tabWidth = 4semi = falsesingleQuote = true
Configuration Overrides‚Äã
Overrides let you have different configuration for certain file extensions, folders and specific files.
Prettier borrows ESLint‚Äôs override format.
JSON:
{  "semi": false,  "overrides": [    {      "files": "*.test.js",      "options": {        "semi": true      }    },    {      "files": ["*.html", "legacy/**/*.js"],      "options": {        "tabWidth": 4      }    }  ]}
YAML:
semi: falseoverrides:  - files: "*.test.js"    options:      semi: true  - files:      - "*.html"      - "legacy/**/*.js"    options:      tabWidth: 4
files is required for each override, and may be a string or array of strings. excludeFiles may be optionally provided to exclude files for a given rule, and may also be a string or array of strings.
Setting the parser option‚Äã
By default, Prettier automatically infers which parser to use based on the input file extension. Combined with overrides you can teach Prettier how to parse files it does not recognize.
For example, to get Prettier to format its own .prettierrc file, you can do:
{  "overrides": [    {      "files": ".prettierrc",      "options": { "parser": "json" }    }  ]}
You can also switch to the flow parser instead of the default babel for .js files:
{  "overrides": [    {      "files": "*.js",      "options": {        "parser": "flow"      }    }  ]}
Note: Never put the parser option at the top level of your configuration. Only use it inside overrides. Otherwise you effectively disable Prettier‚Äôs automatic file extension based parser inference. This forces Prettier to use the parser you specified for all types of files ‚Äì even when it doesn‚Äôt make sense, such as trying to parse a CSS file as JavaScript.
Configuration Schema‚Äã
If you‚Äôd like a JSON schema to validate your configuration, one is available here: https://json.schemastore.org/prettierrc.
EditorConfig‚Äã
If a .editorconfig file is in your project, Prettier will parse it and convert its properties to the corresponding Prettier configuration. This configuration will be overridden by .prettierrc, etc.
Here‚Äôs an annotated description of how different properties map to Prettier‚Äôs behavior:
# Stop the editor from looking for .editorconfig files in the parent directories# root = true[*]# Non-configurable Prettier behaviorscharset = utf-8insert_final_newline = true# Caveat: Prettier won‚Äôt trim trailing whitespace inside template strings, but your editor might.# trim_trailing_whitespace = true# Configurable Prettier behaviors# (change these if your Prettier config differs)end_of_line = lfindent_style = spaceindent_size = 2max_line_length = 80
Here‚Äôs a copy+paste-ready .editorconfig file if you use the default options:
[*]charset = utf-8insert_final_newline = trueend_of_line = lfindent_style = spaceindent_size = 2max_line_length = 80Edit this page\n\nThis is unreleased documentation for Prettier next version.For up-to-date documentation, see the latest version (stable).On this pageConfiguration FileYou can configure Prettier via (in order of precedence):

A "prettier" key in your package.json, or package.yaml file.
A .prettierrc file written in JSON or YAML.
A .prettierrc.json, .prettierrc.yml, .prettierrc.yaml, or .prettierrc.json5 file.
A .prettierrc.js, prettier.config.js, .prettierrc.ts, or prettier.config.ts file that exports an object using export default or module.exports (depends on the type value in your package.json).
A .prettierrc.mjs, prettier.config.mjs, .prettierrc.mts, or prettier.config.mts file that exports an object using export default.
A .prettierrc.cjs, prettier.config.cjs, .prettierrc.cts, or prettier.config.cts file that exports an object using module.exports.
A .prettierrc.toml file.

infoTypeScript configuration files support requires additional setup
The configuration file will be resolved starting from the location of the file being formatted, and searching up the file tree until a config file is (or isn‚Äôt) found.
Prettier intentionally doesn‚Äôt support any kind of global configuration. This is to make sure that when a project is copied to another computer, Prettier‚Äôs behavior stays the same. Otherwise, Prettier wouldn‚Äôt be able to guarantee that everybody in a team gets the same consistent results.
The options you can use in the configuration file are the same as the API options.
TypeScript Configuration Files‚Äã
TypeScript support for Node.js is currently experimental, Node.js>=22.6.0 is required and --experimental-strip-types is required to run Node.js.
node --experimental-strip-types node_modules/prettier/bin/prettier.cjs . --write
or
NODE_OPTIONS="--experimental-strip-types" prettier . --write
Basic Configuration‚Äã
JSON:
{  "trailingComma": "es5",  "tabWidth": 4,  "semi": false,  "singleQuote": true}
JS (ES Modules):
// prettier.config.js, .prettierrc.js, prettier.config.mjs, or .prettierrc.mjs/** * @see https://prettier.io/docs/configuration * @type {import("prettier").Config} */const config = {  trailingComma: "es5",  tabWidth: 4,  semi: false,  singleQuote: true,};export default config;
JS (CommonJS):
// prettier.config.js, .prettierrc.js, prettier.config.cjs, or .prettierrc.cjs/** * @see https://prettier.io/docs/configuration * @type {import("prettier").Config} */const config = {  trailingComma: "es5",  tabWidth: 4,  semi: false,  singleQuote: true,};module.exports = config;
TypeScript (ES Modules):
// prettier.config.ts, .prettierrc.ts, prettier.config.mts, or .prettierrc.mtsimport { type Config } from "prettier";const config: Config = {  trailingComma: "none",};export default config;
TypeScript (CommonJS):
// prettier.config.ts, .prettierrc.ts, prettier.config.cts, or .prettierrc.ctsimport { type Config } from "prettier";const config: Config = {  trailingComma: "none",};module.exports = config;
YAML:
# .prettierrc or .prettierrc.yamltrailingComma: "es5"tabWidth: 4semi: falsesingleQuote: true
TOML:
# .prettierrc.tomltrailingComma = "es5"tabWidth = 4semi = falsesingleQuote = true
Configuration Overrides‚Äã
Overrides let you have different configuration for certain file extensions, folders and specific files.
Prettier borrows ESLint‚Äôs override format.
JSON:
{  "semi": false,  "overrides": [    {      "files": "*.test.js",      "options": {        "semi": true      }    },    {      "files": ["*.html", "legacy/**/*.js"],      "options": {        "tabWidth": 4      }    }  ]}
YAML:
semi: falseoverrides:  - files: "*.test.js"    options:      semi: true  - files:      - "*.html"      - "legacy/**/*.js"    options:      tabWidth: 4
files is required for each override, and may be a string or array of strings. excludeFiles may be optionally provided to exclude files for a given rule, and may also be a string or array of strings.
Setting the parser option‚Äã
By default, Prettier automatically infers which parser to use based on the input file extension. Combined with overrides you can teach Prettier how to parse files it does not recognize.
For example, to get Prettier to format its own .prettierrc file, you can do:
{  "overrides": [    {      "files": ".prettierrc",      "options": { "parser": "json" }    }  ]}
You can also switch to the flow parser instead of the default babel for .js files:
{  "overrides": [    {      "files": "*.js",      "options": {        "parser": "flow"      }    }  ]}
Note: Never put the parser option at the top level of your configuration. Only use it inside overrides. Otherwise you effectively disable Prettier‚Äôs automatic file extension based parser inference. This forces Prettier to use the parser you specified for all types of files ‚Äì even when it doesn‚Äôt make sense, such as trying to parse a CSS file as JavaScript.
Configuration Schema‚Äã
If you‚Äôd like a JSON schema to validate your configuration, one is available here: https://json.schemastore.org/prettierrc.
EditorConfig‚Äã
If a .editorconfig file is in your project, Prettier will parse it and convert its properties to the corresponding Prettier configuration. This configuration will be overridden by .prettierrc, etc.
Here‚Äôs an annotated description of how different properties map to Prettier‚Äôs behavior:
# Stop the editor from looking for .editorconfig files in the parent directories# root = true[*]# Non-configurable Prettier behaviorscharset = utf-8insert_final_newline = true# Caveat: Prettier won‚Äôt trim trailing whitespace inside template strings, but your editor might.# trim_trailing_whitespace = true# Configurable Prettier behaviors# (change these if your Prettier config differs)end_of_line = lfindent_style = spaceindent_size = 2max_line_length = 80
Here‚Äôs a copy+paste-ready .editorconfig file if you use the default options:
[*]charset = utf-8insert_final_newline = trueend_of_line = lfindent_style = spaceindent_size = 2max_line_length = 80Edit this pagePreviousOptionsNextSharing configurationsTypeScript Configuration FilesBasic ConfigurationConfiguration OverridesSetting the parser optionConfiguration SchemaEditorConfig\n\n\n\nOn this pageSharing configurationsIn case you have many different projects, it can be helpful to have a shared configuration which can be used in all of them, instead of copy-pasting the same config for every project.
This page explains how to create, publish and consume a shareable config.
Creating a Shareable Config‚Äã
Sharable configs are just npm packages that export a single prettier config file.
Before we start, make sure you have:

An account for npmjs.com to publish the package
Basic understating about how to create a Node.js module

First, create a new package. We recommend creating a scoped package with the name @username/prettier-config.
A minimal package should have at least two files. A package.json for the package configuration and an index.js which holds the shared prettier configuration object:
prettier-config/‚îú‚îÄ‚îÄ index.js‚îî‚îÄ‚îÄ package.json
Example package.json:
{  "name": "@username/prettier-config",  "version": "1.0.0",  "description": "My personal Prettier config",  "type": "module",  "exports": "./index.js",  "license": "MIT",  "publishConfig": {    "access": "public"  },  "peerDependencies": {    "prettier": ">=3.0.0"  }}
index.js is where you put the shared configuration. This file just exports a regular prettier configuration with the same syntax and same options:
const config = {  trailingComma: "es5",  tabWidth: 4,  singleQuote: true,};export default config;
An example shared configuration repository is available here.
Publishing a Shareable Config‚Äã
Once you are ready, you can publish your package to npm:
npm publish
Using a Shareable Config‚Äã
You first need to install your published configuration, for example:
npmyarnpnpmbunnpm install --save-dev @username/prettier-configyarn add --dev @username/prettier-configpnpm add --save-dev @username/prettier-configbun add --dev @username/prettier-config
Then, you can reference it in your package.json:
{  "name": "my-cool-library",  "version": "1.0.0",  "prettier": "@username/prettier-config"}
If you don‚Äôt want to use package.json, you can use any of the supported extensions to export a string, e.g. .prettierrc:
"@company/prettier-config"
Extending a Sharable Config‚Äã
To extend the configuration to overwrite some properties from the shared configuration, import the file in a .prettierrc.mjs file and export the modifications, e.g:
import usernamePrettierConfig from "@username/prettier-config";/** * @type {import("prettier").Config} */const config = {  ...usernamePrettierConfig,  semi: false,};export default config;
Other examples‚Äã
Using Type Annotation in the Shared Config‚Äã
You can get type safety and autocomplete support in your shared configuration by using a jsdoc type annotation:
/** * @type {import("prettier").Config} */const config = {  trailingComma: "es5",  tabWidth: 4,  semi: false,  singleQuote: true,};export default config;
In order to make this work, you have to install prettier for the project.
After that, your package.json file should look like this:
{  "name": "@username/prettier-config",  "version": "1.0.0",  "description": "My personal Prettier config",  "type": "module",  "exports": "./index.js",  "license": "MIT",  "publishConfig": {    "access": "public"  },  "peerDependencies": {    "prettier": ">=3.0.0"  },+ "devDependencies": {+   "prettier": "^3.3.3"+ }}
Include Plugins in Shareable Configurations‚Äã
In case you want to use plugins in your shared configuration, you need to declare those plugins in the config file's plugin array and as dependencies in package.json:
// index.jsconst config = {  singleQuote: true,  plugins: ["prettier-plugin-xml"],};export default config;
// package.json{  "name": "@username/prettier-config",  "version": "1.0.0",  "description": "My personal Prettier config",  "type": "module",  "exports": "./index.js",  "license": "MIT",  "publishConfig": {    "access": "public"  },+  "dependencies": {+    "prettier-plugin-xml": "3.4.1"+  },  "peerDependencies": {    "prettier": ">=3.0.0"  }}
An example repository can be found here
Note: You can use peerDependencies instead of dependencies. To learn about their differences, you can read this blog post from Domenic Denicola about peer dependenciesEdit this page\n\nThis is unreleased documentation for Prettier next version.For up-to-date documentation, see the latest version (stable).On this pageSharing configurationsIn case you have many different projects, it can be helpful to have a shared configuration which can be used in all of them, instead of copy-pasting the same config for every project.
This page explains how to create, publish and consume a shareable config.
Creating a Shareable Config‚Äã
Sharable configs are just npm packages that export a single prettier config file.
Before we start, make sure you have:

An account for npmjs.com to publish the package
Basic understating about how to create a Node.js module

First, create a new package. We recommend creating a scoped package with the name @username/prettier-config.
A minimal package should have at least two files. A package.json for the package configuration and an index.js which holds the shared prettier configuration object:
prettier-config/‚îú‚îÄ‚îÄ index.js‚îî‚îÄ‚îÄ package.json
Example package.json:
{  "name": "@username/prettier-config",  "version": "1.0.0",  "description": "My personal Prettier config",  "type": "module",  "exports": "./index.js",  "license": "MIT",  "publishConfig": {    "access": "public"  },  "peerDependencies": {    "prettier": ">=3.0.0"  }}
index.js is where you put the shared configuration. This file just exports a regular prettier configuration with the same syntax and same options:
const config = {  trailingComma: "es5",  tabWidth: 4,  singleQuote: true,};export default config;
An example shared configuration repository is available here.
Publishing a Shareable Config‚Äã
Once you are ready, you can publish your package to npm:
npm publish
Using a Shareable Config‚Äã
You first need to install your published configuration, for example:
npmyarnpnpmbunnpm install --save-dev @username/prettier-configyarn add --dev @username/prettier-configpnpm add --save-dev @username/prettier-configbun add --dev @username/prettier-config
Then, you can reference it in your package.json:
{  "name": "my-cool-library",  "version": "1.0.0",  "prettier": "@username/prettier-config"}
If you don‚Äôt want to use package.json, you can use any of the supported extensions to export a string, e.g. .prettierrc:
"@company/prettier-config"
Extending a Sharable Config‚Äã
To extend the configuration to overwrite some properties from the shared configuration, import the file in a .prettierrc.mjs file and export the modifications, e.g:
import usernamePrettierConfig from "@username/prettier-config";/** * @type {import("prettier").Config} */const config = {  ...usernamePrettierConfig,  semi: false,};export default config;
Other examples‚Äã
Using Type Annotation in the Shared Config‚Äã
You can get type safety and autocomplete support in your shared configuration by using a jsdoc type annotation:
/** * @type {import("prettier").Config} */const config = {  trailingComma: "es5",  tabWidth: 4,  semi: false,  singleQuote: true,};export default config;
In order to make this work, you have to install prettier for the project.
After that, your package.json file should look like this:
{  "name": "@username/prettier-config",  "version": "1.0.0",  "description": "My personal Prettier config",  "type": "module",  "exports": "./index.js",  "license": "MIT",  "publishConfig": {    "access": "public"  },  "peerDependencies": {    "prettier": ">=3.0.0"  },+ "devDependencies": {+   "prettier": "^3.3.3"+ }}
Include Plugins in Shareable Configurations‚Äã
In case you want to use plugins in your shared configuration, you need to declare those plugins in the config file's plugin array and as dependencies in package.json:
// index.jsconst config = {  singleQuote: true,  plugins: ["prettier-plugin-xml"],};export default config;
// package.json{  "name": "@username/prettier-config",  "version": "1.0.0",  "description": "My personal Prettier config",  "type": "module",  "exports": "./index.js",  "license": "MIT",  "publishConfig": {    "access": "public"  },+  "dependencies": {+    "prettier-plugin-xml": "3.4.1"+  },  "peerDependencies": {    "prettier": ">=3.0.0"  }}
An example repository can be found here
Note: You can use peerDependencies instead of dependencies. To learn about their differences, you can read this blog post from Domenic Denicola about peer dependenciesEdit this pagePreviousConfiguration FileNextEditor IntegrationCreating a Shareable ConfigPublishing a Shareable ConfigUsing a Shareable ConfigExtending a Sharable ConfigOther examplesUsing Type Annotation in the Shared ConfigInclude Plugins in Shareable Configurations\n\n\n\nOn this pageEditor IntegrationTo get the most out of Prettier, it‚Äôs recommended to run it from your editor.
If your editor does not support Prettier, you can instead run Prettier with a file watcher.
Note! It‚Äôs important to install Prettier locally in every project, so each project gets the correct Prettier version.
Visual Studio Code‚Äã
prettier-vscode can be installed using the extension sidebar ‚Äì it‚Äôs called ‚ÄúPrettier - Code formatter.‚Äù Check its repository for configuration and shortcuts.
If you‚Äôd like to toggle the formatter on and off, install vscode-status-bar-format-toggle.
Emacs‚Äã
Check out the prettier-emacs repo, or prettier.el. The package Apheleia supports multiple code formatters, including Prettier.
Vim‚Äã
vim-prettier is a Prettier-specific Vim plugin. Neoformat, ALE, and coc-prettier are multi-language Vim linter/formatter plugins that support Prettier.
For more details see the Vim setup guide.
Helix‚Äã
A formatter can be specified in your Helix language configuration, which will take precedence over any language servers.
For more details see the Helix external binary formatter configuration for Prettier.
Sublime Text‚Äã
Sublime Text support is available through Package Control and the JsPrettier plug-in.
JetBrains WebStorm, PHPStorm, PyCharm...‚Äã
See the WebStorm setup guide.
Visual Studio‚Äã
Install the JavaScript Prettier extension.
Espresso‚Äã
Espresso users can install the espresso-prettier plugin.Edit this page\n\nThis is unreleased documentation for Prettier next version.For up-to-date documentation, see the latest version (stable).On this pageEditor IntegrationTo get the most out of Prettier, it‚Äôs recommended to run it from your editor.
If your editor does not support Prettier, you can instead run Prettier with a file watcher.
Note! It‚Äôs important to install Prettier locally in every project, so each project gets the correct Prettier version.
Visual Studio Code‚Äã
prettier-vscode can be installed using the extension sidebar ‚Äì it‚Äôs called ‚ÄúPrettier - Code formatter.‚Äù Check its repository for configuration and shortcuts.
If you‚Äôd like to toggle the formatter on and off, install vscode-status-bar-format-toggle.
Emacs‚Äã
Check out the prettier-emacs repo, or prettier.el. The package Apheleia supports multiple code formatters, including Prettier.
Vim‚Äã
vim-prettier is a Prettier-specific Vim plugin. Neoformat, ALE, and coc-prettier are multi-language Vim linter/formatter plugins that support Prettier.
For more details see the Vim setup guide.
Helix‚Äã
A formatter can be specified in your Helix language configuration, which will take precedence over any language servers.
For more details see the Helix external binary formatter configuration for Prettier.
Sublime Text‚Äã
Sublime Text support is available through Package Control and the JsPrettier plug-in.
JetBrains WebStorm, PHPStorm, PyCharm...‚Äã
See the WebStorm setup guide.
Visual Studio‚Äã
Install the JavaScript Prettier extension.
Espresso‚Äã
Espresso users can install the espresso-prettier plugin.Edit this pagePreviousSharing configurationsNextWebStorm SetupVisual Studio CodeEmacsVimHelixSublime TextJetBrains WebStorm, PHPStorm, PyCharm...Visual StudioEspresso\n\n\n\nOn this pageWebStorm SetupJetBrains IDEs (WebStorm, IntelliJ IDEA, PyCharm, etc.)‚Äã
WebStorm comes with built-in support for Prettier. If you‚Äôre using other JetBrains IDE like IntelliJ IDEA, PhpStorm, or PyCharm, make sure you have this plugin installed and enabled in Preferences / Settings | Plugins.
First, you need to install and configure Prettier. You can find instructions on how to do it here.
Once it‚Äôs done, you can do a few things in your IDE. You can use the Reformat with Prettier action (Opt+Shift+Cmd+P on macOS or Alt+Shift+Ctrl+P on Windows and Linux) to format the selected code, a file, or a whole directory.
You can also configure WebStorm to run Prettier on save (Cmd+S/Ctrl+S) or use it as the default formatter (Opt+Cmd+L/Ctrl+Alt+L). For this, open Preferences / Settings | Languages & Frameworks | JavaScript | Prettier and tick the corresponding checkbox: On save and/or On ‚ÄòReformat Code‚Äô action.

By default, WebStorm will apply formatting to all .js, .ts, .jsx, and .tsx files that you‚Äôve edited in your project. To apply the formatting to other file types, or to limit formatting to files located only in specific directories, you can customize the default configuration by using glob patterns.
For more information, see WebStorm online help.Edit this page\n\nThis is unreleased documentation for Prettier next version.For up-to-date documentation, see the latest version (stable).On this pageWebStorm SetupJetBrains IDEs (WebStorm, IntelliJ IDEA, PyCharm, etc.)‚Äã
WebStorm comes with built-in support for Prettier. If you‚Äôre using other JetBrains IDE like IntelliJ IDEA, PhpStorm, or PyCharm, make sure you have this plugin installed and enabled in Preferences / Settings | Plugins.
First, you need to install and configure Prettier. You can find instructions on how to do it here.
Once it‚Äôs done, you can do a few things in your IDE. You can use the Reformat with Prettier action (Opt+Shift+Cmd+P on macOS or Alt+Shift+Ctrl+P on Windows and Linux) to format the selected code, a file, or a whole directory.
You can also configure WebStorm to run Prettier on save (Cmd+S/Ctrl+S) or use it as the default formatter (Opt+Cmd+L/Ctrl+Alt+L). For this, open Preferences / Settings | Languages & Frameworks | JavaScript | Prettier and tick the corresponding checkbox: On save and/or On ‚ÄòReformat Code‚Äô action.

By default, WebStorm will apply formatting to all .js, .ts, .jsx, and .tsx files that you‚Äôve edited in your project. To apply the formatting to other file types, or to limit formatting to files located only in specific directories, you can customize the default configuration by using glob patterns.
For more information, see WebStorm online help.Edit this pagePreviousEditor IntegrationNextVim SetupJetBrains IDEs (WebStorm, IntelliJ IDEA, PyCharm, etc.)\n\n\n\nOn this pageVim SetupVim users can install either vim-prettier, which is Prettier specific, or Neoformat or ALE which are generalized lint/format engines with support for Prettier.
vim-prettier‚Äã
See the vim-prettier readme for installation and usage instructions.
Neoformat‚Äã
The best way to install Neoformat is with your favorite plugin manager for Vim, such as vim-plug:
Plug 'sbdchd/neoformat'
In order for Neoformat to use a project-local version of Prettier (i.e. to use node_modules/.bin/prettier instead of looking for prettier on $PATH), you must set the neoformat_try_node_exe option:
let g:neoformat_try_node_exe = 1
Run :Neoformat or :Neoformat prettier in a supported file to run Prettier.
To have Neoformat run Prettier on save:
autocmd BufWritePre *.js Neoformat
You can also make Vim format your code more frequently, by setting an autocmd for other events. Here are a couple of useful ones:

TextChanged: after a change was made to the text in Normal mode
InsertLeave: when leaving Insert mode

For example, you can format on both of the above events together with BufWritePre like this:
autocmd BufWritePre,TextChanged,InsertLeave *.js Neoformat
See :help autocmd-events in Vim for details.
It‚Äôs recommended to use a config file, but you can also add options in your .vimrc:
autocmd FileType javascript setlocal formatprg=prettier\ --single-quote\ --trailing-comma\ es5" Use formatprg when availablelet g:neoformat_try_formatprg = 1
Each space in Prettier options should be escaped with \.
ALE‚Äã
ALE requires either Vim 8 or Neovim as ALE makes use of the asynchronous abilities that both Vim 8 and Neovim provide.
The best way to install ALE is with your favorite plugin manager for Vim, such as vim-plug:
Plug 'dense-analysis/ale'
You can find further instructions on the ALE repository.
ALE will try to use Prettier installed locally before looking for a global installation.
Enable the Prettier fixer for the languages you use:
let g:ale_fixers = {\   'javascript': ['prettier'],\   'css': ['prettier'],\}
ALE supports both linters and fixers. If you don‚Äôt specify which linters to run, all available tools for all supported languages will be run, and you might get a correctly formatted file with a bunch of lint errors. To disable this behavior you can tell ALE to run only linters you've explicitly configured (more info in the FAQ):
let g:ale_linters_explicit = 1
You can then run :ALEFix in a JavaScript or CSS file to run Prettier.
To have ALE run Prettier on save:
let g:ale_fix_on_save = 1
It‚Äôs recommended to use a config file, but you can also add options in your .vimrc:
let g:ale_javascript_prettier_options = '--single-quote --trailing-comma all'
coc-prettier‚Äã
Prettier extension for coc.nvim which requires neovim or vim8.1.
Install coc.nvim with your favorite plugin manager, such as vim-plug:
Plug 'neoclide/coc.nvim', {'branch': 'release'}
And install coc-prettier by command:
CocInstall coc-prettier
Setup Prettier command in your init.vim or .vimrc
command! -nargs=0 Prettier :call CocAction('runCommand', 'prettier.formatFile')
Update your coc-settings.json for languages that you want format on save.
{  "coc.preferences.formatOnSaveFiletypes": ["css", "markdown"]}
coc-prettier have same configurations of prettier-vscode, open coc-settings.json by :CocConfig to get autocompletion support.
Running manually‚Äã
If you want something really bare-bones, you can create a custom key binding. In this example, gp (mnemonic: "get pretty") is used to run prettier (with options) in the currently active buffer:
nnoremap gp :silent %!prettier --stdin-filepath %<CR>
Note that if there‚Äôs a syntax error in your code, the whole buffer will be replaced with an error message. You‚Äôll need to press u to get your code back.
Another disadvantage of this approach is that the cursor position won‚Äôt be preserved.Edit this page\n\nThis is unreleased documentation for Prettier next version.For up-to-date documentation, see the latest version (stable).On this pageVim SetupVim users can install either vim-prettier, which is Prettier specific, or Neoformat or ALE which are generalized lint/format engines with support for Prettier.
vim-prettier‚Äã
See the vim-prettier readme for installation and usage instructions.
Neoformat‚Äã
The best way to install Neoformat is with your favorite plugin manager for Vim, such as vim-plug:
Plug 'sbdchd/neoformat'
In order for Neoformat to use a project-local version of Prettier (i.e. to use node_modules/.bin/prettier instead of looking for prettier on $PATH), you must set the neoformat_try_node_exe option:
let g:neoformat_try_node_exe = 1
Run :Neoformat or :Neoformat prettier in a supported file to run Prettier.
To have Neoformat run Prettier on save:
autocmd BufWritePre *.js Neoformat
You can also make Vim format your code more frequently, by setting an autocmd for other events. Here are a couple of useful ones:

TextChanged: after a change was made to the text in Normal mode
InsertLeave: when leaving Insert mode

For example, you can format on both of the above events together with BufWritePre like this:
autocmd BufWritePre,TextChanged,InsertLeave *.js Neoformat
See :help autocmd-events in Vim for details.
It‚Äôs recommended to use a config file, but you can also add options in your .vimrc:
autocmd FileType javascript setlocal formatprg=prettier\ --single-quote\ --trailing-comma\ es5" Use formatprg when availablelet g:neoformat_try_formatprg = 1
Each space in Prettier options should be escaped with \.
ALE‚Äã
ALE requires either Vim 8 or Neovim as ALE makes use of the asynchronous abilities that both Vim 8 and Neovim provide.
The best way to install ALE is with your favorite plugin manager for Vim, such as vim-plug:
Plug 'dense-analysis/ale'
You can find further instructions on the ALE repository.
ALE will try to use Prettier installed locally before looking for a global installation.
Enable the Prettier fixer for the languages you use:
let g:ale_fixers = {\   'javascript': ['prettier'],\   'css': ['prettier'],\}
ALE supports both linters and fixers. If you don‚Äôt specify which linters to run, all available tools for all supported languages will be run, and you might get a correctly formatted file with a bunch of lint errors. To disable this behavior you can tell ALE to run only linters you've explicitly configured (more info in the FAQ):
let g:ale_linters_explicit = 1
You can then run :ALEFix in a JavaScript or CSS file to run Prettier.
To have ALE run Prettier on save:
let g:ale_fix_on_save = 1
It‚Äôs recommended to use a config file, but you can also add options in your .vimrc:
let g:ale_javascript_prettier_options = '--single-quote --trailing-comma all'
coc-prettier‚Äã
Prettier extension for coc.nvim which requires neovim or vim8.1.
Install coc.nvim with your favorite plugin manager, such as vim-plug:
Plug 'neoclide/coc.nvim', {'branch': 'release'}
And install coc-prettier by command:
CocInstall coc-prettier
Setup Prettier command in your init.vim or .vimrc
command! -nargs=0 Prettier :call CocAction('runCommand', 'prettier.formatFile')
Update your coc-settings.json for languages that you want format on save.
{  "coc.preferences.formatOnSaveFiletypes": ["css", "markdown"]}
coc-prettier have same configurations of prettier-vscode, open coc-settings.json by :CocConfig to get autocompletion support.
Running manually‚Äã
If you want something really bare-bones, you can create a custom key binding. In this example, gp (mnemonic: "get pretty") is used to run prettier (with options) in the currently active buffer:
nnoremap gp :silent %!prettier --stdin-filepath %<CR>
Note that if there‚Äôs a syntax error in your code, the whole buffer will be replaced with an error message. You‚Äôll need to press u to get your code back.
Another disadvantage of this approach is that the cursor position won‚Äôt be preserved.Edit this pagePreviousWebStorm SetupNextWatching For Changesvim-prettierNeoformatALEcoc-prettierRunning manually\n\n\n\nWatching For ChangesYou can have Prettier watch for changes from the command line by using onchange. For example:
npx onchange "**/*" -- npx prettier --write --ignore-unknown {{changed}}
Or add the following to your package.json:
{  "scripts": {    "prettier-watch": "onchange \"**/*\" -- prettier --write --ignore-unknown {{changed}}"  }}Edit this page\n\nThis is unreleased documentation for Prettier next version.For up-to-date documentation, see the latest version (stable).Watching For ChangesYou can have Prettier watch for changes from the command line by using onchange. For example:
npx onchange "**/*" -- npx prettier --write --ignore-unknown {{changed}}
Or add the following to your package.json:
{  "scripts": {    "prettier-watch": "onchange \"**/*\" -- prettier --write --ignore-unknown {{changed}}"  }}Edit this pagePreviousVim SetupNextTechnical Details\n\n\n\nTechnical DetailsThis printer is a fork of recast‚Äôs printer with its algorithm replaced by the one described by Wadler in "A prettier printer". There still may be leftover code from recast that needs to be cleaned up.
The basic idea is that the printer takes an AST and returns an intermediate representation of the output, and the printer uses that to generate a string. The advantage is that the printer can "measure" the IR and see if the output is going to fit on a line, and break if not.
This means that most of the logic of printing an AST involves generating an abstract representation of the output involving certain commands. For example, ["(", line, arg, line, ")"] would represent a concatenation of opening parens, an argument, and closing parens. But if that doesn‚Äôt fit on one line, the printer can break where line is specified.
The Playground has a special mode for exploring how Prettier‚Äôs intermediate representation is printed. To get there, open the sidebar (the "Show options" button) and set the parser option to the special value doc-explorer.
More (rough) details can be found in commands.md.Edit this page\n\nThis is unreleased documentation for Prettier next version.For up-to-date documentation, see the latest version (stable).Technical DetailsThis printer is a fork of recast‚Äôs printer with its algorithm replaced by the one described by Wadler in "A prettier printer". There still may be leftover code from recast that needs to be cleaned up.
The basic idea is that the printer takes an AST and returns an intermediate representation of the output, and the printer uses that to generate a string. The advantage is that the printer can "measure" the IR and see if the output is going to fit on a line, and break if not.
This means that most of the logic of printing an AST involves generating an abstract representation of the output involving certain commands. For example, ["(", line, arg, line, ")"] would represent a concatenation of opening parens, an argument, and closing parens. But if that doesn‚Äôt fit on one line, the printer can break where line is specified.
The Playground has a special mode for exploring how Prettier‚Äôs intermediate representation is printed. To get there, open the sidebar (the "Show options" button) and set the parser option to the special value doc-explorer.
More (rough) details can be found in commands.md.Edit this pagePreviousWatching For ChangesNextRelated Projects\n\n\n\nOn this pageRelated ProjectsESLint Integrations‚Äã

eslint-config-prettier turns off all ESLint rules that are unnecessary or might conflict with Prettier
eslint-plugin-prettier runs Prettier as an ESLint rule and reports differences as individual ESLint issues
prettier-eslint passes prettier output to eslint --fix
prettier-standard uses prettierx and prettier-eslint to format code with standard rules

stylelint Integrations‚Äã

stylelint-config-prettier turns off all rules that are unnecessary or might conflict with Prettier.
stylelint-prettier runs Prettier as a stylelint rule and reports differences as individual stylelint issues
prettier-stylelint passes prettier output to stylelint --fix

Forks‚Äã

prettierx less opinionated fork of Prettier

Misc‚Äã

parallel-prettier is an alternative CLI that formats files in parallel to speed up large projects
prettier_d runs Prettier as a server to avoid Node.js startup delay
pretty-quick formats changed files with Prettier
rollup-plugin-prettier allows you to use Prettier with Rollup
jest-runner-prettier is Prettier as a Jest runner
prettier-chrome is an extension that runs Prettier in the browser
spotless lets you run prettier from gradle or maven.
csharpier is a port of Prettier for C#
reviewdog-action-prettier runs Prettier in GitHub Actions CI/CD workflows
Edit this page\n\nThis is unreleased documentation for Prettier next version.For up-to-date documentation, see the latest version (stable).On this pageRelated ProjectsESLint Integrations‚Äã

eslint-config-prettier turns off all ESLint rules that are unnecessary or might conflict with Prettier
eslint-plugin-prettier runs Prettier as an ESLint rule and reports differences as individual ESLint issues
prettier-eslint passes prettier output to eslint --fix
prettier-standard uses prettierx and prettier-eslint to format code with standard rules

stylelint Integrations‚Äã

stylelint-config-prettier turns off all rules that are unnecessary or might conflict with Prettier.
stylelint-prettier runs Prettier as a stylelint rule and reports differences as individual stylelint issues
prettier-stylelint passes prettier output to stylelint --fix

Forks‚Äã

prettierx less opinionated fork of Prettier

Misc‚Äã

parallel-prettier is an alternative CLI that formats files in parallel to speed up large projects
prettier_d runs Prettier as a server to avoid Node.js startup delay
pretty-quick formats changed files with Prettier
rollup-plugin-prettier allows you to use Prettier with Rollup
jest-runner-prettier is Prettier as a Jest runner
prettier-chrome is an extension that runs Prettier in the browser
spotless lets you run prettier from gradle or maven.
csharpier is a port of Prettier for C#
reviewdog-action-prettier runs Prettier in GitHub Actions CI/CD workflows
Edit this pagePreviousTechnical DetailsNextFor EnterpriseESLint Integrationsstylelint IntegrationsForksMisc\n\n\n\nOn this pageFor EnterpriseAvailable as part of the Tidelift Subscription‚Äã
Tidelift is working with the maintainers of Prettier and thousands of other open source projects to deliver commercial support and maintenance for the open source dependencies you use to build your applications. Save time, reduce risk, and improve code health, while paying the maintainers of the exact dependencies you use.
Learn more
Request a demo

Enterprise-ready open source software‚Äîmanaged for you‚Äã
The Tidelift Subscription is a managed open source subscription for application dependencies covering millions of open source projects across JavaScript, Python, Java, PHP, Ruby, .NET, and more.
Your subscription includes:
Security updates
Tidelift‚Äôs security response team coordinates patches for new breaking security vulnerabilities and alerts immediately through a private channel, so your software supply chain is always secure.
Licensing verification and indemnification
Tidelift verifies license information to enable easy policy enforcement and adds intellectual property indemnification to cover creators and users in case something goes wrong. You always have a 100% up-to-date bill of materials for your dependencies to share with your legal team, customers, or partners.
Maintenance and code improvement
Tidelift ensures the software you rely on keeps working as long as you need it to work. Your managed dependencies are actively maintained and we recruit additional maintainers where required.
Package selection and version guidance
We help you choose the best open source packages from the start‚Äîand then guide you through updates to stay on the best releases as new issues arise.
Roadmap input
Take a seat at the table with the creators behind the software you use. Tidelift‚Äôs participating maintainers earn more income as their software is used by more subscribers, so they‚Äôre interested in knowing what you need.
Tooling and cloud integration
Tidelift works with GitHub, GitLab, BitBucket, and more. We support every cloud platform (and other deployment targets, too).
The end result? All of the capabilities you expect from commercial-grade software, for the full breadth of open source you use. That means less time grappling with esoteric open source trivia, and more time building your own applications‚Äîand your business.
Learn more
Request a demoEdit this page\n\nThis is unreleased documentation for Prettier next version.For up-to-date documentation, see the latest version (stable).On this pageFor EnterpriseAvailable as part of the Tidelift Subscription‚Äã
Tidelift is working with the maintainers of Prettier and thousands of other open source projects to deliver commercial support and maintenance for the open source dependencies you use to build your applications. Save time, reduce risk, and improve code health, while paying the maintainers of the exact dependencies you use.
Learn more
Request a demo

Enterprise-ready open source software‚Äîmanaged for you‚Äã
The Tidelift Subscription is a managed open source subscription for application dependencies covering millions of open source projects across JavaScript, Python, Java, PHP, Ruby, .NET, and more.
Your subscription includes:
Security updates
Tidelift‚Äôs security response team coordinates patches for new breaking security vulnerabilities and alerts immediately through a private channel, so your software supply chain is always secure.
Licensing verification and indemnification
Tidelift verifies license information to enable easy policy enforcement and adds intellectual property indemnification to cover creators and users in case something goes wrong. You always have a 100% up-to-date bill of materials for your dependencies to share with your legal team, customers, or partners.
Maintenance and code improvement
Tidelift ensures the software you rely on keeps working as long as you need it to work. Your managed dependencies are actively maintained and we recruit additional maintainers where required.
Package selection and version guidance
We help you choose the best open source packages from the start‚Äîand then guide you through updates to stay on the best releases as new issues arise.
Roadmap input
Take a seat at the table with the creators behind the software you use. Tidelift‚Äôs participating maintainers earn more income as their software is used by more subscribers, so they‚Äôre interested in knowing what you need.
Tooling and cloud integration
Tidelift works with GitHub, GitLab, BitBucket, and more. We support every cloud platform (and other deployment targets, too).
The end result? All of the capabilities you expect from commercial-grade software, for the full breadth of open source you use. That means less time grappling with esoteric open source trivia, and more time building your own applications‚Äîand your business.
Learn more
Request a demoEdit this pagePreviousRelated ProjectsAvailable as part of the Tidelift SubscriptionEnterprise-ready open source software‚Äîmanaged for you\n\n\n\nOn this pageWhat is Prettier?Prettier is an opinionated code formatter with support for:

JavaScript (including experimental features)
JSX
Angular
Vue
Flow
TypeScript
CSS, Less, and SCSS
HTML
Ember/Handlebars
JSON
GraphQL
Markdown, including GFM and MDX v1
YAML

It removes all original styling* and ensures that all outputted code conforms to a consistent style. (See this blog post)
Prettier takes your code and reprints it from scratch by taking the line length into account.
For example, take the following code:
foo(arg1, arg2, arg3, arg4);
It fits in a single line so it‚Äôs going to stay as is. However, we've all run into this situation:
foo(reallyLongArg(), omgSoManyParameters(), IShouldRefactorThis(), isThereSeriouslyAnotherOne());
Suddenly our previous format for calling function breaks down because this is too long. Prettier is going to do the painstaking work of reprinting it like that for you:
foo(  reallyLongArg(),  omgSoManyParameters(),  IShouldRefactorThis(),  isThereSeriouslyAnotherOne(),);
Prettier enforces a consistent code style (i.e. code formatting that won‚Äôt affect the AST) across your entire codebase because it disregards the original styling* by parsing it away and re-printing the parsed AST with its own rules that take the maximum line length into account, wrapping code when necessary.
If you want to learn more, these two conference talks are great introductions:


Footnotes‚Äã
* Well actually, some original styling is preserved when practical‚Äîsee empty lines and multi-line objects.Edit this page\n\nThis is unreleased documentation for Prettier next version.For up-to-date documentation, see the latest version (stable).On this pageWhat is Prettier?Prettier is an opinionated code formatter with support for:

JavaScript (including experimental features)
JSX
Angular
Vue
Flow
TypeScript
CSS, Less, and SCSS
HTML
Ember/Handlebars
JSON
GraphQL
Markdown, including GFM and MDX v1
YAML

It removes all original styling* and ensures that all outputted code conforms to a consistent style. (See this blog post)
Prettier takes your code and reprints it from scratch by taking the line length into account.
For example, take the following code:
foo(arg1, arg2, arg3, arg4);
It fits in a single line so it‚Äôs going to stay as is. However, we've all run into this situation:
foo(reallyLongArg(), omgSoManyParameters(), IShouldRefactorThis(), isThereSeriouslyAnotherOne());
Suddenly our previous format for calling function breaks down because this is too long. Prettier is going to do the painstaking work of reprinting it like that for you:
foo(  reallyLongArg(),  omgSoManyParameters(),  IShouldRefactorThis(),  isThereSeriouslyAnotherOne(),);
Prettier enforces a consistent code style (i.e. code formatting that won‚Äôt affect the AST) across your entire codebase because it disregards the original styling* by parsing it away and re-printing the parsed AST with its own rules that take the maximum line length into account, wrapping code when necessary.
If you want to learn more, these two conference talks are great introductions:


Footnotes‚Äã
* Well actually, some original styling is preserved when practical‚Äîsee empty lines and multi-line objects.Edit this pageNextWhy Prettier?\n\n\n\nOn this pageRationalePrettier is an opinionated code formatter. This document explains some of its choices.
What Prettier is concerned about‚Äã
Correctness‚Äã
The first requirement of Prettier is to output valid code that has the exact same behavior as before formatting. Please report any code where Prettier fails to follow these correctness rules ‚Äî that‚Äôs a bug which needs to be fixed!
Strings‚Äã
Double or single quotes? Prettier chooses the one which results in the fewest number of escapes. "It's gettin' better!", not 'It\'s gettin\' better!'. In case of a tie or the string not containing any quotes, Prettier defaults to double quotes (but that can be changed via the singleQuote option).
JSX has its own option for quotes: jsxSingleQuote.
JSX takes its roots from HTML, where the dominant use of quotes for attributes is double quotes. Browser developer tools also follow this convention by always displaying HTML with double quotes, even if the source code uses single quotes. A separate option allows using single quotes for JS and double quotes for "HTML" (JSX).
Prettier maintains the way your string is escaped. For example, "üôÇ" won‚Äôt be formatted into "\uD83D\uDE42" and vice versa.
Empty lines‚Äã
It turns out that empty lines are very hard to automatically generate. The approach that Prettier takes is to preserve empty lines the way they were in the original source code. There are two additional rules:

Prettier collapses multiple blank lines into a single blank line.
Empty lines at the start and end of blocks (and whole files) are removed. (Files always end with a single newline, though.)

Multi-line objects‚Äã
By default, Prettier‚Äôs printing algorithm prints expressions on a single line if they fit. Objects are used for a lot of different things in JavaScript, though, and sometimes it really helps readability if they stay multiline. See object lists, nested configs, stylesheets and keyed methods, for example. We haven‚Äôt been able to find a good rule for all those cases, so by default Prettier keeps objects multi-line if there‚Äôs a newline between the { and the first key in the original source code. Consequently, long single-line objects are automatically expanded, but short multi-line objects are never collapsed.
You can disable this conditional behavior with the objectWrap option.
Tip: If you have a multi-line object that you‚Äôd like to join up into a single line:
const user = {  name: "John Doe",  age: 30,};
‚Ä¶all you need to do is remove the newline after {:
const user = {  name: "John Doe",  age: 30};
‚Ä¶and then run Prettier:
const user = { name: "John Doe", age: 30 };
And if you‚Äôd like to go multi-line again, add in a newline after {:
const user = { name: "John Doe", age: 30 };
‚Ä¶and run Prettier:
const user = {  name: "John Doe",  age: 30,};
A note on formatting reversibilityThe semi-manual formatting for object literals is in fact a workaround, not a feature. It was implemented only because at the time a good heuristic wasn‚Äôt found and an urgent fix was needed. However, as a general strategy, Prettier avoids non-reversible formatting like that, so the team is still looking for heuristics that would allow either to remove this behavior completely or at least to reduce the number of situations where it‚Äôs applied.What does reversible mean? Once an object literal becomes multiline, Prettier won‚Äôt collapse it back. If in Prettier-formatted code, we add a property to an object literal, run Prettier, then change our mind, remove the added property, and then run Prettier again, we might end up with a formatting not identical to the initial one. This useless change might even get included in a commit, which is exactly the kind of situation Prettier was created to prevent.
Decorators‚Äã
Just like with objects, decorators are used for a lot of different things. Sometimes it makes sense to write decorators above the line they're decorating, sometimes it‚Äôs nicer if they're on the same line. We haven‚Äôt been able to find a good rule for this, so Prettier keeps your decorator positioned like you wrote them (if they fit on the line). This isn‚Äôt ideal, but a pragmatic solution to a difficult problem.
@Component({  selector: "hero-button",  template: `<button>{{ label }}</button>`,})class HeroButtonComponent {  // These decorators were written inline and fit on the line so they stay  // inline.  @Output() change = new EventEmitter();  @Input() label: string;  // These were written multiline, so they stay multiline.  @readonly  @nonenumerable  NODE_TYPE: 2;}
There‚Äôs one exception: classes. We don‚Äôt think it ever makes sense to inline the decorators for them, so they are always moved to their own line.
// Before running Prettier:@observer class OrderLine {  @observable price: number = 0;}
// After running Prettier:@observerclass OrderLine {  @observable price: number = 0;}
Note: Prettier 1.14.x and older tried to automatically move your decorators, so if you've run an older Prettier version on your code you might need to manually join up some decorators here and there to avoid inconsistencies:
@observerclass OrderLine {  @observable price: number = 0;  @observable  amount: number = 0;}
One final thing: TC39 has not yet decided if decorators come before or after export. In the meantime, Prettier supports both:
@decorator export class Foo {}export @decorator class Foo {}
Template literals‚Äã
Template literals can contain interpolations. Deciding whether it's appropriate to insert a linebreak within an interpolation unfortunately depends on the semantic content of the template - for example, introducing a linebreak in the middle of a natural-language sentence is usually undesirable. Since Prettier doesn't have enough information to make this decision itself, it uses a heuristic similar to that used for objects: it will only split an interpolation expression across multiple lines if there was already a linebreak within that interpolation.
This means that a literal like the following will not be broken onto multiple lines, even if it exceeds the print width:
`this is a long message which contains an interpolation: ${format(data)} <- like this`;
If you want Prettier to split up an interpolation, you'll need to ensure there's a linebreak somewhere within the ${...}. Otherwise it will keep everything on a single line, no matter how long it is.
The team would prefer not to depend on the original formatting in this way, but it's the best heuristic we have at the moment.
Semicolons‚Äã
This is about using the noSemi option.
Consider this piece of code:
if (shouldAddLines) {  [-1, 1].forEach(delta => addLine(delta * 20))}
While the above code works just fine without semicolons, Prettier actually turns it into:
if (shouldAddLines) {  ;[-1, 1].forEach(delta => addLine(delta * 20))}
This is to help you avoid mistakes. Imagine Prettier not inserting that semicolon and adding this line:
 if (shouldAddLines) {+  console.log('Do we even get here??')   [-1, 1].forEach(delta => addLine(delta * 20)) }
Oops! The above actually means:
if (shouldAddLines) {  console.log('Do we even get here??')[-1, 1].forEach(delta => addLine(delta * 20))}
With a semicolon in front of that [ such issues never happen. It makes the line independent of other lines so you can move and add lines without having to think about ASI rules.
This practice is also common in standard which uses a semicolon-free style.
Note that if your program currently has a semicolon-related bug in it, Prettier will not auto-fix the bug for you. Remember, Prettier only reformats code, it does not change the behavior of the code. Take this buggy piece of code as an example, where the developer forgot to place a semicolon before the (:
console.log('Running a background task')(async () => {  await doBackgroundWork()})()
If you feed this into Prettier, it will not alter the behavior of this code, instead, it will reformat it in a way that shows how this code will actually behave when ran.
console.log("Running a background task")(async () => {  await doBackgroundWork();})();
Print width‚Äã
The printWidth option is more of a guideline to Prettier than a hard rule. It is not the upper allowed line length limit. It is a way to say to Prettier roughly how long you‚Äôd like lines to be. Prettier will make both shorter and longer lines, but generally strive to meet the specified print width.
There are some edge cases, such as really long string literals, regexps, comments and variable names, which cannot be broken across lines (without using code transforms which Prettier doesn‚Äôt do). Or if you nest your code 50 levels deep your lines are of course going to be mostly indentation :)
Apart from that, there are a few cases where Prettier intentionally exceeds the print width.
Imports‚Äã
Prettier can break long import statements across several lines:
import {  CollectionDashboard,  DashboardPlaceholder,} from "../components/collections/collection-dashboard/main";
The following example doesn‚Äôt fit within the print width, but Prettier prints it in a single line anyway:
import { CollectionDashboard } from "../components/collections/collection-dashboard/main";
This might be unexpected by some, but we do it this way since it was a common request to keep imports with single elements in a single line. The same applies for require calls.
Testing functions‚Äã
Another common request was to keep lengthy test descriptions in one line, even if it gets too long. In such cases, wrapping the arguments to new lines doesn‚Äôt help much.
describe("NodeRegistry", () => {  it("makes no request if there are no nodes to prefetch, even if the cache is stale", async () => {    // The above line exceeds the print width but stayed on one line anyway.  });});
Prettier has special cases for common testing framework functions such as describe, it and test.
JSX‚Äã
Prettier prints things a little differently compared to other JS when JSX is involved:
function greet(user) {  return user    ? `Welcome back, ${user.name}!`    : "Greetings, traveler! Sign up today!";}function Greet({ user }) {  return (    <div>      {user ? (        <p>Welcome back, {user.name}!</p>      ) : (        <p>Greetings, traveler! Sign up today!</p>      )}    </div>  );}
There are two reasons.
First off, lots of people already wrapped their JSX in parentheses, especially in return statements. Prettier follows this common style.
Secondly, the alternate formatting makes it easier to edit the JSX. It is easy to leave a semicolon behind. As opposed to normal JS, a leftover semicolon in JSX can end up as plain text showing on your page.
<div>  <p>Greetings, traveler! Sign up today!</p>; {/* <-- Oops! */}</div>
Comments‚Äã
When it comes to the content of comments, Prettier can‚Äôt do much really. Comments can contain everything from prose to commented out code and ASCII diagrams. Since they can contain anything, Prettier can‚Äôt know how to format or wrap them. So they are left as-is. The only exception to this are JSDoc-style comments (block comments where every line starts with a *), which Prettier can fix the indentation of.
Then there‚Äôs the question of where to put the comments. Turns out this is a really difficult problem. Prettier tries its best to keep your comments roughly where they were, but it‚Äôs no easy task because comments can be placed almost anywhere.
Generally, you get the best results when placing comments on their own lines, instead of at the end of lines. Prefer // eslint-disable-next-line over // eslint-disable-line.
Note that ‚Äúmagic comments‚Äù such as eslint-disable-next-line and $FlowFixMe might sometimes need to be manually moved due to Prettier breaking an expression into multiple lines.
Imagine this piece of code:
// eslint-disable-next-line no-evalconst result = safeToEval ? eval(input) : fallback(input);
Then you need to add another condition:
// eslint-disable-next-line no-evalconst result = safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);
Prettier will turn the above into:
// eslint-disable-next-line no-evalconst result =  safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);
Which means that the eslint-disable-next-line comment is no longer effective. In this case you need to move the comment:
const result =  // eslint-disable-next-line no-eval  safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);
If possible, prefer comments that operate on line ranges (e.g. eslint-disable and eslint-enable) or on the statement level (e.g. /* istanbul ignore next */), they are even safer. It‚Äôs possible to disallow using eslint-disable-line and eslint-disable-next-line comments using eslint-plugin-eslint-comments.
Disclaimer about non-standard syntax‚Äã
Prettier is often able to recognize and format non-standard syntax such as ECMAScript early-stage proposals and Markdown syntax extensions not defined by any specification. The support for such syntax is considered best-effort and experimental. Incompatibilities may be introduced in any release and should not be viewed as breaking changes.
Disclaimer about machine-generated files‚Äã
Some files, like package.json or composer.lock, are machine-generated and regularly updated by the package manager. If Prettier were to use the same JSON formatting rules as with other files, it would regularly conflict with these other tools. To avoid this inconvenience, Prettier will use a formatter based on JSON.stringify on such files instead. You may notice these differences, such as the removal of vertical whitespace, but this is an intended behavior.
What Prettier is not concerned about‚Äã
Prettier only prints code. It does not transform it. This is to limit the scope of Prettier. Let‚Äôs focus on the printing and do it really well!
Here are a few examples of things that are out of scope for Prettier:

Turning single- or double-quoted strings into template literals or vice versa.
Using + to break long string literals into parts that fit the print width.
Adding/removing {} and return where they are optional.
Turning ?: into if-else statements.
Sorting/moving imports, object keys, class members, JSX keys, CSS properties or anything else. Apart from being a transform rather than just printing (as mentioned above), sorting is potentially unsafe because of side effects (for imports, as an example) and makes it difficult to verify the most important correctness goal.
Edit this page\n\nThis is unreleased documentation for Prettier next version.For up-to-date documentation, see the latest version (stable).On this pageRationalePrettier is an opinionated code formatter. This document explains some of its choices.
What Prettier is concerned about‚Äã
Correctness‚Äã
The first requirement of Prettier is to output valid code that has the exact same behavior as before formatting. Please report any code where Prettier fails to follow these correctness rules ‚Äî that‚Äôs a bug which needs to be fixed!
Strings‚Äã
Double or single quotes? Prettier chooses the one which results in the fewest number of escapes. "It's gettin' better!", not 'It\'s gettin\' better!'. In case of a tie or the string not containing any quotes, Prettier defaults to double quotes (but that can be changed via the singleQuote option).
JSX has its own option for quotes: jsxSingleQuote.
JSX takes its roots from HTML, where the dominant use of quotes for attributes is double quotes. Browser developer tools also follow this convention by always displaying HTML with double quotes, even if the source code uses single quotes. A separate option allows using single quotes for JS and double quotes for "HTML" (JSX).
Prettier maintains the way your string is escaped. For example, "üôÇ" won‚Äôt be formatted into "\uD83D\uDE42" and vice versa.
Empty lines‚Äã
It turns out that empty lines are very hard to automatically generate. The approach that Prettier takes is to preserve empty lines the way they were in the original source code. There are two additional rules:

Prettier collapses multiple blank lines into a single blank line.
Empty lines at the start and end of blocks (and whole files) are removed. (Files always end with a single newline, though.)

Multi-line objects‚Äã
By default, Prettier‚Äôs printing algorithm prints expressions on a single line if they fit. Objects are used for a lot of different things in JavaScript, though, and sometimes it really helps readability if they stay multiline. See object lists, nested configs, stylesheets and keyed methods, for example. We haven‚Äôt been able to find a good rule for all those cases, so by default Prettier keeps objects multi-line if there‚Äôs a newline between the { and the first key in the original source code. Consequently, long single-line objects are automatically expanded, but short multi-line objects are never collapsed.
You can disable this conditional behavior with the objectWrap option.
Tip: If you have a multi-line object that you‚Äôd like to join up into a single line:
const user = {  name: "John Doe",  age: 30,};
‚Ä¶all you need to do is remove the newline after {:
const user = {  name: "John Doe",  age: 30};
‚Ä¶and then run Prettier:
const user = { name: "John Doe", age: 30 };
And if you‚Äôd like to go multi-line again, add in a newline after {:
const user = { name: "John Doe", age: 30 };
‚Ä¶and run Prettier:
const user = {  name: "John Doe",  age: 30,};
A note on formatting reversibilityThe semi-manual formatting for object literals is in fact a workaround, not a feature. It was implemented only because at the time a good heuristic wasn‚Äôt found and an urgent fix was needed. However, as a general strategy, Prettier avoids non-reversible formatting like that, so the team is still looking for heuristics that would allow either to remove this behavior completely or at least to reduce the number of situations where it‚Äôs applied.What does reversible mean? Once an object literal becomes multiline, Prettier won‚Äôt collapse it back. If in Prettier-formatted code, we add a property to an object literal, run Prettier, then change our mind, remove the added property, and then run Prettier again, we might end up with a formatting not identical to the initial one. This useless change might even get included in a commit, which is exactly the kind of situation Prettier was created to prevent.
Decorators‚Äã
Just like with objects, decorators are used for a lot of different things. Sometimes it makes sense to write decorators above the line they're decorating, sometimes it‚Äôs nicer if they're on the same line. We haven‚Äôt been able to find a good rule for this, so Prettier keeps your decorator positioned like you wrote them (if they fit on the line). This isn‚Äôt ideal, but a pragmatic solution to a difficult problem.
@Component({  selector: "hero-button",  template: `<button>{{ label }}</button>`,})class HeroButtonComponent {  // These decorators were written inline and fit on the line so they stay  // inline.  @Output() change = new EventEmitter();  @Input() label: string;  // These were written multiline, so they stay multiline.  @readonly  @nonenumerable  NODE_TYPE: 2;}
There‚Äôs one exception: classes. We don‚Äôt think it ever makes sense to inline the decorators for them, so they are always moved to their own line.
// Before running Prettier:@observer class OrderLine {  @observable price: number = 0;}
// After running Prettier:@observerclass OrderLine {  @observable price: number = 0;}
Note: Prettier 1.14.x and older tried to automatically move your decorators, so if you've run an older Prettier version on your code you might need to manually join up some decorators here and there to avoid inconsistencies:
@observerclass OrderLine {  @observable price: number = 0;  @observable  amount: number = 0;}
One final thing: TC39 has not yet decided if decorators come before or after export. In the meantime, Prettier supports both:
@decorator export class Foo {}export @decorator class Foo {}
Template literals‚Äã
Template literals can contain interpolations. Deciding whether it's appropriate to insert a linebreak within an interpolation unfortunately depends on the semantic content of the template - for example, introducing a linebreak in the middle of a natural-language sentence is usually undesirable. Since Prettier doesn't have enough information to make this decision itself, it uses a heuristic similar to that used for objects: it will only split an interpolation expression across multiple lines if there was already a linebreak within that interpolation.
This means that a literal like the following will not be broken onto multiple lines, even if it exceeds the print width:
`this is a long message which contains an interpolation: ${format(data)} <- like this`;
If you want Prettier to split up an interpolation, you'll need to ensure there's a linebreak somewhere within the ${...}. Otherwise it will keep everything on a single line, no matter how long it is.
The team would prefer not to depend on the original formatting in this way, but it's the best heuristic we have at the moment.
Semicolons‚Äã
This is about using the noSemi option.
Consider this piece of code:
if (shouldAddLines) {  [-1, 1].forEach(delta => addLine(delta * 20))}
While the above code works just fine without semicolons, Prettier actually turns it into:
if (shouldAddLines) {  ;[-1, 1].forEach(delta => addLine(delta * 20))}
This is to help you avoid mistakes. Imagine Prettier not inserting that semicolon and adding this line:
 if (shouldAddLines) {+  console.log('Do we even get here??')   [-1, 1].forEach(delta => addLine(delta * 20)) }
Oops! The above actually means:
if (shouldAddLines) {  console.log('Do we even get here??')[-1, 1].forEach(delta => addLine(delta * 20))}
With a semicolon in front of that [ such issues never happen. It makes the line independent of other lines so you can move and add lines without having to think about ASI rules.
This practice is also common in standard which uses a semicolon-free style.
Note that if your program currently has a semicolon-related bug in it, Prettier will not auto-fix the bug for you. Remember, Prettier only reformats code, it does not change the behavior of the code. Take this buggy piece of code as an example, where the developer forgot to place a semicolon before the (:
console.log('Running a background task')(async () => {  await doBackgroundWork()})()
If you feed this into Prettier, it will not alter the behavior of this code, instead, it will reformat it in a way that shows how this code will actually behave when ran.
console.log("Running a background task")(async () => {  await doBackgroundWork();})();
Print width‚Äã
The printWidth option is more of a guideline to Prettier than a hard rule. It is not the upper allowed line length limit. It is a way to say to Prettier roughly how long you‚Äôd like lines to be. Prettier will make both shorter and longer lines, but generally strive to meet the specified print width.
There are some edge cases, such as really long string literals, regexps, comments and variable names, which cannot be broken across lines (without using code transforms which Prettier doesn‚Äôt do). Or if you nest your code 50 levels deep your lines are of course going to be mostly indentation :)
Apart from that, there are a few cases where Prettier intentionally exceeds the print width.
Imports‚Äã
Prettier can break long import statements across several lines:
import {  CollectionDashboard,  DashboardPlaceholder,} from "../components/collections/collection-dashboard/main";
The following example doesn‚Äôt fit within the print width, but Prettier prints it in a single line anyway:
import { CollectionDashboard } from "../components/collections/collection-dashboard/main";
This might be unexpected by some, but we do it this way since it was a common request to keep imports with single elements in a single line. The same applies for require calls.
Testing functions‚Äã
Another common request was to keep lengthy test descriptions in one line, even if it gets too long. In such cases, wrapping the arguments to new lines doesn‚Äôt help much.
describe("NodeRegistry", () => {  it("makes no request if there are no nodes to prefetch, even if the cache is stale", async () => {    // The above line exceeds the print width but stayed on one line anyway.  });});
Prettier has special cases for common testing framework functions such as describe, it and test.
JSX‚Äã
Prettier prints things a little differently compared to other JS when JSX is involved:
function greet(user) {  return user    ? `Welcome back, ${user.name}!`    : "Greetings, traveler! Sign up today!";}function Greet({ user }) {  return (    <div>      {user ? (        <p>Welcome back, {user.name}!</p>      ) : (        <p>Greetings, traveler! Sign up today!</p>      )}    </div>  );}
There are two reasons.
First off, lots of people already wrapped their JSX in parentheses, especially in return statements. Prettier follows this common style.
Secondly, the alternate formatting makes it easier to edit the JSX. It is easy to leave a semicolon behind. As opposed to normal JS, a leftover semicolon in JSX can end up as plain text showing on your page.
<div>  <p>Greetings, traveler! Sign up today!</p>; {/* <-- Oops! */}</div>
Comments‚Äã
When it comes to the content of comments, Prettier can‚Äôt do much really. Comments can contain everything from prose to commented out code and ASCII diagrams. Since they can contain anything, Prettier can‚Äôt know how to format or wrap them. So they are left as-is. The only exception to this are JSDoc-style comments (block comments where every line starts with a *), which Prettier can fix the indentation of.
Then there‚Äôs the question of where to put the comments. Turns out this is a really difficult problem. Prettier tries its best to keep your comments roughly where they were, but it‚Äôs no easy task because comments can be placed almost anywhere.
Generally, you get the best results when placing comments on their own lines, instead of at the end of lines. Prefer // eslint-disable-next-line over // eslint-disable-line.
Note that ‚Äúmagic comments‚Äù such as eslint-disable-next-line and $FlowFixMe might sometimes need to be manually moved due to Prettier breaking an expression into multiple lines.
Imagine this piece of code:
// eslint-disable-next-line no-evalconst result = safeToEval ? eval(input) : fallback(input);
Then you need to add another condition:
// eslint-disable-next-line no-evalconst result = safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);
Prettier will turn the above into:
// eslint-disable-next-line no-evalconst result =  safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);
Which means that the eslint-disable-next-line comment is no longer effective. In this case you need to move the comment:
const result =  // eslint-disable-next-line no-eval  safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);
If possible, prefer comments that operate on line ranges (e.g. eslint-disable and eslint-enable) or on the statement level (e.g. /* istanbul ignore next */), they are even safer. It‚Äôs possible to disallow using eslint-disable-line and eslint-disable-next-line comments using eslint-plugin-eslint-comments.
Disclaimer about non-standard syntax‚Äã
Prettier is often able to recognize and format non-standard syntax such as ECMAScript early-stage proposals and Markdown syntax extensions not defined by any specification. The support for such syntax is considered best-effort and experimental. Incompatibilities may be introduced in any release and should not be viewed as breaking changes.
Disclaimer about machine-generated files‚Äã
Some files, like package.json or composer.lock, are machine-generated and regularly updated by the package manager. If Prettier were to use the same JSON formatting rules as with other files, it would regularly conflict with these other tools. To avoid this inconvenience, Prettier will use a formatter based on JSON.stringify on such files instead. You may notice these differences, such as the removal of vertical whitespace, but this is an intended behavior.
What Prettier is not concerned about‚Äã
Prettier only prints code. It does not transform it. This is to limit the scope of Prettier. Let‚Äôs focus on the printing and do it really well!
Here are a few examples of things that are out of scope for Prettier:

Turning single- or double-quoted strings into template literals or vice versa.
Using + to break long string literals into parts that fit the print width.
Adding/removing {} and return where they are optional.
Turning ?: into if-else statements.
Sorting/moving imports, object keys, class members, JSX keys, CSS properties or anything else. Apart from being a transform rather than just printing (as mentioned above), sorting is potentially unsafe because of side effects (for imports, as an example) and makes it difficult to verify the most important correctness goal.
Edit this pagePreviousOption PhilosophyNextInstallWhat Prettier is concerned aboutCorrectnessStringsEmpty linesMulti-line objectsDecoratorsTemplate literalsSemicolonsPrint widthJSXCommentsDisclaimer about non-standard syntaxDisclaimer about machine-generated filesWhat Prettier is not concerned about\n\n\n\nOn this pageRationalePrettier is an opinionated code formatter. This document explains some of its choices.
What Prettier is concerned about‚Äã
Correctness‚Äã
The first requirement of Prettier is to output valid code that has the exact same behavior as before formatting. Please report any code where Prettier fails to follow these correctness rules ‚Äî that‚Äôs a bug which needs to be fixed!
Strings‚Äã
Double or single quotes? Prettier chooses the one which results in the fewest number of escapes. "It's gettin' better!", not 'It\'s gettin\' better!'. In case of a tie or the string not containing any quotes, Prettier defaults to double quotes (but that can be changed via the singleQuote option).
JSX has its own option for quotes: jsxSingleQuote.
JSX takes its roots from HTML, where the dominant use of quotes for attributes is double quotes. Browser developer tools also follow this convention by always displaying HTML with double quotes, even if the source code uses single quotes. A separate option allows using single quotes for JS and double quotes for "HTML" (JSX).
Prettier maintains the way your string is escaped. For example, "üôÇ" won‚Äôt be formatted into "\uD83D\uDE42" and vice versa.
Empty lines‚Äã
It turns out that empty lines are very hard to automatically generate. The approach that Prettier takes is to preserve empty lines the way they were in the original source code. There are two additional rules:

Prettier collapses multiple blank lines into a single blank line.
Empty lines at the start and end of blocks (and whole files) are removed. (Files always end with a single newline, though.)

Multi-line objects‚Äã
By default, Prettier‚Äôs printing algorithm prints expressions on a single line if they fit. Objects are used for a lot of different things in JavaScript, though, and sometimes it really helps readability if they stay multiline. See object lists, nested configs, stylesheets and keyed methods, for example. We haven‚Äôt been able to find a good rule for all those cases, so by default Prettier keeps objects multi-line if there‚Äôs a newline between the { and the first key in the original source code. Consequently, long single-line objects are automatically expanded, but short multi-line objects are never collapsed.
You can disable this conditional behavior with the objectWrap option.
Tip: If you have a multi-line object that you‚Äôd like to join up into a single line:
const user = {  name: "John Doe",  age: 30,};
‚Ä¶all you need to do is remove the newline after {:
const user = {  name: "John Doe",  age: 30};
‚Ä¶and then run Prettier:
const user = { name: "John Doe", age: 30 };
And if you‚Äôd like to go multi-line again, add in a newline after {:
const user = { name: "John Doe", age: 30 };
‚Ä¶and run Prettier:
const user = {  name: "John Doe",  age: 30,};
A note on formatting reversibilityThe semi-manual formatting for object literals is in fact a workaround, not a feature. It was implemented only because at the time a good heuristic wasn‚Äôt found and an urgent fix was needed. However, as a general strategy, Prettier avoids non-reversible formatting like that, so the team is still looking for heuristics that would allow either to remove this behavior completely or at least to reduce the number of situations where it‚Äôs applied.What does reversible mean? Once an object literal becomes multiline, Prettier won‚Äôt collapse it back. If in Prettier-formatted code, we add a property to an object literal, run Prettier, then change our mind, remove the added property, and then run Prettier again, we might end up with a formatting not identical to the initial one. This useless change might even get included in a commit, which is exactly the kind of situation Prettier was created to prevent.
Decorators‚Äã
Just like with objects, decorators are used for a lot of different things. Sometimes it makes sense to write decorators above the line they're decorating, sometimes it‚Äôs nicer if they're on the same line. We haven‚Äôt been able to find a good rule for this, so Prettier keeps your decorator positioned like you wrote them (if they fit on the line). This isn‚Äôt ideal, but a pragmatic solution to a difficult problem.
@Component({  selector: "hero-button",  template: `<button>{{ label }}</button>`,})class HeroButtonComponent {  // These decorators were written inline and fit on the line so they stay  // inline.  @Output() change = new EventEmitter();  @Input() label: string;  // These were written multiline, so they stay multiline.  @readonly  @nonenumerable  NODE_TYPE: 2;}
There‚Äôs one exception: classes. We don‚Äôt think it ever makes sense to inline the decorators for them, so they are always moved to their own line.
// Before running Prettier:@observer class OrderLine {  @observable price: number = 0;}
// After running Prettier:@observerclass OrderLine {  @observable price: number = 0;}
Note: Prettier 1.14.x and older tried to automatically move your decorators, so if you've run an older Prettier version on your code you might need to manually join up some decorators here and there to avoid inconsistencies:
@observerclass OrderLine {  @observable price: number = 0;  @observable  amount: number = 0;}
One final thing: TC39 has not yet decided if decorators come before or after export. In the meantime, Prettier supports both:
@decorator export class Foo {}export @decorator class Foo {}
Template literals‚Äã
Template literals can contain interpolations. Deciding whether it's appropriate to insert a linebreak within an interpolation unfortunately depends on the semantic content of the template - for example, introducing a linebreak in the middle of a natural-language sentence is usually undesirable. Since Prettier doesn't have enough information to make this decision itself, it uses a heuristic similar to that used for objects: it will only split an interpolation expression across multiple lines if there was already a linebreak within that interpolation.
This means that a literal like the following will not be broken onto multiple lines, even if it exceeds the print width:
`this is a long message which contains an interpolation: ${format(data)} <- like this`;
If you want Prettier to split up an interpolation, you'll need to ensure there's a linebreak somewhere within the ${...}. Otherwise it will keep everything on a single line, no matter how long it is.
The team would prefer not to depend on the original formatting in this way, but it's the best heuristic we have at the moment.
Semicolons‚Äã
This is about using the noSemi option.
Consider this piece of code:
if (shouldAddLines) {  [-1, 1].forEach(delta => addLine(delta * 20))}
While the above code works just fine without semicolons, Prettier actually turns it into:
if (shouldAddLines) {  ;[-1, 1].forEach(delta => addLine(delta * 20))}
This is to help you avoid mistakes. Imagine Prettier not inserting that semicolon and adding this line:
 if (shouldAddLines) {+  console.log('Do we even get here??')   [-1, 1].forEach(delta => addLine(delta * 20)) }
Oops! The above actually means:
if (shouldAddLines) {  console.log('Do we even get here??')[-1, 1].forEach(delta => addLine(delta * 20))}
With a semicolon in front of that [ such issues never happen. It makes the line independent of other lines so you can move and add lines without having to think about ASI rules.
This practice is also common in standard which uses a semicolon-free style.
Note that if your program currently has a semicolon-related bug in it, Prettier will not auto-fix the bug for you. Remember, Prettier only reformats code, it does not change the behavior of the code. Take this buggy piece of code as an example, where the developer forgot to place a semicolon before the (:
console.log('Running a background task')(async () => {  await doBackgroundWork()})()
If you feed this into Prettier, it will not alter the behavior of this code, instead, it will reformat it in a way that shows how this code will actually behave when ran.
console.log("Running a background task")(async () => {  await doBackgroundWork();})();
Print width‚Äã
The printWidth option is more of a guideline to Prettier than a hard rule. It is not the upper allowed line length limit. It is a way to say to Prettier roughly how long you‚Äôd like lines to be. Prettier will make both shorter and longer lines, but generally strive to meet the specified print width.
There are some edge cases, such as really long string literals, regexps, comments and variable names, which cannot be broken across lines (without using code transforms which Prettier doesn‚Äôt do). Or if you nest your code 50 levels deep your lines are of course going to be mostly indentation :)
Apart from that, there are a few cases where Prettier intentionally exceeds the print width.
Imports‚Äã
Prettier can break long import statements across several lines:
import {  CollectionDashboard,  DashboardPlaceholder,} from "../components/collections/collection-dashboard/main";
The following example doesn‚Äôt fit within the print width, but Prettier prints it in a single line anyway:
import { CollectionDashboard } from "../components/collections/collection-dashboard/main";
This might be unexpected by some, but we do it this way since it was a common request to keep imports with single elements in a single line. The same applies for require calls.
Testing functions‚Äã
Another common request was to keep lengthy test descriptions in one line, even if it gets too long. In such cases, wrapping the arguments to new lines doesn‚Äôt help much.
describe("NodeRegistry", () => {  it("makes no request if there are no nodes to prefetch, even if the cache is stale", async () => {    // The above line exceeds the print width but stayed on one line anyway.  });});
Prettier has special cases for common testing framework functions such as describe, it and test.
JSX‚Äã
Prettier prints things a little differently compared to other JS when JSX is involved:
function greet(user) {  return user    ? `Welcome back, ${user.name}!`    : "Greetings, traveler! Sign up today!";}function Greet({ user }) {  return (    <div>      {user ? (        <p>Welcome back, {user.name}!</p>      ) : (        <p>Greetings, traveler! Sign up today!</p>      )}    </div>  );}
There are two reasons.
First off, lots of people already wrapped their JSX in parentheses, especially in return statements. Prettier follows this common style.
Secondly, the alternate formatting makes it easier to edit the JSX. It is easy to leave a semicolon behind. As opposed to normal JS, a leftover semicolon in JSX can end up as plain text showing on your page.
<div>  <p>Greetings, traveler! Sign up today!</p>; {/* <-- Oops! */}</div>
Comments‚Äã
When it comes to the content of comments, Prettier can‚Äôt do much really. Comments can contain everything from prose to commented out code and ASCII diagrams. Since they can contain anything, Prettier can‚Äôt know how to format or wrap them. So they are left as-is. The only exception to this are JSDoc-style comments (block comments where every line starts with a *), which Prettier can fix the indentation of.
Then there‚Äôs the question of where to put the comments. Turns out this is a really difficult problem. Prettier tries its best to keep your comments roughly where they were, but it‚Äôs no easy task because comments can be placed almost anywhere.
Generally, you get the best results when placing comments on their own lines, instead of at the end of lines. Prefer // eslint-disable-next-line over // eslint-disable-line.
Note that ‚Äúmagic comments‚Äù such as eslint-disable-next-line and $FlowFixMe might sometimes need to be manually moved due to Prettier breaking an expression into multiple lines.
Imagine this piece of code:
// eslint-disable-next-line no-evalconst result = safeToEval ? eval(input) : fallback(input);
Then you need to add another condition:
// eslint-disable-next-line no-evalconst result = safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);
Prettier will turn the above into:
// eslint-disable-next-line no-evalconst result =  safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);
Which means that the eslint-disable-next-line comment is no longer effective. In this case you need to move the comment:
const result =  // eslint-disable-next-line no-eval  safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);
If possible, prefer comments that operate on line ranges (e.g. eslint-disable and eslint-enable) or on the statement level (e.g. /* istanbul ignore next */), they are even safer. It‚Äôs possible to disallow using eslint-disable-line and eslint-disable-next-line comments using eslint-plugin-eslint-comments.
Disclaimer about non-standard syntax‚Äã
Prettier is often able to recognize and format non-standard syntax such as ECMAScript early-stage proposals and Markdown syntax extensions not defined by any specification. The support for such syntax is considered best-effort and experimental. Incompatibilities may be introduced in any release and should not be viewed as breaking changes.
Disclaimer about machine-generated files‚Äã
Some files, like package.json or composer.lock, are machine-generated and regularly updated by the package manager. If Prettier were to use the same JSON formatting rules as with other files, it would regularly conflict with these other tools. To avoid this inconvenience, Prettier will use a formatter based on JSON.stringify on such files instead. You may notice these differences, such as the removal of vertical whitespace, but this is an intended behavior.
What Prettier is not concerned about‚Äã
Prettier only prints code. It does not transform it. This is to limit the scope of Prettier. Let‚Äôs focus on the printing and do it really well!
Here are a few examples of things that are out of scope for Prettier:

Turning single- or double-quoted strings into template literals or vice versa.
Using + to break long string literals into parts that fit the print width.
Adding/removing {} and return where they are optional.
Turning ?: into if-else statements.
Sorting/moving imports, object keys, class members, JSX keys, CSS properties or anything else. Apart from being a transform rather than just printing (as mentioned above), sorting is potentially unsafe because of side effects (for imports, as an example) and makes it difficult to verify the most important correctness goal.
Edit this page\n\nThis is unreleased documentation for Prettier next version.For up-to-date documentation, see the latest version (stable).On this pageRationalePrettier is an opinionated code formatter. This document explains some of its choices.
What Prettier is concerned about‚Äã
Correctness‚Äã
The first requirement of Prettier is to output valid code that has the exact same behavior as before formatting. Please report any code where Prettier fails to follow these correctness rules ‚Äî that‚Äôs a bug which needs to be fixed!
Strings‚Äã
Double or single quotes? Prettier chooses the one which results in the fewest number of escapes. "It's gettin' better!", not 'It\'s gettin\' better!'. In case of a tie or the string not containing any quotes, Prettier defaults to double quotes (but that can be changed via the singleQuote option).
JSX has its own option for quotes: jsxSingleQuote.
JSX takes its roots from HTML, where the dominant use of quotes for attributes is double quotes. Browser developer tools also follow this convention by always displaying HTML with double quotes, even if the source code uses single quotes. A separate option allows using single quotes for JS and double quotes for "HTML" (JSX).
Prettier maintains the way your string is escaped. For example, "üôÇ" won‚Äôt be formatted into "\uD83D\uDE42" and vice versa.
Empty lines‚Äã
It turns out that empty lines are very hard to automatically generate. The approach that Prettier takes is to preserve empty lines the way they were in the original source code. There are two additional rules:

Prettier collapses multiple blank lines into a single blank line.
Empty lines at the start and end of blocks (and whole files) are removed. (Files always end with a single newline, though.)

Multi-line objects‚Äã
By default, Prettier‚Äôs printing algorithm prints expressions on a single line if they fit. Objects are used for a lot of different things in JavaScript, though, and sometimes it really helps readability if they stay multiline. See object lists, nested configs, stylesheets and keyed methods, for example. We haven‚Äôt been able to find a good rule for all those cases, so by default Prettier keeps objects multi-line if there‚Äôs a newline between the { and the first key in the original source code. Consequently, long single-line objects are automatically expanded, but short multi-line objects are never collapsed.
You can disable this conditional behavior with the objectWrap option.
Tip: If you have a multi-line object that you‚Äôd like to join up into a single line:
const user = {  name: "John Doe",  age: 30,};
‚Ä¶all you need to do is remove the newline after {:
const user = {  name: "John Doe",  age: 30};
‚Ä¶and then run Prettier:
const user = { name: "John Doe", age: 30 };
And if you‚Äôd like to go multi-line again, add in a newline after {:
const user = { name: "John Doe", age: 30 };
‚Ä¶and run Prettier:
const user = {  name: "John Doe",  age: 30,};
A note on formatting reversibilityThe semi-manual formatting for object literals is in fact a workaround, not a feature. It was implemented only because at the time a good heuristic wasn‚Äôt found and an urgent fix was needed. However, as a general strategy, Prettier avoids non-reversible formatting like that, so the team is still looking for heuristics that would allow either to remove this behavior completely or at least to reduce the number of situations where it‚Äôs applied.What does reversible mean? Once an object literal becomes multiline, Prettier won‚Äôt collapse it back. If in Prettier-formatted code, we add a property to an object literal, run Prettier, then change our mind, remove the added property, and then run Prettier again, we might end up with a formatting not identical to the initial one. This useless change might even get included in a commit, which is exactly the kind of situation Prettier was created to prevent.
Decorators‚Äã
Just like with objects, decorators are used for a lot of different things. Sometimes it makes sense to write decorators above the line they're decorating, sometimes it‚Äôs nicer if they're on the same line. We haven‚Äôt been able to find a good rule for this, so Prettier keeps your decorator positioned like you wrote them (if they fit on the line). This isn‚Äôt ideal, but a pragmatic solution to a difficult problem.
@Component({  selector: "hero-button",  template: `<button>{{ label }}</button>`,})class HeroButtonComponent {  // These decorators were written inline and fit on the line so they stay  // inline.  @Output() change = new EventEmitter();  @Input() label: string;  // These were written multiline, so they stay multiline.  @readonly  @nonenumerable  NODE_TYPE: 2;}
There‚Äôs one exception: classes. We don‚Äôt think it ever makes sense to inline the decorators for them, so they are always moved to their own line.
// Before running Prettier:@observer class OrderLine {  @observable price: number = 0;}
// After running Prettier:@observerclass OrderLine {  @observable price: number = 0;}
Note: Prettier 1.14.x and older tried to automatically move your decorators, so if you've run an older Prettier version on your code you might need to manually join up some decorators here and there to avoid inconsistencies:
@observerclass OrderLine {  @observable price: number = 0;  @observable  amount: number = 0;}
One final thing: TC39 has not yet decided if decorators come before or after export. In the meantime, Prettier supports both:
@decorator export class Foo {}export @decorator class Foo {}
Template literals‚Äã
Template literals can contain interpolations. Deciding whether it's appropriate to insert a linebreak within an interpolation unfortunately depends on the semantic content of the template - for example, introducing a linebreak in the middle of a natural-language sentence is usually undesirable. Since Prettier doesn't have enough information to make this decision itself, it uses a heuristic similar to that used for objects: it will only split an interpolation expression across multiple lines if there was already a linebreak within that interpolation.
This means that a literal like the following will not be broken onto multiple lines, even if it exceeds the print width:
`this is a long message which contains an interpolation: ${format(data)} <- like this`;
If you want Prettier to split up an interpolation, you'll need to ensure there's a linebreak somewhere within the ${...}. Otherwise it will keep everything on a single line, no matter how long it is.
The team would prefer not to depend on the original formatting in this way, but it's the best heuristic we have at the moment.
Semicolons‚Äã
This is about using the noSemi option.
Consider this piece of code:
if (shouldAddLines) {  [-1, 1].forEach(delta => addLine(delta * 20))}
While the above code works just fine without semicolons, Prettier actually turns it into:
if (shouldAddLines) {  ;[-1, 1].forEach(delta => addLine(delta * 20))}
This is to help you avoid mistakes. Imagine Prettier not inserting that semicolon and adding this line:
 if (shouldAddLines) {+  console.log('Do we even get here??')   [-1, 1].forEach(delta => addLine(delta * 20)) }
Oops! The above actually means:
if (shouldAddLines) {  console.log('Do we even get here??')[-1, 1].forEach(delta => addLine(delta * 20))}
With a semicolon in front of that [ such issues never happen. It makes the line independent of other lines so you can move and add lines without having to think about ASI rules.
This practice is also common in standard which uses a semicolon-free style.
Note that if your program currently has a semicolon-related bug in it, Prettier will not auto-fix the bug for you. Remember, Prettier only reformats code, it does not change the behavior of the code. Take this buggy piece of code as an example, where the developer forgot to place a semicolon before the (:
console.log('Running a background task')(async () => {  await doBackgroundWork()})()
If you feed this into Prettier, it will not alter the behavior of this code, instead, it will reformat it in a way that shows how this code will actually behave when ran.
console.log("Running a background task")(async () => {  await doBackgroundWork();})();
Print width‚Äã
The printWidth option is more of a guideline to Prettier than a hard rule. It is not the upper allowed line length limit. It is a way to say to Prettier roughly how long you‚Äôd like lines to be. Prettier will make both shorter and longer lines, but generally strive to meet the specified print width.
There are some edge cases, such as really long string literals, regexps, comments and variable names, which cannot be broken across lines (without using code transforms which Prettier doesn‚Äôt do). Or if you nest your code 50 levels deep your lines are of course going to be mostly indentation :)
Apart from that, there are a few cases where Prettier intentionally exceeds the print width.
Imports‚Äã
Prettier can break long import statements across several lines:
import {  CollectionDashboard,  DashboardPlaceholder,} from "../components/collections/collection-dashboard/main";
The following example doesn‚Äôt fit within the print width, but Prettier prints it in a single line anyway:
import { CollectionDashboard } from "../components/collections/collection-dashboard/main";
This might be unexpected by some, but we do it this way since it was a common request to keep imports with single elements in a single line. The same applies for require calls.
Testing functions‚Äã
Another common request was to keep lengthy test descriptions in one line, even if it gets too long. In such cases, wrapping the arguments to new lines doesn‚Äôt help much.
describe("NodeRegistry", () => {  it("makes no request if there are no nodes to prefetch, even if the cache is stale", async () => {    // The above line exceeds the print width but stayed on one line anyway.  });});
Prettier has special cases for common testing framework functions such as describe, it and test.
JSX‚Äã
Prettier prints things a little differently compared to other JS when JSX is involved:
function greet(user) {  return user    ? `Welcome back, ${user.name}!`    : "Greetings, traveler! Sign up today!";}function Greet({ user }) {  return (    <div>      {user ? (        <p>Welcome back, {user.name}!</p>      ) : (        <p>Greetings, traveler! Sign up today!</p>      )}    </div>  );}
There are two reasons.
First off, lots of people already wrapped their JSX in parentheses, especially in return statements. Prettier follows this common style.
Secondly, the alternate formatting makes it easier to edit the JSX. It is easy to leave a semicolon behind. As opposed to normal JS, a leftover semicolon in JSX can end up as plain text showing on your page.
<div>  <p>Greetings, traveler! Sign up today!</p>; {/* <-- Oops! */}</div>
Comments‚Äã
When it comes to the content of comments, Prettier can‚Äôt do much really. Comments can contain everything from prose to commented out code and ASCII diagrams. Since they can contain anything, Prettier can‚Äôt know how to format or wrap them. So they are left as-is. The only exception to this are JSDoc-style comments (block comments where every line starts with a *), which Prettier can fix the indentation of.
Then there‚Äôs the question of where to put the comments. Turns out this is a really difficult problem. Prettier tries its best to keep your comments roughly where they were, but it‚Äôs no easy task because comments can be placed almost anywhere.
Generally, you get the best results when placing comments on their own lines, instead of at the end of lines. Prefer // eslint-disable-next-line over // eslint-disable-line.
Note that ‚Äúmagic comments‚Äù such as eslint-disable-next-line and $FlowFixMe might sometimes need to be manually moved due to Prettier breaking an expression into multiple lines.
Imagine this piece of code:
// eslint-disable-next-line no-evalconst result = safeToEval ? eval(input) : fallback(input);
Then you need to add another condition:
// eslint-disable-next-line no-evalconst result = safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);
Prettier will turn the above into:
// eslint-disable-next-line no-evalconst result =  safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);
Which means that the eslint-disable-next-line comment is no longer effective. In this case you need to move the comment:
const result =  // eslint-disable-next-line no-eval  safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);
If possible, prefer comments that operate on line ranges (e.g. eslint-disable and eslint-enable) or on the statement level (e.g. /* istanbul ignore next */), they are even safer. It‚Äôs possible to disallow using eslint-disable-line and eslint-disable-next-line comments using eslint-plugin-eslint-comments.
Disclaimer about non-standard syntax‚Äã
Prettier is often able to recognize and format non-standard syntax such as ECMAScript early-stage proposals and Markdown syntax extensions not defined by any specification. The support for such syntax is considered best-effort and experimental. Incompatibilities may be introduced in any release and should not be viewed as breaking changes.
Disclaimer about machine-generated files‚Äã
Some files, like package.json or composer.lock, are machine-generated and regularly updated by the package manager. If Prettier were to use the same JSON formatting rules as with other files, it would regularly conflict with these other tools. To avoid this inconvenience, Prettier will use a formatter based on JSON.stringify on such files instead. You may notice these differences, such as the removal of vertical whitespace, but this is an intended behavior.
What Prettier is not concerned about‚Äã
Prettier only prints code. It does not transform it. This is to limit the scope of Prettier. Let‚Äôs focus on the printing and do it really well!
Here are a few examples of things that are out of scope for Prettier:

Turning single- or double-quoted strings into template literals or vice versa.
Using + to break long string literals into parts that fit the print width.
Adding/removing {} and return where they are optional.
Turning ?: into if-else statements.
Sorting/moving imports, object keys, class members, JSX keys, CSS properties or anything else. Apart from being a transform rather than just printing (as mentioned above), sorting is potentially unsafe because of side effects (for imports, as an example) and makes it difficult to verify the most important correctness goal.
Edit this pagePreviousOption PhilosophyNextInstallWhat Prettier is concerned aboutCorrectnessStringsEmpty linesMulti-line objectsDecoratorsTemplate literalsSemicolonsPrint widthJSXCommentsDisclaimer about non-standard syntaxDisclaimer about machine-generated filesWhat Prettier is not concerned about\n\n\n\nPrettier 3.5: New objectWrap option, experimentalOperatorPosition option and TS config file support!February 9, 2025 ¬∑ 9 min readSosuke SuzukiThis release includes a lot of bug fixes and the following new features:

Support for the new objectWrap option
Support for the new experimental experimentalOperatorPosition option
Support for TypeScript configuration file

See each section for details.Read morePrettier 3.4: A lot of bug fixesNovember 26, 2024 ¬∑ 19 min readSosuke SuzukiThis release includes numerous bug fixes and other improvements.
If you appreciate Prettier and would like to support our work, please consider sponsoring us directly via our OpenCollective or by sponsoring the projects we depend on, such as typescript-eslint, remark, and Babel. Thank you for your continued support!Read morePrettier 3.3: New Flow features and a lot of bug fixesJune 1, 2024 ¬∑ 7 min readSosuke SuzukiThis release includes support for new Flow features such as component and hook declarations. All of these features were implemented by the engineers on the Flow team, thank you.
If you appreciate Prettier and would like to support our work, please consider sponsoring us directly via our OpenCollective or by sponsoring the projects we depend on, such as typescript-eslint, remark, and Babel. Thank you for your continued support!Read morePrettier 3.2: Support JSONC and Angular‚Äôs ICU expressionJanuary 12, 2024 ¬∑ 6 min readSosuke SuzukiThis release includes new features such as adding a JSONC parser, adding Angular‚Äôs ICU expressions, and many bug fixes.
We are still seeking feedback for the --experimental-ternaries option released in Prettier 3.1. Please read A curious case of the ternaries and respond via the Google Forms link provided.
Additionally, we recommend reading Prettier's CLI: A Performance Deep Dive by Fabio Spampinato. This faster CLI is slated to be released as version 4.0.Read morePrettier's CLI: A Performance Deep DiveNovember 30, 2023 ¬∑ 24 min readFabio SpampinatoHey, I'm Fabio and I've been contracted by the Prettier team to speed up Prettier's command line interface (CLI). In this post we'll take a look at the optimizations I've discovered, the process that lead to finding them, some exciting numbers comparing the current CLI with the new one, and some guesses about what could be optimized next.Read more$20k Bounty was Claimed!November 27, 2023 ¬∑ 4 min readChristopher ChedeauPrettier, a JavaScript code formatter, has seen an incredible adoption thanks to its careful handling of the very, very, long tail of ways people can write code. At this point, the formatting logic has been solid and after our work on ternaries lands, it will be in a happy state.
This means that we can now focus on the next important aspect: Performance. Prettier has never been fast per se, but fast enough for most use cases. This has always felt unsatisfying so we wanted to do something about it. What better way than a friendly competition.
On November 9th, we put up a $10k bounty for any project written in Rust that would pass 95% of Prettier test suite. Guillermo Rauch, CEO of Vercel, matched it to bring it to $20k and napi.rs added another $2.5k. The folks at Algora even made an amazing landing page for it.
Read morePrettier 3.1: New experimental ternaries formatting and Angular control flow syntax!November 13, 2023 ¬∑ 12 min readSosuke SuzukiThis release adds indentation back to nested ternaries along with a new --experimental-ternaries flag to try a more novel "curious ternary" format that scales better to deeply nested conditionals. We are keen for your feedback on the experimental format before it rolls out as the default behavior later this year!
We have also added support for the control flow syntax in Angular v17. For details on the syntax, please read the official Angular release post.Read moreA curious case of the ternariesNovember 13, 2023 ¬∑ 6 min readAlex RattrayTernary formatting has always been a challenge, and we're finally addressing it in v3.1.0 with the introduction of a novel formatting style.
Read on for our journey and the motivation behind this change, along with early developer feedback and an overview of the "curious ternaries" style.
Please give the --experimental-ternaries option a try and let us know what you think!
For a quick tl;dr, see the release post.Read morePrettier 3.0: Hello, ECMAScript Modules!July 5, 2023 ¬∑ 36 min readSosuke SuzukiWe are excited to announce the release of the new version of Prettier!
We have made the migration to using ECMAScript Modules for all our source code. This change has significantly improved the development experience for the Prettier team. Please rest assured that when using Prettier as a library, you can still use it as CommonJS as well.
This update comes with several breaking changes. One notable example is the alteration in markdown formatting - spaces are no longer inserted between Latin characters and Chinese or Japanese characters. We'd like to extend our gratitude to Tatsunori Uchino, who has made significant contributions to Prettier over the past year, particularly with this feature. Additionally, the default value of trailingComma has been changed to "all".
Another important change in this release is the significant overhaul of the plugin interface. Prettier now supports plugins written using ECMAScript Modules and async parsers. If you're a plugin developer, please exercise caution while updating. You can find the migration guide here. As always, we welcome bug reports and feedback!
This release also includes numerous formatting improvements and bug fixes.
If you appreciate Prettier and would like to support our work, please consider sponsoring us directly via our OpenCollective or by sponsoring the projects we depend on, such as typescript-eslint, remark, and Babel. Thank you for your continued support!Read morePrettier 2.8: improve --cache CLI option and TypeScript 4.9 satisfies operator!November 23, 2022 ¬∑ 7 min readSosuke SuzukiThis release includes improvements to the --cache option added in 2.7. A new --cache-location option has been added, and a bug that saved the cache even when --write wasn't specified has been fixed.
We're also adding support for TypeScript 4.9 satisfies operator!
If you enjoy Prettier and would like to support our work, consider sponsoring us directly via our OpenCollective or by sponsoring the projects we depend on, including typescript-eslint, remark, and Babel.
The Prettier team plans to release 3.0 within the next few months. If you are a plugin developer, get ready for the migration. Visit the migration guide and issue #13606 for more information.Read more\n\nPrettier 3.5: New objectWrap option, experimentalOperatorPosition option and TS config file support!February 9, 2025 ¬∑ 9 min readSosuke SuzukiThis release includes a lot of bug fixes and the following new features:

Support for the new objectWrap option
Support for the new experimental experimentalOperatorPosition option
Support for TypeScript configuration file

See each section for details.Read morePrettier 3.4: A lot of bug fixesNovember 26, 2024 ¬∑ 19 min readSosuke SuzukiThis release includes numerous bug fixes and other improvements.
If you appreciate Prettier and would like to support our work, please consider sponsoring us directly via our OpenCollective or by sponsoring the projects we depend on, such as typescript-eslint, remark, and Babel. Thank you for your continued support!Read morePrettier 3.3: New Flow features and a lot of bug fixesJune 1, 2024 ¬∑ 7 min readSosuke SuzukiThis release includes support for new Flow features such as component and hook declarations. All of these features were implemented by the engineers on the Flow team, thank you.
If you appreciate Prettier and would like to support our work, please consider sponsoring us directly via our OpenCollective or by sponsoring the projects we depend on, such as typescript-eslint, remark, and Babel. Thank you for your continued support!Read morePrettier 3.2: Support JSONC and Angular‚Äôs ICU expressionJanuary 12, 2024 ¬∑ 6 min readSosuke SuzukiThis release includes new features such as adding a JSONC parser, adding Angular‚Äôs ICU expressions, and many bug fixes.
We are still seeking feedback for the --experimental-ternaries option released in Prettier 3.1. Please read A curious case of the ternaries and respond via the Google Forms link provided.
Additionally, we recommend reading Prettier's CLI: A Performance Deep Dive by Fabio Spampinato. This faster CLI is slated to be released as version 4.0.Read morePrettier's CLI: A Performance Deep DiveNovember 30, 2023 ¬∑ 24 min readFabio SpampinatoHey, I'm Fabio and I've been contracted by the Prettier team to speed up Prettier's command line interface (CLI). In this post we'll take a look at the optimizations I've discovered, the process that lead to finding them, some exciting numbers comparing the current CLI with the new one, and some guesses about what could be optimized next.Read more$20k Bounty was Claimed!November 27, 2023 ¬∑ 4 min readChristopher ChedeauPrettier, a JavaScript code formatter, has seen an incredible adoption thanks to its careful handling of the very, very, long tail of ways people can write code. At this point, the formatting logic has been solid and after our work on ternaries lands, it will be in a happy state.
This means that we can now focus on the next important aspect: Performance. Prettier has never been fast per se, but fast enough for most use cases. This has always felt unsatisfying so we wanted to do something about it. What better way than a friendly competition.
On November 9th, we put up a $10k bounty for any project written in Rust that would pass 95% of Prettier test suite. Guillermo Rauch, CEO of Vercel, matched it to bring it to $20k and napi.rs added another $2.5k. The folks at Algora even made an amazing landing page for it.
Read morePrettier 3.1: New experimental ternaries formatting and Angular control flow syntax!November 13, 2023 ¬∑ 12 min readSosuke SuzukiThis release adds indentation back to nested ternaries along with a new --experimental-ternaries flag to try a more novel "curious ternary" format that scales better to deeply nested conditionals. We are keen for your feedback on the experimental format before it rolls out as the default behavior later this year!
We have also added support for the control flow syntax in Angular v17. For details on the syntax, please read the official Angular release post.Read moreA curious case of the ternariesNovember 13, 2023 ¬∑ 6 min readAlex RattrayTernary formatting has always been a challenge, and we're finally addressing it in v3.1.0 with the introduction of a novel formatting style.
Read on for our journey and the motivation behind this change, along with early developer feedback and an overview of the "curious ternaries" style.
Please give the --experimental-ternaries option a try and let us know what you think!
For a quick tl;dr, see the release post.Read morePrettier 3.0: Hello, ECMAScript Modules!July 5, 2023 ¬∑ 36 min readSosuke SuzukiWe are excited to announce the release of the new version of Prettier!
We have made the migration to using ECMAScript Modules for all our source code. This change has significantly improved the development experience for the Prettier team. Please rest assured that when using Prettier as a library, you can still use it as CommonJS as well.
This update comes with several breaking changes. One notable example is the alteration in markdown formatting - spaces are no longer inserted between Latin characters and Chinese or Japanese characters. We'd like to extend our gratitude to Tatsunori Uchino, who has made significant contributions to Prettier over the past year, particularly with this feature. Additionally, the default value of trailingComma has been changed to "all".
Another important change in this release is the significant overhaul of the plugin interface. Prettier now supports plugins written using ECMAScript Modules and async parsers. If you're a plugin developer, please exercise caution while updating. You can find the migration guide here. As always, we welcome bug reports and feedback!
This release also includes numerous formatting improvements and bug fixes.
If you appreciate Prettier and would like to support our work, please consider sponsoring us directly via our OpenCollective or by sponsoring the projects we depend on, such as typescript-eslint, remark, and Babel. Thank you for your continued support!Read morePrettier 2.8: improve --cache CLI option and TypeScript 4.9 satisfies operator!November 23, 2022 ¬∑ 7 min readSosuke SuzukiThis release includes improvements to the --cache option added in 2.7. A new --cache-location option has been added, and a bug that saved the cache even when --write wasn't specified has been fixed.
We're also adding support for TypeScript 4.9 satisfies operator!
If you enjoy Prettier and would like to support our work, consider sponsoring us directly via our OpenCollective or by sponsoring the projects we depend on, including typescript-eslint, remark, and Babel.
The Prettier team plans to release 3.0 within the next few months. If you are a plugin developer, get ready for the migration. Visit the migration guide and issue #13606 for more information.Read moreOlder entries\n\n\n\nPrettier 3.5: New objectWrap option, experimentalOperatorPosition option and TS config file support!February 9, 2025 ¬∑ 9 min readSosuke SuzukiThis release includes a lot of bug fixes and the following new features:

Support for the new objectWrap option
Support for the new experimental experimentalOperatorPosition option
Support for TypeScript configuration file

See each section for details.
If you appreciate Prettier and would like to support our work, please consider sponsoring us directly via our OpenCollective or by sponsoring the projects we depend on, such as typescript-eslint, remark, and Babel. Thank you for your continued support!
Why We Added Two New Options‚Äã
This release introduces two new options. If you‚Äôre familiar with Prettier‚Äôs Option Philosophy, you might be wondering: ‚ÄúWhy add new options?‚Äù Rest assured, these aren‚Äôt your typical options, nor do they violate our option philosophy.
As the name suggests, experimentalOperatorPosition is experimental. We have a policy for experimental options, which means it will eventually be removed. In the future, the new behavior could become the default, or this option might be dropped entirely. If you‚Äôve been following Prettier for a while, you may recall we once added an experimentalTernaries option, and this follows the same approach.
objectWrap is a bit special. For a long time, we‚Äôve struggled with how to print multi-line objects. We haven‚Äôt yet found the perfect solution, so we‚Äôve resorted to a semi-manual approach. For more details, see our Rationale. The current behavior isn‚Äôt ideal because the final output can vary based on how the user writes their code. To provide a more consistent format, we‚Äôve decided to introduce the objectWrap option.
Although this release includes two new options, we want to emphasize that we haven‚Äôt forgotten Prettier‚Äôs option philosophy. These options address specific, long-standing formatting challenges without compromising our option philosophy.
Highlights‚Äã
JavaScript‚Äã
Add experimental option for breaking lines before binary operators (#7111 by @btmills)‚Äã
This is implemented behind the --experimental-operator-position <start|end> flag.
When binary expressions wrap lines, start prints the operators at the start of new lines. Placing binary operators at the beginning of wrapped lines can make the operators more prominent and easier to scan.
// Inputvar a = Math.random() * (yRange * (1 - minVerticalFraction)) + minVerticalFraction * yRange - offset;// `experimentalOperatorPosition: end` (default behavior)var a =  Math.random() * (yRange * (1 - minVerticalFraction)) +  minVerticalFraction * yRange -  offset;// `experimentalOperatorPosition: start`var a =  Math.random() * (yRange * (1 - minVerticalFraction))  + minVerticalFraction * yRange  - offset;
Implement objectWrap config option (#16163 by @pauldraper, @sosukesuzuki)‚Äã
Prettier has historically done semi-manual formatting of multi-line JavaScript object literals.
Namely, an object is kept on multiple lines if there is a newline prior to the first property, even if it could fit on a single line. See Multi-line objects for more details.
While this behavior continues to be the default, --object-wrap=collapse instead ignores whitespace when formatting object literals.
// Inputconst obj1 = {  name1: "value1", name2: "value2",};const obj2 = { name1: "value1",  name2: "value2",};// Prettier 3.4const obj1 = {  name1: "value1",  name2: "value2",};const obj2 = { name1: "value1", name2: "value2" };// Prettier 3.5 (with `--object-wrapping=collapse`)const obj1 = { name1: "value1", name2: "value2" };const obj2 = { name1: "value1", name2: "value2" };
API‚Äã
Add support for TypeScript config files (#16828 by @itsyoboieltr & @fisker)‚Äã
Added new format of configuration files:

.prettierrc.ts
.prettierrc.mts
.prettierrc.cts
prettier.config.ts
prettier.config.mts
prettier.config.cts

Note:
Currently TypeScript support in Node.js is experimental.
To make TypeScript config files work, Node.js>=22.6.0 is required and Node.js v22 requires --experimental-strip-types.
You can run prettier with
node --experimental-strip-types node_modules/prettier/bin/prettier.cjs . --write
or
NODE_OPTIONS="--experimental-strip-types" prettier . --write
Other TS loaders should also work, but not tested, use at your own risk.
For example, with tsx, you can
node --import tsx node_modules/prettier/bin/prettier.cjs . --write
or
tsx node_modules/prettier/bin/prettier.cjs . --write
Other Changes‚Äã
JavaScript‚Äã
Improve word wrapping edge cases in JSX (#16700 by @seiyab)‚Äã
// Inputbr_triggers_expression_break =  <div><br />  text text text text text text text text text text text {this.props.type} </div>// Prettier 3.4br_triggers_expression_break = (  <div>    <br />    text text text text text text text text text text text {      this.props.type    }{" "}  </div>);// Prettier 3.5br_triggers_expression_break = (  <div>    <br />    text text text text text text text text text text text{" "}    {this.props.type}{" "}  </div>);
Flow‚Äã
Support const type parameters in Flow (#16947 by @gkz)‚Äã
function f<const T>(): void {}// Prettier 3.4// Parse error// Prettier 3.5function f<const T>(): void {}
CSS‚Äã
Break before breaking comma separated values (#16907 by @seiyab)‚Äã
/* Input */a {  background-image:    linear-gradient(to bottom, rgb(255 255 0 / 50%), rgb(0 0 255 / 50%)),    url("catfront.png");}/* Prettier 3.4 */a {  background-image: linear-gradient(      to bottom,      rgb(255 255 0 / 50%),      rgb(0 0 255 / 50%)    ),    url("catfront.png");}/* Prettier 3.5 */a {  background-image:    linear-gradient(to bottom, rgb(255 255 0 / 50%), rgb(0 0 255 / 50%)),    url("catfront.png");}
Vue‚Äã
Support .prop shorthand (#16920 by @fisker)‚Äã
.foo is shorthand for v-bind:foo.prop. See v-bind builtin directive for details.
<!-- Input --><template>  <button .disabled="   a &&b ">Click!</button></template><!-- Prettier 3.4 --><template>  <button .disabled="   a &&b ">Click!</button></template><!-- Prettier 3.5 --><template>  <button .disabled="a && b">Click!</button></template>
Angular‚Äã
Improve line breaks inside ICU blocks (#16922 by @fisker)‚Äã
<!-- Input --><span>The author is {gender, select, male {male} female {female} other {other}}</span><span>The author is <span>male consectetur adipiscing elit, sed do eiusmod</span></span><!-- Prettier 3.4 --><span  >The author is {gender, select, male {male} female {female} other {other}}</span><span  >The author is  <span>male consectetur adipiscing elit, sed do eiusmod</span></span><!-- Prettier 3.5 --><span  >The author is  {gender, select, male {male} female {female} other {other}}</span><span  >The author is  <span>male consectetur adipiscing elit, sed do eiusmod</span></span>
Fix extra new line inside ICU blocks (#16922 by @fisker)‚Äã
<!-- Input -->{active, select,  true {    Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod temp  }  false {    Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod temp  }}<!-- Prettier 3.4 -->{active, select,  true {    Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod temp  }  false {    Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod temp  }}<!-- Prettier 3.5 -->{active, select,  true {    Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod temp  }  false {    Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod temp  }}
Ember / Handlebars‚Äã
Handle <style> and <pre> tags in Handlebars/Glimmer (#15087 by @jurgenwerk)‚Äã
{{!-- Input --}}<pre>  cd ~  ls  echo "hey"</pre><style>  .red { color: red }  .blue {    color: red  }</style>{{!-- Prettier 3.4 --}}<pre>  cd ~ ls echo "hey"</pre><style>  .red { color: red } .blue { color: blue }</style>{{!-- Prettier 3.5 --}}<pre>  cd ~  ls  echo "hey"</pre><style>  .red {    color: red;  }  .blue {    color: red;  }</style>
Markdown‚Äã
U+FF5E as CJK punctuation (#16832 by @tats-u)‚Äã
U+FF5E FULLWIDTH TILDE (ÔΩû) is commonly used as a substitute for U+301C WAVE DASH („Äú) in Windows for Japanese. Full width alphabets are less used in Markdown documents comparing to other types of documents (e.g. Microsoft Office documents), and the full width tilde is much less used as this purpose compared to full width alphabets and digits. Therefore, we can assume that the full width tilde in Markdown documents in the wild are a alternative form of the wave dash and a part of CJK punctuation.
<!-- Input (--prose-wrap=never) -->a Â≠ó a Â≠ó a Â≠ó60ÔΩû100ÁÇπ60„Äú100ÁÇπ<!-- Prettier 3.4 -->a Â≠ó a Â≠ó a Â≠ó 60ÔΩû 100ÁÇπ 60„Äú10ÁÇπ<!-- Prettier 3.5 -->a Â≠ó a Â≠ó a Â≠ó 60ÔΩû10ÁÇπ 60„Äú100ÁÇπ
The first symbol between 60 and 100 in the above example is U+FF5E FULLWIDTH TILDE (ÔΩû) and the second one is U+301C WAVE DASH („Äú).
API‚Äã
Support read config from package.json with JSONC syntax on Bun (#17041 by @fisker)‚Äã
Bun 1.2 added JSONC support in package.json, in previous version of Prettier, it will ignore prettier config in it. Since Prettier 3.5, we can read prettier config from it without error.
However, since it's just a Bun feature and not supported by Node.js, it can only work when running Prettier with Bun.
Important note: Prettier uses json-stringify parser to format package.json file by default, to support formatting package.json file with JSONC syntax, you need override the parser option
export default {  overrides: [    {      files: ["package.json"],      options: {        parser: "jsonc",      },    },  ],};
If you can't upgrade Prettier for some reason, you can still use JSONC syntax in package.json, but don't put your prettier config in it, you'll have to use another configuration file.
Miscellaneous‚Äã
Use ESM entrypoint for require(ESM) (#16958 by @tats-u)‚Äã
infoThis change has been reverted in v3.5.2, check #17139 for details.
Node.js 22.12 or later can (experimentally) load ESM modules with require function without runtime flags. This change enables require to load Prettier without the CommonJS entrypoint with almost only the ability to import the ESM entrypoint.
The feature to load ES modules with require is not completely stable but can be used without ExperimentalWarning as of Node 22.13.Edit this page\n\nPrettier 3.5: New objectWrap option, experimentalOperatorPosition option and TS config file support!February 9, 2025 ¬∑ 9 min readSosuke SuzukiThis release includes a lot of bug fixes and the following new features:

Support for the new objectWrap option
Support for the new experimental experimentalOperatorPosition option
Support for TypeScript configuration file

See each section for details.
If you appreciate Prettier and would like to support our work, please consider sponsoring us directly via our OpenCollective or by sponsoring the projects we depend on, such as typescript-eslint, remark, and Babel. Thank you for your continued support!
Why We Added Two New Options‚Äã
This release introduces two new options. If you‚Äôre familiar with Prettier‚Äôs Option Philosophy, you might be wondering: ‚ÄúWhy add new options?‚Äù Rest assured, these aren‚Äôt your typical options, nor do they violate our option philosophy.
As the name suggests, experimentalOperatorPosition is experimental. We have a policy for experimental options, which means it will eventually be removed. In the future, the new behavior could become the default, or this option might be dropped entirely. If you‚Äôve been following Prettier for a while, you may recall we once added an experimentalTernaries option, and this follows the same approach.
objectWrap is a bit special. For a long time, we‚Äôve struggled with how to print multi-line objects. We haven‚Äôt yet found the perfect solution, so we‚Äôve resorted to a semi-manual approach. For more details, see our Rationale. The current behavior isn‚Äôt ideal because the final output can vary based on how the user writes their code. To provide a more consistent format, we‚Äôve decided to introduce the objectWrap option.
Although this release includes two new options, we want to emphasize that we haven‚Äôt forgotten Prettier‚Äôs option philosophy. These options address specific, long-standing formatting challenges without compromising our option philosophy.
Highlights‚Äã
JavaScript‚Äã
Add experimental option for breaking lines before binary operators (#7111 by @btmills)‚Äã
This is implemented behind the --experimental-operator-position <start|end> flag.
When binary expressions wrap lines, start prints the operators at the start of new lines. Placing binary operators at the beginning of wrapped lines can make the operators more prominent and easier to scan.
// Inputvar a = Math.random() * (yRange * (1 - minVerticalFraction)) + minVerticalFraction * yRange - offset;// `experimentalOperatorPosition: end` (default behavior)var a =  Math.random() * (yRange * (1 - minVerticalFraction)) +  minVerticalFraction * yRange -  offset;// `experimentalOperatorPosition: start`var a =  Math.random() * (yRange * (1 - minVerticalFraction))  + minVerticalFraction * yRange  - offset;
Implement objectWrap config option (#16163 by @pauldraper, @sosukesuzuki)‚Äã
Prettier has historically done semi-manual formatting of multi-line JavaScript object literals.
Namely, an object is kept on multiple lines if there is a newline prior to the first property, even if it could fit on a single line. See Multi-line objects for more details.
While this behavior continues to be the default, --object-wrap=collapse instead ignores whitespace when formatting object literals.
// Inputconst obj1 = {  name1: "value1", name2: "value2",};const obj2 = { name1: "value1",  name2: "value2",};// Prettier 3.4const obj1 = {  name1: "value1",  name2: "value2",};const obj2 = { name1: "value1", name2: "value2" };// Prettier 3.5 (with `--object-wrapping=collapse`)const obj1 = { name1: "value1", name2: "value2" };const obj2 = { name1: "value1", name2: "value2" };
API‚Äã
Add support for TypeScript config files (#16828 by @itsyoboieltr & @fisker)‚Äã
Added new format of configuration files:

.prettierrc.ts
.prettierrc.mts
.prettierrc.cts
prettier.config.ts
prettier.config.mts
prettier.config.cts

Note:
Currently TypeScript support in Node.js is experimental.
To make TypeScript config files work, Node.js>=22.6.0 is required and Node.js v22 requires --experimental-strip-types.
You can run prettier with
node --experimental-strip-types node_modules/prettier/bin/prettier.cjs . --write
or
NODE_OPTIONS="--experimental-strip-types" prettier . --write
Other TS loaders should also work, but not tested, use at your own risk.
For example, with tsx, you can
node --import tsx node_modules/prettier/bin/prettier.cjs . --write
or
tsx node_modules/prettier/bin/prettier.cjs . --write
Other Changes‚Äã
JavaScript‚Äã
Improve word wrapping edge cases in JSX (#16700 by @seiyab)‚Äã
// Inputbr_triggers_expression_break =  <div><br />  text text text text text text text text text text text {this.props.type} </div>// Prettier 3.4br_triggers_expression_break = (  <div>    <br />    text text text text text text text text text text text {      this.props.type    }{" "}  </div>);// Prettier 3.5br_triggers_expression_break = (  <div>    <br />    text text text text text text text text text text text{" "}    {this.props.type}{" "}  </div>);
Flow‚Äã
Support const type parameters in Flow (#16947 by @gkz)‚Äã
function f<const T>(): void {}// Prettier 3.4// Parse error// Prettier 3.5function f<const T>(): void {}
CSS‚Äã
Break before breaking comma separated values (#16907 by @seiyab)‚Äã
/* Input */a {  background-image:    linear-gradient(to bottom, rgb(255 255 0 / 50%), rgb(0 0 255 / 50%)),    url("catfront.png");}/* Prettier 3.4 */a {  background-image: linear-gradient(      to bottom,      rgb(255 255 0 / 50%),      rgb(0 0 255 / 50%)    ),    url("catfront.png");}/* Prettier 3.5 */a {  background-image:    linear-gradient(to bottom, rgb(255 255 0 / 50%), rgb(0 0 255 / 50%)),    url("catfront.png");}
Vue‚Äã
Support .prop shorthand (#16920 by @fisker)‚Äã
.foo is shorthand for v-bind:foo.prop. See v-bind builtin directive for details.
<!-- Input --><template>  <button .disabled="   a &&b ">Click!</button></template><!-- Prettier 3.4 --><template>  <button .disabled="   a &&b ">Click!</button></template><!-- Prettier 3.5 --><template>  <button .disabled="a && b">Click!</button></template>
Angular‚Äã
Improve line breaks inside ICU blocks (#16922 by @fisker)‚Äã
<!-- Input --><span>The author is {gender, select, male {male} female {female} other {other}}</span><span>The author is <span>male consectetur adipiscing elit, sed do eiusmod</span></span><!-- Prettier 3.4 --><span  >The author is {gender, select, male {male} female {female} other {other}}</span><span  >The author is  <span>male consectetur adipiscing elit, sed do eiusmod</span></span><!-- Prettier 3.5 --><span  >The author is  {gender, select, male {male} female {female} other {other}}</span><span  >The author is  <span>male consectetur adipiscing elit, sed do eiusmod</span></span>
Fix extra new line inside ICU blocks (#16922 by @fisker)‚Äã
<!-- Input -->{active, select,  true {    Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod temp  }  false {    Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod temp  }}<!-- Prettier 3.4 -->{active, select,  true {    Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod temp  }  false {    Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod temp  }}<!-- Prettier 3.5 -->{active, select,  true {    Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod temp  }  false {    Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod temp  }}
Ember / Handlebars‚Äã
Handle <style> and <pre> tags in Handlebars/Glimmer (#15087 by @jurgenwerk)‚Äã
{{!-- Input --}}<pre>  cd ~  ls  echo "hey"</pre><style>  .red { color: red }  .blue {    color: red  }</style>{{!-- Prettier 3.4 --}}<pre>  cd ~ ls echo "hey"</pre><style>  .red { color: red } .blue { color: blue }</style>{{!-- Prettier 3.5 --}}<pre>  cd ~  ls  echo "hey"</pre><style>  .red {    color: red;  }  .blue {    color: red;  }</style>
Markdown‚Äã
U+FF5E as CJK punctuation (#16832 by @tats-u)‚Äã
U+FF5E FULLWIDTH TILDE (ÔΩû) is commonly used as a substitute for U+301C WAVE DASH („Äú) in Windows for Japanese. Full width alphabets are less used in Markdown documents comparing to other types of documents (e.g. Microsoft Office documents), and the full width tilde is much less used as this purpose compared to full width alphabets and digits. Therefore, we can assume that the full width tilde in Markdown documents in the wild are a alternative form of the wave dash and a part of CJK punctuation.
<!-- Input (--prose-wrap=never) -->a Â≠ó a Â≠ó a Â≠ó60ÔΩû100ÁÇπ60„Äú100ÁÇπ<!-- Prettier 3.4 -->a Â≠ó a Â≠ó a Â≠ó 60ÔΩû 100ÁÇπ 60„Äú10ÁÇπ<!-- Prettier 3.5 -->a Â≠ó a Â≠ó a Â≠ó 60ÔΩû10ÁÇπ 60„Äú100ÁÇπ
The first symbol between 60 and 100 in the above example is U+FF5E FULLWIDTH TILDE (ÔΩû) and the second one is U+301C WAVE DASH („Äú).
API‚Äã
Support read config from package.json with JSONC syntax on Bun (#17041 by @fisker)‚Äã
Bun 1.2 added JSONC support in package.json, in previous version of Prettier, it will ignore prettier config in it. Since Prettier 3.5, we can read prettier config from it without error.
However, since it's just a Bun feature and not supported by Node.js, it can only work when running Prettier with Bun.
Important note: Prettier uses json-stringify parser to format package.json file by default, to support formatting package.json file with JSONC syntax, you need override the parser option
export default {  overrides: [    {      files: ["package.json"],      options: {        parser: "jsonc",      },    },  ],};
If you can't upgrade Prettier for some reason, you can still use JSONC syntax in package.json, but don't put your prettier config in it, you'll have to use another configuration file.
Miscellaneous‚Äã
Use ESM entrypoint for require(ESM) (#16958 by @tats-u)‚Äã
infoThis change has been reverted in v3.5.2, check #17139 for details.
Node.js 22.12 or later can (experimentally) load ESM modules with require function without runtime flags. This change enables require to load Prettier without the CommonJS entrypoint with almost only the ability to import the ESM entrypoint.
The feature to load ES modules with require is not completely stable but can be used without ExperimentalWarning as of Node 22.13.Edit this pageOlder postPrettier 3.4: A lot of bug fixes\n\n\n\nPrettier 3.4: A lot of bug fixesNovember 26, 2024 ¬∑ 19 min readSosuke SuzukiThis release includes numerous bug fixes and other improvements.
If you appreciate Prettier and would like to support our work, please consider sponsoring us directly via our OpenCollective or by sponsoring the projects we depend on, such as typescript-eslint, remark, and Babel. Thank you for your continued support!
Other Changes‚Äã
JavaScript‚Äã
Fix template literal print with array (#13315 by @fisker, @syi0808)‚Äã
// Inputconst string = `${[[1, 2], [3, 4]]}`// Prettier 3.3const string = `${[  [2],  [4],]}`;// Prettier 3.4const string = `${[  [1, 2],  [3, 4],]}`;
Add missing parentheses in tagged template literals (#16500 by @syi0808)‚Äã
// Input(String?.raw)``;(getTag?.())``;// Prettier 3.3String?.raw``;getTag?.()``;// Prettier 3.4(String?.raw)``;(getTag?.())``;
Don't remove useless \ in string literals (#16563 by @sosukesuzuki, #16763 by @fisker)‚Äã
Previously, Prettier would remove useless escape characters (\) from string literals. However, this behavior was inconsistent as it did not apply to template literals, which was reported in issue #16542.
This issue is a feature request to extend this behavior to template literals as well.
After discussing this internally, the Prettier team concluded that removing useless escape characters, whether in string literals or template literals, is the responsibility of a linter, not a formatter.
This change disables the removal of useless escape characters in string literals across all languages supported by Prettier. To keep the previous behavior, we recommend using ESLint rules like no-useless-escape.
Escaped quotes (e.g. "\"\'") may get unescaped when changing between different quotes. This is explained on the Rationale page of the official documentation.
// Inputconst str = "\a";// Prettier 3.3const str = "a";// Prettier 3.4const str = "\a";
Improve comment formatting for logical expression in unary expression (#16593 by @sosukesuzuki)‚Äã
// Input!(  cond1 || // foo  cond2 || // bar  cond3 // baz);// Prettier 3.3!(  (    cond1 || // foo    cond2 || // bar    cond3  ) // baz);// Prettier 3.4!(  cond1 || // foo  cond2 || // bar  cond3 // baz);
Removed support for experimental syntax (#16643, #16705 by @fisker)‚Äã


DecimalLiteral - The Decimal proposal decided not to introduce new syntax. The decimal plugin will be removed from Babel 8.


importReflection - The "Import Reflection" proposal has been renamed to "Source Phase Imports"


Disclaimer about non-standard syntax


TypeScript‚Äã
Add missing parentheses in tagged template literals (#16500 by @syi0808)‚Äã
// Input(String?.raw!)``;(String?.raw)!``;// Prettier 3.3String?.raw!``;String?.raw!``;// Prettier 3.4(String?.raw)!``;(String?.raw)!``;
Preserve a comment on between decorator and modified parameter property (#16574 by @sosukesuzuki)‚Äã
The current version of Prettier unexpectedly moves a line comment between a parameter property modified by readonly, private, public, etc and a decorator. This output results in invalid TypeScript code.
This change ensures that the original format is preserved.
// Inputclass Foo {  constructor(    @decorator    // comment    readonly foo,  ) {}}// Prettier 3.3class Foo {  constructor(    @decorator    readonly // comment    foo,  ) {}}// Prettier 3.4class Foo {  constructor(    @decorator    // comment    readonly foo,  ) {}}
Preserve a comment between modifier and the decorated property name (#16578 by @sosukesuzuki)‚Äã
There was a bug where block comments between the modifier and the name of a decorated property were being treated as trailing comments of the decorator. This behavior was not only unexpected but also lacked idempotency.
With this change, the position of the block comment between the modifier and the property name is preserved.
// Inputclass Foo {  @decorator  readonly /* comment */ propertyName;}// Prettier 3.3class Foo {  @decorator /* comment */  readonly propertyName;}// Prettier 3.3 (second output)class Foo {  @decorator /* comment */ readonly propertyName;}// Prettier 3.4class Foo {  @decorator  readonly /* comment */ propertyName;}
Don't print an extra line break for arrow function with type parameter in assignment (#16586 by @sosukesuzuki)‚Äã
There was a bug where an extra line was inserted when assigning a chained arrow function with type parameters to a variable if there was a line comment above it.
This change ensures that the extra line is no longer inserted.
// Inputconst foo1 =  // comment  <T,>() => () => 1;// Prettier 3.3const foo1 =  // comment    <T,>() =>    () =>      1;// Prettier 3.4const foo1 =  // comment  <T,>() =>    () =>      1;
Support "Top-level await statements" (#16729 by @fisker)‚Äã
// Input(await (await fetch()).json()).foo// Prettier 3.3await(await fetch()).json().foo;// Prettier 3.4(await (await fetch()).json()).foo;
Fix class heritage breaks even though it remains inside the line width (#16730 by @fisker)‚Äã
// Inputexport class JiraCreatePixFraudDetectionGateway  implements Pick<IssuePixFraudDetectionGateway, "createPixFraudDetectionIssue">{  constructor(private readonly logger: Logger) {    this.logger = logger.child({      context: JiraCreatePixFraudDetectionGateway.name,    });  }}// Prettier 3.3export class JiraCreatePixFraudDetectionGateway  implements    Pick<IssuePixFraudDetectionGateway, "createPixFraudDetectionIssue">{  constructor(private readonly logger: Logger) {    this.logger = logger.child({      context: JiraCreatePixFraudDetectionGateway.name,    });  }}// Prettier 3.4export class JiraCreatePixFraudDetectionGateway  implements Pick<IssuePixFraudDetectionGateway, "createPixFraudDetectionIssue">{  constructor(private readonly logger: Logger) {    this.logger = logger.child({      context: JiraCreatePixFraudDetectionGateway.name,    });  }}
Print declare before accessibility in class properties (#16731 by @fisker)‚Äã
// Inputclass A {  declare private readonly name: string;}// Prettier 3.3class A {  private declare readonly name: string;}// Prettier 3.4class A {  declare private readonly name: string;}
CSS‚Äã
Resolve some types of overrun in CSS (#16570 by @seiyab)‚Äã
/* Input */@media (prefers-reduced-data: no-preference) {  @font-face {    unicode-range: U+0000-00FF, U+0131,U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;  }}/* Prettier 3.3 */@media (prefers-reduced-data: no-preference) {  @font-face {    unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA,      U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212,      U+2215, U+FEFF, U+FFFD;  }}/* Prettier 3.4 */@media (prefers-reduced-data: no-preference) {  @font-face {    unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6,      U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193,      U+2212, U+2215, U+FEFF, U+FFFD;  }}
Remove extra indentation in pseudo-class function (#16572 by @sosukesuzuki)‚Äã
This change fixes a bug where extra indentation was added when line breaks were included in the argument list of pseudo-class functions like :where(), :is(), and :not.
/* Input */:where(input:not([type="button"], [type="reset"], [type="submit"]), textarea, select) {    /* CSS here */}/* Prettier 3.3 */:where(    input:not([type="button"], [type="reset"], [type="submit"]),    textarea,    select  ) {  /* CSS here */}/* Prettier 3.4 */:where(  input:not([type="button"], [type="reset"], [type="submit"]),  textarea,  select) {  /* CSS here */}
Fix formatting of incomplete CSS value comments (#16583 by @sosukesuzuki, @fisker)‚Äã
When formatting CSS value comments, the trailing / may be lost, resulting in an invalid comment.
This change ensures that value comments are not truncated.
/* Input */h1 {  --OFF: /* OFF */;}/* Prettier 3.3 */h1 {  --OFF:  /* OFF *;}/* Prettier 3.4 */h1 {  --OFF: /* OFF */;}
SCSS‚Äã
Fix error thrown when formatting SCSS file (#16607 by @fisker)‚Äã
// Input@if true {  $newKey: ($key: ( $theme-name: $value ))}// Prettier 3.3Error// Prettier 3.4@if true {  $newKey: (    $key:      (        $theme-name: $value,      ),  );}
Fix wrong trailing comma position after comment in SCSS (#16617 by @Ma-hawaj, @fisker)‚Äã
/* Input */$z-indexes: (    header: 1035,    overlay: 1202 // TODO: change to 1050 after bootstrap modals will be removed);/* Prettier 3.3 */$z-indexes: (    header: 1035,    overlay: 1202 // TODO: change to 1050 after bootstrap modals will be removed,);/* Prettier 3.4 */$z-indexes: (    header: 1035,    overlay: 1202, // TODO: change to 1050 after bootstrap modals will be removed);
HTML‚Äã
Keep doctype in non-html files unchanged (#16765 by @fisker)‚Äã
In Prettier v3, we print HTML5 doctype in lowercase, it's safe for HTML files, however users may use the html parser to format other files eg: XHTML files, lowercase the doctype will break XHTML documents.
Starting with Prettier 3.4, we'll only lowercase HTML5 doctype (<!doctype html>) when the file extension is .html or .htm, otherwise they will be untouched.
<!-- Input --><!-- foo.xhtml --><!DOCTYPE html><!-- Prettier 3.3 --><!doctype html><!-- Prettier 3.4 --><!DOCTYPE html>
Vue‚Äã
Fix extra semicolon inserted in Vue event binding with non-ascii characters (#16733 by @fisker)‚Äã
<!-- Input --><template>  <button @click="ÁÇπÂáª‰∫ã‰ª∂">ÁÇπÂáª!</button>  <button @click="onClick">Click!</button></template><!-- Prettier 3.3 --><template>  <button @click="ÁÇπÂáª‰∫ã‰ª∂;">ÁÇπÂáª!</button>  <button @click="onClick">Click!</button></template><!-- Prettier 3.4 --><template>  <button @click="ÁÇπÂáª‰∫ã‰ª∂">ÁÇπÂáª!</button>  <button @click="onClick">Click!</button></template>
Angular‚Äã
Support Angular 19 (#16862 by @fisker)‚Äã
Angular 19 added support for typeof keyword in template expressions.
<!-- Input --><div>{{ typeof      x ===    'object' ? 'Y' : 'N'}}</div><!-- Prettier 3.3 --><div>  {{ typeof      x ===    'object' ? 'Y' : 'N'}}</div>// Prettier 3.4<div>{{ typeof x === "object" ? "Y" : "N" }}</div>
Markdown‚Äã
Remove excessive spaces after line prefixes for unordered lists in Markdown (#15526 by @TomasLudvik)‚Äã
<!-- Input -->- first line    - second line indented- third line    - fourth line        - fifth line<!-- Prettier 3.3 -->-   first line    -   second line indented-   third line    -   fourth line        -   fifth line<!-- Prettier 3.4 -->- first line    - second line indented- third line    - fourth line        - fifth line
Fix incorrect wrap in sentence with linkReference (#16546 by @seiyab)‚Äã
<!-- Input (--prose-wrap=always) -->This folder has [VHS] tape files to create gifs for the [Widget Showcase]. To run them, install VHS from main (the theme and screenshot commands are not yet released).<!-- Prettier 3.3 -->This folder has [VHS] tape files to create gifs for the [Widget Showcase]. To runthem, install VHS from main (the theme and screenshot commands are not yet released).<!-- Prettier 3.4 -->This folder has [VHS] tape files to create gifs for the [Widget Showcase]. Torun them, install VHS from main (the theme and screenshot commands are not yetreleased).
Preserve non-ASCII whitespaces at the end of the line and beginning of the next line (#16619 by @tats-u)‚Äã
Prettier removes non-ASCII spaces at the end of the line and beginning of the next line. However, this behavior is not consistent with the CommonMark spec.
https://spec.commonmark.org/0.31.2/#soft-line-breaks

Spaces at the end of the line and beginning of the next line are removed:

https://spec.commonmark.org/0.31.2/#unicode-whitespace-character

A Unicode whitespace character is a character in the Unicode Zs general category, or a tab (U+0009), line feed (U+000A), form feed (U+000C), or carriage return (U+000D).


Unicode whitespace is a sequence of one or more Unicode whitespace characters.


A space is U+0020.

The CommonMark spec doesn't mention non-ASCII spaces here, so removing them changes the content of the Markdown document.
<!-- Input -->‚ÄÉEM Space (U+2003) EM Space„ÄÄÂÖ®Ëßí„Çπ„Éö„Éº„Çπ (U+3000) ÂÖ®ÂΩ¢Á©∫ÁôΩ<!-- Prettier 3.3 -->EM Space (U+2003) EM SpaceÂÖ®Ëßí„Çπ„Éö„Éº„Çπ (U+3000) ÂÖ®ÂΩ¢Á©∫ÁôΩ<!-- Prettier 3.4 -->‚ÄÉEM Space (U+2003) EM Space„ÄÄÂÖ®Ëßí„Çπ„Éö„Éº„Çπ (U+3000) ÂÖ®ÂΩ¢Á©∫ÁôΩ
Don't break a line a between Chinese or Japanese and others (#16691 by @tats-u)‚Äã
Markdown documents are mainly converted to HTML or components of JavaScript-based frameworks. This means that paragraphs in Markdown are eventually processed by the browser according to CSS rules. This is because many Markdown converter preserve line breaks in paragraphs in input Markdown and HTML itself does not specify how browsers should handle line breaks in text in HTML.
According to CSS rules (CSS Text Module Level 3 or later), browsers should remove line breaks between Chinese/Japanese characters instead of replacing them with spaces. However, this rule has been ignored by WebKit-based or Webkit-derived browsers (Chrome, Safari, and so on) for long time.
For example, the following HTML paragraph:
<p>Êó•Êú¨Ë™ûÊ±âËØ≠Êº¢Ë™û<p>
generated from the following Markdown:
Êó•Êú¨Ë™ûÊ±âËØ≠Êº¢Ë™û
should be rendered as follows according to CSS rules and actually is rendered such by Firefox:
Êó•Êú¨Ë™ûÊ±âËØ≠Êº¢Ë™û
However, Chrome and Safari render it as follows:
Êó•Êú¨Ë™û Ê±âËØ≠ Êº¢Ë™û
This is why we should stop Prettier from line breaking between Chinese/Japanese characters. We decided to stop Prettier from forcing users to use a plugin for a Markdown converter that concatenates lines that start or end with Chinese/Japanese characters (remark-join-cjk-lines, for example).
Also, a line break between Chinese/Japanese and others are equivalent to a space according to before the commit suspending a concrete rule in CSS Text Module Level 3 by commenting it out fixing an issue on the CSS Working Group Editor Drafts. Firefox follows this rule. Therefore, all browsers render the following paragraph:
<!-- prettier-ignore -->```html<p>Êó•Êú¨Ë™û English Ê±âËØ≠ ÌïúÍµ≠Ïñ¥ Êº¢Ë™û</p><p></p>
as follows:
Êó•Êú¨Ë™û English Ê±âËØ≠ ÌïúÍµ≠Ïñ¥ Êº¢Ë™û
However, Prettier has broken a line between Chinese/Japanese characters in Markdown for a long time, and between Chinese/Japanese and latin characters in some cases since 3.0.0. For example, the following Markdown paragraph:
Êó•Êú¨Ë™ûEnglishÊ±âËØ≠EnglishÊº¢Ë™û
is formatted as follows if --prose-wrap is set to the other value than preserve in Prettier 3.x:
Êó•Êú¨Ë™ûEnglishÊ±âËØ≠EnglishÊº¢Ë™û
However, the following HTML, which is generated by a Markdown-to-HTML converter based on the above Markdown:
<p>Êó•Êú¨Ë™ûEnglishÊ±âËØ≠EnglishÊº¢Ë™û</p>
is rendered as follows by all browsers:
Êó•Êú¨Ë™ûEnglishÊ±âËØ≠ English Êº¢Ë™û
This is why we should stop Prettier from line breaking al„ÄÄso around Chinese/Japanese characters in Markdown. We are going to conform Prettier's behavior to this rule in a future version. After that, line breaks between Chinese/Japanese and others will be allowed again under certain rules.
One of the few exceptions is spaces and line breaks between Chinese/Japanese and Korean letters. The following Markdown paragraphs are equivalent even in the current Prettier version:
ÌòÑÏû¨ ÈüìÂúãÏùò Â§ßÁµ±È†òÏùÄ Â∞πÈå´ÊÇÖÏù¥Îã§.
ÌòÑÏû¨ÈüìÂúãÏùòÂ§ßÁµ±È†òÏùÄÂ∞πÈå´ÊÇÖÏù¥Îã§.
You get the former if you format the latter with --prose-wrap=always and a sufficiently long --print-width value or with --prose-wrap=never, and you get the latter if you format the former with --prose-wrap=always with a extremely short --print-width value. Therefore, we do not have to touch such spaces and line breaks.
Another exception is those between a Chinese/Japanese character and a meaningful symbol in Markdown like *, `, [, and ]. For example, the following Markdown paragraph is equivalent even in the current Prettier version:
**Yarn** „ÅÆCLIÁµåÁî±„Åß„Éï„Ç©„Éº„Éû„ÉÉ„Éà„Åô„Çã„Å´„ÅØ `yarn prettier -w ` „ÇíÂÆüË°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
**Yarn**„ÅÆCLIÁµåÁî±„Åß„Éï„Ç©„Éº„Éû„ÉÉ„Éà„Åô„Çã„Å´„ÅØ`yarn prettier -w .`„ÇíÂÆüË°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<!-- Input (--prose-wrap=always --print-width=20) -->Êó•Êú¨Ë™û Ê±âËØ≠ Êº¢Ë™û English ÌïúÍµ≠Ïñ¥ Êó•Êú¨Ë™û Ê±âËØ≠ Êº¢Ë™û English ÌïúÍµ≠Ïñ¥ Êó•Êú¨Ë™û Ê±âËØ≠ Êº¢Ë™û English ÌïúÍµ≠Ïñ¥ Êó•Êú¨Ë™û Ê±âËØ≠ Êº¢Ë™û English ÌïúÍµ≠Ïñ¥Êó•Êú¨Ë™ûÊ±âËØ≠Êº¢Ë™ûEnglishÌïúÍµ≠Ïñ¥Êó•Êú¨Ë™ûÊ±âËØ≠Êº¢Ë™ûEnglishÌïúÍµ≠Ïñ¥Êó•Êú¨Ë™ûÊ±âËØ≠Êº¢Ë™ûEnglishÌïúÍµ≠Ïñ¥Êó•Êú¨Ë™ûÊ±âËØ≠Êº¢Ë™ûEnglishÌïúÍµ≠Ïñ¥<!-- Prettier 3.3 -->Êó•Êú¨Ë™û Ê±âËØ≠ Êº¢Ë™ûEnglish ÌïúÍµ≠Ïñ¥ Êó•Êú¨Ë™û Ê±âËØ≠ Êº¢Ë™û EnglishÌïúÍµ≠Ïñ¥ Êó•Êú¨Ë™û Ê±âËØ≠Êº¢Ë™û English ÌïúÍµ≠Ïñ¥Êó•Êú¨Ë™û Ê±âËØ≠ Êº¢Ë™ûEnglish ÌïúÍµ≠Ïñ¥Êó•Êú¨Ë™ûÊ±âËØ≠Êº¢Ë™ûEnglishÌïúÍµ≠Ïñ¥Êó•Êú¨Ë™ûÊ±âËØ≠Êº¢Ë™ûEnglishÌïúÍµ≠Ïñ¥Êó•Êú¨Ë™ûÊ±âËØ≠Êº¢Ë™ûEnglishÌïúÍµ≠Ïñ¥Êó•Êú¨Ë™ûÊ±âËØ≠Êº¢Ë™ûEnglishÌïúÍµ≠Ïñ¥<!-- Prettier 3.4 -->Êó•Êú¨Ë™û Ê±âËØ≠ Êº¢Ë™û EnglishÌïúÍµ≠Ïñ¥Êó•Êú¨Ë™û Ê±âËØ≠ Êº¢Ë™û EnglishÌïúÍµ≠Ïñ¥Êó•Êú¨Ë™û Ê±âËØ≠ Êº¢Ë™û EnglishÌïúÍµ≠Ïñ¥Êó•Êú¨Ë™û Ê±âËØ≠ Êº¢Ë™û EnglishÌïúÍµ≠Ïñ¥Êó•Êú¨Ë™ûÊ±âËØ≠Êº¢Ë™ûEnglishÌïúÍµ≠Ïñ¥Êó•Êú¨Ë™ûÊ±âËØ≠Êº¢Ë™ûEnglishÌïúÍµ≠Ïñ¥Êó•Êú¨Ë™ûÊ±âËØ≠Êº¢Ë™ûEnglishÌïúÍµ≠Ïñ¥Êó•Êú¨Ë™ûÊ±âËØ≠Êº¢Ë™ûEnglishÌïúÍµ≠Ïñ¥
Tell regexp-util to generate regex compatible with u flag (#16816 by @tats-u)‚Äã
CJK characters outside of BMP and Ideographic Variation Sequences (IVS; variation selectors dedicated for han/kanji), which consume 2 characters in JavaScript string, have not been treated as CJK. This is due to the fact that Prettier has not passed the appropriate flag "u" to the regexp-util package.
In the following example, ‚Äú†Æ∑‚Äù (U+20BB7) is out of BMP, and ‚ÄúËëõÛ†ÑÄ‚Äù is a combination of a han ‚ÄúËëõ‚Äù (U+845B) in BMP and an IVS U+E0100. The latter requires a font with the support of Adobe Japan-1 (e.g. Yu Gothic UI and Source Han Sans) to be rendered as a form different from that of the character without IVS (Ëëõ).
<!-- Input (--prose-wrap=never) -->a Â≠ó a Â≠ó a Â≠ó†Æ∑†Æ∑ËëõÛ†ÑÄËëõÛ†ÑÄÁµÇ<!-- Prettier 3.3 -->a Â≠ó a Â≠ó a Â≠ó †Æ∑ †Æ∑ ËëõÛ†ÑÄ ËëõÛ†ÑÄ ÁµÇ<!-- Prettier 3.4 -->a Â≠ó a Â≠ó a Â≠ó†Æ∑†Æ∑ËëõÛ†ÑÄËëõÛ†ÑÄÁµÇ
YAML‚Äã
Fix yaml comment in non-singleline items missing space before # (#16489 by @fyc09)‚Äã
# Input123: # hello  # comment# Prettier 3.3123:# hello  # comment# Prettier 3.4123: # hello  # comment
API‚Äã
Stop doc mutation in prettier.doc.printDocToString (#13315 by @fisker)‚Äã
For performance reason, prettier.doc.printDocToString used to mutate .parts of the fill command during print. It was converted to a pure function to ensure output correctness.
Make getPreferredQuote public (#16567 by @sosukesuzuki)‚Äã
This change makes the internal getPreferredQuote function a part of the public API.
In languages like JavaScript, both single quotes and double quotes can be used for string literals. Prettier determines the quote to enclose a string literal based on the number of quotes within the string and the value of the singleQuote option. For more details, please refer to the Rationale page.
The getPreferredQuote function determines the appropriate quote to enclose a string literal and has the following interface:
type Quote = '"' | "'";function getPreferredQuote(  text: string,  preferredQuoteOrPreferSingleQuote: Quote | boolean,): Quote;
Here are some examples of how to use it:
import * as prettier from "prettier";const SINGLE_QUOTE = `'`;const DOUBLE_QUOTE = `"`;console.log(prettier.util.getPreferredQuote(`Hello World Test`, SINGLE_QUOTE)); // 'console.log(prettier.util.getPreferredQuote(`Hello World Test`, DOUBLE_QUOTE)); // "console.log(prettier.util.getPreferredQuote(`'Hello' "World" 'Test'`, SINGLE_QUOTE)); // "console.log(prettier.util.getPreferredQuote(`"Hello" 'World' "Test"`, DOUBLE_QUOTE)); // 'console.log(prettier.util.getPreferredQuote(`"Hello" "World" "Test"`, SINGLE_QUOTE)); // 'console.log(prettier.util.getPreferredQuote(`'Hello' 'World' 'Test'`, DOUBLE_QUOTE)); // "
Making this function public will benefit plugin developers. Since the function is relatively short, you can find more details in the implementation.
Fix loading ESM-style shared config file in Node.js 23 (#16857 by @sosukesuzuki)‚Äã
In Prettier 3.3, attempting to load an ESM-style shared config file in Node.js 23 resulted in the following warnings, preventing the options from being loaded:
[warn] Ignored unknown option { __esModule: true }.[warn] Ignored unknown option { default: { trailingComma: "es5", tabWidth: 4, singleQuote: true } }.
This issue was caused by a new module feature in Node.js 23, known as require(ESM). Prettier 3.4 resolves this problem, allowing the options to load correctly.
For more details, please see https://github.com/prettier/prettier/issues/16812.
CLI‚Äã
Ignore files in the Jujutsu directory (#16684 by @marcusirgens)‚Äã
The Jujutsu VCS uses the .jj directory, similarly to how Git uses .git.
This change adds .jj to the list of directories which are silently ignored by prettier.
Miscellaneous‚Äã
Fix cursorOffset feature sometimes being catastrophically slow (#15709 by @ExplodingCabbage)‚Äã
Previously, Prettier's cursorOffset feature would be spectacularly slow in certain unfortunate circumstances (namely when the user's cursor was not contained within a leaf node of the AST, and the non-leaf node containing it was very large and being significantly reformatted by Prettier). As a consequence, if you used Prettier via an editor integration that used cursorOffset under the hood, your editor would sometimes inexplicably hang when you tried to format a file.
All examples of this phenomenon that we are aware of should now be fixed, but bug reports of any further pathological examples would be welcome.Edit this page\n\nPrettier 3.4: A lot of bug fixesNovember 26, 2024 ¬∑ 19 min readSosuke SuzukiThis release includes numerous bug fixes and other improvements.
If you appreciate Prettier and would like to support our work, please consider sponsoring us directly via our OpenCollective or by sponsoring the projects we depend on, such as typescript-eslint, remark, and Babel. Thank you for your continued support!
Other Changes‚Äã
JavaScript‚Äã
Fix template literal print with array (#13315 by @fisker, @syi0808)‚Äã
// Inputconst string = `${[[1, 2], [3, 4]]}`// Prettier 3.3const string = `${[  [2],  [4],]}`;// Prettier 3.4const string = `${[  [1, 2],  [3, 4],]}`;
Add missing parentheses in tagged template literals (#16500 by @syi0808)‚Äã
// Input(String?.raw)``;(getTag?.())``;// Prettier 3.3String?.raw``;getTag?.()``;// Prettier 3.4(String?.raw)``;(getTag?.())``;
Don't remove useless \ in string literals (#16563 by @sosukesuzuki, #16763 by @fisker)‚Äã
Previously, Prettier would remove useless escape characters (\) from string literals. However, this behavior was inconsistent as it did not apply to template literals, which was reported in issue #16542.
This issue is a feature request to extend this behavior to template literals as well.
After discussing this internally, the Prettier team concluded that removing useless escape characters, whether in string literals or template literals, is the responsibility of a linter, not a formatter.
This change disables the removal of useless escape characters in string literals across all languages supported by Prettier. To keep the previous behavior, we recommend using ESLint rules like no-useless-escape.
Escaped quotes (e.g. "\"\'") may get unescaped when changing between different quotes. This is explained on the Rationale page of the official documentation.
// Inputconst str = "\a";// Prettier 3.3const str = "a";// Prettier 3.4const str = "\a";
Improve comment formatting for logical expression in unary expression (#16593 by @sosukesuzuki)‚Äã
// Input!(  cond1 || // foo  cond2 || // bar  cond3 // baz);// Prettier 3.3!(  (    cond1 || // foo    cond2 || // bar    cond3  ) // baz);// Prettier 3.4!(  cond1 || // foo  cond2 || // bar  cond3 // baz);
Removed support for experimental syntax (#16643, #16705 by @fisker)‚Äã


DecimalLiteral - The Decimal proposal decided not to introduce new syntax. The decimal plugin will be removed from Babel 8.


importReflection - The "Import Reflection" proposal has been renamed to "Source Phase Imports"


Disclaimer about non-standard syntax


TypeScript‚Äã
Add missing parentheses in tagged template literals (#16500 by @syi0808)‚Äã
// Input(String?.raw!)``;(String?.raw)!``;// Prettier 3.3String?.raw!``;String?.raw!``;// Prettier 3.4(String?.raw)!``;(String?.raw)!``;
Preserve a comment on between decorator and modified parameter property (#16574 by @sosukesuzuki)‚Äã
The current version of Prettier unexpectedly moves a line comment between a parameter property modified by readonly, private, public, etc and a decorator. This output results in invalid TypeScript code.
This change ensures that the original format is preserved.
// Inputclass Foo {  constructor(    @decorator    // comment    readonly foo,  ) {}}// Prettier 3.3class Foo {  constructor(    @decorator    readonly // comment    foo,  ) {}}// Prettier 3.4class Foo {  constructor(    @decorator    // comment    readonly foo,  ) {}}
Preserve a comment between modifier and the decorated property name (#16578 by @sosukesuzuki)‚Äã
There was a bug where block comments between the modifier and the name of a decorated property were being treated as trailing comments of the decorator. This behavior was not only unexpected but also lacked idempotency.
With this change, the position of the block comment between the modifier and the property name is preserved.
// Inputclass Foo {  @decorator  readonly /* comment */ propertyName;}// Prettier 3.3class Foo {  @decorator /* comment */  readonly propertyName;}// Prettier 3.3 (second output)class Foo {  @decorator /* comment */ readonly propertyName;}// Prettier 3.4class Foo {  @decorator  readonly /* comment */ propertyName;}
Don't print an extra line break for arrow function with type parameter in assignment (#16586 by @sosukesuzuki)‚Äã
There was a bug where an extra line was inserted when assigning a chained arrow function with type parameters to a variable if there was a line comment above it.
This change ensures that the extra line is no longer inserted.
// Inputconst foo1 =  // comment  <T,>() => () => 1;// Prettier 3.3const foo1 =  // comment    <T,>() =>    () =>      1;// Prettier 3.4const foo1 =  // comment  <T,>() =>    () =>      1;
Support "Top-level await statements" (#16729 by @fisker)‚Äã
// Input(await (await fetch()).json()).foo// Prettier 3.3await(await fetch()).json().foo;// Prettier 3.4(await (await fetch()).json()).foo;
Fix class heritage breaks even though it remains inside the line width (#16730 by @fisker)‚Äã
// Inputexport class JiraCreatePixFraudDetectionGateway  implements Pick<IssuePixFraudDetectionGateway, "createPixFraudDetectionIssue">{  constructor(private readonly logger: Logger) {    this.logger = logger.child({      context: JiraCreatePixFraudDetectionGateway.name,    });  }}// Prettier 3.3export class JiraCreatePixFraudDetectionGateway  implements    Pick<IssuePixFraudDetectionGateway, "createPixFraudDetectionIssue">{  constructor(private readonly logger: Logger) {    this.logger = logger.child({      context: JiraCreatePixFraudDetectionGateway.name,    });  }}// Prettier 3.4export class JiraCreatePixFraudDetectionGateway  implements Pick<IssuePixFraudDetectionGateway, "createPixFraudDetectionIssue">{  constructor(private readonly logger: Logger) {    this.logger = logger.child({      context: JiraCreatePixFraudDetectionGateway.name,    });  }}
Print declare before accessibility in class properties (#16731 by @fisker)‚Äã
// Inputclass A {  declare private readonly name: string;}// Prettier 3.3class A {  private declare readonly name: string;}// Prettier 3.4class A {  declare private readonly name: string;}
CSS‚Äã
Resolve some types of overrun in CSS (#16570 by @seiyab)‚Äã
/* Input */@media (prefers-reduced-data: no-preference) {  @font-face {    unicode-range: U+0000-00FF, U+0131,U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;  }}/* Prettier 3.3 */@media (prefers-reduced-data: no-preference) {  @font-face {    unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA,      U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212,      U+2215, U+FEFF, U+FFFD;  }}/* Prettier 3.4 */@media (prefers-reduced-data: no-preference) {  @font-face {    unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6,      U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193,      U+2212, U+2215, U+FEFF, U+FFFD;  }}
Remove extra indentation in pseudo-class function (#16572 by @sosukesuzuki)‚Äã
This change fixes a bug where extra indentation was added when line breaks were included in the argument list of pseudo-class functions like :where(), :is(), and :not.
/* Input */:where(input:not([type="button"], [type="reset"], [type="submit"]), textarea, select) {    /* CSS here */}/* Prettier 3.3 */:where(    input:not([type="button"], [type="reset"], [type="submit"]),    textarea,    select  ) {  /* CSS here */}/* Prettier 3.4 */:where(  input:not([type="button"], [type="reset"], [type="submit"]),  textarea,  select) {  /* CSS here */}
Fix formatting of incomplete CSS value comments (#16583 by @sosukesuzuki, @fisker)‚Äã
When formatting CSS value comments, the trailing / may be lost, resulting in an invalid comment.
This change ensures that value comments are not truncated.
/* Input */h1 {  --OFF: /* OFF */;}/* Prettier 3.3 */h1 {  --OFF:  /* OFF *;}/* Prettier 3.4 */h1 {  --OFF: /* OFF */;}
SCSS‚Äã
Fix error thrown when formatting SCSS file (#16607 by @fisker)‚Äã
// Input@if true {  $newKey: ($key: ( $theme-name: $value ))}// Prettier 3.3Error// Prettier 3.4@if true {  $newKey: (    $key:      (        $theme-name: $value,      ),  );}
Fix wrong trailing comma position after comment in SCSS (#16617 by @Ma-hawaj, @fisker)‚Äã
/* Input */$z-indexes: (    header: 1035,    overlay: 1202 // TODO: change to 1050 after bootstrap modals will be removed);/* Prettier 3.3 */$z-indexes: (    header: 1035,    overlay: 1202 // TODO: change to 1050 after bootstrap modals will be removed,);/* Prettier 3.4 */$z-indexes: (    header: 1035,    overlay: 1202, // TODO: change to 1050 after bootstrap modals will be removed);
HTML‚Äã
Keep doctype in non-html files unchanged (#16765 by @fisker)‚Äã
In Prettier v3, we print HTML5 doctype in lowercase, it's safe for HTML files, however users may use the html parser to format other files eg: XHTML files, lowercase the doctype will break XHTML documents.
Starting with Prettier 3.4, we'll only lowercase HTML5 doctype (<!doctype html>) when the file extension is .html or .htm, otherwise they will be untouched.
<!-- Input --><!-- foo.xhtml --><!DOCTYPE html><!-- Prettier 3.3 --><!doctype html><!-- Prettier 3.4 --><!DOCTYPE html>
Vue‚Äã
Fix extra semicolon inserted in Vue event binding with non-ascii characters (#16733 by @fisker)‚Äã
<!-- Input --><template>  <button @click="ÁÇπÂáª‰∫ã‰ª∂">ÁÇπÂáª!</button>  <button @click="onClick">Click!</button></template><!-- Prettier 3.3 --><template>  <button @click="ÁÇπÂáª‰∫ã‰ª∂;">ÁÇπÂáª!</button>  <button @click="onClick">Click!</button></template><!-- Prettier 3.4 --><template>  <button @click="ÁÇπÂáª‰∫ã‰ª∂">ÁÇπÂáª!</button>  <button @click="onClick">Click!</button></template>
Angular‚Äã
Support Angular 19 (#16862 by @fisker)‚Äã
Angular 19 added support for typeof keyword in template expressions.
<!-- Input --><div>{{ typeof      x ===    'object' ? 'Y' : 'N'}}</div><!-- Prettier 3.3 --><div>  {{ typeof      x ===    'object' ? 'Y' : 'N'}}</div>// Prettier 3.4<div>{{ typeof x === "object" ? "Y" : "N" }}</div>
Markdown‚Äã
Remove excessive spaces after line prefixes for unordered lists in Markdown (#15526 by @TomasLudvik)‚Äã
<!-- Input -->- first line    - second line indented- third line    - fourth line        - fifth line<!-- Prettier 3.3 -->-   first line    -   second line indented-   third line    -   fourth line        -   fifth line<!-- Prettier 3.4 -->- first line    - second line indented- third line    - fourth line        - fifth line
Fix incorrect wrap in sentence with linkReference (#16546 by @seiyab)‚Äã
<!-- Input (--prose-wrap=always) -->This folder has [VHS] tape files to create gifs for the [Widget Showcase]. To run them, install VHS from main (the theme and screenshot commands are not yet released).<!-- Prettier 3.3 -->This folder has [VHS] tape files to create gifs for the [Widget Showcase]. To runthem, install VHS from main (the theme and screenshot commands are not yet released).<!-- Prettier 3.4 -->This folder has [VHS] tape files to create gifs for the [Widget Showcase]. Torun them, install VHS from main (the theme and screenshot commands are not yetreleased).
Preserve non-ASCII whitespaces at the end of the line and beginning of the next line (#16619 by @tats-u)‚Äã
Prettier removes non-ASCII spaces at the end of the line and beginning of the next line. However, this behavior is not consistent with the CommonMark spec.
https://spec.commonmark.org/0.31.2/#soft-line-breaks

Spaces at the end of the line and beginning of the next line are removed:

https://spec.commonmark.org/0.31.2/#unicode-whitespace-character

A Unicode whitespace character is a character in the Unicode Zs general category, or a tab (U+0009), line feed (U+000A), form feed (U+000C), or carriage return (U+000D).


Unicode whitespace is a sequence of one or more Unicode whitespace characters.


A space is U+0020.

The CommonMark spec doesn't mention non-ASCII spaces here, so removing them changes the content of the Markdown document.
<!-- Input -->‚ÄÉEM Space (U+2003) EM Space„ÄÄÂÖ®Ëßí„Çπ„Éö„Éº„Çπ (U+3000) ÂÖ®ÂΩ¢Á©∫ÁôΩ<!-- Prettier 3.3 -->EM Space (U+2003) EM SpaceÂÖ®Ëßí„Çπ„Éö„Éº„Çπ (U+3000) ÂÖ®ÂΩ¢Á©∫ÁôΩ<!-- Prettier 3.4 -->‚ÄÉEM Space (U+2003) EM Space„ÄÄÂÖ®Ëßí„Çπ„Éö„Éº„Çπ (U+3000) ÂÖ®ÂΩ¢Á©∫ÁôΩ
Don't break a line a between Chinese or Japanese and others (#16691 by @tats-u)‚Äã
Markdown documents are mainly converted to HTML or components of JavaScript-based frameworks. This means that paragraphs in Markdown are eventually processed by the browser according to CSS rules. This is because many Markdown converter preserve line breaks in paragraphs in input Markdown and HTML itself does not specify how browsers should handle line breaks in text in HTML.
According to CSS rules (CSS Text Module Level 3 or later), browsers should remove line breaks between Chinese/Japanese characters instead of replacing them with spaces. However, this rule has been ignored by WebKit-based or Webkit-derived browsers (Chrome, Safari, and so on) for long time.
For example, the following HTML paragraph:
<p>Êó•Êú¨Ë™ûÊ±âËØ≠Êº¢Ë™û<p>
generated from the following Markdown:
Êó•Êú¨Ë™ûÊ±âËØ≠Êº¢Ë™û
should be rendered as follows according to CSS rules and actually is rendered such by Firefox:
Êó•Êú¨Ë™ûÊ±âËØ≠Êº¢Ë™û
However, Chrome and Safari render it as follows:
Êó•Êú¨Ë™û Ê±âËØ≠ Êº¢Ë™û
This is why we should stop Prettier from line breaking between Chinese/Japanese characters. We decided to stop Prettier from forcing users to use a plugin for a Markdown converter that concatenates lines that start or end with Chinese/Japanese characters (remark-join-cjk-lines, for example).
Also, a line break between Chinese/Japanese and others are equivalent to a space according to before the commit suspending a concrete rule in CSS Text Module Level 3 by commenting it out fixing an issue on the CSS Working Group Editor Drafts. Firefox follows this rule. Therefore, all browsers render the following paragraph:
<!-- prettier-ignore -->```html<p>Êó•Êú¨Ë™û English Ê±âËØ≠ ÌïúÍµ≠Ïñ¥ Êº¢Ë™û</p><p></p>
as follows:
Êó•Êú¨Ë™û English Ê±âËØ≠ ÌïúÍµ≠Ïñ¥ Êº¢Ë™û
However, Prettier has broken a line between Chinese/Japanese characters in Markdown for a long time, and between Chinese/Japanese and latin characters in some cases since 3.0.0. For example, the following Markdown paragraph:
Êó•Êú¨Ë™ûEnglishÊ±âËØ≠EnglishÊº¢Ë™û
is formatted as follows if --prose-wrap is set to the other value than preserve in Prettier 3.x:
Êó•Êú¨Ë™ûEnglishÊ±âËØ≠EnglishÊº¢Ë™û
However, the following HTML, which is generated by a Markdown-to-HTML converter based on the above Markdown:
<p>Êó•Êú¨Ë™ûEnglishÊ±âËØ≠EnglishÊº¢Ë™û</p>
is rendered as follows by all browsers:
Êó•Êú¨Ë™ûEnglishÊ±âËØ≠ English Êº¢Ë™û
This is why we should stop Prettier from line breaking al„ÄÄso around Chinese/Japanese characters in Markdown. We are going to conform Prettier's behavior to this rule in a future version. After that, line breaks between Chinese/Japanese and others will be allowed again under certain rules.
One of the few exceptions is spaces and line breaks between Chinese/Japanese and Korean letters. The following Markdown paragraphs are equivalent even in the current Prettier version:
ÌòÑÏû¨ ÈüìÂúãÏùò Â§ßÁµ±È†òÏùÄ Â∞πÈå´ÊÇÖÏù¥Îã§.
ÌòÑÏû¨ÈüìÂúãÏùòÂ§ßÁµ±È†òÏùÄÂ∞πÈå´ÊÇÖÏù¥Îã§.
You get the former if you format the latter with --prose-wrap=always and a sufficiently long --print-width value or with --prose-wrap=never, and you get the latter if you format the former with --prose-wrap=always with a extremely short --print-width value. Therefore, we do not have to touch such spaces and line breaks.
Another exception is those between a Chinese/Japanese character and a meaningful symbol in Markdown like *, `, [, and ]. For example, the following Markdown paragraph is equivalent even in the current Prettier version:
**Yarn** „ÅÆCLIÁµåÁî±„Åß„Éï„Ç©„Éº„Éû„ÉÉ„Éà„Åô„Çã„Å´„ÅØ `yarn prettier -w ` „ÇíÂÆüË°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
**Yarn**„ÅÆCLIÁµåÁî±„Åß„Éï„Ç©„Éº„Éû„ÉÉ„Éà„Åô„Çã„Å´„ÅØ`yarn prettier -w .`„ÇíÂÆüË°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<!-- Input (--prose-wrap=always --print-width=20) -->Êó•Êú¨Ë™û Ê±âËØ≠ Êº¢Ë™û English ÌïúÍµ≠Ïñ¥ Êó•Êú¨Ë™û Ê±âËØ≠ Êº¢Ë™û English ÌïúÍµ≠Ïñ¥ Êó•Êú¨Ë™û Ê±âËØ≠ Êº¢Ë™û English ÌïúÍµ≠Ïñ¥ Êó•Êú¨Ë™û Ê±âËØ≠ Êº¢Ë™û English ÌïúÍµ≠Ïñ¥Êó•Êú¨Ë™ûÊ±âËØ≠Êº¢Ë™ûEnglishÌïúÍµ≠Ïñ¥Êó•Êú¨Ë™ûÊ±âËØ≠Êº¢Ë™ûEnglishÌïúÍµ≠Ïñ¥Êó•Êú¨Ë™ûÊ±âËØ≠Êº¢Ë™ûEnglishÌïúÍµ≠Ïñ¥Êó•Êú¨Ë™ûÊ±âËØ≠Êº¢Ë™ûEnglishÌïúÍµ≠Ïñ¥<!-- Prettier 3.3 -->Êó•Êú¨Ë™û Ê±âËØ≠ Êº¢Ë™ûEnglish ÌïúÍµ≠Ïñ¥ Êó•Êú¨Ë™û Ê±âËØ≠ Êº¢Ë™û EnglishÌïúÍµ≠Ïñ¥ Êó•Êú¨Ë™û Ê±âËØ≠Êº¢Ë™û English ÌïúÍµ≠Ïñ¥Êó•Êú¨Ë™û Ê±âËØ≠ Êº¢Ë™ûEnglish ÌïúÍµ≠Ïñ¥Êó•Êú¨Ë™ûÊ±âËØ≠Êº¢Ë™ûEnglishÌïúÍµ≠Ïñ¥Êó•Êú¨Ë™ûÊ±âËØ≠Êº¢Ë™ûEnglishÌïúÍµ≠Ïñ¥Êó•Êú¨Ë™ûÊ±âËØ≠Êº¢Ë™ûEnglishÌïúÍµ≠Ïñ¥Êó•Êú¨Ë™ûÊ±âËØ≠Êº¢Ë™ûEnglishÌïúÍµ≠Ïñ¥<!-- Prettier 3.4 -->Êó•Êú¨Ë™û Ê±âËØ≠ Êº¢Ë™û EnglishÌïúÍµ≠Ïñ¥Êó•Êú¨Ë™û Ê±âËØ≠ Êº¢Ë™û EnglishÌïúÍµ≠Ïñ¥Êó•Êú¨Ë™û Ê±âËØ≠ Êº¢Ë™û EnglishÌïúÍµ≠Ïñ¥Êó•Êú¨Ë™û Ê±âËØ≠ Êº¢Ë™û EnglishÌïúÍµ≠Ïñ¥Êó•Êú¨Ë™ûÊ±âËØ≠Êº¢Ë™ûEnglishÌïúÍµ≠Ïñ¥Êó•Êú¨Ë™ûÊ±âËØ≠Êº¢Ë™ûEnglishÌïúÍµ≠Ïñ¥Êó•Êú¨Ë™ûÊ±âËØ≠Êº¢Ë™ûEnglishÌïúÍµ≠Ïñ¥Êó•Êú¨Ë™ûÊ±âËØ≠Êº¢Ë™ûEnglishÌïúÍµ≠Ïñ¥
Tell regexp-util to generate regex compatible with u flag (#16816 by @tats-u)‚Äã
CJK characters outside of BMP and Ideographic Variation Sequences (IVS; variation selectors dedicated for han/kanji), which consume 2 characters in JavaScript string, have not been treated as CJK. This is due to the fact that Prettier has not passed the appropriate flag "u" to the regexp-util package.
In the following example, ‚Äú†Æ∑‚Äù (U+20BB7) is out of BMP, and ‚ÄúËëõÛ†ÑÄ‚Äù is a combination of a han ‚ÄúËëõ‚Äù (U+845B) in BMP and an IVS U+E0100. The latter requires a font with the support of Adobe Japan-1 (e.g. Yu Gothic UI and Source Han Sans) to be rendered as a form different from that of the character without IVS (Ëëõ).
<!-- Input (--prose-wrap=never) -->a Â≠ó a Â≠ó a Â≠ó†Æ∑†Æ∑ËëõÛ†ÑÄËëõÛ†ÑÄÁµÇ<!-- Prettier 3.3 -->a Â≠ó a Â≠ó a Â≠ó †Æ∑ †Æ∑ ËëõÛ†ÑÄ ËëõÛ†ÑÄ ÁµÇ<!-- Prettier 3.4 -->a Â≠ó a Â≠ó a Â≠ó†Æ∑†Æ∑ËëõÛ†ÑÄËëõÛ†ÑÄÁµÇ
YAML‚Äã
Fix yaml comment in non-singleline items missing space before # (#16489 by @fyc09)‚Äã
# Input123: # hello  # comment# Prettier 3.3123:# hello  # comment# Prettier 3.4123: # hello  # comment
API‚Äã
Stop doc mutation in prettier.doc.printDocToString (#13315 by @fisker)‚Äã
For performance reason, prettier.doc.printDocToString used to mutate .parts of the fill command during print. It was converted to a pure function to ensure output correctness.
Make getPreferredQuote public (#16567 by @sosukesuzuki)‚Äã
This change makes the internal getPreferredQuote function a part of the public API.
In languages like JavaScript, both single quotes and double quotes can be used for string literals. Prettier determines the quote to enclose a string literal based on the number of quotes within the string and the value of the singleQuote option. For more details, please refer to the Rationale page.
The getPreferredQuote function determines the appropriate quote to enclose a string literal and has the following interface:
type Quote = '"' | "'";function getPreferredQuote(  text: string,  preferredQuoteOrPreferSingleQuote: Quote | boolean,): Quote;
Here are some examples of how to use it:
import * as prettier from "prettier";const SINGLE_QUOTE = `'`;const DOUBLE_QUOTE = `"`;console.log(prettier.util.getPreferredQuote(`Hello World Test`, SINGLE_QUOTE)); // 'console.log(prettier.util.getPreferredQuote(`Hello World Test`, DOUBLE_QUOTE)); // "console.log(prettier.util.getPreferredQuote(`'Hello' "World" 'Test'`, SINGLE_QUOTE)); // "console.log(prettier.util.getPreferredQuote(`"Hello" 'World' "Test"`, DOUBLE_QUOTE)); // 'console.log(prettier.util.getPreferredQuote(`"Hello" "World" "Test"`, SINGLE_QUOTE)); // 'console.log(prettier.util.getPreferredQuote(`'Hello' 'World' 'Test'`, DOUBLE_QUOTE)); // "
Making this function public will benefit plugin developers. Since the function is relatively short, you can find more details in the implementation.
Fix loading ESM-style shared config file in Node.js 23 (#16857 by @sosukesuzuki)‚Äã
In Prettier 3.3, attempting to load an ESM-style shared config file in Node.js 23 resulted in the following warnings, preventing the options from being loaded:
[warn] Ignored unknown option { __esModule: true }.[warn] Ignored unknown option { default: { trailingComma: "es5", tabWidth: 4, singleQuote: true } }.
This issue was caused by a new module feature in Node.js 23, known as require(ESM). Prettier 3.4 resolves this problem, allowing the options to load correctly.
For more details, please see https://github.com/prettier/prettier/issues/16812.
CLI‚Äã
Ignore files in the Jujutsu directory (#16684 by @marcusirgens)‚Äã
The Jujutsu VCS uses the .jj directory, similarly to how Git uses .git.
This change adds .jj to the list of directories which are silently ignored by prettier.
Miscellaneous‚Äã
Fix cursorOffset feature sometimes being catastrophically slow (#15709 by @ExplodingCabbage)‚Äã
Previously, Prettier's cursorOffset feature would be spectacularly slow in certain unfortunate circumstances (namely when the user's cursor was not contained within a leaf node of the AST, and the non-leaf node containing it was very large and being significantly reformatted by Prettier). As a consequence, if you used Prettier via an editor integration that used cursorOffset under the hood, your editor would sometimes inexplicably hang when you tried to format a file.
All examples of this phenomenon that we are aware of should now be fixed, but bug reports of any further pathological examples would be welcome.Edit this pageNewer postPrettier 3.5: New objectWrap option, experimentalOperatorPosition option and TS config file support!Older postPrettier 3.3: New Flow features and a lot of bug fixes\n\nYarnYarn\n\n\n\nPrettier 3.3: New Flow features and a lot of bug fixesJune 1, 2024 ¬∑ 7 min readSosuke SuzukiThis release includes support for new Flow features such as component and hook declarations. All of these features were implemented by the engineers on the Flow team, thank you.
If you appreciate Prettier and would like to support our work, please consider sponsoring us directly via our OpenCollective or by sponsoring the projects we depend on, such as typescript-eslint, remark, and Babel. Thank you for your continued support!
Highlights‚Äã
Flow‚Äã
declare namespace printing support (#16066 by @SamChou19815)‚Äã
// Inputdeclare namespace foo {  declare var bar: string;}// Prettier 3.2// does not parse// Prettier 3.3declare namespace foo {  declare var bar: string;}
Component syntax printing support (#16191 by @SamChou19815)‚Äã
// Inputcomponent MyComponent(a: string, b: number) renders SomeComponent {  return <OtherComponent />;}hook useMyHook(a: string) {  return useState(a);}// Prettier 3.2// does not parse// Prettier 3.3component MyComponent(a: string, b: number) renders SomeComponent {  return <OtherComponent />;}hook useMyHook(a: string) {  return useState(a);}
Support big int Enums (#16268 by @gkz)‚Äã
Adds support for big int Flow Enums.
// Inputenum E {  A = 0n,  B = 1n,}// Prettier 3.2// error// Prettier 3.3enum E {  A = 0n,  B = 1n,}
Support inexact tuple types (#16271 by @gkz)‚Äã
Adds support for Flow's inexact tuple types.
// Inputtype T = [number, ...];// Prettier 3.2type T = [number];// Prettier 3.3type T = [number, ...];
Support 'implies' type guard variant (#16272 by @gkz)‚Äã
Adds support for Flow's implies type guard variant. Also updates the flow-parser dependency.
// Inputdeclare function f(x: mixed): implies x is T;// Prettier 3.2// error// Prettier 3.3declare function f(x: mixed): implies x is T;
Other Changes‚Äã
JavaScript‚Äã
Unquote keys in import attributes (#15888 by @sosukesuzuki)‚Äã
// Inputimport json from "./mod.json" with { "type": "json" };// Prettier 3.2import json from "./mod.json" with { "type": "json" };// Prettier 3.3import json from "./mod.json" with { type: "json" };
Fix unstable object print (#16058 by @fisker)‚Äã
// Inputa = {"\a": 1, "b": 2}// Prettier 3.2 (--quote-props consistent)a = { "a": 1, "b": 2 };// Prettier 3.2 (--quote-props as-needed)a = { "a": 1, b: 2 };// Prettier 3.3a = { a: 1, b: 2 };
Format embedded GQL in template literal statements (#16064 by @keithlayne)‚Äã
// Input/* GraphQL */ `  query foo { id }`;// Prettier 3.2/* GraphQL */ `  query foo { id }`;// Prettier 3.3/* GraphQL */ `  query foo {    id  }`;
Improve formatting of React useImperativeHandle hook (#16070 by @Jaswanth-Sriram-Veturi)‚Äã
// InputuseImperativeHandle(ref, () => {  /* Function body */}, []);// Prettier 3.2useImperativeHandle(  ref,  () => {    /* Function body */  },  [],);// Prettier 3.3useImperativeHandle(ref, () => {  /* Function body */}, []);
Allow linebreaks in member expressions in template interpolations (#16116 by @bakkot)‚Äã
When there is already a linebreak in a template interpolation, allow it to stay there even if it is a member expression. Note that (as of #15209) Prettier will not insert a linebreak inside an interpolation when one is not already present.
// Input`template with ${    very.very.very.very.very.very.very.very.very.very.very.long.chain}`;// Prettier 3.2`template with ${very.very.very.very.very.very.very.very.very.very.very.long.chain}`;// Prettier 3.3`template with ${  very.very.very.very.very.very.very.very.very.very.very.long.chain}`;
Fix dynamic import when the module source is a template string (#16267 by @fisker)‚Äã
// Inputconst module = await import(`data:text/javascript,  console.log("RUN");`);// Prettier 3.2const module = await (`data:text/javascript,  console.log("RUN");`);// Prettier 3.3const module = await import(`data:text/javascript,  console.log("RUN");`);
TypeScript‚Äã
Add missing parentheses to TSInferType (#16031 by @fisker)‚Äã
// Inputtype Foo<T> = T extends (infer U extends number) | { a: infer U extends number }  ? U  : never;// Prettier 3.2type Foo<T> = T extends infer U extends number | { a: infer U extends number }  ? U  : never;// Prettier 3.3type Foo<T> = T extends (infer U extends number) | { a: infer U extends number }  ? U  : never;
Throw errors for duplicated accessibility modifiers (#16040 by @fisker, @auvred)‚Äã
// Inputclass Foo {  public public bar() {};}// Prettier 3.2class Foo {  public bar() {}}// Prettier 3.3SyntaxError: Accessibility modifier already seen. (2:10)  1 | class Foo {> 2 |   public public bar() {};    |          ^^^^^^  3 | }
Respect --no-semi for readonly class field (#16133 by @sxzz)‚Äã
// Inputclass A {  field  readonly [expr] = true}// Prettier 3.2class A {  field;  readonly [expr] = true}// Prettier 3.3class A {  field  readonly [expr] = true}
Add necessary parentheses to yield expressions (#16194 by @kirkwaiblinger)‚Äã
Add parentheses around yield expressions if parent is an angle-bracket type assertion.
// Inputfunction* g() {  const y = <T>(yield x);}// Prettier 3.2function* g() {  const y = <T>yield x;}// Prettier 3.3function* g() {  const y = <T>(yield x);}
Markdown‚Äã
Improve wrapping for code block in markdown and jsx in mdx (#15993 by @seiyab)‚Äã
<!-- Input -->```cssimg {  filter: drop-shadow(2px 2px 0 hsl(300deg 100% 50%)) drop-shadow(      -2px -2px 0 hsl(210deg 100% 50%))    drop-shadow(2px 2px 0 hsl(120deg 100% 50%)) drop-shadow(      -2px -2px 0 hsl(30deg 100% 50%)    );}```<!-- Prettier 3.2 -->```cssimg {  filter: drop-shadow(2px 2px 0 hsl(300deg 100% 50%)) drop-shadow(      -2px -2px 0 hsl(210deg 100% 50%)    )    drop-shadow(2px 2px 0 hsl(120deg 100% 50%)) drop-shadow(      -2px -2px 0 hsl(30deg 100% 50%)    );}```<!-- Prettier 3.3 -->```cssimg {  filter: drop-shadow(2px 2px 0 hsl(300deg 100% 50%))    drop-shadow(-2px -2px 0 hsl(210deg 100% 50%))    drop-shadow(2px 2px 0 hsl(120deg 100% 50%))    drop-shadow(-2px -2px 0 hsl(30deg 100% 50%));}```
<!-- Input --><ExternalLink href="http://example.com">Prettier</ExternalLink> is an opinionated-code-formatter-that-support-many-languages-and-integrate-with-most-editors<!-- Prettier 3.2 --><ExternalLink href="http://example.com">Prettier</ExternalLink> is an opinionated-code-formatter-that-support-many-languages-and-integrate-with-most-editors<!-- Prettier 3.3 --><ExternalLink href="http://example.com">Prettier</ExternalLink> is anopinionated-code-formatter-that-support-many-languages-and-integrate-with-most-editors
Add newline between markdown footnote definitions (#16063 by @Atema)‚Äã
<!-- Input -->[^a]: Footnote A[^b]: Footnote B<!-- Prettier 3.2 -->[^a]: Footnote A[^b]: Footnote B<!-- Prettier 3.3 -->[^a]: Footnote A[^b]: Footnote B
Improve wrapping for markdown / mdx (#16158 by @seiyab)‚Äã
{ "proseWrap": "always" }
<!-- Input -->\word very-very-very-very-very-very-very-very-very-very-long-word very-very-very-very-very-very-very-very-very-very-long-word<!-- Prettier 3.2 -->\word very-very-very-very-very-very-very-very-very-very-long-word very-very-very-very-very-very-very-very-very-very-long-word<!-- Prettier 3.3 -->\word very-very-very-very-very-very-very-very-very-very-long-wordvery-very-very-very-very-very-very-very-very-very-long-word
API‚Äã
Add support for package.yaml config (#16157 by @danielbayley)‚Äã
Enable support for reading prettier configuration from package.yaml.
# package.yamlprettier:  semi: false  singleQuote: trueEdit this page\n\nPrettier 3.3: New Flow features and a lot of bug fixesJune 1, 2024 ¬∑ 7 min readSosuke SuzukiThis release includes support for new Flow features such as component and hook declarations. All of these features were implemented by the engineers on the Flow team, thank you.
If you appreciate Prettier and would like to support our work, please consider sponsoring us directly via our OpenCollective or by sponsoring the projects we depend on, such as typescript-eslint, remark, and Babel. Thank you for your continued support!
Highlights‚Äã
Flow‚Äã
declare namespace printing support (#16066 by @SamChou19815)‚Äã
// Inputdeclare namespace foo {  declare var bar: string;}// Prettier 3.2// does not parse// Prettier 3.3declare namespace foo {  declare var bar: string;}
Component syntax printing support (#16191 by @SamChou19815)‚Äã
// Inputcomponent MyComponent(a: string, b: number) renders SomeComponent {  return <OtherComponent />;}hook useMyHook(a: string) {  return useState(a);}// Prettier 3.2// does not parse// Prettier 3.3component MyComponent(a: string, b: number) renders SomeComponent {  return <OtherComponent />;}hook useMyHook(a: string) {  return useState(a);}
Support big int Enums (#16268 by @gkz)‚Äã
Adds support for big int Flow Enums.
// Inputenum E {  A = 0n,  B = 1n,}// Prettier 3.2// error// Prettier 3.3enum E {  A = 0n,  B = 1n,}
Support inexact tuple types (#16271 by @gkz)‚Äã
Adds support for Flow's inexact tuple types.
// Inputtype T = [number, ...];// Prettier 3.2type T = [number];// Prettier 3.3type T = [number, ...];
Support 'implies' type guard variant (#16272 by @gkz)‚Äã
Adds support for Flow's implies type guard variant. Also updates the flow-parser dependency.
// Inputdeclare function f(x: mixed): implies x is T;// Prettier 3.2// error// Prettier 3.3declare function f(x: mixed): implies x is T;
Other Changes‚Äã
JavaScript‚Äã
Unquote keys in import attributes (#15888 by @sosukesuzuki)‚Äã
// Inputimport json from "./mod.json" with { "type": "json" };// Prettier 3.2import json from "./mod.json" with { "type": "json" };// Prettier 3.3import json from "./mod.json" with { type: "json" };
Fix unstable object print (#16058 by @fisker)‚Äã
// Inputa = {"\a": 1, "b": 2}// Prettier 3.2 (--quote-props consistent)a = { "a": 1, "b": 2 };// Prettier 3.2 (--quote-props as-needed)a = { "a": 1, b: 2 };// Prettier 3.3a = { a: 1, b: 2 };
Format embedded GQL in template literal statements (#16064 by @keithlayne)‚Äã
// Input/* GraphQL */ `  query foo { id }`;// Prettier 3.2/* GraphQL */ `  query foo { id }`;// Prettier 3.3/* GraphQL */ `  query foo {    id  }`;
Improve formatting of React useImperativeHandle hook (#16070 by @Jaswanth-Sriram-Veturi)‚Äã
// InputuseImperativeHandle(ref, () => {  /* Function body */}, []);// Prettier 3.2useImperativeHandle(  ref,  () => {    /* Function body */  },  [],);// Prettier 3.3useImperativeHandle(ref, () => {  /* Function body */}, []);
Allow linebreaks in member expressions in template interpolations (#16116 by @bakkot)‚Äã
When there is already a linebreak in a template interpolation, allow it to stay there even if it is a member expression. Note that (as of #15209) Prettier will not insert a linebreak inside an interpolation when one is not already present.
// Input`template with ${    very.very.very.very.very.very.very.very.very.very.very.long.chain}`;// Prettier 3.2`template with ${very.very.very.very.very.very.very.very.very.very.very.long.chain}`;// Prettier 3.3`template with ${  very.very.very.very.very.very.very.very.very.very.very.long.chain}`;
Fix dynamic import when the module source is a template string (#16267 by @fisker)‚Äã
// Inputconst module = await import(`data:text/javascript,  console.log("RUN");`);// Prettier 3.2const module = await (`data:text/javascript,  console.log("RUN");`);// Prettier 3.3const module = await import(`data:text/javascript,  console.log("RUN");`);
TypeScript‚Äã
Add missing parentheses to TSInferType (#16031 by @fisker)‚Äã
// Inputtype Foo<T> = T extends (infer U extends number) | { a: infer U extends number }  ? U  : never;// Prettier 3.2type Foo<T> = T extends infer U extends number | { a: infer U extends number }  ? U  : never;// Prettier 3.3type Foo<T> = T extends (infer U extends number) | { a: infer U extends number }  ? U  : never;
Throw errors for duplicated accessibility modifiers (#16040 by @fisker, @auvred)‚Äã
// Inputclass Foo {  public public bar() {};}// Prettier 3.2class Foo {  public bar() {}}// Prettier 3.3SyntaxError: Accessibility modifier already seen. (2:10)  1 | class Foo {> 2 |   public public bar() {};    |          ^^^^^^  3 | }
Respect --no-semi for readonly class field (#16133 by @sxzz)‚Äã
// Inputclass A {  field  readonly [expr] = true}// Prettier 3.2class A {  field;  readonly [expr] = true}// Prettier 3.3class A {  field  readonly [expr] = true}
Add necessary parentheses to yield expressions (#16194 by @kirkwaiblinger)‚Äã
Add parentheses around yield expressions if parent is an angle-bracket type assertion.
// Inputfunction* g() {  const y = <T>(yield x);}// Prettier 3.2function* g() {  const y = <T>yield x;}// Prettier 3.3function* g() {  const y = <T>(yield x);}
Markdown‚Äã
Improve wrapping for code block in markdown and jsx in mdx (#15993 by @seiyab)‚Äã
<!-- Input -->```cssimg {  filter: drop-shadow(2px 2px 0 hsl(300deg 100% 50%)) drop-shadow(      -2px -2px 0 hsl(210deg 100% 50%))    drop-shadow(2px 2px 0 hsl(120deg 100% 50%)) drop-shadow(      -2px -2px 0 hsl(30deg 100% 50%)    );}```<!-- Prettier 3.2 -->```cssimg {  filter: drop-shadow(2px 2px 0 hsl(300deg 100% 50%)) drop-shadow(      -2px -2px 0 hsl(210deg 100% 50%)    )    drop-shadow(2px 2px 0 hsl(120deg 100% 50%)) drop-shadow(      -2px -2px 0 hsl(30deg 100% 50%)    );}```<!-- Prettier 3.3 -->```cssimg {  filter: drop-shadow(2px 2px 0 hsl(300deg 100% 50%))    drop-shadow(-2px -2px 0 hsl(210deg 100% 50%))    drop-shadow(2px 2px 0 hsl(120deg 100% 50%))    drop-shadow(-2px -2px 0 hsl(30deg 100% 50%));}```
<!-- Input --><ExternalLink href="http://example.com">Prettier</ExternalLink> is an opinionated-code-formatter-that-support-many-languages-and-integrate-with-most-editors<!-- Prettier 3.2 --><ExternalLink href="http://example.com">Prettier</ExternalLink> is an opinionated-code-formatter-that-support-many-languages-and-integrate-with-most-editors<!-- Prettier 3.3 --><ExternalLink href="http://example.com">Prettier</ExternalLink> is anopinionated-code-formatter-that-support-many-languages-and-integrate-with-most-editors
Add newline between markdown footnote definitions (#16063 by @Atema)‚Äã
<!-- Input -->[^a]: Footnote A[^b]: Footnote B<!-- Prettier 3.2 -->[^a]: Footnote A[^b]: Footnote B<!-- Prettier 3.3 -->[^a]: Footnote A[^b]: Footnote B
Improve wrapping for markdown / mdx (#16158 by @seiyab)‚Äã
{ "proseWrap": "always" }
<!-- Input -->\word very-very-very-very-very-very-very-very-very-very-long-word very-very-very-very-very-very-very-very-very-very-long-word<!-- Prettier 3.2 -->\word very-very-very-very-very-very-very-very-very-very-long-word very-very-very-very-very-very-very-very-very-very-long-word<!-- Prettier 3.3 -->\word very-very-very-very-very-very-very-very-very-very-long-wordvery-very-very-very-very-very-very-very-very-very-long-word
API‚Äã
Add support for package.yaml config (#16157 by @danielbayley)‚Äã
Enable support for reading prettier configuration from package.yaml.
# package.yamlprettier:  semi: false  singleQuote: trueEdit this pageNewer postPrettier 3.4: A lot of bug fixesOlder postPrettier 3.2: Support JSONC and Angular‚Äôs ICU expression\n\n\n\nPrettier 3.2: Support JSONC and Angular‚Äôs ICU expressionJanuary 12, 2024 ¬∑ 6 min readSosuke SuzukiThis release includes new features such as adding a JSONC parser, adding Angular‚Äôs ICU expressions, and many bug fixes.
We are still seeking feedback for the --experimental-ternaries option released in Prettier 3.1. Please read A curious case of the ternaries and respond via the Google Forms link provided.
Additionally, we recommend reading Prettier's CLI: A Performance Deep Dive by Fabio Spampinato. This faster CLI is slated to be released as version 4.0.
If you appreciate Prettier and would like to support our work, please consider sponsoring us directly via our OpenCollective or by sponsoring the projects we depend on, such as typescript-eslint, remark, and Babel. Thank you for your continued support!
Highlights‚Äã
JSON‚Äã
New jsonc parser added (#15831 by @fisker)‚Äã
Previously, we infer the parser of .jsonc files to be json, but if we want keep the trailing comma, we'll have to use a hacky workaround config {parser: "json5", quoteProps: "preserve", singleQuote: false}.
The new added jsonc parser:

Always quote the object keys.
Wrap strings with double quotes.
Of course, respect the trailingComma option.

Angular‚Äã
Support formatting for Angular ICU expression (#15777 by @sosukesuzuki)‚Äã
Support two kinds of Angular ICU expressions: plural and select.
<span i18n>  Updated:  {minutes, plural,    =0 {just now}    =1 {one minute ago}    other {{{minutes}} minutes ago}  }</span><span i18n>  The author is {gender, select, male {male} female {female} other {other}}</span>
Other Changes‚Äã
JavaScript‚Äã
Avoid introducing linebreaks in template interpolations (#15209 by @bakkot)‚Äã
In a template string like
`this is a long message which contains an interpolation: ${format(data)} <- like this`;
avoid adding a linebreak when formatting the expression unless one is already present or it's unavoidable due to e.g. a nested function. Previously a linebreak could be introduced whenever some interpolation in the template was sufficiently "not simple":
`this is a long message which contains an interpolation: ${format(  data,)} <- like this`;
Now it will instead be left alone.
If a linebreak is already present within the ${...}, format as normal.
Fix non-idempotent formatting of method chain with empty line (#15522 by @seiyab)‚Äã
// InputFoo.a().b();// Prettier 3.1 (first format)Foo.a().b();// Prettier 3.1 (second format)Foo.a().b();// Prettier 3.2Foo.a()  .b();
Fix formatting of ternary in function call (#15677 by @fisker)‚Äã
// InputstopDirectory = await (useCache  ? memoizedFindProjectRoot  : findProjectRootWithoutCache)(path.dirname(path.resolve(filePath)));// Prettier 3.1stopDirectory = await (useCache  ? memoizedFindProjectRoot  : findProjectRootWithoutCache)(path.dirname(path.resolve(filePath)));// Prettier 3.2stopDirectory = await (  useCache ? memoizedFindProjectRoot : findProjectRootWithoutCache)(path.dirname(path.resolve(filePath)));
Fix inconsistencies for optional-chaining (#15806 by @fisker)‚Äã
Only happens when using typescript, meriyah or other ESTree parsers except babel.
// Inputfunction someFunctionName() {  return isEqual(a.map(([t, _]) => t?.id), b.map(([t, _]) => t?.id));  return isEqual(a?.map(([t, _]) => t?.id), b?.map(([t, _]) => t?.id));}theValue = Object.entries(someLongObjectName).filter(  ([listingId]) => someListToCompareToHere.includes(listingId),);theValue = Object.entries(someLongObjectName).filter(  ([listingId]) => someListToCompareToHere?.includes(listingId),);// Prettier 3.1function someFunctionName() {  return isEqual(    a.map(([t, _]) => t?.id),    b.map(([t, _]) => t?.id),  );  return isEqual(a?.map(([t, _]) => t?.id), b?.map(([t, _]) => t?.id));}theValue = Object.entries(someLongObjectName).filter(([listingId]) =>  someListToCompareToHere.includes(listingId),);theValue = Object.entries(someLongObjectName).filter(  ([listingId]) => someListToCompareToHere?.includes(listingId),);// Prettier 3.2function someFunctionName() {  return isEqual(    a.map(([t, _]) => t?.id),    b.map(([t, _]) => t?.id),  );  return isEqual(    a?.map(([t, _]) => t?.id),    b?.map(([t, _]) => t?.id),  );}theValue = Object.entries(someLongObjectName).filter(([listingId]) =>  someListToCompareToHere.includes(listingId),);theValue = Object.entries(someLongObjectName).filter(([listingId]) =>  someListToCompareToHere?.includes(listingId),);
Fix comments in if (#15826 by @fisker)‚Äã
// Inputif (foo) for (i = 2; i > 0; i--) console.log(i); // comment 1else bar();for (;;){  if (foo) continue; // comment 2  else bar();}// Prettier 3.1Error: Comment "comment 2" was not printed. Please report this error!// Prettier 3.2if (foo)  for (i = 2; i > 0; i--) console.log(i); // comment 1else bar();for (;;) {  if (foo)    continue; // comment 2  else bar();}
TypeScript‚Äã
Improve conditional type alias layout (#15811 by @seiyab)‚Äã
// Inputtype FallbackFlags<F extends Flags | undefined> =  Equals<NonNullableFlag<F>["flags"], {}> extends true    ? Dict<any>    : NonNullableFlag<F>["flags"];// Prettier 3.1type FallbackFlags<F extends Flags | undefined> = Equals<  NonNullableFlag<F>["flags"],  {}> extends true  ? Dict<any>  : NonNullableFlag<F>["flags"];// Prettier 3.2type FallbackFlags<F extends Flags | undefined> =  Equals<NonNullableFlag<F>["flags"], {}> extends true    ? Dict<any>    : NonNullableFlag<F>["flags"];
HTML‚Äã
Fix formatting of prettier-ignored unclosed elements (#15748 by @fisker)‚Äã
<!-- Input --><!-- prettier-ignore --><h1>Hello <span>world!<!-- Prettier 3.1 --><!-- prettier-ignore --><h1><!-- Prettier 3.2 --><!-- prettier-ignore --><h1>Hello <span>world!
Angular‚Äã
Fix prettier-ignored angular control flow block (#15827 by @fisker)‚Äã
<!-- Input --><!-- prettier-ignore -->@if (condition) {  Foo} @else {  Other}<!-- Prettier 3.1 --><!-- prettier-ignore -->@if (condition) {  Foo}} @else {  Other}<!-- Prettier 3.2 --><!-- prettier-ignore -->@if (condition) {  Foo}@else {  Other}
Avoid adding colon for track in 3rd expression of for blocks (#15887 by @sosukesuzuki)‚Äã
<!-- Input -->@for (item of items; let i = $index; track block) {}<!-- Prettier 3.1 -->@for (item of items; let i = $index; track: block) {}<!-- Prettier 3.2 -->@for (item of items; let i = $index; track block) {}
Ember / Handlebars‚Äã
Preserve path literal segments (#15605 by @maxpowa)‚Äã
Fixes scenarios where an input handlebars file containing literal segments would be reformatted to unwrap the literal segments, causing syntax errors in the resulting output.
<!-- Input -->{{input.[funky<api!response]}}{{input.[this one has spaces]}}{{input.[anotherone].[0]}}<!-- Prettier 3.1 -->{{input.funky<api!response}}{{input.this one has spaces}}{{input.anotherone.0}}<!-- Prettier 3.2 -->{{input.[funky<api!response]}}{{input.[this one has spaces]}}{{input.anotherone.[0]}}
GraphQL‚Äã
Improve GraphQL union types formatting (#15870 by @ArchitGajjar)‚Äã
# Inputunion SearchResult = Conference| Festival | Concert | Venue | Conference| Festival | Concert | Venue# Prettier 3.1union SearchResult =    Conference  | Festival  | Concert  | Venue  | Conference  | Festival  | Concert  | Venue# Prettier 3.2union SearchResult =  | Conference  | Festival  | Concert  | Venue  | Conference  | Festival  | Concert  | Venue
API‚Äã
Support absolute path as plugin in config file (#15666 by @fisker)‚Äã
// prettier.config.cjsmodule.exports = {  plugins: [    // posix style    "/path/to/plugin.js",    // Windows style    "D:\\\\path\\to\\plugin.js",    // Use `require.resolve`    require.resolve("my-awesome-prettier-plugin"),  ],};
Fix getFileInfo and getSupportInfo type definitions (#15854 by @auvred)‚Äã
const plugin: Plugin = {};prettier.getFileInfo("./file.ext", {  plugins: [plugin],});prettier.getSupportInfo({ plugins: [plugin], showDeprecated: true });
Miscellaneous‚Äã
Fix false claim in docs that cursorOffset is incompatible with rangeStart/rangeEnd (#15750 by @ExplodingCabbage)‚Äã
The cursorOffset option has in fact been compatible with rangeStart/rangeEnd for over 5 years, thanks to work by @ds300. However, Prettier's documentation (including the CLI --help text) continued to claim otherwise, falsely. The documentation is now fixed.Edit this page\n\nPrettier 3.2: Support JSONC and Angular‚Äôs ICU expressionJanuary 12, 2024 ¬∑ 6 min readSosuke SuzukiThis release includes new features such as adding a JSONC parser, adding Angular‚Äôs ICU expressions, and many bug fixes.
We are still seeking feedback for the --experimental-ternaries option released in Prettier 3.1. Please read A curious case of the ternaries and respond via the Google Forms link provided.
Additionally, we recommend reading Prettier's CLI: A Performance Deep Dive by Fabio Spampinato. This faster CLI is slated to be released as version 4.0.
If you appreciate Prettier and would like to support our work, please consider sponsoring us directly via our OpenCollective or by sponsoring the projects we depend on, such as typescript-eslint, remark, and Babel. Thank you for your continued support!
Highlights‚Äã
JSON‚Äã
New jsonc parser added (#15831 by @fisker)‚Äã
Previously, we infer the parser of .jsonc files to be json, but if we want keep the trailing comma, we'll have to use a hacky workaround config {parser: "json5", quoteProps: "preserve", singleQuote: false}.
The new added jsonc parser:

Always quote the object keys.
Wrap strings with double quotes.
Of course, respect the trailingComma option.

Angular‚Äã
Support formatting for Angular ICU expression (#15777 by @sosukesuzuki)‚Äã
Support two kinds of Angular ICU expressions: plural and select.
<span i18n>  Updated:  {minutes, plural,    =0 {just now}    =1 {one minute ago}    other {{{minutes}} minutes ago}  }</span><span i18n>  The author is {gender, select, male {male} female {female} other {other}}</span>
Other Changes‚Äã
JavaScript‚Äã
Avoid introducing linebreaks in template interpolations (#15209 by @bakkot)‚Äã
In a template string like
`this is a long message which contains an interpolation: ${format(data)} <- like this`;
avoid adding a linebreak when formatting the expression unless one is already present or it's unavoidable due to e.g. a nested function. Previously a linebreak could be introduced whenever some interpolation in the template was sufficiently "not simple":
`this is a long message which contains an interpolation: ${format(  data,)} <- like this`;
Now it will instead be left alone.
If a linebreak is already present within the ${...}, format as normal.
Fix non-idempotent formatting of method chain with empty line (#15522 by @seiyab)‚Äã
// InputFoo.a().b();// Prettier 3.1 (first format)Foo.a().b();// Prettier 3.1 (second format)Foo.a().b();// Prettier 3.2Foo.a()  .b();
Fix formatting of ternary in function call (#15677 by @fisker)‚Äã
// InputstopDirectory = await (useCache  ? memoizedFindProjectRoot  : findProjectRootWithoutCache)(path.dirname(path.resolve(filePath)));// Prettier 3.1stopDirectory = await (useCache  ? memoizedFindProjectRoot  : findProjectRootWithoutCache)(path.dirname(path.resolve(filePath)));// Prettier 3.2stopDirectory = await (  useCache ? memoizedFindProjectRoot : findProjectRootWithoutCache)(path.dirname(path.resolve(filePath)));
Fix inconsistencies for optional-chaining (#15806 by @fisker)‚Äã
Only happens when using typescript, meriyah or other ESTree parsers except babel.
// Inputfunction someFunctionName() {  return isEqual(a.map(([t, _]) => t?.id), b.map(([t, _]) => t?.id));  return isEqual(a?.map(([t, _]) => t?.id), b?.map(([t, _]) => t?.id));}theValue = Object.entries(someLongObjectName).filter(  ([listingId]) => someListToCompareToHere.includes(listingId),);theValue = Object.entries(someLongObjectName).filter(  ([listingId]) => someListToCompareToHere?.includes(listingId),);// Prettier 3.1function someFunctionName() {  return isEqual(    a.map(([t, _]) => t?.id),    b.map(([t, _]) => t?.id),  );  return isEqual(a?.map(([t, _]) => t?.id), b?.map(([t, _]) => t?.id));}theValue = Object.entries(someLongObjectName).filter(([listingId]) =>  someListToCompareToHere.includes(listingId),);theValue = Object.entries(someLongObjectName).filter(  ([listingId]) => someListToCompareToHere?.includes(listingId),);// Prettier 3.2function someFunctionName() {  return isEqual(    a.map(([t, _]) => t?.id),    b.map(([t, _]) => t?.id),  );  return isEqual(    a?.map(([t, _]) => t?.id),    b?.map(([t, _]) => t?.id),  );}theValue = Object.entries(someLongObjectName).filter(([listingId]) =>  someListToCompareToHere.includes(listingId),);theValue = Object.entries(someLongObjectName).filter(([listingId]) =>  someListToCompareToHere?.includes(listingId),);
Fix comments in if (#15826 by @fisker)‚Äã
// Inputif (foo) for (i = 2; i > 0; i--) console.log(i); // comment 1else bar();for (;;){  if (foo) continue; // comment 2  else bar();}// Prettier 3.1Error: Comment "comment 2" was not printed. Please report this error!// Prettier 3.2if (foo)  for (i = 2; i > 0; i--) console.log(i); // comment 1else bar();for (;;) {  if (foo)    continue; // comment 2  else bar();}
TypeScript‚Äã
Improve conditional type alias layout (#15811 by @seiyab)‚Äã
// Inputtype FallbackFlags<F extends Flags | undefined> =  Equals<NonNullableFlag<F>["flags"], {}> extends true    ? Dict<any>    : NonNullableFlag<F>["flags"];// Prettier 3.1type FallbackFlags<F extends Flags | undefined> = Equals<  NonNullableFlag<F>["flags"],  {}> extends true  ? Dict<any>  : NonNullableFlag<F>["flags"];// Prettier 3.2type FallbackFlags<F extends Flags | undefined> =  Equals<NonNullableFlag<F>["flags"], {}> extends true    ? Dict<any>    : NonNullableFlag<F>["flags"];
HTML‚Äã
Fix formatting of prettier-ignored unclosed elements (#15748 by @fisker)‚Äã
<!-- Input --><!-- prettier-ignore --><h1>Hello <span>world!<!-- Prettier 3.1 --><!-- prettier-ignore --><h1><!-- Prettier 3.2 --><!-- prettier-ignore --><h1>Hello <span>world!
Angular‚Äã
Fix prettier-ignored angular control flow block (#15827 by @fisker)‚Äã
<!-- Input --><!-- prettier-ignore -->@if (condition) {  Foo} @else {  Other}<!-- Prettier 3.1 --><!-- prettier-ignore -->@if (condition) {  Foo}} @else {  Other}<!-- Prettier 3.2 --><!-- prettier-ignore -->@if (condition) {  Foo}@else {  Other}
Avoid adding colon for track in 3rd expression of for blocks (#15887 by @sosukesuzuki)‚Äã
<!-- Input -->@for (item of items; let i = $index; track block) {}<!-- Prettier 3.1 -->@for (item of items; let i = $index; track: block) {}<!-- Prettier 3.2 -->@for (item of items; let i = $index; track block) {}
Ember / Handlebars‚Äã
Preserve path literal segments (#15605 by @maxpowa)‚Äã
Fixes scenarios where an input handlebars file containing literal segments would be reformatted to unwrap the literal segments, causing syntax errors in the resulting output.
<!-- Input -->{{input.[funky<api!response]}}{{input.[this one has spaces]}}{{input.[anotherone].[0]}}<!-- Prettier 3.1 -->{{input.funky<api!response}}{{input.this one has spaces}}{{input.anotherone.0}}<!-- Prettier 3.2 -->{{input.[funky<api!response]}}{{input.[this one has spaces]}}{{input.anotherone.[0]}}
GraphQL‚Äã
Improve GraphQL union types formatting (#15870 by @ArchitGajjar)‚Äã
# Inputunion SearchResult = Conference| Festival | Concert | Venue | Conference| Festival | Concert | Venue# Prettier 3.1union SearchResult =    Conference  | Festival  | Concert  | Venue  | Conference  | Festival  | Concert  | Venue# Prettier 3.2union SearchResult =  | Conference  | Festival  | Concert  | Venue  | Conference  | Festival  | Concert  | Venue
API‚Äã
Support absolute path as plugin in config file (#15666 by @fisker)‚Äã
// prettier.config.cjsmodule.exports = {  plugins: [    // posix style    "/path/to/plugin.js",    // Windows style    "D:\\\\path\\to\\plugin.js",    // Use `require.resolve`    require.resolve("my-awesome-prettier-plugin"),  ],};
Fix getFileInfo and getSupportInfo type definitions (#15854 by @auvred)‚Äã
const plugin: Plugin = {};prettier.getFileInfo("./file.ext", {  plugins: [plugin],});prettier.getSupportInfo({ plugins: [plugin], showDeprecated: true });
Miscellaneous‚Äã
Fix false claim in docs that cursorOffset is incompatible with rangeStart/rangeEnd (#15750 by @ExplodingCabbage)‚Äã
The cursorOffset option has in fact been compatible with rangeStart/rangeEnd for over 5 years, thanks to work by @ds300. However, Prettier's documentation (including the CLI --help text) continued to claim otherwise, falsely. The documentation is now fixed.Edit this pageNewer postPrettier 3.3: New Flow features and a lot of bug fixesOlder postPrettier's CLI: A Performance Deep Dive\n\n\n\nPrettier's CLI: A Performance Deep DiveNovember 30, 2023 ¬∑ 24 min readFabio SpampinatoHey, I'm Fabio and I've been contracted by the Prettier team to speed up Prettier's command line interface (CLI). In this post we'll take a look at the optimizations I've discovered, the process that lead to finding them, some exciting numbers comparing the current CLI with the new one, and some guesses about what could be optimized next.
Installation‚Äã
The new work-in-progress CLI for Prettier has just been released, and you can install it now:
npm install prettier@next
It should be largely backwards compatible:
prettier . --check # Like before, but faster
If you find any issues you can temporarily use the old CLI using an environment variable:
PRETTIER_LEGACY_CLI=1 prettier . --check
You can also try it via npx, though npx itself is pretty slow:
npx prettier@next . --check
The goal is to make it close to ~100% backwards compatible, and then just ship it in a future stable release of the prettier package, replacing the current CLI.
Overview‚Äã

Prettier's CLI works roughly like in the diagram above:

There's some action we want to execute on files, for example checking if they are formatted properly.
We need to actually find all the files to execute this action on.
We need to resolve .gitignore and .prettierignore files, to figure out if some of those files are to be ignored.
We need to resolve .editorconfig files, for EditorConfig-specific formatting configurations for those files.
We need to resolve .prettierrc files, and ~10 more, for Prettier-specific formatting configurations for those files.
We need to check if each of the files matches its formatting configuration.
Finally we need to output some kind of result to the terminal.

After this high-level look at the CLI's architecture I think there are mainly 3 observations to make:

The amount of work to do scales with the number of target files, but most files are completely unchanged between runs of the CLI, because for example a commit in a large-enough repository generally only touches a fraction of the files, so if we could only remember work done in the previous run most of the work on the current run could be skipped.
There are potentially a huge number of configuration files to resolve, since our repository could have thousands of folders and each folder could have some configuration files in it, moreover if for example we find 10 different .editorconfig files, each of them could define different settings for files matching specific globs, so they all need to be combined together in a file-specific way, for each target file. But, in almost every case a repository is only going to contain just one or a handful of .editorconfig files, even if the repo has thousands of folders, so somehow this shouldn't be that expensive.
This isn't a particularly insightful observation, but if everything a program is doing is necessary, and everything done is done efficiently, then the program itself must execute efficiently as a result, so we are generally just going to try to skip unnecessary work as much as possible, and what we can't skip we'll try to make efficient.

From these observations I started writing a new CLI for Prettier from scratch, as it's often easier to rewrite things with performance in mind from the start than to patch them to be performant.
I'll use Babel's monorepo to take measurements throughout this post, as it provides a good sort of benchmark, and it should give you a sense of what the improvement will be in practice for a real, fairly large, monorepo.
Finding files fast‚Äã
First of all we need to find our target files. Prettier's current CLI uses fast-glob for that, and the code for using it may look like this:
import fastGlob from "fast-glob";const files = await fastGlob("packages/**/*.{js,cjs,mjs}", {  ignore: ["**/.git", "**/.sl", "**/.svn", "**/.hg", "**/node_modules"],  absolute: true,  dot: true,  followSymbolicLinks: false,  onlyFiles: true,  unique: true,});
If we run that on Babel's monorepo we'll see that it takes some ~220ms to find ~17k files matching our globs, out of ~30k total files found, which seems reasonably good, considering that Babel's monorepo contains over 13k folders also.
With a quick profiling we can spot that a significant amount of time is being spent checking if the found files match any of our "ignore" globs, which seem internally converted to regexes and matched one by one. So I tried merging the globs into a single one: "**/{.git,.sl,.svn,.hg,node_modules}", but it seems to get internally split up again for some reason, so that didn't change anything.
By commenting our ignore globs out entirely we can find pretty much the same files, because almost none of them got actually ignored, in just around ~180ms, which is ~20% less time. So if we could match those globs differently, in a faster way, we could lower times a bit.
This is probably a good time to mention that fast-glob does a pretty cool optimization, if our glob looks like this: packages/**/*.{js,cjs,mjs}, then it can spot that the beginning of it is entirely static, what we are actually asking it to do is to search for **/*.{js,cjs.mjs} inside the packages folder only. This optimization can be significant if there are lots of files in other folders we don't actually care about, because they will just never be scanned at all.
That got me thinking: our ignore globs are basically the same, but the static part is at the end, rather than at the start. So I wrote another library for finding files with a glob that is able to take advantage of globs with a static end too. The equivalent code for finding files with that would be this:
import readdir from "tiny-readdir-glob";const { files } = await readdir("packages/**/*.{js,cjs,mjs}", {  ignore: "**/{.git,.sl,.svn,.hg,node_modules}",  followSymlinks: false,});
And it finds the same files in just around ~130ms. By commenting out the ignore glob, just to check how much overhead that adds, it seems to take about the same amount of time, so that got optimized enough that it's hard to measure its cost in this scenario.
It got faster than we perhaps expected, for a few reasons:

Other than the ignore glob, the **/*.{js,cjs,mjs} portion of the main glob ended up getting optimized too.
Globs are matched against the relative path of a file from the root folder we started searching from, so there would be a bunch of path.relative calls in there, but if our glob looks like this: **/.git, then it doesn't matter if we calculate the relative path or not, we'll effectively be looking at the end of that string for a child path anyway, so I'm just skipping those path.relative calls completely.
Node's fs.readdir API is used internally in both libraries to scan directories, and it gives us the names of the found files and folders, not their absolute paths, which is what we actually want, but we can generate that more manually, by joining the parent path and the name with the path separator, rather than by calling path.join, which speeds things up a bit more.

Additionally this new library is ~90% smaller, about 65kb of minified code is no longer needed, which speeds up startup for the entire CLI. In much smaller repos than Babel's the new CLI might be able to find all the target files by the time the old one just finished parsing fast-glob.
Rewriting this part of the CLI may seem a little heavy-handed for the kind of speed up that we got, but the main reason for the rewrite is actually another. It would seem that there should be nothing that we could do here that would speed up the CLI by multiple seconds, since finding all the files takes less than half a second to begin with, but, the crucial point to highlight here is that for the entire CLI we not only need to find files to format, but we also need to find configuration files, and knowing every single file and folder that was found, even if they didn't match our globs, is very valuable information that will allow us to shave multiple seconds later. tiny-readdir-glob can give us that information more or less for free, so it seemed worth writing it even just for that alone.
To summarize the perhaps interesting points from this section:

If you can, always tell Prettier the extensions to look for, for example with a glob like packages/**/*.{js,cjs,mjs}. If you used packages/**/* or just packages instead in this scenario 13k extra files would need to be processed, and it would be more expensive for Prettier to discard them later on.
There's always something left to optimize or special-case for performance, even in already optimized libraries, if one has the time to look into it.
It's worth thinking about what kind of information is being thrown away, or made somewhat expensive to reconstruct. Here the glob library has to know the found files and folders just to do its work, exposing that information to the caller unlocks additional performance basically for free, in some cases.

Guesses on how to speed this up further:

This seems to be bottlenecked by the performance of fs.promises.readdir in Node, and/or the overhead of creating a Promise for each found folder. It may be worth looking into using the callback-style version of that API, and into optimization opportunities in Node itself.

Resolving configurations fast‚Äã
This is possibly the most impactful optimization behind the new CLI, and it's basically about finding configuration files as fast as possible, for each folder only ever checking once if it contains configuration files, and parsing the found configuration files only once.
A major problem behind the current CLI is that it caches resolved configurations by file path, rather than by folder path, so for example Babel's monorepo has ~17k files to format, but only 1 .editorconfig file in the whole repo, we should be parsing that file once, but instead it got parsed ~17k times. Additionally if you imagine those ~17k files being under the same folder, that folder got asked if it contained an .editorconfig file ~17k times, so actually the deeper nested into folders files to format were, the slower the entire CLI would get.
This problem got largely solved in two steps:

Resolved configuration files are cached by folder path, so it doesn't matter anymore how many files each folder contains, or how deep they are into folders.
The found folders are now being asked basically 0 times if they contain each of the ~15 supported configuration files, because we know from the previous section every single file in the repo, so we can just do a lookup in there, which ends up being a lot faster than asking the filesystem. This wouldn't matter much in most small repos, but Babel's for example has ~13k folders, and 13k * 15 checks with the filesystem added multiplied up quickly enough.

Let's now take a deeper look into how each specific supported type of configuration is resolved.
Resolving EditorConfig configurations‚Äã
Assuming from the previous step that we've parsed every .editorconfig file in the repo and that we can fetch the relevant ones for any target file in constant time, what we now want to do is to merge them together into a single configuration object, for each target file, basically.
Right away this idea kinda goes out of the window, because the editorconfig package doesn't provide a function for doing this. The closest one seems the one called parseFromFiles, which besides being deprecated it seems to do what we want, but it wants configurations as strings, so it will presumably parse them by itself after each call, which is the thing we wanted to avoid in the first place, we only want to ever parse those once.
So that package got rewritten for Prettier's needs, tiny-editorconfig provides exactly the resolve function we need, and it leaves the logic for finding configuration files to us, which is what we want anyway because we need to cache these files in a custom way.
While I was at it I've rewritten the INI parser behind it too, and it seems to be ~9x faster. It shouldn't matter much, because most repos will only have 1 .editorconfig file in them, but I enjoy writing these little parsers, and hey if you happen to have thousands of .editorconfig files in your repo you'll notice the extra performance boost!
Additionally this new library is ~82% smaller, ~50kb of minified code got deleted, which speeds up startup for the whole CLI. Also it uses the same glob library that tiny-readdir-glob uses, while in the current CLI fast-glob and editorconfig use different ones, so actually a bit more code than that got effectively deleted.
Previously it would have taken multiple seconds to resolve these files for Babel's monorepo, now it takes roughly ~100ms.
Guesses on how to speed this up further:

It should be possible in some (most?) cases to pre-resolve these configuration files for any possible file path we could encounter, for example depending on the globs in them it may be possible that we can end up with 3 possible resolved configurations at most, one for files that don't match any of the globs, one for files that match the **/*.js glob, and one for files that match the **/*.md glob. It's a bit complicated to implement though, and unclear what the speedup will be in practice, but it's something to think about for the future.

Resolving Prettier configurations‚Äã
For Prettier-specific configurations, like the .prettierrc file, we are also assuming that we've resolved all the found configuration files, and can retrieve them in constant time for any target file.
It's basically an identical situation to what we had for EditorConfig-specific configurations, so we'll basically do the same, this time hard-coding the logic for merging the configurations inside the CLI itself, as making a standalone package for it seems of basically no utility to the ecosystem.
The main aspects to consider here for the future are, in my opinion:

A large number of different configuration files are supported. In Babel's monorepo this translates to ~150k lookups in the object of known paths we created in the first step, which while not super expensive it's not free either. If this number could be reduced by a lot it would speed things up a bit.
Also some of the parsers required to parse those configuration files are relatively expensive, the json5 parser requires ~100x as much code as the smallest JSONC (JSON with Comments) parser that I know of for JavaScript, while being in some cases ~50x slower at parsing also. If fewer formats could be supported the CLI would be leaner as a result.
If we could check just once if a file named for example .prettierrc.json5 got found anywhere in the repo we could reduce the number of checks for these configuration files by an order of magnitude, because if no file with that name was found anywhere in the repo then we don't need to ask each of Babel's ~13k folders if they have it. The list of all known file names is another piece of valuable information that the glob library we are using could give us for free.

Resolving Ignore configurations‚Äã
Lastly we need to resolve .gitignore and .prettierignore files, to understand which found files to ignore. We are also assuming that we resolved all the found ones already and can fetch them in constant time for any target file.
I'm not doing any major optimizations here, I'm largely just asking node-ignore to make us a function that we can call to check if a file should be ignored.
A small optimization though is skipping calling path.relative, and the ignore function itself in some cases. Ignore files match more or less the relative path of found files from the folder where the ignore file exist in, and since we know that all the paths we are dealing with are normalized, if the absolute path of a target file doesn't start with the absolute path of the folder where each ignore file existed in then that file exists outside of the folder that the ignore file manages, so we don't have to call the ignore function that node-ignore made for us.
A decent amount of time seems spent matching the globs in these files against the found files though, hundreds of milliseconds for thousands of files, because there can just be a large number of globs in these files and a large number of files to match, which multiplied together gives us roughly the number of glob matches that will be attempted in the worst case.
The nice thing about .gitignore and .prettierignore files though is that they often repay for themselves, because the time spent parsing them and matching files against them is often less than the time needed to process every file that would have gotten discarded by them.
Guesses on how to speed this up further:

Maybe most of those globs could be sort of merged together into a single more complicated glob, and matched all together in one go by the engine, since we are not interested in knowing which exact glob matched, only if any of them did.
Maybe globs could be executed in a different order, perhaps executing cheaper and broader globs first allows us to spend less time matching globs, on average. This wouldn't make a difference if most found files are not ignored though.
Perhaps we could just remember which file paths matched or not with a cache, but it feels like this could be sped up a lot without caching too.

Caching‚Äã
At this point we've found all the files, and we've parsed all the configurations, what's left to do is doing the actual potentially expensive work of formatting each target file, and that's where caching comes in.
The current CLI has support for some form of caching, but it's opt-in, requiring an explicit --cache flag, and it doesn't remember if a file in the previous run was found to not be formatted properly, only if it was formatted properly, which can cause some unnecessary overhead in some cases, as those unformatted files would get formatted again to check if they are formatted, when we could have just remembered from the previous run that they aren't.
What we want to do here is skip the most amount of work possible, by remembering if a file was formatted or not, while generating reasonably small cache files, and while not introducing much overhead with the caching mechanism itself.
The new CLI has opt-out caching instead, so caching is always turned on, unless you explicitly disable it with a --no-cache flag, this way its benefits should reach a much higher number of people by default. Also the cache is now turned on by default because it takes everything into account, so it shouldn't be realistic for the cache to tell the CLI something that's actually incorrect. If any of the following change, then the cache, or parts of it, get invalidated automatically: Prettier's version, all resolved EditorConfig/Prettier/Ignore configurations files and their paths, formatting options provided via CLI flags, the actual content of each file, and the file path of each file.
The main trick here is that we don't want to have the cache for each file to be directly dependent on its resolved formatting configuration, because that would require merging those configuration files for each target file, serializing the resulting object, and hashing that, which can be more expensive than we'd like.
What the new CLI is doing instead is just parsing all found configurations files, and then just serializing and hashing them, which takes a constant amount of time to do no matter how many files we need to format later, and it only requires a single hash to be remembered in the cache file to account indirectly for configuration files. This is safe to do because if the paths to configuration files and their contents don't change, then any file with the same path from the previous run will necessarily be formatted with the same resolved formatting configuration object. The only potential issue is if any dependency used to parse those configuration files is actually buggy, but worst case scenario Prettier's own version can be bumped along with the buggy dependency's.
To give some numbers the current CLI checks Babel's monorepo without a cache in around ~29 seconds, the new CLI needs ~7.5s to do the same without a cache and without parallelization. If the cache file is enabled and it exists though the current CLI still needs ~22 seconds, while the new CLI needs ~1.3 seconds, and this number can probably be cut in half with more optimizations in the future.
If there's anything to remember from this long post is that if you want the CLI to go as fast as it can, you need to remember the cache file. The cache file is stored under ./node_modules/.cache/prettier by default, and its location can be customized by passing the --cache-location <path> flag. I'll say it again: if performance matters for your scenario the single biggest thing to do to speed things up here is to remember the cache file between runs.
Guesses on how to speed this up further:

An optimization opportunity would be speeding up hashing in Node. Calculating the same hashes in Bun seems ~3x faster, so surely there's some room for optimization there. I've reported that to Node, no PR has been submitted yet to address it, it seems complicated.
Potentially the parsed configuration files could be cached too, rather than just remembering their hash, but there should usually only be a handful of them, so it probably wouldn't matter too much.
Potentially more code could be deleted or lazy-loaded, speeding up the fully cached path a bit more.

Formatting‚Äã
We've now almost reached the end of the pipeline, we know which files we need to format, and we've just gotta do it.
I haven't looked into optimizing the core formatting function itself much, since for few files it seems reasonably fast already, and most of the slowdown for the CLI seemed to come from resolving configurations inefficiently and not remembering work done in the past, but that could be one of the major things to look into next. There may just not be any major and/or easy optimizations opportunities in there though, with some quick profiling I didn't spot any at least.
I've tried a couple of other things though.
First of all multiple files can be formatted in parallel, that's the default now and a --no-parallel flag is supported to opt-out of it. The --parallel-workers <int> flag can also be used to set a custom number of workers to use, for some manual fine-tuning. On my 10 core computer with parallelization the time needed to check Babel's monorepo goes down from ~7.5s to ~5.5s, which doesn't seem particularly impressive, I'm not sure why I'm not getting better scaling than that, I'd like to look deeper into this eventually. There are much larger repos and CI machines with hundreds of cores though, it may make a much bigger difference for your use case, on top of all the other optimizations.
Lastly I tried quickly replacing Prettier's format function with @wasm-fmt/biome_fmt, which is Biome's format function compiled to WASM, and I see ~3.5s for checking Babel's monorepo without parallelization, and ~2.2s with parallelization. So roughly 2x better numbers than I'm seeing with Prettier's own formatter. Potentially the improvement could be even larger if Biome's format function was compiled to a native Node module, I'm not sure.
Guesses on how to speed this up further:

I haven't done much work on the core formatting, which seems roughly at least 2x slower than optimal, but the work required to get there may be major, we'll see. There's definitely some room for improvement though.
The --parallel flag, while enabled by default, has one minor issue: if you don't have many files to format, but you have many cores to feed, you could end up feeding few files to each core, which can actually slow things down a bit. This can probably be addressed by dynamically sizing the pool depending on some heuristics. It's currently enabled by default because it slows things down a bit only in scenarios where things are pretty fast anyway, while providing a significant improvement in scenarios that would be much slower otherwise.

Outputting to the terminal‚Äã
Lastly the final step is just to output the result of the command that the CLI was asked to execute to the terminal.
There wasn't much to do here, but there were a couple of optimizations possible:

First of all in some cases, like when formatting many small files, the current CLI would very quickly output the current file's path it was formatting, just to delete it a millisecond later, after formatting was done. Doing that for thousands of files is actually surprisingly expensive because console.log calls are synchronous and block the main thread, moreover if we do that 100 times within 16ms it's a bit pointless because our screen maybe got refreshed only once or twice in that amount of time, whatever was logged we didn't even see it. The new CLI at the moment doesn't log files that are currently being formatted, shaving some hundreds of milliseconds in some cases.
Lastly the current CLI may call console.log thousands of times, depending on how many files are being formatted, while the new CLI batches logs and just performs a single console.log at the end, which in some cases can be surprisingly faster also.

I think the main room for improvement in this area is doing something visually interesting, which keeps the user busy looking at it, since perceived performance can be even more important than actual performance, but doing it in a way that doesn't keep the computer busy nearly as much.
Results‚Äã

Before we wrap up, here are some numbers I see when checking files in Babel's monorepo, with all files formatted, but 9 erroring files, with various flags, and with the current and new CLI:
prettier packages --check # 29sprettier packages --check --cache # 20sprettier@next packages --check --no-cache --no-parallel # 7.3sprettier@next packages --check --no-cache # 5.5sprettier@next packages --check # 1.3s
By default times for the same command go from ~29s to ~1.3s, for a ~22x speedup. This requires the cache file to be remembered between executions. We can probably get much closer to a 50x speedup in the future also.
If the cache file is not remembered, or if you explicitly turn caching off, or if this is the first run, then times go from ~29s to ~5.5s with parallelization, on my computer, for a ~5x speedup, which should still be pretty significant.
Worth noting again that this improvement is achieved without changing anything in Prettier's format function itself.
Results compared to Biome‚Äã
It's interesting to compare the numbers we got with the numbers that Biome, the leading Rust formatter and probably performance champion, would give us:
biome format packages# Diagnostics not shown: 25938.# Compared 28703 file(s) in 869ms# Skipped 4770 file(s)
Here Biome is checking the formatting for ~11k more files compared to our CLI, since they don't seem to be implementing .gitignore and/or .prettierignore resolution yet. There may be other, potentially significant, differences in behavior also, I'm not sure.
Manually patching our CLI to disable support for ignore files, to try to more closely mimic Biome's behavior, gives us the following number:
prettier@next packages --check --no-cache # 15s
Comparison to take with a pinch of salt because the two tools aren't doing exactly the same thing, but it's interesting to see the speed at which Biome is able to check the formatting of many files. Speed that we probably need a cache file to match.
Different approaches to try to speed things up massively for users.
Wrapping up‚Äã
The new CLI is still a work in progress, but we are excited for you to give it a try! You can install it today.
I'd be interesting to see the speedup that the new CLI enables for you, feel free to tweet those results at @PrettierCode or at @fabiospampinato directly, especially if you have some questions or ideas on how to speed things up further.Edit this page\n\nPrettier's CLI: A Performance Deep DiveNovember 30, 2023 ¬∑ 24 min readFabio SpampinatoHey, I'm Fabio and I've been contracted by the Prettier team to speed up Prettier's command line interface (CLI). In this post we'll take a look at the optimizations I've discovered, the process that lead to finding them, some exciting numbers comparing the current CLI with the new one, and some guesses about what could be optimized next.
Installation‚Äã
The new work-in-progress CLI for Prettier has just been released, and you can install it now:
npm install prettier@next
It should be largely backwards compatible:
prettier . --check # Like before, but faster
If you find any issues you can temporarily use the old CLI using an environment variable:
PRETTIER_LEGACY_CLI=1 prettier . --check
You can also try it via npx, though npx itself is pretty slow:
npx prettier@next . --check
The goal is to make it close to ~100% backwards compatible, and then just ship it in a future stable release of the prettier package, replacing the current CLI.
Overview‚Äã

Prettier's CLI works roughly like in the diagram above:

There's some action we want to execute on files, for example checking if they are formatted properly.
We need to actually find all the files to execute this action on.
We need to resolve .gitignore and .prettierignore files, to figure out if some of those files are to be ignored.
We need to resolve .editorconfig files, for EditorConfig-specific formatting configurations for those files.
We need to resolve .prettierrc files, and ~10 more, for Prettier-specific formatting configurations for those files.
We need to check if each of the files matches its formatting configuration.
Finally we need to output some kind of result to the terminal.

After this high-level look at the CLI's architecture I think there are mainly 3 observations to make:

The amount of work to do scales with the number of target files, but most files are completely unchanged between runs of the CLI, because for example a commit in a large-enough repository generally only touches a fraction of the files, so if we could only remember work done in the previous run most of the work on the current run could be skipped.
There are potentially a huge number of configuration files to resolve, since our repository could have thousands of folders and each folder could have some configuration files in it, moreover if for example we find 10 different .editorconfig files, each of them could define different settings for files matching specific globs, so they all need to be combined together in a file-specific way, for each target file. But, in almost every case a repository is only going to contain just one or a handful of .editorconfig files, even if the repo has thousands of folders, so somehow this shouldn't be that expensive.
This isn't a particularly insightful observation, but if everything a program is doing is necessary, and everything done is done efficiently, then the program itself must execute efficiently as a result, so we are generally just going to try to skip unnecessary work as much as possible, and what we can't skip we'll try to make efficient.

From these observations I started writing a new CLI for Prettier from scratch, as it's often easier to rewrite things with performance in mind from the start than to patch them to be performant.
I'll use Babel's monorepo to take measurements throughout this post, as it provides a good sort of benchmark, and it should give you a sense of what the improvement will be in practice for a real, fairly large, monorepo.
Finding files fast‚Äã
First of all we need to find our target files. Prettier's current CLI uses fast-glob for that, and the code for using it may look like this:
import fastGlob from "fast-glob";const files = await fastGlob("packages/**/*.{js,cjs,mjs}", {  ignore: ["**/.git", "**/.sl", "**/.svn", "**/.hg", "**/node_modules"],  absolute: true,  dot: true,  followSymbolicLinks: false,  onlyFiles: true,  unique: true,});
If we run that on Babel's monorepo we'll see that it takes some ~220ms to find ~17k files matching our globs, out of ~30k total files found, which seems reasonably good, considering that Babel's monorepo contains over 13k folders also.
With a quick profiling we can spot that a significant amount of time is being spent checking if the found files match any of our "ignore" globs, which seem internally converted to regexes and matched one by one. So I tried merging the globs into a single one: "**/{.git,.sl,.svn,.hg,node_modules}", but it seems to get internally split up again for some reason, so that didn't change anything.
By commenting our ignore globs out entirely we can find pretty much the same files, because almost none of them got actually ignored, in just around ~180ms, which is ~20% less time. So if we could match those globs differently, in a faster way, we could lower times a bit.
This is probably a good time to mention that fast-glob does a pretty cool optimization, if our glob looks like this: packages/**/*.{js,cjs,mjs}, then it can spot that the beginning of it is entirely static, what we are actually asking it to do is to search for **/*.{js,cjs.mjs} inside the packages folder only. This optimization can be significant if there are lots of files in other folders we don't actually care about, because they will just never be scanned at all.
That got me thinking: our ignore globs are basically the same, but the static part is at the end, rather than at the start. So I wrote another library for finding files with a glob that is able to take advantage of globs with a static end too. The equivalent code for finding files with that would be this:
import readdir from "tiny-readdir-glob";const { files } = await readdir("packages/**/*.{js,cjs,mjs}", {  ignore: "**/{.git,.sl,.svn,.hg,node_modules}",  followSymlinks: false,});
And it finds the same files in just around ~130ms. By commenting out the ignore glob, just to check how much overhead that adds, it seems to take about the same amount of time, so that got optimized enough that it's hard to measure its cost in this scenario.
It got faster than we perhaps expected, for a few reasons:

Other than the ignore glob, the **/*.{js,cjs,mjs} portion of the main glob ended up getting optimized too.
Globs are matched against the relative path of a file from the root folder we started searching from, so there would be a bunch of path.relative calls in there, but if our glob looks like this: **/.git, then it doesn't matter if we calculate the relative path or not, we'll effectively be looking at the end of that string for a child path anyway, so I'm just skipping those path.relative calls completely.
Node's fs.readdir API is used internally in both libraries to scan directories, and it gives us the names of the found files and folders, not their absolute paths, which is what we actually want, but we can generate that more manually, by joining the parent path and the name with the path separator, rather than by calling path.join, which speeds things up a bit more.

Additionally this new library is ~90% smaller, about 65kb of minified code is no longer needed, which speeds up startup for the entire CLI. In much smaller repos than Babel's the new CLI might be able to find all the target files by the time the old one just finished parsing fast-glob.
Rewriting this part of the CLI may seem a little heavy-handed for the kind of speed up that we got, but the main reason for the rewrite is actually another. It would seem that there should be nothing that we could do here that would speed up the CLI by multiple seconds, since finding all the files takes less than half a second to begin with, but, the crucial point to highlight here is that for the entire CLI we not only need to find files to format, but we also need to find configuration files, and knowing every single file and folder that was found, even if they didn't match our globs, is very valuable information that will allow us to shave multiple seconds later. tiny-readdir-glob can give us that information more or less for free, so it seemed worth writing it even just for that alone.
To summarize the perhaps interesting points from this section:

If you can, always tell Prettier the extensions to look for, for example with a glob like packages/**/*.{js,cjs,mjs}. If you used packages/**/* or just packages instead in this scenario 13k extra files would need to be processed, and it would be more expensive for Prettier to discard them later on.
There's always something left to optimize or special-case for performance, even in already optimized libraries, if one has the time to look into it.
It's worth thinking about what kind of information is being thrown away, or made somewhat expensive to reconstruct. Here the glob library has to know the found files and folders just to do its work, exposing that information to the caller unlocks additional performance basically for free, in some cases.

Guesses on how to speed this up further:

This seems to be bottlenecked by the performance of fs.promises.readdir in Node, and/or the overhead of creating a Promise for each found folder. It may be worth looking into using the callback-style version of that API, and into optimization opportunities in Node itself.

Resolving configurations fast‚Äã
This is possibly the most impactful optimization behind the new CLI, and it's basically about finding configuration files as fast as possible, for each folder only ever checking once if it contains configuration files, and parsing the found configuration files only once.
A major problem behind the current CLI is that it caches resolved configurations by file path, rather than by folder path, so for example Babel's monorepo has ~17k files to format, but only 1 .editorconfig file in the whole repo, we should be parsing that file once, but instead it got parsed ~17k times. Additionally if you imagine those ~17k files being under the same folder, that folder got asked if it contained an .editorconfig file ~17k times, so actually the deeper nested into folders files to format were, the slower the entire CLI would get.
This problem got largely solved in two steps:

Resolved configuration files are cached by folder path, so it doesn't matter anymore how many files each folder contains, or how deep they are into folders.
The found folders are now being asked basically 0 times if they contain each of the ~15 supported configuration files, because we know from the previous section every single file in the repo, so we can just do a lookup in there, which ends up being a lot faster than asking the filesystem. This wouldn't matter much in most small repos, but Babel's for example has ~13k folders, and 13k * 15 checks with the filesystem added multiplied up quickly enough.

Let's now take a deeper look into how each specific supported type of configuration is resolved.
Resolving EditorConfig configurations‚Äã
Assuming from the previous step that we've parsed every .editorconfig file in the repo and that we can fetch the relevant ones for any target file in constant time, what we now want to do is to merge them together into a single configuration object, for each target file, basically.
Right away this idea kinda goes out of the window, because the editorconfig package doesn't provide a function for doing this. The closest one seems the one called parseFromFiles, which besides being deprecated it seems to do what we want, but it wants configurations as strings, so it will presumably parse them by itself after each call, which is the thing we wanted to avoid in the first place, we only want to ever parse those once.
So that package got rewritten for Prettier's needs, tiny-editorconfig provides exactly the resolve function we need, and it leaves the logic for finding configuration files to us, which is what we want anyway because we need to cache these files in a custom way.
While I was at it I've rewritten the INI parser behind it too, and it seems to be ~9x faster. It shouldn't matter much, because most repos will only have 1 .editorconfig file in them, but I enjoy writing these little parsers, and hey if you happen to have thousands of .editorconfig files in your repo you'll notice the extra performance boost!
Additionally this new library is ~82% smaller, ~50kb of minified code got deleted, which speeds up startup for the whole CLI. Also it uses the same glob library that tiny-readdir-glob uses, while in the current CLI fast-glob and editorconfig use different ones, so actually a bit more code than that got effectively deleted.
Previously it would have taken multiple seconds to resolve these files for Babel's monorepo, now it takes roughly ~100ms.
Guesses on how to speed this up further:

It should be possible in some (most?) cases to pre-resolve these configuration files for any possible file path we could encounter, for example depending on the globs in them it may be possible that we can end up with 3 possible resolved configurations at most, one for files that don't match any of the globs, one for files that match the **/*.js glob, and one for files that match the **/*.md glob. It's a bit complicated to implement though, and unclear what the speedup will be in practice, but it's something to think about for the future.

Resolving Prettier configurations‚Äã
For Prettier-specific configurations, like the .prettierrc file, we are also assuming that we've resolved all the found configuration files, and can retrieve them in constant time for any target file.
It's basically an identical situation to what we had for EditorConfig-specific configurations, so we'll basically do the same, this time hard-coding the logic for merging the configurations inside the CLI itself, as making a standalone package for it seems of basically no utility to the ecosystem.
The main aspects to consider here for the future are, in my opinion:

A large number of different configuration files are supported. In Babel's monorepo this translates to ~150k lookups in the object of known paths we created in the first step, which while not super expensive it's not free either. If this number could be reduced by a lot it would speed things up a bit.
Also some of the parsers required to parse those configuration files are relatively expensive, the json5 parser requires ~100x as much code as the smallest JSONC (JSON with Comments) parser that I know of for JavaScript, while being in some cases ~50x slower at parsing also. If fewer formats could be supported the CLI would be leaner as a result.
If we could check just once if a file named for example .prettierrc.json5 got found anywhere in the repo we could reduce the number of checks for these configuration files by an order of magnitude, because if no file with that name was found anywhere in the repo then we don't need to ask each of Babel's ~13k folders if they have it. The list of all known file names is another piece of valuable information that the glob library we are using could give us for free.

Resolving Ignore configurations‚Äã
Lastly we need to resolve .gitignore and .prettierignore files, to understand which found files to ignore. We are also assuming that we resolved all the found ones already and can fetch them in constant time for any target file.
I'm not doing any major optimizations here, I'm largely just asking node-ignore to make us a function that we can call to check if a file should be ignored.
A small optimization though is skipping calling path.relative, and the ignore function itself in some cases. Ignore files match more or less the relative path of found files from the folder where the ignore file exist in, and since we know that all the paths we are dealing with are normalized, if the absolute path of a target file doesn't start with the absolute path of the folder where each ignore file existed in then that file exists outside of the folder that the ignore file manages, so we don't have to call the ignore function that node-ignore made for us.
A decent amount of time seems spent matching the globs in these files against the found files though, hundreds of milliseconds for thousands of files, because there can just be a large number of globs in these files and a large number of files to match, which multiplied together gives us roughly the number of glob matches that will be attempted in the worst case.
The nice thing about .gitignore and .prettierignore files though is that they often repay for themselves, because the time spent parsing them and matching files against them is often less than the time needed to process every file that would have gotten discarded by them.
Guesses on how to speed this up further:

Maybe most of those globs could be sort of merged together into a single more complicated glob, and matched all together in one go by the engine, since we are not interested in knowing which exact glob matched, only if any of them did.
Maybe globs could be executed in a different order, perhaps executing cheaper and broader globs first allows us to spend less time matching globs, on average. This wouldn't make a difference if most found files are not ignored though.
Perhaps we could just remember which file paths matched or not with a cache, but it feels like this could be sped up a lot without caching too.

Caching‚Äã
At this point we've found all the files, and we've parsed all the configurations, what's left to do is doing the actual potentially expensive work of formatting each target file, and that's where caching comes in.
The current CLI has support for some form of caching, but it's opt-in, requiring an explicit --cache flag, and it doesn't remember if a file in the previous run was found to not be formatted properly, only if it was formatted properly, which can cause some unnecessary overhead in some cases, as those unformatted files would get formatted again to check if they are formatted, when we could have just remembered from the previous run that they aren't.
What we want to do here is skip the most amount of work possible, by remembering if a file was formatted or not, while generating reasonably small cache files, and while not introducing much overhead with the caching mechanism itself.
The new CLI has opt-out caching instead, so caching is always turned on, unless you explicitly disable it with a --no-cache flag, this way its benefits should reach a much higher number of people by default. Also the cache is now turned on by default because it takes everything into account, so it shouldn't be realistic for the cache to tell the CLI something that's actually incorrect. If any of the following change, then the cache, or parts of it, get invalidated automatically: Prettier's version, all resolved EditorConfig/Prettier/Ignore configurations files and their paths, formatting options provided via CLI flags, the actual content of each file, and the file path of each file.
The main trick here is that we don't want to have the cache for each file to be directly dependent on its resolved formatting configuration, because that would require merging those configuration files for each target file, serializing the resulting object, and hashing that, which can be more expensive than we'd like.
What the new CLI is doing instead is just parsing all found configurations files, and then just serializing and hashing them, which takes a constant amount of time to do no matter how many files we need to format later, and it only requires a single hash to be remembered in the cache file to account indirectly for configuration files. This is safe to do because if the paths to configuration files and their contents don't change, then any file with the same path from the previous run will necessarily be formatted with the same resolved formatting configuration object. The only potential issue is if any dependency used to parse those configuration files is actually buggy, but worst case scenario Prettier's own version can be bumped along with the buggy dependency's.
To give some numbers the current CLI checks Babel's monorepo without a cache in around ~29 seconds, the new CLI needs ~7.5s to do the same without a cache and without parallelization. If the cache file is enabled and it exists though the current CLI still needs ~22 seconds, while the new CLI needs ~1.3 seconds, and this number can probably be cut in half with more optimizations in the future.
If there's anything to remember from this long post is that if you want the CLI to go as fast as it can, you need to remember the cache file. The cache file is stored under ./node_modules/.cache/prettier by default, and its location can be customized by passing the --cache-location <path> flag. I'll say it again: if performance matters for your scenario the single biggest thing to do to speed things up here is to remember the cache file between runs.
Guesses on how to speed this up further:

An optimization opportunity would be speeding up hashing in Node. Calculating the same hashes in Bun seems ~3x faster, so surely there's some room for optimization there. I've reported that to Node, no PR has been submitted yet to address it, it seems complicated.
Potentially the parsed configuration files could be cached too, rather than just remembering their hash, but there should usually only be a handful of them, so it probably wouldn't matter too much.
Potentially more code could be deleted or lazy-loaded, speeding up the fully cached path a bit more.

Formatting‚Äã
We've now almost reached the end of the pipeline, we know which files we need to format, and we've just gotta do it.
I haven't looked into optimizing the core formatting function itself much, since for few files it seems reasonably fast already, and most of the slowdown for the CLI seemed to come from resolving configurations inefficiently and not remembering work done in the past, but that could be one of the major things to look into next. There may just not be any major and/or easy optimizations opportunities in there though, with some quick profiling I didn't spot any at least.
I've tried a couple of other things though.
First of all multiple files can be formatted in parallel, that's the default now and a --no-parallel flag is supported to opt-out of it. The --parallel-workers <int> flag can also be used to set a custom number of workers to use, for some manual fine-tuning. On my 10 core computer with parallelization the time needed to check Babel's monorepo goes down from ~7.5s to ~5.5s, which doesn't seem particularly impressive, I'm not sure why I'm not getting better scaling than that, I'd like to look deeper into this eventually. There are much larger repos and CI machines with hundreds of cores though, it may make a much bigger difference for your use case, on top of all the other optimizations.
Lastly I tried quickly replacing Prettier's format function with @wasm-fmt/biome_fmt, which is Biome's format function compiled to WASM, and I see ~3.5s for checking Babel's monorepo without parallelization, and ~2.2s with parallelization. So roughly 2x better numbers than I'm seeing with Prettier's own formatter. Potentially the improvement could be even larger if Biome's format function was compiled to a native Node module, I'm not sure.
Guesses on how to speed this up further:

I haven't done much work on the core formatting, which seems roughly at least 2x slower than optimal, but the work required to get there may be major, we'll see. There's definitely some room for improvement though.
The --parallel flag, while enabled by default, has one minor issue: if you don't have many files to format, but you have many cores to feed, you could end up feeding few files to each core, which can actually slow things down a bit. This can probably be addressed by dynamically sizing the pool depending on some heuristics. It's currently enabled by default because it slows things down a bit only in scenarios where things are pretty fast anyway, while providing a significant improvement in scenarios that would be much slower otherwise.

Outputting to the terminal‚Äã
Lastly the final step is just to output the result of the command that the CLI was asked to execute to the terminal.
There wasn't much to do here, but there were a couple of optimizations possible:

First of all in some cases, like when formatting many small files, the current CLI would very quickly output the current file's path it was formatting, just to delete it a millisecond later, after formatting was done. Doing that for thousands of files is actually surprisingly expensive because console.log calls are synchronous and block the main thread, moreover if we do that 100 times within 16ms it's a bit pointless because our screen maybe got refreshed only once or twice in that amount of time, whatever was logged we didn't even see it. The new CLI at the moment doesn't log files that are currently being formatted, shaving some hundreds of milliseconds in some cases.
Lastly the current CLI may call console.log thousands of times, depending on how many files are being formatted, while the new CLI batches logs and just performs a single console.log at the end, which in some cases can be surprisingly faster also.

I think the main room for improvement in this area is doing something visually interesting, which keeps the user busy looking at it, since perceived performance can be even more important than actual performance, but doing it in a way that doesn't keep the computer busy nearly as much.
Results‚Äã

Before we wrap up, here are some numbers I see when checking files in Babel's monorepo, with all files formatted, but 9 erroring files, with various flags, and with the current and new CLI:
prettier packages --check # 29sprettier packages --check --cache # 20sprettier@next packages --check --no-cache --no-parallel # 7.3sprettier@next packages --check --no-cache # 5.5sprettier@next packages --check # 1.3s
By default times for the same command go from ~29s to ~1.3s, for a ~22x speedup. This requires the cache file to be remembered between executions. We can probably get much closer to a 50x speedup in the future also.
If the cache file is not remembered, or if you explicitly turn caching off, or if this is the first run, then times go from ~29s to ~5.5s with parallelization, on my computer, for a ~5x speedup, which should still be pretty significant.
Worth noting again that this improvement is achieved without changing anything in Prettier's format function itself.
Results compared to Biome‚Äã
It's interesting to compare the numbers we got with the numbers that Biome, the leading Rust formatter and probably performance champion, would give us:
biome format packages# Diagnostics not shown: 25938.# Compared 28703 file(s) in 869ms# Skipped 4770 file(s)
Here Biome is checking the formatting for ~11k more files compared to our CLI, since they don't seem to be implementing .gitignore and/or .prettierignore resolution yet. There may be other, potentially significant, differences in behavior also, I'm not sure.
Manually patching our CLI to disable support for ignore files, to try to more closely mimic Biome's behavior, gives us the following number:
prettier@next packages --check --no-cache # 15s
Comparison to take with a pinch of salt because the two tools aren't doing exactly the same thing, but it's interesting to see the speed at which Biome is able to check the formatting of many files. Speed that we probably need a cache file to match.
Different approaches to try to speed things up massively for users.
Wrapping up‚Äã
The new CLI is still a work in progress, but we are excited for you to give it a try! You can install it today.
I'd be interesting to see the speedup that the new CLI enables for you, feel free to tweet those results at @PrettierCode or at @fabiospampinato directly, especially if you have some questions or ideas on how to speed things up further.Edit this pageNewer postPrettier 3.2: Support JSONC and Angular‚Äôs ICU expressionOlder post$20k Bounty was Claimed!\n\n\n\n$20k Bounty was Claimed!November 27, 2023 ¬∑ 4 min readChristopher ChedeauPrettier, a JavaScript code formatter, has seen an incredible adoption thanks to its careful handling of the very, very, long tail of ways people can write code. At this point, the formatting logic has been solid and after our work on ternaries lands, it will be in a happy state.
This means that we can now focus on the next important aspect: Performance. Prettier has never been fast per se, but fast enough for most use cases. This has always felt unsatisfying so we wanted to do something about it. What better way than a friendly competition.
On November 9th, we put up a $10k bounty for any project written in Rust that would pass 95% of Prettier test suite. Guillermo Rauch, CEO of Vercel, matched it to bring it to $20k and napi.rs added another $2.5k. The folks at Algora even made an amazing landing page for it.

Winner Winner Chicken Dinner‚Äã
I'm so excited to report that the Biome project claimed the bounty! It has been so epic to see a dozen people come together to improve compatibility in only a short 3 weeks. You can read their full report for the details.
One question you are probably wondering is why would the Prettier team fund another project!? In practice, Prettier has been the dominant code formatter for JavaScript and as a result of a lack of competition, there has been little incentive to push on performance and fix various edge cases.
There is now a Prettier-compatible and way faster implementation in Biome that people can switch to. So Prettier has to step up its game! Thankfully Fabio Spampinato got nerd sniped with the challenge and found many extreme inefficiencies in Prettier's CLI by doing proper profiling. He will fix them by the end of the year.
By matching all the tests, the Biome project also found a lot of bugs and questionable decisions in Prettier that we will be able to improve upon.
Money, Money, Money‚Äã
I want to start by acknowledging that this bounty and the continued success of Prettier have been possible thanks to various people making significant donations. Companies: Indeed ($20,000), Frontend Masters ($10,850), Sentry ($10,529), Salesforce ($10,025), Airbnb ($8,426), Cybozu ($6,086). Individuals: Shintaro Kaneko ($1,635), Suhail Doshi ($1,000), icchiman ($500), Mariusz Nowak ($270), Beno√Æt Burgener ($270), Jeremy Combs ($270), f_subal ($230).
You may not be aware but thanks to all those donations, we've been able to pay two people $1.5k/month for the past two years to keep shipping. Fisker Cheung and Sosuke Suzuki have done an incredible job!
With the current budget, we only have 8 months of runway left, so this is a good time to solicit your donations.
Consider donating if you or your company are using Prettier and it has been helpful to you: https://opencollective.com/prettier
I would also like to give a big shout-out to Open Collective. It has been incredible for the project. From a maintainer perspective, it has been amazing as you can sign up without giving any personal information and it acts as a bank. It lets people give and receive money all around the world and handles all the tax documents properly which is a huge deal.
Prettier raised a total of $110k and redistributed $75k.
Conclusion‚Äã
While this was a one time bounty, the goal is to give an energy boost to the space of code formatting so that as an ecosystem we can make the best developer experience possible! It's been heartwarming to see so many people coming together and we hope they'll only achieve bigger things from now.Edit this page\n\n$20k Bounty was Claimed!November 27, 2023 ¬∑ 4 min readChristopher ChedeauPrettier, a JavaScript code formatter, has seen an incredible adoption thanks to its careful handling of the very, very, long tail of ways people can write code. At this point, the formatting logic has been solid and after our work on ternaries lands, it will be in a happy state.
This means that we can now focus on the next important aspect: Performance. Prettier has never been fast per se, but fast enough for most use cases. This has always felt unsatisfying so we wanted to do something about it. What better way than a friendly competition.
On November 9th, we put up a $10k bounty for any project written in Rust that would pass 95% of Prettier test suite. Guillermo Rauch, CEO of Vercel, matched it to bring it to $20k and napi.rs added another $2.5k. The folks at Algora even made an amazing landing page for it.

Winner Winner Chicken Dinner‚Äã
I'm so excited to report that the Biome project claimed the bounty! It has been so epic to see a dozen people come together to improve compatibility in only a short 3 weeks. You can read their full report for the details.
One question you are probably wondering is why would the Prettier team fund another project!? In practice, Prettier has been the dominant code formatter for JavaScript and as a result of a lack of competition, there has been little incentive to push on performance and fix various edge cases.
There is now a Prettier-compatible and way faster implementation in Biome that people can switch to. So Prettier has to step up its game! Thankfully Fabio Spampinato got nerd sniped with the challenge and found many extreme inefficiencies in Prettier's CLI by doing proper profiling. He will fix them by the end of the year.
By matching all the tests, the Biome project also found a lot of bugs and questionable decisions in Prettier that we will be able to improve upon.
Money, Money, Money‚Äã
I want to start by acknowledging that this bounty and the continued success of Prettier have been possible thanks to various people making significant donations. Companies: Indeed ($20,000), Frontend Masters ($10,850), Sentry ($10,529), Salesforce ($10,025), Airbnb ($8,426), Cybozu ($6,086). Individuals: Shintaro Kaneko ($1,635), Suhail Doshi ($1,000), icchiman ($500), Mariusz Nowak ($270), Beno√Æt Burgener ($270), Jeremy Combs ($270), f_subal ($230).
You may not be aware but thanks to all those donations, we've been able to pay two people $1.5k/month for the past two years to keep shipping. Fisker Cheung and Sosuke Suzuki have done an incredible job!
With the current budget, we only have 8 months of runway left, so this is a good time to solicit your donations.
Consider donating if you or your company are using Prettier and it has been helpful to you: https://opencollective.com/prettier
I would also like to give a big shout-out to Open Collective. It has been incredible for the project. From a maintainer perspective, it has been amazing as you can sign up without giving any personal information and it acts as a bank. It lets people give and receive money all around the world and handles all the tax documents properly which is a huge deal.
Prettier raised a total of $110k and redistributed $75k.
Conclusion‚Äã
While this was a one time bounty, the goal is to give an energy boost to the space of code formatting so that as an ecosystem we can make the best developer experience possible! It's been heartwarming to see so many people coming together and we hope they'll only achieve bigger things from now.Edit this pageNewer postPrettier's CLI: A Performance Deep DiveOlder postPrettier 3.1: New experimental ternaries formatting and Angular control flow syntax!\n\n\n\nPrettier 3.1: New experimental ternaries formatting and Angular control flow syntax!November 13, 2023 ¬∑ 12 min readSosuke SuzukiThis release adds indentation back to nested ternaries along with a new --experimental-ternaries flag to try a more novel "curious ternary" format that scales better to deeply nested conditionals. We are keen for your feedback on the experimental format before it rolls out as the default behavior later this year!
We have also added support for the control flow syntax in Angular v17. For details on the syntax, please read the official Angular release post.
If you appreciate Prettier and would like to support our work, please consider sponsoring us directly via our OpenCollective or by sponsoring the projects we depend on, such as typescript-eslint, remark, and Babel. Thank you for your continued support!
Highlights‚Äã
JavaScript‚Äã
Add indentation back to nested ternaries (#9559 by @rattrayalex)‚Äã
// Inputconst message =  i % 3 === 0 && i % 5 === 0    ? "fizzbuzz"  : i % 3 === 0    ? "fizz"  : i % 5 === 0    ? "buzz"    : String(i);// Prettier 3.0const message =  i % 3 === 0 && i % 5 === 0    ? "fizzbuzz"    : i % 3 === 0    ? "fizz"    : i % 5 === 0    ? "buzz"    : String(i);// Prettier 3.1const message =  i % 3 === 0 && i % 5 === 0    ? "fizzbuzz"    : i % 3 === 0      ? "fizz"      : i % 5 === 0        ? "buzz"        : String(i);
New Experimental Ternary Formatting: A Curious Case of the Ternaries (#13183 by @rattrayalex)‚Äã
This is implemented behind a --experimental-ternaries flag.
We move the ? in multiline ternaries to the end of the first line instead of the start of the second, along with several related changes.
While it might look weird at first, beta-testing shows that after a few hours of use, developers find it makes nested ternaries much more readable and useful.
This PR resolves one of our a highly-upvoted issue without the problems its proposed solution would reintroduce.
Please see A curious case of the ternaries for more details.
Example‚Äã
// "Questioning" ternaries for simple ternaries:const content =  children && !isEmptyChildren(children) ?    render(children)  : renderDefaultChildren();// "Case-style" ternaries for chained ternaries:const message =  i % 3 === 0 && i % 5 === 0 ? "fizzbuzz"  : i % 3 === 0 ? "fizz"  : i % 5 === 0 ? "buzz"  : String(i);// Smoothly transitions between "case-style" and "questioning" when things get complicated:const reactRouterResult =  children && !isEmptyChildren(children) ? children  : props.match ?    component ? React.createElement(component, props)    : render ? render(props)    : null  : null
Support new syntaxes supported by Babel 7.23.0 (#15485, #15486, #15487, #15488 by @sosukesuzuki)‚Äã
We support new JS syntax supported by Babel 7.23.0!
Source Phase Imports‚Äã
Please see https://github.com/tc39/proposal-source-phase-imports for more details.
import source x from "mod";
Deferred Import Evaluation‚Äã
Please see https://github.com/tc39/proposal-defer-import-eval for more details.
import defer * as ns from "mod";
Optional Chaining Assignments‚Äã
Please see https://github.com/tc39/proposal-optional-chaining-assignment for more details.
maybeObj?.prop1 = value;
Angular‚Äã
Support Angular control flow (#15606 by @DingWeizhe, @fisker)‚Äã
Added support for built-in control flow in Angular 17. Please give us feedback if you find any bugs.
For more details about control flow, please check this article on the official blog.
https://blog.angular.io/introducing-angular-v17-4d7033312e4b
Other Changes‚Äã
JavaScript‚Äã
Fix comment between parentheses and function body (#15326 by @fisker)‚Äã
// Inputfunction function_declaration()// this is a function{  return 42}(function function_expression()// this is a function{  return 42})();// Prettier 3.0function function_declaration() {  // this is a function  return 42;}(function function_expression() // this is a function{  return 42;})();// Prettier 3.1function function_declaration() {  // this is a function  return 42;}(function function_expression() {  // this is a function  return 42;})();
// Inputfunction function_declaration()// this is a function{  return 42}export default function()// this is a function{  return 42}// Prettier 3.0TypeError: Cannot read properties of null (reading 'range')// Prettier 3.1function function_declaration() {  // this is a function  return 42;}export default function () {  // this is a function  return 42;}
Disambiguate unary expressions on left hand side of instanceof and in (#15468 by @lucacasonato)‚Äã
Parentheses are now added around unary expression on the left hand side of
instanceof and in expressions, to disambiguate the unary on the left hand
side with a unary applying to the entire binary expression.
This helps catch a common mistake where a user intends to write !("x" in y)
but instead writes !"x" in y, which is really parsed as the nonsensical
(!"x") in y.
// Input!"x" in y;!("x" in y);// Prettier 3.0!"x" in y;!("x" in y);// Prettier 3.1(!"x") in y;!("x" in y);
Fix name case of selectors in styled components interpolation (#15472 by @lucasols)‚Äã
// Inputconst StyledComponent = styled.div`  margin-right: -4px;  ${Container}.isExpanded & {    transform: rotate(-180deg);  }`;const StyledComponent2 = styled.div`  margin-right: -4px;  ${abc}.camelCase + ${def}.camelCase & {    transform: rotate(-180deg);  }`;// Prettier 3.0const StyledComponent = styled.div`  margin-right: -4px;  ${Container}.isexpanded & {    transform: rotate(-180deg);  }`;const StyledComponent2 = styled.div`  margin-right: -4px;  ${abc}.camelcase + ${def}.camelCase & {    transform: rotate(-180deg);  }`;// Prettier 3.1 -- same as input
Consistently format strings containing escapes (#15525 by @sosukesuzuki)‚Äã
// Inputexport const MSG_GENERIC_OPERATION_FAILURE_BODY_1 =  goog.getMsg("That's all we know");export const MSG_GENERIC_OPERATION_FAILURE_BODY_2 =  goog.getMsg("That\'s all we know");// Prettier 3.0export const MSG_GENERIC_OPERATION_FAILURE_BODY_1 =  goog.getMsg("That's all we know");export const MSG_GENERIC_OPERATION_FAILURE_BODY_2 = goog.getMsg(  "That's all we know",);// Prettier 3.1export const MSG_GENERIC_OPERATION_FAILURE_BODY_1 =  goog.getMsg("That's all we know");export const MSG_GENERIC_OPERATION_FAILURE_BODY_2 =  goog.getMsg("That's all we know");
Improve formatting for assignment its left can break (#15547 by @sosukesuzuki)‚Äã
// Inputparams["redirectTo"] =  `${window.location.pathname}${window.location.search}${window.location.hash}`;// Prettier 3.0params[  "redirectTo"] = `${window.location.pathname}${window.location.search}${window.location.hash}`;// Prettier 3.1params["redirectTo"] =  `${window.location.pathname}${window.location.search}${window.location.hash}`;
TypeScript‚Äã
Fix unstable comment after the last parameter property (#15324 by @fisker)‚Äã
// Inputclass Class {  constructor(      private readonly paramProp: Type,    // comment  ) {  }}// Prettier 3.0class Class {  constructor(private readonly paramProp: Type) // comment  {}}// Prettier 3.0 (Second format)class Class {  constructor(    private readonly paramProp: Type, // comment  ) {}}// Prettier 3.1class Class {  constructor(    private readonly paramProp: Type,    // comment  ) {}}
Support embedded formatting in template literals annotated with as const (#15408 by @sosukesuzuki)‚Äã
// Inputconst GQL_QUERY_WITH_CONST = /* GraphQL */ `  query S { shop }` as const;// Prettier 3.0const GQL_QUERY_WITH_CONST = /* GraphQL */ `  query S { shop }` as const;// Prettier 3.1const GQL_QUERY_WITH_CONST = /* GraphQL */ `  query S {    shop  }` as const;
Fix printing comment for the last operand of union types (#15409 by @sosukesuzuki)‚Äã
// Inputtype Foo1 = (  | "thing1" // Comment1  | "thing2" // Comment2)[]; // Final comment1type Foo2 = (  | "thing1" // Comment1  | "thing2" // Comment2) & Bar; // Final comment2// Prettier 3.0type Foo1 = (  | "thing1" // Comment1  | "thing2")[]; // Comment2 // Final comment1type Foo2 = (  | "thing1" // Comment1  | "thing2") & // Comment2  Bar; // Final comment2// Prettier 3.1type Foo1 = (  | "thing1" // Comment1  | "thing2" // Comment2)[]; // Final comment1type Foo2 = (  | "thing1" // Comment1  | "thing2" // Comment2) &  Bar; // Final comment2
Keep required parenthesis around some specific keyword like identifiers in expression statement of satisfies / as expression (#15514 by @seiyab)‚Äã
// Input(type) satisfies never;// Prettier 3.0type satisfies never;// Prettier 3.1(type) satisfies never;
Flow‚Äã
Support as and satisfies expressions for Flow (#15130 by @gkz)‚Äã
// Inputconst x = y as T;// Prettier 3.0// <error: unsupported>// Prettier 3.1const x = y as T;
Support type arguments on jsx opening elements for Flow (#15429 by @SamChou19815)‚Äã
// Input<Foo<bar> />;// Prettier 3.0<Foo />;// Prettier 3.1<Foo<bar> />;
Support type arguments after typeof (#15466 by @sosukesuzuki)‚Äã
Supports type arguments after typeof syntax supported since Flow v0.127.0:
type Foo = typeof MyGenericClass<string, number>;
SCSS‚Äã
Do not split call of scss function with leading dash (#15370 by @auvred)‚Äã
/* Input */div {  width: -double(-double(3));}/* Prettier 3.0 */div {  width: -double(- double(3));}/* Prettier 3.1 */div {  width: -double(-double(3));}
HTML‚Äã
Fix formatting of menu and marquee elements (#15334 by @fisker)‚Äã
<!-- Input --><menu><li><button onclick="copy()">Copy</button></li>  <li><button onclick="cut()">Cut</button></li>  <li><button onclick="paste()">Paste</button></li></menu><marquee  direction="down"  width="250"  height="200"  behavior="alternate"  style="border:solid"><marquee behavior="alternate"> This text will bounce </marquee></marquee><!-- Prettier 3.0 --><menu  ><li><button onclick="copy()">Copy</button></li>  <li><button onclick="cut()">Cut</button></li>  <li><button onclick="paste()">Paste</button></li></menu><marquee  direction="down"  width="250"  height="200"  behavior="alternate"  style="border: solid"  ><marquee behavior="alternate"> This text will bounce </marquee></marquee><!-- Prettier 3.1 --><menu>  <li><button onclick="copy()">Copy</button></li>  <li><button onclick="cut()">Cut</button></li>  <li><button onclick="paste()">Paste</button></li></menu><marquee  direction="down"  width="250"  height="200"  behavior="alternate"  style="border: solid">  <marquee behavior="alternate">This text will bounce</marquee></marquee>
Markdown‚Äã
Encoding < and > in markdown urls (#15400 by @vivekjoshi556)‚Äã
<!-- Input -->[link](https://www.google.fr/()foo->bar)<!-- Prettier 3.0 -->[link](<https://www.google.fr/()foo->bar>)<!-- Prettier 3.1 -->[link](<https://www.google.fr/()foo-%3Ebar>)
<!-- Input -->![link](<https://www.google.fr/()foo->bar>)<!-- Prettier 3.0 -->![link](<https://www.google.fr/()foo->bar>)<!-- Prettier 3.1 -->![link](<https://www.google.fr/()foo-%3Ebar>)
Don't split lines between Japanese kana & COMBINING KATAKANA-HIRAGANA (SEMI-)VOICED SOUND MARK (#15411 by @tats-u)‚Äã
This PR fixes #15410.
Japanese (semi-)voiced kana characters can be split into two code points. For example, the following hiragana character /ka/ can be represented as:
„Åå (U+304C) ‚Üí „Åã (U+304B) + „Çô (U+3099) ‚Üí „Åã„Çô (U+304C U+3099)
Most users do not use or meet expressions like this except for file paths in macOS. However, there are some characters that can only be represented in this way. Some Japanese text that have to tell /≈ãaÃ†/ (there are not a few Japanese that do not use it these days though) from the common /ga/ use a expression "„Åã„Çö" (U+304B U+309A).
nasal„Åã„Çö„Åç„Çö„Åè„Çö„Åë„Çö„Åì„Çö„Åã„Çö„Åç„Çö„Åè„Çö„Åë„Çö„Åì„Çö„Åã„Çö„Åç„Çö„Åè„Çö„Åë„Çö„Åì„Çö„Åã„Çö„Åç„Çö„Åè„Çö„Åë„Çö„Åì„Çö
The above Markdown is formatted as in Prettier 3.0:
nasal„Åã„Çö„Åç„Çö„Åè„Çö„Åë„Çö„Åì„Çö„Åã„Çö„Åç„Çö„Åè„Çö„Åë„Çö„Åì„Çö„Åã„Çö„Åç„Çö„Åè„Çö„Åë„Çö„Åì„Çö„Åã„Çö„Åç„Çö„Åè„Çö„Åë„Çö„Åì„Çö
The semi-voiced sound mark goes to the next line but it is not correct. By this PR, the source Markdown is now formatted as:
nasal„Åã„Çö„Åç„Çö„Åè„Çö„Åë„Çö„Åì„Çö„Åã„Çö„Åç„Çö„Åè„Çö„Åë„Çö„Åì„Çö„Åã„Çö„Åç„Çö„Åè„Çö„Åë„Çö„Åì„Çö„Åã„Çö„Åç„Çö„Åè„Çö„Åë„Çö„Åì„Çö
The semi-voiced sound mark now keeps attached to the hiragana "„Åë".
API‚Äã
Accept URL in prettier.{resolveConfig,resolveConfigFile,getFileInfo}() (#15332, #15354, #15360, #15364 by @fisker)‚Äã
prettier.resolveConfig(), prettier.resolveConfigFile(), and prettier.getFileInfo() now accepts an URL with file: protocol or a url string starts with file://.
// `URL`await prettier.resolveConfig(new URL("./path/to/file", import.meta.url));await prettier.resolveConfigFile(new URL("./path/to/file", import.meta.url));await prettier.getFileInfo(new URL("./path/to/file", import.meta.url));await prettier.getFileInfo("/path/to/file", {  ignorePath: new URL("./.eslintignore", import.meta.url),});// URL stringawait prettier.resolveConfig("file:///path/to/file");await prettier.resolveConfigFile("file:///path/to/file");await prettier.getFileInfo("file:///path/to/file");await prettier.getFileInfo("/path/to/file", {  ignorePath: "file:///path/to/.eslintignore",});
CLI‚Äã
Process files only supported by plugins (#15433 by @sosukesuzuki)‚Äã
In Prettier 3.0, when specifying a directory from the CLI, only files with default supported extensions were processed.
In the following scenario, not just foo.js but also foo.astro should be formatted:
# Prettier 3.0 version$ ls .foo.js foo.astro$ cat .prettierrc{ "plugins": ["prettier-plugin-astro"] }$ prettier --write .foo.js 20ms
With this update, both foo.js and foo.astro will now be formatted:
# Prettier 3.1 branch$ prettier --write .foo.js 20msfoo.astro 32ms
You can replace prettier "**/*" --ignore-unknown with prettier . since they are equivalent now.
Show (unchanged) keyword for accessibility in CLI --write (#15467 by @ADTC)‚Äã
Previously, the only distinction between a changed file and an unchanged file was the grey color of the file name. In the example below, we can't distinguish between a.js and b.js as the color is missing. This issue is fixed by adding the (unchanged) keyword which makes the distinction accessible without color.
prettier --write .# Prettier 3.0a.js 0msb.js 0msc.js 0ms (cached)# Prettier 3.1a.js 0msb.js 0ms (unchanged)c.js 0ms (unchanged) (cached)
Fix error when formatting file names contains special characters (#15597 by @fisker)‚Äã
prettier "[with-square-brackets].js" --list# Prettier 3.0[error] Explicitly specified file was ignored due to negative glob patterns: "[with-square-brackets].js".# Prettier 3.1[with-square-brackets].jsEdit this page\n\nPrettier 3.1: New experimental ternaries formatting and Angular control flow syntax!November 13, 2023 ¬∑ 12 min readSosuke SuzukiThis release adds indentation back to nested ternaries along with a new --experimental-ternaries flag to try a more novel "curious ternary" format that scales better to deeply nested conditionals. We are keen for your feedback on the experimental format before it rolls out as the default behavior later this year!
We have also added support for the control flow syntax in Angular v17. For details on the syntax, please read the official Angular release post.
If you appreciate Prettier and would like to support our work, please consider sponsoring us directly via our OpenCollective or by sponsoring the projects we depend on, such as typescript-eslint, remark, and Babel. Thank you for your continued support!
Highlights‚Äã
JavaScript‚Äã
Add indentation back to nested ternaries (#9559 by @rattrayalex)‚Äã
// Inputconst message =  i % 3 === 0 && i % 5 === 0    ? "fizzbuzz"  : i % 3 === 0    ? "fizz"  : i % 5 === 0    ? "buzz"    : String(i);// Prettier 3.0const message =  i % 3 === 0 && i % 5 === 0    ? "fizzbuzz"    : i % 3 === 0    ? "fizz"    : i % 5 === 0    ? "buzz"    : String(i);// Prettier 3.1const message =  i % 3 === 0 && i % 5 === 0    ? "fizzbuzz"    : i % 3 === 0      ? "fizz"      : i % 5 === 0        ? "buzz"        : String(i);
New Experimental Ternary Formatting: A Curious Case of the Ternaries (#13183 by @rattrayalex)‚Äã
This is implemented behind a --experimental-ternaries flag.
We move the ? in multiline ternaries to the end of the first line instead of the start of the second, along with several related changes.
While it might look weird at first, beta-testing shows that after a few hours of use, developers find it makes nested ternaries much more readable and useful.
This PR resolves one of our a highly-upvoted issue without the problems its proposed solution would reintroduce.
Please see A curious case of the ternaries for more details.
Example‚Äã
// "Questioning" ternaries for simple ternaries:const content =  children && !isEmptyChildren(children) ?    render(children)  : renderDefaultChildren();// "Case-style" ternaries for chained ternaries:const message =  i % 3 === 0 && i % 5 === 0 ? "fizzbuzz"  : i % 3 === 0 ? "fizz"  : i % 5 === 0 ? "buzz"  : String(i);// Smoothly transitions between "case-style" and "questioning" when things get complicated:const reactRouterResult =  children && !isEmptyChildren(children) ? children  : props.match ?    component ? React.createElement(component, props)    : render ? render(props)    : null  : null
Support new syntaxes supported by Babel 7.23.0 (#15485, #15486, #15487, #15488 by @sosukesuzuki)‚Äã
We support new JS syntax supported by Babel 7.23.0!
Source Phase Imports‚Äã
Please see https://github.com/tc39/proposal-source-phase-imports for more details.
import source x from "mod";
Deferred Import Evaluation‚Äã
Please see https://github.com/tc39/proposal-defer-import-eval for more details.
import defer * as ns from "mod";
Optional Chaining Assignments‚Äã
Please see https://github.com/tc39/proposal-optional-chaining-assignment for more details.
maybeObj?.prop1 = value;
Angular‚Äã
Support Angular control flow (#15606 by @DingWeizhe, @fisker)‚Äã
Added support for built-in control flow in Angular 17. Please give us feedback if you find any bugs.
For more details about control flow, please check this article on the official blog.
https://blog.angular.io/introducing-angular-v17-4d7033312e4b
Other Changes‚Äã
JavaScript‚Äã
Fix comment between parentheses and function body (#15326 by @fisker)‚Äã
// Inputfunction function_declaration()// this is a function{  return 42}(function function_expression()// this is a function{  return 42})();// Prettier 3.0function function_declaration() {  // this is a function  return 42;}(function function_expression() // this is a function{  return 42;})();// Prettier 3.1function function_declaration() {  // this is a function  return 42;}(function function_expression() {  // this is a function  return 42;})();
// Inputfunction function_declaration()// this is a function{  return 42}export default function()// this is a function{  return 42}// Prettier 3.0TypeError: Cannot read properties of null (reading 'range')// Prettier 3.1function function_declaration() {  // this is a function  return 42;}export default function () {  // this is a function  return 42;}
Disambiguate unary expressions on left hand side of instanceof and in (#15468 by @lucacasonato)‚Äã
Parentheses are now added around unary expression on the left hand side of
instanceof and in expressions, to disambiguate the unary on the left hand
side with a unary applying to the entire binary expression.
This helps catch a common mistake where a user intends to write !("x" in y)
but instead writes !"x" in y, which is really parsed as the nonsensical
(!"x") in y.
// Input!"x" in y;!("x" in y);// Prettier 3.0!"x" in y;!("x" in y);// Prettier 3.1(!"x") in y;!("x" in y);
Fix name case of selectors in styled components interpolation (#15472 by @lucasols)‚Äã
// Inputconst StyledComponent = styled.div`  margin-right: -4px;  ${Container}.isExpanded & {    transform: rotate(-180deg);  }`;const StyledComponent2 = styled.div`  margin-right: -4px;  ${abc}.camelCase + ${def}.camelCase & {    transform: rotate(-180deg);  }`;// Prettier 3.0const StyledComponent = styled.div`  margin-right: -4px;  ${Container}.isexpanded & {    transform: rotate(-180deg);  }`;const StyledComponent2 = styled.div`  margin-right: -4px;  ${abc}.camelcase + ${def}.camelCase & {    transform: rotate(-180deg);  }`;// Prettier 3.1 -- same as input
Consistently format strings containing escapes (#15525 by @sosukesuzuki)‚Äã
// Inputexport const MSG_GENERIC_OPERATION_FAILURE_BODY_1 =  goog.getMsg("That's all we know");export const MSG_GENERIC_OPERATION_FAILURE_BODY_2 =  goog.getMsg("That\'s all we know");// Prettier 3.0export const MSG_GENERIC_OPERATION_FAILURE_BODY_1 =  goog.getMsg("That's all we know");export const MSG_GENERIC_OPERATION_FAILURE_BODY_2 = goog.getMsg(  "That's all we know",);// Prettier 3.1export const MSG_GENERIC_OPERATION_FAILURE_BODY_1 =  goog.getMsg("That's all we know");export const MSG_GENERIC_OPERATION_FAILURE_BODY_2 =  goog.getMsg("That's all we know");
Improve formatting for assignment its left can break (#15547 by @sosukesuzuki)‚Äã
// Inputparams["redirectTo"] =  `${window.location.pathname}${window.location.search}${window.location.hash}`;// Prettier 3.0params[  "redirectTo"] = `${window.location.pathname}${window.location.search}${window.location.hash}`;// Prettier 3.1params["redirectTo"] =  `${window.location.pathname}${window.location.search}${window.location.hash}`;
TypeScript‚Äã
Fix unstable comment after the last parameter property (#15324 by @fisker)‚Äã
// Inputclass Class {  constructor(      private readonly paramProp: Type,    // comment  ) {  }}// Prettier 3.0class Class {  constructor(private readonly paramProp: Type) // comment  {}}// Prettier 3.0 (Second format)class Class {  constructor(    private readonly paramProp: Type, // comment  ) {}}// Prettier 3.1class Class {  constructor(    private readonly paramProp: Type,    // comment  ) {}}
Support embedded formatting in template literals annotated with as const (#15408 by @sosukesuzuki)‚Äã
// Inputconst GQL_QUERY_WITH_CONST = /* GraphQL */ `  query S { shop }` as const;// Prettier 3.0const GQL_QUERY_WITH_CONST = /* GraphQL */ `  query S { shop }` as const;// Prettier 3.1const GQL_QUERY_WITH_CONST = /* GraphQL */ `  query S {    shop  }` as const;
Fix printing comment for the last operand of union types (#15409 by @sosukesuzuki)‚Äã
// Inputtype Foo1 = (  | "thing1" // Comment1  | "thing2" // Comment2)[]; // Final comment1type Foo2 = (  | "thing1" // Comment1  | "thing2" // Comment2) & Bar; // Final comment2// Prettier 3.0type Foo1 = (  | "thing1" // Comment1  | "thing2")[]; // Comment2 // Final comment1type Foo2 = (  | "thing1" // Comment1  | "thing2") & // Comment2  Bar; // Final comment2// Prettier 3.1type Foo1 = (  | "thing1" // Comment1  | "thing2" // Comment2)[]; // Final comment1type Foo2 = (  | "thing1" // Comment1  | "thing2" // Comment2) &  Bar; // Final comment2
Keep required parenthesis around some specific keyword like identifiers in expression statement of satisfies / as expression (#15514 by @seiyab)‚Äã
// Input(type) satisfies never;// Prettier 3.0type satisfies never;// Prettier 3.1(type) satisfies never;
Flow‚Äã
Support as and satisfies expressions for Flow (#15130 by @gkz)‚Äã
// Inputconst x = y as T;// Prettier 3.0// <error: unsupported>// Prettier 3.1const x = y as T;
Support type arguments on jsx opening elements for Flow (#15429 by @SamChou19815)‚Äã
// Input<Foo<bar> />;// Prettier 3.0<Foo />;// Prettier 3.1<Foo<bar> />;
Support type arguments after typeof (#15466 by @sosukesuzuki)‚Äã
Supports type arguments after typeof syntax supported since Flow v0.127.0:
type Foo = typeof MyGenericClass<string, number>;
SCSS‚Äã
Do not split call of scss function with leading dash (#15370 by @auvred)‚Äã
/* Input */div {  width: -double(-double(3));}/* Prettier 3.0 */div {  width: -double(- double(3));}/* Prettier 3.1 */div {  width: -double(-double(3));}
HTML‚Äã
Fix formatting of menu and marquee elements (#15334 by @fisker)‚Äã
<!-- Input --><menu><li><button onclick="copy()">Copy</button></li>  <li><button onclick="cut()">Cut</button></li>  <li><button onclick="paste()">Paste</button></li></menu><marquee  direction="down"  width="250"  height="200"  behavior="alternate"  style="border:solid"><marquee behavior="alternate"> This text will bounce </marquee></marquee><!-- Prettier 3.0 --><menu  ><li><button onclick="copy()">Copy</button></li>  <li><button onclick="cut()">Cut</button></li>  <li><button onclick="paste()">Paste</button></li></menu><marquee  direction="down"  width="250"  height="200"  behavior="alternate"  style="border: solid"  ><marquee behavior="alternate"> This text will bounce </marquee></marquee><!-- Prettier 3.1 --><menu>  <li><button onclick="copy()">Copy</button></li>  <li><button onclick="cut()">Cut</button></li>  <li><button onclick="paste()">Paste</button></li></menu><marquee  direction="down"  width="250"  height="200"  behavior="alternate"  style="border: solid">  <marquee behavior="alternate">This text will bounce</marquee></marquee>
Markdown‚Äã
Encoding < and > in markdown urls (#15400 by @vivekjoshi556)‚Äã
<!-- Input -->[link](https://www.google.fr/()foo->bar)<!-- Prettier 3.0 -->[link](<https://www.google.fr/()foo->bar>)<!-- Prettier 3.1 -->[link](<https://www.google.fr/()foo-%3Ebar>)
<!-- Input -->![link](<https://www.google.fr/()foo->bar>)<!-- Prettier 3.0 -->![link](<https://www.google.fr/()foo->bar>)<!-- Prettier 3.1 -->![link](<https://www.google.fr/()foo-%3Ebar>)
Don't split lines between Japanese kana & COMBINING KATAKANA-HIRAGANA (SEMI-)VOICED SOUND MARK (#15411 by @tats-u)‚Äã
This PR fixes #15410.
Japanese (semi-)voiced kana characters can be split into two code points. For example, the following hiragana character /ka/ can be represented as:
„Åå (U+304C) ‚Üí „Åã (U+304B) + „Çô (U+3099) ‚Üí „Åã„Çô (U+304C U+3099)
Most users do not use or meet expressions like this except for file paths in macOS. However, there are some characters that can only be represented in this way. Some Japanese text that have to tell /≈ãaÃ†/ (there are not a few Japanese that do not use it these days though) from the common /ga/ use a expression "„Åã„Çö" (U+304B U+309A).
nasal„Åã„Çö„Åç„Çö„Åè„Çö„Åë„Çö„Åì„Çö„Åã„Çö„Åç„Çö„Åè„Çö„Åë„Çö„Åì„Çö„Åã„Çö„Åç„Çö„Åè„Çö„Åë„Çö„Åì„Çö„Åã„Çö„Åç„Çö„Åè„Çö„Åë„Çö„Åì„Çö
The above Markdown is formatted as in Prettier 3.0:
nasal„Åã„Çö„Åç„Çö„Åè„Çö„Åë„Çö„Åì„Çö„Åã„Çö„Åç„Çö„Åè„Çö„Åë„Çö„Åì„Çö„Åã„Çö„Åç„Çö„Åè„Çö„Åë„Çö„Åì„Çö„Åã„Çö„Åç„Çö„Åè„Çö„Åë„Çö„Åì„Çö
The semi-voiced sound mark goes to the next line but it is not correct. By this PR, the source Markdown is now formatted as:
nasal„Åã„Çö„Åç„Çö„Åè„Çö„Åë„Çö„Åì„Çö„Åã„Çö„Åç„Çö„Åè„Çö„Åë„Çö„Åì„Çö„Åã„Çö„Åç„Çö„Åè„Çö„Åë„Çö„Åì„Çö„Åã„Çö„Åç„Çö„Åè„Çö„Åë„Çö„Åì„Çö
The semi-voiced sound mark now keeps attached to the hiragana "„Åë".
API‚Äã
Accept URL in prettier.{resolveConfig,resolveConfigFile,getFileInfo}() (#15332, #15354, #15360, #15364 by @fisker)‚Äã
prettier.resolveConfig(), prettier.resolveConfigFile(), and prettier.getFileInfo() now accepts an URL with file: protocol or a url string starts with file://.
// `URL`await prettier.resolveConfig(new URL("./path/to/file", import.meta.url));await prettier.resolveConfigFile(new URL("./path/to/file", import.meta.url));await prettier.getFileInfo(new URL("./path/to/file", import.meta.url));await prettier.getFileInfo("/path/to/file", {  ignorePath: new URL("./.eslintignore", import.meta.url),});// URL stringawait prettier.resolveConfig("file:///path/to/file");await prettier.resolveConfigFile("file:///path/to/file");await prettier.getFileInfo("file:///path/to/file");await prettier.getFileInfo("/path/to/file", {  ignorePath: "file:///path/to/.eslintignore",});
CLI‚Äã
Process files only supported by plugins (#15433 by @sosukesuzuki)‚Äã
In Prettier 3.0, when specifying a directory from the CLI, only files with default supported extensions were processed.
In the following scenario, not just foo.js but also foo.astro should be formatted:
# Prettier 3.0 version$ ls .foo.js foo.astro$ cat .prettierrc{ "plugins": ["prettier-plugin-astro"] }$ prettier --write .foo.js 20ms
With this update, both foo.js and foo.astro will now be formatted:
# Prettier 3.1 branch$ prettier --write .foo.js 20msfoo.astro 32ms
You can replace prettier "**/*" --ignore-unknown with prettier . since they are equivalent now.
Show (unchanged) keyword for accessibility in CLI --write (#15467 by @ADTC)‚Äã
Previously, the only distinction between a changed file and an unchanged file was the grey color of the file name. In the example below, we can't distinguish between a.js and b.js as the color is missing. This issue is fixed by adding the (unchanged) keyword which makes the distinction accessible without color.
prettier --write .# Prettier 3.0a.js 0msb.js 0msc.js 0ms (cached)# Prettier 3.1a.js 0msb.js 0ms (unchanged)c.js 0ms (unchanged) (cached)
Fix error when formatting file names contains special characters (#15597 by @fisker)‚Äã
prettier "[with-square-brackets].js" --list# Prettier 3.0[error] Explicitly specified file was ignored due to negative glob patterns: "[with-square-brackets].js".# Prettier 3.1[with-square-brackets].jsEdit this pageNewer post$20k Bounty was Claimed!Older postA curious case of the ternaries\n\nlinklinklinklinklinklink\n\n\n\nA curious case of the ternariesNovember 13, 2023 ¬∑ 6 min readAlex RattrayTernary formatting has always been a challenge, and we're finally addressing it in v3.1.0 with the introduction of a novel formatting style.
Read on for our journey and the motivation behind this change, along with early developer feedback and an overview of the "curious ternaries" style.
Please give the --experimental-ternaries option a try and let us know what you think!
For a quick tl;dr, see the release post.
Introduction‚Äã
Formatting nested ternaries nicely in a wide variety of scenarios is a surprisingly tricky challenge.
Developers have long found them so confusing to read that they end up just refactoring their code to an ugly series of if-else statements, often with a let declaration, an iife, or a separate function entirely.
According to beta testers, the new formatting style we've developed can take some getting used to, but ultimately allows ternaries to be practically used as a concise form of if-else-expressions in modern codebases.
Historical background‚Äã
Prettier's original, na√Øve approach ‚Äì just add indentation to each level of a nested ternary ‚Äì worked fine in simple cases, but obviously doesn't scale to long chains of nested ternaries and had other problems.
So in 2018, we replaced that with flat ternaries, which seemed like a good idea at the time, but was not received well ‚Äì¬†the issue asking it to be reverted had well over 500 upvotes.
While we did ultimately revert back to indented ternaries, we wanted to find a better way.
Over the last few years, we explored and experimented with many, many possible solutions which would be as readable as indented ternaries in common cases, but also scale to work well in a wider variety of situations.
Challenging criteria‚Äã
Ideally, we'd find one scheme that would meet our criteria:

In all cases, it should be easy to follow "what's the if", "what's the then", and "what's the else" ‚Äì¬†and what they map to.
The code should fluidly flow from a single ternary, to a chain of 2, to a long chain of simple cases, to something more complex with a few nested conditions. (Most alternatives we explored failed this test).
The syntax in JSX, TypeScript conditional expressions (which cannot be expressed with if), and normal JS should all look and feel the same.
It should scale to nested ternary chains of arbitrary length (imagine a TypeScript conditional type with dozens of alternative cases).

Indented ternaries clearly failed (4), arguably (1), and even (3) ‚Äì we have almost always printed JSX ternaries in a flat-but-readable format that unfortunately felt unnatural outside of JSX.
Many people in the community were excited about a "case-style", drawing inspiration from the match syntax from languages like Rust or OCaml, but it did not meet (2) and other goals.
A surprising solution‚Äã
The good news is that we found a formatting algorithm that met our criteria. The bad news is that it's novel, and thus unfamiliar to most developers.
In beta testing this feature, we found developers were quite skeptical when they first saw it:

But then, after using it for a bit, they didn't want to go back:

Another developer had this to say:

My first hour with the rule on, it felt a little odd. But by hour two, I‚Äôd used it a few times to solve problems that otherwise would have been ugly refactors to if statements. I‚Äôm not going back.


I used to hate nested ternaries, but I also hate restructuring a nice line of code into if-else statements. The new rule adds an understandable, linear if-else, if-else expression to the language and is much nicer than multiple ternaries as nested branches.

So we felt we had a winning formula, but we knew it could be a jarring introduction to the community.
As a result, we decided to put this new formatting behind a temporary --experimental-ternaries option for a few months, and in the meantime go ahead and ship what the community has been clamoring for: indented ternaries.
Styling Overview‚Äã
So what does this new style look like, anyway?
Here's a quick, contrived example to show the thinking behind "curious" ternaries:
const animalName =  pet.canBark() ?    pet.isScary() ?      'wolf'    : 'dog'  : pet.canMeow() ? 'cat'  : 'probably a bunny';

Every line that ends with a question mark is an "if".

If you see foo ? it's like asking a question about foo ‚Äì "if foo? then, ‚Ä¶".


Every line that starts with a : is an "else".

If you see : foo that means, "else, foo".
If you see : foo ? that means "else, if foo?".


Every line without : or ? is a "then".

If you just see foo, that means, "then foo".



And here's the code rewritten to demonstrate "case-style" ternaries:
const animalName =  pet.isScary() ? 'wolf'  : pet.canBark() ? 'dog'  : pet.canMeow() ? 'cat'  : 'probably a bunny';
You can see this is a nice concise way to get something approaching match-style syntax in JavaScript, with just the humble ternary operator (albeit missing several features).
Our new formatting is a fluid blend of "curious" ternaries (where the question mark is always at the end of the line), and "case-style" ternaries, where the question mark is in the middle of the line.
For example:
const animalName =  pet.canSqueak() ? 'mouse'  : pet.canBark() ?    pet.isScary() ?      'wolf'    : 'dog'  : pet.canMeow() ? 'cat'  : pet.canSqueak() ? 'mouse'  : 'probably a bunny';
Give us your feedback!‚Äã
We hope you like the more readable new default, and we really hope you give the new --experimental-ternaries option a try for a few weeks and let us know what you think.
Please give us feedback via Google Forms: https://forms.gle/vwEuboCobTVhEkt66Edit this page\n\nA curious case of the ternariesNovember 13, 2023 ¬∑ 6 min readAlex RattrayTernary formatting has always been a challenge, and we're finally addressing it in v3.1.0 with the introduction of a novel formatting style.
Read on for our journey and the motivation behind this change, along with early developer feedback and an overview of the "curious ternaries" style.
Please give the --experimental-ternaries option a try and let us know what you think!
For a quick tl;dr, see the release post.
Introduction‚Äã
Formatting nested ternaries nicely in a wide variety of scenarios is a surprisingly tricky challenge.
Developers have long found them so confusing to read that they end up just refactoring their code to an ugly series of if-else statements, often with a let declaration, an iife, or a separate function entirely.
According to beta testers, the new formatting style we've developed can take some getting used to, but ultimately allows ternaries to be practically used as a concise form of if-else-expressions in modern codebases.
Historical background‚Äã
Prettier's original, na√Øve approach ‚Äì just add indentation to each level of a nested ternary ‚Äì worked fine in simple cases, but obviously doesn't scale to long chains of nested ternaries and had other problems.
So in 2018, we replaced that with flat ternaries, which seemed like a good idea at the time, but was not received well ‚Äì¬†the issue asking it to be reverted had well over 500 upvotes.
While we did ultimately revert back to indented ternaries, we wanted to find a better way.
Over the last few years, we explored and experimented with many, many possible solutions which would be as readable as indented ternaries in common cases, but also scale to work well in a wider variety of situations.
Challenging criteria‚Äã
Ideally, we'd find one scheme that would meet our criteria:

In all cases, it should be easy to follow "what's the if", "what's the then", and "what's the else" ‚Äì¬†and what they map to.
The code should fluidly flow from a single ternary, to a chain of 2, to a long chain of simple cases, to something more complex with a few nested conditions. (Most alternatives we explored failed this test).
The syntax in JSX, TypeScript conditional expressions (which cannot be expressed with if), and normal JS should all look and feel the same.
It should scale to nested ternary chains of arbitrary length (imagine a TypeScript conditional type with dozens of alternative cases).

Indented ternaries clearly failed (4), arguably (1), and even (3) ‚Äì we have almost always printed JSX ternaries in a flat-but-readable format that unfortunately felt unnatural outside of JSX.
Many people in the community were excited about a "case-style", drawing inspiration from the match syntax from languages like Rust or OCaml, but it did not meet (2) and other goals.
A surprising solution‚Äã
The good news is that we found a formatting algorithm that met our criteria. The bad news is that it's novel, and thus unfamiliar to most developers.
In beta testing this feature, we found developers were quite skeptical when they first saw it:

But then, after using it for a bit, they didn't want to go back:

Another developer had this to say:

My first hour with the rule on, it felt a little odd. But by hour two, I‚Äôd used it a few times to solve problems that otherwise would have been ugly refactors to if statements. I‚Äôm not going back.


I used to hate nested ternaries, but I also hate restructuring a nice line of code into if-else statements. The new rule adds an understandable, linear if-else, if-else expression to the language and is much nicer than multiple ternaries as nested branches.

So we felt we had a winning formula, but we knew it could be a jarring introduction to the community.
As a result, we decided to put this new formatting behind a temporary --experimental-ternaries option for a few months, and in the meantime go ahead and ship what the community has been clamoring for: indented ternaries.
Styling Overview‚Äã
So what does this new style look like, anyway?
Here's a quick, contrived example to show the thinking behind "curious" ternaries:
const animalName =  pet.canBark() ?    pet.isScary() ?      'wolf'    : 'dog'  : pet.canMeow() ? 'cat'  : 'probably a bunny';

Every line that ends with a question mark is an "if".

If you see foo ? it's like asking a question about foo ‚Äì "if foo? then, ‚Ä¶".


Every line that starts with a : is an "else".

If you see : foo that means, "else, foo".
If you see : foo ? that means "else, if foo?".


Every line without : or ? is a "then".

If you just see foo, that means, "then foo".



And here's the code rewritten to demonstrate "case-style" ternaries:
const animalName =  pet.isScary() ? 'wolf'  : pet.canBark() ? 'dog'  : pet.canMeow() ? 'cat'  : 'probably a bunny';
You can see this is a nice concise way to get something approaching match-style syntax in JavaScript, with just the humble ternary operator (albeit missing several features).
Our new formatting is a fluid blend of "curious" ternaries (where the question mark is always at the end of the line), and "case-style" ternaries, where the question mark is in the middle of the line.
For example:
const animalName =  pet.canSqueak() ? 'mouse'  : pet.canBark() ?    pet.isScary() ?      'wolf'    : 'dog'  : pet.canMeow() ? 'cat'  : pet.canSqueak() ? 'mouse'  : 'probably a bunny';
Give us your feedback!‚Äã
We hope you like the more readable new default, and we really hope you give the new --experimental-ternaries option a try for a few weeks and let us know what you think.
Please give us feedback via Google Forms: https://forms.gle/vwEuboCobTVhEkt66Edit this pageNewer postPrettier 3.1: New experimental ternaries formatting and Angular control flow syntax!Older postPrettier 3.0: Hello, ECMAScript Modules!\n\n\n\nPrettier 3.0: Hello, ECMAScript Modules!July 5, 2023 ¬∑ 36 min readSosuke SuzukiWe are excited to announce the release of the new version of Prettier!
We have made the migration to using ECMAScript Modules for all our source code. This change has significantly improved the development experience for the Prettier team. Please rest assured that when using Prettier as a library, you can still use it as CommonJS as well.
This update comes with several breaking changes. One notable example is the alteration in markdown formatting - spaces are no longer inserted between Latin characters and Chinese or Japanese characters. We'd like to extend our gratitude to Tatsunori Uchino, who has made significant contributions to Prettier over the past year, particularly with this feature. Additionally, the default value of trailingComma has been changed to "all".
Another important change in this release is the significant overhaul of the plugin interface. Prettier now supports plugins written using ECMAScript Modules and async parsers. If you're a plugin developer, please exercise caution while updating. You can find the migration guide here. As always, we welcome bug reports and feedback!
This release also includes numerous formatting improvements and bug fixes.
If you appreciate Prettier and would like to support our work, please consider sponsoring us directly via our OpenCollective or by sponsoring the projects we depend on, such as typescript-eslint, remark, and Babel. Thank you for your continued support!
Highlights‚Äã
Markdown‚Äã
Improve handling of whitespace for Chinese, Japanese, and Korean (#11597 by @tats-u)‚Äã
Stop inserting spaces between Chinese or Japanese and Western characters‚Äã
Previously, Prettier would insert spaces between Chinese or Japanese and Western characters (letters and digits). While some people prefer this style, it isn‚Äôt standard, and is in fact contrary to official guidelines. Please see here for more details. We decided it‚Äôs not Prettier‚Äôs job to enforce a particular style in this case, so spaces aren‚Äôt inserted anymore, while existing ones are preserved. If you need a tool for enforcing spacing style, consider textlint-ja or lint-md (rules space-round-alphabet and space-round-number).
The tricky part of this change were ambiguous line breaks between Chinese or Japanese and Western characters. When Prettier unwraps text, it needs to decide whether such a line break should be simply removed or replaced with a space. For that Prettier examines the surrounding text and infers the preferred style.
<!-- Input -->Êº¢Â≠óAlphabets„Å≤„Çâ„Åå„Å™12345„Ç´„Çø„Ç´„Éä67890Êº¢Â≠ó Alphabets „Å≤„Çâ„Åå„Å™ 12345 „Ç´„Çø„Ç´„Éä 67890<!-- Prettier 2.8 -->Êº¢Â≠ó Alphabets „Å≤„Çâ„Åå„Å™ 12345 „Ç´„Çø„Ç´„Éä 67890Êº¢Â≠ó Alphabets „Å≤„Çâ„Åå„Å™ 12345 „Ç´„Çø„Ç´„Éä 67890<!-- Prettier 3.0 -->Êº¢Â≠óAlphabets„Å≤„Çâ„Åå„Å™12345„Ç´„Çø„Ç´„Éä67890Êº¢Â≠ó Alphabets „Å≤„Çâ„Åå„Å™ 12345 „Ç´„Çø„Ç´„Éä 67890
Comply to line breaking rules in Chinese and Japanese‚Äã
There are rules that prohibit certain characters from appearing at the beginning or the end of a line in Chinese and Japanese. E.g., full stop characters „ÄÇ, Ôºé, and . shouldn‚Äôt start a line whereas Ôºà shouldn‚Äôt end a line. Prettier now follows these rules when it wraps text, that is when proseWrap is set to always.
<!-- Input -->HTCPCP„ÅÆ„Ç®„É©„Éº418„ÅØ„ÄÅ„ÉÜ„Ç£„Éº„Éù„ÉÉ„Éà„Å´„Ç≥„Éº„Éí„Éº„ÇíÊ∑πÔºà„ÅÑÔºâ„Çå„Åï„Åõ„Çà„ÅÜ„Å®„Åó„Åü„Å®„Åç„Å´Ëøî„Åï„Çå„Çã„Çπ„ÉÜ„Éº„Çø„Çπ„Ç≥„Éº„Éâ„Å†„ÄÇ<!-- Prettier 2.8 with --prose-wrap always --print-width 8 -->HTCPCP „ÅÆ„Ç®„É©„Éº418 „ÅØ„ÄÅ„ÉÜ„Ç£„Éº„Éù„ÉÉ„Éà„Å´„Ç≥„Éº„Éí„Éº„ÇíÊ∑πÔºà„ÅÑÔºâ„Çå„Åï„Åõ„Çà„ÅÜ„Å®„Åó„Åü„Å®„Åç„Å´Ëøî„Åï„Çå„Çã„Çπ„ÉÜ„Éº„Çø„Çπ„Ç≥„Éº„Éâ„Å†„ÄÇ<!-- Prettier 3.0 with the same options -->HTCPCP„ÅÆ„Ç®„É©„Éº418„ÅØ„ÄÅ„ÉÜ„Ç£„Éº„Éù„ÉÉ„Éà„Å´„Ç≥„Éº„Éí„Éº„ÇíÊ∑πÔºà„ÅÑÔºâ„Çå„Åï„Åõ„Çà„ÅÜ„Å®„Åó„Åü„Å®„Åç„Å´Ëøî„Åï„Çå„Çã„Çπ„ÉÜ„Éº„Çø„Çπ„Ç≥„Éº„Éâ„Å†„ÄÇ
Do not break lines inside Korean words‚Äã
Korean uses spaces to divide words, and an inappropriate division may change the meaning of a sentence:

ÎÖ∏ÎûòÎ•º Î™ªÌï¥Ïöî.: I‚Äôm not good at singing.
ÎÖ∏ÎûòÎ•º Î™ª Ìï¥Ïöî.: I can‚Äôt sing (for some reason).

Previously, when proseWrap was set to always, successive Hangul characters could get split by a line break, which could later be converted to a space when the document is edited and reformatted. This doesn‚Äôt happen anymore. Korean text is now wrapped like English.
<!-- Input -->ÎÖ∏ÎûòÎ•º Î™ªÌï¥Ïöî.<!-- Prettier 2.8 with --prose-wrap always --print-width 9 -->ÎÖ∏ÎûòÎ•º Î™ªÌï¥Ïöî.<!-- Prettier 2.8, subsequent reformat with --prose-wrap always --print-width 80 -->ÎÖ∏ÎûòÎ•º Î™ª Ìï¥Ïöî.<!-- Prettier 3.0 with --prose-wrap always --print-width 9 -->ÎÖ∏ÎûòÎ•ºÎ™ªÌï¥Ïöî.<!-- Prettier 3.0, subsequent reformat with --prose-wrap always --print-width 80 -->ÎÖ∏ÎûòÎ•º Î™ªÌï¥Ïöî.
A line break between Hangul and non-Hangul letters and digits is converted to a space when Prettier unwraps the text. Consider this example:

3Î∂Ñ Í∏∞Îã§Î†§ Ï£ºÏßÄ.

In this sentence, if you break the line between ‚Äú3‚Äù and ‚ÄúÎ∂Ñ‚Äù, a space will be inserted there when the text gets unwrapped.
API‚Äã
Support plugins with async parsers (#12748 by @fisker, #13211 by @thorn0 and @fisker)‚Äã
parse function in a plugin can return a Promise now.
In order to support async parsers for embedded languages, we had to introduce a breaking change to the plugin API. Namely, the embed method of a printer has now to match a completely new signature, incompatible with previous versions. If you're a plugin author and your plugins don't define embed, you have nothing to worry about, otherwise see the docs for details.
Also, the preprocess method of a printer can return a promise now.
Support config files in ESM (#13130 by @fisker)‚Äã
Config files in ESM are supported, supported config file names:

prettier.config.js (in place with {"type": "module"} in package.json)
.prettierrc.js (same as above)
prettier.config.mjs
.prettierrc.mjs.

export default {  trailingComma: "es5",  tabWidth: 4,  semi: false,  singleQuote: true,};
Shareable config package can also be a pure ESM package.
Breaking Changes‚Äã
JavaScript‚Äã
Change the default value for trailingComma to all (#11479 by @fisker, #13143 by @sosukesuzuki)‚Äã
Since version 2.0. we've changed the default value for trailingComma to es5.
Internet Explorer, the last browser to not allow trailing commas in function calls, has been unsupported on June 15, 2022. Accordingly, change the default value for trailingComma to all.
If the old behavior is still preferred, please configure Prettier with { "trailingComma": "es5" }.
Remove Flow syntax support from babel parser (#14314 by @fisker, @thorn0)‚Äã
For historical reasons, Prettier used to recognize Flow syntax in JS files when the parser option was set to babel even if the file didn't include the @flow pragma. This support was limited and bad for performance, so it has been removed in Prettier 3.0. Prettier with the babel parser still automatically switches to the Flow syntax if it finds the @flow pragma or the file has the .js.flow extension.
Flow‚Äã
Remove support for Flow comments (#13687, #13703 by @thorn0)‚Äã
Being a kind of preprocessor, Flow comments AKA comment types are processed on the token level and can't be represented in an AST in the general case. Flow builds the AST as if these special comment tokens didn't exist. Example:
/*:: if */ (x) + y;
This is parsed as if (x) +y; by Flow and as x + y; by JS parsers that don't support Flow.
Previously, for some special cases, Prettier tried to detect that this syntax was used and to preserve it. As an attempt to solve an unsolvable problem, this limited support was fragile and riddled with bugs, so it has been removed. Now if the parser option is set to flow or babel-flow, Flow comments will be parsed and reprinted like normal code. If a parser that doesn't support Flow is used, they will be treated like usual comments.
// Inputlet a /*: foo */ = b;// Prettier 2.8let a /*: foo */ = b;// Prettier 3.0 with --parser flowlet a: foo = b;// Prettier 3.0 with --parser babellet a /*: foo */ = b;
Print trailing comma in type parameters and tuple types when --trailing-comma=es5 (#14086, #14085 by @fisker)‚Äã
// Inputtype Foo =  [  {    from: string,    to: string,  }, // <- 1];type Foo = Promise<  | { ok: true, bar: string, baz: SomeOtherLongType }  | { ok: false, bar: SomeOtherLongType }, // <- 2>;// Prettier 2.8type Foo = [  {    from: string,    to: string,  } // <- 1];type Foo = Promise<  | { ok: true, bar: string, baz: SomeOtherLongType }  | { ok: false, bar: SomeOtherLongType } // <- 2>;// Prettier 3.0type Foo = [  {    from: string,    to: string,  }, // <- 1];type Foo = Promise<  | { ok: true, bar: string, baz: SomeOtherLongType }  | { ok: false, bar: SomeOtherLongType }, // <- 2>;
CSS‚Äã
Add the pure css parser (#7933, #9092, #9093 by @fisker)‚Äã
Previously, when --parser=css was passed, Prettier tried to parse the content using postcss-scss and postcss-less. This caused confusion, and made syntax errors difficult to spot. Now --parser=css works only with the vanilla CSS syntax.
If you use parser="css" for your .less/.scss files, update it to the correct parser or remove the parser option to let Prettier auto-detect the parser by the file extension.
/* Input *//* Less Syntax with `--parser=css` */a {.bordered();}/* Prettier 2.8 *//* Less Syntax with `--parser=css` */a {  .bordered();}/* Prettier 3.0 */SyntaxError: (postcss) CssSyntaxError Unknown word (2:4)  1 | /* Less Syntax with `--parser=css` */> 2 | a {.bordered();}
/* Input *//* Scss Syntax with `--parser=css` */::before {content: #{$foo}}/* Prettier 2.8 *//* Scss Syntax with `--parser=css` */::before {  content: #{$foo};}/* Prettier 3.0 */SyntaxError: (postcss) CssSyntaxError Unknown word (2:22)  1 | /* Scss Syntax with `--parser=css` */> 2 | ::before {content: #{$foo}}
GraphQL‚Äã
Drop support for "comma separated interfaces" syntax (#12835 by @fisker)‚Äã
# Inputtype Type1 implements A, B {a: a}# Prettier 2.8type Type1 implements A, B {  a: a}# Prettier 3.0SyntaxError: Syntax Error: Unexpected Name "B". (1:26)> 1 | type Type1 implements A, B {a: a}
API‚Äã
Drop support for Node.js 10 and 12 (#11830 by @fisker, #13118 by @sosukesuzuki)‚Äã
The minimal required Node.js version is v14
Change public APIs to asynchronous (#12574, #12788, #12790, #13265 by @fisker)‚Äã

prettier.format() returns Promise<string>
prettier.formatWithCursor() returns Promise<{formatted: string, cursorOffset: number}>
prettier.formatAST() returns Promise<string>
prettier.check() returns Promise<boolean>
prettier.getSupportInfo() returns Promise
prettier.clearConfigCache() returns Promise<void>
prettier.resolveConfig.sync is removed
prettier.resolveConfigFile.sync is removed
prettier.getFileInfo.sync is removed

If you still need sync APIs, you can try @prettier/sync
Npm package file structures changed (#12740 by @fisker, #13530 by @fisker, #14570 by @fisker)‚Äã
File structures changes:

bin-prettier.js -> bin/prettier.cjs
esm/standalone.mjs -> standalone.mjs
esm/parser-angular.mjs -> plugins/angular.mjs
parser-angular.js -> plugins/angular.js
esm/parser-babel.mjs -> plugins/babel.mjs
parser-babel.js -> plugins/babel.js
esm/parser-espree.mjs -> plugins/acorn-and-espree.mjs
parser-espree.js -> plugins/acorn.js
global object renamed prettierPlugins.espree -> prettierPlugins.acorn
esm/parser-flow.mjs -> plugins/flow.mjs
parser-flow.js -> plugins/flow.js
esm/parser-glimmer.mjs -> plugins/glimmer.mjs
parser-glimmer.js -> plugins/glimmer.js
esm/parser-graphql.mjs -> plugins/graphql.mjs
parser-graphql.js -> plugins/graphql.js
esm/parser-html.mjs -> plugins/html.mjs
parser-html.js -> plugins/html.js
esm/parser-markdown.mjs -> plugins/markdown.mjs
parser-markdown.js -> plugins/markdown.js
esm/parser-meriyah.mjs -> plugins/meriyah.mjs
parser-meriyah.js -> plugins/meriyah.js
esm/parser-postcss.mjs -> plugins/postcss.mjs
parser-postcss.js -> plugins/postcss.js
esm/parser-typescript.mjs -> plugins/typescript.mjs
parser-typescript.js -> plugins/typescript.js
esm/parser-yaml.mjs -> plugins/yaml.mjs
parser-yaml.js -> plugins/yaml.js

Check full list on https://unpkg.com/browse/prettier@3.0.0/.
A new plugin has been added:

plugins/estree.mjs (ESM version)
plugins/estree.js (UMD version)

If you use standalone version, this plugin should be loaded when printing JavaScript, TypeScript, Flow, or JSON.
import { format } from "prettier/standalone";- import prettierPluginBabel from "prettier/parser-babel";+ import * as prettierPluginBabel from "prettier/plugins/babel";+ import * as prettierPluginEstree from "prettier/plugins/estree";console.log(-  format(code, {+  await format(code, {      parser: "babel",-     plugins: [prettierPluginBabel],+     plugins: [prettierPluginBabel, prettierPluginEstree],   }));
- node ./node_modules/prettier/bin-prettier.js . --write+ node ./node_modules/prettier/bin/prettier.cjs . --write
Support plugins in ESM (#13201 by @fisker)‚Äã
Since v3.0.0, we load plugins via import() instead of require(), plugins can be ESM modules now.
If you use --plugin by directory path, or file path without extensions, the plugin may not able to load.
- prettier . --plugin=path/to/my-plugin-directory+ prettier . --plugin=path/to/my-plugin-directory/index.js
- prettier . --plugin=path/to/my-plugin-file+ prettier . --plugin=path/to/my-plugin-file.js
Update prettier.doc (#13203, #14456 by @fisker)‚Äã
prettier.doc.builders.concat was deprecated in v2.3.0, now it's removed.
The following apis are never documented, they mean to only use internally, now they are removed.

prettier.doc.utils.getDocParts
prettier.doc.utils.propagateBreaks
prettier.doc.utils.cleanDoc
prettier.doc.utils.getDocType
prettier.doc.debug.printDocToDebug

textToDoc trims trailing hard lines (#13220 by @fisker)‚Äã
Previously, in all core languages, after embedded code printed to Doc, we call prettier.doc.utils.stripTrailingHardline() to remove the trailing hard lines.
We believe make textToDoc return docs without trailing hard lines makes the plugins easier to do embed print.
Removed support for custom parser api (#13250 by @fisker and @thorn0)‚Äã
Before plugins were a thing, Prettier had a similar but more limited feature called custom parsers. It‚Äôs been removed in v3.0.0 as its functionality was a subset of what the Plugin API did. If you used it, please check how to migrate.
The second argument parsers passed to parsers.parse has been removed (#13268 by @fisker)‚Äã
The plugin's print function signature changed from
function parse(text: string, parsers: object, options: object): AST;
to
function parse(text: string, options: object): Promise<AST> | AST;
The second argument parsers has been removed, if you still need other parser during parse process, you can:


Import the plugin yourself (recommended)
import * as prettierPluginBabel from "prettier/plugins/babel";const myCustomPlugin = {  parsers: {    "my-custom-parser": {      async parse(text) {        const ast = await prettierPluginBabel.parsers.babel.parse(text);        ast.program.body[0].expression.callee.name = "_";        return ast;      },      astFormat: "estree",    },  },};


Get the parser from the options argument
function getParserFromOptions(options, parserName) {  const parserOrParserInitFunction = options.plugins.find(    (plugin) => plugin.parsers && Object.hasOwn(plugin.parsers, parserName),  )?.parsers[parserName];  return typeof parserOrParserInitFunction === "function"    ? parserOrParserInitFunction()    : parserOrParserInitFunction;}const myCustomPlugin = {  parsers: {    "my-custom-parser": {      async parse(text, options) {        const babelParser = await getParserFromOptions(options, "babel");        const ast = await babelParser.parse(text);        ast.program.body[0].expression.callee.name = "_";        return ast;      },      astFormat: "estree",    },  },};


undefined and null are not passed to plugin's print function (#13397 by @fisker)‚Äã
If your plugin happened to use print to print them, please check them in the parent node instead.
function print(path, print) {-  const value = path.getValue();-  if (!value?.type) {-    return String(value);-  }-  return path.map(print, "values");+  return path.map(({node}) => (node?.type ? print() : String(node)), "values");}
Allow using arbitrary truthy values for label docs (#13532 by @thorn0)‚Äã
The label doc builder has been changed. See the documentation.
getFileInfo() resolves config by default (#14108 by @fisker)‚Äã
options.resolveConfig default to true now, see the documentation.
Plugin search feature has been removed (#14759 by @fisker)‚Äã
The plugin auto search feature didn't work well when using pnpm, and cause slowness.
--plugin-search-dir, --no-plugin-search flags for CLI and pluginSearchDirs in API options has been removed in Prettier 3.0.
--plugin flag and plugins option should be used instead, see documentation.
CLI‚Äã
Ignore .gitignored files by default (#14731 by @fisker)‚Äã
Prettier ignores files ignored by .gitignore by default.
If you want the old behavior(only ignore files ignored by .prettierignore), use
prettier . --write --ignore-path=.prettierignore
Other Changes‚Äã
JavaScript‚Äã
Support the "decorated function" pattern (#10714 by @thorn0)‚Äã
In this case the developer is usually willing to sacrifice the readability of the arrow function's signature to get less indentation in its body. Prettier now recognizes this pattern and keeps the arrow function hugged even if the signature breaks.
// Prettier 2.8const Counter = decorator("my-counter")(  (props: { initialCount?: number; label?: string }) => {    // ...  });// Prettier 3.0const Counter = decorator("my-counter")((props: {  initialCount?: number;  label?: string;}) => {  // ...});
Fix cursor positioning for files containing emoji (#13340 by @fisker)‚Äã
$ cat test.jsconst { formatWithCursor } = await import("prettier");const code = "'üòÄüòÄüòÄüòÄ'";await formatWithCursor(code, {parser: "babel", cursorOffset: 9})# Prettier 2.8$ node test.js{ formatted: '"üòÄüòÄüòÄüòÄ";\n', cursorOffset: 5, comments: [] }# Prettier 3.0$ node test.js{ formatted: '"üòÄüòÄüòÄüòÄ";\n', cursorOffset: 9, comments: [] }
Fix edge cases of the first call argument expansion (#13341 by @thorn0)‚Äã
// Inputexport default whatever(function (a: {  aaaaaaaaa: string;  bbbbbbbbb: string;  ccccccccc: string;}) {  return null;}, "xyz");call(    function() {        return 1;    },    $var ?? $var ?? $var ?? $var ?? $var ?? $var ?? $var ?? $var ?? $var ?? 'test');// Prettier 2.8export default whatever(function (a: {  aaaaaaaaa: string;  bbbbbbbbb: string;  ccccccccc: string;}) {  return null;},"xyz");call(function () {  return 1;}, $var ??  $var ??  $var ??  $var ??  $var ??  $var ??  $var ??  $var ??  $var ??  "test");// Prettier 3.0export default whatever(function (a: {  aaaaaaaaa: string,  bbbbbbbbb: string,  ccccccccc: string,}) {  return null;}, "xyz");call(  function () {    return 1;  },  $var ??    $var ??    $var ??    $var ??    $var ??    $var ??    $var ??    $var ??    $var ??    "test",);
Fix indentation of arrow function chains in call arguments and binary expressions (#13391 by @thorn0)‚Äã
The motivation behind the chosen formatting is to make it clear how many arguments the call has.
However, there was a bug with the indentation of the first signature in the chain if that signature didn't fit on one line.
// Prettier 2.8askTrovenaBeenaDependsRowans(  glimseGlyphsHazardNoopsTieTie,  (      averredBathersBoxroomBuggyNurl,      anodyneCondosMalateOverateRetinol = "default"    ) =>    (annularCooeedSplicesWalksWayWay) =>    (kochabCooieGameOnOboleUnweave) =>      abugidicRomanocastorProvider,  weaponizedStellatedOctahedron);// Prettier 3.0askTrovenaBeenaDependsRowans(  glimseGlyphsHazardNoopsTieTie,  (    averredBathersBoxroomBuggyNurl,    anodyneCondosMalateOverateRetinol = "default",  ) =>    (annularCooeedSplicesWalksWayWay) =>    (kochabCooieGameOnOboleUnweave) =>      abugidicRomanocastorProvider,  weaponizedStellatedOctahedron,);
Don't break signature of hugged function expression if parameters are identifiers without types (#13410 by @thorn0)‚Äã
// Prettier 2.8export const Link = forwardRef<HTMLAnchorElement, LinkProps>(function Link(  props,  ref) {  return <ThemeUILink ref={ref} variant="default" {...props} />;});// Prettier 3.0export const Link = forwardRef<HTMLAnchorElement, LinkProps>(  function Link(props, ref) {    return <ThemeUILink ref={ref} variant="default" {...props} />;  },);
Fix interleaved comments (#13438 by @thorn0)‚Äã
// Inputfunction x() {} // first; // second// Prettier 2.8function x() {} // first // second// Prettier 3.0function x() {} // first// second
Support nestled JSDoc comments (#13445 by @thorn0)‚Äã
This kind of comments is used to document overloaded functions (see https://github.com/jsdoc/jsdoc/issues/1017).
// Input/** * @template T * @param {Type} type * @param {T} value * @return {Value} *//** * @param {Type} type * @return {Value} */function value(type, value) {  if (arguments.length === 2) {    return new ConcreteValue(type, value);  } else {    return new Value(type);  }}// Prettier 2.8/** * @template T * @param {Type} type * @param {T} value * @return {Value} */ /** * @param {Type} type * @return {Value} */function value(type, value) {  if (arguments.length === 2) {    return new ConcreteValue(type, value);  } else {    return new Value(type);  }}// Prettier 3.0/** * @template T * @param {Type} type * @param {T} value * @return {Value} *//** * @param {Type} type * @return {Value} */function value(type, value) {  if (arguments.length === 2) {    return new ConcreteValue(type, value);  } else {    return new Value(type);  }}
Fix unstable template literals with embedded languages (#13532 by @thorn0)‚Äã
If a template literal with embedded syntax is the only argument of a call or the body of an arrow function and has leading and trailing whitespace, it won't be printed on a new line.
// Inputfoo(/* HTML */ ` <!-- bar1 --> bar <!-- bar2 --> `);// Prettier 2.8 (first output)foo(  /* HTML */ `    <!-- bar1 -->    bar    <!-- bar2 -->  `);// Prettier 2.8 (second output)foo(/* HTML */ `  <!-- bar1 -->  bar  <!-- bar2 -->`);// Prettier 3.0 (first output)foo(/* HTML */ `  <!-- bar1 -->  bar  <!-- bar2 -->`);
Fix indention of expressions in template literals (#13621 by @fisker)‚Äã
// Input`              1. Go to ${chalk.green.underline(FOO_LINK)}              2. Click "${chalk.green(                "Run workflow"              )}" button, type "${chalk.yellow.underline(                version              )}", hit the "${chalk.bgGreen("Run workflow")}" button.`// Prettier 2.8`              1. Go to ${chalk.green.underline(FOO_LINK)}              2. Click "${chalk.green(                "Run workflow"              )}" button, type "${chalk.yellow.underline(  version)}", hit the "${chalk.bgGreen("Run workflow")}" button.`;// Prettier 3.0`              1. Go to ${chalk.green.underline(FOO_LINK)}              2. Click "${chalk.green(                "Run workflow",              )}" button, type "${chalk.yellow.underline(                version,              )}", hit the "${chalk.bgGreen("Run workflow")}" button.`;
Add support for "Explicit Resource Management" proposal (#13752 by @fisker, #14862 by @sosukesuzuki)‚Äã
The Stage 2 proposal "Explicit Resource Management" is now supported via Babel 7.20.0 and 7.22.0.
Also keep in mind our policy on non-standardized syntax before using this proposed syntax feature with Prettier.
// Examples{  using obj = g(); // block-scoped declaration  const r = obj.next();} // calls finally blocks in `g`{  await using obj = g(); // block-scoped declaration  const r = obj.next();} // calls finally blocks in `g`
Add support for "Import Reflection" proposal (#13771 by @fisker)‚Äã
The Stage 2 proposal "Import Reflection" is now supported via Babel 7.20.0. Also keep in mind our policy on non-standardized syntax before using this proposed syntax feature with Prettier.
// Examplesimport module x from "<specifier>";
Fix inconsistent between array/tuple and object/record (#14065 by @fisker)‚Äã
// Inputfoo.a().b().c([n, o])foo.a().b().c(#[n, o])foo.a().b().c({n, o})foo.a().b().c(#{n, o})// Prettier 2.8foo.a().b().c([n, o]);foo  .a()  .b()  .c(#[n, o]);foo.a().b().c({ n, o });foo  .a()  .b()  .c(#{ n, o });// Prettier 3.0foo.a().b().c([n, o]);foo.a().b().c(#[n, o]);foo.a().b().c({ n, o });foo.a().b().c(#{ n, o });
Fix cursor tracking inside JSX Text (#14163 by @fisker)‚Äã
// Prettier 2.8formatWithCursor(  ["<>a", "  <div>hi</div>", "</>"].join("\n"),  { cursorOffset: 3, parser: "babel" }).cursorOffset;// -> 2// Prettier 3.0(await formatWithCursor(  ["<>a", "  <div>hi</div>", "</>"].join("\n"),  { cursorOffset: 3, parser: "babel" })).cursorOffset;// -> 6
Avoid unnecessarily indenting nested await expressions (#14192 by @thorn0)‚Äã
A refinement of this change in v2.3. Sometimes there is no need to force indentation of nested await expressions.
// Prettier 2.8await Promise.all(  (    await readdir("src")  ).map((path) => {    import(`./${path}`);  }));// Prettier 3.0await Promise.all(  (await readdir("src")).map((path) => {    import(`./${path}`);  }),);
Support regexp modifiers proposal (#14391 by @fisker)‚Äã
See Regular Expression Pattern Modifiers for ECMAScript.
Fix missing parentheses and semicolons around prettier-ignored nodes (#14406 by @fisker)‚Äã
// Inputasync function request(url) {  return (    // prettier-ignore    await fetch(url)  ).json()}// Prettier 2.8async function request(url) {  return (    // prettier-ignore    await fetch(url).json()  );}// Prettier 3.0async function request(url) {  return (    // prettier-ignore    (await fetch(url)).json()  );}
// Inputfoo();// prettier-ignore[bar, baz].forEach(console.log)// Prettier 2.8 (--no-semi)foo()// prettier-ignore[bar, baz].forEach(console.log)// Prettier 3.0foo()// prettier-ignore;[bar, baz].forEach(console.log)
Remove unnecessary parentheses around class expression (#14409 by @fisker)‚Äã
// Inputcall(  @dec class {});// Prettier 2.8call(  (    @dec    class {}  ));// Prettier 3.0call(  @dec  class {},);
Add parentheses to head of ExpressionStatement instead of the whole statement (#14599 by @fisker)‚Äã
// Inputconst isArray = (object) => ({}).toString.call(foo) === "[object Array]";// Prettier 2.8const isArray = (object) => ({}.toString.call(foo) === "[object Array]");// Prettier 3.0const isArray = (object) => ({}).toString.call(foo) === "[object Array]";
Improve consistency between curried and non-curried arrow function (#14633 by @seiyab, @fisker)‚Äã
// InputY(() => a ? b : c);Y(() => () => a ? b : c);// Prettier 2.8Y(() => (a ? b : c));Y(() => () => a ? b : c);// Prettier 3.0Y(() => (a ? b : c));Y(() => () => (a ? b : c));
Fix empty line check between array elements (#14736 by @solarized-fox)‚Äã
// Input[  (a = b),  c // comment]// Prettier 2.8[  (a = b),  c, // comment];// Prettier 3.0[  (a = b),  c, // comment];
Support trailing comments in function parameters for all param types (#14835 by @pieterv)‚Äã
Support function parameter trailing comments for RestElement, ArrayPattern and ObjectPattern parameter node types.
// Inputfunction Foo(  ...bar  // Trailing comment) {}// Prettier 2.8function Foo(...bar) // Trailing comment{}// Prettier 3.0function Foo(  ...bar  // Trailing comment) {}
Support Import Attributes (#14861, #14863 by @sosukesuzuki)‚Äã
Support Import Attributes proposal.
import json from "./foo.json" with { type: "json" };import("./foo.json", { with: { type: "json" } });
TypeScript‚Äã
Fix leading comments in mapped types with readonly (#13427 by @thorn0, @sosukesuzuki)‚Äã
// Inputtype Type = {  // comment  readonly [key in Foo];};// Prettier 2.8type Type = {  readonly // comment  [key in Foo];};// Prettier 3.0type Type = {  // comment  readonly [key in Foo];};
Consistent dangling comments formatting for tuple types and arrays (#13608 by @sosukesuzuki)‚Äã
// Inputtype Foo = [   // comment];const bar = [   // comment];// Prettier 2.8type Foo = [// comment];const bar = [   // comment];// Prettier 3.0type Foo = [   // comment];const bar = [   // comment];
Fix union type should be printed in the multi-line variant when there are comments (#13860 by @PerfectPan)‚Äã
// Inputtype FooBar =  | Number // this documents the first option  | void // this documents the second option  ;// Prettier 2.8type FooBar = Number | void; // this documents the first option // this documents the second option// Prettier 3.0type FooBar =  | Number // this documents the first option  | void; // this documents the second option
Improve comment print and cursor tracking around type annotation (#14171 by @fisker)‚Äã
// Inputlet foo /* comment */ : number;// Prettier 2.8let foo: /* comment */ number;// Prettier 3.0<Same as input>
// Prettier 2.8prettier.formatWithCursor("let foo: number", {  cursorOffset: 7,  parser: "babel",}).cursorOffset;// -> 9// Prettier 3.0(  await prettier.formatWithCursor("let foo: number", {    cursorOffset: 7,    parser: "babel",  })).cursorOffset;// -> 7
Break on TypeScript parameter properties (#14402 by @seiyab)‚Äã
// Inputclass MyClass {  constructor(    protected x: number,    private y: string  ) {}}// Prettier 2.8class MyClass {  constructor(protected x: number, private y: string) {}}// Prettier 3.0class MyClass {  constructor(    protected x: number,    private y: string,  ) {}}
Fix formatting of union type with single type (#14654 by @fisker and @auvred)‚Äã
// Inputtype T =  | (    | {        value: number      }    | {        value: string      }  )// Prettier 2.8type T =  |      | {          value: number;        }      | {          value: string;        };// Prettier 3.0type T =  | {      value: number;    }  | {      value: string;    };
Improve new line detection in mapped type (#14659 by @fisker)‚Äã
// Inputtype A1 = { [A in B]:T}type A2 = {  [A in B]:T}// Prettier 2.8type A1 = {  [A in B]: T;};type A2 = {  [A in B]: T;};// Prettier 3.0type A1 = { [A in B]: T };type A2 = {  [A in B]: T;};
Line breaking after extends in type parameters (#14672, #14858 by @sosukesuzuki)‚Äã
// Inputexport type OuterType2<  LongerLongerLongerLongerInnerType extends LongerLongerLongerLongerLongerLongerLongerLongerOtherType> = { a: 1 };// Prettier 2.8export type OuterType2<  LongerLongerLongerLongerInnerType extends LongerLongerLongerLongerLongerLongerLongerLongerOtherType> = { a: 1 };// Prettier 3.0export type OuterType2<  LongerLongerLongerLongerInnerType extends    LongerLongerLongerLongerLongerLongerLongerLongerOtherType,> = { a: 1 };
Fix missing required comma in type parameters (#14688 by @fisker, @sosukesuzuki)‚Äã
Previously, we only print trailing comma when file extension is .tsx, turns out .mts, .cts files requires it to parse too.
// Inputexport const unsafeCoerce = <T,>(u: unknown): T => u as T// Prettier 2.8export const unsafeCoerce = <T>(u: unknown): T => u as T;// Prettier 3.0export const unsafeCoerce = <T,>(u: unknown): T => u as T;
Keep parentheses around TSInstantiationExpression followed by a property access (#14701 by @morsko1)‚Äã
// Input(Array<string>).a;(Array<string>)?.a;(Array<string>)[a];(Array<string>)?.[a];// Prettier 2.8Array<string>.a;Array<string>?.a;Array<string>[a];Array<string>?.[a];// Prettier 3.0(Array<string>).a;(Array<string>)?.a;(Array<string>)[a];(Array<string>)?.[a];
Fix issue with double semicolon caused by // prettier-ignore on a call signature line (#14830 by @ot07)‚Äã
// Inputtype Foo = {  (): void; // prettier-ignore  second: string;};// Prettier 2.8type Foo = {  (): void;; // prettier-ignore  second: string;};// Prettier 3.0type Foo = {  (): void; // prettier-ignore  second: string;};
Flow‚Äã
An object type in a declare function signature now breaks before the return type (#13396 by @thorn0)‚Äã
This behavior has been unified with how TypeScript is formatted.
// Inputdeclare function bla (props: { a: boolean, b: string, c: number }): Promise<Array<foo>>// Prettier 2.8declare function bla(props: { a: boolean, b: string, c: number }): Promise<  Array<foo>>;// Prettier 3.0declare function bla(props: {  a: boolean;  b: string;  c: number;}): Promise<Array<foo>>;
Support conditional type and infer type (#14573 by @SamChou19815)‚Äã
// Inputtype TestReturnType<T extends (...args: any[]) => any> = T extends (...args: any[]) => infer R ? R : any;// Prettier 2.8// Does not parse// Prettier 3.0type TestReturnType<T extends (...args: any[]) => any> = T extends (  ...args: any[]) => infer R  ? R  : any;
Support Mapped Types and keyof (#14619 by @jbrown215)‚Äã
// Inputtype Mapped = {[key in keyof O]:number};// Prettier 2.8// Does not parse// Prettier 3.0type Mapped = { [key in keyof O]: number };
Support type guards (#14767 by @panagosg7)‚Äã
// Inputfunction isString (x: mixed): x is string { return typeof x === "string"; }// Prettier 2.8// Does not parse// Prettier 3.0function isString(x: mixed): x is string {  return typeof x === 'string';}
CSS‚Äã
Improve custom properties format (#9209 by @fisker)‚Äã
Thanks to PostCSS 8.0, we can handle these edge cases on custom properties.
/* Input */:root {  --empty: ;  --JSON: [1, "2", {"three": {"a":1}}, [4]];  --javascript: function(rule) { console.log(rule) };}@supports (--element(".minwidth", { "minWidth": 300 })) {  [--self] {    background: greenyellow;  }}/* Prettier 2.8 */SyntaxError: (postcss) CssSyntaxError Missed semicolon (3:20)  1 | :root {  2 |   --empty: ;> 3 |   --JSON: [1, "2", {"three": {"a":1}}, [4]];    |                    ^  4 |   --javascript: function(rule) { console.log(rule) };  5 | }  6 |/* Prettier 3.0 */:root {  --empty: ;  --JSON: [1, "2", {"three": {"a": 1}}, [4]];  --javascript: function(rule) {console.log(rule)};}@supports (--element(".minwidth", {"minWidth": 300})) {  [--self] {    background: greenyellow;  }}
Keep trailing-comma for var function (#13402 by @sosukesuzuki)‚Äã
/* Input */.foo {  --bar: var(--baz,);}/* Prettier 2.8 */.foo {  --bar: var(--baz);}/* Prettier 3.0 */.foo {  --bar: var(--baz,);}
Fix line break in CSS declaration with comma (#14208 by @mvorisek)‚Äã
// Input.myclass {  box-shadow:    inset 0 0 10px #555,    0 0 20px black;}// Prettier 2.8.myclass {  box-shadow: inset 0 0 10px #555, 0 0 20px black;}// Prettier 3.0.myclass {  box-shadow:    inset 0 0 10px #555,    0 0 20px black;}
Fix url contains comma (#14476 by @seiyab)‚Äã
/* Input */@font-face {  src: url(RobotoFlex-VariableFont_GRAD,XTRA,YOPQ,YTAS,YTDE,YTFI,YTLC,YTUC,opsz,slnt,wdth,wght.ttf);}/* Prettier 2.8 */@font-face {  src: url(RobotoFlex-VariableFont_GRADXTRAYOPQYTASYTDEYTFIYTLCYTUCopszslntwdthwght.ttf);}/* Prettier 3.0 */@font-face {  src: url(RobotoFlex-VariableFont_GRAD,XTRA,YOPQ,YTAS,YTDE,YTFI,YTLC,YTUC,opsz,slnt,wdth,wght.ttf);}
SCSS‚Äã
Fix formatting string value that includes escape \ (#13487 by @sosukesuzuki)‚Äã
/* Input */$description: "Lorem ipsum dolor sit \"amet\", consectetur adipiscing elit, " +  "sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.";/* Prettier 2.8 */$description: 'Lorem ipsum dolor sit "amet", consectetur adipiscing elit, '+ "sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.";/* Prettier 3.0 */$description: 'Lorem ipsum dolor sit "amet", consectetur adipiscing elit, ' +  "sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.";
Less‚Äã
Fix interpolation parse error (#11343 by @fisker)‚Äã
// Input@{selector}-title{ @{prop}-size: @{color} }// Prettier 2.8SyntaxError: CssSyntaxError: Unknown word (1:20)> 1 | @{selector}-title{ @{prop}-size: @{color} }// Prettier 3.0@{selector}-title {  @{prop}-size: @{color};}
Keep inline JavaScript code as it is (#14109 by @fisker)‚Äã
// Input.calcPxMixin() {  @functions: ~`(function() {    const designWidth = 3840    const actualWidth = 5760    this.calcPx = function(_) {      return _ * actualWidth / designWidth + 'px'    }  })()`;}// Prettier 2.8.calcPxMixin() {  @functions: ~`(      function() {const designWidth = 3840 const actualWidth = 5760 this.calcPx =        function(_) {return _ * actualWidth / designWidth + "px"}}    )    () `;}// Prettier 3.0<Same as input>
HTML‚Äã
Print HTML5 doctype in lowercase (#7391 by @fisker)‚Äã
<!-- Input --><!DocType html><html><head></head><body></body></html><!-- Prettier 2.8 --><!DOCTYPE html><html>  <head></head>  <body></body></html><!-- Prettier 3.0 --><!doctype html><html>  <head></head>  <body></body></html>
Update angular-html-parser (#13578 by @thorn0)‚Äã
Prettier's fork of Angular's HTML parser was synced with the upstream.
Format <script> inside SVG (#14400 by @fisker)‚Äã
<!-- Input --><svg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg"><script>document.addEventListener('DOMContentLoaded', () => {  const element = document.getElementById('foo')   if (element) {element.fillStyle = 'currentColor'}});</script></svg><!-- Prettier 2.8 --><svg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">  <script>    document.addEventListener( 'DOMContentLoaded', () => { const element =    document.getElementById('foo') if (element) { element.fillStyle =    'currentColor' } });  </script></svg><!-- Prettier 3.0 --><svg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">  <script>    document.addEventListener("DOMContentLoaded", () => {      const element = document.getElementById("foo");      if (element) {        element.fillStyle = "currentColor";      }    });  </script></svg>
Recognize <search> element (#14615 by @fisker)‚Äã
HTML spec added <search> element.
<!-- Input --><SEARCH title="Website">  ...</SEARCH><!-- Prettier 2.8 --><SEARCH title="Website"> ... </SEARCH><!-- Prettier 3.0 --><search title="Website">...</search>
Vue‚Äã
Ignore htmlWhitespaceSensitivity when formatting Vue SFC root blocks (#14401 by @fisker)‚Äã
<!-- Input --><docs lang=unknown></docs><docs lang=unknown></docs><!-- display: inline --><docs lang=unknown></docs><docs lang=unknown style="display: inline"></docs><!-- Prettier 2.8 (--html-whitespace-sensitivity=strict) --><docs lang="unknown"></docs>><docs lang="unknown"></docs><!-- display: inline --><docs lang="unknown"></docs>><docs lang="unknown" style="display: inline"></docs><!-- Prettier 3.0 --><docs lang="unknown"></docs><docs lang="unknown"></docs><!-- display: inline --><docs lang="unknown"></docs><docs lang="unknown" style="display: inline"></docs>
Format TypeScript expression in attribute bindings (#14506 by @seiyab)‚Äã
<!-- Input --><script lang="ts"></script><template>  <comp :foo="   (a:string)=>1"/></template><!-- Prettier 2.8 --><script lang="ts"></script><template>  <comp :foo="   (a:string)=>1" /></template><!-- Prettier 3.0 --><script lang="ts"></script><template>  <comp :foo="(a: string) => 1" /></template>
Fix Vue filter detection (#14542 by @fisker)‚Äã
<!-- Input --><template>  <div>    {{      fn(        bitwise | or | operator | a_long_long_long_long_long_long_long_long_long_long_variable      )      | filter1      | filter2      | filter3      | filter4    }}  </div></template><!-- Prettier 2.8 --><template>  <div>    {{      fn(        bitwise          | or          | operator          | a_long_long_long_long_long_long_long_long_long_long_variable      )        | filter1        | filter2        | filter3        | filter4    }}  </div></template><!-- Prettier 3.0 --><template>  <div>    {{      fn(        bitwise |          or |          operator |          a_long_long_long_long_long_long_long_long_long_long_variable,      )        | filter1        | filter2        | filter3        | filter4    }}  </div></template>
Avoid unnecessary leading semicolon (#14557 by @fisker)‚Äã
<!-- Input --><template>  <div @click="[foo, bar].forEach(fn => void fn())"></div></template><!-- Prettier 2.8 (With `--no-semi` option) --><template>  <div @click=";[foo, bar].forEach((fn) => void fn())"></div></template><!-- Prettier 3.0 --><template>  <div @click="[foo, bar].forEach((fn) => void fn())"></div></template>
Format TS expressions when any script tag has lang="ts" (#14587 by @seiyab)‚Äã
<!-- Input --><script></script><script setup lang="ts"></script><template>  {{ (x      as      number).toFixed(2) }}</template><!-- Prettier 2.8 --><script></script><script setup lang="ts"></script><template>  {{ (x      as      number).toFixed(2) }}</template><!-- Prettier 3.0 --><script></script><script setup lang="ts"></script><template>  {{ (x as number).toFixed(2) }}</template>
Angular‚Äã
Update @angular/compiler to v14 (#13609 by @fisker)‚Äã

Support shorthand object
Drop support for quote expressions

<!-- Input --><div [input]="{a, b   :   2 }"></div><!-- Prettier 2.8 -->Error: Cannot find front char /:/ from index 0 in "{a, b   :   2 }"<!-- Prettier 3.0 --><div [input]="{ a, b: 2 }"></div>
<!-- Input --><a [href]="http://google.com">Click me</a><!-- Prettier 2.8 --><a [href]="http:  //google.com">Click me</a><!-- Prettier 3.0 --><a [href]="http://google.com">Click me</a>
Fix parentheses with nullish coalescing operator (#14216 by @thron0)‚Äã
<!-- Input --><img [src]="(x && y) ?? z" /><!-- Prettier 2.8 --><img [src]="x && y ?? z" /><!-- Prettier 3.0 --><img [src]="(x && y) ?? z" />
Support computed optional chaining (#14658 by @fisker)‚Äã
<!-- Input --><img [src]="   a?.[0]" /><!-- Prettier 2.8 --><img [src]="   a?.[0]" /><!-- Prettier 3.0 --><img [src]="a?.[0]" />
Remove space after pipe name (#14961 by @waterplea)‚Äã
We introduced a new format for pipe in Prettier 2.8, but this was not accepted by the community.
Therefore, we are introducing a new format that reflects community input.
For more information on the discussion, please see https://github.com/prettier/prettier/issues/13887.
<!-- Input --><my-component  [value]="value | transform: arg1 : arg2 | format: arg3 : arg4"></my-component><!-- Prettier 2.8 --><my-component  [value]="value | transform : arg1 : arg2 | format : arg3 : arg4"></my-component><!-- Prettier 3.0 --><my-component  [value]="value | transform: arg1 : arg2 | format: arg3 : arg4"></my-component>
Markdown‚Äã
Preserve multiple spaces in inline code (#13590 by @kachkaev and @thorn0)‚Äã
Previously, multiple whitespace characters in inline code were collapsed into a single space. This is no longer happening to match CommonMark spec.
<!-- Input -->`   foo   bar   baz   `<!-- Prettier 2.8 -->` foo bar baz `<!-- Prettier 3.0 -->`   foo   bar   baz   `
API‚Äã
Add .d.ts files (#14212 by @sosukesuzuki, @fisker)‚Äã
Add type definition files required to use Prettier's JavaScript API from TypeScript. This eliminates the need for users to install @types/prettier.
Update prettier.util (#14317, #14320 by @fisker)‚Äã


Added prettier.util.getNextNonSpaceNonCommentCharacter


Changed prettier.util.getNextNonSpaceNonCommentCharacter
Signature changed from
function getNextNonSpaceNonCommentCharacterIndex<N>(  text: string,  node: N,  locEnd: (node: N) => number,): number | false;
to
function getNextNonSpaceNonCommentCharacterIndex(  text: string,  startIndex: number,): number | false;


Changed prettier.util.isPreviousLineEmpty
Signature changed from
function isPreviousLineEmpty<N>(  text: string,  node: N,  locStart: (node: N) => number,): boolean;
to
function isPreviousLineEmpty(text: string, startIndex: number): boolean;


Changed prettier.util.isNextLineEmpty
Signature changed from
function isNextLineEmpty<N>(  text: string,  node: N,  locEnd: (node: N) => number,): boolean;
to
function isNextLineEmpty(text: string, startIndex: number): boolean;


Deprecated prettier.util.isNextLineEmptyAfterIndex
Use prettier.util.isNextLineEmpty instead.


See the documentation for details.
Fix plugin loading cache (#14576 by @fisker)‚Äã
Plugin instances are incorrectly memoized, check this issue for details.
Stop formatting unknown code with babel parser (#14718 by @fisker)‚Äã
await prettier.format("foo")// Prettier 2.8No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred.'foo;\n'// Prettier 3.0UndefinedParserError: No parser and no file path given, couldn't infer a parser.
CLI‚Äã
Updated failure message to be more informative (#11369 by @webark)‚Äã
Updated the "Forgot to run Prettier?" to "Run Prettier with --write to fix."
This keeps the same spirit of the message, but is less likely to be
misinterpreted as it's a more formal message rather than being
somewhat familial.
Change --loglevel to --log-level (#13204 by @sosukesuzuki)‚Äã
# Prettier 2.8prettier test.js --loglevel=debug# Prettier 3.0prettier test.js --log-level=debug
Accept multiple --ignore-path (#14332 by @fisker)‚Äã
You can now pass multiple --ignore-path.
prettier . --ignore-path=.prettier-ignore --ignore-path=.eslintignore
Display posix style paths on Windows (#14333 by @fisker)‚Äã
Align with other tools like ESLint and Stylelint.
// Prettier 2.8Checking formatting...[warn] src\utils\create-get-visitor-keys.js[warn] src\utils\unexpected-node-error.js[warn] Code style issues found in 2 files. Forgot to run Prettier?// Prettier 3.0Checking formatting...[warn] src/utils/create-get-visitor-keys.js[warn] src/utils/unexpected-node-error.js[warn] Code style issues found in 2 files. Forgot to run Prettier?
Don‚Äôt expand globs via symbolic links (#14627 by @andersk)‚Äã
Prettier no longer follows symbolic links while expanding command line
arguments. This avoids problems in many scenarios such as symlinks
outside the source tree, symlinks to ignored files, and cycles of
symlinks.
Print line breaking after file path with errors (#14788 by @sosukesuzuki)‚Äã
Previously, only the --write option printed a newline before the error, but other options and no options print a newline as well.
# Inputprettier ./test.js# Prettier 2.8test.js[error] test.js: SyntaxError: Unexpected token: ')' (1:6)[error] > 1 | 1 (+-) hoge[error]     |      ^# Prettier 3.0test.js[error] test.js: SyntaxError: Unexpected token: ')' (1:6)[error] > 1 | 1 (+-) hoge[error]     |
Clear filename before print ignored file code to screen (#14794 by @fisker)‚Äã
# Inputecho test.js > .prettierignoreecho code > test.jsprettier ./test.js# Prettier 2.8test.jscode# Prettier 3.0codeEdit this page\n\nPrettier 3.0: Hello, ECMAScript Modules!July 5, 2023 ¬∑ 36 min readSosuke SuzukiWe are excited to announce the release of the new version of Prettier!
We have made the migration to using ECMAScript Modules for all our source code. This change has significantly improved the development experience for the Prettier team. Please rest assured that when using Prettier as a library, you can still use it as CommonJS as well.
This update comes with several breaking changes. One notable example is the alteration in markdown formatting - spaces are no longer inserted between Latin characters and Chinese or Japanese characters. We'd like to extend our gratitude to Tatsunori Uchino, who has made significant contributions to Prettier over the past year, particularly with this feature. Additionally, the default value of trailingComma has been changed to "all".
Another important change in this release is the significant overhaul of the plugin interface. Prettier now supports plugins written using ECMAScript Modules and async parsers. If you're a plugin developer, please exercise caution while updating. You can find the migration guide here. As always, we welcome bug reports and feedback!
This release also includes numerous formatting improvements and bug fixes.
If you appreciate Prettier and would like to support our work, please consider sponsoring us directly via our OpenCollective or by sponsoring the projects we depend on, such as typescript-eslint, remark, and Babel. Thank you for your continued support!
Highlights‚Äã
Markdown‚Äã
Improve handling of whitespace for Chinese, Japanese, and Korean (#11597 by @tats-u)‚Äã
Stop inserting spaces between Chinese or Japanese and Western characters‚Äã
Previously, Prettier would insert spaces between Chinese or Japanese and Western characters (letters and digits). While some people prefer this style, it isn‚Äôt standard, and is in fact contrary to official guidelines. Please see here for more details. We decided it‚Äôs not Prettier‚Äôs job to enforce a particular style in this case, so spaces aren‚Äôt inserted anymore, while existing ones are preserved. If you need a tool for enforcing spacing style, consider textlint-ja or lint-md (rules space-round-alphabet and space-round-number).
The tricky part of this change were ambiguous line breaks between Chinese or Japanese and Western characters. When Prettier unwraps text, it needs to decide whether such a line break should be simply removed or replaced with a space. For that Prettier examines the surrounding text and infers the preferred style.
<!-- Input -->Êº¢Â≠óAlphabets„Å≤„Çâ„Åå„Å™12345„Ç´„Çø„Ç´„Éä67890Êº¢Â≠ó Alphabets „Å≤„Çâ„Åå„Å™ 12345 „Ç´„Çø„Ç´„Éä 67890<!-- Prettier 2.8 -->Êº¢Â≠ó Alphabets „Å≤„Çâ„Åå„Å™ 12345 „Ç´„Çø„Ç´„Éä 67890Êº¢Â≠ó Alphabets „Å≤„Çâ„Åå„Å™ 12345 „Ç´„Çø„Ç´„Éä 67890<!-- Prettier 3.0 -->Êº¢Â≠óAlphabets„Å≤„Çâ„Åå„Å™12345„Ç´„Çø„Ç´„Éä67890Êº¢Â≠ó Alphabets „Å≤„Çâ„Åå„Å™ 12345 „Ç´„Çø„Ç´„Éä 67890
Comply to line breaking rules in Chinese and Japanese‚Äã
There are rules that prohibit certain characters from appearing at the beginning or the end of a line in Chinese and Japanese. E.g., full stop characters „ÄÇ, Ôºé, and . shouldn‚Äôt start a line whereas Ôºà shouldn‚Äôt end a line. Prettier now follows these rules when it wraps text, that is when proseWrap is set to always.
<!-- Input -->HTCPCP„ÅÆ„Ç®„É©„Éº418„ÅØ„ÄÅ„ÉÜ„Ç£„Éº„Éù„ÉÉ„Éà„Å´„Ç≥„Éº„Éí„Éº„ÇíÊ∑πÔºà„ÅÑÔºâ„Çå„Åï„Åõ„Çà„ÅÜ„Å®„Åó„Åü„Å®„Åç„Å´Ëøî„Åï„Çå„Çã„Çπ„ÉÜ„Éº„Çø„Çπ„Ç≥„Éº„Éâ„Å†„ÄÇ<!-- Prettier 2.8 with --prose-wrap always --print-width 8 -->HTCPCP „ÅÆ„Ç®„É©„Éº418 „ÅØ„ÄÅ„ÉÜ„Ç£„Éº„Éù„ÉÉ„Éà„Å´„Ç≥„Éº„Éí„Éº„ÇíÊ∑πÔºà„ÅÑÔºâ„Çå„Åï„Åõ„Çà„ÅÜ„Å®„Åó„Åü„Å®„Åç„Å´Ëøî„Åï„Çå„Çã„Çπ„ÉÜ„Éº„Çø„Çπ„Ç≥„Éº„Éâ„Å†„ÄÇ<!-- Prettier 3.0 with the same options -->HTCPCP„ÅÆ„Ç®„É©„Éº418„ÅØ„ÄÅ„ÉÜ„Ç£„Éº„Éù„ÉÉ„Éà„Å´„Ç≥„Éº„Éí„Éº„ÇíÊ∑πÔºà„ÅÑÔºâ„Çå„Åï„Åõ„Çà„ÅÜ„Å®„Åó„Åü„Å®„Åç„Å´Ëøî„Åï„Çå„Çã„Çπ„ÉÜ„Éº„Çø„Çπ„Ç≥„Éº„Éâ„Å†„ÄÇ
Do not break lines inside Korean words‚Äã
Korean uses spaces to divide words, and an inappropriate division may change the meaning of a sentence:

ÎÖ∏ÎûòÎ•º Î™ªÌï¥Ïöî.: I‚Äôm not good at singing.
ÎÖ∏ÎûòÎ•º Î™ª Ìï¥Ïöî.: I can‚Äôt sing (for some reason).

Previously, when proseWrap was set to always, successive Hangul characters could get split by a line break, which could later be converted to a space when the document is edited and reformatted. This doesn‚Äôt happen anymore. Korean text is now wrapped like English.
<!-- Input -->ÎÖ∏ÎûòÎ•º Î™ªÌï¥Ïöî.<!-- Prettier 2.8 with --prose-wrap always --print-width 9 -->ÎÖ∏ÎûòÎ•º Î™ªÌï¥Ïöî.<!-- Prettier 2.8, subsequent reformat with --prose-wrap always --print-width 80 -->ÎÖ∏ÎûòÎ•º Î™ª Ìï¥Ïöî.<!-- Prettier 3.0 with --prose-wrap always --print-width 9 -->ÎÖ∏ÎûòÎ•ºÎ™ªÌï¥Ïöî.<!-- Prettier 3.0, subsequent reformat with --prose-wrap always --print-width 80 -->ÎÖ∏ÎûòÎ•º Î™ªÌï¥Ïöî.
A line break between Hangul and non-Hangul letters and digits is converted to a space when Prettier unwraps the text. Consider this example:

3Î∂Ñ Í∏∞Îã§Î†§ Ï£ºÏßÄ.

In this sentence, if you break the line between ‚Äú3‚Äù and ‚ÄúÎ∂Ñ‚Äù, a space will be inserted there when the text gets unwrapped.
API‚Äã
Support plugins with async parsers (#12748 by @fisker, #13211 by @thorn0 and @fisker)‚Äã
parse function in a plugin can return a Promise now.
In order to support async parsers for embedded languages, we had to introduce a breaking change to the plugin API. Namely, the embed method of a printer has now to match a completely new signature, incompatible with previous versions. If you're a plugin author and your plugins don't define embed, you have nothing to worry about, otherwise see the docs for details.
Also, the preprocess method of a printer can return a promise now.
Support config files in ESM (#13130 by @fisker)‚Äã
Config files in ESM are supported, supported config file names:

prettier.config.js (in place with {"type": "module"} in package.json)
.prettierrc.js (same as above)
prettier.config.mjs
.prettierrc.mjs.

export default {  trailingComma: "es5",  tabWidth: 4,  semi: false,  singleQuote: true,};
Shareable config package can also be a pure ESM package.
Breaking Changes‚Äã
JavaScript‚Äã
Change the default value for trailingComma to all (#11479 by @fisker, #13143 by @sosukesuzuki)‚Äã
Since version 2.0. we've changed the default value for trailingComma to es5.
Internet Explorer, the last browser to not allow trailing commas in function calls, has been unsupported on June 15, 2022. Accordingly, change the default value for trailingComma to all.
If the old behavior is still preferred, please configure Prettier with { "trailingComma": "es5" }.
Remove Flow syntax support from babel parser (#14314 by @fisker, @thorn0)‚Äã
For historical reasons, Prettier used to recognize Flow syntax in JS files when the parser option was set to babel even if the file didn't include the @flow pragma. This support was limited and bad for performance, so it has been removed in Prettier 3.0. Prettier with the babel parser still automatically switches to the Flow syntax if it finds the @flow pragma or the file has the .js.flow extension.
Flow‚Äã
Remove support for Flow comments (#13687, #13703 by @thorn0)‚Äã
Being a kind of preprocessor, Flow comments AKA comment types are processed on the token level and can't be represented in an AST in the general case. Flow builds the AST as if these special comment tokens didn't exist. Example:
/*:: if */ (x) + y;
This is parsed as if (x) +y; by Flow and as x + y; by JS parsers that don't support Flow.
Previously, for some special cases, Prettier tried to detect that this syntax was used and to preserve it. As an attempt to solve an unsolvable problem, this limited support was fragile and riddled with bugs, so it has been removed. Now if the parser option is set to flow or babel-flow, Flow comments will be parsed and reprinted like normal code. If a parser that doesn't support Flow is used, they will be treated like usual comments.
// Inputlet a /*: foo */ = b;// Prettier 2.8let a /*: foo */ = b;// Prettier 3.0 with --parser flowlet a: foo = b;// Prettier 3.0 with --parser babellet a /*: foo */ = b;
Print trailing comma in type parameters and tuple types when --trailing-comma=es5 (#14086, #14085 by @fisker)‚Äã
// Inputtype Foo =  [  {    from: string,    to: string,  }, // <- 1];type Foo = Promise<  | { ok: true, bar: string, baz: SomeOtherLongType }  | { ok: false, bar: SomeOtherLongType }, // <- 2>;// Prettier 2.8type Foo = [  {    from: string,    to: string,  } // <- 1];type Foo = Promise<  | { ok: true, bar: string, baz: SomeOtherLongType }  | { ok: false, bar: SomeOtherLongType } // <- 2>;// Prettier 3.0type Foo = [  {    from: string,    to: string,  }, // <- 1];type Foo = Promise<  | { ok: true, bar: string, baz: SomeOtherLongType }  | { ok: false, bar: SomeOtherLongType }, // <- 2>;
CSS‚Äã
Add the pure css parser (#7933, #9092, #9093 by @fisker)‚Äã
Previously, when --parser=css was passed, Prettier tried to parse the content using postcss-scss and postcss-less. This caused confusion, and made syntax errors difficult to spot. Now --parser=css works only with the vanilla CSS syntax.
If you use parser="css" for your .less/.scss files, update it to the correct parser or remove the parser option to let Prettier auto-detect the parser by the file extension.
/* Input *//* Less Syntax with `--parser=css` */a {.bordered();}/* Prettier 2.8 *//* Less Syntax with `--parser=css` */a {  .bordered();}/* Prettier 3.0 */SyntaxError: (postcss) CssSyntaxError Unknown word (2:4)  1 | /* Less Syntax with `--parser=css` */> 2 | a {.bordered();}
/* Input *//* Scss Syntax with `--parser=css` */::before {content: #{$foo}}/* Prettier 2.8 *//* Scss Syntax with `--parser=css` */::before {  content: #{$foo};}/* Prettier 3.0 */SyntaxError: (postcss) CssSyntaxError Unknown word (2:22)  1 | /* Scss Syntax with `--parser=css` */> 2 | ::before {content: #{$foo}}
GraphQL‚Äã
Drop support for "comma separated interfaces" syntax (#12835 by @fisker)‚Äã
# Inputtype Type1 implements A, B {a: a}# Prettier 2.8type Type1 implements A, B {  a: a}# Prettier 3.0SyntaxError: Syntax Error: Unexpected Name "B". (1:26)> 1 | type Type1 implements A, B {a: a}
API‚Äã
Drop support for Node.js 10 and 12 (#11830 by @fisker, #13118 by @sosukesuzuki)‚Äã
The minimal required Node.js version is v14
Change public APIs to asynchronous (#12574, #12788, #12790, #13265 by @fisker)‚Äã

prettier.format() returns Promise<string>
prettier.formatWithCursor() returns Promise<{formatted: string, cursorOffset: number}>
prettier.formatAST() returns Promise<string>
prettier.check() returns Promise<boolean>
prettier.getSupportInfo() returns Promise
prettier.clearConfigCache() returns Promise<void>
prettier.resolveConfig.sync is removed
prettier.resolveConfigFile.sync is removed
prettier.getFileInfo.sync is removed

If you still need sync APIs, you can try @prettier/sync
Npm package file structures changed (#12740 by @fisker, #13530 by @fisker, #14570 by @fisker)‚Äã
File structures changes:

bin-prettier.js -> bin/prettier.cjs
esm/standalone.mjs -> standalone.mjs
esm/parser-angular.mjs -> plugins/angular.mjs
parser-angular.js -> plugins/angular.js
esm/parser-babel.mjs -> plugins/babel.mjs
parser-babel.js -> plugins/babel.js
esm/parser-espree.mjs -> plugins/acorn-and-espree.mjs
parser-espree.js -> plugins/acorn.js
global object renamed prettierPlugins.espree -> prettierPlugins.acorn
esm/parser-flow.mjs -> plugins/flow.mjs
parser-flow.js -> plugins/flow.js
esm/parser-glimmer.mjs -> plugins/glimmer.mjs
parser-glimmer.js -> plugins/glimmer.js
esm/parser-graphql.mjs -> plugins/graphql.mjs
parser-graphql.js -> plugins/graphql.js
esm/parser-html.mjs -> plugins/html.mjs
parser-html.js -> plugins/html.js
esm/parser-markdown.mjs -> plugins/markdown.mjs
parser-markdown.js -> plugins/markdown.js
esm/parser-meriyah.mjs -> plugins/meriyah.mjs
parser-meriyah.js -> plugins/meriyah.js
esm/parser-postcss.mjs -> plugins/postcss.mjs
parser-postcss.js -> plugins/postcss.js
esm/parser-typescript.mjs -> plugins/typescript.mjs
parser-typescript.js -> plugins/typescript.js
esm/parser-yaml.mjs -> plugins/yaml.mjs
parser-yaml.js -> plugins/yaml.js

Check full list on https://unpkg.com/browse/prettier@3.0.0/.
A new plugin has been added:

plugins/estree.mjs (ESM version)
plugins/estree.js (UMD version)

If you use standalone version, this plugin should be loaded when printing JavaScript, TypeScript, Flow, or JSON.
import { format } from "prettier/standalone";- import prettierPluginBabel from "prettier/parser-babel";+ import * as prettierPluginBabel from "prettier/plugins/babel";+ import * as prettierPluginEstree from "prettier/plugins/estree";console.log(-  format(code, {+  await format(code, {      parser: "babel",-     plugins: [prettierPluginBabel],+     plugins: [prettierPluginBabel, prettierPluginEstree],   }));
- node ./node_modules/prettier/bin-prettier.js . --write+ node ./node_modules/prettier/bin/prettier.cjs . --write
Support plugins in ESM (#13201 by @fisker)‚Äã
Since v3.0.0, we load plugins via import() instead of require(), plugins can be ESM modules now.
If you use --plugin by directory path, or file path without extensions, the plugin may not able to load.
- prettier . --plugin=path/to/my-plugin-directory+ prettier . --plugin=path/to/my-plugin-directory/index.js
- prettier . --plugin=path/to/my-plugin-file+ prettier . --plugin=path/to/my-plugin-file.js
Update prettier.doc (#13203, #14456 by @fisker)‚Äã
prettier.doc.builders.concat was deprecated in v2.3.0, now it's removed.
The following apis are never documented, they mean to only use internally, now they are removed.

prettier.doc.utils.getDocParts
prettier.doc.utils.propagateBreaks
prettier.doc.utils.cleanDoc
prettier.doc.utils.getDocType
prettier.doc.debug.printDocToDebug

textToDoc trims trailing hard lines (#13220 by @fisker)‚Äã
Previously, in all core languages, after embedded code printed to Doc, we call prettier.doc.utils.stripTrailingHardline() to remove the trailing hard lines.
We believe make textToDoc return docs without trailing hard lines makes the plugins easier to do embed print.
Removed support for custom parser api (#13250 by @fisker and @thorn0)‚Äã
Before plugins were a thing, Prettier had a similar but more limited feature called custom parsers. It‚Äôs been removed in v3.0.0 as its functionality was a subset of what the Plugin API did. If you used it, please check how to migrate.
The second argument parsers passed to parsers.parse has been removed (#13268 by @fisker)‚Äã
The plugin's print function signature changed from
function parse(text: string, parsers: object, options: object): AST;
to
function parse(text: string, options: object): Promise<AST> | AST;
The second argument parsers has been removed, if you still need other parser during parse process, you can:


Import the plugin yourself (recommended)
import * as prettierPluginBabel from "prettier/plugins/babel";const myCustomPlugin = {  parsers: {    "my-custom-parser": {      async parse(text) {        const ast = await prettierPluginBabel.parsers.babel.parse(text);        ast.program.body[0].expression.callee.name = "_";        return ast;      },      astFormat: "estree",    },  },};


Get the parser from the options argument
function getParserFromOptions(options, parserName) {  const parserOrParserInitFunction = options.plugins.find(    (plugin) => plugin.parsers && Object.hasOwn(plugin.parsers, parserName),  )?.parsers[parserName];  return typeof parserOrParserInitFunction === "function"    ? parserOrParserInitFunction()    : parserOrParserInitFunction;}const myCustomPlugin = {  parsers: {    "my-custom-parser": {      async parse(text, options) {        const babelParser = await getParserFromOptions(options, "babel");        const ast = await babelParser.parse(text);        ast.program.body[0].expression.callee.name = "_";        return ast;      },      astFormat: "estree",    },  },};


undefined and null are not passed to plugin's print function (#13397 by @fisker)‚Äã
If your plugin happened to use print to print them, please check them in the parent node instead.
function print(path, print) {-  const value = path.getValue();-  if (!value?.type) {-    return String(value);-  }-  return path.map(print, "values");+  return path.map(({node}) => (node?.type ? print() : String(node)), "values");}
Allow using arbitrary truthy values for label docs (#13532 by @thorn0)‚Äã
The label doc builder has been changed. See the documentation.
getFileInfo() resolves config by default (#14108 by @fisker)‚Äã
options.resolveConfig default to true now, see the documentation.
Plugin search feature has been removed (#14759 by @fisker)‚Äã
The plugin auto search feature didn't work well when using pnpm, and cause slowness.
--plugin-search-dir, --no-plugin-search flags for CLI and pluginSearchDirs in API options has been removed in Prettier 3.0.
--plugin flag and plugins option should be used instead, see documentation.
CLI‚Äã
Ignore .gitignored files by default (#14731 by @fisker)‚Äã
Prettier ignores files ignored by .gitignore by default.
If you want the old behavior(only ignore files ignored by .prettierignore), use
prettier . --write --ignore-path=.prettierignore
Other Changes‚Äã
JavaScript‚Äã
Support the "decorated function" pattern (#10714 by @thorn0)‚Äã
In this case the developer is usually willing to sacrifice the readability of the arrow function's signature to get less indentation in its body. Prettier now recognizes this pattern and keeps the arrow function hugged even if the signature breaks.
// Prettier 2.8const Counter = decorator("my-counter")(  (props: { initialCount?: number; label?: string }) => {    // ...  });// Prettier 3.0const Counter = decorator("my-counter")((props: {  initialCount?: number;  label?: string;}) => {  // ...});
Fix cursor positioning for files containing emoji (#13340 by @fisker)‚Äã
$ cat test.jsconst { formatWithCursor } = await import("prettier");const code = "'üòÄüòÄüòÄüòÄ'";await formatWithCursor(code, {parser: "babel", cursorOffset: 9})# Prettier 2.8$ node test.js{ formatted: '"üòÄüòÄüòÄüòÄ";\n', cursorOffset: 5, comments: [] }# Prettier 3.0$ node test.js{ formatted: '"üòÄüòÄüòÄüòÄ";\n', cursorOffset: 9, comments: [] }
Fix edge cases of the first call argument expansion (#13341 by @thorn0)‚Äã
// Inputexport default whatever(function (a: {  aaaaaaaaa: string;  bbbbbbbbb: string;  ccccccccc: string;}) {  return null;}, "xyz");call(    function() {        return 1;    },    $var ?? $var ?? $var ?? $var ?? $var ?? $var ?? $var ?? $var ?? $var ?? 'test');// Prettier 2.8export default whatever(function (a: {  aaaaaaaaa: string;  bbbbbbbbb: string;  ccccccccc: string;}) {  return null;},"xyz");call(function () {  return 1;}, $var ??  $var ??  $var ??  $var ??  $var ??  $var ??  $var ??  $var ??  $var ??  "test");// Prettier 3.0export default whatever(function (a: {  aaaaaaaaa: string,  bbbbbbbbb: string,  ccccccccc: string,}) {  return null;}, "xyz");call(  function () {    return 1;  },  $var ??    $var ??    $var ??    $var ??    $var ??    $var ??    $var ??    $var ??    $var ??    "test",);
Fix indentation of arrow function chains in call arguments and binary expressions (#13391 by @thorn0)‚Äã
The motivation behind the chosen formatting is to make it clear how many arguments the call has.
However, there was a bug with the indentation of the first signature in the chain if that signature didn't fit on one line.
// Prettier 2.8askTrovenaBeenaDependsRowans(  glimseGlyphsHazardNoopsTieTie,  (      averredBathersBoxroomBuggyNurl,      anodyneCondosMalateOverateRetinol = "default"    ) =>    (annularCooeedSplicesWalksWayWay) =>    (kochabCooieGameOnOboleUnweave) =>      abugidicRomanocastorProvider,  weaponizedStellatedOctahedron);// Prettier 3.0askTrovenaBeenaDependsRowans(  glimseGlyphsHazardNoopsTieTie,  (    averredBathersBoxroomBuggyNurl,    anodyneCondosMalateOverateRetinol = "default",  ) =>    (annularCooeedSplicesWalksWayWay) =>    (kochabCooieGameOnOboleUnweave) =>      abugidicRomanocastorProvider,  weaponizedStellatedOctahedron,);
Don't break signature of hugged function expression if parameters are identifiers without types (#13410 by @thorn0)‚Äã
// Prettier 2.8export const Link = forwardRef<HTMLAnchorElement, LinkProps>(function Link(  props,  ref) {  return <ThemeUILink ref={ref} variant="default" {...props} />;});// Prettier 3.0export const Link = forwardRef<HTMLAnchorElement, LinkProps>(  function Link(props, ref) {    return <ThemeUILink ref={ref} variant="default" {...props} />;  },);
Fix interleaved comments (#13438 by @thorn0)‚Äã
// Inputfunction x() {} // first; // second// Prettier 2.8function x() {} // first // second// Prettier 3.0function x() {} // first// second
Support nestled JSDoc comments (#13445 by @thorn0)‚Äã
This kind of comments is used to document overloaded functions (see https://github.com/jsdoc/jsdoc/issues/1017).
// Input/** * @template T * @param {Type} type * @param {T} value * @return {Value} *//** * @param {Type} type * @return {Value} */function value(type, value) {  if (arguments.length === 2) {    return new ConcreteValue(type, value);  } else {    return new Value(type);  }}// Prettier 2.8/** * @template T * @param {Type} type * @param {T} value * @return {Value} */ /** * @param {Type} type * @return {Value} */function value(type, value) {  if (arguments.length === 2) {    return new ConcreteValue(type, value);  } else {    return new Value(type);  }}// Prettier 3.0/** * @template T * @param {Type} type * @param {T} value * @return {Value} *//** * @param {Type} type * @return {Value} */function value(type, value) {  if (arguments.length === 2) {    return new ConcreteValue(type, value);  } else {    return new Value(type);  }}
Fix unstable template literals with embedded languages (#13532 by @thorn0)‚Äã
If a template literal with embedded syntax is the only argument of a call or the body of an arrow function and has leading and trailing whitespace, it won't be printed on a new line.
// Inputfoo(/* HTML */ ` <!-- bar1 --> bar <!-- bar2 --> `);// Prettier 2.8 (first output)foo(  /* HTML */ `    <!-- bar1 -->    bar    <!-- bar2 -->  `);// Prettier 2.8 (second output)foo(/* HTML */ `  <!-- bar1 -->  bar  <!-- bar2 -->`);// Prettier 3.0 (first output)foo(/* HTML */ `  <!-- bar1 -->  bar  <!-- bar2 -->`);
Fix indention of expressions in template literals (#13621 by @fisker)‚Äã
// Input`              1. Go to ${chalk.green.underline(FOO_LINK)}              2. Click "${chalk.green(                "Run workflow"              )}" button, type "${chalk.yellow.underline(                version              )}", hit the "${chalk.bgGreen("Run workflow")}" button.`// Prettier 2.8`              1. Go to ${chalk.green.underline(FOO_LINK)}              2. Click "${chalk.green(                "Run workflow"              )}" button, type "${chalk.yellow.underline(  version)}", hit the "${chalk.bgGreen("Run workflow")}" button.`;// Prettier 3.0`              1. Go to ${chalk.green.underline(FOO_LINK)}              2. Click "${chalk.green(                "Run workflow",              )}" button, type "${chalk.yellow.underline(                version,              )}", hit the "${chalk.bgGreen("Run workflow")}" button.`;
Add support for "Explicit Resource Management" proposal (#13752 by @fisker, #14862 by @sosukesuzuki)‚Äã
The Stage 2 proposal "Explicit Resource Management" is now supported via Babel 7.20.0 and 7.22.0.
Also keep in mind our policy on non-standardized syntax before using this proposed syntax feature with Prettier.
// Examples{  using obj = g(); // block-scoped declaration  const r = obj.next();} // calls finally blocks in `g`{  await using obj = g(); // block-scoped declaration  const r = obj.next();} // calls finally blocks in `g`
Add support for "Import Reflection" proposal (#13771 by @fisker)‚Äã
The Stage 2 proposal "Import Reflection" is now supported via Babel 7.20.0. Also keep in mind our policy on non-standardized syntax before using this proposed syntax feature with Prettier.
// Examplesimport module x from "<specifier>";
Fix inconsistent between array/tuple and object/record (#14065 by @fisker)‚Äã
// Inputfoo.a().b().c([n, o])foo.a().b().c(#[n, o])foo.a().b().c({n, o})foo.a().b().c(#{n, o})// Prettier 2.8foo.a().b().c([n, o]);foo  .a()  .b()  .c(#[n, o]);foo.a().b().c({ n, o });foo  .a()  .b()  .c(#{ n, o });// Prettier 3.0foo.a().b().c([n, o]);foo.a().b().c(#[n, o]);foo.a().b().c({ n, o });foo.a().b().c(#{ n, o });
Fix cursor tracking inside JSX Text (#14163 by @fisker)‚Äã
// Prettier 2.8formatWithCursor(  ["<>a", "  <div>hi</div>", "</>"].join("\n"),  { cursorOffset: 3, parser: "babel" }).cursorOffset;// -> 2// Prettier 3.0(await formatWithCursor(  ["<>a", "  <div>hi</div>", "</>"].join("\n"),  { cursorOffset: 3, parser: "babel" })).cursorOffset;// -> 6
Avoid unnecessarily indenting nested await expressions (#14192 by @thorn0)‚Äã
A refinement of this change in v2.3. Sometimes there is no need to force indentation of nested await expressions.
// Prettier 2.8await Promise.all(  (    await readdir("src")  ).map((path) => {    import(`./${path}`);  }));// Prettier 3.0await Promise.all(  (await readdir("src")).map((path) => {    import(`./${path}`);  }),);
Support regexp modifiers proposal (#14391 by @fisker)‚Äã
See Regular Expression Pattern Modifiers for ECMAScript.
Fix missing parentheses and semicolons around prettier-ignored nodes (#14406 by @fisker)‚Äã
// Inputasync function request(url) {  return (    // prettier-ignore    await fetch(url)  ).json()}// Prettier 2.8async function request(url) {  return (    // prettier-ignore    await fetch(url).json()  );}// Prettier 3.0async function request(url) {  return (    // prettier-ignore    (await fetch(url)).json()  );}
// Inputfoo();// prettier-ignore[bar, baz].forEach(console.log)// Prettier 2.8 (--no-semi)foo()// prettier-ignore[bar, baz].forEach(console.log)// Prettier 3.0foo()// prettier-ignore;[bar, baz].forEach(console.log)
Remove unnecessary parentheses around class expression (#14409 by @fisker)‚Äã
// Inputcall(  @dec class {});// Prettier 2.8call(  (    @dec    class {}  ));// Prettier 3.0call(  @dec  class {},);
Add parentheses to head of ExpressionStatement instead of the whole statement (#14599 by @fisker)‚Äã
// Inputconst isArray = (object) => ({}).toString.call(foo) === "[object Array]";// Prettier 2.8const isArray = (object) => ({}.toString.call(foo) === "[object Array]");// Prettier 3.0const isArray = (object) => ({}).toString.call(foo) === "[object Array]";
Improve consistency between curried and non-curried arrow function (#14633 by @seiyab, @fisker)‚Äã
// InputY(() => a ? b : c);Y(() => () => a ? b : c);// Prettier 2.8Y(() => (a ? b : c));Y(() => () => a ? b : c);// Prettier 3.0Y(() => (a ? b : c));Y(() => () => (a ? b : c));
Fix empty line check between array elements (#14736 by @solarized-fox)‚Äã
// Input[  (a = b),  c // comment]// Prettier 2.8[  (a = b),  c, // comment];// Prettier 3.0[  (a = b),  c, // comment];
Support trailing comments in function parameters for all param types (#14835 by @pieterv)‚Äã
Support function parameter trailing comments for RestElement, ArrayPattern and ObjectPattern parameter node types.
// Inputfunction Foo(  ...bar  // Trailing comment) {}// Prettier 2.8function Foo(...bar) // Trailing comment{}// Prettier 3.0function Foo(  ...bar  // Trailing comment) {}
Support Import Attributes (#14861, #14863 by @sosukesuzuki)‚Äã
Support Import Attributes proposal.
import json from "./foo.json" with { type: "json" };import("./foo.json", { with: { type: "json" } });
TypeScript‚Äã
Fix leading comments in mapped types with readonly (#13427 by @thorn0, @sosukesuzuki)‚Äã
// Inputtype Type = {  // comment  readonly [key in Foo];};// Prettier 2.8type Type = {  readonly // comment  [key in Foo];};// Prettier 3.0type Type = {  // comment  readonly [key in Foo];};
Consistent dangling comments formatting for tuple types and arrays (#13608 by @sosukesuzuki)‚Äã
// Inputtype Foo = [   // comment];const bar = [   // comment];// Prettier 2.8type Foo = [// comment];const bar = [   // comment];// Prettier 3.0type Foo = [   // comment];const bar = [   // comment];
Fix union type should be printed in the multi-line variant when there are comments (#13860 by @PerfectPan)‚Äã
// Inputtype FooBar =  | Number // this documents the first option  | void // this documents the second option  ;// Prettier 2.8type FooBar = Number | void; // this documents the first option // this documents the second option// Prettier 3.0type FooBar =  | Number // this documents the first option  | void; // this documents the second option
Improve comment print and cursor tracking around type annotation (#14171 by @fisker)‚Äã
// Inputlet foo /* comment */ : number;// Prettier 2.8let foo: /* comment */ number;// Prettier 3.0<Same as input>
// Prettier 2.8prettier.formatWithCursor("let foo: number", {  cursorOffset: 7,  parser: "babel",}).cursorOffset;// -> 9// Prettier 3.0(  await prettier.formatWithCursor("let foo: number", {    cursorOffset: 7,    parser: "babel",  })).cursorOffset;// -> 7
Break on TypeScript parameter properties (#14402 by @seiyab)‚Äã
// Inputclass MyClass {  constructor(    protected x: number,    private y: string  ) {}}// Prettier 2.8class MyClass {  constructor(protected x: number, private y: string) {}}// Prettier 3.0class MyClass {  constructor(    protected x: number,    private y: string,  ) {}}
Fix formatting of union type with single type (#14654 by @fisker and @auvred)‚Äã
// Inputtype T =  | (    | {        value: number      }    | {        value: string      }  )// Prettier 2.8type T =  |      | {          value: number;        }      | {          value: string;        };// Prettier 3.0type T =  | {      value: number;    }  | {      value: string;    };
Improve new line detection in mapped type (#14659 by @fisker)‚Äã
// Inputtype A1 = { [A in B]:T}type A2 = {  [A in B]:T}// Prettier 2.8type A1 = {  [A in B]: T;};type A2 = {  [A in B]: T;};// Prettier 3.0type A1 = { [A in B]: T };type A2 = {  [A in B]: T;};
Line breaking after extends in type parameters (#14672, #14858 by @sosukesuzuki)‚Äã
// Inputexport type OuterType2<  LongerLongerLongerLongerInnerType extends LongerLongerLongerLongerLongerLongerLongerLongerOtherType> = { a: 1 };// Prettier 2.8export type OuterType2<  LongerLongerLongerLongerInnerType extends LongerLongerLongerLongerLongerLongerLongerLongerOtherType> = { a: 1 };// Prettier 3.0export type OuterType2<  LongerLongerLongerLongerInnerType extends    LongerLongerLongerLongerLongerLongerLongerLongerOtherType,> = { a: 1 };
Fix missing required comma in type parameters (#14688 by @fisker, @sosukesuzuki)‚Äã
Previously, we only print trailing comma when file extension is .tsx, turns out .mts, .cts files requires it to parse too.
// Inputexport const unsafeCoerce = <T,>(u: unknown): T => u as T// Prettier 2.8export const unsafeCoerce = <T>(u: unknown): T => u as T;// Prettier 3.0export const unsafeCoerce = <T,>(u: unknown): T => u as T;
Keep parentheses around TSInstantiationExpression followed by a property access (#14701 by @morsko1)‚Äã
// Input(Array<string>).a;(Array<string>)?.a;(Array<string>)[a];(Array<string>)?.[a];// Prettier 2.8Array<string>.a;Array<string>?.a;Array<string>[a];Array<string>?.[a];// Prettier 3.0(Array<string>).a;(Array<string>)?.a;(Array<string>)[a];(Array<string>)?.[a];
Fix issue with double semicolon caused by // prettier-ignore on a call signature line (#14830 by @ot07)‚Äã
// Inputtype Foo = {  (): void; // prettier-ignore  second: string;};// Prettier 2.8type Foo = {  (): void;; // prettier-ignore  second: string;};// Prettier 3.0type Foo = {  (): void; // prettier-ignore  second: string;};
Flow‚Äã
An object type in a declare function signature now breaks before the return type (#13396 by @thorn0)‚Äã
This behavior has been unified with how TypeScript is formatted.
// Inputdeclare function bla (props: { a: boolean, b: string, c: number }): Promise<Array<foo>>// Prettier 2.8declare function bla(props: { a: boolean, b: string, c: number }): Promise<  Array<foo>>;// Prettier 3.0declare function bla(props: {  a: boolean;  b: string;  c: number;}): Promise<Array<foo>>;
Support conditional type and infer type (#14573 by @SamChou19815)‚Äã
// Inputtype TestReturnType<T extends (...args: any[]) => any> = T extends (...args: any[]) => infer R ? R : any;// Prettier 2.8// Does not parse// Prettier 3.0type TestReturnType<T extends (...args: any[]) => any> = T extends (  ...args: any[]) => infer R  ? R  : any;
Support Mapped Types and keyof (#14619 by @jbrown215)‚Äã
// Inputtype Mapped = {[key in keyof O]:number};// Prettier 2.8// Does not parse// Prettier 3.0type Mapped = { [key in keyof O]: number };
Support type guards (#14767 by @panagosg7)‚Äã
// Inputfunction isString (x: mixed): x is string { return typeof x === "string"; }// Prettier 2.8// Does not parse// Prettier 3.0function isString(x: mixed): x is string {  return typeof x === 'string';}
CSS‚Äã
Improve custom properties format (#9209 by @fisker)‚Äã
Thanks to PostCSS 8.0, we can handle these edge cases on custom properties.
/* Input */:root {  --empty: ;  --JSON: [1, "2", {"three": {"a":1}}, [4]];  --javascript: function(rule) { console.log(rule) };}@supports (--element(".minwidth", { "minWidth": 300 })) {  [--self] {    background: greenyellow;  }}/* Prettier 2.8 */SyntaxError: (postcss) CssSyntaxError Missed semicolon (3:20)  1 | :root {  2 |   --empty: ;> 3 |   --JSON: [1, "2", {"three": {"a":1}}, [4]];    |                    ^  4 |   --javascript: function(rule) { console.log(rule) };  5 | }  6 |/* Prettier 3.0 */:root {  --empty: ;  --JSON: [1, "2", {"three": {"a": 1}}, [4]];  --javascript: function(rule) {console.log(rule)};}@supports (--element(".minwidth", {"minWidth": 300})) {  [--self] {    background: greenyellow;  }}
Keep trailing-comma for var function (#13402 by @sosukesuzuki)‚Äã
/* Input */.foo {  --bar: var(--baz,);}/* Prettier 2.8 */.foo {  --bar: var(--baz);}/* Prettier 3.0 */.foo {  --bar: var(--baz,);}
Fix line break in CSS declaration with comma (#14208 by @mvorisek)‚Äã
// Input.myclass {  box-shadow:    inset 0 0 10px #555,    0 0 20px black;}// Prettier 2.8.myclass {  box-shadow: inset 0 0 10px #555, 0 0 20px black;}// Prettier 3.0.myclass {  box-shadow:    inset 0 0 10px #555,    0 0 20px black;}
Fix url contains comma (#14476 by @seiyab)‚Äã
/* Input */@font-face {  src: url(RobotoFlex-VariableFont_GRAD,XTRA,YOPQ,YTAS,YTDE,YTFI,YTLC,YTUC,opsz,slnt,wdth,wght.ttf);}/* Prettier 2.8 */@font-face {  src: url(RobotoFlex-VariableFont_GRADXTRAYOPQYTASYTDEYTFIYTLCYTUCopszslntwdthwght.ttf);}/* Prettier 3.0 */@font-face {  src: url(RobotoFlex-VariableFont_GRAD,XTRA,YOPQ,YTAS,YTDE,YTFI,YTLC,YTUC,opsz,slnt,wdth,wght.ttf);}
SCSS‚Äã
Fix formatting string value that includes escape \ (#13487 by @sosukesuzuki)‚Äã
/* Input */$description: "Lorem ipsum dolor sit \"amet\", consectetur adipiscing elit, " +  "sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.";/* Prettier 2.8 */$description: 'Lorem ipsum dolor sit "amet", consectetur adipiscing elit, '+ "sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.";/* Prettier 3.0 */$description: 'Lorem ipsum dolor sit "amet", consectetur adipiscing elit, ' +  "sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.";
Less‚Äã
Fix interpolation parse error (#11343 by @fisker)‚Äã
// Input@{selector}-title{ @{prop}-size: @{color} }// Prettier 2.8SyntaxError: CssSyntaxError: Unknown word (1:20)> 1 | @{selector}-title{ @{prop}-size: @{color} }// Prettier 3.0@{selector}-title {  @{prop}-size: @{color};}
Keep inline JavaScript code as it is (#14109 by @fisker)‚Äã
// Input.calcPxMixin() {  @functions: ~`(function() {    const designWidth = 3840    const actualWidth = 5760    this.calcPx = function(_) {      return _ * actualWidth / designWidth + 'px'    }  })()`;}// Prettier 2.8.calcPxMixin() {  @functions: ~`(      function() {const designWidth = 3840 const actualWidth = 5760 this.calcPx =        function(_) {return _ * actualWidth / designWidth + "px"}}    )    () `;}// Prettier 3.0<Same as input>
HTML‚Äã
Print HTML5 doctype in lowercase (#7391 by @fisker)‚Äã
<!-- Input --><!DocType html><html><head></head><body></body></html><!-- Prettier 2.8 --><!DOCTYPE html><html>  <head></head>  <body></body></html><!-- Prettier 3.0 --><!doctype html><html>  <head></head>  <body></body></html>
Update angular-html-parser (#13578 by @thorn0)‚Äã
Prettier's fork of Angular's HTML parser was synced with the upstream.
Format <script> inside SVG (#14400 by @fisker)‚Äã
<!-- Input --><svg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg"><script>document.addEventListener('DOMContentLoaded', () => {  const element = document.getElementById('foo')   if (element) {element.fillStyle = 'currentColor'}});</script></svg><!-- Prettier 2.8 --><svg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">  <script>    document.addEventListener( 'DOMContentLoaded', () => { const element =    document.getElementById('foo') if (element) { element.fillStyle =    'currentColor' } });  </script></svg><!-- Prettier 3.0 --><svg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">  <script>    document.addEventListener("DOMContentLoaded", () => {      const element = document.getElementById("foo");      if (element) {        element.fillStyle = "currentColor";      }    });  </script></svg>
Recognize <search> element (#14615 by @fisker)‚Äã
HTML spec added <search> element.
<!-- Input --><SEARCH title="Website">  ...</SEARCH><!-- Prettier 2.8 --><SEARCH title="Website"> ... </SEARCH><!-- Prettier 3.0 --><search title="Website">...</search>
Vue‚Äã
Ignore htmlWhitespaceSensitivity when formatting Vue SFC root blocks (#14401 by @fisker)‚Äã
<!-- Input --><docs lang=unknown></docs><docs lang=unknown></docs><!-- display: inline --><docs lang=unknown></docs><docs lang=unknown style="display: inline"></docs><!-- Prettier 2.8 (--html-whitespace-sensitivity=strict) --><docs lang="unknown"></docs>><docs lang="unknown"></docs><!-- display: inline --><docs lang="unknown"></docs>><docs lang="unknown" style="display: inline"></docs><!-- Prettier 3.0 --><docs lang="unknown"></docs><docs lang="unknown"></docs><!-- display: inline --><docs lang="unknown"></docs><docs lang="unknown" style="display: inline"></docs>
Format TypeScript expression in attribute bindings (#14506 by @seiyab)‚Äã
<!-- Input --><script lang="ts"></script><template>  <comp :foo="   (a:string)=>1"/></template><!-- Prettier 2.8 --><script lang="ts"></script><template>  <comp :foo="   (a:string)=>1" /></template><!-- Prettier 3.0 --><script lang="ts"></script><template>  <comp :foo="(a: string) => 1" /></template>
Fix Vue filter detection (#14542 by @fisker)‚Äã
<!-- Input --><template>  <div>    {{      fn(        bitwise | or | operator | a_long_long_long_long_long_long_long_long_long_long_variable      )      | filter1      | filter2      | filter3      | filter4    }}  </div></template><!-- Prettier 2.8 --><template>  <div>    {{      fn(        bitwise          | or          | operator          | a_long_long_long_long_long_long_long_long_long_long_variable      )        | filter1        | filter2        | filter3        | filter4    }}  </div></template><!-- Prettier 3.0 --><template>  <div>    {{      fn(        bitwise |          or |          operator |          a_long_long_long_long_long_long_long_long_long_long_variable,      )        | filter1        | filter2        | filter3        | filter4    }}  </div></template>
Avoid unnecessary leading semicolon (#14557 by @fisker)‚Äã
<!-- Input --><template>  <div @click="[foo, bar].forEach(fn => void fn())"></div></template><!-- Prettier 2.8 (With `--no-semi` option) --><template>  <div @click=";[foo, bar].forEach((fn) => void fn())"></div></template><!-- Prettier 3.0 --><template>  <div @click="[foo, bar].forEach((fn) => void fn())"></div></template>
Format TS expressions when any script tag has lang="ts" (#14587 by @seiyab)‚Äã
<!-- Input --><script></script><script setup lang="ts"></script><template>  {{ (x      as      number).toFixed(2) }}</template><!-- Prettier 2.8 --><script></script><script setup lang="ts"></script><template>  {{ (x      as      number).toFixed(2) }}</template><!-- Prettier 3.0 --><script></script><script setup lang="ts"></script><template>  {{ (x as number).toFixed(2) }}</template>
Angular‚Äã
Update @angular/compiler to v14 (#13609 by @fisker)‚Äã

Support shorthand object
Drop support for quote expressions

<!-- Input --><div [input]="{a, b   :   2 }"></div><!-- Prettier 2.8 -->Error: Cannot find front char /:/ from index 0 in "{a, b   :   2 }"<!-- Prettier 3.0 --><div [input]="{ a, b: 2 }"></div>
<!-- Input --><a [href]="http://google.com">Click me</a><!-- Prettier 2.8 --><a [href]="http:  //google.com">Click me</a><!-- Prettier 3.0 --><a [href]="http://google.com">Click me</a>
Fix parentheses with nullish coalescing operator (#14216 by @thron0)‚Äã
<!-- Input --><img [src]="(x && y) ?? z" /><!-- Prettier 2.8 --><img [src]="x && y ?? z" /><!-- Prettier 3.0 --><img [src]="(x && y) ?? z" />
Support computed optional chaining (#14658 by @fisker)‚Äã
<!-- Input --><img [src]="   a?.[0]" /><!-- Prettier 2.8 --><img [src]="   a?.[0]" /><!-- Prettier 3.0 --><img [src]="a?.[0]" />
Remove space after pipe name (#14961 by @waterplea)‚Äã
We introduced a new format for pipe in Prettier 2.8, but this was not accepted by the community.
Therefore, we are introducing a new format that reflects community input.
For more information on the discussion, please see https://github.com/prettier/prettier/issues/13887.
<!-- Input --><my-component  [value]="value | transform: arg1 : arg2 | format: arg3 : arg4"></my-component><!-- Prettier 2.8 --><my-component  [value]="value | transform : arg1 : arg2 | format : arg3 : arg4"></my-component><!-- Prettier 3.0 --><my-component  [value]="value | transform: arg1 : arg2 | format: arg3 : arg4"></my-component>
Markdown‚Äã
Preserve multiple spaces in inline code (#13590 by @kachkaev and @thorn0)‚Äã
Previously, multiple whitespace characters in inline code were collapsed into a single space. This is no longer happening to match CommonMark spec.
<!-- Input -->`   foo   bar   baz   `<!-- Prettier 2.8 -->` foo bar baz `<!-- Prettier 3.0 -->`   foo   bar   baz   `
API‚Äã
Add .d.ts files (#14212 by @sosukesuzuki, @fisker)‚Äã
Add type definition files required to use Prettier's JavaScript API from TypeScript. This eliminates the need for users to install @types/prettier.
Update prettier.util (#14317, #14320 by @fisker)‚Äã


Added prettier.util.getNextNonSpaceNonCommentCharacter


Changed prettier.util.getNextNonSpaceNonCommentCharacter
Signature changed from
function getNextNonSpaceNonCommentCharacterIndex<N>(  text: string,  node: N,  locEnd: (node: N) => number,): number | false;
to
function getNextNonSpaceNonCommentCharacterIndex(  text: string,  startIndex: number,): number | false;


Changed prettier.util.isPreviousLineEmpty
Signature changed from
function isPreviousLineEmpty<N>(  text: string,  node: N,  locStart: (node: N) => number,): boolean;
to
function isPreviousLineEmpty(text: string, startIndex: number): boolean;


Changed prettier.util.isNextLineEmpty
Signature changed from
function isNextLineEmpty<N>(  text: string,  node: N,  locEnd: (node: N) => number,): boolean;
to
function isNextLineEmpty(text: string, startIndex: number): boolean;


Deprecated prettier.util.isNextLineEmptyAfterIndex
Use prettier.util.isNextLineEmpty instead.


See the documentation for details.
Fix plugin loading cache (#14576 by @fisker)‚Äã
Plugin instances are incorrectly memoized, check this issue for details.
Stop formatting unknown code with babel parser (#14718 by @fisker)‚Äã
await prettier.format("foo")// Prettier 2.8No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred.'foo;\n'// Prettier 3.0UndefinedParserError: No parser and no file path given, couldn't infer a parser.
CLI‚Äã
Updated failure message to be more informative (#11369 by @webark)‚Äã
Updated the "Forgot to run Prettier?" to "Run Prettier with --write to fix."
This keeps the same spirit of the message, but is less likely to be
misinterpreted as it's a more formal message rather than being
somewhat familial.
Change --loglevel to --log-level (#13204 by @sosukesuzuki)‚Äã
# Prettier 2.8prettier test.js --loglevel=debug# Prettier 3.0prettier test.js --log-level=debug
Accept multiple --ignore-path (#14332 by @fisker)‚Äã
You can now pass multiple --ignore-path.
prettier . --ignore-path=.prettier-ignore --ignore-path=.eslintignore
Display posix style paths on Windows (#14333 by @fisker)‚Äã
Align with other tools like ESLint and Stylelint.
// Prettier 2.8Checking formatting...[warn] src\utils\create-get-visitor-keys.js[warn] src\utils\unexpected-node-error.js[warn] Code style issues found in 2 files. Forgot to run Prettier?// Prettier 3.0Checking formatting...[warn] src/utils/create-get-visitor-keys.js[warn] src/utils/unexpected-node-error.js[warn] Code style issues found in 2 files. Forgot to run Prettier?
Don‚Äôt expand globs via symbolic links (#14627 by @andersk)‚Äã
Prettier no longer follows symbolic links while expanding command line
arguments. This avoids problems in many scenarios such as symlinks
outside the source tree, symlinks to ignored files, and cycles of
symlinks.
Print line breaking after file path with errors (#14788 by @sosukesuzuki)‚Äã
Previously, only the --write option printed a newline before the error, but other options and no options print a newline as well.
# Inputprettier ./test.js# Prettier 2.8test.js[error] test.js: SyntaxError: Unexpected token: ')' (1:6)[error] > 1 | 1 (+-) hoge[error]     |      ^# Prettier 3.0test.js[error] test.js: SyntaxError: Unexpected token: ')' (1:6)[error] > 1 | 1 (+-) hoge[error]     |
Clear filename before print ignored file code to screen (#14794 by @fisker)‚Äã
# Inputecho test.js > .prettierignoreecho code > test.jsprettier ./test.js# Prettier 2.8test.jscode# Prettier 3.0codeEdit this pageNewer postA curious case of the ternariesOlder postPrettier 2.8: improve --cache CLI option and TypeScript 4.9 satisfies operator!\n\n\n\nPrettier 2.8: improve --cache CLI option and TypeScript 4.9 satisfies operator!November 23, 2022 ¬∑ 7 min readSosuke SuzukiThis release includes improvements to the --cache option added in 2.7. A new --cache-location option has been added, and a bug that saved the cache even when --write wasn't specified has been fixed.
We're also adding support for TypeScript 4.9 satisfies operator!
If you enjoy Prettier and would like to support our work, consider sponsoring us directly via our OpenCollective or by sponsoring the projects we depend on, including typescript-eslint, remark, and Babel.
The Prettier team plans to release 3.0 within the next few months. If you are a plugin developer, get ready for the migration. Visit the migration guide and issue #13606 for more information.
Highlights‚Äã
TypeScript‚Äã
Support TypeScript 4.9 satisfies operator (#13764, #13783, #13872 by @sosukesuzuki)‚Äã
const palette = {  red: [255, 0, 0],  green: "#00ff00",  blue: [0, 0, 255]} satisfies Record<Colors, string | RGB>;
Auto-Accessors in Classes will be supported in an upcoming 2.8 patch release. We have de-scoped them for now to ship satisfies operator sooner.
CLI‚Äã
Do not save the cache if the --write option wasn't specified (#13016 by @Milly)‚Äã
# Prettier 2.7$ prettier --cache foo.js# This shows formatted contents of `foo.js`.# Then cache is created and `foo.js` is flagged as already formatted.$ prettier --cache --write foo.jsfoo.js 2ms (cached)# "... (cached)" means the file is already formatted, so nothing is done this time.# Prettier 2.8$ prettier --cache foo.js# Show formatted contents of `foo.js`.$ prettier --cache --write foo.jsfoo.js 2ms# `foo.js` is formatted now.
Add --cache-location option (#13019 by @sosukesuzuki)‚Äã
By default, Prettier CLI saves the cache file for the --cache option at ./node_modules/.cache/prettier/.prettier-cache. This can be overridden now:
prettier --write --cache --cache-location=my_cache_file src
Other Changes‚Äã
JavaScript‚Äã
Fix docblock parsing (#13054 by @fisker)‚Äã
// With `--insert-pragma` flag// Input/* comment */foo()// Prettier 2.7/** * /* comment * * @format */foo();// Prettier 2.8/** * comment * * @format */foo();
Fix range format for function bodies (#13173 by @thorn0)‚Äã
// Inputlet fn = (() => {  return; ////^^^^^^^^^^ - range});// Prettier 2.7let fn = (() => {  return; //};);// Prettier 2.8let fn = (() => {  return; //});
Fix inconsistent formatting for multiline strings (#13274 by @GlebDolzhikov)‚Äã
// Inputconst loremIpsumFooBazBar1 = 'Multiline string\         Multiline string\'const loremIpsumFooBazBar2 = 'Multiline string\         Multiline string\         Multiline string'// Prettier 2.7const loremIpsumFooBazBar1 = "Multiline string\         Multiline string\";const loremIpsumFooBazBar2 =  "Multiline string\         Multiline string\         Multiline string";// Prettier 2.8const loremIpsumFooBazBar1 =  "Multiline string\         Multiline string\";const loremIpsumFooBazBar2 =  "Multiline string\         Multiline string\         Multiline string";
TypeScript‚Äã
Fix parens in inferred function return types with extends (#13289 by @GlebDolzhikov)‚Äã
// Inputtype Foo<T> = T extends (...a: any[]) => (infer R extends string) ? R : never;// Prettier 2.7type Foo<T> = T extends (...a: any[]) => infer R extends string ? R : never;// Prettier 2.8type Foo<T> = T extends ((...a: any[]) => infer R extends string) ? R : never;
CSS‚Äã
Fix formatting of long :is, :where, and :not selectors (#13577 by @j-f1)‚Äã
Pseudo-selectors like :is, :where, and :not that can take multiple selectors as arguments are now formatted like function calls are in other languages. Previously, no special significance was attached to the commas between their ‚Äúarguments,‚Äù leading to confusing wrapping behavior. There are likely still improvements to be made here ‚Äî please open an issue with some example code if you find something that doesn‚Äôt look as expected.
/* Input */:where(  label > input:valid,  label > textarea:not(:empty),  label > button[disabled]) ~ .errors > .error { display: none; }/* Prettier 2.7 */:where(label > input:valid, label > textarea:not(:empty), label    > button[disabled])  ~ .errors  > .error {  display: none;}/* Prettier 2.8 */:where(    label > input:valid,    label > textarea:not(:empty),    label > button[disabled]  )  ~ .errors  > .error {  display: none;}
SCSS‚Äã
Fix: extra space between '#' and '{' (#13286 by @jspereiramoura)‚Äã
// Inputpadding: var(--spacer#{(1) + 2});// Prettier 2.7padding: var(--spacer# {(1) + 2});// Prettier 2.8padding: var(--spacer#{(1) + 2});
Angular‚Äã
Insert spaces in pipe (#13100 by @sosukesuzuki)‚Äã
<!-- Input --><tui-line-chart  [value]="chart | tuiFilter : filter : range | tuiMapper : toNumbers : range"></tui-line-chart><!-- Prettier 2.7 --><tui-line-chart  [value]="chart | tuiFilter: filter:range | tuiMapper: toNumbers:range"></tui-line-chart><!-- Prettier 2.8 --><tui-line-chart  [value]="chart | tuiFilter : filter : range | tuiMapper : toNumbers : range"></tui-line-chart>
Ember / Handlebars‚Äã
Correctly format custom "else if" blocks (#13507 by @jamescdavis)‚Äã
A template transform can be used to create custom block keywords that behave similar to if. This updates printer-glimmer to correctly recognize and format the "else if" case when "if" is a custom keyword.
{{! Input }}{{#when isAtWork}}  Ship that code!{{else when isReading}}  You can finish War and Peace eventually...{{else}}  Go to bed!{{/when}}{{! Prettier 2.7 }}{{#when isAtWork}}  Ship that code!{{else}}{{#when isReading}}    You can finish War and Peace eventually...  {{else}}    Go to bed!  {{/when}}{{/when}}{{! Prettier 2.8 }}{{#when isAtWork}}  Ship that code!{{else when isReading}}  You can finish War and Peace eventually...{{else}}  Go to bed!{{/when}}
Markdown‚Äã
Preserve inline code line breaks if --prose-wrap=preserve (#11373 by @andersk)‚Äã
<!-- Input -->Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod `temporincididunt` ut labore et dolore magna aliqua.<!-- Prettier 2.7 -->Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod `tempor incididunt` ut labore et dolore magna aliqua.<!-- Prettier 2.8 -->Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod `temporincididunt` ut labore et dolore magna aliqua.
MDX‚Äã
Improve MDX range ignore support (#12208 by @nickrttn)‚Äã
Adds support for using Markdown range ignore directives in MDX, using JSX comments.
// Input{/* prettier-ignore-start */}export const Hello = () => {  return (<p>  Hello</p>)}{/* prettier-ignore-end */}// Prettier 2.7 (throws an error)TypeError: Cannot read properties of undefined (reading 'type')// Prettier 2.8{/* prettier-ignore-start */}export const Hello = () => {  return (<p>  Hello</p>)}{/* prettier-ignore-end */}
API‚Äã
"Doc Explorer" mode for the Playground (#10183 by @thorn0)‚Äã
Switch the parser option to the special doc-explorer value to play with Prettier's intermediate representation and see how it's printed with different options.
Fix doc printer issue when using ifBreak inside group (#12362 by @fisker)‚Äã
// Input//                                                                              |80for (const number of [123_123_123, 123_123_123, 123_123_123, 123_123_123, 12]) {}// Prettier 2.7for (const number of [  123_123_123, 123_123_123, 123_123_123, 123_123_123, 12,]) {}// Prettier 2.8for (const number of [123_123_123, 123_123_123, 123_123_123, 123_123_123, 12]) {}
"Rethrow embed errors" checkbox on the Playground (#13227 by @thorn0)‚Äã
Previously, the behavior of the Playground was confusingly inconsistent with the local behavior of Prettier in that it surfaced parsing errors in embedded languages for debug purposes. Now this behavior is controlled by a checkbox and disabled by default.
CLI‚Äã
Infer parser for .lintstagedrc (#13081 by @OrRosenblatt)‚Äã
A .lintstagedrc file (without extension) is handled using json and yaml parsers.Edit this page\n\nPrettier 2.8: improve --cache CLI option and TypeScript 4.9 satisfies operator!November 23, 2022 ¬∑ 7 min readSosuke SuzukiThis release includes improvements to the --cache option added in 2.7. A new --cache-location option has been added, and a bug that saved the cache even when --write wasn't specified has been fixed.
We're also adding support for TypeScript 4.9 satisfies operator!
If you enjoy Prettier and would like to support our work, consider sponsoring us directly via our OpenCollective or by sponsoring the projects we depend on, including typescript-eslint, remark, and Babel.
The Prettier team plans to release 3.0 within the next few months. If you are a plugin developer, get ready for the migration. Visit the migration guide and issue #13606 for more information.
Highlights‚Äã
TypeScript‚Äã
Support TypeScript 4.9 satisfies operator (#13764, #13783, #13872 by @sosukesuzuki)‚Äã
const palette = {  red: [255, 0, 0],  green: "#00ff00",  blue: [0, 0, 255]} satisfies Record<Colors, string | RGB>;
Auto-Accessors in Classes will be supported in an upcoming 2.8 patch release. We have de-scoped them for now to ship satisfies operator sooner.
CLI‚Äã
Do not save the cache if the --write option wasn't specified (#13016 by @Milly)‚Äã
# Prettier 2.7$ prettier --cache foo.js# This shows formatted contents of `foo.js`.# Then cache is created and `foo.js` is flagged as already formatted.$ prettier --cache --write foo.jsfoo.js 2ms (cached)# "... (cached)" means the file is already formatted, so nothing is done this time.# Prettier 2.8$ prettier --cache foo.js# Show formatted contents of `foo.js`.$ prettier --cache --write foo.jsfoo.js 2ms# `foo.js` is formatted now.
Add --cache-location option (#13019 by @sosukesuzuki)‚Äã
By default, Prettier CLI saves the cache file for the --cache option at ./node_modules/.cache/prettier/.prettier-cache. This can be overridden now:
prettier --write --cache --cache-location=my_cache_file src
Other Changes‚Äã
JavaScript‚Äã
Fix docblock parsing (#13054 by @fisker)‚Äã
// With `--insert-pragma` flag// Input/* comment */foo()// Prettier 2.7/** * /* comment * * @format */foo();// Prettier 2.8/** * comment * * @format */foo();
Fix range format for function bodies (#13173 by @thorn0)‚Äã
// Inputlet fn = (() => {  return; ////^^^^^^^^^^ - range});// Prettier 2.7let fn = (() => {  return; //};);// Prettier 2.8let fn = (() => {  return; //});
Fix inconsistent formatting for multiline strings (#13274 by @GlebDolzhikov)‚Äã
// Inputconst loremIpsumFooBazBar1 = 'Multiline string\         Multiline string\'const loremIpsumFooBazBar2 = 'Multiline string\         Multiline string\         Multiline string'// Prettier 2.7const loremIpsumFooBazBar1 = "Multiline string\         Multiline string\";const loremIpsumFooBazBar2 =  "Multiline string\         Multiline string\         Multiline string";// Prettier 2.8const loremIpsumFooBazBar1 =  "Multiline string\         Multiline string\";const loremIpsumFooBazBar2 =  "Multiline string\         Multiline string\         Multiline string";
TypeScript‚Äã
Fix parens in inferred function return types with extends (#13289 by @GlebDolzhikov)‚Äã
// Inputtype Foo<T> = T extends (...a: any[]) => (infer R extends string) ? R : never;// Prettier 2.7type Foo<T> = T extends (...a: any[]) => infer R extends string ? R : never;// Prettier 2.8type Foo<T> = T extends ((...a: any[]) => infer R extends string) ? R : never;
CSS‚Äã
Fix formatting of long :is, :where, and :not selectors (#13577 by @j-f1)‚Äã
Pseudo-selectors like :is, :where, and :not that can take multiple selectors as arguments are now formatted like function calls are in other languages. Previously, no special significance was attached to the commas between their ‚Äúarguments,‚Äù leading to confusing wrapping behavior. There are likely still improvements to be made here ‚Äî please open an issue with some example code if you find something that doesn‚Äôt look as expected.
/* Input */:where(  label > input:valid,  label > textarea:not(:empty),  label > button[disabled]) ~ .errors > .error { display: none; }/* Prettier 2.7 */:where(label > input:valid, label > textarea:not(:empty), label    > button[disabled])  ~ .errors  > .error {  display: none;}/* Prettier 2.8 */:where(    label > input:valid,    label > textarea:not(:empty),    label > button[disabled]  )  ~ .errors  > .error {  display: none;}
SCSS‚Äã
Fix: extra space between '#' and '{' (#13286 by @jspereiramoura)‚Äã
// Inputpadding: var(--spacer#{(1) + 2});// Prettier 2.7padding: var(--spacer# {(1) + 2});// Prettier 2.8padding: var(--spacer#{(1) + 2});
Angular‚Äã
Insert spaces in pipe (#13100 by @sosukesuzuki)‚Äã
<!-- Input --><tui-line-chart  [value]="chart | tuiFilter : filter : range | tuiMapper : toNumbers : range"></tui-line-chart><!-- Prettier 2.7 --><tui-line-chart  [value]="chart | tuiFilter: filter:range | tuiMapper: toNumbers:range"></tui-line-chart><!-- Prettier 2.8 --><tui-line-chart  [value]="chart | tuiFilter : filter : range | tuiMapper : toNumbers : range"></tui-line-chart>
Ember / Handlebars‚Äã
Correctly format custom "else if" blocks (#13507 by @jamescdavis)‚Äã
A template transform can be used to create custom block keywords that behave similar to if. This updates printer-glimmer to correctly recognize and format the "else if" case when "if" is a custom keyword.
{{! Input }}{{#when isAtWork}}  Ship that code!{{else when isReading}}  You can finish War and Peace eventually...{{else}}  Go to bed!{{/when}}{{! Prettier 2.7 }}{{#when isAtWork}}  Ship that code!{{else}}{{#when isReading}}    You can finish War and Peace eventually...  {{else}}    Go to bed!  {{/when}}{{/when}}{{! Prettier 2.8 }}{{#when isAtWork}}  Ship that code!{{else when isReading}}  You can finish War and Peace eventually...{{else}}  Go to bed!{{/when}}
Markdown‚Äã
Preserve inline code line breaks if --prose-wrap=preserve (#11373 by @andersk)‚Äã
<!-- Input -->Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod `temporincididunt` ut labore et dolore magna aliqua.<!-- Prettier 2.7 -->Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod `tempor incididunt` ut labore et dolore magna aliqua.<!-- Prettier 2.8 -->Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod `temporincididunt` ut labore et dolore magna aliqua.
MDX‚Äã
Improve MDX range ignore support (#12208 by @nickrttn)‚Äã
Adds support for using Markdown range ignore directives in MDX, using JSX comments.
// Input{/* prettier-ignore-start */}export const Hello = () => {  return (<p>  Hello</p>)}{/* prettier-ignore-end */}// Prettier 2.7 (throws an error)TypeError: Cannot read properties of undefined (reading 'type')// Prettier 2.8{/* prettier-ignore-start */}export const Hello = () => {  return (<p>  Hello</p>)}{/* prettier-ignore-end */}
API‚Äã
"Doc Explorer" mode for the Playground (#10183 by @thorn0)‚Äã
Switch the parser option to the special doc-explorer value to play with Prettier's intermediate representation and see how it's printed with different options.
Fix doc printer issue when using ifBreak inside group (#12362 by @fisker)‚Äã
// Input//                                                                              |80for (const number of [123_123_123, 123_123_123, 123_123_123, 123_123_123, 12]) {}// Prettier 2.7for (const number of [  123_123_123, 123_123_123, 123_123_123, 123_123_123, 12,]) {}// Prettier 2.8for (const number of [123_123_123, 123_123_123, 123_123_123, 123_123_123, 12]) {}
"Rethrow embed errors" checkbox on the Playground (#13227 by @thorn0)‚Äã
Previously, the behavior of the Playground was confusingly inconsistent with the local behavior of Prettier in that it surfaced parsing errors in embedded languages for debug purposes. Now this behavior is controlled by a checkbox and disabled by default.
CLI‚Äã
Infer parser for .lintstagedrc (#13081 by @OrRosenblatt)‚Äã
A .lintstagedrc file (without extension) is handled using json and yaml parsers.Edit this pageNewer postPrettier 3.0: Hello, ECMAScript Modules!Older postPrettier 2.7: new --cache CLI option and TypeScript 4.7 syntax!\n\n\n\n