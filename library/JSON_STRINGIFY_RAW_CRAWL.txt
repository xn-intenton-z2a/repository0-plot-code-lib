JSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nResources for Developers, by DevelopersDocumenting web technologies, including CSS, HTML, and JavaScript, since 2005.Search MDNClear search inputSearchFeatured articlesBlogJavaScript Temporal is comingA new way to handle dates and times is being added to JavaScript. Let's take a look at Temporal, what problems it solves, the current state, and what you'll find in the new documentation about it on MDN.
CSSCSS anchor positioningThe CSS anchor positioning module defines features that allow you to tether elements together. Certain elements are defined as anchor elements; anchor-positioned elements can then have their size and position set based on the size and location of the anchor elements to which they are bound.
Web APIsUsing the View Transition APIThis article explains the theory behind how the View Transition API works, how to create view transitions and customize the transition animations, and how to manipulate active view transitions. This covers view transitions for both DOM state updates in a single-page app (SPA), and navigating between documents in a multi-page app (MPA).
JavaScriptTemporalThe Temporal object enables date and time management in various scenarios, including built-in time zone and calendar representation, wall-clock time conversions, arithmetics, formatting, and more. It is designed as a full replacement for the Date object.
Latest newsMDN 2024 content projectsdeveloper.mozilla.org3 months agoA new learning experience on MDNdeveloper.mozilla.org4 months agoIntroducing the new MDN Community pagedeveloper.mozilla.org6 months agoRecent contributionszh-CN: create `webRequest.CertificateInfo`mdn/translated-contenta day ago[zh-tw] Global attributes classmdn/translated-contenta day agozh-cn: add new page for br instructionmdn/translated-content13 hours agozh-cn: add new page for block instructionmdn/translated-content13 hours agozh-cn: add new page for call instructionmdn/translated-content13 hours agoFix title typomdn/content8 hours agosimplify WritableStream examplemdn/content7 hours agoMake all JS articles reachable via sidebarmdn/content5 hours agoAdd more links to the Wasm sidebarmdn/contentan hour agoMerge Transforming_XML_with_XSLT subarticles into itselfmdn/contentan hour agoContributor SpotlightYash Raj BhartiMDN resonates with my passion to build a consistent and open web, where developers can learn and grow.Get involved →\n\nResources for Developers, by DevelopersDocumenting web technologies, including CSS, HTML, and JavaScript, since 2005.Search MDNClear search inputSearchFeatured articlesBlogJavaScript Temporal is comingA new way to handle dates and times is being added to JavaScript. Let's take a look at Temporal, what problems it solves, the current state, and what you'll find in the new documentation about it on MDN.
CSSCSS anchor positioningThe CSS anchor positioning module defines features that allow you to tether elements together. Certain elements are defined as anchor elements; anchor-positioned elements can then have their size and position set based on the size and location of the anchor elements to which they are bound.
Web APIsUsing the View Transition APIThis article explains the theory behind how the View Transition API works, how to create view transitions and customize the transition animations, and how to manipulate active view transitions. This covers view transitions for both DOM state updates in a single-page app (SPA), and navigating between documents in a multi-page app (MPA).
JavaScriptTemporalThe Temporal object enables date and time management in various scenarios, including built-in time zone and calendar representation, wall-clock time conversions, arithmetics, formatting, and more. It is designed as a full replacement for the Date object.
Latest newsMDN 2024 content projectsdeveloper.mozilla.org3 months agoA new learning experience on MDNdeveloper.mozilla.org4 months agoIntroducing the new MDN Community pagedeveloper.mozilla.org6 months agoRecent contributionszh-CN: create `webRequest.CertificateInfo`mdn/translated-contenta day ago[zh-tw] Global attributes classmdn/translated-contenta day agozh-cn: add new page for br instructionmdn/translated-content13 hours agozh-cn: add new page for block instructionmdn/translated-content13 hours agozh-cn: add new page for call instructionmdn/translated-content13 hours agoFix title typomdn/content8 hours agosimplify WritableStream examplemdn/content7 hours agoMake all JS articles reachable via sidebarmdn/content5 hours agoAdd more links to the Wasm sidebarmdn/contentan hour agoMerge Transforming_XML_with_XSLT subarticles into itselfmdn/contentan hour agoContributor SpotlightYash Raj BhartiMDN resonates with my passion to build a consistent and open web, where developers can learn and grow.Get involved →\n\n\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

Guides
HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

Guides
HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

Guides
HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nCSS: Cascading Style SheetsCascading Style Sheets (CSS) is a stylesheet language used to describe the presentation of a document written in HTML or XML (including XML dialects such as SVG, MathML or XHTML). CSS describes how elements should be rendered on screen, on paper, in speech, or on other media.
CSS is among the core languages of the open web and is standardized across Web browsers according to W3C specifications. Previously, the development of various parts of CSS specification was done synchronously, which allowed the versioning of the latest recommendations. You might have heard about CSS1, CSS2.1, or even CSS3. There will never be a CSS3 or a CSS4; rather, everything is now just "CSS" with individual CSS modules having version numbers.
After CSS 2.1, the scope of the specification increased significantly and the progress on different CSS modules started to differ so much, that it became more effective to develop and release recommendations separately per module. Instead of versioning the CSS specification, W3C now periodically takes a snapshot of the latest stable state of the CSS specification and individual modules progress. CSS modules now have version numbers, or levels, such as CSS Color Module Level 5.Beginner's tutorials
Your first website: Styling the content

This article provides a brief tour of what CSS is and how to use it, aimed at people who are completely new to web development.

CSS styling basics

Our Learn web development section's CSS basics module teaches CSS fundamentals from the ground up.

CSS text styling

Here we look at fundamentals including setting font, boldness, italics, line and letter spacing, drop shadows, and other text features. We round off the module by looking at applying custom fonts to your page, and styling lists and links.

CSS layout

Now it's time to look at how to correctly lay out your boxes in relation to one another, and the browser viewport. This module looks at floats, positioning, other modern layout tools, and building responsive designs that will adapt to different devices, screen sizes, and resolutions.

ReferenceThe CSS reference is an exhaustive reference for seasoned Web developers, describing every property and concept of CSS, including:

The syntax and forms of the language
Specificity, inheritance, and the cascade
CSS selectors, including pseudo-elements, nesting, scoping and shadow parts
CSS at-rules, including media and container queries
CSS values and units module, including numeric data types, textual data types and functional notations
Box model and margin collapse
The containing block
Stacking and block-formatting contexts
Initial, computed, used, and actual values
CSS shorthand properties
CSS flexible box, multi-column and grid layout
Animation, transitions, and transforms
CookbookThe CSS layout cookbook aims to bring together recipes for common layout patterns, things you might need to implement in your sites. In addition to providing code you can use as a starting point in your projects, these recipes highlight the different ways layout specifications can be used and the choices you can make as a developer.Tools for CSS development
You can use the W3C CSS Validation Service to check if your CSS is valid. This is an invaluable debugging tool.
Firefox Developer Tools lets you view and edit a page's live CSS via the Inspector and Style Editor tools.
The Web Developer extension for Firefox lets you track and edit live CSS on watched sites.
Meta bugs
Firefox: Firefox bug 1323667
See also
Web languages to which CSS is often applied: HTML, SVG, MathML, XHTML, and XML.
Stack Overflow questions about CSS\n\nCSS: Cascading Style SheetsCascading Style Sheets (CSS) is a stylesheet language used to describe the presentation of a document written in HTML or XML (including XML dialects such as SVG, MathML or XHTML). CSS describes how elements should be rendered on screen, on paper, in speech, or on other media.
CSS is among the core languages of the open web and is standardized across Web browsers according to W3C specifications. Previously, the development of various parts of CSS specification was done synchronously, which allowed the versioning of the latest recommendations. You might have heard about CSS1, CSS2.1, or even CSS3. There will never be a CSS3 or a CSS4; rather, everything is now just "CSS" with individual CSS modules having version numbers.
After CSS 2.1, the scope of the specification increased significantly and the progress on different CSS modules started to differ so much, that it became more effective to develop and release recommendations separately per module. Instead of versioning the CSS specification, W3C now periodically takes a snapshot of the latest stable state of the CSS specification and individual modules progress. CSS modules now have version numbers, or levels, such as CSS Color Module Level 5.Beginner's tutorials
Your first website: Styling the content

This article provides a brief tour of what CSS is and how to use it, aimed at people who are completely new to web development.

CSS styling basics

Our Learn web development section's CSS basics module teaches CSS fundamentals from the ground up.

CSS text styling

Here we look at fundamentals including setting font, boldness, italics, line and letter spacing, drop shadows, and other text features. We round off the module by looking at applying custom fonts to your page, and styling lists and links.

CSS layout

Now it's time to look at how to correctly lay out your boxes in relation to one another, and the browser viewport. This module looks at floats, positioning, other modern layout tools, and building responsive designs that will adapt to different devices, screen sizes, and resolutions.

ReferenceThe CSS reference is an exhaustive reference for seasoned Web developers, describing every property and concept of CSS, including:

The syntax and forms of the language
Specificity, inheritance, and the cascade
CSS selectors, including pseudo-elements, nesting, scoping and shadow parts
CSS at-rules, including media and container queries
CSS values and units module, including numeric data types, textual data types and functional notations
Box model and margin collapse
The containing block
Stacking and block-formatting contexts
Initial, computed, used, and actual values
CSS shorthand properties
CSS flexible box, multi-column and grid layout
Animation, transitions, and transforms
CookbookThe CSS layout cookbook aims to bring together recipes for common layout patterns, things you might need to implement in your sites. In addition to providing code you can use as a starting point in your projects, these recipes highlight the different ways layout specifications can be used and the choices you can make as a developer.Tools for CSS development
You can use the W3C CSS Validation Service to check if your CSS is valid. This is an invaluable debugging tool.
Firefox Developer Tools lets you view and edit a page's live CSS via the Inspector and Style Editor tools.
The Web Developer extension for Firefox lets you track and edit live CSS on watched sites.
Meta bugs
Firefox: Firefox bug 1323667
See also
Web languages to which CSS is often applied: HTML, SVG, MathML, XHTML, and XML.
Stack Overflow questions about CSS
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 22, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nCSS: Cascading Style SheetsCascading Style Sheets (CSS) is a stylesheet language used to describe the presentation of a document written in HTML or XML (including XML dialects such as SVG, MathML or XHTML). CSS describes how elements should be rendered on screen, on paper, in speech, or on other media.
CSS is among the core languages of the open web and is standardized across Web browsers according to W3C specifications. Previously, the development of various parts of CSS specification was done synchronously, which allowed the versioning of the latest recommendations. You might have heard about CSS1, CSS2.1, or even CSS3. There will never be a CSS3 or a CSS4; rather, everything is now just "CSS" with individual CSS modules having version numbers.
After CSS 2.1, the scope of the specification increased significantly and the progress on different CSS modules started to differ so much, that it became more effective to develop and release recommendations separately per module. Instead of versioning the CSS specification, W3C now periodically takes a snapshot of the latest stable state of the CSS specification and individual modules progress. CSS modules now have version numbers, or levels, such as CSS Color Module Level 5.Beginner's tutorials
Your first website: Styling the content

This article provides a brief tour of what CSS is and how to use it, aimed at people who are completely new to web development.

CSS styling basics

Our Learn web development section's CSS basics module teaches CSS fundamentals from the ground up.

CSS text styling

Here we look at fundamentals including setting font, boldness, italics, line and letter spacing, drop shadows, and other text features. We round off the module by looking at applying custom fonts to your page, and styling lists and links.

CSS layout

Now it's time to look at how to correctly lay out your boxes in relation to one another, and the browser viewport. This module looks at floats, positioning, other modern layout tools, and building responsive designs that will adapt to different devices, screen sizes, and resolutions.

ReferenceThe CSS reference is an exhaustive reference for seasoned Web developers, describing every property and concept of CSS, including:

The syntax and forms of the language
Specificity, inheritance, and the cascade
CSS selectors, including pseudo-elements, nesting, scoping and shadow parts
CSS at-rules, including media and container queries
CSS values and units module, including numeric data types, textual data types and functional notations
Box model and margin collapse
The containing block
Stacking and block-formatting contexts
Initial, computed, used, and actual values
CSS shorthand properties
CSS flexible box, multi-column and grid layout
Animation, transitions, and transforms
CookbookThe CSS layout cookbook aims to bring together recipes for common layout patterns, things you might need to implement in your sites. In addition to providing code you can use as a starting point in your projects, these recipes highlight the different ways layout specifications can be used and the choices you can make as a developer.Tools for CSS development
You can use the W3C CSS Validation Service to check if your CSS is valid. This is an invaluable debugging tool.
Firefox Developer Tools lets you view and edit a page's live CSS via the Inspector and Style Editor tools.
The Web Developer extension for Firefox lets you track and edit live CSS on watched sites.
Meta bugs
Firefox: Firefox bug 1323667
See also
Web languages to which CSS is often applied: HTML, SVG, MathML, XHTML, and XML.
Stack Overflow questions about CSS
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 22, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJavaScriptJavaScript (JS) is a lightweight interpreted (or just-in-time compiled) programming language with first-class functions. While it is most well-known as the scripting language for Web pages, many non-browser environments also use it, such as Node.js, Apache CouchDB and Adobe Acrobat. JavaScript is a prototype-based, multi-paradigm, single-threaded, dynamic language, supporting object-oriented, imperative, and declarative (e.g., functional programming) styles.
JavaScript's dynamic capabilities include runtime object construction, variable parameter lists, function variables, dynamic script creation (via eval), object introspection (via for...in and Object utilities), and source-code recovery (JavaScript functions store their source text and can be retrieved through toString()).
This section is dedicated to the JavaScript language itself, and not the parts that are specific to Web pages or other host environments. For information about APIs that are specific to Web pages, please see Web APIs and DOM.
The standards for JavaScript are the ECMAScript Language Specification (ECMA-262) and the ECMAScript Internationalization API specification (ECMA-402). As soon as one browser implements a feature, we try to document it. This means that cases where some proposals for new ECMAScript features have already been implemented in browsers, documentation and examples in MDN articles may use some of those new features. Most of the time, this happens between the stages 3 and 4, and is usually before the spec is officially published.
Do not confuse JavaScript with the Java programming language — JavaScript is not "Interpreted Java". Both "Java" and "JavaScript" are trademarks or registered trademarks of Oracle in the U.S. and other countries. However, the two programming languages have very different syntax, semantics, and use.
JavaScript documentation of core language features (pure ECMAScript, for the most part) includes the following:

The JavaScript guide
The JavaScript reference

For more information about JavaScript specifications and related technologies, see JavaScript technologies overview.Beginner's tutorialsLearn how to program in JavaScript from the ground up with our beginner's tutorials.

Your first website: Adding interactivity

This article provides a brief tour of what JavaScript is and how to use it, aimed at people who are completely new to web development.

Dynamic scripting with JavaScript

Our Learn web development section's JavaScript module teaches all the JavaScript fundamentals from the ground up.

JavaScript frameworks and libraries

JavaScript frameworks are an essential part of modern front-end web development, providing developers with tried and tested tools for building scalable, interactive web applications. Many modern companies use frameworks as a standard part of their tooling, so many front-end development jobs now require framework experience. In this set of articles, we aim to give you a comfortable starting point to help you begin learning frameworks.

JavaScript guidesFundamental language guides
JavaScript Guide

A much more detailed guide to the JavaScript language, aimed at those with previous programming experience either in JavaScript or another language.

Intermediate
Advanced JavaScript objects

The object-oriented nature of JavaScript is important to understand if you want to go further with your knowledge of the language and write more efficient code, therefore we've provided this module to help you.

Asynchronous JavaScript

In this module, we take a look at asynchronous JavaScript, why it is important, and how it can be used to effectively handle potential blocking operations, such as fetching resources from a server.

Client-side web APIs

Explores what APIs are, and how to use some of the most common APIs you'll come across often in your development work.

JavaScript language overview

An overview of the basic syntax and semantics of JavaScript for those coming from other programming languages to get up to speed.

JavaScript data structures

Overview of available data structures in JavaScript.

Equality comparisons and sameness

JavaScript provides three different value comparison operations: strict equality using ===, loose equality using ==, and the Object.is() method.

Enumerability and ownership of properties

How different methods that visit a group of object properties one-by-one handle the enumerability and ownership of properties.

Closures

A closure is the combination of a function and the lexical environment within which that function was declared.

Advanced
Inheritance and the prototype chain

Explanation of the widely misunderstood and underestimated prototype-based inheritance.

Memory Management

Memory life cycle and garbage collection in JavaScript.

ReferenceBrowse the complete JavaScript reference documentation.

Standard objects

Get to know standard built-in objects: Array, Boolean, Error, Function, JSON, Math, Number, Object, RegExp, String, Map, Set, WeakMap, WeakSet, and others.

Expressions and operators

Learn more about the behavior of JavaScript's operators instanceof, typeof, new, this, the operator precedence, and more.

Statements and declarations

Learn how do-while, for-in, for-of, try-catch, let, var, const, if-else, switch, and more JavaScript statements and keywords work.

Functions

Learn how to work with JavaScript's functions to develop your applications.

Classes

JavaScript classes are the most appropriate way to do object-oriented programming.\n\nJavaScriptJavaScript (JS) is a lightweight interpreted (or just-in-time compiled) programming language with first-class functions. While it is most well-known as the scripting language for Web pages, many non-browser environments also use it, such as Node.js, Apache CouchDB and Adobe Acrobat. JavaScript is a prototype-based, multi-paradigm, single-threaded, dynamic language, supporting object-oriented, imperative, and declarative (e.g., functional programming) styles.
JavaScript's dynamic capabilities include runtime object construction, variable parameter lists, function variables, dynamic script creation (via eval), object introspection (via for...in and Object utilities), and source-code recovery (JavaScript functions store their source text and can be retrieved through toString()).
This section is dedicated to the JavaScript language itself, and not the parts that are specific to Web pages or other host environments. For information about APIs that are specific to Web pages, please see Web APIs and DOM.
The standards for JavaScript are the ECMAScript Language Specification (ECMA-262) and the ECMAScript Internationalization API specification (ECMA-402). As soon as one browser implements a feature, we try to document it. This means that cases where some proposals for new ECMAScript features have already been implemented in browsers, documentation and examples in MDN articles may use some of those new features. Most of the time, this happens between the stages 3 and 4, and is usually before the spec is officially published.
Do not confuse JavaScript with the Java programming language — JavaScript is not "Interpreted Java". Both "Java" and "JavaScript" are trademarks or registered trademarks of Oracle in the U.S. and other countries. However, the two programming languages have very different syntax, semantics, and use.
JavaScript documentation of core language features (pure ECMAScript, for the most part) includes the following:

The JavaScript guide
The JavaScript reference

For more information about JavaScript specifications and related technologies, see JavaScript technologies overview.Beginner's tutorialsLearn how to program in JavaScript from the ground up with our beginner's tutorials.

Your first website: Adding interactivity

This article provides a brief tour of what JavaScript is and how to use it, aimed at people who are completely new to web development.

Dynamic scripting with JavaScript

Our Learn web development section's JavaScript module teaches all the JavaScript fundamentals from the ground up.

JavaScript frameworks and libraries

JavaScript frameworks are an essential part of modern front-end web development, providing developers with tried and tested tools for building scalable, interactive web applications. Many modern companies use frameworks as a standard part of their tooling, so many front-end development jobs now require framework experience. In this set of articles, we aim to give you a comfortable starting point to help you begin learning frameworks.

JavaScript guidesFundamental language guides
JavaScript Guide

A much more detailed guide to the JavaScript language, aimed at those with previous programming experience either in JavaScript or another language.

Intermediate
Advanced JavaScript objects

The object-oriented nature of JavaScript is important to understand if you want to go further with your knowledge of the language and write more efficient code, therefore we've provided this module to help you.

Asynchronous JavaScript

In this module, we take a look at asynchronous JavaScript, why it is important, and how it can be used to effectively handle potential blocking operations, such as fetching resources from a server.

Client-side web APIs

Explores what APIs are, and how to use some of the most common APIs you'll come across often in your development work.

JavaScript language overview

An overview of the basic syntax and semantics of JavaScript for those coming from other programming languages to get up to speed.

JavaScript data structures

Overview of available data structures in JavaScript.

Equality comparisons and sameness

JavaScript provides three different value comparison operations: strict equality using ===, loose equality using ==, and the Object.is() method.

Enumerability and ownership of properties

How different methods that visit a group of object properties one-by-one handle the enumerability and ownership of properties.

Closures

A closure is the combination of a function and the lexical environment within which that function was declared.

Advanced
Inheritance and the prototype chain

Explanation of the widely misunderstood and underestimated prototype-based inheritance.

Memory Management

Memory life cycle and garbage collection in JavaScript.

ReferenceBrowse the complete JavaScript reference documentation.

Standard objects

Get to know standard built-in objects: Array, Boolean, Error, Function, JSON, Math, Number, Object, RegExp, String, Map, Set, WeakMap, WeakSet, and others.

Expressions and operators

Learn more about the behavior of JavaScript's operators instanceof, typeof, new, this, the operator precedence, and more.

Statements and declarations

Learn how do-while, for-in, for-of, try-catch, let, var, const, if-else, switch, and more JavaScript statements and keywords work.

Functions

Learn how to work with JavaScript's functions to develop your applications.

Classes

JavaScript classes are the most appropriate way to do object-oriented programming.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJavaScriptJavaScript (JS) is a lightweight interpreted (or just-in-time compiled) programming language with first-class functions. While it is most well-known as the scripting language for Web pages, many non-browser environments also use it, such as Node.js, Apache CouchDB and Adobe Acrobat. JavaScript is a prototype-based, multi-paradigm, single-threaded, dynamic language, supporting object-oriented, imperative, and declarative (e.g., functional programming) styles.
JavaScript's dynamic capabilities include runtime object construction, variable parameter lists, function variables, dynamic script creation (via eval), object introspection (via for...in and Object utilities), and source-code recovery (JavaScript functions store their source text and can be retrieved through toString()).
This section is dedicated to the JavaScript language itself, and not the parts that are specific to Web pages or other host environments. For information about APIs that are specific to Web pages, please see Web APIs and DOM.
The standards for JavaScript are the ECMAScript Language Specification (ECMA-262) and the ECMAScript Internationalization API specification (ECMA-402). As soon as one browser implements a feature, we try to document it. This means that cases where some proposals for new ECMAScript features have already been implemented in browsers, documentation and examples in MDN articles may use some of those new features. Most of the time, this happens between the stages 3 and 4, and is usually before the spec is officially published.
Do not confuse JavaScript with the Java programming language — JavaScript is not "Interpreted Java". Both "Java" and "JavaScript" are trademarks or registered trademarks of Oracle in the U.S. and other countries. However, the two programming languages have very different syntax, semantics, and use.
JavaScript documentation of core language features (pure ECMAScript, for the most part) includes the following:

The JavaScript guide
The JavaScript reference

For more information about JavaScript specifications and related technologies, see JavaScript technologies overview.Beginner's tutorialsLearn how to program in JavaScript from the ground up with our beginner's tutorials.

Your first website: Adding interactivity

This article provides a brief tour of what JavaScript is and how to use it, aimed at people who are completely new to web development.

Dynamic scripting with JavaScript

Our Learn web development section's JavaScript module teaches all the JavaScript fundamentals from the ground up.

JavaScript frameworks and libraries

JavaScript frameworks are an essential part of modern front-end web development, providing developers with tried and tested tools for building scalable, interactive web applications. Many modern companies use frameworks as a standard part of their tooling, so many front-end development jobs now require framework experience. In this set of articles, we aim to give you a comfortable starting point to help you begin learning frameworks.

JavaScript guidesFundamental language guides
JavaScript Guide

A much more detailed guide to the JavaScript language, aimed at those with previous programming experience either in JavaScript or another language.

Intermediate
Advanced JavaScript objects

The object-oriented nature of JavaScript is important to understand if you want to go further with your knowledge of the language and write more efficient code, therefore we've provided this module to help you.

Asynchronous JavaScript

In this module, we take a look at asynchronous JavaScript, why it is important, and how it can be used to effectively handle potential blocking operations, such as fetching resources from a server.

Client-side web APIs

Explores what APIs are, and how to use some of the most common APIs you'll come across often in your development work.

JavaScript language overview

An overview of the basic syntax and semantics of JavaScript for those coming from other programming languages to get up to speed.

JavaScript data structures

Overview of available data structures in JavaScript.

Equality comparisons and sameness

JavaScript provides three different value comparison operations: strict equality using ===, loose equality using ==, and the Object.is() method.

Enumerability and ownership of properties

How different methods that visit a group of object properties one-by-one handle the enumerability and ownership of properties.

Closures

A closure is the combination of a function and the lexical environment within which that function was declared.

Advanced
Inheritance and the prototype chain

Explanation of the widely misunderstood and underestimated prototype-based inheritance.

Memory Management

Memory life cycle and garbage collection in JavaScript.

ReferenceBrowse the complete JavaScript reference documentation.

Standard objects

Get to know standard built-in objects: Array, Boolean, Error, Function, JSON, Math, Number, Object, RegExp, String, Map, Set, WeakMap, WeakSet, and others.

Expressions and operators

Learn more about the behavior of JavaScript's operators instanceof, typeof, new, this, the operator precedence, and more.

Statements and declarations

Learn how do-while, for-in, for-of, try-catch, let, var, const, if-else, switch, and more JavaScript statements and keywords work.

Functions

Learn how to work with JavaScript's functions to develop your applications.

Classes

JavaScript classes are the most appropriate way to do object-oriented programming.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nHTTPHypertext Transfer Protocol (HTTP) is an application-layer protocol for transmitting hypermedia documents, such as HTML.
It was designed for communication between web browsers and web servers, but it can also be used for other purposes, such as machine-to-machine communication, programmatic access to APIs, and more.
HTTP follows a classical client-server model, with a client opening a connection to make a request, then waiting until it receives a response from the server.
HTTP is a stateless protocol, meaning that the server does not keep any session data between two requests, although the later addition of cookies adds state to some client-server interactions.Reference documentationThe HTTP reference documentation contains detailed information about headers, request methods, status responses, and lists relevant specifications and standards documents.

HTTP headers

Message headers are used to send metadata about a resource or a HTTP message, and to describe the behavior of the client or the server.

HTTP request methods

Request methods indicate the purpose of the request and what is expected if the request is successful.
The most common methods are GET and POST for retrieving and sending data to servers, respectively, but there are other methods which serve different purposes.

HTTP response status codes

Response status codes indicate the outcome of a specific HTTP request.
Responses are grouped in five classes: informational, successful, redirections, client errors, and server errors.

HTTP resources and specifications

This page lists relevant resources about HTTP since it was first specified in the early 1990s.


The following subsections are also notable:

CSP directives

The Content-Security-Policy (CSP) response header allows website administrators to specify which resources the user agent is allowed to load for a given page.
This section lists directives that can be used in a CSP header, with individual documentation pages that describe how the directives work and how to use them.

Permissions-Policy directives

The Permissions-Policy response header provides a mechanism to allow or deny the use of browser features in a document or within any <iframe> element in the document.
This section lists directives that can be used in a Permissions-Policy header, with individual documentation pages that describe how the directives work and how to use them.

HTTP guidesHTTP is an extensible protocol that relies on concepts like resources and Uniform Resource Identifiers (URIs), a basic message structure, and client-server communication model.
On top of these concepts, numerous extensions have been developed over the years that add functionality and updated semantics, including additional HTTP methods and headers.
The guides below are listed in order from general overviews to specialized, use-case-driven topics.
Beginners are encouraged to start with the foundational guides before exploring more focused articles.

Overview of HTTP

The basic features of HTTP, what it can do, its intended use in web architecture, and its position in the protocol stack.

Evolution of HTTP

HTTP was created in the early 1990s and has been extended several times.
This article goes through its history and describes HTTP/0.9, HTTP/1.0, HTTP/1.1, through HTTP/2 and HTTP/3, as well as novelties introduced over the years.

A typical HTTP session

Describes the flow of an HTTP session, from establishing a connection, sending a request, to receiving a response.

HTTP messages

HTTP messages transmitted as requests and responses have a defined structure.
This article describes this general structure, its purpose, and the different types of messages.

MIME types

Since HTTP/1.0, different types of content can be transmitted.
This article explains how this is accomplished using the Content-Type header and the MIME standard.
A shortlist of common types used by web developers can be found in Common MIME types.

Compression in HTTP

Browsers and servers compress their messages before sending them over the network to reduce the amount of data that needs to be transmitted, improving transfer speed and bandwidth utilization.

HTTP caching

Caching is a highly important mechanism for delivering fast experiences on the Web and for efficient use of resources.
This article describes different methods of caching and how to use HTTP headers to control them.

HTTP authentication

Authentication is a way to verify the identity of a client when making requests to a server.
It ensures that only authorized users or systems can access certain resources.

Using HTTP cookies

Although HTTP is a stateless protocol, a server can send a Set-Cookie header with the response.
The client then returns the cookie's value with every subsequent request to the server in the form of a Cookie request header.
This adds the ability to store and exchange a small amount of data which effectively adds state to some client-server interactions.

Redirections in HTTP

URL redirection, also known as URL forwarding, is a technique to give more than one URL address to a page, a form, a whole website, or a web application.
HTTP has a special kind of response, called a HTTP redirect, for this operation.

HTTP conditional requests

In conditional requests, the outcome of a request depends on the value of a validator in the request.
This method is used heavily in caching and use cases such as resuming a download, preventing lost updates when modifying a document on the server, and more.

HTTP range requests

A range request asks the server to send a specific part (or parts) of a resource back to a client instead of the full resource.
Range requests are useful for cases when a client knows they need only part of a large file, or for cases where an application allows the user to pause and resume a download.

Content negotiation

HTTP defines a set of message headers, starting with Accept as a way for a browser to announce the format, language, or encoding it prefers.
This article explains how this advertisement happens, how the server is expected to react, and how it chooses the most adequate response to a request.

Connection management in HTTP/1.x

HTTP/1.1 was the first version of HTTP to support persistent connections and pipelining.
This article explains both concepts, including the pros and cons of each.

Protocol upgrade mechanism

HTTP/1.1 provides a mechanism to upgrade an already-established connection to a different protocol using the Upgrade header.
A client can upgrade a connection from HTTP/1.1 to HTTP/2, or an HTTP(S) connection to a WebSocket (ws / wss).

Proxy servers and tunneling

A proxy can be on the user's local computer, or anywhere between the user's computer and a destination server on the Internet.
This page outlines some basics about proxies and introduces a few configuration options.

HTTP Client hints

Client Hints are a set of response headers that a server can use to proactively request information from a client about the device, network, user, and user-agent-specific preferences.
The server can then determine which resources to send, based on the information that the client chooses to provide.

Network Error Logging 
Experimental


Network Error Logging is a mechanism that can be configured via the NEL HTTP response header.
This experimental header allows websites and applications to opt-in to receive reports about failed (or even successful) network fetches from supporting browsers.

Browser detection using the user agent

It's very rarely a good idea to use user agent sniffing to detect a browser, but there are edge cases that require it.
This document will guide you in doing this as correctly as possible when this is necessary, with an emphasis on considerations to make before embarking on this route.

Security and privacy
Permissions Policy

Permissions Policy provides mechanisms for web developers to explicitly declare what functionality can and cannot be used on a website.
You define a set of "policies" that restrict what APIs the site's code can access or modify the browser's default behavior for certain features.

Cross-Origin Resource Sharing (CORS)

Cross-site HTTP requests are requests for resources from a different domain than that of the resource making the request.
Web pages today very commonly load cross-site resources, for example, a page 'Domain A' (http://domaina.example/) requests an image on 'Domain B' (http://domainb.foo/image.jpg) via the img element.
CORS allows web developers to control how their site reacts to cross-site requests.

Content Security Policy (CSP)

CSP allows website administrators to use the Content-Security-Policy response header to control which resources the client is allowed to load for a given page.
The CSP guide describes the overall Content Security Policy mechanism which helps detect and mitigate certain types of attacks, including Cross-Site Scripting (XSS) and data injection attacks.

Cross-Origin Resource Policy (CORP)

CORP lets websites and applications opt in to protection against specific requests from other origins (such as those issued with elements like <script> and <img>), to mitigate speculative side-channel attacks.

Mozilla web security guidelines

A collection of tips to help operational teams with creating secure web applications.

Related resources
URIs

Uniform Resource Identifiers (URIs) are used to describe and locate resources on the web and are an essential component in HTTP requests.

Configuring servers for Ogg media

This guide covers a few server configuration changes that may be necessary for your web server to correctly serve Ogg media files.
This information may also be useful if you encounter other media types your server isn't already configured to recognize.

Tools & resourcesHelpful tools and resources for understanding and debugging HTTP.

Firefox Developer Tools

Network monitor

HTTP Observatory

A project designed to help developers, system administrators, and security professionals configure their sites safely and securely.

RedBot

Tools to check your cache-related headers.

nghttp2

An HTTP/2 client, server and proxy implementation written in C with load test and benchmarking tools and an HPACK encoder and decoder.

curl

A command-line tool for transferring data specified with URL syntax.
Supports HTTP, HTTPS, WS, WSS, among many other protocols.

How Browsers Work (2011)

A very comprehensive article on browser internals and request flow through HTTP protocol.\n\nHTTPHypertext Transfer Protocol (HTTP) is an application-layer protocol for transmitting hypermedia documents, such as HTML.
It was designed for communication between web browsers and web servers, but it can also be used for other purposes, such as machine-to-machine communication, programmatic access to APIs, and more.
HTTP follows a classical client-server model, with a client opening a connection to make a request, then waiting until it receives a response from the server.
HTTP is a stateless protocol, meaning that the server does not keep any session data between two requests, although the later addition of cookies adds state to some client-server interactions.Reference documentationThe HTTP reference documentation contains detailed information about headers, request methods, status responses, and lists relevant specifications and standards documents.

HTTP headers

Message headers are used to send metadata about a resource or a HTTP message, and to describe the behavior of the client or the server.

HTTP request methods

Request methods indicate the purpose of the request and what is expected if the request is successful.
The most common methods are GET and POST for retrieving and sending data to servers, respectively, but there are other methods which serve different purposes.

HTTP response status codes

Response status codes indicate the outcome of a specific HTTP request.
Responses are grouped in five classes: informational, successful, redirections, client errors, and server errors.

HTTP resources and specifications

This page lists relevant resources about HTTP since it was first specified in the early 1990s.


The following subsections are also notable:

CSP directives

The Content-Security-Policy (CSP) response header allows website administrators to specify which resources the user agent is allowed to load for a given page.
This section lists directives that can be used in a CSP header, with individual documentation pages that describe how the directives work and how to use them.

Permissions-Policy directives

The Permissions-Policy response header provides a mechanism to allow or deny the use of browser features in a document or within any <iframe> element in the document.
This section lists directives that can be used in a Permissions-Policy header, with individual documentation pages that describe how the directives work and how to use them.

HTTP guidesHTTP is an extensible protocol that relies on concepts like resources and Uniform Resource Identifiers (URIs), a basic message structure, and client-server communication model.
On top of these concepts, numerous extensions have been developed over the years that add functionality and updated semantics, including additional HTTP methods and headers.
The guides below are listed in order from general overviews to specialized, use-case-driven topics.
Beginners are encouraged to start with the foundational guides before exploring more focused articles.

Overview of HTTP

The basic features of HTTP, what it can do, its intended use in web architecture, and its position in the protocol stack.

Evolution of HTTP

HTTP was created in the early 1990s and has been extended several times.
This article goes through its history and describes HTTP/0.9, HTTP/1.0, HTTP/1.1, through HTTP/2 and HTTP/3, as well as novelties introduced over the years.

A typical HTTP session

Describes the flow of an HTTP session, from establishing a connection, sending a request, to receiving a response.

HTTP messages

HTTP messages transmitted as requests and responses have a defined structure.
This article describes this general structure, its purpose, and the different types of messages.

MIME types

Since HTTP/1.0, different types of content can be transmitted.
This article explains how this is accomplished using the Content-Type header and the MIME standard.
A shortlist of common types used by web developers can be found in Common MIME types.

Compression in HTTP

Browsers and servers compress their messages before sending them over the network to reduce the amount of data that needs to be transmitted, improving transfer speed and bandwidth utilization.

HTTP caching

Caching is a highly important mechanism for delivering fast experiences on the Web and for efficient use of resources.
This article describes different methods of caching and how to use HTTP headers to control them.

HTTP authentication

Authentication is a way to verify the identity of a client when making requests to a server.
It ensures that only authorized users or systems can access certain resources.

Using HTTP cookies

Although HTTP is a stateless protocol, a server can send a Set-Cookie header with the response.
The client then returns the cookie's value with every subsequent request to the server in the form of a Cookie request header.
This adds the ability to store and exchange a small amount of data which effectively adds state to some client-server interactions.

Redirections in HTTP

URL redirection, also known as URL forwarding, is a technique to give more than one URL address to a page, a form, a whole website, or a web application.
HTTP has a special kind of response, called a HTTP redirect, for this operation.

HTTP conditional requests

In conditional requests, the outcome of a request depends on the value of a validator in the request.
This method is used heavily in caching and use cases such as resuming a download, preventing lost updates when modifying a document on the server, and more.

HTTP range requests

A range request asks the server to send a specific part (or parts) of a resource back to a client instead of the full resource.
Range requests are useful for cases when a client knows they need only part of a large file, or for cases where an application allows the user to pause and resume a download.

Content negotiation

HTTP defines a set of message headers, starting with Accept as a way for a browser to announce the format, language, or encoding it prefers.
This article explains how this advertisement happens, how the server is expected to react, and how it chooses the most adequate response to a request.

Connection management in HTTP/1.x

HTTP/1.1 was the first version of HTTP to support persistent connections and pipelining.
This article explains both concepts, including the pros and cons of each.

Protocol upgrade mechanism

HTTP/1.1 provides a mechanism to upgrade an already-established connection to a different protocol using the Upgrade header.
A client can upgrade a connection from HTTP/1.1 to HTTP/2, or an HTTP(S) connection to a WebSocket (ws / wss).

Proxy servers and tunneling

A proxy can be on the user's local computer, or anywhere between the user's computer and a destination server on the Internet.
This page outlines some basics about proxies and introduces a few configuration options.

HTTP Client hints

Client Hints are a set of response headers that a server can use to proactively request information from a client about the device, network, user, and user-agent-specific preferences.
The server can then determine which resources to send, based on the information that the client chooses to provide.

Network Error Logging 
Experimental


Network Error Logging is a mechanism that can be configured via the NEL HTTP response header.
This experimental header allows websites and applications to opt-in to receive reports about failed (or even successful) network fetches from supporting browsers.

Browser detection using the user agent

It's very rarely a good idea to use user agent sniffing to detect a browser, but there are edge cases that require it.
This document will guide you in doing this as correctly as possible when this is necessary, with an emphasis on considerations to make before embarking on this route.

Security and privacy
Permissions Policy

Permissions Policy provides mechanisms for web developers to explicitly declare what functionality can and cannot be used on a website.
You define a set of "policies" that restrict what APIs the site's code can access or modify the browser's default behavior for certain features.

Cross-Origin Resource Sharing (CORS)

Cross-site HTTP requests are requests for resources from a different domain than that of the resource making the request.
Web pages today very commonly load cross-site resources, for example, a page 'Domain A' (http://domaina.example/) requests an image on 'Domain B' (http://domainb.foo/image.jpg) via the img element.
CORS allows web developers to control how their site reacts to cross-site requests.

Content Security Policy (CSP)

CSP allows website administrators to use the Content-Security-Policy response header to control which resources the client is allowed to load for a given page.
The CSP guide describes the overall Content Security Policy mechanism which helps detect and mitigate certain types of attacks, including Cross-Site Scripting (XSS) and data injection attacks.

Cross-Origin Resource Policy (CORP)

CORP lets websites and applications opt in to protection against specific requests from other origins (such as those issued with elements like <script> and <img>), to mitigate speculative side-channel attacks.

Mozilla web security guidelines

A collection of tips to help operational teams with creating secure web applications.

Related resources
URIs

Uniform Resource Identifiers (URIs) are used to describe and locate resources on the web and are an essential component in HTTP requests.

Configuring servers for Ogg media

This guide covers a few server configuration changes that may be necessary for your web server to correctly serve Ogg media files.
This information may also be useful if you encounter other media types your server isn't already configured to recognize.

Tools & resourcesHelpful tools and resources for understanding and debugging HTTP.

Firefox Developer Tools

Network monitor

HTTP Observatory

A project designed to help developers, system administrators, and security professionals configure their sites safely and securely.

RedBot

Tools to check your cache-related headers.

nghttp2

An HTTP/2 client, server and proxy implementation written in C with load test and benchmarking tools and an HPACK encoder and decoder.

curl

A command-line tool for transferring data specified with URL syntax.
Supports HTTP, HTTPS, WS, WSS, among many other protocols.

How Browsers Work (2011)

A very comprehensive article on browser internals and request flow through HTTP protocol.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 14, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nHTTPHypertext Transfer Protocol (HTTP) is an application-layer protocol for transmitting hypermedia documents, such as HTML.
It was designed for communication between web browsers and web servers, but it can also be used for other purposes, such as machine-to-machine communication, programmatic access to APIs, and more.
HTTP follows a classical client-server model, with a client opening a connection to make a request, then waiting until it receives a response from the server.
HTTP is a stateless protocol, meaning that the server does not keep any session data between two requests, although the later addition of cookies adds state to some client-server interactions.Reference documentationThe HTTP reference documentation contains detailed information about headers, request methods, status responses, and lists relevant specifications and standards documents.

HTTP headers

Message headers are used to send metadata about a resource or a HTTP message, and to describe the behavior of the client or the server.

HTTP request methods

Request methods indicate the purpose of the request and what is expected if the request is successful.
The most common methods are GET and POST for retrieving and sending data to servers, respectively, but there are other methods which serve different purposes.

HTTP response status codes

Response status codes indicate the outcome of a specific HTTP request.
Responses are grouped in five classes: informational, successful, redirections, client errors, and server errors.

HTTP resources and specifications

This page lists relevant resources about HTTP since it was first specified in the early 1990s.


The following subsections are also notable:

CSP directives

The Content-Security-Policy (CSP) response header allows website administrators to specify which resources the user agent is allowed to load for a given page.
This section lists directives that can be used in a CSP header, with individual documentation pages that describe how the directives work and how to use them.

Permissions-Policy directives

The Permissions-Policy response header provides a mechanism to allow or deny the use of browser features in a document or within any <iframe> element in the document.
This section lists directives that can be used in a Permissions-Policy header, with individual documentation pages that describe how the directives work and how to use them.

HTTP guidesHTTP is an extensible protocol that relies on concepts like resources and Uniform Resource Identifiers (URIs), a basic message structure, and client-server communication model.
On top of these concepts, numerous extensions have been developed over the years that add functionality and updated semantics, including additional HTTP methods and headers.
The guides below are listed in order from general overviews to specialized, use-case-driven topics.
Beginners are encouraged to start with the foundational guides before exploring more focused articles.

Overview of HTTP

The basic features of HTTP, what it can do, its intended use in web architecture, and its position in the protocol stack.

Evolution of HTTP

HTTP was created in the early 1990s and has been extended several times.
This article goes through its history and describes HTTP/0.9, HTTP/1.0, HTTP/1.1, through HTTP/2 and HTTP/3, as well as novelties introduced over the years.

A typical HTTP session

Describes the flow of an HTTP session, from establishing a connection, sending a request, to receiving a response.

HTTP messages

HTTP messages transmitted as requests and responses have a defined structure.
This article describes this general structure, its purpose, and the different types of messages.

MIME types

Since HTTP/1.0, different types of content can be transmitted.
This article explains how this is accomplished using the Content-Type header and the MIME standard.
A shortlist of common types used by web developers can be found in Common MIME types.

Compression in HTTP

Browsers and servers compress their messages before sending them over the network to reduce the amount of data that needs to be transmitted, improving transfer speed and bandwidth utilization.

HTTP caching

Caching is a highly important mechanism for delivering fast experiences on the Web and for efficient use of resources.
This article describes different methods of caching and how to use HTTP headers to control them.

HTTP authentication

Authentication is a way to verify the identity of a client when making requests to a server.
It ensures that only authorized users or systems can access certain resources.

Using HTTP cookies

Although HTTP is a stateless protocol, a server can send a Set-Cookie header with the response.
The client then returns the cookie's value with every subsequent request to the server in the form of a Cookie request header.
This adds the ability to store and exchange a small amount of data which effectively adds state to some client-server interactions.

Redirections in HTTP

URL redirection, also known as URL forwarding, is a technique to give more than one URL address to a page, a form, a whole website, or a web application.
HTTP has a special kind of response, called a HTTP redirect, for this operation.

HTTP conditional requests

In conditional requests, the outcome of a request depends on the value of a validator in the request.
This method is used heavily in caching and use cases such as resuming a download, preventing lost updates when modifying a document on the server, and more.

HTTP range requests

A range request asks the server to send a specific part (or parts) of a resource back to a client instead of the full resource.
Range requests are useful for cases when a client knows they need only part of a large file, or for cases where an application allows the user to pause and resume a download.

Content negotiation

HTTP defines a set of message headers, starting with Accept as a way for a browser to announce the format, language, or encoding it prefers.
This article explains how this advertisement happens, how the server is expected to react, and how it chooses the most adequate response to a request.

Connection management in HTTP/1.x

HTTP/1.1 was the first version of HTTP to support persistent connections and pipelining.
This article explains both concepts, including the pros and cons of each.

Protocol upgrade mechanism

HTTP/1.1 provides a mechanism to upgrade an already-established connection to a different protocol using the Upgrade header.
A client can upgrade a connection from HTTP/1.1 to HTTP/2, or an HTTP(S) connection to a WebSocket (ws / wss).

Proxy servers and tunneling

A proxy can be on the user's local computer, or anywhere between the user's computer and a destination server on the Internet.
This page outlines some basics about proxies and introduces a few configuration options.

HTTP Client hints

Client Hints are a set of response headers that a server can use to proactively request information from a client about the device, network, user, and user-agent-specific preferences.
The server can then determine which resources to send, based on the information that the client chooses to provide.

Network Error Logging 
Experimental


Network Error Logging is a mechanism that can be configured via the NEL HTTP response header.
This experimental header allows websites and applications to opt-in to receive reports about failed (or even successful) network fetches from supporting browsers.

Browser detection using the user agent

It's very rarely a good idea to use user agent sniffing to detect a browser, but there are edge cases that require it.
This document will guide you in doing this as correctly as possible when this is necessary, with an emphasis on considerations to make before embarking on this route.

Security and privacy
Permissions Policy

Permissions Policy provides mechanisms for web developers to explicitly declare what functionality can and cannot be used on a website.
You define a set of "policies" that restrict what APIs the site's code can access or modify the browser's default behavior for certain features.

Cross-Origin Resource Sharing (CORS)

Cross-site HTTP requests are requests for resources from a different domain than that of the resource making the request.
Web pages today very commonly load cross-site resources, for example, a page 'Domain A' (http://domaina.example/) requests an image on 'Domain B' (http://domainb.foo/image.jpg) via the img element.
CORS allows web developers to control how their site reacts to cross-site requests.

Content Security Policy (CSP)

CSP allows website administrators to use the Content-Security-Policy response header to control which resources the client is allowed to load for a given page.
The CSP guide describes the overall Content Security Policy mechanism which helps detect and mitigate certain types of attacks, including Cross-Site Scripting (XSS) and data injection attacks.

Cross-Origin Resource Policy (CORP)

CORP lets websites and applications opt in to protection against specific requests from other origins (such as those issued with elements like <script> and <img>), to mitigate speculative side-channel attacks.

Mozilla web security guidelines

A collection of tips to help operational teams with creating secure web applications.

Related resources
URIs

Uniform Resource Identifiers (URIs) are used to describe and locate resources on the web and are an essential component in HTTP requests.

Configuring servers for Ogg media

This guide covers a few server configuration changes that may be necessary for your web server to correctly serve Ogg media files.
This information may also be useful if you encounter other media types your server isn't already configured to recognize.

Tools & resourcesHelpful tools and resources for understanding and debugging HTTP.

Firefox Developer Tools

Network monitor

HTTP Observatory

A project designed to help developers, system administrators, and security professionals configure their sites safely and securely.

RedBot

Tools to check your cache-related headers.

nghttp2

An HTTP/2 client, server and proxy implementation written in C with load test and benchmarking tools and an HPACK encoder and decoder.

curl

A command-line tool for transferring data specified with URL syntax.
Supports HTTP, HTTPS, WS, WSS, among many other protocols.

How Browsers Work (2011)

A very comprehensive article on browser internals and request flow through HTTP protocol.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 14, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nWeb APIsWhen writing code for the Web, there are a large number of Web APIs available. Below is a list of all the APIs and interfaces (object types) that you may be able to use while developing your Web app or site.
Web APIs are typically used with JavaScript, although this doesn't always have to be the case.SpecificationsThis is a list of all the APIs that are available.
AAttribution Reporting API
Experimental
Audio Output Devices API
Experimental
BBackground Fetch API
Experimental
Background Synchronization APIBackground Tasks APIBadging APIBarcode Detection API
Experimental
Battery Status APIBeacon APIWeb Bluetooth API
Experimental
Broadcast Channel APICCSS Custom Highlight APICSS Font Loading APICSS Painting API
Experimental
CSS Properties and Values APICSS Typed Object Model APICSS Object Model (CSSOM)Canvas APIChannel Messaging APIClipboard APICompression Streams APICompute Pressure API
Experimental
Console APIContact Picker API
Experimental
Content Index API
Experimental
Cookie Store APICredential Management APIDDocument Object Model (DOM)Device Memory APIDevice orientation eventsDevice Posture API
Experimental
Document Picture-in-Picture API
Experimental
EEditContext API
Experimental
Encoding APIEncrypted Media Extensions APIEyeDropper API
Experimental
FFederated Credential Management (FedCM) API
Experimental
Fenced Frame API
Experimental
Fetch APIFile APIFile System APIFile and Directory Entries APIForce Touch events
Non-standard
Fullscreen APIGGamepad APIGeolocation APIGeometry interfacesHThe HTML DOM APIHTML Drag and Drop APIHistory APIHoudini APIsIIdle Detection API
Experimental
MediaStream Image Capture APIIndexedDB APIInk API
Experimental
InputDeviceCapabilities API
Experimental
Insertable Streams for MediaStreamTrack APIIntersection Observer APIInvoker Commands APIJJS Self-Profiling API
Experimental
KKeyboard API
Experimental
LLaunch Handler API
Experimental
Local Font Access API
Experimental
MMedia Capabilities APIMedia Capture and Streams API (Media Stream)Media Session APIMedia Source API
Experimental
MediaStream Recording APINNavigation API
Experimental
Network Information APIPPage Visibility APIPayment Handler API
Experimental
Payment Request APIPerformance APIsWeb Periodic Background Synchronization API
Experimental
Permissions APIPicture-in-Picture APIPointer eventsPointer Lock APIPopover APIPresentation API
Experimental
Prioritized Task Scheduling APIPush APIRRemote Playback APIReporting APIResize Observer APISSVG APIScreen Capture APIScreen Orientation APIScreen Wake Lock APISelection APISensor APIsServer-sent eventsService Worker APIShared Storage API
Experimental
Speculation Rules API
Experimental
Storage APIStorage Access APIStreams APITTopics API
Experimental

Non-standard
Touch eventsTrusted Types APIUUI EventsURL APIURL Fragment Text DirectivesURL Pattern API
Experimental
User-Agent Client Hints API
Experimental
VVibration APIView Transition APIVirtualKeyboard API
Experimental
Visual Viewport APIWWeb Animations APIWeb Audio APIWeb Authentication APIWeb ComponentsWeb Crypto APIWeb Locks APIWeb MIDI APIWeb NFC API
Experimental
Notifications APIWeb Serial API
Experimental
Web Share APIWeb Speech APIWeb Storage APIWeb Workers APIWebCodecs APIWebGL: 2D and 3D graphics for the webWebGPU API
Experimental
WebHID API
Experimental
WebOTP APIWebRTC APIThe WebSocket API (WebSockets)WebTransport APIWebUSB API
Experimental
WebVR API
Non-standard

Deprecated
WebVTT APIWebXR Device API
Experimental
Window Controls Overlay API
Experimental
Window Management API
Experimental
XXMLHttpRequest APIffetchLater() API
Experimental
InterfacesThis is a list of all the interfaces (that is, types of objects) that are available.
AAbortControllerAbortSignalAbsoluteOrientationSensorAbstractRangeAccelerometer
Experimental
AesCbcParamsAesCtrParamsAesGcmParamsAesKeyGenParamsAmbientLightSensor
Experimental
AnalyserNodeANGLE_instanced_arraysAnimationAnimationEffectAnimationEventAnimationPlaybackEventAnimationTimelineAttrAudioBufferAudioBufferSourceNodeAudioContextAudioDataAudioDecoderAudioDestinationNodeAudioEncoderAudioListenerAudioNodeAudioParamAudioParamDescriptorAudioParamMapAudioProcessingEvent
Deprecated
AudioScheduledSourceNodeAudioSinkInfo
Experimental
AudioTrackAudioTrackListAudioWorkletAudioWorkletGlobalScopeAudioWorkletNodeAudioWorkletProcessorAuthenticatorAssertionResponseAuthenticatorAttestationResponseAuthenticatorResponseBBackgroundFetchEvent
Experimental
BackgroundFetchManager
Experimental
BackgroundFetchRecord
Experimental
BackgroundFetchRegistration
Experimental
BackgroundFetchUpdateUIEvent
Experimental
BarcodeDetector
Experimental
BarPropBaseAudioContextBatteryManagerBeforeInstallPromptEvent
Experimental

Non-standard
BeforeUnloadEventBiquadFilterNodeBlobBlobEventBluetooth
Experimental
BluetoothCharacteristicProperties
Experimental
BluetoothDevice
Experimental
BluetoothRemoteGATTCharacteristic
Experimental
BluetoothRemoteGATTDescriptor
Experimental
BluetoothRemoteGATTServer
Experimental
BluetoothRemoteGATTService
Experimental
BluetoothUUIDBroadcastChannelBrowserCaptureMediaStreamTrack
Experimental
ByteLengthQueuingStrategyCCacheCacheStorageCanMakePaymentEvent
Experimental
CanvasCaptureMediaStreamTrackCanvasGradientCanvasPatternCanvasRenderingContext2DCaptureController
Experimental
CaretPositionCDATASectionChannelMergerNodeChannelSplitterNodeChapterInformation
Experimental
CharacterBoundsUpdateEvent
Experimental
CharacterDataClientClientsClipboardClipboardEventClipboardItemCloseEventCloseWatcher
Experimental
CommandEventCommentCompositionEventCompressionStreamcconsoleCConstantSourceNodeContactAddress
Experimental
ContactsManager
Experimental
ContentIndex
Experimental
ContentIndexEvent
Experimental
ContentVisibilityAutoStateChangeEventConvolverNodeCookieChangeEventCookieStoreCookieStoreManagerCountQueuingStrategyCredentialCredentialsContainerCropTarget
Experimental
CryptoCryptoKeyCryptoKeyPairCSPViolationReportBodyCSSCSSAnimationCSSConditionRuleCSSContainerRuleCSSCounterStyleRuleCSSFontFaceRuleCSSFontFeatureValuesRuleCSSFontPaletteValuesRuleCSSGroupingRuleCSSImageValueCSSImportRuleCSSKeyframeRuleCSSKeyframesRuleCSSKeywordValueCSSLayerBlockRuleCSSLayerStatementRuleCSSMathInvertCSSMathMaxCSSMathMinCSSMathNegateCSSMathProductCSSMathSumCSSMathValueCSSMatrixComponentCSSMediaRuleCSSNamespaceRuleCSSNestedDeclarationsCSSNumericArrayCSSNumericValueCSSPageDescriptors
Experimental
CSSPageRuleCSSPerspectiveCSSPositionTryDescriptors
Experimental
CSSPositionTryRule
Experimental
CSSPositionValue
Non-standard

Deprecated
CSSPrimitiveValue
Deprecated
CSSPropertyRuleCSSPseudoElement
Experimental
CSSRotateCSSRuleCSSRuleListCSSScaleCSSScopeRuleCSSSkewCSSSkewXCSSSkewYCSSStartingStyleRuleCSSStyleDeclarationCSSStyleRuleCSSStyleSheetCSSStyleValueCSSSupportsRuleCSSTransformComponentCSSTransformValueCSSTransitionCSSTranslateCSSUnitValueCSSUnparsedValueCSSValue
Deprecated
CSSValueList
Deprecated
CSSVariableReferenceValueCustomElementRegistryCustomEventCustomStateSetDDataTransferDataTransferItemDataTransferItemListDecompressionStreamDedicatedWorkerGlobalScopeDeferredRequestInit
Experimental
DelayNodeDelegatedInkTrailPresenter
Experimental
DeprecationReportBody
Experimental
DeviceMotionEventDeviceMotionEventAccelerationDeviceMotionEventRotationRateDeviceOrientationEventDevicePosture
Experimental
DirectoryEntrySync
Non-standard

Deprecated
DirectoryReaderSync
Non-standard

Deprecated
DocumentDocumentFragmentDocumentPictureInPicture
Experimental
DocumentPictureInPictureEvent
Experimental
DocumentTimelineDocumentTypeDOMError
Deprecated
DOMExceptionDOMHighResTimeStampDOMImplementationDOMMatrixDOMMatrixReadOnlyDOMParserDOMPointDOMPointReadOnlyDOMQuadDOMRectDOMRectListDOMRectReadOnlyDOMStringListDOMStringMapDOMTokenListDragEventDynamicsCompressorNodeEEcdhKeyDeriveParamsEcdsaParamsEcKeyGenParamsEcKeyImportParamsEditContext
Experimental
ElementElementInternalsEncodedAudioChunkEncodedVideoChunkErrorEventEventEventCountsEventSourceEventTargetExtendableCookieChangeEventExtendableEventExtendableMessageEventEyeDropper
Experimental
FFeaturePolicy
Experimental
FederatedCredential
Experimental
FederatedCredentialInitFence
Experimental
FencedFrameConfig
Experimental
FetchEventFetchLaterResult
Experimental
FileFileEntrySync
Non-standard

Deprecated
FileListFileReaderFileReaderSyncFileSystemFileSystemChangeRecordFileSystemDirectoryEntryFileSystemDirectoryHandleFileSystemDirectoryReaderFileSystemEntryFileSystemFileEntryFileSystemFileHandleFileSystemHandleFileSystemObserver
Experimental

Non-standard
FileSystemSync
Non-standard

Deprecated
FileSystemSyncAccessHandleFileSystemWritableFileStreamFocusEventFontData
Experimental
FontFaceFontFaceSetFontFaceSetLoadEventFormDataFormDataEventFragmentDirectiveGGainNodeGamepadGamepadButtonGamepadEventGamepadHapticActuatorGamepadPose
Experimental
GeolocationGeolocationCoordinatesGeolocationPositionGeolocationPositionErrorGestureEvent
Non-standard
GPU
Experimental
GPUAdapter
Experimental
GPUAdapterInfo
Experimental
GPUBindGroup
Experimental
GPUBindGroupLayout
Experimental
GPUBuffer
Experimental
GPUCanvasContext
Experimental
GPUCommandBuffer
Experimental
GPUCommandEncoder
Experimental
GPUCompilationInfo
Experimental
GPUCompilationMessage
Experimental
GPUComputePassEncoder
Experimental
GPUComputePipeline
Experimental
GPUDevice
Experimental
GPUDeviceLostInfo
Experimental
GPUError
Experimental
GPUExternalTexture
Experimental
GPUInternalError
Experimental
GPUOutOfMemoryError
Experimental
GPUPipelineError
Experimental
GPUPipelineLayout
Experimental
GPUQuerySet
Experimental
GPUQueue
Experimental
GPURenderBundle
Experimental
GPURenderBundleEncoder
Experimental
GPURenderPassEncoder
Experimental
GPURenderPipeline
Experimental
GPUSampler
Experimental
GPUShaderModule
Experimental
GPUSupportedFeatures
Experimental
GPUSupportedLimits
Experimental
GPUTexture
Experimental
GPUTextureView
Experimental
GPUUncapturedErrorEvent
Experimental
GPUValidationError
Experimental
GravitySensorGyroscopeHHashChangeEventHeadersHID
Experimental
HIDConnectionEvent
Experimental
HIDDevice
Experimental
HIDInputReportEvent
Experimental
HighlightHighlightRegistryHistoryHkdfParamsHmacImportParamsHmacKeyGenParamsHMDVRDevice
Non-standard

Deprecated
HTMLAllCollectionHTMLAnchorElementHTMLAreaElementHTMLAudioElementHTMLBaseElementHTMLBodyElementHTMLBRElementHTMLButtonElementHTMLCanvasElementHTMLCollectionHTMLDataElementHTMLDataListElementHTMLDetailsElementHTMLDialogElementHTMLDivElementHTMLDListElementHTMLDocumentHTMLElementHTMLEmbedElementHTMLFencedFrameElement
Experimental
HTMLFieldSetElementHTMLFontElement
Deprecated
HTMLFormControlsCollectionHTMLFormElementHTMLFrameSetElement
Deprecated
HTMLHeadElementHTMLHeadingElementHTMLHRElementHTMLHtmlElementHTMLIFrameElementHTMLImageElementHTMLInputElementHTMLLabelElementHTMLLegendElementHTMLLIElementHTMLLinkElementHTMLMapElementHTMLMarqueeElement
Deprecated
HTMLMediaElementHTMLMenuElementHTMLMetaElementHTMLMeterElementHTMLModElementHTMLObjectElementHTMLOListElementHTMLOptGroupElementHTMLOptionElementHTMLOptionsCollectionHTMLOutputElementHTMLParagraphElementHTMLParamElement
Deprecated
HTMLPictureElementHTMLPreElementHTMLProgressElementHTMLQuoteElementHTMLScriptElementHTMLSelectedContentElementHTMLSelectElementHTMLSlotElementHTMLSourceElementHTMLSpanElementHTMLStyleElementHTMLTableCaptionElementHTMLTableCellElementHTMLTableColElementHTMLTableElementHTMLTableRowElementHTMLTableSectionElementHTMLTemplateElementHTMLTextAreaElementHTMLTimeElementHTMLTitleElementHTMLTrackElementHTMLUListElementHTMLUnknownElementHTMLVideoElementIIDBCursorIDBCursorWithValueIDBDatabaseIDBFactoryIDBIndexIDBKeyRangeIDBObjectStoreIDBOpenDBRequestIDBRequestIDBTransactionIDBVersionChangeEventIdentityCredential
Experimental
IdentityCredentialRequestOptionsIdentityProvider
Experimental
IdleDeadlineIdleDetector
Experimental
IIRFilterNodeImageBitmapImageBitmapRenderingContextImageCaptureImageDataImageDecoderImageTrackImageTrackListInk
Experimental
InputDeviceCapabilities
Experimental
InputDeviceInfoInputEventInstallEventIntersectionObserverIntersectionObserverEntryInterventionReportBody
Experimental
KKeyboard
Experimental
KeyboardEventKeyboardLayoutMap
Experimental
KeyframeEffectLLargestContentfulPaintLaunchParams
Experimental
LaunchQueue
Experimental
LayoutShift
Experimental
LayoutShiftAttribution
Experimental
LinearAccelerationSensorLocationLockLockManagerMMagnetometer
Experimental
MathMLElementMediaCapabilitiesMediaDeviceInfoMediaDevicesMediaElementAudioSourceNodeMediaEncryptedEventMediaErrorMediaKeyMessageEventMediaKeysMediaKeySessionMediaKeyStatusMapMediaKeySystemAccessMediaListMediaMetadataMediaQueryListMediaQueryListEventMediaRecorderMediaRecorderErrorEvent
Non-standard

Deprecated
MediaSessionMediaSourceMediaSourceHandleMediaStreamMediaStreamAudioDestinationNodeMediaStreamAudioSourceNodeMediaStreamEvent
Non-standard

Deprecated
MediaStreamTrackMediaStreamTrackAudioSourceNodeMediaStreamTrackEventMediaStreamTrackGenerator
Experimental

Non-standard
MediaStreamTrackProcessorMediaTrackConstraintsMediaTrackSettingsMediaTrackSupportedConstraintsMerchantValidationEvent
Deprecated
MessageChannelMessageEventMessagePortMetadata
Experimental

Non-standard
MIDIAccessMIDIConnectionEventMIDIInputMIDIInputMapMIDIMessageEventMIDIOutputMIDIOutputMapMIDIPortMimeType
Deprecated
MimeTypeArray
Deprecated
MouseEventMouseScrollEvent
Non-standard

Deprecated
MutationEvent
Non-standard

Deprecated
MutationObserverMutationRecordNNamedNodeMapNavigateEvent
Experimental
Navigation
Experimental
NavigationActivation
Experimental
NavigationCurrentEntryChangeEvent
Experimental
NavigationDestination
Experimental
NavigationHistoryEntry
Experimental
NavigationPreloadManagerNavigationTransition
Experimental
NavigatorNavigatorLoginNavigatorUAData
Experimental
NDEFMessage
Experimental
NDEFReader
Experimental
NDEFReadingEvent
Experimental
NDEFRecord
Experimental
NetworkInformationNodeNodeIteratorNodeListNotificationNotificationEventNotRestoredReasonDetails
Experimental
NotRestoredReasons
Experimental
OOES_draw_buffers_indexedOfflineAudioCompletionEventOfflineAudioContextOffscreenCanvasOffscreenCanvasRenderingContext2DOrientationSensorOscillatorNodeOTPCredential
Experimental
OverconstrainedErrorPPageRevealEventPageSwapEventPageTransitionEventPaintRenderingContext2DPaintSizePaintWorkletGlobalScope
Experimental
PannerNodePasswordCredential
Experimental
PasswordCredentialInitPath2DPaymentAddress
Non-standard

Deprecated
PaymentManager
Experimental
PaymentMethodChangeEventPaymentRequestPaymentRequestEvent
Experimental
PaymentRequestUpdateEventPaymentResponsePbkdf2ParamsPerformancePerformanceElementTiming
Experimental
PerformanceEntryPerformanceEventTimingPerformanceLongAnimationFrameTiming
Experimental
PerformanceLongTaskTiming
Experimental
PerformanceMarkPerformanceMeasurePerformanceNavigation
Deprecated
PerformanceNavigationTimingPerformanceObserverPerformanceObserverEntryListPerformancePaintTimingPerformanceResourceTimingPerformanceScriptTiming
Experimental
PerformanceServerTimingPerformanceTiming
Deprecated
PeriodicSyncEvent
Experimental
PeriodicSyncManager
Experimental
PeriodicWavePermissionsPermissionStatusPictureInPictureEventPictureInPictureWindowPlugin
Deprecated
PluginArray
Deprecated
Point
Non-standard

Deprecated
PointerEventPopStateEventPositionSensorVRDevice
Non-standard

Deprecated
Presentation
Experimental
PresentationAvailability
Experimental
PresentationConnection
Experimental
PresentationConnectionAvailableEvent
Experimental
PresentationConnectionCloseEvent
Experimental
PresentationConnectionList
Experimental
PresentationReceiver
Experimental
PresentationRequest
Experimental
PressureObserver
Experimental
PressureRecord
Experimental
ProcessingInstructionProfiler
Experimental
ProgressEventPromiseRejectionEventPublicKeyCredentialPublicKeyCredentialCreationOptionsPublicKeyCredentialRequestOptionsPushEventPushManagerPushMessageDataPushSubscriptionPushSubscriptionOptionsRRadioNodeListRangeReadableByteStreamControllerReadableStreamReadableStreamBYOBReaderReadableStreamBYOBRequestReadableStreamDefaultControllerReadableStreamDefaultReaderRelativeOrientationSensorRemotePlaybackReportReportBodyReportingObserverRequestRequestInitResizeObserverResizeObserverEntryResizeObserverSizeResponseRestrictionTarget
Experimental
RsaHashedImportParamsRsaHashedKeyGenParamsRsaOaepParamsRsaPssParamsRTCAudioSourceStatsRTCCertificateRTCCertificateStatsRTCCodecStatsRTCDataChannelRTCDataChannelEventRTCDataChannelStatsRTCDtlsTransportRTCDTMFSenderRTCDTMFToneChangeEventRTCEncodedAudioFrameRTCEncodedVideoFrameRTCErrorRTCErrorEventRTCIceCandidateRTCIceCandidatePairRTCIceCandidatePairStatsRTCIceCandidateStatsRTCIceParametersRTCIceTransportRTCIdentityAssertion
Experimental
RTCInboundRtpStreamStatsRTCOutboundRtpStreamStatsRTCPeerConnectionRTCPeerConnectionIceErrorEventRTCPeerConnectionIceEventRTCPeerConnectionStatsRTCRemoteInboundRtpStreamStatsRTCRemoteOutboundRtpStreamStatsRTCRtpReceiverRTCRtpScriptTransformRTCRtpScriptTransformerRTCRtpSenderRTCRtpTransceiverRTCSctpTransportRTCSessionDescriptionRTCStatsReportRTCTrackEventRTCTransformEventRTCTransportStatsRTCVideoSourceStatsSSchedulerScheduling
Experimental
ScreenScreenDetailed
Experimental
ScreenDetails
Experimental
ScreenOrientationScriptProcessorNode
Deprecated
ScrollTimeline
Experimental
SecurePaymentConfirmationRequestSecurityPolicyViolationEventSelectionSensorSensorErrorEventSerial
Experimental
SerialPort
Experimental
ServiceWorkerServiceWorkerContainerServiceWorkerGlobalScopeServiceWorkerRegistrationShadowRootSharedStorage
Experimental
SharedStorageOperation
Experimental
SharedStorageRunOperation
Experimental
SharedStorageSelectURLOperation
Experimental
SharedStorageWorklet
Experimental
SharedStorageWorkletGlobalScope
Experimental
SharedWorkerSharedWorkerGlobalScopeSnapEvent
Experimental
SourceBufferSourceBufferListSpeechGrammar
Non-standard

Deprecated
SpeechGrammarList
Experimental
SpeechRecognitionSpeechRecognitionAlternativeSpeechRecognitionErrorEventSpeechRecognitionEventSpeechRecognitionResultSpeechRecognitionResultListSpeechSynthesisSpeechSynthesisErrorEventSpeechSynthesisEventSpeechSynthesisUtteranceSpeechSynthesisVoiceStaticRangeStereoPannerNodeStorageStorageAccessHandleStorageEventStorageManagerStylePropertyMapStylePropertyMapReadOnlyStyleSheetStyleSheetListSubmitEventSubtleCryptoSVGAElementSVGAngleSVGAnimateColorElement
Deprecated
SVGAnimatedAngleSVGAnimatedBooleanSVGAnimatedEnumerationSVGAnimatedIntegerSVGAnimatedLengthSVGAnimatedLengthListSVGAnimatedNumberSVGAnimatedNumberListSVGAnimatedPreserveAspectRatioSVGAnimatedRectSVGAnimatedStringSVGAnimatedTransformListSVGAnimateElementSVGAnimateMotionElementSVGAnimateTransformElementSVGAnimationElementSVGCircleElementSVGClipPathElementSVGComponentTransferFunctionElementSVGDefsElementSVGDescElementSVGDiscardElement
Experimental
SVGElementSVGEllipseElementSVGFEBlendElementSVGFEColorMatrixElementSVGFEComponentTransferElementSVGFECompositeElementSVGFEConvolveMatrixElementSVGFEDiffuseLightingElementSVGFEDisplacementMapElementSVGFEDistantLightElementSVGFEDropShadowElementSVGFEFloodElementSVGFEFuncAElementSVGFEFuncBElementSVGFEFuncGElementSVGFEFuncRElementSVGFEGaussianBlurElementSVGFEImageElementSVGFEMergeElementSVGFEMergeNodeElementSVGFEMorphologyElementSVGFEOffsetElementSVGFEPointLightElementSVGFESpecularLightingElementSVGFESpotLightElementSVGFETileElementSVGFETurbulenceElementSVGFilterElementSVGForeignObjectElementSVGGElementSVGGeometryElementSVGGradientElementSVGGraphicsElementSVGImageElementSVGLengthSVGLengthListSVGLinearGradientElementSVGLineElementSVGMarkerElementSVGMaskElementSVGMetadataElementSVGMPathElementSVGNumberSVGNumberListSVGPathElementSVGPatternElementSVGPoint
Deprecated
SVGPointListSVGPolygonElementSVGPolylineElementSVGPreserveAspectRatioSVGRadialGradientElementSVGRectSVGRectElementSVGRenderingIntent
Deprecated
SVGScriptElementSVGSetElementSVGStopElementSVGStringListSVGStyleElementSVGSVGElementSVGSwitchElementSVGSymbolElementSVGTextContentElementSVGTextElementSVGTextPathElementSVGTextPositioningElementSVGTitleElementSVGTransformSVGTransformListSVGTSpanElementSVGUnitTypesSVGUseElementSVGViewElementSyncEventSyncManagerTTaskAttributionTiming
Experimental
TaskControllerTaskPriorityChangeEventTaskSignalTextTextDecoderTextDecoderStreamTextEncoderTextEncoderStreamTextEvent
Deprecated
TextFormat
Experimental
TextFormatUpdateEvent
Experimental
TextMetricsTextTrackTextTrackCueTextTrackCueListTextTrackListTextUpdateEvent
Experimental
TimeEventTimeRangesToggleEventTouchTouchEventTouchListTrackEventTransformStreamTransformStreamDefaultControllerTransitionEventTreeWalkerTrustedHTMLTrustedScriptTrustedScriptURLTrustedTypePolicyTrustedTypePolicyFactoryUUIEventURLURLPattern
Experimental
URLSearchParamsUSB
Experimental
USBAlternateInterface
Experimental
USBConfiguration
Experimental
USBConnectionEvent
Experimental
USBDevice
Experimental
USBEndpoint
Experimental
USBInterface
Experimental
USBInTransferResult
Experimental
USBIsochronousInTransferPacket
Experimental
USBIsochronousInTransferResult
Experimental
USBIsochronousOutTransferPacket
Experimental
USBIsochronousOutTransferResult
Experimental
USBOutTransferResult
Experimental
UserActivationVValidityStateVideoColorSpaceVideoDecoderVideoEncoderVideoFrameVideoPlaybackQualityVideoTrackVideoTrackListViewTimeline
Experimental
ViewTransitionVirtualKeyboard
Experimental
VisibilityStateEntry
Experimental
VisualViewportVRDisplay
Non-standard

Deprecated
VRDisplayCapabilities
Non-standard

Deprecated
VRDisplayEvent
Non-standard

Deprecated
VREyeParameters
Non-standard

Deprecated
VRFieldOfView
Non-standard

Deprecated
VRFrameData
Non-standard

Deprecated
VRLayerInit
Deprecated
VRPose
Non-standard

Deprecated
VRStageParameters
Non-standard

Deprecated
VTTCueVTTRegionWWakeLockWakeLockSentinelWaveShaperNodeWebGL2RenderingContextWebGLActiveInfoWebGLBufferWebGLContextEventWebGLFramebufferWebGLObject
Experimental
WebGLProgramWebGLQueryWebGLRenderbufferWebGLRenderingContextWebGLSamplerWebGLShaderWebGLShaderPrecisionFormatWebGLSyncWebGLTextureWebGLTransformFeedbackWebGLUniformLocationWebGLVertexArrayObjectWebSocketWebSocketStream
Experimental
WebTransportWebTransportBidirectionalStreamWebTransportDatagramDuplexStreamWebTransportErrorWebTransportReceiveStream
Experimental
WebTransportSendStream
Experimental
WGSLLanguageFeatures
Experimental
WheelEventWindowWindowClientWindowControlsOverlay
Experimental
WindowControlsOverlayGeometryChangeEvent
Experimental
WindowSharedStorage
Experimental
WorkerWorkerGlobalScopeWorkerLocationWorkerNavigatorWorkletWorkletGlobalScopeWorkletSharedStorage
Experimental
WritableStreamWritableStreamDefaultControllerWritableStreamDefaultWriterXXMLDocumentXMLHttpRequestXMLHttpRequestEventTargetXMLHttpRequestUploadXMLSerializerXPathEvaluatorXPathExpressionXPathResultXRAnchor
Experimental
XRAnchorSet
Experimental
XRBoundedReferenceSpace
Experimental
XRCompositionLayer
Experimental
XRCPUDepthInformation
Experimental
XRCubeLayer
Experimental
XRCylinderLayer
Experimental
XRDepthInformation
Experimental
XREquirectLayer
Experimental
XRFrame
Experimental
XRHandXRHitTestResult
Experimental
XRHitTestSource
Experimental
XRInputSourceXRInputSourceArray
Experimental
XRInputSourceEventXRInputSourcesChangeEventXRJointPoseXRJointSpaceXRLayer
Experimental
XRLayerEvent
Experimental
XRLightEstimate
Experimental
XRLightProbe
Experimental
XRMediaBinding
Experimental
XRPoseXRProjectionLayer
Experimental
XRQuadLayer
Experimental
XRRay
Experimental
XRReferenceSpaceXRReferenceSpaceEventXRRenderState
Experimental
XRRigidTransformXRSession
Experimental
XRSessionEventXRSpaceXRSubImage
Experimental
XRSystem
Experimental
XRTransientInputHitTestResult
Experimental
XRTransientInputHitTestSource
Experimental
XRView
Experimental
XRViewerPoseXRViewportXRWebGLBinding
Experimental
XRWebGLDepthInformation
Experimental
XRWebGLLayer
Experimental
XRWebGLSubImage
Experimental
XSLTProcessorSee also
Web API event reference\n\nWeb APIsWhen writing code for the Web, there are a large number of Web APIs available. Below is a list of all the APIs and interfaces (object types) that you may be able to use while developing your Web app or site.
Web APIs are typically used with JavaScript, although this doesn't always have to be the case.SpecificationsThis is a list of all the APIs that are available.
AAttribution Reporting API
Experimental
Audio Output Devices API
Experimental
BBackground Fetch API
Experimental
Background Synchronization APIBackground Tasks APIBadging APIBarcode Detection API
Experimental
Battery Status APIBeacon APIWeb Bluetooth API
Experimental
Broadcast Channel APICCSS Custom Highlight APICSS Font Loading APICSS Painting API
Experimental
CSS Properties and Values APICSS Typed Object Model APICSS Object Model (CSSOM)Canvas APIChannel Messaging APIClipboard APICompression Streams APICompute Pressure API
Experimental
Console APIContact Picker API
Experimental
Content Index API
Experimental
Cookie Store APICredential Management APIDDocument Object Model (DOM)Device Memory APIDevice orientation eventsDevice Posture API
Experimental
Document Picture-in-Picture API
Experimental
EEditContext API
Experimental
Encoding APIEncrypted Media Extensions APIEyeDropper API
Experimental
FFederated Credential Management (FedCM) API
Experimental
Fenced Frame API
Experimental
Fetch APIFile APIFile System APIFile and Directory Entries APIForce Touch events
Non-standard
Fullscreen APIGGamepad APIGeolocation APIGeometry interfacesHThe HTML DOM APIHTML Drag and Drop APIHistory APIHoudini APIsIIdle Detection API
Experimental
MediaStream Image Capture APIIndexedDB APIInk API
Experimental
InputDeviceCapabilities API
Experimental
Insertable Streams for MediaStreamTrack APIIntersection Observer APIInvoker Commands APIJJS Self-Profiling API
Experimental
KKeyboard API
Experimental
LLaunch Handler API
Experimental
Local Font Access API
Experimental
MMedia Capabilities APIMedia Capture and Streams API (Media Stream)Media Session APIMedia Source API
Experimental
MediaStream Recording APINNavigation API
Experimental
Network Information APIPPage Visibility APIPayment Handler API
Experimental
Payment Request APIPerformance APIsWeb Periodic Background Synchronization API
Experimental
Permissions APIPicture-in-Picture APIPointer eventsPointer Lock APIPopover APIPresentation API
Experimental
Prioritized Task Scheduling APIPush APIRRemote Playback APIReporting APIResize Observer APISSVG APIScreen Capture APIScreen Orientation APIScreen Wake Lock APISelection APISensor APIsServer-sent eventsService Worker APIShared Storage API
Experimental
Speculation Rules API
Experimental
Storage APIStorage Access APIStreams APITTopics API
Experimental

Non-standard
Touch eventsTrusted Types APIUUI EventsURL APIURL Fragment Text DirectivesURL Pattern API
Experimental
User-Agent Client Hints API
Experimental
VVibration APIView Transition APIVirtualKeyboard API
Experimental
Visual Viewport APIWWeb Animations APIWeb Audio APIWeb Authentication APIWeb ComponentsWeb Crypto APIWeb Locks APIWeb MIDI APIWeb NFC API
Experimental
Notifications APIWeb Serial API
Experimental
Web Share APIWeb Speech APIWeb Storage APIWeb Workers APIWebCodecs APIWebGL: 2D and 3D graphics for the webWebGPU API
Experimental
WebHID API
Experimental
WebOTP APIWebRTC APIThe WebSocket API (WebSockets)WebTransport APIWebUSB API
Experimental
WebVR API
Non-standard

Deprecated
WebVTT APIWebXR Device API
Experimental
Window Controls Overlay API
Experimental
Window Management API
Experimental
XXMLHttpRequest APIffetchLater() API
Experimental
InterfacesThis is a list of all the interfaces (that is, types of objects) that are available.
AAbortControllerAbortSignalAbsoluteOrientationSensorAbstractRangeAccelerometer
Experimental
AesCbcParamsAesCtrParamsAesGcmParamsAesKeyGenParamsAmbientLightSensor
Experimental
AnalyserNodeANGLE_instanced_arraysAnimationAnimationEffectAnimationEventAnimationPlaybackEventAnimationTimelineAttrAudioBufferAudioBufferSourceNodeAudioContextAudioDataAudioDecoderAudioDestinationNodeAudioEncoderAudioListenerAudioNodeAudioParamAudioParamDescriptorAudioParamMapAudioProcessingEvent
Deprecated
AudioScheduledSourceNodeAudioSinkInfo
Experimental
AudioTrackAudioTrackListAudioWorkletAudioWorkletGlobalScopeAudioWorkletNodeAudioWorkletProcessorAuthenticatorAssertionResponseAuthenticatorAttestationResponseAuthenticatorResponseBBackgroundFetchEvent
Experimental
BackgroundFetchManager
Experimental
BackgroundFetchRecord
Experimental
BackgroundFetchRegistration
Experimental
BackgroundFetchUpdateUIEvent
Experimental
BarcodeDetector
Experimental
BarPropBaseAudioContextBatteryManagerBeforeInstallPromptEvent
Experimental

Non-standard
BeforeUnloadEventBiquadFilterNodeBlobBlobEventBluetooth
Experimental
BluetoothCharacteristicProperties
Experimental
BluetoothDevice
Experimental
BluetoothRemoteGATTCharacteristic
Experimental
BluetoothRemoteGATTDescriptor
Experimental
BluetoothRemoteGATTServer
Experimental
BluetoothRemoteGATTService
Experimental
BluetoothUUIDBroadcastChannelBrowserCaptureMediaStreamTrack
Experimental
ByteLengthQueuingStrategyCCacheCacheStorageCanMakePaymentEvent
Experimental
CanvasCaptureMediaStreamTrackCanvasGradientCanvasPatternCanvasRenderingContext2DCaptureController
Experimental
CaretPositionCDATASectionChannelMergerNodeChannelSplitterNodeChapterInformation
Experimental
CharacterBoundsUpdateEvent
Experimental
CharacterDataClientClientsClipboardClipboardEventClipboardItemCloseEventCloseWatcher
Experimental
CommandEventCommentCompositionEventCompressionStreamcconsoleCConstantSourceNodeContactAddress
Experimental
ContactsManager
Experimental
ContentIndex
Experimental
ContentIndexEvent
Experimental
ContentVisibilityAutoStateChangeEventConvolverNodeCookieChangeEventCookieStoreCookieStoreManagerCountQueuingStrategyCredentialCredentialsContainerCropTarget
Experimental
CryptoCryptoKeyCryptoKeyPairCSPViolationReportBodyCSSCSSAnimationCSSConditionRuleCSSContainerRuleCSSCounterStyleRuleCSSFontFaceRuleCSSFontFeatureValuesRuleCSSFontPaletteValuesRuleCSSGroupingRuleCSSImageValueCSSImportRuleCSSKeyframeRuleCSSKeyframesRuleCSSKeywordValueCSSLayerBlockRuleCSSLayerStatementRuleCSSMathInvertCSSMathMaxCSSMathMinCSSMathNegateCSSMathProductCSSMathSumCSSMathValueCSSMatrixComponentCSSMediaRuleCSSNamespaceRuleCSSNestedDeclarationsCSSNumericArrayCSSNumericValueCSSPageDescriptors
Experimental
CSSPageRuleCSSPerspectiveCSSPositionTryDescriptors
Experimental
CSSPositionTryRule
Experimental
CSSPositionValue
Non-standard

Deprecated
CSSPrimitiveValue
Deprecated
CSSPropertyRuleCSSPseudoElement
Experimental
CSSRotateCSSRuleCSSRuleListCSSScaleCSSScopeRuleCSSSkewCSSSkewXCSSSkewYCSSStartingStyleRuleCSSStyleDeclarationCSSStyleRuleCSSStyleSheetCSSStyleValueCSSSupportsRuleCSSTransformComponentCSSTransformValueCSSTransitionCSSTranslateCSSUnitValueCSSUnparsedValueCSSValue
Deprecated
CSSValueList
Deprecated
CSSVariableReferenceValueCustomElementRegistryCustomEventCustomStateSetDDataTransferDataTransferItemDataTransferItemListDecompressionStreamDedicatedWorkerGlobalScopeDeferredRequestInit
Experimental
DelayNodeDelegatedInkTrailPresenter
Experimental
DeprecationReportBody
Experimental
DeviceMotionEventDeviceMotionEventAccelerationDeviceMotionEventRotationRateDeviceOrientationEventDevicePosture
Experimental
DirectoryEntrySync
Non-standard

Deprecated
DirectoryReaderSync
Non-standard

Deprecated
DocumentDocumentFragmentDocumentPictureInPicture
Experimental
DocumentPictureInPictureEvent
Experimental
DocumentTimelineDocumentTypeDOMError
Deprecated
DOMExceptionDOMHighResTimeStampDOMImplementationDOMMatrixDOMMatrixReadOnlyDOMParserDOMPointDOMPointReadOnlyDOMQuadDOMRectDOMRectListDOMRectReadOnlyDOMStringListDOMStringMapDOMTokenListDragEventDynamicsCompressorNodeEEcdhKeyDeriveParamsEcdsaParamsEcKeyGenParamsEcKeyImportParamsEditContext
Experimental
ElementElementInternalsEncodedAudioChunkEncodedVideoChunkErrorEventEventEventCountsEventSourceEventTargetExtendableCookieChangeEventExtendableEventExtendableMessageEventEyeDropper
Experimental
FFeaturePolicy
Experimental
FederatedCredential
Experimental
FederatedCredentialInitFence
Experimental
FencedFrameConfig
Experimental
FetchEventFetchLaterResult
Experimental
FileFileEntrySync
Non-standard

Deprecated
FileListFileReaderFileReaderSyncFileSystemFileSystemChangeRecordFileSystemDirectoryEntryFileSystemDirectoryHandleFileSystemDirectoryReaderFileSystemEntryFileSystemFileEntryFileSystemFileHandleFileSystemHandleFileSystemObserver
Experimental

Non-standard
FileSystemSync
Non-standard

Deprecated
FileSystemSyncAccessHandleFileSystemWritableFileStreamFocusEventFontData
Experimental
FontFaceFontFaceSetFontFaceSetLoadEventFormDataFormDataEventFragmentDirectiveGGainNodeGamepadGamepadButtonGamepadEventGamepadHapticActuatorGamepadPose
Experimental
GeolocationGeolocationCoordinatesGeolocationPositionGeolocationPositionErrorGestureEvent
Non-standard
GPU
Experimental
GPUAdapter
Experimental
GPUAdapterInfo
Experimental
GPUBindGroup
Experimental
GPUBindGroupLayout
Experimental
GPUBuffer
Experimental
GPUCanvasContext
Experimental
GPUCommandBuffer
Experimental
GPUCommandEncoder
Experimental
GPUCompilationInfo
Experimental
GPUCompilationMessage
Experimental
GPUComputePassEncoder
Experimental
GPUComputePipeline
Experimental
GPUDevice
Experimental
GPUDeviceLostInfo
Experimental
GPUError
Experimental
GPUExternalTexture
Experimental
GPUInternalError
Experimental
GPUOutOfMemoryError
Experimental
GPUPipelineError
Experimental
GPUPipelineLayout
Experimental
GPUQuerySet
Experimental
GPUQueue
Experimental
GPURenderBundle
Experimental
GPURenderBundleEncoder
Experimental
GPURenderPassEncoder
Experimental
GPURenderPipeline
Experimental
GPUSampler
Experimental
GPUShaderModule
Experimental
GPUSupportedFeatures
Experimental
GPUSupportedLimits
Experimental
GPUTexture
Experimental
GPUTextureView
Experimental
GPUUncapturedErrorEvent
Experimental
GPUValidationError
Experimental
GravitySensorGyroscopeHHashChangeEventHeadersHID
Experimental
HIDConnectionEvent
Experimental
HIDDevice
Experimental
HIDInputReportEvent
Experimental
HighlightHighlightRegistryHistoryHkdfParamsHmacImportParamsHmacKeyGenParamsHMDVRDevice
Non-standard

Deprecated
HTMLAllCollectionHTMLAnchorElementHTMLAreaElementHTMLAudioElementHTMLBaseElementHTMLBodyElementHTMLBRElementHTMLButtonElementHTMLCanvasElementHTMLCollectionHTMLDataElementHTMLDataListElementHTMLDetailsElementHTMLDialogElementHTMLDivElementHTMLDListElementHTMLDocumentHTMLElementHTMLEmbedElementHTMLFencedFrameElement
Experimental
HTMLFieldSetElementHTMLFontElement
Deprecated
HTMLFormControlsCollectionHTMLFormElementHTMLFrameSetElement
Deprecated
HTMLHeadElementHTMLHeadingElementHTMLHRElementHTMLHtmlElementHTMLIFrameElementHTMLImageElementHTMLInputElementHTMLLabelElementHTMLLegendElementHTMLLIElementHTMLLinkElementHTMLMapElementHTMLMarqueeElement
Deprecated
HTMLMediaElementHTMLMenuElementHTMLMetaElementHTMLMeterElementHTMLModElementHTMLObjectElementHTMLOListElementHTMLOptGroupElementHTMLOptionElementHTMLOptionsCollectionHTMLOutputElementHTMLParagraphElementHTMLParamElement
Deprecated
HTMLPictureElementHTMLPreElementHTMLProgressElementHTMLQuoteElementHTMLScriptElementHTMLSelectedContentElementHTMLSelectElementHTMLSlotElementHTMLSourceElementHTMLSpanElementHTMLStyleElementHTMLTableCaptionElementHTMLTableCellElementHTMLTableColElementHTMLTableElementHTMLTableRowElementHTMLTableSectionElementHTMLTemplateElementHTMLTextAreaElementHTMLTimeElementHTMLTitleElementHTMLTrackElementHTMLUListElementHTMLUnknownElementHTMLVideoElementIIDBCursorIDBCursorWithValueIDBDatabaseIDBFactoryIDBIndexIDBKeyRangeIDBObjectStoreIDBOpenDBRequestIDBRequestIDBTransactionIDBVersionChangeEventIdentityCredential
Experimental
IdentityCredentialRequestOptionsIdentityProvider
Experimental
IdleDeadlineIdleDetector
Experimental
IIRFilterNodeImageBitmapImageBitmapRenderingContextImageCaptureImageDataImageDecoderImageTrackImageTrackListInk
Experimental
InputDeviceCapabilities
Experimental
InputDeviceInfoInputEventInstallEventIntersectionObserverIntersectionObserverEntryInterventionReportBody
Experimental
KKeyboard
Experimental
KeyboardEventKeyboardLayoutMap
Experimental
KeyframeEffectLLargestContentfulPaintLaunchParams
Experimental
LaunchQueue
Experimental
LayoutShift
Experimental
LayoutShiftAttribution
Experimental
LinearAccelerationSensorLocationLockLockManagerMMagnetometer
Experimental
MathMLElementMediaCapabilitiesMediaDeviceInfoMediaDevicesMediaElementAudioSourceNodeMediaEncryptedEventMediaErrorMediaKeyMessageEventMediaKeysMediaKeySessionMediaKeyStatusMapMediaKeySystemAccessMediaListMediaMetadataMediaQueryListMediaQueryListEventMediaRecorderMediaRecorderErrorEvent
Non-standard

Deprecated
MediaSessionMediaSourceMediaSourceHandleMediaStreamMediaStreamAudioDestinationNodeMediaStreamAudioSourceNodeMediaStreamEvent
Non-standard

Deprecated
MediaStreamTrackMediaStreamTrackAudioSourceNodeMediaStreamTrackEventMediaStreamTrackGenerator
Experimental

Non-standard
MediaStreamTrackProcessorMediaTrackConstraintsMediaTrackSettingsMediaTrackSupportedConstraintsMerchantValidationEvent
Deprecated
MessageChannelMessageEventMessagePortMetadata
Experimental

Non-standard
MIDIAccessMIDIConnectionEventMIDIInputMIDIInputMapMIDIMessageEventMIDIOutputMIDIOutputMapMIDIPortMimeType
Deprecated
MimeTypeArray
Deprecated
MouseEventMouseScrollEvent
Non-standard

Deprecated
MutationEvent
Non-standard

Deprecated
MutationObserverMutationRecordNNamedNodeMapNavigateEvent
Experimental
Navigation
Experimental
NavigationActivation
Experimental
NavigationCurrentEntryChangeEvent
Experimental
NavigationDestination
Experimental
NavigationHistoryEntry
Experimental
NavigationPreloadManagerNavigationTransition
Experimental
NavigatorNavigatorLoginNavigatorUAData
Experimental
NDEFMessage
Experimental
NDEFReader
Experimental
NDEFReadingEvent
Experimental
NDEFRecord
Experimental
NetworkInformationNodeNodeIteratorNodeListNotificationNotificationEventNotRestoredReasonDetails
Experimental
NotRestoredReasons
Experimental
OOES_draw_buffers_indexedOfflineAudioCompletionEventOfflineAudioContextOffscreenCanvasOffscreenCanvasRenderingContext2DOrientationSensorOscillatorNodeOTPCredential
Experimental
OverconstrainedErrorPPageRevealEventPageSwapEventPageTransitionEventPaintRenderingContext2DPaintSizePaintWorkletGlobalScope
Experimental
PannerNodePasswordCredential
Experimental
PasswordCredentialInitPath2DPaymentAddress
Non-standard

Deprecated
PaymentManager
Experimental
PaymentMethodChangeEventPaymentRequestPaymentRequestEvent
Experimental
PaymentRequestUpdateEventPaymentResponsePbkdf2ParamsPerformancePerformanceElementTiming
Experimental
PerformanceEntryPerformanceEventTimingPerformanceLongAnimationFrameTiming
Experimental
PerformanceLongTaskTiming
Experimental
PerformanceMarkPerformanceMeasurePerformanceNavigation
Deprecated
PerformanceNavigationTimingPerformanceObserverPerformanceObserverEntryListPerformancePaintTimingPerformanceResourceTimingPerformanceScriptTiming
Experimental
PerformanceServerTimingPerformanceTiming
Deprecated
PeriodicSyncEvent
Experimental
PeriodicSyncManager
Experimental
PeriodicWavePermissionsPermissionStatusPictureInPictureEventPictureInPictureWindowPlugin
Deprecated
PluginArray
Deprecated
Point
Non-standard

Deprecated
PointerEventPopStateEventPositionSensorVRDevice
Non-standard

Deprecated
Presentation
Experimental
PresentationAvailability
Experimental
PresentationConnection
Experimental
PresentationConnectionAvailableEvent
Experimental
PresentationConnectionCloseEvent
Experimental
PresentationConnectionList
Experimental
PresentationReceiver
Experimental
PresentationRequest
Experimental
PressureObserver
Experimental
PressureRecord
Experimental
ProcessingInstructionProfiler
Experimental
ProgressEventPromiseRejectionEventPublicKeyCredentialPublicKeyCredentialCreationOptionsPublicKeyCredentialRequestOptionsPushEventPushManagerPushMessageDataPushSubscriptionPushSubscriptionOptionsRRadioNodeListRangeReadableByteStreamControllerReadableStreamReadableStreamBYOBReaderReadableStreamBYOBRequestReadableStreamDefaultControllerReadableStreamDefaultReaderRelativeOrientationSensorRemotePlaybackReportReportBodyReportingObserverRequestRequestInitResizeObserverResizeObserverEntryResizeObserverSizeResponseRestrictionTarget
Experimental
RsaHashedImportParamsRsaHashedKeyGenParamsRsaOaepParamsRsaPssParamsRTCAudioSourceStatsRTCCertificateRTCCertificateStatsRTCCodecStatsRTCDataChannelRTCDataChannelEventRTCDataChannelStatsRTCDtlsTransportRTCDTMFSenderRTCDTMFToneChangeEventRTCEncodedAudioFrameRTCEncodedVideoFrameRTCErrorRTCErrorEventRTCIceCandidateRTCIceCandidatePairRTCIceCandidatePairStatsRTCIceCandidateStatsRTCIceParametersRTCIceTransportRTCIdentityAssertion
Experimental
RTCInboundRtpStreamStatsRTCOutboundRtpStreamStatsRTCPeerConnectionRTCPeerConnectionIceErrorEventRTCPeerConnectionIceEventRTCPeerConnectionStatsRTCRemoteInboundRtpStreamStatsRTCRemoteOutboundRtpStreamStatsRTCRtpReceiverRTCRtpScriptTransformRTCRtpScriptTransformerRTCRtpSenderRTCRtpTransceiverRTCSctpTransportRTCSessionDescriptionRTCStatsReportRTCTrackEventRTCTransformEventRTCTransportStatsRTCVideoSourceStatsSSchedulerScheduling
Experimental
ScreenScreenDetailed
Experimental
ScreenDetails
Experimental
ScreenOrientationScriptProcessorNode
Deprecated
ScrollTimeline
Experimental
SecurePaymentConfirmationRequestSecurityPolicyViolationEventSelectionSensorSensorErrorEventSerial
Experimental
SerialPort
Experimental
ServiceWorkerServiceWorkerContainerServiceWorkerGlobalScopeServiceWorkerRegistrationShadowRootSharedStorage
Experimental
SharedStorageOperation
Experimental
SharedStorageRunOperation
Experimental
SharedStorageSelectURLOperation
Experimental
SharedStorageWorklet
Experimental
SharedStorageWorkletGlobalScope
Experimental
SharedWorkerSharedWorkerGlobalScopeSnapEvent
Experimental
SourceBufferSourceBufferListSpeechGrammar
Non-standard

Deprecated
SpeechGrammarList
Experimental
SpeechRecognitionSpeechRecognitionAlternativeSpeechRecognitionErrorEventSpeechRecognitionEventSpeechRecognitionResultSpeechRecognitionResultListSpeechSynthesisSpeechSynthesisErrorEventSpeechSynthesisEventSpeechSynthesisUtteranceSpeechSynthesisVoiceStaticRangeStereoPannerNodeStorageStorageAccessHandleStorageEventStorageManagerStylePropertyMapStylePropertyMapReadOnlyStyleSheetStyleSheetListSubmitEventSubtleCryptoSVGAElementSVGAngleSVGAnimateColorElement
Deprecated
SVGAnimatedAngleSVGAnimatedBooleanSVGAnimatedEnumerationSVGAnimatedIntegerSVGAnimatedLengthSVGAnimatedLengthListSVGAnimatedNumberSVGAnimatedNumberListSVGAnimatedPreserveAspectRatioSVGAnimatedRectSVGAnimatedStringSVGAnimatedTransformListSVGAnimateElementSVGAnimateMotionElementSVGAnimateTransformElementSVGAnimationElementSVGCircleElementSVGClipPathElementSVGComponentTransferFunctionElementSVGDefsElementSVGDescElementSVGDiscardElement
Experimental
SVGElementSVGEllipseElementSVGFEBlendElementSVGFEColorMatrixElementSVGFEComponentTransferElementSVGFECompositeElementSVGFEConvolveMatrixElementSVGFEDiffuseLightingElementSVGFEDisplacementMapElementSVGFEDistantLightElementSVGFEDropShadowElementSVGFEFloodElementSVGFEFuncAElementSVGFEFuncBElementSVGFEFuncGElementSVGFEFuncRElementSVGFEGaussianBlurElementSVGFEImageElementSVGFEMergeElementSVGFEMergeNodeElementSVGFEMorphologyElementSVGFEOffsetElementSVGFEPointLightElementSVGFESpecularLightingElementSVGFESpotLightElementSVGFETileElementSVGFETurbulenceElementSVGFilterElementSVGForeignObjectElementSVGGElementSVGGeometryElementSVGGradientElementSVGGraphicsElementSVGImageElementSVGLengthSVGLengthListSVGLinearGradientElementSVGLineElementSVGMarkerElementSVGMaskElementSVGMetadataElementSVGMPathElementSVGNumberSVGNumberListSVGPathElementSVGPatternElementSVGPoint
Deprecated
SVGPointListSVGPolygonElementSVGPolylineElementSVGPreserveAspectRatioSVGRadialGradientElementSVGRectSVGRectElementSVGRenderingIntent
Deprecated
SVGScriptElementSVGSetElementSVGStopElementSVGStringListSVGStyleElementSVGSVGElementSVGSwitchElementSVGSymbolElementSVGTextContentElementSVGTextElementSVGTextPathElementSVGTextPositioningElementSVGTitleElementSVGTransformSVGTransformListSVGTSpanElementSVGUnitTypesSVGUseElementSVGViewElementSyncEventSyncManagerTTaskAttributionTiming
Experimental
TaskControllerTaskPriorityChangeEventTaskSignalTextTextDecoderTextDecoderStreamTextEncoderTextEncoderStreamTextEvent
Deprecated
TextFormat
Experimental
TextFormatUpdateEvent
Experimental
TextMetricsTextTrackTextTrackCueTextTrackCueListTextTrackListTextUpdateEvent
Experimental
TimeEventTimeRangesToggleEventTouchTouchEventTouchListTrackEventTransformStreamTransformStreamDefaultControllerTransitionEventTreeWalkerTrustedHTMLTrustedScriptTrustedScriptURLTrustedTypePolicyTrustedTypePolicyFactoryUUIEventURLURLPattern
Experimental
URLSearchParamsUSB
Experimental
USBAlternateInterface
Experimental
USBConfiguration
Experimental
USBConnectionEvent
Experimental
USBDevice
Experimental
USBEndpoint
Experimental
USBInterface
Experimental
USBInTransferResult
Experimental
USBIsochronousInTransferPacket
Experimental
USBIsochronousInTransferResult
Experimental
USBIsochronousOutTransferPacket
Experimental
USBIsochronousOutTransferResult
Experimental
USBOutTransferResult
Experimental
UserActivationVValidityStateVideoColorSpaceVideoDecoderVideoEncoderVideoFrameVideoPlaybackQualityVideoTrackVideoTrackListViewTimeline
Experimental
ViewTransitionVirtualKeyboard
Experimental
VisibilityStateEntry
Experimental
VisualViewportVRDisplay
Non-standard

Deprecated
VRDisplayCapabilities
Non-standard

Deprecated
VRDisplayEvent
Non-standard

Deprecated
VREyeParameters
Non-standard

Deprecated
VRFieldOfView
Non-standard

Deprecated
VRFrameData
Non-standard

Deprecated
VRLayerInit
Deprecated
VRPose
Non-standard

Deprecated
VRStageParameters
Non-standard

Deprecated
VTTCueVTTRegionWWakeLockWakeLockSentinelWaveShaperNodeWebGL2RenderingContextWebGLActiveInfoWebGLBufferWebGLContextEventWebGLFramebufferWebGLObject
Experimental
WebGLProgramWebGLQueryWebGLRenderbufferWebGLRenderingContextWebGLSamplerWebGLShaderWebGLShaderPrecisionFormatWebGLSyncWebGLTextureWebGLTransformFeedbackWebGLUniformLocationWebGLVertexArrayObjectWebSocketWebSocketStream
Experimental
WebTransportWebTransportBidirectionalStreamWebTransportDatagramDuplexStreamWebTransportErrorWebTransportReceiveStream
Experimental
WebTransportSendStream
Experimental
WGSLLanguageFeatures
Experimental
WheelEventWindowWindowClientWindowControlsOverlay
Experimental
WindowControlsOverlayGeometryChangeEvent
Experimental
WindowSharedStorage
Experimental
WorkerWorkerGlobalScopeWorkerLocationWorkerNavigatorWorkletWorkletGlobalScopeWorkletSharedStorage
Experimental
WritableStreamWritableStreamDefaultControllerWritableStreamDefaultWriterXXMLDocumentXMLHttpRequestXMLHttpRequestEventTargetXMLHttpRequestUploadXMLSerializerXPathEvaluatorXPathExpressionXPathResultXRAnchor
Experimental
XRAnchorSet
Experimental
XRBoundedReferenceSpace
Experimental
XRCompositionLayer
Experimental
XRCPUDepthInformation
Experimental
XRCubeLayer
Experimental
XRCylinderLayer
Experimental
XRDepthInformation
Experimental
XREquirectLayer
Experimental
XRFrame
Experimental
XRHandXRHitTestResult
Experimental
XRHitTestSource
Experimental
XRInputSourceXRInputSourceArray
Experimental
XRInputSourceEventXRInputSourcesChangeEventXRJointPoseXRJointSpaceXRLayer
Experimental
XRLayerEvent
Experimental
XRLightEstimate
Experimental
XRLightProbe
Experimental
XRMediaBinding
Experimental
XRPoseXRProjectionLayer
Experimental
XRQuadLayer
Experimental
XRRay
Experimental
XRReferenceSpaceXRReferenceSpaceEventXRRenderState
Experimental
XRRigidTransformXRSession
Experimental
XRSessionEventXRSpaceXRSubImage
Experimental
XRSystem
Experimental
XRTransientInputHitTestResult
Experimental
XRTransientInputHitTestSource
Experimental
XRView
Experimental
XRViewerPoseXRViewportXRWebGLBinding
Experimental
XRWebGLDepthInformation
Experimental
XRWebGLLayer
Experimental
XRWebGLSubImage
Experimental
XSLTProcessorSee also
Web API event reference
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 20, 2023 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWeb APIsWhen writing code for the Web, there are a large number of Web APIs available. Below is a list of all the APIs and interfaces (object types) that you may be able to use while developing your Web app or site.
Web APIs are typically used with JavaScript, although this doesn't always have to be the case.SpecificationsThis is a list of all the APIs that are available.
AAttribution Reporting API
Experimental
Audio Output Devices API
Experimental
BBackground Fetch API
Experimental
Background Synchronization APIBackground Tasks APIBadging APIBarcode Detection API
Experimental
Battery Status APIBeacon APIWeb Bluetooth API
Experimental
Broadcast Channel APICCSS Custom Highlight APICSS Font Loading APICSS Painting API
Experimental
CSS Properties and Values APICSS Typed Object Model APICSS Object Model (CSSOM)Canvas APIChannel Messaging APIClipboard APICompression Streams APICompute Pressure API
Experimental
Console APIContact Picker API
Experimental
Content Index API
Experimental
Cookie Store APICredential Management APIDDocument Object Model (DOM)Device Memory APIDevice orientation eventsDevice Posture API
Experimental
Document Picture-in-Picture API
Experimental
EEditContext API
Experimental
Encoding APIEncrypted Media Extensions APIEyeDropper API
Experimental
FFederated Credential Management (FedCM) API
Experimental
Fenced Frame API
Experimental
Fetch APIFile APIFile System APIFile and Directory Entries APIForce Touch events
Non-standard
Fullscreen APIGGamepad APIGeolocation APIGeometry interfacesHThe HTML DOM APIHTML Drag and Drop APIHistory APIHoudini APIsIIdle Detection API
Experimental
MediaStream Image Capture APIIndexedDB APIInk API
Experimental
InputDeviceCapabilities API
Experimental
Insertable Streams for MediaStreamTrack APIIntersection Observer APIInvoker Commands APIJJS Self-Profiling API
Experimental
KKeyboard API
Experimental
LLaunch Handler API
Experimental
Local Font Access API
Experimental
MMedia Capabilities APIMedia Capture and Streams API (Media Stream)Media Session APIMedia Source API
Experimental
MediaStream Recording APINNavigation API
Experimental
Network Information APIPPage Visibility APIPayment Handler API
Experimental
Payment Request APIPerformance APIsWeb Periodic Background Synchronization API
Experimental
Permissions APIPicture-in-Picture APIPointer eventsPointer Lock APIPopover APIPresentation API
Experimental
Prioritized Task Scheduling APIPush APIRRemote Playback APIReporting APIResize Observer APISSVG APIScreen Capture APIScreen Orientation APIScreen Wake Lock APISelection APISensor APIsServer-sent eventsService Worker APIShared Storage API
Experimental
Speculation Rules API
Experimental
Storage APIStorage Access APIStreams APITTopics API
Experimental

Non-standard
Touch eventsTrusted Types APIUUI EventsURL APIURL Fragment Text DirectivesURL Pattern API
Experimental
User-Agent Client Hints API
Experimental
VVibration APIView Transition APIVirtualKeyboard API
Experimental
Visual Viewport APIWWeb Animations APIWeb Audio APIWeb Authentication APIWeb ComponentsWeb Crypto APIWeb Locks APIWeb MIDI APIWeb NFC API
Experimental
Notifications APIWeb Serial API
Experimental
Web Share APIWeb Speech APIWeb Storage APIWeb Workers APIWebCodecs APIWebGL: 2D and 3D graphics for the webWebGPU API
Experimental
WebHID API
Experimental
WebOTP APIWebRTC APIThe WebSocket API (WebSockets)WebTransport APIWebUSB API
Experimental
WebVR API
Non-standard

Deprecated
WebVTT APIWebXR Device API
Experimental
Window Controls Overlay API
Experimental
Window Management API
Experimental
XXMLHttpRequest APIffetchLater() API
Experimental
InterfacesThis is a list of all the interfaces (that is, types of objects) that are available.
AAbortControllerAbortSignalAbsoluteOrientationSensorAbstractRangeAccelerometer
Experimental
AesCbcParamsAesCtrParamsAesGcmParamsAesKeyGenParamsAmbientLightSensor
Experimental
AnalyserNodeANGLE_instanced_arraysAnimationAnimationEffectAnimationEventAnimationPlaybackEventAnimationTimelineAttrAudioBufferAudioBufferSourceNodeAudioContextAudioDataAudioDecoderAudioDestinationNodeAudioEncoderAudioListenerAudioNodeAudioParamAudioParamDescriptorAudioParamMapAudioProcessingEvent
Deprecated
AudioScheduledSourceNodeAudioSinkInfo
Experimental
AudioTrackAudioTrackListAudioWorkletAudioWorkletGlobalScopeAudioWorkletNodeAudioWorkletProcessorAuthenticatorAssertionResponseAuthenticatorAttestationResponseAuthenticatorResponseBBackgroundFetchEvent
Experimental
BackgroundFetchManager
Experimental
BackgroundFetchRecord
Experimental
BackgroundFetchRegistration
Experimental
BackgroundFetchUpdateUIEvent
Experimental
BarcodeDetector
Experimental
BarPropBaseAudioContextBatteryManagerBeforeInstallPromptEvent
Experimental

Non-standard
BeforeUnloadEventBiquadFilterNodeBlobBlobEventBluetooth
Experimental
BluetoothCharacteristicProperties
Experimental
BluetoothDevice
Experimental
BluetoothRemoteGATTCharacteristic
Experimental
BluetoothRemoteGATTDescriptor
Experimental
BluetoothRemoteGATTServer
Experimental
BluetoothRemoteGATTService
Experimental
BluetoothUUIDBroadcastChannelBrowserCaptureMediaStreamTrack
Experimental
ByteLengthQueuingStrategyCCacheCacheStorageCanMakePaymentEvent
Experimental
CanvasCaptureMediaStreamTrackCanvasGradientCanvasPatternCanvasRenderingContext2DCaptureController
Experimental
CaretPositionCDATASectionChannelMergerNodeChannelSplitterNodeChapterInformation
Experimental
CharacterBoundsUpdateEvent
Experimental
CharacterDataClientClientsClipboardClipboardEventClipboardItemCloseEventCloseWatcher
Experimental
CommandEventCommentCompositionEventCompressionStreamcconsoleCConstantSourceNodeContactAddress
Experimental
ContactsManager
Experimental
ContentIndex
Experimental
ContentIndexEvent
Experimental
ContentVisibilityAutoStateChangeEventConvolverNodeCookieChangeEventCookieStoreCookieStoreManagerCountQueuingStrategyCredentialCredentialsContainerCropTarget
Experimental
CryptoCryptoKeyCryptoKeyPairCSPViolationReportBodyCSSCSSAnimationCSSConditionRuleCSSContainerRuleCSSCounterStyleRuleCSSFontFaceRuleCSSFontFeatureValuesRuleCSSFontPaletteValuesRuleCSSGroupingRuleCSSImageValueCSSImportRuleCSSKeyframeRuleCSSKeyframesRuleCSSKeywordValueCSSLayerBlockRuleCSSLayerStatementRuleCSSMathInvertCSSMathMaxCSSMathMinCSSMathNegateCSSMathProductCSSMathSumCSSMathValueCSSMatrixComponentCSSMediaRuleCSSNamespaceRuleCSSNestedDeclarationsCSSNumericArrayCSSNumericValueCSSPageDescriptors
Experimental
CSSPageRuleCSSPerspectiveCSSPositionTryDescriptors
Experimental
CSSPositionTryRule
Experimental
CSSPositionValue
Non-standard

Deprecated
CSSPrimitiveValue
Deprecated
CSSPropertyRuleCSSPseudoElement
Experimental
CSSRotateCSSRuleCSSRuleListCSSScaleCSSScopeRuleCSSSkewCSSSkewXCSSSkewYCSSStartingStyleRuleCSSStyleDeclarationCSSStyleRuleCSSStyleSheetCSSStyleValueCSSSupportsRuleCSSTransformComponentCSSTransformValueCSSTransitionCSSTranslateCSSUnitValueCSSUnparsedValueCSSValue
Deprecated
CSSValueList
Deprecated
CSSVariableReferenceValueCustomElementRegistryCustomEventCustomStateSetDDataTransferDataTransferItemDataTransferItemListDecompressionStreamDedicatedWorkerGlobalScopeDeferredRequestInit
Experimental
DelayNodeDelegatedInkTrailPresenter
Experimental
DeprecationReportBody
Experimental
DeviceMotionEventDeviceMotionEventAccelerationDeviceMotionEventRotationRateDeviceOrientationEventDevicePosture
Experimental
DirectoryEntrySync
Non-standard

Deprecated
DirectoryReaderSync
Non-standard

Deprecated
DocumentDocumentFragmentDocumentPictureInPicture
Experimental
DocumentPictureInPictureEvent
Experimental
DocumentTimelineDocumentTypeDOMError
Deprecated
DOMExceptionDOMHighResTimeStampDOMImplementationDOMMatrixDOMMatrixReadOnlyDOMParserDOMPointDOMPointReadOnlyDOMQuadDOMRectDOMRectListDOMRectReadOnlyDOMStringListDOMStringMapDOMTokenListDragEventDynamicsCompressorNodeEEcdhKeyDeriveParamsEcdsaParamsEcKeyGenParamsEcKeyImportParamsEditContext
Experimental
ElementElementInternalsEncodedAudioChunkEncodedVideoChunkErrorEventEventEventCountsEventSourceEventTargetExtendableCookieChangeEventExtendableEventExtendableMessageEventEyeDropper
Experimental
FFeaturePolicy
Experimental
FederatedCredential
Experimental
FederatedCredentialInitFence
Experimental
FencedFrameConfig
Experimental
FetchEventFetchLaterResult
Experimental
FileFileEntrySync
Non-standard

Deprecated
FileListFileReaderFileReaderSyncFileSystemFileSystemChangeRecordFileSystemDirectoryEntryFileSystemDirectoryHandleFileSystemDirectoryReaderFileSystemEntryFileSystemFileEntryFileSystemFileHandleFileSystemHandleFileSystemObserver
Experimental

Non-standard
FileSystemSync
Non-standard

Deprecated
FileSystemSyncAccessHandleFileSystemWritableFileStreamFocusEventFontData
Experimental
FontFaceFontFaceSetFontFaceSetLoadEventFormDataFormDataEventFragmentDirectiveGGainNodeGamepadGamepadButtonGamepadEventGamepadHapticActuatorGamepadPose
Experimental
GeolocationGeolocationCoordinatesGeolocationPositionGeolocationPositionErrorGestureEvent
Non-standard
GPU
Experimental
GPUAdapter
Experimental
GPUAdapterInfo
Experimental
GPUBindGroup
Experimental
GPUBindGroupLayout
Experimental
GPUBuffer
Experimental
GPUCanvasContext
Experimental
GPUCommandBuffer
Experimental
GPUCommandEncoder
Experimental
GPUCompilationInfo
Experimental
GPUCompilationMessage
Experimental
GPUComputePassEncoder
Experimental
GPUComputePipeline
Experimental
GPUDevice
Experimental
GPUDeviceLostInfo
Experimental
GPUError
Experimental
GPUExternalTexture
Experimental
GPUInternalError
Experimental
GPUOutOfMemoryError
Experimental
GPUPipelineError
Experimental
GPUPipelineLayout
Experimental
GPUQuerySet
Experimental
GPUQueue
Experimental
GPURenderBundle
Experimental
GPURenderBundleEncoder
Experimental
GPURenderPassEncoder
Experimental
GPURenderPipeline
Experimental
GPUSampler
Experimental
GPUShaderModule
Experimental
GPUSupportedFeatures
Experimental
GPUSupportedLimits
Experimental
GPUTexture
Experimental
GPUTextureView
Experimental
GPUUncapturedErrorEvent
Experimental
GPUValidationError
Experimental
GravitySensorGyroscopeHHashChangeEventHeadersHID
Experimental
HIDConnectionEvent
Experimental
HIDDevice
Experimental
HIDInputReportEvent
Experimental
HighlightHighlightRegistryHistoryHkdfParamsHmacImportParamsHmacKeyGenParamsHMDVRDevice
Non-standard

Deprecated
HTMLAllCollectionHTMLAnchorElementHTMLAreaElementHTMLAudioElementHTMLBaseElementHTMLBodyElementHTMLBRElementHTMLButtonElementHTMLCanvasElementHTMLCollectionHTMLDataElementHTMLDataListElementHTMLDetailsElementHTMLDialogElementHTMLDivElementHTMLDListElementHTMLDocumentHTMLElementHTMLEmbedElementHTMLFencedFrameElement
Experimental
HTMLFieldSetElementHTMLFontElement
Deprecated
HTMLFormControlsCollectionHTMLFormElementHTMLFrameSetElement
Deprecated
HTMLHeadElementHTMLHeadingElementHTMLHRElementHTMLHtmlElementHTMLIFrameElementHTMLImageElementHTMLInputElementHTMLLabelElementHTMLLegendElementHTMLLIElementHTMLLinkElementHTMLMapElementHTMLMarqueeElement
Deprecated
HTMLMediaElementHTMLMenuElementHTMLMetaElementHTMLMeterElementHTMLModElementHTMLObjectElementHTMLOListElementHTMLOptGroupElementHTMLOptionElementHTMLOptionsCollectionHTMLOutputElementHTMLParagraphElementHTMLParamElement
Deprecated
HTMLPictureElementHTMLPreElementHTMLProgressElementHTMLQuoteElementHTMLScriptElementHTMLSelectedContentElementHTMLSelectElementHTMLSlotElementHTMLSourceElementHTMLSpanElementHTMLStyleElementHTMLTableCaptionElementHTMLTableCellElementHTMLTableColElementHTMLTableElementHTMLTableRowElementHTMLTableSectionElementHTMLTemplateElementHTMLTextAreaElementHTMLTimeElementHTMLTitleElementHTMLTrackElementHTMLUListElementHTMLUnknownElementHTMLVideoElementIIDBCursorIDBCursorWithValueIDBDatabaseIDBFactoryIDBIndexIDBKeyRangeIDBObjectStoreIDBOpenDBRequestIDBRequestIDBTransactionIDBVersionChangeEventIdentityCredential
Experimental
IdentityCredentialRequestOptionsIdentityProvider
Experimental
IdleDeadlineIdleDetector
Experimental
IIRFilterNodeImageBitmapImageBitmapRenderingContextImageCaptureImageDataImageDecoderImageTrackImageTrackListInk
Experimental
InputDeviceCapabilities
Experimental
InputDeviceInfoInputEventInstallEventIntersectionObserverIntersectionObserverEntryInterventionReportBody
Experimental
KKeyboard
Experimental
KeyboardEventKeyboardLayoutMap
Experimental
KeyframeEffectLLargestContentfulPaintLaunchParams
Experimental
LaunchQueue
Experimental
LayoutShift
Experimental
LayoutShiftAttribution
Experimental
LinearAccelerationSensorLocationLockLockManagerMMagnetometer
Experimental
MathMLElementMediaCapabilitiesMediaDeviceInfoMediaDevicesMediaElementAudioSourceNodeMediaEncryptedEventMediaErrorMediaKeyMessageEventMediaKeysMediaKeySessionMediaKeyStatusMapMediaKeySystemAccessMediaListMediaMetadataMediaQueryListMediaQueryListEventMediaRecorderMediaRecorderErrorEvent
Non-standard

Deprecated
MediaSessionMediaSourceMediaSourceHandleMediaStreamMediaStreamAudioDestinationNodeMediaStreamAudioSourceNodeMediaStreamEvent
Non-standard

Deprecated
MediaStreamTrackMediaStreamTrackAudioSourceNodeMediaStreamTrackEventMediaStreamTrackGenerator
Experimental

Non-standard
MediaStreamTrackProcessorMediaTrackConstraintsMediaTrackSettingsMediaTrackSupportedConstraintsMerchantValidationEvent
Deprecated
MessageChannelMessageEventMessagePortMetadata
Experimental

Non-standard
MIDIAccessMIDIConnectionEventMIDIInputMIDIInputMapMIDIMessageEventMIDIOutputMIDIOutputMapMIDIPortMimeType
Deprecated
MimeTypeArray
Deprecated
MouseEventMouseScrollEvent
Non-standard

Deprecated
MutationEvent
Non-standard

Deprecated
MutationObserverMutationRecordNNamedNodeMapNavigateEvent
Experimental
Navigation
Experimental
NavigationActivation
Experimental
NavigationCurrentEntryChangeEvent
Experimental
NavigationDestination
Experimental
NavigationHistoryEntry
Experimental
NavigationPreloadManagerNavigationTransition
Experimental
NavigatorNavigatorLoginNavigatorUAData
Experimental
NDEFMessage
Experimental
NDEFReader
Experimental
NDEFReadingEvent
Experimental
NDEFRecord
Experimental
NetworkInformationNodeNodeIteratorNodeListNotificationNotificationEventNotRestoredReasonDetails
Experimental
NotRestoredReasons
Experimental
OOES_draw_buffers_indexedOfflineAudioCompletionEventOfflineAudioContextOffscreenCanvasOffscreenCanvasRenderingContext2DOrientationSensorOscillatorNodeOTPCredential
Experimental
OverconstrainedErrorPPageRevealEventPageSwapEventPageTransitionEventPaintRenderingContext2DPaintSizePaintWorkletGlobalScope
Experimental
PannerNodePasswordCredential
Experimental
PasswordCredentialInitPath2DPaymentAddress
Non-standard

Deprecated
PaymentManager
Experimental
PaymentMethodChangeEventPaymentRequestPaymentRequestEvent
Experimental
PaymentRequestUpdateEventPaymentResponsePbkdf2ParamsPerformancePerformanceElementTiming
Experimental
PerformanceEntryPerformanceEventTimingPerformanceLongAnimationFrameTiming
Experimental
PerformanceLongTaskTiming
Experimental
PerformanceMarkPerformanceMeasurePerformanceNavigation
Deprecated
PerformanceNavigationTimingPerformanceObserverPerformanceObserverEntryListPerformancePaintTimingPerformanceResourceTimingPerformanceScriptTiming
Experimental
PerformanceServerTimingPerformanceTiming
Deprecated
PeriodicSyncEvent
Experimental
PeriodicSyncManager
Experimental
PeriodicWavePermissionsPermissionStatusPictureInPictureEventPictureInPictureWindowPlugin
Deprecated
PluginArray
Deprecated
Point
Non-standard

Deprecated
PointerEventPopStateEventPositionSensorVRDevice
Non-standard

Deprecated
Presentation
Experimental
PresentationAvailability
Experimental
PresentationConnection
Experimental
PresentationConnectionAvailableEvent
Experimental
PresentationConnectionCloseEvent
Experimental
PresentationConnectionList
Experimental
PresentationReceiver
Experimental
PresentationRequest
Experimental
PressureObserver
Experimental
PressureRecord
Experimental
ProcessingInstructionProfiler
Experimental
ProgressEventPromiseRejectionEventPublicKeyCredentialPublicKeyCredentialCreationOptionsPublicKeyCredentialRequestOptionsPushEventPushManagerPushMessageDataPushSubscriptionPushSubscriptionOptionsRRadioNodeListRangeReadableByteStreamControllerReadableStreamReadableStreamBYOBReaderReadableStreamBYOBRequestReadableStreamDefaultControllerReadableStreamDefaultReaderRelativeOrientationSensorRemotePlaybackReportReportBodyReportingObserverRequestRequestInitResizeObserverResizeObserverEntryResizeObserverSizeResponseRestrictionTarget
Experimental
RsaHashedImportParamsRsaHashedKeyGenParamsRsaOaepParamsRsaPssParamsRTCAudioSourceStatsRTCCertificateRTCCertificateStatsRTCCodecStatsRTCDataChannelRTCDataChannelEventRTCDataChannelStatsRTCDtlsTransportRTCDTMFSenderRTCDTMFToneChangeEventRTCEncodedAudioFrameRTCEncodedVideoFrameRTCErrorRTCErrorEventRTCIceCandidateRTCIceCandidatePairRTCIceCandidatePairStatsRTCIceCandidateStatsRTCIceParametersRTCIceTransportRTCIdentityAssertion
Experimental
RTCInboundRtpStreamStatsRTCOutboundRtpStreamStatsRTCPeerConnectionRTCPeerConnectionIceErrorEventRTCPeerConnectionIceEventRTCPeerConnectionStatsRTCRemoteInboundRtpStreamStatsRTCRemoteOutboundRtpStreamStatsRTCRtpReceiverRTCRtpScriptTransformRTCRtpScriptTransformerRTCRtpSenderRTCRtpTransceiverRTCSctpTransportRTCSessionDescriptionRTCStatsReportRTCTrackEventRTCTransformEventRTCTransportStatsRTCVideoSourceStatsSSchedulerScheduling
Experimental
ScreenScreenDetailed
Experimental
ScreenDetails
Experimental
ScreenOrientationScriptProcessorNode
Deprecated
ScrollTimeline
Experimental
SecurePaymentConfirmationRequestSecurityPolicyViolationEventSelectionSensorSensorErrorEventSerial
Experimental
SerialPort
Experimental
ServiceWorkerServiceWorkerContainerServiceWorkerGlobalScopeServiceWorkerRegistrationShadowRootSharedStorage
Experimental
SharedStorageOperation
Experimental
SharedStorageRunOperation
Experimental
SharedStorageSelectURLOperation
Experimental
SharedStorageWorklet
Experimental
SharedStorageWorkletGlobalScope
Experimental
SharedWorkerSharedWorkerGlobalScopeSnapEvent
Experimental
SourceBufferSourceBufferListSpeechGrammar
Non-standard

Deprecated
SpeechGrammarList
Experimental
SpeechRecognitionSpeechRecognitionAlternativeSpeechRecognitionErrorEventSpeechRecognitionEventSpeechRecognitionResultSpeechRecognitionResultListSpeechSynthesisSpeechSynthesisErrorEventSpeechSynthesisEventSpeechSynthesisUtteranceSpeechSynthesisVoiceStaticRangeStereoPannerNodeStorageStorageAccessHandleStorageEventStorageManagerStylePropertyMapStylePropertyMapReadOnlyStyleSheetStyleSheetListSubmitEventSubtleCryptoSVGAElementSVGAngleSVGAnimateColorElement
Deprecated
SVGAnimatedAngleSVGAnimatedBooleanSVGAnimatedEnumerationSVGAnimatedIntegerSVGAnimatedLengthSVGAnimatedLengthListSVGAnimatedNumberSVGAnimatedNumberListSVGAnimatedPreserveAspectRatioSVGAnimatedRectSVGAnimatedStringSVGAnimatedTransformListSVGAnimateElementSVGAnimateMotionElementSVGAnimateTransformElementSVGAnimationElementSVGCircleElementSVGClipPathElementSVGComponentTransferFunctionElementSVGDefsElementSVGDescElementSVGDiscardElement
Experimental
SVGElementSVGEllipseElementSVGFEBlendElementSVGFEColorMatrixElementSVGFEComponentTransferElementSVGFECompositeElementSVGFEConvolveMatrixElementSVGFEDiffuseLightingElementSVGFEDisplacementMapElementSVGFEDistantLightElementSVGFEDropShadowElementSVGFEFloodElementSVGFEFuncAElementSVGFEFuncBElementSVGFEFuncGElementSVGFEFuncRElementSVGFEGaussianBlurElementSVGFEImageElementSVGFEMergeElementSVGFEMergeNodeElementSVGFEMorphologyElementSVGFEOffsetElementSVGFEPointLightElementSVGFESpecularLightingElementSVGFESpotLightElementSVGFETileElementSVGFETurbulenceElementSVGFilterElementSVGForeignObjectElementSVGGElementSVGGeometryElementSVGGradientElementSVGGraphicsElementSVGImageElementSVGLengthSVGLengthListSVGLinearGradientElementSVGLineElementSVGMarkerElementSVGMaskElementSVGMetadataElementSVGMPathElementSVGNumberSVGNumberListSVGPathElementSVGPatternElementSVGPoint
Deprecated
SVGPointListSVGPolygonElementSVGPolylineElementSVGPreserveAspectRatioSVGRadialGradientElementSVGRectSVGRectElementSVGRenderingIntent
Deprecated
SVGScriptElementSVGSetElementSVGStopElementSVGStringListSVGStyleElementSVGSVGElementSVGSwitchElementSVGSymbolElementSVGTextContentElementSVGTextElementSVGTextPathElementSVGTextPositioningElementSVGTitleElementSVGTransformSVGTransformListSVGTSpanElementSVGUnitTypesSVGUseElementSVGViewElementSyncEventSyncManagerTTaskAttributionTiming
Experimental
TaskControllerTaskPriorityChangeEventTaskSignalTextTextDecoderTextDecoderStreamTextEncoderTextEncoderStreamTextEvent
Deprecated
TextFormat
Experimental
TextFormatUpdateEvent
Experimental
TextMetricsTextTrackTextTrackCueTextTrackCueListTextTrackListTextUpdateEvent
Experimental
TimeEventTimeRangesToggleEventTouchTouchEventTouchListTrackEventTransformStreamTransformStreamDefaultControllerTransitionEventTreeWalkerTrustedHTMLTrustedScriptTrustedScriptURLTrustedTypePolicyTrustedTypePolicyFactoryUUIEventURLURLPattern
Experimental
URLSearchParamsUSB
Experimental
USBAlternateInterface
Experimental
USBConfiguration
Experimental
USBConnectionEvent
Experimental
USBDevice
Experimental
USBEndpoint
Experimental
USBInterface
Experimental
USBInTransferResult
Experimental
USBIsochronousInTransferPacket
Experimental
USBIsochronousInTransferResult
Experimental
USBIsochronousOutTransferPacket
Experimental
USBIsochronousOutTransferResult
Experimental
USBOutTransferResult
Experimental
UserActivationVValidityStateVideoColorSpaceVideoDecoderVideoEncoderVideoFrameVideoPlaybackQualityVideoTrackVideoTrackListViewTimeline
Experimental
ViewTransitionVirtualKeyboard
Experimental
VisibilityStateEntry
Experimental
VisualViewportVRDisplay
Non-standard

Deprecated
VRDisplayCapabilities
Non-standard

Deprecated
VRDisplayEvent
Non-standard

Deprecated
VREyeParameters
Non-standard

Deprecated
VRFieldOfView
Non-standard

Deprecated
VRFrameData
Non-standard

Deprecated
VRLayerInit
Deprecated
VRPose
Non-standard

Deprecated
VRStageParameters
Non-standard

Deprecated
VTTCueVTTRegionWWakeLockWakeLockSentinelWaveShaperNodeWebGL2RenderingContextWebGLActiveInfoWebGLBufferWebGLContextEventWebGLFramebufferWebGLObject
Experimental
WebGLProgramWebGLQueryWebGLRenderbufferWebGLRenderingContextWebGLSamplerWebGLShaderWebGLShaderPrecisionFormatWebGLSyncWebGLTextureWebGLTransformFeedbackWebGLUniformLocationWebGLVertexArrayObjectWebSocketWebSocketStream
Experimental
WebTransportWebTransportBidirectionalStreamWebTransportDatagramDuplexStreamWebTransportErrorWebTransportReceiveStream
Experimental
WebTransportSendStream
Experimental
WGSLLanguageFeatures
Experimental
WheelEventWindowWindowClientWindowControlsOverlay
Experimental
WindowControlsOverlayGeometryChangeEvent
Experimental
WindowSharedStorage
Experimental
WorkerWorkerGlobalScopeWorkerLocationWorkerNavigatorWorkletWorkletGlobalScopeWorkletSharedStorage
Experimental
WritableStreamWritableStreamDefaultControllerWritableStreamDefaultWriterXXMLDocumentXMLHttpRequestXMLHttpRequestEventTargetXMLHttpRequestUploadXMLSerializerXPathEvaluatorXPathExpressionXPathResultXRAnchor
Experimental
XRAnchorSet
Experimental
XRBoundedReferenceSpace
Experimental
XRCompositionLayer
Experimental
XRCPUDepthInformation
Experimental
XRCubeLayer
Experimental
XRCylinderLayer
Experimental
XRDepthInformation
Experimental
XREquirectLayer
Experimental
XRFrame
Experimental
XRHandXRHitTestResult
Experimental
XRHitTestSource
Experimental
XRInputSourceXRInputSourceArray
Experimental
XRInputSourceEventXRInputSourcesChangeEventXRJointPoseXRJointSpaceXRLayer
Experimental
XRLayerEvent
Experimental
XRLightEstimate
Experimental
XRLightProbe
Experimental
XRMediaBinding
Experimental
XRPoseXRProjectionLayer
Experimental
XRQuadLayer
Experimental
XRRay
Experimental
XRReferenceSpaceXRReferenceSpaceEventXRRenderState
Experimental
XRRigidTransformXRSession
Experimental
XRSessionEventXRSpaceXRSubImage
Experimental
XRSystem
Experimental
XRTransientInputHitTestResult
Experimental
XRTransientInputHitTestSource
Experimental
XRView
Experimental
XRViewerPoseXRViewportXRWebGLBinding
Experimental
XRWebGLDepthInformation
Experimental
XRWebGLLayer
Experimental
XRWebGLSubImage
Experimental
XSLTProcessorSee also
Web API event reference
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 20, 2023 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nBrowser extensionsExtensions, or add-ons, can modify and enhance the capability of a browser. Extensions for Firefox are built using the WebExtensions API cross-browser technology.
The technology for extensions in Firefox is, to a large extent, compatible with the extension API supported by Chromium-based browsers (such as Google Chrome, Microsoft Edge, Opera, Vivaldi). In most cases, extensions written for Chromium-based browsers run in Firefox with just a few changes.Key resources
Guides

Whether you're just beginning or looking for more advanced advice, learn about how extensions work and use the WebExtensions API from our extensive range of tutorials and guides.

References

Get comprehensive details about the methods, properties, types, and events of the WebExtensions APIs and full details about the manifest keys.

Firefox workflow

Discover how to build and publish extensions for Firefox: get the lowdown on developer tools, publication and distribution, and porting on Extension Workshop.



Note:
If you have ideas or questions or need help, you can reach us on the community forum or in the Add-ons Room on Matrix.
Get startedDiscover what extensions can do before building your first extension. Learn about the anatomy of an extension and get an overview of the extension development and publication workflow, Firefox style. Explore a little deeper with a comprehensive selection of example extensions that you can run right in Firefox.ConceptsGet detailed information on the concept that underpin extensions from an overview of the JavaScript API, through content scripts, match patterns, working with files, internationalization, and content security policy, to more advanced subjects such as native messaging, using the devtools APIs, and native manifests.User interfaceDiscover all the user interface components you can use in your extensions, with coding examples and tips.How toFrom patterns you'll regularly use such as work with the Tabs API and adding a button to the toolbar to more advanced topics such as intercepting HTTP requests and working with contextual identities, you'll find a range of tutorials to get you started.Firefox workflowWhen you are ready to create your extension for Firefox or port your Chrome extension, head over to Extension Workshop. It has details on:

The Firefox workflow, such as temporarily installing extensions during development, debugging, request the right permissions, and more.
The web-ext developer tool.
Porting a Google Chrome extension, differences between desktop and Android, and more.
Publishing and distribution overview, promoting your extension, the extension lifecycle best practices, and more.
ReferenceJavaScript APIsGet comprehensive details about the methods, properties, types, and events for all the JavaScript APIs. There is also detailed information about the compatibility of each API with the major browsers. Most reference pages also include coding examples and links to the extension examples that use the API.Manifest keysGet full details about the manifest keys, including all their properties and settings.\n\nBrowser extensionsExtensions, or add-ons, can modify and enhance the capability of a browser. Extensions for Firefox are built using the WebExtensions API cross-browser technology.
The technology for extensions in Firefox is, to a large extent, compatible with the extension API supported by Chromium-based browsers (such as Google Chrome, Microsoft Edge, Opera, Vivaldi). In most cases, extensions written for Chromium-based browsers run in Firefox with just a few changes.Key resources
Guides

Whether you're just beginning or looking for more advanced advice, learn about how extensions work and use the WebExtensions API from our extensive range of tutorials and guides.

References

Get comprehensive details about the methods, properties, types, and events of the WebExtensions APIs and full details about the manifest keys.

Firefox workflow

Discover how to build and publish extensions for Firefox: get the lowdown on developer tools, publication and distribution, and porting on Extension Workshop.



Note:
If you have ideas or questions or need help, you can reach us on the community forum or in the Add-ons Room on Matrix.
Get startedDiscover what extensions can do before building your first extension. Learn about the anatomy of an extension and get an overview of the extension development and publication workflow, Firefox style. Explore a little deeper with a comprehensive selection of example extensions that you can run right in Firefox.ConceptsGet detailed information on the concept that underpin extensions from an overview of the JavaScript API, through content scripts, match patterns, working with files, internationalization, and content security policy, to more advanced subjects such as native messaging, using the devtools APIs, and native manifests.User interfaceDiscover all the user interface components you can use in your extensions, with coding examples and tips.How toFrom patterns you'll regularly use such as work with the Tabs API and adding a button to the toolbar to more advanced topics such as intercepting HTTP requests and working with contextual identities, you'll find a range of tutorials to get you started.Firefox workflowWhen you are ready to create your extension for Firefox or port your Chrome extension, head over to Extension Workshop. It has details on:

The Firefox workflow, such as temporarily installing extensions during development, debugging, request the right permissions, and more.
The web-ext developer tool.
Porting a Google Chrome extension, differences between desktop and Android, and more.
Publishing and distribution overview, promoting your extension, the extension lifecycle best practices, and more.
ReferenceJavaScript APIsGet comprehensive details about the methods, properties, types, and events for all the JavaScript APIs. There is also detailed information about the compatibility of each API with the major browsers. Most reference pages also include coding examples and links to the extension examples that use the API.Manifest keysGet full details about the manifest keys, including all their properties and settings.Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 22, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nBrowser extensionsExtensions, or add-ons, can modify and enhance the capability of a browser. Extensions for Firefox are built using the WebExtensions API cross-browser technology.
The technology for extensions in Firefox is, to a large extent, compatible with the extension API supported by Chromium-based browsers (such as Google Chrome, Microsoft Edge, Opera, Vivaldi). In most cases, extensions written for Chromium-based browsers run in Firefox with just a few changes.Key resources
Guides

Whether you're just beginning or looking for more advanced advice, learn about how extensions work and use the WebExtensions API from our extensive range of tutorials and guides.

References

Get comprehensive details about the methods, properties, types, and events of the WebExtensions APIs and full details about the manifest keys.

Firefox workflow

Discover how to build and publish extensions for Firefox: get the lowdown on developer tools, publication and distribution, and porting on Extension Workshop.



Note:
If you have ideas or questions or need help, you can reach us on the community forum or in the Add-ons Room on Matrix.
Get startedDiscover what extensions can do before building your first extension. Learn about the anatomy of an extension and get an overview of the extension development and publication workflow, Firefox style. Explore a little deeper with a comprehensive selection of example extensions that you can run right in Firefox.ConceptsGet detailed information on the concept that underpin extensions from an overview of the JavaScript API, through content scripts, match patterns, working with files, internationalization, and content security policy, to more advanced subjects such as native messaging, using the devtools APIs, and native manifests.User interfaceDiscover all the user interface components you can use in your extensions, with coding examples and tips.How toFrom patterns you'll regularly use such as work with the Tabs API and adding a button to the toolbar to more advanced topics such as intercepting HTTP requests and working with contextual identities, you'll find a range of tutorials to get you started.Firefox workflowWhen you are ready to create your extension for Firefox or port your Chrome extension, head over to Extension Workshop. It has details on:

The Firefox workflow, such as temporarily installing extensions during development, debugging, request the right permissions, and more.
The web-ext developer tool.
Porting a Google Chrome extension, differences between desktop and Android, and more.
Publishing and distribution overview, promoting your extension, the extension lifecycle best practices, and more.
ReferenceJavaScript APIsGet comprehensive details about the methods, properties, types, and events for all the JavaScript APIs. There is also detailed information about the compatibility of each API with the major browsers. Most reference pages also include coding examples and links to the extension examples that use the API.Manifest keysGet full details about the manifest keys, including all their properties and settings.Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 22, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nAccessibilityAccessibility (often abbreviated to A11y — as in, "a", then 11 characters, and then "y") in web development means enabling as many people as possible to use websites, even when those people's abilities are limited in some way.
For many people, technology makes things easier. For people with disabilities, technology makes things possible. Accessibility means developing content to be as accessible as possible, no matter an individual's physical and cognitive abilities and how they access the web.

The Web is fundamentally designed to work for all people, whatever their hardware, software, language, location, or ability.
When the Web meets this goal, it is accessible to people with a diverse range of hearing, movement, sight, and cognitive ability. 
– (W3C - Accessibility)
Accessibility guides
Accessibility information for web authors

This document lists guidelines and regulations, how-to's, and tools for checking and repairing accessibility problems with websites.

Personalization to help browse safely

This article discusses making web content accessible for those with vestibular disorders, and those who support them, by taking advantage of personalization and accessibility settings built into the operating systems.

Accessible web applications and widgets

Most JavaScript libraries offer a library of client-side widgets that mimic the behavior of familiar desktop interfaces.
While this results in a widget that looks like its desktop counterpart, there usually isn't enough semantic information in the markup to be usable by an assistive technology.
This document describes techniques to improve accessibility of such widgets.

Keyboard-navigable JavaScript widgets

Until now, web developers who wanted to make their styled <div> and <span> based widgets accessible have lacked proper techniques.
Keyboard accessibility is part of the minimum accessibility requirements, which a developer should be aware of.
This document describes techniques to make JavaScript widgets accessible with the keyboard.

Mobile accessibility checklist

This document provides a concise checklist of accessibility requirements for mobile app developers.

Understanding the Web Content Accessibility Guidelines (WCAG)

A set of articles that provide quick explanations to help you understand the steps that need to be taken to conform to the recommendations outlined in the Web Content Accessibility Guidelines (WCAG).

Cognitive accessibility

Cognitive accessibility covers accessibility considerations for people with cognition and learning disabilities.
This document introduces cognitive accessibility and improving accessibility of the web for people with cognitive and learning differences.

Accessibility and spatial patterns

This document describes visual patterns that can induce physical symptoms in people who have photosensitive epilepsy, vestibular disorders, or other perceptual issues.

Web Accessibility: Understanding Colors and Luminance

While understanding color, luminance, and saturation is important for design and readability for all sighted users, they are essential for those with reduced vision and color-deficient vision and those with specific neurological, cognitive, and other impairments.

Web accessibility for seizures and physical reactions

Some types of visual web content can induce seizures in people with certain brain disorders.
This article helps you understand the types of content that can be problematic and find tools and strategies to help you avoid them.

ARIA

This is a collection of articles to learn how to use Accessible Rich Internet Applications (ARIA) to make your HTML documents more accessible.

Tutorials for beginnersThe MDN Accessibility Learning Area contains modern, up-to-date tutorials covering the following accessibility essentials:

What is accessibility?

This article starts off the module with a good look at what accessibility actually is — this includes what groups of people we need to consider and why, what tools different people use to interact with the Web, and how we can make accessibility part of our web development workflow.

HTML: A good basis for accessibility

A great deal of web content can be made accessible just by making sure that the correct HTML elements are used for the correct purpose at all times. This article looks in detail at how HTML can be used to ensure maximum accessibility.

CSS and JavaScript accessibility best practices

CSS and JavaScript, when used properly, also have the potential to allow for accessible web experiences. They can significantly harm accessibility if misused. This article outlines some CSS and JavaScript best practices that should be considered to ensure that even complex content is as accessible as possible.

WAI-ARIA basics

Following on from the previous article, sometimes making complex UI controls that involve unsemantic HTML and dynamic JavaScript-updated content can be difficult. WAI-ARIA is a technology that can help with such problems by adding in further semantics that browsers and assistive technologies can recognize and let users know what is going on. Here we'll show how to use it at a basic level to improve accessibility.

Accessible multimedia

Another category of content that can create accessibility problems is multimedia — video, audio, and image content need to be given proper textual alternatives so that they can be understood by assistive technologies and their users. This article shows how.

Mobile accessibility

With web access on mobile devices being so popular and popular platforms such as iOS and Android having fully-fledged accessibility tools, it is important to consider the accessibility of your web content on these platforms. This article looks at mobile-specific accessibility considerations.

References
ARIA reference

Reference documentation for Accessible Rich Internet Applications (ARIA) attributes and roles.

See also
Developer guides
WAI Interest Group\n\nAccessibilityAccessibility (often abbreviated to A11y — as in, "a", then 11 characters, and then "y") in web development means enabling as many people as possible to use websites, even when those people's abilities are limited in some way.
For many people, technology makes things easier. For people with disabilities, technology makes things possible. Accessibility means developing content to be as accessible as possible, no matter an individual's physical and cognitive abilities and how they access the web.

The Web is fundamentally designed to work for all people, whatever their hardware, software, language, location, or ability.
When the Web meets this goal, it is accessible to people with a diverse range of hearing, movement, sight, and cognitive ability. 
– (W3C - Accessibility)
Accessibility guides
Accessibility information for web authors

This document lists guidelines and regulations, how-to's, and tools for checking and repairing accessibility problems with websites.

Personalization to help browse safely

This article discusses making web content accessible for those with vestibular disorders, and those who support them, by taking advantage of personalization and accessibility settings built into the operating systems.

Accessible web applications and widgets

Most JavaScript libraries offer a library of client-side widgets that mimic the behavior of familiar desktop interfaces.
While this results in a widget that looks like its desktop counterpart, there usually isn't enough semantic information in the markup to be usable by an assistive technology.
This document describes techniques to improve accessibility of such widgets.

Keyboard-navigable JavaScript widgets

Until now, web developers who wanted to make their styled <div> and <span> based widgets accessible have lacked proper techniques.
Keyboard accessibility is part of the minimum accessibility requirements, which a developer should be aware of.
This document describes techniques to make JavaScript widgets accessible with the keyboard.

Mobile accessibility checklist

This document provides a concise checklist of accessibility requirements for mobile app developers.

Understanding the Web Content Accessibility Guidelines (WCAG)

A set of articles that provide quick explanations to help you understand the steps that need to be taken to conform to the recommendations outlined in the Web Content Accessibility Guidelines (WCAG).

Cognitive accessibility

Cognitive accessibility covers accessibility considerations for people with cognition and learning disabilities.
This document introduces cognitive accessibility and improving accessibility of the web for people with cognitive and learning differences.

Accessibility and spatial patterns

This document describes visual patterns that can induce physical symptoms in people who have photosensitive epilepsy, vestibular disorders, or other perceptual issues.

Web Accessibility: Understanding Colors and Luminance

While understanding color, luminance, and saturation is important for design and readability for all sighted users, they are essential for those with reduced vision and color-deficient vision and those with specific neurological, cognitive, and other impairments.

Web accessibility for seizures and physical reactions

Some types of visual web content can induce seizures in people with certain brain disorders.
This article helps you understand the types of content that can be problematic and find tools and strategies to help you avoid them.

ARIA

This is a collection of articles to learn how to use Accessible Rich Internet Applications (ARIA) to make your HTML documents more accessible.

Tutorials for beginnersThe MDN Accessibility Learning Area contains modern, up-to-date tutorials covering the following accessibility essentials:

What is accessibility?

This article starts off the module with a good look at what accessibility actually is — this includes what groups of people we need to consider and why, what tools different people use to interact with the Web, and how we can make accessibility part of our web development workflow.

HTML: A good basis for accessibility

A great deal of web content can be made accessible just by making sure that the correct HTML elements are used for the correct purpose at all times. This article looks in detail at how HTML can be used to ensure maximum accessibility.

CSS and JavaScript accessibility best practices

CSS and JavaScript, when used properly, also have the potential to allow for accessible web experiences. They can significantly harm accessibility if misused. This article outlines some CSS and JavaScript best practices that should be considered to ensure that even complex content is as accessible as possible.

WAI-ARIA basics

Following on from the previous article, sometimes making complex UI controls that involve unsemantic HTML and dynamic JavaScript-updated content can be difficult. WAI-ARIA is a technology that can help with such problems by adding in further semantics that browsers and assistive technologies can recognize and let users know what is going on. Here we'll show how to use it at a basic level to improve accessibility.

Accessible multimedia

Another category of content that can create accessibility problems is multimedia — video, audio, and image content need to be given proper textual alternatives so that they can be understood by assistive technologies and their users. This article shows how.

Mobile accessibility

With web access on mobile devices being so popular and popular platforms such as iOS and Android having fully-fledged accessibility tools, it is important to consider the accessibility of your web content on these platforms. This article looks at mobile-specific accessibility considerations.

References
ARIA reference

Reference documentation for Accessible Rich Internet Applications (ARIA) attributes and roles.

See also
Developer guides
WAI Interest Group
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nAccessibilityAccessibility (often abbreviated to A11y — as in, "a", then 11 characters, and then "y") in web development means enabling as many people as possible to use websites, even when those people's abilities are limited in some way.
For many people, technology makes things easier. For people with disabilities, technology makes things possible. Accessibility means developing content to be as accessible as possible, no matter an individual's physical and cognitive abilities and how they access the web.

The Web is fundamentally designed to work for all people, whatever their hardware, software, language, location, or ability.
When the Web meets this goal, it is accessible to people with a diverse range of hearing, movement, sight, and cognitive ability. 
– (W3C - Accessibility)
Accessibility guides
Accessibility information for web authors

This document lists guidelines and regulations, how-to's, and tools for checking and repairing accessibility problems with websites.

Personalization to help browse safely

This article discusses making web content accessible for those with vestibular disorders, and those who support them, by taking advantage of personalization and accessibility settings built into the operating systems.

Accessible web applications and widgets

Most JavaScript libraries offer a library of client-side widgets that mimic the behavior of familiar desktop interfaces.
While this results in a widget that looks like its desktop counterpart, there usually isn't enough semantic information in the markup to be usable by an assistive technology.
This document describes techniques to improve accessibility of such widgets.

Keyboard-navigable JavaScript widgets

Until now, web developers who wanted to make their styled <div> and <span> based widgets accessible have lacked proper techniques.
Keyboard accessibility is part of the minimum accessibility requirements, which a developer should be aware of.
This document describes techniques to make JavaScript widgets accessible with the keyboard.

Mobile accessibility checklist

This document provides a concise checklist of accessibility requirements for mobile app developers.

Understanding the Web Content Accessibility Guidelines (WCAG)

A set of articles that provide quick explanations to help you understand the steps that need to be taken to conform to the recommendations outlined in the Web Content Accessibility Guidelines (WCAG).

Cognitive accessibility

Cognitive accessibility covers accessibility considerations for people with cognition and learning disabilities.
This document introduces cognitive accessibility and improving accessibility of the web for people with cognitive and learning differences.

Accessibility and spatial patterns

This document describes visual patterns that can induce physical symptoms in people who have photosensitive epilepsy, vestibular disorders, or other perceptual issues.

Web Accessibility: Understanding Colors and Luminance

While understanding color, luminance, and saturation is important for design and readability for all sighted users, they are essential for those with reduced vision and color-deficient vision and those with specific neurological, cognitive, and other impairments.

Web accessibility for seizures and physical reactions

Some types of visual web content can induce seizures in people with certain brain disorders.
This article helps you understand the types of content that can be problematic and find tools and strategies to help you avoid them.

ARIA

This is a collection of articles to learn how to use Accessible Rich Internet Applications (ARIA) to make your HTML documents more accessible.

Tutorials for beginnersThe MDN Accessibility Learning Area contains modern, up-to-date tutorials covering the following accessibility essentials:

What is accessibility?

This article starts off the module with a good look at what accessibility actually is — this includes what groups of people we need to consider and why, what tools different people use to interact with the Web, and how we can make accessibility part of our web development workflow.

HTML: A good basis for accessibility

A great deal of web content can be made accessible just by making sure that the correct HTML elements are used for the correct purpose at all times. This article looks in detail at how HTML can be used to ensure maximum accessibility.

CSS and JavaScript accessibility best practices

CSS and JavaScript, when used properly, also have the potential to allow for accessible web experiences. They can significantly harm accessibility if misused. This article outlines some CSS and JavaScript best practices that should be considered to ensure that even complex content is as accessible as possible.

WAI-ARIA basics

Following on from the previous article, sometimes making complex UI controls that involve unsemantic HTML and dynamic JavaScript-updated content can be difficult. WAI-ARIA is a technology that can help with such problems by adding in further semantics that browsers and assistive technologies can recognize and let users know what is going on. Here we'll show how to use it at a basic level to improve accessibility.

Accessible multimedia

Another category of content that can create accessibility problems is multimedia — video, audio, and image content need to be given proper textual alternatives so that they can be understood by assistive technologies and their users. This article shows how.

Mobile accessibility

With web access on mobile devices being so popular and popular platforms such as iOS and Android having fully-fledged accessibility tools, it is important to consider the accessibility of your web content on these platforms. This article looks at mobile-specific accessibility considerations.

References
ARIA reference

Reference documentation for Accessible Rich Internet Applications (ARIA) attributes and roles.

See also
Developer guides
WAI Interest Group
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nLearn web developmentThe essential skillset for new front-end developersWelcome to MDN Learning Web Development (also known as Learn). This resource provides a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer, along with challenges and further recommended resources.About Learn web development

Teaches the essential skills and knowledge every front-end developer needs for career success and industry relevance, as defined in the MDN Curriculum.


Created by the MDN community and refined with insights from students, educators, and developers from the broader web community.


Designed to take you from "beginner" to "comfortable" (not "beginner" to "expert"), giving you enough knowledge to use more advanced resources (such as the rest of MDN).



Note:
Last updated: December 2024 (see changelog).
Don't know where to get started?
Never coded before?

Our Getting started modules provide setup tutorials and essential concepts and background information for complete beginners. You should start here if you are a complete beginner (i.e., you've not installed a code editor or written any code yet).

Want to master the essentials?

Our Core modules provide a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer.

Beyond the basics?

Our Extension modules cover useful additional skills to learn as you start to expand your knowledge and develop specialisms. Go onto these after you finish our Core.

Working at a school?

Use our modules to guide your teaching, check out our Educators page for more ideas, or enroll your students in Scrimba's Frontend Developer Career PathMDN learning partner.

Getting our code examplesThe code examples you'll encounter in the Learning Area are all available on GitHub:

The easiest way to get them is to download a ZIP of the latest main code branch.
If you are familiar with Git and GitHub, you could also choose to clone the repository.
Contact usIf you want to get in touch with us about anything, use the communication channels. We'd love to hear from you about anything you think is wrong or missing on the site, requests for new learning topics, requests for help with items you don't understand, or any other questions or concerns.
If you're interested in helping develop/improve the content, take a look at how you can help and get in touch! We are more than happy to talk to you, whether you are a learner, teacher, experienced web developer, or someone else interested in helping to improve the learning experience.See also
The Frontend Developer Career Path MDN learning partner

Scrimba's Frontend Developer Career Path teaches all you need to know to be a competent front-end web developer, with fun interactive lessons and challenges, knowledgeable teachers, and a supportive community. Go from zero to landing your first front-end job! Many of the course components are available as standalone free versions.

Codecademy

A great interactive site for learning programming languages from scratch.

freeCodeCamp.org

Interactive site with tutorials and projects to learn web development.

Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.\n\nLearn web developmentThe essential skillset for new front-end developersWelcome to MDN Learning Web Development (also known as Learn). This resource provides a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer, along with challenges and further recommended resources.About Learn web development

Teaches the essential skills and knowledge every front-end developer needs for career success and industry relevance, as defined in the MDN Curriculum.


Created by the MDN community and refined with insights from students, educators, and developers from the broader web community.


Designed to take you from "beginner" to "comfortable" (not "beginner" to "expert"), giving you enough knowledge to use more advanced resources (such as the rest of MDN).



Note:
Last updated: December 2024 (see changelog).
Don't know where to get started?
Never coded before?

Our Getting started modules provide setup tutorials and essential concepts and background information for complete beginners. You should start here if you are a complete beginner (i.e., you've not installed a code editor or written any code yet).

Want to master the essentials?

Our Core modules provide a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer.

Beyond the basics?

Our Extension modules cover useful additional skills to learn as you start to expand your knowledge and develop specialisms. Go onto these after you finish our Core.

Working at a school?

Use our modules to guide your teaching, check out our Educators page for more ideas, or enroll your students in Scrimba's Frontend Developer Career PathMDN learning partner.

Getting our code examplesThe code examples you'll encounter in the Learning Area are all available on GitHub:

The easiest way to get them is to download a ZIP of the latest main code branch.
If you are familiar with Git and GitHub, you could also choose to clone the repository.
Contact usIf you want to get in touch with us about anything, use the communication channels. We'd love to hear from you about anything you think is wrong or missing on the site, requests for new learning topics, requests for help with items you don't understand, or any other questions or concerns.
If you're interested in helping develop/improve the content, take a look at how you can help and get in touch! We are more than happy to talk to you, whether you are a learner, teacher, experienced web developer, or someone else interested in helping to improve the learning experience.See also
The Frontend Developer Career Path MDN learning partner

Scrimba's Frontend Developer Career Path teaches all you need to know to be a competent front-end web developer, with fun interactive lessons and challenges, knowledgeable teachers, and a supportive community. Go from zero to landing your first front-end job! Many of the course components are available as standalone free versions.

Codecademy

A great interactive site for learning programming languages from scratch.

freeCodeCamp.org

Interactive site with tutorials and projects to learn web development.

Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 15, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nLearn web developmentThe essential skillset for new front-end developersWelcome to MDN Learning Web Development (also known as Learn). This resource provides a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer, along with challenges and further recommended resources.About Learn web development

Teaches the essential skills and knowledge every front-end developer needs for career success and industry relevance, as defined in the MDN Curriculum.


Created by the MDN community and refined with insights from students, educators, and developers from the broader web community.


Designed to take you from "beginner" to "comfortable" (not "beginner" to "expert"), giving you enough knowledge to use more advanced resources (such as the rest of MDN).



Note:
Last updated: December 2024 (see changelog).
Don't know where to get started?
Never coded before?

Our Getting started modules provide setup tutorials and essential concepts and background information for complete beginners. You should start here if you are a complete beginner (i.e., you've not installed a code editor or written any code yet).

Want to master the essentials?

Our Core modules provide a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer.

Beyond the basics?

Our Extension modules cover useful additional skills to learn as you start to expand your knowledge and develop specialisms. Go onto these after you finish our Core.

Working at a school?

Use our modules to guide your teaching, check out our Educators page for more ideas, or enroll your students in Scrimba's Frontend Developer Career PathMDN learning partner.

Getting our code examplesThe code examples you'll encounter in the Learning Area are all available on GitHub:

The easiest way to get them is to download a ZIP of the latest main code branch.
If you are familiar with Git and GitHub, you could also choose to clone the repository.
Contact usIf you want to get in touch with us about anything, use the communication channels. We'd love to hear from you about anything you think is wrong or missing on the site, requests for new learning topics, requests for help with items you don't understand, or any other questions or concerns.
If you're interested in helping develop/improve the content, take a look at how you can help and get in touch! We are more than happy to talk to you, whether you are a learner, teacher, experienced web developer, or someone else interested in helping to improve the learning experience.See also
The Frontend Developer Career Path MDN learning partner

Scrimba's Frontend Developer Career Path teaches all you need to know to be a competent front-end web developer, with fun interactive lessons and challenges, knowledgeable teachers, and a supportive community. Go from zero to landing your first front-end job! Many of the course components are available as standalone free versions.

Codecademy

A great interactive site for learning programming languages from scratch.

freeCodeCamp.org

Interactive site with tutorials and projects to learn web development.

Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 15, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nStructuring content with HTML Overview: Core learning modules Next  
HTML is the technology that defines the content and structure of any website. Written properly, it should also define the semantics (meaning) of the content in a machine-readable way, which is vital for accessibility, search engine optimization, and making use of the built-in features browsers provide for content to work optimally. This module covers the basics of the language, before looking at key areas such as document structure, links, lists, images, forms, and more.PrerequisitesBefore starting this module, you don't need any previous HTML knowledge, but you should have at least basic familiarity with using computers and using the web passively (i.e., just looking at it and consuming content). You should have a basic work environment set up (as detailed in Installing basic software), and understand how to create and manage files (as detailed in Dealing with files). Both are parts of our Getting started with the web complete beginner's module.

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
Basic HTML syntax

Covers the absolute basics of HTML, to get you started — we define elements, attributes, and other important terms, and show where they fit in the language. We also show how a typical HTML page is structured and how an HTML element is structured, and explain other important basic language features. Along the way, we'll play with some HTML to get you interested!

What's in the head? Web page metadata

The head of an HTML document is the part that is not displayed in the web browser when the page is loaded. It contains metadata information such as the page <title>, links to CSS (if you want to style your HTML content with CSS), links to custom favicons, and metadata (data about the HTML, such as who wrote it, and important keywords that describe the document).

Headings and paragraphs

One of HTML's main jobs is to give text structure so that a browser can display an HTML document the way its developer intends. This article explains how HTML can be used to provide fundamental page structure by defining headings and paragraphs.

Emphasis and importance

The previous article looked at why semantics are important in HTML, and focused on headings and paragraphs. This article continues on the theme of semantics, looking at HTML elements that apply emphasis and importance to text (parallel to italics and bold text in print media).

Lists

Lists are everywhere in life—from your shopping list to the list of directions you subconsciously follow to get to your house every day, to the lists of instructions you are following in these tutorials! It may not surprise you that HTML has a convenient set of elements that allows us to define different types of list. On the web, we have three types of lists: unordered, ordered, and description lists. This lesson shows you how to use the different types.

Structuring documents

In addition to defining individual parts of your page (such as "a paragraph" or "an image"), HTML also boasts a number of block level elements used to define areas of your website (such as "the header", "the navigation menu", "the main content column"). This article looks into how to plan a basic website structure, and write the HTML to represent this structure.

Advanced text features

There are many other elements in HTML for defining text semantics, which we didn't get to in the Emphasis and importance article. The elements described in this article are less known, but still useful to know about (and this is still not a complete list by any means). Here you'll learn about marking up quotations, computer code and other related text, subscript and superscript, contact information, and more.

Creating links

Links (also known as hyperlinks) are really important — they are what makes the Web a web. This article shows the syntax required to make a link, and discusses link best practices.

Marking up a letter Challenge

We all learn to write a letter sooner or later; it is also a useful example to test our text formatting skills. In this challenge, you'll have a letter to mark up as a test for your HTML text formatting skills, as well as hyperlinks and proper use of the HTML <head> element.

Structuring a page of content Challenge

Structuring a page of content ready for laying it out using CSS is a very important skill to master, so in this challenge you'll be tested on your ability to think about how a page might end up looking, and choose appropriate structural semantics to build a layout on top of.

HTML images

In the beginning, the web was just text, and it was really quite boring. Fortunately, it wasn't too long before the ability to embed images (and other more interesting types of content) inside web pages was added. In this article we'll look at how to use the <img> element in depth, including the basics, annotating it with captions using <figure>, and detailing how it relates to CSS background images.

HTML video and audio

Now that we are comfortable with adding simple images to a webpage, the next step is to start adding video and audio players to your HTML documents! In this article we'll look at doing just that with the <video> and <audio> elements; we'll then finish off by looking at how to add captions/subtitles to your videos.

Mozilla splash page Challenge

In this challenge, we'll test your knowledge of some of the techniques discussed in the last couple of lessons, getting you to add some images and video to a funky splash page all about Mozilla!

HTML table basics

This article gets you started with HTML tables, covering the very basics such as rows, cells, headings, making cells span multiple columns and rows, and how to group together all the cells in a column for styling purposes.

HTML table accessibility

In this article we look at more HTML table accessibility features such as captions/summaries, grouping your rows into table head, body and footer sections, and scoping columns and rows.

Structuring a planet data table Challenge

In this challenge, we provide you with some data on the planets in our solar system. Your job is to structure it into an accessible HTML table.

Forms and buttons in HTML

HTML forms and buttons are powerful tools for interacting with users — most commonly they are used for collecting data from users or allowing them to control a user interface. In this article we provide an introduction to the basics of forms and buttons.

Debugging HTML

Writing HTML is fine, but what if something goes wrong, and you can't work out where the error in the code is? This article will introduce you to some tools that can help you find and fix errors in HTML.

Test your skills: HTML

This page lists HTML tests you can try so you can verify if you've understood the content in this module.

Additional tutorialsThese tutorials are not part of the learning pathway, but they are interesting nonetheless — you should consider these as stretch goals, to optionally study when you are done with the main Core articles.

Including vector graphics in HTML

Vector graphics are very useful in many circumstances — they have small file sizes and are highly scalable, so they don't pixelate when zoomed in or blown up to a large size. In this article we'll show you how to include one in your webpage.

From object to iframe — general embedding technologies

Developers commonly think of embedding media such as images, video and audio into web pages. In this article we take somewhat of a sideways step, looking at some elements that allow you to embed a wide variety of content types into your webpages: the <iframe>, <embed> and <object> elements. <iframe>s are for embedding other web pages, and the other two allow you to embed external resources such as PDF files.

See also
Learn HTML and CSS, Scrimba MDN learning partner

Scrimba's Learn HTML and CSS course teaches you HTML and CSS through building and deploying five awesome projects, with fun interactive lessons and challenges taught by knowledgeable teachers.

Learn HTML, Codecademy

Another useful resource for learning HTML basics.

The basics of semantic HTML, Scrimba MDN learning partner

This interactive lesson provides a useful description of HTML, with particular emphasis on why the semantic aspect of it is important.


 Overview: Core learning modules Next\n\nStructuring content with HTML Overview: Core learning modules Next  
HTML is the technology that defines the content and structure of any website. Written properly, it should also define the semantics (meaning) of the content in a machine-readable way, which is vital for accessibility, search engine optimization, and making use of the built-in features browsers provide for content to work optimally. This module covers the basics of the language, before looking at key areas such as document structure, links, lists, images, forms, and more.PrerequisitesBefore starting this module, you don't need any previous HTML knowledge, but you should have at least basic familiarity with using computers and using the web passively (i.e., just looking at it and consuming content). You should have a basic work environment set up (as detailed in Installing basic software), and understand how to create and manage files (as detailed in Dealing with files). Both are parts of our Getting started with the web complete beginner's module.

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
Basic HTML syntax

Covers the absolute basics of HTML, to get you started — we define elements, attributes, and other important terms, and show where they fit in the language. We also show how a typical HTML page is structured and how an HTML element is structured, and explain other important basic language features. Along the way, we'll play with some HTML to get you interested!

What's in the head? Web page metadata

The head of an HTML document is the part that is not displayed in the web browser when the page is loaded. It contains metadata information such as the page <title>, links to CSS (if you want to style your HTML content with CSS), links to custom favicons, and metadata (data about the HTML, such as who wrote it, and important keywords that describe the document).

Headings and paragraphs

One of HTML's main jobs is to give text structure so that a browser can display an HTML document the way its developer intends. This article explains how HTML can be used to provide fundamental page structure by defining headings and paragraphs.

Emphasis and importance

The previous article looked at why semantics are important in HTML, and focused on headings and paragraphs. This article continues on the theme of semantics, looking at HTML elements that apply emphasis and importance to text (parallel to italics and bold text in print media).

Lists

Lists are everywhere in life—from your shopping list to the list of directions you subconsciously follow to get to your house every day, to the lists of instructions you are following in these tutorials! It may not surprise you that HTML has a convenient set of elements that allows us to define different types of list. On the web, we have three types of lists: unordered, ordered, and description lists. This lesson shows you how to use the different types.

Structuring documents

In addition to defining individual parts of your page (such as "a paragraph" or "an image"), HTML also boasts a number of block level elements used to define areas of your website (such as "the header", "the navigation menu", "the main content column"). This article looks into how to plan a basic website structure, and write the HTML to represent this structure.

Advanced text features

There are many other elements in HTML for defining text semantics, which we didn't get to in the Emphasis and importance article. The elements described in this article are less known, but still useful to know about (and this is still not a complete list by any means). Here you'll learn about marking up quotations, computer code and other related text, subscript and superscript, contact information, and more.

Creating links

Links (also known as hyperlinks) are really important — they are what makes the Web a web. This article shows the syntax required to make a link, and discusses link best practices.

Marking up a letter Challenge

We all learn to write a letter sooner or later; it is also a useful example to test our text formatting skills. In this challenge, you'll have a letter to mark up as a test for your HTML text formatting skills, as well as hyperlinks and proper use of the HTML <head> element.

Structuring a page of content Challenge

Structuring a page of content ready for laying it out using CSS is a very important skill to master, so in this challenge you'll be tested on your ability to think about how a page might end up looking, and choose appropriate structural semantics to build a layout on top of.

HTML images

In the beginning, the web was just text, and it was really quite boring. Fortunately, it wasn't too long before the ability to embed images (and other more interesting types of content) inside web pages was added. In this article we'll look at how to use the <img> element in depth, including the basics, annotating it with captions using <figure>, and detailing how it relates to CSS background images.

HTML video and audio

Now that we are comfortable with adding simple images to a webpage, the next step is to start adding video and audio players to your HTML documents! In this article we'll look at doing just that with the <video> and <audio> elements; we'll then finish off by looking at how to add captions/subtitles to your videos.

Mozilla splash page Challenge

In this challenge, we'll test your knowledge of some of the techniques discussed in the last couple of lessons, getting you to add some images and video to a funky splash page all about Mozilla!

HTML table basics

This article gets you started with HTML tables, covering the very basics such as rows, cells, headings, making cells span multiple columns and rows, and how to group together all the cells in a column for styling purposes.

HTML table accessibility

In this article we look at more HTML table accessibility features such as captions/summaries, grouping your rows into table head, body and footer sections, and scoping columns and rows.

Structuring a planet data table Challenge

In this challenge, we provide you with some data on the planets in our solar system. Your job is to structure it into an accessible HTML table.

Forms and buttons in HTML

HTML forms and buttons are powerful tools for interacting with users — most commonly they are used for collecting data from users or allowing them to control a user interface. In this article we provide an introduction to the basics of forms and buttons.

Debugging HTML

Writing HTML is fine, but what if something goes wrong, and you can't work out where the error in the code is? This article will introduce you to some tools that can help you find and fix errors in HTML.

Test your skills: HTML

This page lists HTML tests you can try so you can verify if you've understood the content in this module.

Additional tutorialsThese tutorials are not part of the learning pathway, but they are interesting nonetheless — you should consider these as stretch goals, to optionally study when you are done with the main Core articles.

Including vector graphics in HTML

Vector graphics are very useful in many circumstances — they have small file sizes and are highly scalable, so they don't pixelate when zoomed in or blown up to a large size. In this article we'll show you how to include one in your webpage.

From object to iframe — general embedding technologies

Developers commonly think of embedding media such as images, video and audio into web pages. In this article we take somewhat of a sideways step, looking at some elements that allow you to embed a wide variety of content types into your webpages: the <iframe>, <embed> and <object> elements. <iframe>s are for embedding other web pages, and the other two allow you to embed external resources such as PDF files.

See also
Learn HTML and CSS, Scrimba MDN learning partner

Scrimba's Learn HTML and CSS course teaches you HTML and CSS through building and deploying five awesome projects, with fun interactive lessons and challenges taught by knowledgeable teachers.

Learn HTML, Codecademy

Another useful resource for learning HTML basics.

The basics of semantic HTML, Scrimba MDN learning partner

This interactive lesson provides a useful description of HTML, with particular emphasis on why the semantic aspect of it is important.


 Overview: Core learning modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 15, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nStructuring content with HTML Overview: Core learning modules Next  
HTML is the technology that defines the content and structure of any website. Written properly, it should also define the semantics (meaning) of the content in a machine-readable way, which is vital for accessibility, search engine optimization, and making use of the built-in features browsers provide for content to work optimally. This module covers the basics of the language, before looking at key areas such as document structure, links, lists, images, forms, and more.PrerequisitesBefore starting this module, you don't need any previous HTML knowledge, but you should have at least basic familiarity with using computers and using the web passively (i.e., just looking at it and consuming content). You should have a basic work environment set up (as detailed in Installing basic software), and understand how to create and manage files (as detailed in Dealing with files). Both are parts of our Getting started with the web complete beginner's module.

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
Basic HTML syntax

Covers the absolute basics of HTML, to get you started — we define elements, attributes, and other important terms, and show where they fit in the language. We also show how a typical HTML page is structured and how an HTML element is structured, and explain other important basic language features. Along the way, we'll play with some HTML to get you interested!

What's in the head? Web page metadata

The head of an HTML document is the part that is not displayed in the web browser when the page is loaded. It contains metadata information such as the page <title>, links to CSS (if you want to style your HTML content with CSS), links to custom favicons, and metadata (data about the HTML, such as who wrote it, and important keywords that describe the document).

Headings and paragraphs

One of HTML's main jobs is to give text structure so that a browser can display an HTML document the way its developer intends. This article explains how HTML can be used to provide fundamental page structure by defining headings and paragraphs.

Emphasis and importance

The previous article looked at why semantics are important in HTML, and focused on headings and paragraphs. This article continues on the theme of semantics, looking at HTML elements that apply emphasis and importance to text (parallel to italics and bold text in print media).

Lists

Lists are everywhere in life—from your shopping list to the list of directions you subconsciously follow to get to your house every day, to the lists of instructions you are following in these tutorials! It may not surprise you that HTML has a convenient set of elements that allows us to define different types of list. On the web, we have three types of lists: unordered, ordered, and description lists. This lesson shows you how to use the different types.

Structuring documents

In addition to defining individual parts of your page (such as "a paragraph" or "an image"), HTML also boasts a number of block level elements used to define areas of your website (such as "the header", "the navigation menu", "the main content column"). This article looks into how to plan a basic website structure, and write the HTML to represent this structure.

Advanced text features

There are many other elements in HTML for defining text semantics, which we didn't get to in the Emphasis and importance article. The elements described in this article are less known, but still useful to know about (and this is still not a complete list by any means). Here you'll learn about marking up quotations, computer code and other related text, subscript and superscript, contact information, and more.

Creating links

Links (also known as hyperlinks) are really important — they are what makes the Web a web. This article shows the syntax required to make a link, and discusses link best practices.

Marking up a letter Challenge

We all learn to write a letter sooner or later; it is also a useful example to test our text formatting skills. In this challenge, you'll have a letter to mark up as a test for your HTML text formatting skills, as well as hyperlinks and proper use of the HTML <head> element.

Structuring a page of content Challenge

Structuring a page of content ready for laying it out using CSS is a very important skill to master, so in this challenge you'll be tested on your ability to think about how a page might end up looking, and choose appropriate structural semantics to build a layout on top of.

HTML images

In the beginning, the web was just text, and it was really quite boring. Fortunately, it wasn't too long before the ability to embed images (and other more interesting types of content) inside web pages was added. In this article we'll look at how to use the <img> element in depth, including the basics, annotating it with captions using <figure>, and detailing how it relates to CSS background images.

HTML video and audio

Now that we are comfortable with adding simple images to a webpage, the next step is to start adding video and audio players to your HTML documents! In this article we'll look at doing just that with the <video> and <audio> elements; we'll then finish off by looking at how to add captions/subtitles to your videos.

Mozilla splash page Challenge

In this challenge, we'll test your knowledge of some of the techniques discussed in the last couple of lessons, getting you to add some images and video to a funky splash page all about Mozilla!

HTML table basics

This article gets you started with HTML tables, covering the very basics such as rows, cells, headings, making cells span multiple columns and rows, and how to group together all the cells in a column for styling purposes.

HTML table accessibility

In this article we look at more HTML table accessibility features such as captions/summaries, grouping your rows into table head, body and footer sections, and scoping columns and rows.

Structuring a planet data table Challenge

In this challenge, we provide you with some data on the planets in our solar system. Your job is to structure it into an accessible HTML table.

Forms and buttons in HTML

HTML forms and buttons are powerful tools for interacting with users — most commonly they are used for collecting data from users or allowing them to control a user interface. In this article we provide an introduction to the basics of forms and buttons.

Debugging HTML

Writing HTML is fine, but what if something goes wrong, and you can't work out where the error in the code is? This article will introduce you to some tools that can help you find and fix errors in HTML.

Test your skills: HTML

This page lists HTML tests you can try so you can verify if you've understood the content in this module.

Additional tutorialsThese tutorials are not part of the learning pathway, but they are interesting nonetheless — you should consider these as stretch goals, to optionally study when you are done with the main Core articles.

Including vector graphics in HTML

Vector graphics are very useful in many circumstances — they have small file sizes and are highly scalable, so they don't pixelate when zoomed in or blown up to a large size. In this article we'll show you how to include one in your webpage.

From object to iframe — general embedding technologies

Developers commonly think of embedding media such as images, video and audio into web pages. In this article we take somewhat of a sideways step, looking at some elements that allow you to embed a wide variety of content types into your webpages: the <iframe>, <embed> and <object> elements. <iframe>s are for embedding other web pages, and the other two allow you to embed external resources such as PDF files.

See also
Learn HTML and CSS, Scrimba MDN learning partner

Scrimba's Learn HTML and CSS course teaches you HTML and CSS through building and deploying five awesome projects, with fun interactive lessons and challenges taught by knowledgeable teachers.

Learn HTML, Codecademy

Another useful resource for learning HTML basics.

The basics of semantic HTML, Scrimba MDN learning partner

This interactive lesson provides a useful description of HTML, with particular emphasis on why the semantic aspect of it is important.


 Overview: Core learning modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 15, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nCSS styling basics Overview: Core learning modules Next  
CSS (Cascading Style Sheets) is used to style and layout web pages — for example, to alter the font, color, size, and spacing of your content, split it into multiple columns, or add animations and other decorative features. This module provides all the CSS fundamentals you'll need for now, including syntax, features, and techniques.PrerequisitesBefore starting this module, you should have a basic work environment set up (as detailed in Installing basic software), and understand how to create and manage files (as detailed in Dealing with files). You should also be familiar with HTML (work through our Structuring content with HTML module if not).

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
What is CSS?

CSS allows you to create great-looking web pages, but how does it work under the hood? This article explains what CSS, what the basic syntax looks like, and how your browser applies CSS to HTML to style it.

Getting started with CSS

In this article, we will take a simple HTML document and apply CSS to it, learning some practical details of the language along the way. We will also review the CSS syntax features you've not looked at yet.

Styling a biography page Challenge

In this challenge you will style a simple bio page, testing you on some of the skills you learned in the last couple of lessons including writing selectors and text styling.

Basic CSS selectors

In this article we'll recap some selector fundamentals, including the basic type, class, and ID selectors.

Attribute selectors

As you know from your study of HTML, elements can have attributes that give further detail about the element being marked up. In CSS you can use attribute selectors to target elements with certain attributes. This lesson will show you how to use these very useful selectors.

Pseudo-classes and pseudo-elements

The next set of selectors we will look at are referred to as pseudo-classes and pseudo-elements. There are a large number of these, and they often serve quite specific purposes. Once you know how to use them, you can look through the different types to see if there is something which works for the task you are trying to achieve.

Combinators

The final selectors we will look at are called combinators. Combinators are used to combine other selectors in a way that allows us to select elements based on their location in the DOM relative to other elements (for example, child or sibling).

The box model

Everything in CSS has a box around it, and understanding these boxes is key to being able to create more complex layouts with CSS, or to align items with other items. In this lesson, we will take a look at the CSS Box model. You'll get an understanding of how it works and the terminology that relates to it.

Handling conflicts

The aim of this lesson is to develop your understanding of some of the most fundamental concepts of CSS — the cascade, specificity, and inheritance — which control how CSS is applied to HTML and how conflicts between style declarations are resolved.

Values and units

CSS rules contain declarations, which in turn are composed of properties and values. Each property used in CSS has a value type that describes what kind of values it is allowed to have. In this lesson, we will take a look at some of the most frequently used value types, what they are, and how they work.

Sizing items in CSS

Understanding how big the different features in your design will be is important. In this lesson we will summarize the various ways elements get a size via CSS and define a few terms about sizing that will help you in the future.

Backgrounds and borders

In this lesson, we will take a look at some of the creative things you can do with CSS backgrounds and borders. From adding gradients, background images, and rounded corners, backgrounds and borders are the answer to a lot of styling questions in CSS.

Overflowing content

Overflow is what happens when there is too much content to fit inside an element box. In this lesson, you will learn how to manage overflow using CSS.

Images, media, and form elements

In this lesson we will take a look at how certain special elements are treated in CSS. Images, other media, and form elements behave a little differently from regular boxes in terms of your ability to style them with CSS. Understanding what is and isn't possible can save some frustration, and this lesson will highlight some of the main things that you need to know.

Styling tables

Styling an HTML table isn't the most glamorous job in the world, but sometimes we all have to do it. This article explains how to make HTML tables look good, with some specific table styling techniques highlighted.

Debugging CSS

This article will give you guidance on how to go about debugging a CSS problem, and show you how the DevTools included in all modern browsers can help you to find out what is going on.

Challenge: Fundamental CSS comprehension Challenge

This challenge provides a number of related exercises that must be completed in order to create the final design — a business card/gamer card/social media profile.

Challenge: Creating fancy letterheaded paper Challenge

If you want to make the right impression, writing a letter on nice letterheaded paper can be a really good start. In this challenge you will create an online template to achieve such a look.

Challenge: A cool-looking box Challenge

In this challenge, you'll get some more practice in creating cool-looking boxes by trying to create an eye-catching box.

Additional tutorialsThese tutorials are not part of the learning pathway, but they are interesting nonetheless — you should consider these as stretch goals, to optionally study when you are done with the main Core articles.

Advanced styling effects

This article will give you guidance on how to go about debugging a CSS problem, and show you how the DevTools included in all modern browsers can help you to find out what is going on.

Cascade layers

This lesson aims to introduce you to cascade layers, a more advanced feature that builds on the fundamental concepts of the CSS cascade and CSS specificity.

Handling different text directions

In recent years, CSS has evolved in order to better support different directionality of content, including right-to-left but also top-to-bottom content (such as Japanese) — these different directionalities are called writing modes. As you progress in your study and begin to work with layout, an understanding of writing modes will be very helpful to you, therefore we will introduce them in this article.

Organizing CSS

As you start to work on larger stylesheets and big projects you will discover that maintaining a huge CSS file can be challenging. In this article we will take a brief look at some best practices for writing your CSS to make it easily maintainable, and some of the solutions you will find in use by others to help improve maintainability.

See also
Learn HTML and CSS, Scrimba MDN learning partner

Scrimba's Learn HTML and CSS course teaches you HTML and CSS through building and deploying five awesome projects, with fun interactive lessons and challenges taught by knowledgeable teachers.

Write your first lines of CSS!, Scrimba MDN learning partner

This interactive lesson provides a useful introduction to CSS syntax.


 Overview: Core learning modules Next\n\nCSS styling basics Overview: Core learning modules Next  
CSS (Cascading Style Sheets) is used to style and layout web pages — for example, to alter the font, color, size, and spacing of your content, split it into multiple columns, or add animations and other decorative features. This module provides all the CSS fundamentals you'll need for now, including syntax, features, and techniques.PrerequisitesBefore starting this module, you should have a basic work environment set up (as detailed in Installing basic software), and understand how to create and manage files (as detailed in Dealing with files). You should also be familiar with HTML (work through our Structuring content with HTML module if not).

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
What is CSS?

CSS allows you to create great-looking web pages, but how does it work under the hood? This article explains what CSS, what the basic syntax looks like, and how your browser applies CSS to HTML to style it.

Getting started with CSS

In this article, we will take a simple HTML document and apply CSS to it, learning some practical details of the language along the way. We will also review the CSS syntax features you've not looked at yet.

Styling a biography page Challenge

In this challenge you will style a simple bio page, testing you on some of the skills you learned in the last couple of lessons including writing selectors and text styling.

Basic CSS selectors

In this article we'll recap some selector fundamentals, including the basic type, class, and ID selectors.

Attribute selectors

As you know from your study of HTML, elements can have attributes that give further detail about the element being marked up. In CSS you can use attribute selectors to target elements with certain attributes. This lesson will show you how to use these very useful selectors.

Pseudo-classes and pseudo-elements

The next set of selectors we will look at are referred to as pseudo-classes and pseudo-elements. There are a large number of these, and they often serve quite specific purposes. Once you know how to use them, you can look through the different types to see if there is something which works for the task you are trying to achieve.

Combinators

The final selectors we will look at are called combinators. Combinators are used to combine other selectors in a way that allows us to select elements based on their location in the DOM relative to other elements (for example, child or sibling).

The box model

Everything in CSS has a box around it, and understanding these boxes is key to being able to create more complex layouts with CSS, or to align items with other items. In this lesson, we will take a look at the CSS Box model. You'll get an understanding of how it works and the terminology that relates to it.

Handling conflicts

The aim of this lesson is to develop your understanding of some of the most fundamental concepts of CSS — the cascade, specificity, and inheritance — which control how CSS is applied to HTML and how conflicts between style declarations are resolved.

Values and units

CSS rules contain declarations, which in turn are composed of properties and values. Each property used in CSS has a value type that describes what kind of values it is allowed to have. In this lesson, we will take a look at some of the most frequently used value types, what they are, and how they work.

Sizing items in CSS

Understanding how big the different features in your design will be is important. In this lesson we will summarize the various ways elements get a size via CSS and define a few terms about sizing that will help you in the future.

Backgrounds and borders

In this lesson, we will take a look at some of the creative things you can do with CSS backgrounds and borders. From adding gradients, background images, and rounded corners, backgrounds and borders are the answer to a lot of styling questions in CSS.

Overflowing content

Overflow is what happens when there is too much content to fit inside an element box. In this lesson, you will learn how to manage overflow using CSS.

Images, media, and form elements

In this lesson we will take a look at how certain special elements are treated in CSS. Images, other media, and form elements behave a little differently from regular boxes in terms of your ability to style them with CSS. Understanding what is and isn't possible can save some frustration, and this lesson will highlight some of the main things that you need to know.

Styling tables

Styling an HTML table isn't the most glamorous job in the world, but sometimes we all have to do it. This article explains how to make HTML tables look good, with some specific table styling techniques highlighted.

Debugging CSS

This article will give you guidance on how to go about debugging a CSS problem, and show you how the DevTools included in all modern browsers can help you to find out what is going on.

Challenge: Fundamental CSS comprehension Challenge

This challenge provides a number of related exercises that must be completed in order to create the final design — a business card/gamer card/social media profile.

Challenge: Creating fancy letterheaded paper Challenge

If you want to make the right impression, writing a letter on nice letterheaded paper can be a really good start. In this challenge you will create an online template to achieve such a look.

Challenge: A cool-looking box Challenge

In this challenge, you'll get some more practice in creating cool-looking boxes by trying to create an eye-catching box.

Additional tutorialsThese tutorials are not part of the learning pathway, but they are interesting nonetheless — you should consider these as stretch goals, to optionally study when you are done with the main Core articles.

Advanced styling effects

This article will give you guidance on how to go about debugging a CSS problem, and show you how the DevTools included in all modern browsers can help you to find out what is going on.

Cascade layers

This lesson aims to introduce you to cascade layers, a more advanced feature that builds on the fundamental concepts of the CSS cascade and CSS specificity.

Handling different text directions

In recent years, CSS has evolved in order to better support different directionality of content, including right-to-left but also top-to-bottom content (such as Japanese) — these different directionalities are called writing modes. As you progress in your study and begin to work with layout, an understanding of writing modes will be very helpful to you, therefore we will introduce them in this article.

Organizing CSS

As you start to work on larger stylesheets and big projects you will discover that maintaining a huge CSS file can be challenging. In this article we will take a brief look at some best practices for writing your CSS to make it easily maintainable, and some of the solutions you will find in use by others to help improve maintainability.

See also
Learn HTML and CSS, Scrimba MDN learning partner

Scrimba's Learn HTML and CSS course teaches you HTML and CSS through building and deploying five awesome projects, with fun interactive lessons and challenges taught by knowledgeable teachers.

Write your first lines of CSS!, Scrimba MDN learning partner

This interactive lesson provides a useful introduction to CSS syntax.


 Overview: Core learning modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 15, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nCSS styling basics Overview: Core learning modules Next  
CSS (Cascading Style Sheets) is used to style and layout web pages — for example, to alter the font, color, size, and spacing of your content, split it into multiple columns, or add animations and other decorative features. This module provides all the CSS fundamentals you'll need for now, including syntax, features, and techniques.PrerequisitesBefore starting this module, you should have a basic work environment set up (as detailed in Installing basic software), and understand how to create and manage files (as detailed in Dealing with files). You should also be familiar with HTML (work through our Structuring content with HTML module if not).

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
What is CSS?

CSS allows you to create great-looking web pages, but how does it work under the hood? This article explains what CSS, what the basic syntax looks like, and how your browser applies CSS to HTML to style it.

Getting started with CSS

In this article, we will take a simple HTML document and apply CSS to it, learning some practical details of the language along the way. We will also review the CSS syntax features you've not looked at yet.

Styling a biography page Challenge

In this challenge you will style a simple bio page, testing you on some of the skills you learned in the last couple of lessons including writing selectors and text styling.

Basic CSS selectors

In this article we'll recap some selector fundamentals, including the basic type, class, and ID selectors.

Attribute selectors

As you know from your study of HTML, elements can have attributes that give further detail about the element being marked up. In CSS you can use attribute selectors to target elements with certain attributes. This lesson will show you how to use these very useful selectors.

Pseudo-classes and pseudo-elements

The next set of selectors we will look at are referred to as pseudo-classes and pseudo-elements. There are a large number of these, and they often serve quite specific purposes. Once you know how to use them, you can look through the different types to see if there is something which works for the task you are trying to achieve.

Combinators

The final selectors we will look at are called combinators. Combinators are used to combine other selectors in a way that allows us to select elements based on their location in the DOM relative to other elements (for example, child or sibling).

The box model

Everything in CSS has a box around it, and understanding these boxes is key to being able to create more complex layouts with CSS, or to align items with other items. In this lesson, we will take a look at the CSS Box model. You'll get an understanding of how it works and the terminology that relates to it.

Handling conflicts

The aim of this lesson is to develop your understanding of some of the most fundamental concepts of CSS — the cascade, specificity, and inheritance — which control how CSS is applied to HTML and how conflicts between style declarations are resolved.

Values and units

CSS rules contain declarations, which in turn are composed of properties and values. Each property used in CSS has a value type that describes what kind of values it is allowed to have. In this lesson, we will take a look at some of the most frequently used value types, what they are, and how they work.

Sizing items in CSS

Understanding how big the different features in your design will be is important. In this lesson we will summarize the various ways elements get a size via CSS and define a few terms about sizing that will help you in the future.

Backgrounds and borders

In this lesson, we will take a look at some of the creative things you can do with CSS backgrounds and borders. From adding gradients, background images, and rounded corners, backgrounds and borders are the answer to a lot of styling questions in CSS.

Overflowing content

Overflow is what happens when there is too much content to fit inside an element box. In this lesson, you will learn how to manage overflow using CSS.

Images, media, and form elements

In this lesson we will take a look at how certain special elements are treated in CSS. Images, other media, and form elements behave a little differently from regular boxes in terms of your ability to style them with CSS. Understanding what is and isn't possible can save some frustration, and this lesson will highlight some of the main things that you need to know.

Styling tables

Styling an HTML table isn't the most glamorous job in the world, but sometimes we all have to do it. This article explains how to make HTML tables look good, with some specific table styling techniques highlighted.

Debugging CSS

This article will give you guidance on how to go about debugging a CSS problem, and show you how the DevTools included in all modern browsers can help you to find out what is going on.

Challenge: Fundamental CSS comprehension Challenge

This challenge provides a number of related exercises that must be completed in order to create the final design — a business card/gamer card/social media profile.

Challenge: Creating fancy letterheaded paper Challenge

If you want to make the right impression, writing a letter on nice letterheaded paper can be a really good start. In this challenge you will create an online template to achieve such a look.

Challenge: A cool-looking box Challenge

In this challenge, you'll get some more practice in creating cool-looking boxes by trying to create an eye-catching box.

Additional tutorialsThese tutorials are not part of the learning pathway, but they are interesting nonetheless — you should consider these as stretch goals, to optionally study when you are done with the main Core articles.

Advanced styling effects

This article will give you guidance on how to go about debugging a CSS problem, and show you how the DevTools included in all modern browsers can help you to find out what is going on.

Cascade layers

This lesson aims to introduce you to cascade layers, a more advanced feature that builds on the fundamental concepts of the CSS cascade and CSS specificity.

Handling different text directions

In recent years, CSS has evolved in order to better support different directionality of content, including right-to-left but also top-to-bottom content (such as Japanese) — these different directionalities are called writing modes. As you progress in your study and begin to work with layout, an understanding of writing modes will be very helpful to you, therefore we will introduce them in this article.

Organizing CSS

As you start to work on larger stylesheets and big projects you will discover that maintaining a huge CSS file can be challenging. In this article we will take a brief look at some best practices for writing your CSS to make it easily maintainable, and some of the solutions you will find in use by others to help improve maintainability.

See also
Learn HTML and CSS, Scrimba MDN learning partner

Scrimba's Learn HTML and CSS course teaches you HTML and CSS through building and deploying five awesome projects, with fun interactive lessons and challenges taught by knowledgeable teachers.

Write your first lines of CSS!, Scrimba MDN learning partner

This interactive lesson provides a useful introduction to CSS syntax.


 Overview: Core learning modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 15, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nDynamic scripting with JavaScript Overview: Core learning modules Next  
JavaScript is a huge topic, with so many different features, styles, and techniques to learn, and so many APIs and tools built on top of it. This module focuses mostly on the essentials of the core language, plus some key surrounding topics — learning these topics will give you a solid basis to work from.PrerequisitesBefore starting this module, you don't need any previous JavaScript knowledge, but you should have worked through the previous modules in the course. You should at least know HTML and the basic fundamentals of CSS.

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
What is JavaScript?

Welcome to the MDN beginner's JavaScript course! In this first article we will look at JavaScript from a high level, answering questions such as "what is it?", and "what is it doing?", and making sure you are comfortable with JavaScript's purpose.

A first splash into JavaScript

Now you've learned something about the theory of JavaScript, and what you can do with it, we are going to give you a crash course on the basic features of JavaScript via a completely practical tutorial. Here you'll build up a simple "Guess the number" game, step by step.

What went wrong? Troubleshooting JavaScript

When you built up the "Guess the number" game in the previous article, you may have found that it didn't work. Never fear — this article aims to save you from tearing your hair out over such problems by providing you with some simple tips on how to find and fix errors in JavaScript programs.

Storing the information you need — Variables

After reading the last couple of articles you should now know what JavaScript is, what it can do for you, how you use it alongside other web technologies, and what its main features look like from a high level. In this article, we will get down to the real basics, looking at how to work with the most basic building blocks of JavaScript — Variables.

Basic math in JavaScript — numbers and operators

At this point in the course, we discuss maths in JavaScript — how we can combine operators and other features to successfully manipulate numbers to do our bidding.

Handling text — strings in JavaScript

Next, we'll turn our attention to strings — this is what pieces of text are called in programming. In this article, we'll look at all the common things that you really ought to know about strings when learning JavaScript, such as creating strings, escaping quotes in strings, and joining them together.

Useful string methods

Now we've looked at the very basics of strings, let's move up a gear and start thinking about what useful operations we can do on strings with built-in methods, such as finding the length of a text string, joining and splitting strings, substituting one character in a string for another, and more.

Arrays

In this lesson we'll look at arrays — a neat way of storing a list of data items under a single variable name. Here we look at why this is useful, then explore how to create an array, retrieve, add, and remove items stored in an array, and more besides.

Challenge: Silly story generator Challenge

In this challenge, you'll be tasked with taking some of the knowledge you've picked up in this module's articles and applying it to creating a fun app that generates random silly stories. Have fun!

Making decisions in your code — conditionals

In any programming language, the code needs to make decisions and carry out actions accordingly depending on different inputs. For example, in a game, if the player's number of lives is 0, then it's game over. In a weather app, if it is being looked at in the morning, show a sunrise graphic; show stars and a moon if it is nighttime. In this article, we'll explore how so-called conditional statements work in JavaScript.

Looping code

Programming languages are very useful for rapidly completing repetitive tasks, from multiple basic calculations to just about any other situation where you've got a lot of similar items of work to complete. Here we'll look at the loop structures available in JavaScript that handle such needs.

Functions — reusable blocks of code

Another essential concept in coding is functions, which allow you to store a piece of code that does a single task inside a defined block, and then call that code whenever you need it using a single short command — rather than having to type out the same code multiple times. In this article we'll explore fundamental concepts behind functions such as basic syntax, how to invoke and define them, scope, and parameters.

Build your own function

With most of the essential theory dealt with in the previous article, this article provides practical experience. Here you will get some practice building your own, custom function. Along the way, we'll also explain some useful details of dealing with functions.

Function return values

There's one last essential concept about functions for us to discuss — return values. Some functions don't return a significant value, but others do. It's important to understand what their values are, how to use them in your code, and how to make functions return useful values. We'll cover all of these below.

Introduction to events

In this article, we discuss some important concepts surrounding events, and look at the fundamentals of how they work in browsers.

Event bubbling

This article introduces the concepts of event bubbling, event capture, and event delegation, which are all about what happens when you add a listener to an element that contains another element, and an event then happens to the contained element.

Challenge: Image gallery Challenge

Now that we've looked at the fundamental building blocks of JavaScript, we'll test your knowledge of loops, functions, conditionals and events by getting you to build a fairly common item you'll see on a lot of websites — a JavaScript-powered image gallery.

Object basics

In this article, we'll look at fundamental JavaScript object syntax, and revisit some JavaScript features that we've already seen earlier in the course, reiterating the fact that many of the features you've already dealt with are objects.

DOM scripting introduction

When writing web pages and apps, one of the most common things you'll want to do is change the document structure in some way. This is usually done by manipulating the Document Object Model (DOM) via a set of built-in browser APIs for controlling HTML and styling information. In this article we'll introduce you to DOM scripting.

Making network requests with JavaScript

Another very common task in modern websites and applications is making network requests to retrieve individual data items from the server to update sections of a webpage without having to load an entire new page. This seemingly small detail has had a huge impact on the performance and behavior of sites, so in this article, we'll explain the concept and look at technologies that make it possible.

Working with JSON

JavaScript Object Notation (JSON) is a standard text-based format for representing structured data based on JavaScript object syntax. It is commonly used for transmitting data in web applications (e.g., sending some data from the server to the client, so it can be displayed on a web page, or vice versa). You'll come across it quite often, so in this article, we give you all you need to work with JSON using JavaScript, including parsing JSON so you can access data within it, and creating JSON.

JavaScript debugging and error handling

In this lesson, we will return to the subject of debugging JavaScript (which we first looked at in What went wrong?). Here we will delve deeper into techniques for tracking down errors, but also look at how to code defensively and handle errors in your code, avoiding problems in the first place.

Test your skills: JavaScript

This page lists JavaScript tests you can try so you can verify if you've understood the content in this module.

See also
Scrimba: Learn JavaScript MDN learning partner

Scrimba's Learn JavaScript course teaches you JavaScript through solving 140+ interactive coding challenges, building projects including a game, a browser extension, and even a mobile app. Scrimba features fun interactive lessons taught by knowledgeable teachers.

Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.


 Overview: Core learning modules Next\n\nDynamic scripting with JavaScript Overview: Core learning modules Next  
JavaScript is a huge topic, with so many different features, styles, and techniques to learn, and so many APIs and tools built on top of it. This module focuses mostly on the essentials of the core language, plus some key surrounding topics — learning these topics will give you a solid basis to work from.PrerequisitesBefore starting this module, you don't need any previous JavaScript knowledge, but you should have worked through the previous modules in the course. You should at least know HTML and the basic fundamentals of CSS.

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
What is JavaScript?

Welcome to the MDN beginner's JavaScript course! In this first article we will look at JavaScript from a high level, answering questions such as "what is it?", and "what is it doing?", and making sure you are comfortable with JavaScript's purpose.

A first splash into JavaScript

Now you've learned something about the theory of JavaScript, and what you can do with it, we are going to give you a crash course on the basic features of JavaScript via a completely practical tutorial. Here you'll build up a simple "Guess the number" game, step by step.

What went wrong? Troubleshooting JavaScript

When you built up the "Guess the number" game in the previous article, you may have found that it didn't work. Never fear — this article aims to save you from tearing your hair out over such problems by providing you with some simple tips on how to find and fix errors in JavaScript programs.

Storing the information you need — Variables

After reading the last couple of articles you should now know what JavaScript is, what it can do for you, how you use it alongside other web technologies, and what its main features look like from a high level. In this article, we will get down to the real basics, looking at how to work with the most basic building blocks of JavaScript — Variables.

Basic math in JavaScript — numbers and operators

At this point in the course, we discuss maths in JavaScript — how we can combine operators and other features to successfully manipulate numbers to do our bidding.

Handling text — strings in JavaScript

Next, we'll turn our attention to strings — this is what pieces of text are called in programming. In this article, we'll look at all the common things that you really ought to know about strings when learning JavaScript, such as creating strings, escaping quotes in strings, and joining them together.

Useful string methods

Now we've looked at the very basics of strings, let's move up a gear and start thinking about what useful operations we can do on strings with built-in methods, such as finding the length of a text string, joining and splitting strings, substituting one character in a string for another, and more.

Arrays

In this lesson we'll look at arrays — a neat way of storing a list of data items under a single variable name. Here we look at why this is useful, then explore how to create an array, retrieve, add, and remove items stored in an array, and more besides.

Challenge: Silly story generator Challenge

In this challenge, you'll be tasked with taking some of the knowledge you've picked up in this module's articles and applying it to creating a fun app that generates random silly stories. Have fun!

Making decisions in your code — conditionals

In any programming language, the code needs to make decisions and carry out actions accordingly depending on different inputs. For example, in a game, if the player's number of lives is 0, then it's game over. In a weather app, if it is being looked at in the morning, show a sunrise graphic; show stars and a moon if it is nighttime. In this article, we'll explore how so-called conditional statements work in JavaScript.

Looping code

Programming languages are very useful for rapidly completing repetitive tasks, from multiple basic calculations to just about any other situation where you've got a lot of similar items of work to complete. Here we'll look at the loop structures available in JavaScript that handle such needs.

Functions — reusable blocks of code

Another essential concept in coding is functions, which allow you to store a piece of code that does a single task inside a defined block, and then call that code whenever you need it using a single short command — rather than having to type out the same code multiple times. In this article we'll explore fundamental concepts behind functions such as basic syntax, how to invoke and define them, scope, and parameters.

Build your own function

With most of the essential theory dealt with in the previous article, this article provides practical experience. Here you will get some practice building your own, custom function. Along the way, we'll also explain some useful details of dealing with functions.

Function return values

There's one last essential concept about functions for us to discuss — return values. Some functions don't return a significant value, but others do. It's important to understand what their values are, how to use them in your code, and how to make functions return useful values. We'll cover all of these below.

Introduction to events

In this article, we discuss some important concepts surrounding events, and look at the fundamentals of how they work in browsers.

Event bubbling

This article introduces the concepts of event bubbling, event capture, and event delegation, which are all about what happens when you add a listener to an element that contains another element, and an event then happens to the contained element.

Challenge: Image gallery Challenge

Now that we've looked at the fundamental building blocks of JavaScript, we'll test your knowledge of loops, functions, conditionals and events by getting you to build a fairly common item you'll see on a lot of websites — a JavaScript-powered image gallery.

Object basics

In this article, we'll look at fundamental JavaScript object syntax, and revisit some JavaScript features that we've already seen earlier in the course, reiterating the fact that many of the features you've already dealt with are objects.

DOM scripting introduction

When writing web pages and apps, one of the most common things you'll want to do is change the document structure in some way. This is usually done by manipulating the Document Object Model (DOM) via a set of built-in browser APIs for controlling HTML and styling information. In this article we'll introduce you to DOM scripting.

Making network requests with JavaScript

Another very common task in modern websites and applications is making network requests to retrieve individual data items from the server to update sections of a webpage without having to load an entire new page. This seemingly small detail has had a huge impact on the performance and behavior of sites, so in this article, we'll explain the concept and look at technologies that make it possible.

Working with JSON

JavaScript Object Notation (JSON) is a standard text-based format for representing structured data based on JavaScript object syntax. It is commonly used for transmitting data in web applications (e.g., sending some data from the server to the client, so it can be displayed on a web page, or vice versa). You'll come across it quite often, so in this article, we give you all you need to work with JSON using JavaScript, including parsing JSON so you can access data within it, and creating JSON.

JavaScript debugging and error handling

In this lesson, we will return to the subject of debugging JavaScript (which we first looked at in What went wrong?). Here we will delve deeper into techniques for tracking down errors, but also look at how to code defensively and handle errors in your code, avoiding problems in the first place.

Test your skills: JavaScript

This page lists JavaScript tests you can try so you can verify if you've understood the content in this module.

See also
Scrimba: Learn JavaScript MDN learning partner

Scrimba's Learn JavaScript course teaches you JavaScript through solving 140+ interactive coding challenges, building projects including a game, a browser extension, and even a mobile app. Scrimba features fun interactive lessons taught by knowledgeable teachers.

Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.


 Overview: Core learning modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 15, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nDynamic scripting with JavaScript Overview: Core learning modules Next  
JavaScript is a huge topic, with so many different features, styles, and techniques to learn, and so many APIs and tools built on top of it. This module focuses mostly on the essentials of the core language, plus some key surrounding topics — learning these topics will give you a solid basis to work from.PrerequisitesBefore starting this module, you don't need any previous JavaScript knowledge, but you should have worked through the previous modules in the course. You should at least know HTML and the basic fundamentals of CSS.

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
What is JavaScript?

Welcome to the MDN beginner's JavaScript course! In this first article we will look at JavaScript from a high level, answering questions such as "what is it?", and "what is it doing?", and making sure you are comfortable with JavaScript's purpose.

A first splash into JavaScript

Now you've learned something about the theory of JavaScript, and what you can do with it, we are going to give you a crash course on the basic features of JavaScript via a completely practical tutorial. Here you'll build up a simple "Guess the number" game, step by step.

What went wrong? Troubleshooting JavaScript

When you built up the "Guess the number" game in the previous article, you may have found that it didn't work. Never fear — this article aims to save you from tearing your hair out over such problems by providing you with some simple tips on how to find and fix errors in JavaScript programs.

Storing the information you need — Variables

After reading the last couple of articles you should now know what JavaScript is, what it can do for you, how you use it alongside other web technologies, and what its main features look like from a high level. In this article, we will get down to the real basics, looking at how to work with the most basic building blocks of JavaScript — Variables.

Basic math in JavaScript — numbers and operators

At this point in the course, we discuss maths in JavaScript — how we can combine operators and other features to successfully manipulate numbers to do our bidding.

Handling text — strings in JavaScript

Next, we'll turn our attention to strings — this is what pieces of text are called in programming. In this article, we'll look at all the common things that you really ought to know about strings when learning JavaScript, such as creating strings, escaping quotes in strings, and joining them together.

Useful string methods

Now we've looked at the very basics of strings, let's move up a gear and start thinking about what useful operations we can do on strings with built-in methods, such as finding the length of a text string, joining and splitting strings, substituting one character in a string for another, and more.

Arrays

In this lesson we'll look at arrays — a neat way of storing a list of data items under a single variable name. Here we look at why this is useful, then explore how to create an array, retrieve, add, and remove items stored in an array, and more besides.

Challenge: Silly story generator Challenge

In this challenge, you'll be tasked with taking some of the knowledge you've picked up in this module's articles and applying it to creating a fun app that generates random silly stories. Have fun!

Making decisions in your code — conditionals

In any programming language, the code needs to make decisions and carry out actions accordingly depending on different inputs. For example, in a game, if the player's number of lives is 0, then it's game over. In a weather app, if it is being looked at in the morning, show a sunrise graphic; show stars and a moon if it is nighttime. In this article, we'll explore how so-called conditional statements work in JavaScript.

Looping code

Programming languages are very useful for rapidly completing repetitive tasks, from multiple basic calculations to just about any other situation where you've got a lot of similar items of work to complete. Here we'll look at the loop structures available in JavaScript that handle such needs.

Functions — reusable blocks of code

Another essential concept in coding is functions, which allow you to store a piece of code that does a single task inside a defined block, and then call that code whenever you need it using a single short command — rather than having to type out the same code multiple times. In this article we'll explore fundamental concepts behind functions such as basic syntax, how to invoke and define them, scope, and parameters.

Build your own function

With most of the essential theory dealt with in the previous article, this article provides practical experience. Here you will get some practice building your own, custom function. Along the way, we'll also explain some useful details of dealing with functions.

Function return values

There's one last essential concept about functions for us to discuss — return values. Some functions don't return a significant value, but others do. It's important to understand what their values are, how to use them in your code, and how to make functions return useful values. We'll cover all of these below.

Introduction to events

In this article, we discuss some important concepts surrounding events, and look at the fundamentals of how they work in browsers.

Event bubbling

This article introduces the concepts of event bubbling, event capture, and event delegation, which are all about what happens when you add a listener to an element that contains another element, and an event then happens to the contained element.

Challenge: Image gallery Challenge

Now that we've looked at the fundamental building blocks of JavaScript, we'll test your knowledge of loops, functions, conditionals and events by getting you to build a fairly common item you'll see on a lot of websites — a JavaScript-powered image gallery.

Object basics

In this article, we'll look at fundamental JavaScript object syntax, and revisit some JavaScript features that we've already seen earlier in the course, reiterating the fact that many of the features you've already dealt with are objects.

DOM scripting introduction

When writing web pages and apps, one of the most common things you'll want to do is change the document structure in some way. This is usually done by manipulating the Document Object Model (DOM) via a set of built-in browser APIs for controlling HTML and styling information. In this article we'll introduce you to DOM scripting.

Making network requests with JavaScript

Another very common task in modern websites and applications is making network requests to retrieve individual data items from the server to update sections of a webpage without having to load an entire new page. This seemingly small detail has had a huge impact on the performance and behavior of sites, so in this article, we'll explain the concept and look at technologies that make it possible.

Working with JSON

JavaScript Object Notation (JSON) is a standard text-based format for representing structured data based on JavaScript object syntax. It is commonly used for transmitting data in web applications (e.g., sending some data from the server to the client, so it can be displayed on a web page, or vice versa). You'll come across it quite often, so in this article, we give you all you need to work with JSON using JavaScript, including parsing JSON so you can access data within it, and creating JSON.

JavaScript debugging and error handling

In this lesson, we will return to the subject of debugging JavaScript (which we first looked at in What went wrong?). Here we will delve deeper into techniques for tracking down errors, but also look at how to code defensively and handle errors in your code, avoiding problems in the first place.

Test your skills: JavaScript

This page lists JavaScript tests you can try so you can verify if you've understood the content in this module.

See also
Scrimba: Learn JavaScript MDN learning partner

Scrimba's Learn JavaScript course teaches you JavaScript through solving 140+ interactive coding challenges, building projects including a game, a browser extension, and even a mobile app. Scrimba features fun interactive lessons taught by knowledgeable teachers.

Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.


 Overview: Core learning modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 15, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nAccessibility on the web Overview: Core learning modules Next  
Access to web content such as public services, education, e-commerce sites, and entertainment is a human right. No one should be excluded based on disability, race, geography, or other human characteristics. This module discusses the best practices and techniques you should learn to make your websites as accessible as possible.PrerequisitesYou should be familiar with HTML, CSS, and JavaScript before starting this module.

Note:
If you are working on a computer/tablet/other devices where you don't have the ability to create your own files, you can try out most of the code examples in an online coding program such as JS Bin or Glitch.
Tutorials and challenges
What is accessibility?

This article starts off the module with a good look at what accessibility is — this includes what groups of people we need to consider and why, what tools different people use to interact with the web, and how we can make accessibility part of our web development workflow.

Accessibility tooling and assistive technology

Next we turn our attention to accessibility tooling, providing information on the kinds of tools you can use to help solve accessibility issues, and the assistive technologies used by people with disabilities as they browse the web. You'll be using these tools throughout subsequent articles.

HTML: A good basis for accessibility

A great deal of web content can be made accessible just by making sure the correct HTML elements are always used for the correct purpose. This article looks in detail at how HTML can be used to ensure maximum accessibility.

CSS and JavaScript accessibility best practices

CSS and JavaScript, when used properly, also have the potential to allow for accessible web experiences, but if misused they can significantly harm accessibility. This article outlines some CSS and JavaScript best practices that should be considered to ensure that even complex content is as accessible as possible.

WAI-ARIA basics

Following on from the previous article, sometimes making complex UI controls that involve unsemantic HTML and dynamic JavaScript-updated content can be difficult. WAI-ARIA is a technology that can help with such problems by adding in further semantics that browsers and assistive technologies can recognize and use to let users know what is going on. Here we'll show how to use it at a basic level to improve accessibility.

Accessible multimedia

Another category of content that can create accessibility problems is multimedia — video, audio, and image content need to be given proper textual alternatives, so they can be understood by assistive technologies and their users. This article shows how.

Mobile accessibility

With web access on mobile devices being so popular, and popular platforms such as iOS and Android having fully-fledged accessibility tools, it is important to consider the accessibility of your web content on these platforms. This article looks at mobile-specific accessibility considerations.

Accessibility troubleshooting Challenge

In this challenge, we present to you a simple site with several accessibility issues that you need to diagnose and fix.

See also
Start Building Accessible Web Applications Today

An excellent series of video tutorials by Marcy Sutton.

Deque University resources

Includes code examples, screen reader references, and other useful resources.

WebAIM resources

Includes guides, checklists, tools, and more.

Web Accessibility Evaluation Tools List

Includes a list of web accessibility evaluation tools.

Learn Accessible Web Design MDN learning partner

Scrimba's Learn Accessible Web Design course teaches you how to write accessible HTML by solving interactive coding challenges and fixing a real-world website.


 Overview: Core learning modules Next\n\nAccessibility on the web Overview: Core learning modules Next  
Access to web content such as public services, education, e-commerce sites, and entertainment is a human right. No one should be excluded based on disability, race, geography, or other human characteristics. This module discusses the best practices and techniques you should learn to make your websites as accessible as possible.PrerequisitesYou should be familiar with HTML, CSS, and JavaScript before starting this module.

Note:
If you are working on a computer/tablet/other devices where you don't have the ability to create your own files, you can try out most of the code examples in an online coding program such as JS Bin or Glitch.
Tutorials and challenges
What is accessibility?

This article starts off the module with a good look at what accessibility is — this includes what groups of people we need to consider and why, what tools different people use to interact with the web, and how we can make accessibility part of our web development workflow.

Accessibility tooling and assistive technology

Next we turn our attention to accessibility tooling, providing information on the kinds of tools you can use to help solve accessibility issues, and the assistive technologies used by people with disabilities as they browse the web. You'll be using these tools throughout subsequent articles.

HTML: A good basis for accessibility

A great deal of web content can be made accessible just by making sure the correct HTML elements are always used for the correct purpose. This article looks in detail at how HTML can be used to ensure maximum accessibility.

CSS and JavaScript accessibility best practices

CSS and JavaScript, when used properly, also have the potential to allow for accessible web experiences, but if misused they can significantly harm accessibility. This article outlines some CSS and JavaScript best practices that should be considered to ensure that even complex content is as accessible as possible.

WAI-ARIA basics

Following on from the previous article, sometimes making complex UI controls that involve unsemantic HTML and dynamic JavaScript-updated content can be difficult. WAI-ARIA is a technology that can help with such problems by adding in further semantics that browsers and assistive technologies can recognize and use to let users know what is going on. Here we'll show how to use it at a basic level to improve accessibility.

Accessible multimedia

Another category of content that can create accessibility problems is multimedia — video, audio, and image content need to be given proper textual alternatives, so they can be understood by assistive technologies and their users. This article shows how.

Mobile accessibility

With web access on mobile devices being so popular, and popular platforms such as iOS and Android having fully-fledged accessibility tools, it is important to consider the accessibility of your web content on these platforms. This article looks at mobile-specific accessibility considerations.

Accessibility troubleshooting Challenge

In this challenge, we present to you a simple site with several accessibility issues that you need to diagnose and fix.

See also
Start Building Accessible Web Applications Today

An excellent series of video tutorials by Marcy Sutton.

Deque University resources

Includes code examples, screen reader references, and other useful resources.

WebAIM resources

Includes guides, checklists, tools, and more.

Web Accessibility Evaluation Tools List

Includes a list of web accessibility evaluation tools.

Learn Accessible Web Design MDN learning partner

Scrimba's Learn Accessible Web Design course teaches you how to write accessible HTML by solving interactive coding challenges and fixing a real-world website.


 Overview: Core learning modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 15, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nAccessibility on the web Overview: Core learning modules Next  
Access to web content such as public services, education, e-commerce sites, and entertainment is a human right. No one should be excluded based on disability, race, geography, or other human characteristics. This module discusses the best practices and techniques you should learn to make your websites as accessible as possible.PrerequisitesYou should be familiar with HTML, CSS, and JavaScript before starting this module.

Note:
If you are working on a computer/tablet/other devices where you don't have the ability to create your own files, you can try out most of the code examples in an online coding program such as JS Bin or Glitch.
Tutorials and challenges
What is accessibility?

This article starts off the module with a good look at what accessibility is — this includes what groups of people we need to consider and why, what tools different people use to interact with the web, and how we can make accessibility part of our web development workflow.

Accessibility tooling and assistive technology

Next we turn our attention to accessibility tooling, providing information on the kinds of tools you can use to help solve accessibility issues, and the assistive technologies used by people with disabilities as they browse the web. You'll be using these tools throughout subsequent articles.

HTML: A good basis for accessibility

A great deal of web content can be made accessible just by making sure the correct HTML elements are always used for the correct purpose. This article looks in detail at how HTML can be used to ensure maximum accessibility.

CSS and JavaScript accessibility best practices

CSS and JavaScript, when used properly, also have the potential to allow for accessible web experiences, but if misused they can significantly harm accessibility. This article outlines some CSS and JavaScript best practices that should be considered to ensure that even complex content is as accessible as possible.

WAI-ARIA basics

Following on from the previous article, sometimes making complex UI controls that involve unsemantic HTML and dynamic JavaScript-updated content can be difficult. WAI-ARIA is a technology that can help with such problems by adding in further semantics that browsers and assistive technologies can recognize and use to let users know what is going on. Here we'll show how to use it at a basic level to improve accessibility.

Accessible multimedia

Another category of content that can create accessibility problems is multimedia — video, audio, and image content need to be given proper textual alternatives, so they can be understood by assistive technologies and their users. This article shows how.

Mobile accessibility

With web access on mobile devices being so popular, and popular platforms such as iOS and Android having fully-fledged accessibility tools, it is important to consider the accessibility of your web content on these platforms. This article looks at mobile-specific accessibility considerations.

Accessibility troubleshooting Challenge

In this challenge, we present to you a simple site with several accessibility issues that you need to diagnose and fix.

See also
Start Building Accessible Web Applications Today

An excellent series of video tutorials by Marcy Sutton.

Deque University resources

Includes code examples, screen reader references, and other useful resources.

WebAIM resources

Includes guides, checklists, tools, and more.

Web Accessibility Evaluation Tools List

Includes a list of web accessibility evaluation tools.

Learn Accessible Web Design MDN learning partner

Scrimba's Learn Accessible Web Design course teaches you how to write accessible HTML by solving interactive coding challenges and fixing a real-world website.


 Overview: Core learning modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 15, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nMore MDN. Your MDN.Support MDN and make it your own.Get startedWhat's includedGo ads freeEnjoy MDN ads-free with an MDN Plus subscription.Support MDN and enjoy a focused, ad-free experience alongside other features such as curated collections, custom web platform updates, offline access, and more. Subscribers to paid tiers of MDN Plus have the option to browse MDN without ads.Learn more →AI HelpGet real-time assistance and support.No need to scroll through page after page to find your answers. Introducing an AI assistant that can answer all your web development questions in real time. Powered by OpenAI GPT-4o and GPT-4o mini.Learn more →PlaygroundWrite,Test and Share your code.Your playground to learn and share your amazing work with the world. By simply logging in, you can now spread your creativity far and wide.Learn more →UpdatesCompatibility changes at a glance.Filter and sort updates that matter most to build your projectThe Web doesn't have a changelog, but MDN can help. You can personalize and filter compatibility changes based on browsers or the tech category you are interested in whether that is JavaScript, CSS, etc.Learn more →CollectionsBuild your perfect library. Or let us build it for you.No more haphazard hunting through the vast virtual library: unleash your inner curator and collect your favorite articles in one place for convenient consultation.Learn more →Loading available plans…* Do you need MDN Plus for your company? Let us know and we’ll get back to you when it becomes available.\n\nMore MDN. Your MDN.Support MDN and make it your own.Get startedWhat's includedGo ads freeEnjoy MDN ads-free with an MDN Plus subscription.Support MDN and enjoy a focused, ad-free experience alongside other features such as curated collections, custom web platform updates, offline access, and more. Subscribers to paid tiers of MDN Plus have the option to browse MDN without ads.Learn more →AI HelpGet real-time assistance and support.No need to scroll through page after page to find your answers. Introducing an AI assistant that can answer all your web development questions in real time. Powered by OpenAI GPT-4o and GPT-4o mini.Learn more →PlaygroundWrite,Test and Share your code.Your playground to learn and share your amazing work with the world. By simply logging in, you can now spread your creativity far and wide.Learn more →UpdatesCompatibility changes at a glance.Filter and sort updates that matter most to build your projectThe Web doesn't have a changelog, but MDN can help. You can personalize and filter compatibility changes based on browsers or the tech category you are interested in whether that is JavaScript, CSS, etc.Learn more →CollectionsBuild your perfect library. Or let us build it for you.No more haphazard hunting through the vast virtual library: unleash your inner curator and collect your favorite articles in one place for convenient consultation.Learn more →Loading available plans…* Do you need MDN Plus for your company? Let us know and we’ll get back to you when it becomes available.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOverview

More MDN. Your MDN. Get started.
This page is an overview of the MDN Plus documentation and related resources.

MDN Plus is a premium subscription service launched by Mozilla. The service
allows users to customize their MDN Web Docs experience through premium features
such as Collections, filtering Updates and MDN Offline.
Learn more about MDN Plus on our website or in this
blogpost.\n\nOverview

More MDN. Your MDN. Get started.
This page is an overview of the MDN Plus documentation and related resources.

MDN Plus is a premium subscription service launched by Mozilla. The service
allows users to customize their MDN Web Docs experience through premium features
such as Collections, filtering Updates and MDN Offline.
Learn more about MDN Plus on our website or in this
blogpost.\n\nOverview

More MDN. Your MDN. Get started.
This page is an overview of the MDN Plus documentation and related resources.

MDN Plus is a premium subscription service launched by Mozilla. The service
allows users to customize their MDN Web Docs experience through premium features
such as Collections, filtering Updates and MDN Offline.
Learn more about MDN Plus on our website or in this
blogpost.\n\n\n\nFrequently asked questionsWhat is MDN Plus?MDN Plus is a premium subscription service launched in March 2022 by Mozilla.
The service allows users to customize their MDN Web Docs experience through
premium features such as Updates,
Collections and
MDN Offline.Why are we working on premium features on MDN?The extensive research we have done in 2020 and 2021 showed us that MDN users
would appreciate a customized experience on MDN. We’ve got information on what
you would find useful and what you would be interested in. All the premium
features we propose today reflect that feedback. MDN Plus is an initial step
towards making the experience on the site more interactive and helpful for our
users.How much does MDN Plus cost?A three-tiered pricing model has been put in place in order to try and
accommodate our users’ needs as much as possible:

MDN Core - A free plan, for those ones who want to try out a limited version
of the premium features.
MDN Plus 5 - A $5/month or $50/year plan that offers unlimited access to the
premium features included in MDN Plus.
MDN Supporter 10 - A $10/month or $100/year plan for users who want to
support MDN with a higher amount. On top of the MDN Plus premium features, MDN
supporters will be able to contribute and shape the product moving forward, by
having early access to premium features and a direct feedback channel with the
MDN team.

Subscribing for a yearly plan activates a 20% discount for all the paid options.Can I upgrade/downgrade my plan?Currently, you can only upgrade your plan. For getting a downgrade, please
cancel your current subscription first and then activate the new one.What is happening with the existing MDN Web Docs?Nothing. We will continue to develop & maintain our web documentation that will
remain free and accessible for everyone. There will be no change there. Even
more, we believe that MDN Web Docs will benefit from MDN Plus, as we plan to
reinvest part of the gains from MDN Plus and improve our documentation as well
as the overall user experience on the website.Are we violating any OS license obligation by adding a paid product to MDN?MDN content is made available under a CC BY-SA 2.5 license. That license doesn't
preclude Mozilla (or other users of MDN content) from having a paid product. MDN
Plus adds premium features like updates and collections on top of the free
content. Regular users can still access and reuse MDN content under the Creative
Commons license.Where will the money from MDN Plus go?Since its beginning in 2005, MDN Web Docs has been a project hosted and provided
by Mozilla. Mozilla covers the cost of infrastructure, development and
maintenance of the MDN platform, including a team of engineers and its own team
of dedicated writers.
Mozilla wants MDN Plus to help ensure that MDN's open source content continues
to be supported into the future. MDN Plus has been built only with Mozilla
resources, and any revenue generated by MDN Plus will stay within Mozilla. We
are looking into ways to reinvest some of these additional funds into open
source projects contributing to MDN but it is still in the early stages.Does the launch of MDN Plus impact the relationship with partners like OWD?The existence of a new subscription model will not detract from MDN's current
free Web Docs offering in any way. The current experience of accessing web
documentation will not change for users who do not wish to sign up for a premium
subscription. Open Web Docs (OWD) and Mozilla will continue to work closely
together on MDN for the best possible web platform documentation for everyone.
For more information about how our organizations work together, please check
this article.What regions is MDN Plus available in?The free version of MDN Plus is available worldwide. Anyone can create an MDN
Plus account and try out a limited version of the premium features. As for the
paid plans, they are currently available as follows: in the United States,
Canada (since March 24th, 2022), Austria, Belgium, Finland, France, the United
Kingdom, Germany, Ireland, Italy, Malaysia, the Netherlands, New Zealand, Puerto
Rico, Sweden, Singapore, Switzerland, Spain (since April 28th, 2022), Estonia,
Greece, Latvia, Lithuania, Portugal, Slovakia and Slovenia (since June 15th,
2022). We are working on expanding this list even further.I have an idea for MDN Plus, who should I contact?In case you have an idea you would like to share about MDN Plus, you can add
your suggestions to our mdn-community
repo.
If a subscriber, you can also leave us feedback by accessing the ‘Feedback’
option in the user menu.\n\nFrequently asked questionsWhat is MDN Plus?MDN Plus is a premium subscription service launched in March 2022 by Mozilla.
The service allows users to customize their MDN Web Docs experience through
premium features such as Updates,
Collections and
MDN Offline.Why are we working on premium features on MDN?The extensive research we have done in 2020 and 2021 showed us that MDN users
would appreciate a customized experience on MDN. We’ve got information on what
you would find useful and what you would be interested in. All the premium
features we propose today reflect that feedback. MDN Plus is an initial step
towards making the experience on the site more interactive and helpful for our
users.How much does MDN Plus cost?A three-tiered pricing model has been put in place in order to try and
accommodate our users’ needs as much as possible:

MDN Core - A free plan, for those ones who want to try out a limited version
of the premium features.
MDN Plus 5 - A $5/month or $50/year plan that offers unlimited access to the
premium features included in MDN Plus.
MDN Supporter 10 - A $10/month or $100/year plan for users who want to
support MDN with a higher amount. On top of the MDN Plus premium features, MDN
supporters will be able to contribute and shape the product moving forward, by
having early access to premium features and a direct feedback channel with the
MDN team.

Subscribing for a yearly plan activates a 20% discount for all the paid options.Can I upgrade/downgrade my plan?Currently, you can only upgrade your plan. For getting a downgrade, please
cancel your current subscription first and then activate the new one.What is happening with the existing MDN Web Docs?Nothing. We will continue to develop & maintain our web documentation that will
remain free and accessible for everyone. There will be no change there. Even
more, we believe that MDN Web Docs will benefit from MDN Plus, as we plan to
reinvest part of the gains from MDN Plus and improve our documentation as well
as the overall user experience on the website.Are we violating any OS license obligation by adding a paid product to MDN?MDN content is made available under a CC BY-SA 2.5 license. That license doesn't
preclude Mozilla (or other users of MDN content) from having a paid product. MDN
Plus adds premium features like updates and collections on top of the free
content. Regular users can still access and reuse MDN content under the Creative
Commons license.Where will the money from MDN Plus go?Since its beginning in 2005, MDN Web Docs has been a project hosted and provided
by Mozilla. Mozilla covers the cost of infrastructure, development and
maintenance of the MDN platform, including a team of engineers and its own team
of dedicated writers.
Mozilla wants MDN Plus to help ensure that MDN's open source content continues
to be supported into the future. MDN Plus has been built only with Mozilla
resources, and any revenue generated by MDN Plus will stay within Mozilla. We
are looking into ways to reinvest some of these additional funds into open
source projects contributing to MDN but it is still in the early stages.Does the launch of MDN Plus impact the relationship with partners like OWD?The existence of a new subscription model will not detract from MDN's current
free Web Docs offering in any way. The current experience of accessing web
documentation will not change for users who do not wish to sign up for a premium
subscription. Open Web Docs (OWD) and Mozilla will continue to work closely
together on MDN for the best possible web platform documentation for everyone.
For more information about how our organizations work together, please check
this article.What regions is MDN Plus available in?The free version of MDN Plus is available worldwide. Anyone can create an MDN
Plus account and try out a limited version of the premium features. As for the
paid plans, they are currently available as follows: in the United States,
Canada (since March 24th, 2022), Austria, Belgium, Finland, France, the United
Kingdom, Germany, Ireland, Italy, Malaysia, the Netherlands, New Zealand, Puerto
Rico, Sweden, Singapore, Switzerland, Spain (since April 28th, 2022), Estonia,
Greece, Latvia, Lithuania, Portugal, Slovakia and Slovenia (since June 15th,
2022). We are working on expanding this list even further.I have an idea for MDN Plus, who should I contact?In case you have an idea you would like to share about MDN Plus, you can add
your suggestions to our mdn-community
repo.
If a subscriber, you can also leave us feedback by accessing the ‘Feedback’
option in the user menu.\n\nFrequently asked questionsWhat is MDN Plus?MDN Plus is a premium subscription service launched in March 2022 by Mozilla.
The service allows users to customize their MDN Web Docs experience through
premium features such as Updates,
Collections and
MDN Offline.Why are we working on premium features on MDN?The extensive research we have done in 2020 and 2021 showed us that MDN users
would appreciate a customized experience on MDN. We’ve got information on what
you would find useful and what you would be interested in. All the premium
features we propose today reflect that feedback. MDN Plus is an initial step
towards making the experience on the site more interactive and helpful for our
users.How much does MDN Plus cost?A three-tiered pricing model has been put in place in order to try and
accommodate our users’ needs as much as possible:

MDN Core - A free plan, for those ones who want to try out a limited version
of the premium features.
MDN Plus 5 - A $5/month or $50/year plan that offers unlimited access to the
premium features included in MDN Plus.
MDN Supporter 10 - A $10/month or $100/year plan for users who want to
support MDN with a higher amount. On top of the MDN Plus premium features, MDN
supporters will be able to contribute and shape the product moving forward, by
having early access to premium features and a direct feedback channel with the
MDN team.

Subscribing for a yearly plan activates a 20% discount for all the paid options.Can I upgrade/downgrade my plan?Currently, you can only upgrade your plan. For getting a downgrade, please
cancel your current subscription first and then activate the new one.What is happening with the existing MDN Web Docs?Nothing. We will continue to develop & maintain our web documentation that will
remain free and accessible for everyone. There will be no change there. Even
more, we believe that MDN Web Docs will benefit from MDN Plus, as we plan to
reinvest part of the gains from MDN Plus and improve our documentation as well
as the overall user experience on the website.Are we violating any OS license obligation by adding a paid product to MDN?MDN content is made available under a CC BY-SA 2.5 license. That license doesn't
preclude Mozilla (or other users of MDN content) from having a paid product. MDN
Plus adds premium features like updates and collections on top of the free
content. Regular users can still access and reuse MDN content under the Creative
Commons license.Where will the money from MDN Plus go?Since its beginning in 2005, MDN Web Docs has been a project hosted and provided
by Mozilla. Mozilla covers the cost of infrastructure, development and
maintenance of the MDN platform, including a team of engineers and its own team
of dedicated writers.
Mozilla wants MDN Plus to help ensure that MDN's open source content continues
to be supported into the future. MDN Plus has been built only with Mozilla
resources, and any revenue generated by MDN Plus will stay within Mozilla. We
are looking into ways to reinvest some of these additional funds into open
source projects contributing to MDN but it is still in the early stages.Does the launch of MDN Plus impact the relationship with partners like OWD?The existence of a new subscription model will not detract from MDN's current
free Web Docs offering in any way. The current experience of accessing web
documentation will not change for users who do not wish to sign up for a premium
subscription. Open Web Docs (OWD) and Mozilla will continue to work closely
together on MDN for the best possible web platform documentation for everyone.
For more information about how our organizations work together, please check
this article.What regions is MDN Plus available in?The free version of MDN Plus is available worldwide. Anyone can create an MDN
Plus account and try out a limited version of the premium features. As for the
paid plans, they are currently available as follows: in the United States,
Canada (since March 24th, 2022), Austria, Belgium, Finland, France, the United
Kingdom, Germany, Ireland, Italy, Malaysia, the Netherlands, New Zealand, Puerto
Rico, Sweden, Singapore, Switzerland, Spain (since April 28th, 2022), Estonia,
Greece, Latvia, Lithuania, Portugal, Slovakia and Slovenia (since June 15th,
2022). We are working on expanding this list even further.I have an idea for MDN Plus, who should I contact?In case you have an idea you would like to share about MDN Plus, you can add
your suggestions to our mdn-community
repo.
If a subscriber, you can also leave us feedback by accessing the ‘Feedback’
option in the user menu.\n\n\n\nMDN CurriculumThe essential skillset for new front-end developersThe MDN Curriculum provides a structured guide to the essential skills and practices for being a successful front-end developer, along with recommended learning resources.
Last updated: February 2024About the curriculum
Beginner's level
Self-paced
Free

Defines the essential skills and knowledge every front-end developer needs for career success and industry relevance.
Created by Mozilla and refined with insights from students, educators, and developers from the broader web community.
Includes learning resource recommendations covering every curriculum topic, helping you become job-ready.
Learn moreLearn our curriculum with Scrimba's interactive Frontend Developer Career Path.ModulesGetting started1. Soft skillsDevelop a great attitude towards learning, researching, and collaborating to enhance your chances of success.Best Practices2. Environment setupFamiliarize yourself with your development environment and the tools you'll use to build websites.ToolingLet's beginCore1. Web standardsUnderstand how the web works at a high level, and the process for creating web technologies.Web Standards & Semantics2. Semantic HTMLLearn the fundamentals of HTML, the language used to define and structure web content.Web Standards & Semantics3. CSS fundamentalsDive into the fundamentals of CSS, the language you'll use to style and layout websites.Styling4. CSS text stylingFocus on using CSS to style text and apply custom web fonts.Styling5. CSS layoutLearn modern techniques for creating flexible layouts that work on a wide variety of devices.Styling6. JavaScript fundamentalsFocus on the core JavaScript language and fundamental surrounding topics.Scripting7. AccessibilityUnderstand the need for universal access to web content and how to write accessible code.Best Practices8. Design for developersAppreciate basic design theory, how to speak design language, and what makes websites look good.Best Practices9. Version controlUnderstand why version control is necessary, and use GitHub to store code and collaborate with others.ToolingLet's beginExtensions1. Transform & animate CSSAdd animations to your toolbox to enhance user experience and perceived performance.Web Standards & Semantics2. Custom JS objectsCreate custom JavaScript objects to gain a deeper understanding of object-oriented programming.Scripting3. Web APIsStudy common WebAPIs in depth to appreciate how WebAPIs work in general.Scripting4. PerformanceExplore how to create performant, fast-loading websites and enhance perceived performance.Best Practices5. Security and privacyLearn how to protect data from unauthorized access and how to treat user data responsibly.Best Practices6. TestingExplore the need for testing, and learn how to implement common test types.Best Practices7. JavaScript frameworksStudy the features of popular JavaScript frameworks, and use them to implement common use cases.Tooling8. CSS toolingLook at popular CSS tooling and understand what code problems they can solve.Tooling9. Other tooling typesUnderstand the purpose and usage of other tooling types commonly found in a web project.ToolingLet's beginLearn the curriculum with Scrimba and become job readyScrimba's Frontend Developer Career Path teaches the MDN Curriculum Core with fun interactive lessons and challenges, knowledgeable teachers, and a supportive community. Go from zero to landing your first front-end job!Find out moreHow can youboost your employability with the MDNCurriculum?Learn about research collaboration and other essential soft skills.Balance between modern tooling and long-term best practices.Get access to high-quality recommended resources.Get guidance from trusted voices.Don't know where toget started? 

Starting out with coding?
Begin with our "Getting started" and "Core" modules to grasp the essential skills for web development.
Core modules


Beyond the basics?
Dive deeper with our "Extensions" modules to develop specialized skills.
Extensions modules


Seeking employment?
Our "Soft skills" module, part of "Getting started", offers crucial insights to help you land your job.
Getting started modules


Working at a school?
Use our modules to guide your teaching, or enroll your students in Scrimba's Frontend Path.
Frontend Path\n\nMDN CurriculumThe essential skillset for new front-end developersThe MDN Curriculum provides a structured guide to the essential skills and practices for being a successful front-end developer, along with recommended learning resources.
Last updated: February 2024About the curriculum
Beginner's level
Self-paced
Free

Defines the essential skills and knowledge every front-end developer needs for career success and industry relevance.
Created by Mozilla and refined with insights from students, educators, and developers from the broader web community.
Includes learning resource recommendations covering every curriculum topic, helping you become job-ready.
Learn moreLearn our curriculum with Scrimba's interactive Frontend Developer Career Path.ModulesGetting started1. Soft skillsDevelop a great attitude towards learning, researching, and collaborating to enhance your chances of success.Best Practices2. Environment setupFamiliarize yourself with your development environment and the tools you'll use to build websites.ToolingLet's beginCore1. Web standardsUnderstand how the web works at a high level, and the process for creating web technologies.Web Standards & Semantics2. Semantic HTMLLearn the fundamentals of HTML, the language used to define and structure web content.Web Standards & Semantics3. CSS fundamentalsDive into the fundamentals of CSS, the language you'll use to style and layout websites.Styling4. CSS text stylingFocus on using CSS to style text and apply custom web fonts.Styling5. CSS layoutLearn modern techniques for creating flexible layouts that work on a wide variety of devices.Styling6. JavaScript fundamentalsFocus on the core JavaScript language and fundamental surrounding topics.Scripting7. AccessibilityUnderstand the need for universal access to web content and how to write accessible code.Best Practices8. Design for developersAppreciate basic design theory, how to speak design language, and what makes websites look good.Best Practices9. Version controlUnderstand why version control is necessary, and use GitHub to store code and collaborate with others.ToolingLet's beginExtensions1. Transform & animate CSSAdd animations to your toolbox to enhance user experience and perceived performance.Web Standards & Semantics2. Custom JS objectsCreate custom JavaScript objects to gain a deeper understanding of object-oriented programming.Scripting3. Web APIsStudy common WebAPIs in depth to appreciate how WebAPIs work in general.Scripting4. PerformanceExplore how to create performant, fast-loading websites and enhance perceived performance.Best Practices5. Security and privacyLearn how to protect data from unauthorized access and how to treat user data responsibly.Best Practices6. TestingExplore the need for testing, and learn how to implement common test types.Best Practices7. JavaScript frameworksStudy the features of popular JavaScript frameworks, and use them to implement common use cases.Tooling8. CSS toolingLook at popular CSS tooling and understand what code problems they can solve.Tooling9. Other tooling typesUnderstand the purpose and usage of other tooling types commonly found in a web project.ToolingLet's beginLearn the curriculum with Scrimba and become job readyScrimba's Frontend Developer Career Path teaches the MDN Curriculum Core with fun interactive lessons and challenges, knowledgeable teachers, and a supportive community. Go from zero to landing your first front-end job!Find out moreHow can youboost your employability with the MDNCurriculum?Learn about research collaboration and other essential soft skills.Balance between modern tooling and long-term best practices.Get access to high-quality recommended resources.Get guidance from trusted voices.Don't know where toget started? 

Starting out with coding?
Begin with our "Getting started" and "Core" modules to grasp the essential skills for web development.
Core modules


Beyond the basics?
Dive deeper with our "Extensions" modules to develop specialized skills.
Extensions modules


Seeking employment?
Our "Soft skills" module, part of "Getting started", offers crucial insights to help you land your job.
Getting started modules


Working at a school?
Use our modules to guide your teaching, or enroll your students in Scrimba's Frontend Path.
Frontend Path\n\nMDN CurriculumThe essential skillset for new front-end developersThe MDN Curriculum provides a structured guide to the essential skills and practices for being a successful front-end developer, along with recommended learning resources.
Last updated: February 2024About the curriculum
Beginner's level
Self-paced
Free

Defines the essential skills and knowledge every front-end developer needs for career success and industry relevance.
Created by Mozilla and refined with insights from students, educators, and developers from the broader web community.
Includes learning resource recommendations covering every curriculum topic, helping you become job-ready.
Learn moreLearn our curriculum with Scrimba's interactive Frontend Developer Career Path.ModulesGetting started1. Soft skillsDevelop a great attitude towards learning, researching, and collaborating to enhance your chances of success.Best Practices2. Environment setupFamiliarize yourself with your development environment and the tools you'll use to build websites.ToolingLet's beginCore1. Web standardsUnderstand how the web works at a high level, and the process for creating web technologies.Web Standards & Semantics2. Semantic HTMLLearn the fundamentals of HTML, the language used to define and structure web content.Web Standards & Semantics3. CSS fundamentalsDive into the fundamentals of CSS, the language you'll use to style and layout websites.Styling4. CSS text stylingFocus on using CSS to style text and apply custom web fonts.Styling5. CSS layoutLearn modern techniques for creating flexible layouts that work on a wide variety of devices.Styling6. JavaScript fundamentalsFocus on the core JavaScript language and fundamental surrounding topics.Scripting7. AccessibilityUnderstand the need for universal access to web content and how to write accessible code.Best Practices8. Design for developersAppreciate basic design theory, how to speak design language, and what makes websites look good.Best Practices9. Version controlUnderstand why version control is necessary, and use GitHub to store code and collaborate with others.ToolingLet's beginExtensions1. Transform & animate CSSAdd animations to your toolbox to enhance user experience and perceived performance.Web Standards & Semantics2. Custom JS objectsCreate custom JavaScript objects to gain a deeper understanding of object-oriented programming.Scripting3. Web APIsStudy common WebAPIs in depth to appreciate how WebAPIs work in general.Scripting4. PerformanceExplore how to create performant, fast-loading websites and enhance perceived performance.Best Practices5. Security and privacyLearn how to protect data from unauthorized access and how to treat user data responsibly.Best Practices6. TestingExplore the need for testing, and learn how to implement common test types.Best Practices7. JavaScript frameworksStudy the features of popular JavaScript frameworks, and use them to implement common use cases.Tooling8. CSS toolingLook at popular CSS tooling and understand what code problems they can solve.Tooling9. Other tooling typesUnderstand the purpose and usage of other tooling types commonly found in a web project.ToolingLet's beginLearn the curriculum with Scrimba and become job readyScrimba's Frontend Developer Career Path teaches the MDN Curriculum Core with fun interactive lessons and challenges, knowledgeable teachers, and a supportive community. Go from zero to landing your first front-end job!Find out moreHow can youboost your employability with the MDNCurriculum?Learn about research collaboration and other essential soft skills.Balance between modern tooling and long-term best practices.Get access to high-quality recommended resources.Get guidance from trusted voices.Don't know where toget started? 

Starting out with coding?
Begin with our "Getting started" and "Core" modules to grasp the essential skills for web development.
Core modules


Beyond the basics?
Dive deeper with our "Extensions" modules to develop specialized skills.
Extensions modules


Seeking employment?
Our "Soft skills" module, part of "Getting started", offers crucial insights to help you land your job.
Getting started modules


Working at a school?
Use our modules to guide your teaching, or enroll your students in Scrimba's Frontend Path.
Frontend Path\n\n\n\nDefault styles for h1 elements are changingSimon PietersApril 11, 20254 minute readBrowsers are starting to roll out changes in default UA styles for nested section headings. This post describes the incoming changes, how to identify if it's an issue on your websites, and hints for conformant and better-structured pages.
Read more →Implications of Global Privacy ControlLola OdelolaMarch 15, 20255 minute readGlobal Privacy Control (GPC) is on the way to becoming a formal privacy standard with the recent publication of its first working draft. Let's take a look at what the implications are for developers and users.Read more →JavaScript Temporal is comingBrian SmithJanuary 24, 20255 minute readA new way to handle dates and times is being added to JavaScript. Let's take a look at Temporal, what problems it solves, the current state, and what you'll find in the new documentation about it on MDN.
Read more →Fix your website's Largest Contentful Paint by optimizing image loadingDebugBearJanuary 13, 202510 minute readLearn techniques to improve the Largest Contentful Paint metric, a part of Core Web Vitals, for your website.
SponsoredRead more →MDN 2024 content projectsVadim MakeevJanuary 8, 20259 minute readLet's have a look at MDN Web Docs content projects in 2024, with highlights of our top picks and recommended reading, and at what's next on MDN for 2025.
Read more →A new learning experience on MDNRuth JohnDecember 20, 20244 minute readThere's a new Learn Web Development section on MDN that merges the MDN Curriculum with the Learn section. Here's the background to these changes, what's new, and what you can expect to see in the future.
Read more →Countdown to the holidays with daily coding challengesSonal SoodDecember 1, 20242 minute readJoin JavaScriptmas this December for daily coding challenges designed to boost your skills and bring festive fun. Solve challenges on Scrimba, learn something new, and take part for a chance to win exciting prizes!
Read more →Monitoring and optimizing website performanceDebugBearNovember 11, 202412 minute readLearn about reading network request waterfalls, identifying common network performance issues, and optimizing page rendering.
SponsoredRead more →How to land your first developer jobPer BorgenNovember 1, 202411 minute readHere are six effective strategies for landing your first developer job. These are especially relevant if you're self-taught or breaking into the tech industry without a traditional CS degree.
SponsoredRead more →Introducing the new MDN Community pagePranshu KhannaOctober 15, 20245 minute readWe are thrilled to announce the new MDN community page that will be a hub to recognize our contributors and a place for contributors to get involved.
Read more →Fixing your website's JavaScript performanceDebugBearOctober 9, 20249 minute readLearn about lesser-known web performance bottlenecks connected to excessive JavaScript usage, like long tasks, large bundle sizes, and hydration issues.
SponsoredRead more →Get back to school! Supercharge your learning with MDN and ScrimbaHermina CondeiSeptember 12, 20242 minute readFor many of us, the holidays are over, and the time has come to focus.  Now is an ideal time to dive into learning web development, and you're in luck — MDN and Scrimba are offering a 30% discount on select courses for the next month!
Read more →Efficient data handling with the Streams APIVultrSeptember 6, 20246 minute readThis post demonstrates how to use the Streams API in a web application to fetch and transform text on the fly.  By processing the data as it arrives, this approach enhances performance, responsiveness, and resource efficiency.
SponsoredRead more →Locale-sensitive text segmentation in JavaScript with Intl.SegmenterBrian SmithSeptember 3, 20245 minute readLearn how to use Intl.Segmenter for locale-sensitive text segmentation in JavaScript to simplify localization, count words or sentences in different languages, and more.Read more →Optimize your workflow with Git stashGitLabAugust 28, 20248 minute readLearn how to use Git stash to break down large commits. Discover a better approach for saving work when switching branches.SponsoredRead more →How to debug mobile apps across devicesLambdaTestAugust 7, 20248 minute readThis post explores what mobile app debugging is, commonly used techniques, and how you can debug mobile apps on multiple devices.SponsoredRead more →Exclusive accordions using the HTML details elementBrian SmithAugust 5, 20243 minute readThe 'name' attribute of the HTML details element is gaining more support across browsers. Learn how this feature allows creating exclusive accordions without scripting widgets from scratch.Read more →Exploring the Broadcast Channel API for cross-tab communicationVultrJuly 12, 20244 minute readThis article explains how to use the Broadcast Channel API to build synchronized and interconnected web applications.SponsoredRead more →MDN partners with Scrimba to enhance web development learningHermina CondeiJuly 9, 20246 minute readWe have chosen Scrimba as a course partner for the MDN Curriculum. This blog post explores what the partnership means practically, and how we will provide an even better web education experience together.Read more →Introducing the MDN HTTP ObservatoryHermina CondeiJuly 2, 20247 minute readFirst released in 2016, the HTTP Observatory became popular in the web community with a combination of helpful security audits and educational material. Fast forward to 2024, and we are delighted to announce that Observatory's new home is MDN. Read on to find out more about what this entails, and give the HTTP Observatory a warm welcome!Read more →Static Site Generation (SSG) with Next.jsVultrJune 28, 20247 minute readThis guide explains how to use Static Site Generation in Next.js to build scalable and secure web applications with fast loading times and a focus on performance.SponsoredRead more →New JavaScript Set methodsBrian SmithJune 24, 20245 minute readNew JavaScript Set methods are landing across browsers. Learn about sets, how you can use these methods to compare different sets, create new sets with specific properties, and more.Read more →Securing APIs: Express rate limit and slow downVultrMay 28, 20246 minute readThis guide introduces you to rate limits and slow down mechanisms. Learn how to apply slow down and rate limit mechanisms in Express applications.SponsoredRead more →Using the Page Visibility APIBrian SmithMay 10, 20246 minute readThis post takes a look at what page visibility is, how you can use the Page Visibility API in your applications, and describes pitfalls to avoid if you build features around this functionality.Read more →A year of publishing the MDN BlogThe MDN TeamMay 3, 20245 minute readWe've been writing about web development and the web platform on the MDN Blog since May 2023. Here's our highlights and top posts along with our favorites.Read more →Setting up service workers on VultrVultrApril 23, 20246 minute readThis guide introduces you to service workers and their lifecycle. Learn how to deploy a project using service workers with HTTPS on Vultr.SponsoredRead more →Interop 2023: MDN updatesBrian SmithMarch 27, 20246 minute readInterop 2023 has successfully concluded, and the Interop 2024 project is now officially underway. Learn what Interop is, discover the updates from Interop 2023 now on MDN, and find out what's coming to the web next.Read more →Testing JavaScript with Jest on VultrVultrMarch 22, 20247 minute readThis guide introduces you to the common types of tests and the testing conventions. Learn how to test JavaScript with Jest on Vultr.SponsoredRead more →Creating color palettes with the CSS color-mix() functionMichelle BarkerMarch 8, 20247 minute readWorking with colors on the web just got more interesting! In this article, we’ll explore how to use the CSS color-mix() function to create variations in color palettes.Read more →Modernizing conventional test automation with TestGridTestGridFebruary 29, 202412 minute readThis post reflects on the conventional test automation methods using Selenium and Appium. Learn how you can use TestGrid's unified testing platform to enhance the conventional methods and also leverage the modern codeless testing techniques.SponsoredRead more →Lift-off: The MDN Curriculum launchHermina CondeiFebruary 27, 20246 minute readThe long-awaited MDN Curriculum is now live on MDN, providing a structured guide to the essential front-end development skills and best practices for industry newcomers. Learn all the key details in this article.Read more →Creating effective technical documentationDipika BhattacharyaFebruary 13, 20247 minute readThis article provides an overview of the core components required for creating effective technical documentation. Learn the best practices to make your documentation clear, consistent, and well-structured.Read more →Leveraging Bun on Vultr: A superior Node.js alternativeVultrJanuary 17, 20245 minute readThis guide explains Bun functionalities as a runtime package manager and a bundler. It also explains the benefits of built-in Bun APIs and how to use Bun's Vultr marketplace application.SponsoredRead more →Border images in CSS: A key focus area for Interop 2023Dipika BhattacharyaDecember 19, 202310 minute readAligning with Interop 2023's emphasis on cross-browser consistency, this post walks you through various `border-image` properties that you can control to create captivating web designs. Learn how to use custom graphics for enhancing the look of your websites that appear consistent across different browsers.Read more →Build AI-powered applications using OpenLLM and Vultr Cloud GPUVultrDecember 12, 20237 minute readLearn how to build AI-powered apps using OpenLLM and Vultr Cloud GPU. This guide shows how to generate API responses using a Large Language Model. It also covers instructions for setting up an Nginx server and implementing SSL security.SponsoredRead more →Saying goodbye to third-party cookies in 2024Chris MillsDecember 8, 20238 minute readThe tail end of 2023 welcomes positive news for web privacy, as Chrome announces it is to join Firefox and Safari in deprecating third-party cookies in 2024. Find out more details about these changes, and what they mean for web developers.Read more →Baseline's evolution on MDNVadim MakeevDecember 5, 20234 minute readToday we're updating the Baseline widgets and introducing a new one, along with the updated definition of Baseline.Read more →Developer essentials: JavaScript console methodsBrian SmithNovember 30, 20236 minute readThe JavaScript console is an essential tool for web development. Learn new and fun ways to use the console to display data and debug your code.Read more →Getting started with CSS container queriesMichelle BarkerNovember 16, 20238 minute readCSS container queries are a powerful new tool for our CSS layout toolbox. In this post we'll dive into the practicalities of building a layout with container queries.Read more →Deploying Node.js applications with PM2 on VultrVultrNovember 8, 20237 minute readLearn how to deploy a Node.js application on Vultr using PM2 to create persistent services. This guide shows how to efficiently use resources via PM2 cluster mode. It also covers Nginx server setup and SSL security.SponsoredRead more →VS Code: Tips and tricks for beginnersDipika BhattacharyaNovember 7, 20238 minute readDiscover essential tips and tricks for using Visual Studio Code (VS Code), a powerful IDE. Learn how to leverage its integrated editing features and Git support, and explore a few extensions.Read more →Coming Soon: MDN Observatory 2.0The MDN TeamOctober 25, 20232 minute readObservatory 2.0 is launching soon as part of the Mozilla Developer Network as the MDN Observatory with new security scoring standards and other exciting updates.Read more →Optimizing DevSecOps workflows with GitLab's conditional CI/CD pipelinesGitLabOctober 23, 20238 minute readThis guide explores the various types of CI/CD pipelines and helps you understand their specific use cases. Learn how to leverage rules to create highly efficient DevSecOps workflows.SponsoredRead more →Introduction to web sustainabilityMichelle BarkerOctober 11, 20238 minute readWhat can web designers and developers do to build a more sustainable web? This post explores the environmental impacts of web technologies and looks at some of the ways we can build greener websites.Read more →Migrating from GitHub to GitLab seamlessly: A step-by-step guideGitLabOctober 5, 20239 minute readThinking about making the move from GitHub to GitLab? This guide demystifies the migration process, addressing common concerns for DevSecOps teams that are looking to seamlessly transition between the two platforms. This post provides a step-by-step guided tutorial on how to migrate your data from GitHub into GitLab.SponsoredRead more →Announcing the MDN front-end developer curriculumThe MDN TeamAugust 14, 20235 minute readMDN has created a curriculum for aspiring front-end developers to build a rewarding and successful career. Take a look at the curriculum, who it's for, and the research it's based on.Read more →Creating custom easing effects in CSS animations using the linear() functionMichelle BarkerAugust 1, 202310 minute readThe new CSS linear() timing function enables custom easing in animations. Explore how linear() works compared with other timing functions used for easing, with practical examples.Read more →Securing your CDN: Why and how should you use SRITerence EdenJuly 21, 20234 minute readRelying on external resources for your website is always fraught with risks. Learn how to protect your website and its visitors by using SRI to secure third-party content.Read more →Scroll progress animations in CSSMichelle BarkerJuly 14, 20237 minute readScroll-driven animations are coming to CSS! In this post, we'll look at a few types of animations and learn how to link them to the scroll progress of a container.Read more →Reflections on AI Explain: A postmortemThe MDN TeamJuly 11, 202310 minute readWe recently launched a feature called AI Explain, but we have rolled this back for now. In this post, we look into the story behind AI Explain: its development, launch, and the reasons that led us to press the pause button.Read more →Developer essentials: How to search code using grepBrian SmithJuly 3, 20239 minute readgrep is a powerful tool for searching code from the terminal. This post will show you how to use grep and why it's an essential developer tool.Read more →Introducing AI Help (Beta): Your Companion for Web DevelopmentHermina CondeiJune 27, 20233 minute readWe're introducing an AI assistant powered by MDN and OpenAI GPT 3.5 to answer all your web development questions in real time.Read more →Learn how to use hue in CSS colors with HSLBrian SmithJune 26, 20237 minute readHues are a bright way to define colors in CSS. Learn about hues, color wheels, how to use color functions, and how you can create vibrant color palettes for your website using hue.Read more →Introducing the MDN Playground: Bring your code to life!Florian DiemingerJune 22, 20236 minute readMDN is launching a code Playground. Users can prototype ideas and expand all live samples into an interactive experience.Read more →MDN doc updates: CSS selectors & media queries, WebGPU & WebTransport APIs, Progressive web appsDipika BhattacharyaJune 13, 20236 minute readDiscover CSS :lang(), experimental media queries, manipulating graphics with WebGPU, client-server communication with WebTransport, ECMAScript module support, and more.Read more →How to draw any regular shape with just one JavaScript functionRuth JohnMay 26, 20234 minute readLearn how to use JavaScript to draw any regular shape to a HTML canvas with a single function, and how to modify it to draw multiple shapes.Read more →New reference pages on MDN for JavaScript regular expressionsBrian SmithMay 23, 20235 minute readSee the latest updates to the MDN reference pages about JavaScript regular expressions, including new sections on sub-features and browser compatibility information.Read more →Celebrating Global Accessibility Awareness DaySchalk NeethlingMay 18, 20236 minute readIn celebration of Global Accessibility Awareness Day in 2023, we share some tools and guidelines to help you make the web more accessible.Read more →Using HTML landmark roles to improve accessibilitySchalk NeethlingMay 15, 202311 minute readLearn what HTML landmark roles are, how they improve accessibility, and how you can include them on your website effectively.Read more →Introducing Baseline: a unified view of stable web featuresHermina CondeiMay 10, 20233 minute readMDN leads the way in implementing WebDX community group's efforts, delivering a clear and simple baseline for the web platform to developers.Read more →How :not() chains multiple selectorsDipika BhattacharyaMay 5, 20234 minute readLearn how the CSS `:not()` pseudo-class behaves when multiple selectors are passed as argument.Read more →New functions, gradients, and hues in CSS colors (Level 4)Brian SmithMay 3, 20239 minute readLearn what's new in CSS Colors Module Level 4, including color spaces, color functions, fancy gradients, and support for wide-gamut displays.Read more →Welcome to the MDN blogRuth JohnMay 3, 20232 minute readThe MDN blog publishes web development news, tutorials, and insights as an extension of MDN Web Docs, helping you discover, learn, and create for the web.Read more →\n\nBlog it betterDefault styles for h1 elements are changingSimon PietersApril 11, 20254 minute readBrowsers are starting to roll out changes in default UA styles for nested section headings. This post describes the incoming changes, how to identify if it's an issue on your websites, and hints for conformant and better-structured pages.
Read more →Implications of Global Privacy ControlLola OdelolaMarch 15, 20255 minute readGlobal Privacy Control (GPC) is on the way to becoming a formal privacy standard with the recent publication of its first working draft. Let's take a look at what the implications are for developers and users.Read more →JavaScript Temporal is comingBrian SmithJanuary 24, 20255 minute readA new way to handle dates and times is being added to JavaScript. Let's take a look at Temporal, what problems it solves, the current state, and what you'll find in the new documentation about it on MDN.
Read more →Fix your website's Largest Contentful Paint by optimizing image loadingDebugBearJanuary 13, 202510 minute readLearn techniques to improve the Largest Contentful Paint metric, a part of Core Web Vitals, for your website.
SponsoredRead more →MDN 2024 content projectsVadim MakeevJanuary 8, 20259 minute readLet's have a look at MDN Web Docs content projects in 2024, with highlights of our top picks and recommended reading, and at what's next on MDN for 2025.
Read more →A new learning experience on MDNRuth JohnDecember 20, 20244 minute readThere's a new Learn Web Development section on MDN that merges the MDN Curriculum with the Learn section. Here's the background to these changes, what's new, and what you can expect to see in the future.
Read more →Countdown to the holidays with daily coding challengesSonal SoodDecember 1, 20242 minute readJoin JavaScriptmas this December for daily coding challenges designed to boost your skills and bring festive fun. Solve challenges on Scrimba, learn something new, and take part for a chance to win exciting prizes!
Read more →Monitoring and optimizing website performanceDebugBearNovember 11, 202412 minute readLearn about reading network request waterfalls, identifying common network performance issues, and optimizing page rendering.
SponsoredRead more →How to land your first developer jobPer BorgenNovember 1, 202411 minute readHere are six effective strategies for landing your first developer job. These are especially relevant if you're self-taught or breaking into the tech industry without a traditional CS degree.
SponsoredRead more →Introducing the new MDN Community pagePranshu KhannaOctober 15, 20245 minute readWe are thrilled to announce the new MDN community page that will be a hub to recognize our contributors and a place for contributors to get involved.
Read more →Fixing your website's JavaScript performanceDebugBearOctober 9, 20249 minute readLearn about lesser-known web performance bottlenecks connected to excessive JavaScript usage, like long tasks, large bundle sizes, and hydration issues.
SponsoredRead more →Get back to school! Supercharge your learning with MDN and ScrimbaHermina CondeiSeptember 12, 20242 minute readFor many of us, the holidays are over, and the time has come to focus.  Now is an ideal time to dive into learning web development, and you're in luck — MDN and Scrimba are offering a 30% discount on select courses for the next month!
Read more →Efficient data handling with the Streams APIVultrSeptember 6, 20246 minute readThis post demonstrates how to use the Streams API in a web application to fetch and transform text on the fly.  By processing the data as it arrives, this approach enhances performance, responsiveness, and resource efficiency.
SponsoredRead more →Locale-sensitive text segmentation in JavaScript with Intl.SegmenterBrian SmithSeptember 3, 20245 minute readLearn how to use Intl.Segmenter for locale-sensitive text segmentation in JavaScript to simplify localization, count words or sentences in different languages, and more.Read more →Optimize your workflow with Git stashGitLabAugust 28, 20248 minute readLearn how to use Git stash to break down large commits. Discover a better approach for saving work when switching branches.SponsoredRead more →How to debug mobile apps across devicesLambdaTestAugust 7, 20248 minute readThis post explores what mobile app debugging is, commonly used techniques, and how you can debug mobile apps on multiple devices.SponsoredRead more →Exclusive accordions using the HTML details elementBrian SmithAugust 5, 20243 minute readThe 'name' attribute of the HTML details element is gaining more support across browsers. Learn how this feature allows creating exclusive accordions without scripting widgets from scratch.Read more →Exploring the Broadcast Channel API for cross-tab communicationVultrJuly 12, 20244 minute readThis article explains how to use the Broadcast Channel API to build synchronized and interconnected web applications.SponsoredRead more →MDN partners with Scrimba to enhance web development learningHermina CondeiJuly 9, 20246 minute readWe have chosen Scrimba as a course partner for the MDN Curriculum. This blog post explores what the partnership means practically, and how we will provide an even better web education experience together.Read more →Introducing the MDN HTTP ObservatoryHermina CondeiJuly 2, 20247 minute readFirst released in 2016, the HTTP Observatory became popular in the web community with a combination of helpful security audits and educational material. Fast forward to 2024, and we are delighted to announce that Observatory's new home is MDN. Read on to find out more about what this entails, and give the HTTP Observatory a warm welcome!Read more →Static Site Generation (SSG) with Next.jsVultrJune 28, 20247 minute readThis guide explains how to use Static Site Generation in Next.js to build scalable and secure web applications with fast loading times and a focus on performance.SponsoredRead more →New JavaScript Set methodsBrian SmithJune 24, 20245 minute readNew JavaScript Set methods are landing across browsers. Learn about sets, how you can use these methods to compare different sets, create new sets with specific properties, and more.Read more →Securing APIs: Express rate limit and slow downVultrMay 28, 20246 minute readThis guide introduces you to rate limits and slow down mechanisms. Learn how to apply slow down and rate limit mechanisms in Express applications.SponsoredRead more →Using the Page Visibility APIBrian SmithMay 10, 20246 minute readThis post takes a look at what page visibility is, how you can use the Page Visibility API in your applications, and describes pitfalls to avoid if you build features around this functionality.Read more →A year of publishing the MDN BlogThe MDN TeamMay 3, 20245 minute readWe've been writing about web development and the web platform on the MDN Blog since May 2023. Here's our highlights and top posts along with our favorites.Read more →Setting up service workers on VultrVultrApril 23, 20246 minute readThis guide introduces you to service workers and their lifecycle. Learn how to deploy a project using service workers with HTTPS on Vultr.SponsoredRead more →Interop 2023: MDN updatesBrian SmithMarch 27, 20246 minute readInterop 2023 has successfully concluded, and the Interop 2024 project is now officially underway. Learn what Interop is, discover the updates from Interop 2023 now on MDN, and find out what's coming to the web next.Read more →Testing JavaScript with Jest on VultrVultrMarch 22, 20247 minute readThis guide introduces you to the common types of tests and the testing conventions. Learn how to test JavaScript with Jest on Vultr.SponsoredRead more →Creating color palettes with the CSS color-mix() functionMichelle BarkerMarch 8, 20247 minute readWorking with colors on the web just got more interesting! In this article, we’ll explore how to use the CSS color-mix() function to create variations in color palettes.Read more →Modernizing conventional test automation with TestGridTestGridFebruary 29, 202412 minute readThis post reflects on the conventional test automation methods using Selenium and Appium. Learn how you can use TestGrid's unified testing platform to enhance the conventional methods and also leverage the modern codeless testing techniques.SponsoredRead more →Lift-off: The MDN Curriculum launchHermina CondeiFebruary 27, 20246 minute readThe long-awaited MDN Curriculum is now live on MDN, providing a structured guide to the essential front-end development skills and best practices for industry newcomers. Learn all the key details in this article.Read more →Creating effective technical documentationDipika BhattacharyaFebruary 13, 20247 minute readThis article provides an overview of the core components required for creating effective technical documentation. Learn the best practices to make your documentation clear, consistent, and well-structured.Read more →Leveraging Bun on Vultr: A superior Node.js alternativeVultrJanuary 17, 20245 minute readThis guide explains Bun functionalities as a runtime package manager and a bundler. It also explains the benefits of built-in Bun APIs and how to use Bun's Vultr marketplace application.SponsoredRead more →Border images in CSS: A key focus area for Interop 2023Dipika BhattacharyaDecember 19, 202310 minute readAligning with Interop 2023's emphasis on cross-browser consistency, this post walks you through various `border-image` properties that you can control to create captivating web designs. Learn how to use custom graphics for enhancing the look of your websites that appear consistent across different browsers.Read more →Build AI-powered applications using OpenLLM and Vultr Cloud GPUVultrDecember 12, 20237 minute readLearn how to build AI-powered apps using OpenLLM and Vultr Cloud GPU. This guide shows how to generate API responses using a Large Language Model. It also covers instructions for setting up an Nginx server and implementing SSL security.SponsoredRead more →Saying goodbye to third-party cookies in 2024Chris MillsDecember 8, 20238 minute readThe tail end of 2023 welcomes positive news for web privacy, as Chrome announces it is to join Firefox and Safari in deprecating third-party cookies in 2024. Find out more details about these changes, and what they mean for web developers.Read more →Baseline's evolution on MDNVadim MakeevDecember 5, 20234 minute readToday we're updating the Baseline widgets and introducing a new one, along with the updated definition of Baseline.Read more →Developer essentials: JavaScript console methodsBrian SmithNovember 30, 20236 minute readThe JavaScript console is an essential tool for web development. Learn new and fun ways to use the console to display data and debug your code.Read more →Getting started with CSS container queriesMichelle BarkerNovember 16, 20238 minute readCSS container queries are a powerful new tool for our CSS layout toolbox. In this post we'll dive into the practicalities of building a layout with container queries.Read more →Deploying Node.js applications with PM2 on VultrVultrNovember 8, 20237 minute readLearn how to deploy a Node.js application on Vultr using PM2 to create persistent services. This guide shows how to efficiently use resources via PM2 cluster mode. It also covers Nginx server setup and SSL security.SponsoredRead more →VS Code: Tips and tricks for beginnersDipika BhattacharyaNovember 7, 20238 minute readDiscover essential tips and tricks for using Visual Studio Code (VS Code), a powerful IDE. Learn how to leverage its integrated editing features and Git support, and explore a few extensions.Read more →Coming Soon: MDN Observatory 2.0The MDN TeamOctober 25, 20232 minute readObservatory 2.0 is launching soon as part of the Mozilla Developer Network as the MDN Observatory with new security scoring standards and other exciting updates.Read more →Optimizing DevSecOps workflows with GitLab's conditional CI/CD pipelinesGitLabOctober 23, 20238 minute readThis guide explores the various types of CI/CD pipelines and helps you understand their specific use cases. Learn how to leverage rules to create highly efficient DevSecOps workflows.SponsoredRead more →Introduction to web sustainabilityMichelle BarkerOctober 11, 20238 minute readWhat can web designers and developers do to build a more sustainable web? This post explores the environmental impacts of web technologies and looks at some of the ways we can build greener websites.Read more →Migrating from GitHub to GitLab seamlessly: A step-by-step guideGitLabOctober 5, 20239 minute readThinking about making the move from GitHub to GitLab? This guide demystifies the migration process, addressing common concerns for DevSecOps teams that are looking to seamlessly transition between the two platforms. This post provides a step-by-step guided tutorial on how to migrate your data from GitHub into GitLab.SponsoredRead more →Announcing the MDN front-end developer curriculumThe MDN TeamAugust 14, 20235 minute readMDN has created a curriculum for aspiring front-end developers to build a rewarding and successful career. Take a look at the curriculum, who it's for, and the research it's based on.Read more →Creating custom easing effects in CSS animations using the linear() functionMichelle BarkerAugust 1, 202310 minute readThe new CSS linear() timing function enables custom easing in animations. Explore how linear() works compared with other timing functions used for easing, with practical examples.Read more →Securing your CDN: Why and how should you use SRITerence EdenJuly 21, 20234 minute readRelying on external resources for your website is always fraught with risks. Learn how to protect your website and its visitors by using SRI to secure third-party content.Read more →Scroll progress animations in CSSMichelle BarkerJuly 14, 20237 minute readScroll-driven animations are coming to CSS! In this post, we'll look at a few types of animations and learn how to link them to the scroll progress of a container.Read more →Reflections on AI Explain: A postmortemThe MDN TeamJuly 11, 202310 minute readWe recently launched a feature called AI Explain, but we have rolled this back for now. In this post, we look into the story behind AI Explain: its development, launch, and the reasons that led us to press the pause button.Read more →Developer essentials: How to search code using grepBrian SmithJuly 3, 20239 minute readgrep is a powerful tool for searching code from the terminal. This post will show you how to use grep and why it's an essential developer tool.Read more →Introducing AI Help (Beta): Your Companion for Web DevelopmentHermina CondeiJune 27, 20233 minute readWe're introducing an AI assistant powered by MDN and OpenAI GPT 3.5 to answer all your web development questions in real time.Read more →Learn how to use hue in CSS colors with HSLBrian SmithJune 26, 20237 minute readHues are a bright way to define colors in CSS. Learn about hues, color wheels, how to use color functions, and how you can create vibrant color palettes for your website using hue.Read more →Introducing the MDN Playground: Bring your code to life!Florian DiemingerJune 22, 20236 minute readMDN is launching a code Playground. Users can prototype ideas and expand all live samples into an interactive experience.Read more →MDN doc updates: CSS selectors & media queries, WebGPU & WebTransport APIs, Progressive web appsDipika BhattacharyaJune 13, 20236 minute readDiscover CSS :lang(), experimental media queries, manipulating graphics with WebGPU, client-server communication with WebTransport, ECMAScript module support, and more.Read more →How to draw any regular shape with just one JavaScript functionRuth JohnMay 26, 20234 minute readLearn how to use JavaScript to draw any regular shape to a HTML canvas with a single function, and how to modify it to draw multiple shapes.Read more →New reference pages on MDN for JavaScript regular expressionsBrian SmithMay 23, 20235 minute readSee the latest updates to the MDN reference pages about JavaScript regular expressions, including new sections on sub-features and browser compatibility information.Read more →Celebrating Global Accessibility Awareness DaySchalk NeethlingMay 18, 20236 minute readIn celebration of Global Accessibility Awareness Day in 2023, we share some tools and guidelines to help you make the web more accessible.Read more →Using HTML landmark roles to improve accessibilitySchalk NeethlingMay 15, 202311 minute readLearn what HTML landmark roles are, how they improve accessibility, and how you can include them on your website effectively.Read more →Introducing Baseline: a unified view of stable web featuresHermina CondeiMay 10, 20233 minute readMDN leads the way in implementing WebDX community group's efforts, delivering a clear and simple baseline for the web platform to developers.Read more →How :not() chains multiple selectorsDipika BhattacharyaMay 5, 20234 minute readLearn how the CSS `:not()` pseudo-class behaves when multiple selectors are passed as argument.Read more →New functions, gradients, and hues in CSS colors (Level 4)Brian SmithMay 3, 20239 minute readLearn what's new in CSS Colors Module Level 4, including color spaces, color functions, fancy gradients, and support for wide-gamut displays.Read more →Welcome to the MDN blogRuth JohnMay 3, 20232 minute readThe MDN blog publishes web development news, tutorials, and insights as an extension of MDN Web Docs, helping you discover, learn, and create for the web.Read more →\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nJavaScript referenceThe JavaScript reference serves as a repository of facts about the JavaScript language. The entire language is described here in detail. As you write JavaScript code, you'll refer to these pages often (thus the title "JavaScript reference").
The JavaScript language is intended to be used within some larger environment, be it a browser, server-side scripts, or similar. For the most part, this reference attempts to be environment-agnostic and does not target a web browser environment.
If you are new to JavaScript, start with the guide. Once you have a firm grasp of the fundamentals, you can use the reference to get more details on individual objects and language constructs.Built-insJavaScript standard built-in objects, along with their methods and properties.Value properties
globalThis
Infinity
NaN
undefined
Function properties
eval()
isFinite()
isNaN()
parseFloat()
parseInt()
decodeURI()
decodeURIComponent()
encodeURI()
encodeURIComponent()
escape() 
Deprecated

unescape() 
Deprecated

Fundamental objects
Object
Function
Boolean
Symbol
Error objects
Error
AggregateError
EvalError
RangeError
ReferenceError
SyntaxError
TypeError
URIError
InternalError 
Non-standard

Numbers and dates
Number
BigInt
Math
Date
Temporal
Text processing
String
RegExp
Indexed collections
Array
Int8Array
Uint8Array
Uint8ClampedArray
Int16Array
Uint16Array
Int32Array
Uint32Array
BigInt64Array
BigUint64Array
Float16Array
Float32Array
Float64Array
Keyed collections
Map
Set
WeakMap
WeakSet
Structured data
ArrayBuffer
SharedArrayBuffer
DataView
Atomics
JSON
Managing memory
WeakRef
FinalizationRegistry
Control abstraction objects
Iterator
AsyncIterator
Promise
GeneratorFunction
AsyncGeneratorFunction
Generator
AsyncGenerator
AsyncFunction
Reflection
Reflect
Proxy
Internationalization
Intl
Intl.Collator
Intl.DateTimeFormat
Intl.DisplayNames
Intl.DurationFormat
Intl.ListFormat
Intl.Locale
Intl.NumberFormat
Intl.PluralRules
Intl.RelativeTimeFormat
Intl.Segmenter
StatementsJavaScript statements and declarationsControl flow
return
break
continue
throw
if...else
switch
try...catch
Declaring variables
var
let
const
Functions and classes
function
function*
async function
async function*
class
Iterations
do...while
for
for...in
for...of
for await...of
while
Others
Empty
Block
Expression statement
debugger
export
import
label
with 
Deprecated

Expressions and operatorsJavaScript expressions and operators.Primary expressions
this
Literals
[]
{}
function
class
function*
async function
async function*
/ab+c/i
`string`
( )
Left-hand-side expressions
Property accessors
?.
new
new.target
import.meta
super
import()
Increment and decrement
A++
A--
++A
--A
Unary operators
delete
void
typeof
+
-
~
!
await
Arithmetic operators
**
*
/
%
+ (Plus)
-
Relational operators
< (Less than)
> (Greater than)
<=
>=
instanceof
in
Equality operators
==
!=
===
!==
Bitwise shift operators
<<
>>
>>>
Binary bitwise operators
&
|
^
Binary logical operators
&&
||
??
Conditional (ternary) operator
(condition ? ifTrue : ifFalse)
Assignment operators
=
*=
/=
%=
+=
-=
<<=
>>=
>>>=
&=
^=
|=
**=
&&=
||=
??=
[a, b] = arr, { a, b } = obj
Yield operators
yield
yield*
Spread syntax
...obj
Comma operator
,
FunctionsJavaScript functions.

Arrow Functions
Default parameters
Rest parameters
arguments
Method definitions
getter
setter
ClassesJavaScript classes.

constructor
extends
Private properties
Public class fields
static
Static initialization blocks
Regular expressionsJavaScript regular expressions.

Backreference: \1, \2
Capturing group: (...)
Character class: [...], [^...]
Character class escape: \d, \D, \w, \W,  , \S
Character escape: \n, \u{...}
Disjunction: |
Input boundary assertion: ^, $
Literal character: a, b
Lookahead assertion: (?=...), (?!...)
Lookbehind assertion: (?<=...), (?<!...)
Modifier: (?ims-ims:...)
Named backreference: \k<name>
Named capturing group: (?<name>...)
Non-capturing group: (?:...)
Quantifier: *, +, ?, {n}, {n,}, {n,m}
Unicode character class escape: \p{...}, \P{...}
Wildcard: .
Word boundary assertion: \b, \B
Additional reference pages
Execution model
Lexical grammar
Data types and data structures
Iteration protocols
Trailing commas
Errors
Strict mode
Deprecated features\n\nJavaScript referenceThe JavaScript reference serves as a repository of facts about the JavaScript language. The entire language is described here in detail. As you write JavaScript code, you'll refer to these pages often (thus the title "JavaScript reference").
The JavaScript language is intended to be used within some larger environment, be it a browser, server-side scripts, or similar. For the most part, this reference attempts to be environment-agnostic and does not target a web browser environment.
If you are new to JavaScript, start with the guide. Once you have a firm grasp of the fundamentals, you can use the reference to get more details on individual objects and language constructs.Built-insJavaScript standard built-in objects, along with their methods and properties.Value properties
globalThis
Infinity
NaN
undefined
Function properties
eval()
isFinite()
isNaN()
parseFloat()
parseInt()
decodeURI()
decodeURIComponent()
encodeURI()
encodeURIComponent()
escape() 
Deprecated

unescape() 
Deprecated

Fundamental objects
Object
Function
Boolean
Symbol
Error objects
Error
AggregateError
EvalError
RangeError
ReferenceError
SyntaxError
TypeError
URIError
InternalError 
Non-standard

Numbers and dates
Number
BigInt
Math
Date
Temporal
Text processing
String
RegExp
Indexed collections
Array
Int8Array
Uint8Array
Uint8ClampedArray
Int16Array
Uint16Array
Int32Array
Uint32Array
BigInt64Array
BigUint64Array
Float16Array
Float32Array
Float64Array
Keyed collections
Map
Set
WeakMap
WeakSet
Structured data
ArrayBuffer
SharedArrayBuffer
DataView
Atomics
JSON
Managing memory
WeakRef
FinalizationRegistry
Control abstraction objects
Iterator
AsyncIterator
Promise
GeneratorFunction
AsyncGeneratorFunction
Generator
AsyncGenerator
AsyncFunction
Reflection
Reflect
Proxy
Internationalization
Intl
Intl.Collator
Intl.DateTimeFormat
Intl.DisplayNames
Intl.DurationFormat
Intl.ListFormat
Intl.Locale
Intl.NumberFormat
Intl.PluralRules
Intl.RelativeTimeFormat
Intl.Segmenter
StatementsJavaScript statements and declarationsControl flow
return
break
continue
throw
if...else
switch
try...catch
Declaring variables
var
let
const
Functions and classes
function
function*
async function
async function*
class
Iterations
do...while
for
for...in
for...of
for await...of
while
Others
Empty
Block
Expression statement
debugger
export
import
label
with 
Deprecated

Expressions and operatorsJavaScript expressions and operators.Primary expressions
this
Literals
[]
{}
function
class
function*
async function
async function*
/ab+c/i
`string`
( )
Left-hand-side expressions
Property accessors
?.
new
new.target
import.meta
super
import()
Increment and decrement
A++
A--
++A
--A
Unary operators
delete
void
typeof
+
-
~
!
await
Arithmetic operators
**
*
/
%
+ (Plus)
-
Relational operators
< (Less than)
> (Greater than)
<=
>=
instanceof
in
Equality operators
==
!=
===
!==
Bitwise shift operators
<<
>>
>>>
Binary bitwise operators
&
|
^
Binary logical operators
&&
||
??
Conditional (ternary) operator
(condition ? ifTrue : ifFalse)
Assignment operators
=
*=
/=
%=
+=
-=
<<=
>>=
>>>=
&=
^=
|=
**=
&&=
||=
??=
[a, b] = arr, { a, b } = obj
Yield operators
yield
yield*
Spread syntax
...obj
Comma operator
,
FunctionsJavaScript functions.

Arrow Functions
Default parameters
Rest parameters
arguments
Method definitions
getter
setter
ClassesJavaScript classes.

constructor
extends
Private properties
Public class fields
static
Static initialization blocks
Regular expressionsJavaScript regular expressions.

Backreference: \1, \2
Capturing group: (...)
Character class: [...], [^...]
Character class escape: \d, \D, \w, \W,  , \S
Character escape: \n, \u{...}
Disjunction: |
Input boundary assertion: ^, $
Literal character: a, b
Lookahead assertion: (?=...), (?!...)
Lookbehind assertion: (?<=...), (?<!...)
Modifier: (?ims-ims:...)
Named backreference: \k<name>
Named capturing group: (?<name>...)
Non-capturing group: (?:...)
Quantifier: *, +, ?, {n}, {n,}, {n,m}
Unicode character class escape: \p{...}, \P{...}
Wildcard: .
Word boundary assertion: \b, \B
Additional reference pages
Execution model
Lexical grammar
Data types and data structures
Iteration protocols
Trailing commas
Errors
Strict mode
Deprecated features
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 7, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJavaScript referenceThe JavaScript reference serves as a repository of facts about the JavaScript language. The entire language is described here in detail. As you write JavaScript code, you'll refer to these pages often (thus the title "JavaScript reference").
The JavaScript language is intended to be used within some larger environment, be it a browser, server-side scripts, or similar. For the most part, this reference attempts to be environment-agnostic and does not target a web browser environment.
If you are new to JavaScript, start with the guide. Once you have a firm grasp of the fundamentals, you can use the reference to get more details on individual objects and language constructs.Built-insJavaScript standard built-in objects, along with their methods and properties.Value properties
globalThis
Infinity
NaN
undefined
Function properties
eval()
isFinite()
isNaN()
parseFloat()
parseInt()
decodeURI()
decodeURIComponent()
encodeURI()
encodeURIComponent()
escape() 
Deprecated

unescape() 
Deprecated

Fundamental objects
Object
Function
Boolean
Symbol
Error objects
Error
AggregateError
EvalError
RangeError
ReferenceError
SyntaxError
TypeError
URIError
InternalError 
Non-standard

Numbers and dates
Number
BigInt
Math
Date
Temporal
Text processing
String
RegExp
Indexed collections
Array
Int8Array
Uint8Array
Uint8ClampedArray
Int16Array
Uint16Array
Int32Array
Uint32Array
BigInt64Array
BigUint64Array
Float16Array
Float32Array
Float64Array
Keyed collections
Map
Set
WeakMap
WeakSet
Structured data
ArrayBuffer
SharedArrayBuffer
DataView
Atomics
JSON
Managing memory
WeakRef
FinalizationRegistry
Control abstraction objects
Iterator
AsyncIterator
Promise
GeneratorFunction
AsyncGeneratorFunction
Generator
AsyncGenerator
AsyncFunction
Reflection
Reflect
Proxy
Internationalization
Intl
Intl.Collator
Intl.DateTimeFormat
Intl.DisplayNames
Intl.DurationFormat
Intl.ListFormat
Intl.Locale
Intl.NumberFormat
Intl.PluralRules
Intl.RelativeTimeFormat
Intl.Segmenter
StatementsJavaScript statements and declarationsControl flow
return
break
continue
throw
if...else
switch
try...catch
Declaring variables
var
let
const
Functions and classes
function
function*
async function
async function*
class
Iterations
do...while
for
for...in
for...of
for await...of
while
Others
Empty
Block
Expression statement
debugger
export
import
label
with 
Deprecated

Expressions and operatorsJavaScript expressions and operators.Primary expressions
this
Literals
[]
{}
function
class
function*
async function
async function*
/ab+c/i
`string`
( )
Left-hand-side expressions
Property accessors
?.
new
new.target
import.meta
super
import()
Increment and decrement
A++
A--
++A
--A
Unary operators
delete
void
typeof
+
-
~
!
await
Arithmetic operators
**
*
/
%
+ (Plus)
-
Relational operators
< (Less than)
> (Greater than)
<=
>=
instanceof
in
Equality operators
==
!=
===
!==
Bitwise shift operators
<<
>>
>>>
Binary bitwise operators
&
|
^
Binary logical operators
&&
||
??
Conditional (ternary) operator
(condition ? ifTrue : ifFalse)
Assignment operators
=
*=
/=
%=
+=
-=
<<=
>>=
>>>=
&=
^=
|=
**=
&&=
||=
??=
[a, b] = arr, { a, b } = obj
Yield operators
yield
yield*
Spread syntax
...obj
Comma operator
,
FunctionsJavaScript functions.

Arrow Functions
Default parameters
Rest parameters
arguments
Method definitions
getter
setter
ClassesJavaScript classes.

constructor
extends
Private properties
Public class fields
static
Static initialization blocks
Regular expressionsJavaScript regular expressions.

Backreference: \1, \2
Capturing group: (...)
Character class: [...], [^...]
Character class escape: \d, \D, \w, \W,  , \S
Character escape: \n, \u{...}
Disjunction: |
Input boundary assertion: ^, $
Literal character: a, b
Lookahead assertion: (?=...), (?!...)
Lookbehind assertion: (?<=...), (?<!...)
Modifier: (?ims-ims:...)
Named backreference: \k<name>
Named capturing group: (?<name>...)
Non-capturing group: (?:...)
Quantifier: *, +, ?, {n}, {n,}, {n,m}
Unicode character class escape: \p{...}, \P{...}
Wildcard: .
Word boundary assertion: \b, \B
Additional reference pages
Execution model
Lexical grammar
Data types and data structures
Iteration protocols
Trailing commas
Errors
Strict mode
Deprecated features
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 7, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nStandard built-in objectsThis chapter documents all of JavaScript's standard, built-in objects, including their methods and properties.
The term "global objects" (or standard built-in objects) here is not to be confused with the global object. Here, "global objects" refer to objects in the global scope.
The global object itself can be accessed using the this operator in the global scope. In fact, the global scope consists of the properties of the global object, including inherited properties, if any.
Other objects in the global scope are either created by the user script or provided by the host application. The host objects available in browser contexts are documented in the API reference.
For more information about the distinction between the DOM and core JavaScript, see JavaScript technologies overview.Standard objects by categoryValue propertiesThese global properties return a simple value. They have no properties or methods.

globalThis
Infinity
NaN
undefined
Function propertiesThese global functions—functions which are called globally, rather than on an object—directly return their results to the caller.

eval()
isFinite()
isNaN()
parseFloat()
parseInt()
decodeURI()
decodeURIComponent()
encodeURI()
encodeURIComponent()
escape() 
Deprecated

unescape() 
Deprecated

Fundamental objectsThese objects represent fundamental language constructs.

Object
Function
Boolean
Symbol
Error objectsError objects are a special type of fundamental object. They include the basic Error type, as well as several specialized error types.

Error
AggregateError
EvalError
RangeError
ReferenceError
SyntaxError
TypeError
URIError
InternalError 
Non-standard

Numbers and datesThese are the base objects representing numbers, dates, and mathematical calculations.

Number
BigInt
Math
Date
Temporal
Text processingThese objects represent strings and support manipulating them.

String
RegExp
Indexed collectionsThese objects represent collections of data which are ordered by an index value. This includes (typed) arrays and array-like constructs.

Array
TypedArray
Int8Array
Uint8Array
Uint8ClampedArray
Int16Array
Uint16Array
Int32Array
Uint32Array
BigInt64Array
BigUint64Array
Float16Array
Float32Array
Float64Array
Keyed collectionsThese objects represent collections which use keys. The iterable collections (Map and Set) contain elements which are easily iterated in the order of insertion.

Map
Set
WeakMap
WeakSet
Structured dataThese objects represent and interact with structured data buffers and data coded using JavaScript Object Notation (JSON).

ArrayBuffer
SharedArrayBuffer
DataView
Atomics
JSON
Managing memoryThese objects interact with the garbage collection mechanism.

WeakRef
FinalizationRegistry
Control abstraction objectsControl abstractions can help to structure code, especially async code (without using deeply nested callbacks, for example).

Iterator
AsyncIterator
Promise
GeneratorFunction
AsyncGeneratorFunction
Generator
AsyncGenerator
AsyncFunction
Reflection
Reflect
Proxy
InternationalizationAdditions to the ECMAScript core for language-sensitive functionalities.

Intl
Intl.Collator
Intl.DateTimeFormat
Intl.DisplayNames
Intl.DurationFormat
Intl.ListFormat
Intl.Locale
Intl.NumberFormat
Intl.PluralRules
Intl.RelativeTimeFormat
Intl.Segmenter\n\nStandard built-in objectsThis chapter documents all of JavaScript's standard, built-in objects, including their methods and properties.
The term "global objects" (or standard built-in objects) here is not to be confused with the global object. Here, "global objects" refer to objects in the global scope.
The global object itself can be accessed using the this operator in the global scope. In fact, the global scope consists of the properties of the global object, including inherited properties, if any.
Other objects in the global scope are either created by the user script or provided by the host application. The host objects available in browser contexts are documented in the API reference.
For more information about the distinction between the DOM and core JavaScript, see JavaScript technologies overview.Standard objects by categoryValue propertiesThese global properties return a simple value. They have no properties or methods.

globalThis
Infinity
NaN
undefined
Function propertiesThese global functions—functions which are called globally, rather than on an object—directly return their results to the caller.

eval()
isFinite()
isNaN()
parseFloat()
parseInt()
decodeURI()
decodeURIComponent()
encodeURI()
encodeURIComponent()
escape() 
Deprecated

unescape() 
Deprecated

Fundamental objectsThese objects represent fundamental language constructs.

Object
Function
Boolean
Symbol
Error objectsError objects are a special type of fundamental object. They include the basic Error type, as well as several specialized error types.

Error
AggregateError
EvalError
RangeError
ReferenceError
SyntaxError
TypeError
URIError
InternalError 
Non-standard

Numbers and datesThese are the base objects representing numbers, dates, and mathematical calculations.

Number
BigInt
Math
Date
Temporal
Text processingThese objects represent strings and support manipulating them.

String
RegExp
Indexed collectionsThese objects represent collections of data which are ordered by an index value. This includes (typed) arrays and array-like constructs.

Array
TypedArray
Int8Array
Uint8Array
Uint8ClampedArray
Int16Array
Uint16Array
Int32Array
Uint32Array
BigInt64Array
BigUint64Array
Float16Array
Float32Array
Float64Array
Keyed collectionsThese objects represent collections which use keys. The iterable collections (Map and Set) contain elements which are easily iterated in the order of insertion.

Map
Set
WeakMap
WeakSet
Structured dataThese objects represent and interact with structured data buffers and data coded using JavaScript Object Notation (JSON).

ArrayBuffer
SharedArrayBuffer
DataView
Atomics
JSON
Managing memoryThese objects interact with the garbage collection mechanism.

WeakRef
FinalizationRegistry
Control abstraction objectsControl abstractions can help to structure code, especially async code (without using deeply nested callbacks, for example).

Iterator
AsyncIterator
Promise
GeneratorFunction
AsyncGeneratorFunction
Generator
AsyncGenerator
AsyncFunction
Reflection
Reflect
Proxy
InternationalizationAdditions to the ECMAScript core for language-sensitive functionalities.

Intl
Intl.Collator
Intl.DateTimeFormat
Intl.DisplayNames
Intl.DurationFormat
Intl.ListFormat
Intl.Locale
Intl.NumberFormat
Intl.PluralRules
Intl.RelativeTimeFormat
Intl.Segmenter
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 12, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nStandard built-in objectsThis chapter documents all of JavaScript's standard, built-in objects, including their methods and properties.
The term "global objects" (or standard built-in objects) here is not to be confused with the global object. Here, "global objects" refer to objects in the global scope.
The global object itself can be accessed using the this operator in the global scope. In fact, the global scope consists of the properties of the global object, including inherited properties, if any.
Other objects in the global scope are either created by the user script or provided by the host application. The host objects available in browser contexts are documented in the API reference.
For more information about the distinction between the DOM and core JavaScript, see JavaScript technologies overview.Standard objects by categoryValue propertiesThese global properties return a simple value. They have no properties or methods.

globalThis
Infinity
NaN
undefined
Function propertiesThese global functions—functions which are called globally, rather than on an object—directly return their results to the caller.

eval()
isFinite()
isNaN()
parseFloat()
parseInt()
decodeURI()
decodeURIComponent()
encodeURI()
encodeURIComponent()
escape() 
Deprecated

unescape() 
Deprecated

Fundamental objectsThese objects represent fundamental language constructs.

Object
Function
Boolean
Symbol
Error objectsError objects are a special type of fundamental object. They include the basic Error type, as well as several specialized error types.

Error
AggregateError
EvalError
RangeError
ReferenceError
SyntaxError
TypeError
URIError
InternalError 
Non-standard

Numbers and datesThese are the base objects representing numbers, dates, and mathematical calculations.

Number
BigInt
Math
Date
Temporal
Text processingThese objects represent strings and support manipulating them.

String
RegExp
Indexed collectionsThese objects represent collections of data which are ordered by an index value. This includes (typed) arrays and array-like constructs.

Array
TypedArray
Int8Array
Uint8Array
Uint8ClampedArray
Int16Array
Uint16Array
Int32Array
Uint32Array
BigInt64Array
BigUint64Array
Float16Array
Float32Array
Float64Array
Keyed collectionsThese objects represent collections which use keys. The iterable collections (Map and Set) contain elements which are easily iterated in the order of insertion.

Map
Set
WeakMap
WeakSet
Structured dataThese objects represent and interact with structured data buffers and data coded using JavaScript Object Notation (JSON).

ArrayBuffer
SharedArrayBuffer
DataView
Atomics
JSON
Managing memoryThese objects interact with the garbage collection mechanism.

WeakRef
FinalizationRegistry
Control abstraction objectsControl abstractions can help to structure code, especially async code (without using deeply nested callbacks, for example).

Iterator
AsyncIterator
Promise
GeneratorFunction
AsyncGeneratorFunction
Generator
AsyncGenerator
AsyncFunction
Reflection
Reflect
Proxy
InternationalizationAdditions to the ECMAScript core for language-sensitive functionalities.

Intl
Intl.Collator
Intl.DateTimeFormat
Intl.DisplayNames
Intl.DurationFormat
Intl.ListFormat
Intl.Locale
Intl.NumberFormat
Intl.PluralRules
Intl.RelativeTimeFormat
Intl.Segmenter
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 12, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJSONBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe JSON namespace object contains static methods for parsing values from and converting values to JavaScript Object Notation (JSON).DescriptionUnlike most global objects, JSON is not a constructor. You cannot use it with the new operator or invoke the JSON object as a function. All properties and methods of JSON are static (just like the Math object).JavaScript and JSON differencesJSON is a syntax for serializing objects, arrays, numbers, strings, booleans, and null. It is based upon JavaScript syntax, but is distinct from JavaScript: most of JavaScript is not JSON. For example:

Objects and Arrays

Property names must be double-quoted strings; trailing commas are forbidden.

Numbers

Leading zeros are prohibited. A decimal point must be followed by at least one digit. NaN and Infinity are unsupported.


Any JSON text is a valid JavaScript expression, but only after the JSON superset revision. Before the revision, U+2028 LINE SEPARATOR and U+2029 PARAGRAPH SEPARATOR are allowed in string literals and property keys in JSON; but the same use in JavaScript string literals is a SyntaxError.
Other differences include allowing only double-quoted strings and no support for undefined or comments. For those who wish to use a more human-friendly configuration format based on JSON, there is JSON5, used by the Babel compiler, and the more commonly used YAML.
The same text may represent different values in JavaScript object literals vs. JSON as well. For more information, see Object literal syntax vs. JSON.Full JSON grammarValid JSON syntax is formally defined by the following grammar, expressed in ABNF, and copied from IETF JSON standard (RFC):
JSON-text = object / array
begin-array     = ws %x5B ws  ; [ left square bracket
begin-object    = ws %x7B ws  ; { left curly bracket
end-array       = ws %x5D ws  ; ] right square bracket
end-object      = ws %x7D ws  ; } right curly bracket
name-separator  = ws %x3A ws  ; : colon
value-separator = ws %x2C ws  ; , comma
ws = *(
     %x20 /              ; Space
     %x09 /              ; Horizontal tab
     %x0A /              ; Line feed or New line
     %x0D                ; Carriage return
     )
value = false / null / true / object / array / number / string
false = %x66.61.6c.73.65   ; false
null  = %x6e.75.6c.6c      ; null
true  = %x74.72.75.65      ; true
object = begin-object [ member *( value-separator member ) ]
         end-object
member = string name-separator value
array = begin-array [ value *( value-separator value ) ] end-array
number = [ minus ] int [ frac ] [ exp ]
decimal-point = %x2E       ; .
digit1-9 = %x31-39         ; 1-9
e = %x65 / %x45            ; e E
exp = e [ minus / plus ] 1*DIGIT
frac = decimal-point 1*DIGIT
int = zero / ( digit1-9 *DIGIT )
minus = %x2D               ; -
plus = %x2B                ; +
zero = %x30                ; 0
string = quotation-mark *char quotation-mark
char = unescaped /
    escape (
        %x22 /          ; "    quotation mark  U+0022
        %x5C /          ; \    reverse solidus U+005C
        %x2F /          ; /    solidus         U+002F
        %x62 /          ; b    backspace       U+0008
        %x66 /          ; f    form feed       U+000C
        %x6E /          ; n    line feed       U+000A
        %x72 /          ; r    carriage return U+000D
        %x74 /          ; t    tab             U+0009
        %x75 4HEXDIG )  ; uXXXX                U+XXXX
escape = %x5C              ; \
quotation-mark = %x22      ; "
unescaped = %x20-21 / %x23-5B / %x5D-10FFFF
HEXDIG = DIGIT / %x41-46 / %x61-66   ; 0-9, A-F, or a-f
       ; HEXDIG equivalent to HEXDIG rule in [RFC5234]
DIGIT = %x30-39            ; 0-9
      ; DIGIT equivalent to DIGIT rule in [RFC5234]

Insignificant whitespace may be present anywhere except within a JSONNumber (numbers must contain no whitespace) or JSONString (where it is interpreted as the corresponding character in the string, or would cause an error). The tab (U+0009), carriage return (U+000D), line feed (U+000A), and space (U+0020) characters are the only valid whitespace characters.Static properties
JSON[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "JSON". This property is used in Object.prototype.toString().

Static methods
JSON.isRawJSON()

Tests whether a value is an object returned by JSON.rawJSON().

JSON.parse()

Parse a piece of string text as JSON, optionally transforming the produced value and its properties, and return the value.

JSON.rawJSON()

Creates a "raw JSON" object containing a piece of JSON text. When serialized to JSON, the raw JSON object is treated as if it is already a piece of JSON. This text is required to be valid JSON.

JSON.stringify()

Return a JSON string corresponding to the specified value, optionally including only certain properties or replacing property values in a user-defined manner.

ExamplesExample JSONjson{
  "browsers": {
    "firefox": {
      "name": "Firefox",
      "pref_url": "about:config",
      "releases": {
        "1": {
          "release_date": "2004-11-09",
          "status": "retired",
          "engine": "Gecko",
          "engine_version": "1.7"
        }
      }
    }
  }
}

You can use the JSON.parse() method to convert the above JSON string into a JavaScript object:
jsconst jsonText = `{
  "browsers": {
    "firefox": {
      "name": "Firefox",
      "pref_url": "about:config",
      "releases": {
        "1": {
          "release_date": "2004-11-09",
          "status": "retired",
          "engine": "Gecko",
          "engine_version": "1.7"
        }
      }
    }
  }
}`;

console.log(JSON.parse(jsonText));
Lossless number serializationJSON can contain number literals of arbitrary precision. However, it is not possible to represent all JSON numbers exactly in JavaScript, because JavaScript uses floating point representation which has a fixed precision. For example, 12345678901234567890 === 12345678901234567000 in JavaScript because they have the same floating point representation. This means there is no JavaScript number that corresponds precisely to the 12345678901234567890 JSON number.
Let's assume you have a exact representation of some number (either via BigInt or a custom library):
jsconst data = {
  // Using a BigInt here to store the exact value,
  // but it can also be a custom high-precision number library,
  // if the number might not be an integer.
  gross_gdp: 12345678901234567890n,
};

You want to serialize it and then parse to the same exact number. There are several difficulties:

On the serialization side, in order to obtain a number in JSON, you have to pass a number to JSON.stringify, either via the replacer function or via the toJSON method. But, in either case, you have already lost precision during number conversion. If you pass a string to JSON.stringify, it will be serialized as a string, not a number.
On the parsing side, not all numbers can be represented exactly. For example, JSON.parse("12345678901234567890") returns 12345678901234568000 because the number is rounded to the nearest representable number. Even if you use a reviver function, the number will already be rounded before the reviver function is called.

There are, in general, two ways to ensure that numbers are losslessly converted to JSON and parsed back: one involves a JSON number, another involves a JSON string. JSON is a communication format, so if you use JSON, you are likely communicating with another system (HTTP request, storing in database, etc.). The best solution to choose depends on the recipient system.
Using JSON strings
If the recipient system does not have same JSON-handling capabilities as JavaScript, and does not support high precision numbers, you may want to serialize the number as a string, and then handle it as a string on the recipient side. This is also the only option in older JavaScript.
To specify how custom data types (including BigInt) should be serialized to JSON, either add a toJSON method to your data type, or use the replacer function of JSON.stringify().
js// Using toJSON() method
BigInt.prototype.toJSON = function () {
  return this.toString();
};
const str1 = JSON.stringify(data);

// Using JSON.stringify() with replacer
const str2 = JSON.stringify(data, (key, value) => {
  if (key === "gross_gdp") {
    return value.toString();
  }
  return value;
});

In either case, the JSON text will look like {"gross_gdp":"12345678901234567890"}, where the value is a string, not a number. Then, on the recipient side, you can parse the JSON and handle the string.
Using JSON numbers
If the recipient of this message natively supports high precision numbers (such as Python integers), passing numbers as JSON numbers is obviously better, because they can directly parse to the high precision type instead of parsing a string from JSON, and then parsing a number from the string. In JavaScript, you can serialize arbitrary data types to JSON numbers without producing a number value first (resulting in loss of precision) by using JSON.rawJSON() to precisely specify what the JSON source text should be.
js// Using toJSON() method
BigInt.prototype.toJSON = function () {
  return JSON.rawJSON(this.toString());
};
const str1 = JSON.stringify(data);

// Using JSON.stringify() with replacer
const str2 = JSON.stringify(data, (key, value) => {
  if (key === "gross_gdp") {
    return JSON.rawJSON(value.toString());
  }
  return value;
});

The text passed to JSON.rawJSON is treated as if it is already a piece of JSON, so it won't be serialized again as a string. Therefore, the JSON text will look like {"gross_gdp":12345678901234567890}, where the value is a number. This JSON can then be parsed by the recipient without any extra processing, provided that the recipient system does not have the same precision limitations as JavaScript.
When parsing JSON containing high-precision numbers in JavaScript, take extra care because when JSON.parse() invokes the reviver function, the value you receive is already parsed (and has lost precision). You can use the context.source parameter of the JSON.parse() reviver function to re-parse the number yourself.
jsconst parsedData = JSON.parse(str, (key, value, context) => {
  if (key === "gross_gdp") {
    // Or use the constructor of your custom high-precision number library
    return BigInt(context.source);
  }
  return value;
});
// { gross_gdp: 12345678901234567890n }
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json-objectBrowser compatibilitySee also
JSON Diff
JSON Beautifier/editor
JSON Parser
JSON Validator\n\nJSONBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe JSON namespace object contains static methods for parsing values from and converting values to JavaScript Object Notation (JSON).DescriptionUnlike most global objects, JSON is not a constructor. You cannot use it with the new operator or invoke the JSON object as a function. All properties and methods of JSON are static (just like the Math object).JavaScript and JSON differencesJSON is a syntax for serializing objects, arrays, numbers, strings, booleans, and null. It is based upon JavaScript syntax, but is distinct from JavaScript: most of JavaScript is not JSON. For example:

Objects and Arrays

Property names must be double-quoted strings; trailing commas are forbidden.

Numbers

Leading zeros are prohibited. A decimal point must be followed by at least one digit. NaN and Infinity are unsupported.


Any JSON text is a valid JavaScript expression, but only after the JSON superset revision. Before the revision, U+2028 LINE SEPARATOR and U+2029 PARAGRAPH SEPARATOR are allowed in string literals and property keys in JSON; but the same use in JavaScript string literals is a SyntaxError.
Other differences include allowing only double-quoted strings and no support for undefined or comments. For those who wish to use a more human-friendly configuration format based on JSON, there is JSON5, used by the Babel compiler, and the more commonly used YAML.
The same text may represent different values in JavaScript object literals vs. JSON as well. For more information, see Object literal syntax vs. JSON.Full JSON grammarValid JSON syntax is formally defined by the following grammar, expressed in ABNF, and copied from IETF JSON standard (RFC):
JSON-text = object / array
begin-array     = ws %x5B ws  ; [ left square bracket
begin-object    = ws %x7B ws  ; { left curly bracket
end-array       = ws %x5D ws  ; ] right square bracket
end-object      = ws %x7D ws  ; } right curly bracket
name-separator  = ws %x3A ws  ; : colon
value-separator = ws %x2C ws  ; , comma
ws = *(
     %x20 /              ; Space
     %x09 /              ; Horizontal tab
     %x0A /              ; Line feed or New line
     %x0D                ; Carriage return
     )
value = false / null / true / object / array / number / string
false = %x66.61.6c.73.65   ; false
null  = %x6e.75.6c.6c      ; null
true  = %x74.72.75.65      ; true
object = begin-object [ member *( value-separator member ) ]
         end-object
member = string name-separator value
array = begin-array [ value *( value-separator value ) ] end-array
number = [ minus ] int [ frac ] [ exp ]
decimal-point = %x2E       ; .
digit1-9 = %x31-39         ; 1-9
e = %x65 / %x45            ; e E
exp = e [ minus / plus ] 1*DIGIT
frac = decimal-point 1*DIGIT
int = zero / ( digit1-9 *DIGIT )
minus = %x2D               ; -
plus = %x2B                ; +
zero = %x30                ; 0
string = quotation-mark *char quotation-mark
char = unescaped /
    escape (
        %x22 /          ; "    quotation mark  U+0022
        %x5C /          ; \    reverse solidus U+005C
        %x2F /          ; /    solidus         U+002F
        %x62 /          ; b    backspace       U+0008
        %x66 /          ; f    form feed       U+000C
        %x6E /          ; n    line feed       U+000A
        %x72 /          ; r    carriage return U+000D
        %x74 /          ; t    tab             U+0009
        %x75 4HEXDIG )  ; uXXXX                U+XXXX
escape = %x5C              ; \
quotation-mark = %x22      ; "
unescaped = %x20-21 / %x23-5B / %x5D-10FFFF
HEXDIG = DIGIT / %x41-46 / %x61-66   ; 0-9, A-F, or a-f
       ; HEXDIG equivalent to HEXDIG rule in [RFC5234]
DIGIT = %x30-39            ; 0-9
      ; DIGIT equivalent to DIGIT rule in [RFC5234]

Insignificant whitespace may be present anywhere except within a JSONNumber (numbers must contain no whitespace) or JSONString (where it is interpreted as the corresponding character in the string, or would cause an error). The tab (U+0009), carriage return (U+000D), line feed (U+000A), and space (U+0020) characters are the only valid whitespace characters.Static properties
JSON[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "JSON". This property is used in Object.prototype.toString().

Static methods
JSON.isRawJSON()

Tests whether a value is an object returned by JSON.rawJSON().

JSON.parse()

Parse a piece of string text as JSON, optionally transforming the produced value and its properties, and return the value.

JSON.rawJSON()

Creates a "raw JSON" object containing a piece of JSON text. When serialized to JSON, the raw JSON object is treated as if it is already a piece of JSON. This text is required to be valid JSON.

JSON.stringify()

Return a JSON string corresponding to the specified value, optionally including only certain properties or replacing property values in a user-defined manner.

ExamplesExample JSONjson{
  "browsers": {
    "firefox": {
      "name": "Firefox",
      "pref_url": "about:config",
      "releases": {
        "1": {
          "release_date": "2004-11-09",
          "status": "retired",
          "engine": "Gecko",
          "engine_version": "1.7"
        }
      }
    }
  }
}

You can use the JSON.parse() method to convert the above JSON string into a JavaScript object:
jsconst jsonText = `{
  "browsers": {
    "firefox": {
      "name": "Firefox",
      "pref_url": "about:config",
      "releases": {
        "1": {
          "release_date": "2004-11-09",
          "status": "retired",
          "engine": "Gecko",
          "engine_version": "1.7"
        }
      }
    }
  }
}`;

console.log(JSON.parse(jsonText));
Lossless number serializationJSON can contain number literals of arbitrary precision. However, it is not possible to represent all JSON numbers exactly in JavaScript, because JavaScript uses floating point representation which has a fixed precision. For example, 12345678901234567890 === 12345678901234567000 in JavaScript because they have the same floating point representation. This means there is no JavaScript number that corresponds precisely to the 12345678901234567890 JSON number.
Let's assume you have a exact representation of some number (either via BigInt or a custom library):
jsconst data = {
  // Using a BigInt here to store the exact value,
  // but it can also be a custom high-precision number library,
  // if the number might not be an integer.
  gross_gdp: 12345678901234567890n,
};

You want to serialize it and then parse to the same exact number. There are several difficulties:

On the serialization side, in order to obtain a number in JSON, you have to pass a number to JSON.stringify, either via the replacer function or via the toJSON method. But, in either case, you have already lost precision during number conversion. If you pass a string to JSON.stringify, it will be serialized as a string, not a number.
On the parsing side, not all numbers can be represented exactly. For example, JSON.parse("12345678901234567890") returns 12345678901234568000 because the number is rounded to the nearest representable number. Even if you use a reviver function, the number will already be rounded before the reviver function is called.

There are, in general, two ways to ensure that numbers are losslessly converted to JSON and parsed back: one involves a JSON number, another involves a JSON string. JSON is a communication format, so if you use JSON, you are likely communicating with another system (HTTP request, storing in database, etc.). The best solution to choose depends on the recipient system.
Using JSON strings
If the recipient system does not have same JSON-handling capabilities as JavaScript, and does not support high precision numbers, you may want to serialize the number as a string, and then handle it as a string on the recipient side. This is also the only option in older JavaScript.
To specify how custom data types (including BigInt) should be serialized to JSON, either add a toJSON method to your data type, or use the replacer function of JSON.stringify().
js// Using toJSON() method
BigInt.prototype.toJSON = function () {
  return this.toString();
};
const str1 = JSON.stringify(data);

// Using JSON.stringify() with replacer
const str2 = JSON.stringify(data, (key, value) => {
  if (key === "gross_gdp") {
    return value.toString();
  }
  return value;
});

In either case, the JSON text will look like {"gross_gdp":"12345678901234567890"}, where the value is a string, not a number. Then, on the recipient side, you can parse the JSON and handle the string.
Using JSON numbers
If the recipient of this message natively supports high precision numbers (such as Python integers), passing numbers as JSON numbers is obviously better, because they can directly parse to the high precision type instead of parsing a string from JSON, and then parsing a number from the string. In JavaScript, you can serialize arbitrary data types to JSON numbers without producing a number value first (resulting in loss of precision) by using JSON.rawJSON() to precisely specify what the JSON source text should be.
js// Using toJSON() method
BigInt.prototype.toJSON = function () {
  return JSON.rawJSON(this.toString());
};
const str1 = JSON.stringify(data);

// Using JSON.stringify() with replacer
const str2 = JSON.stringify(data, (key, value) => {
  if (key === "gross_gdp") {
    return JSON.rawJSON(value.toString());
  }
  return value;
});

The text passed to JSON.rawJSON is treated as if it is already a piece of JSON, so it won't be serialized again as a string. Therefore, the JSON text will look like {"gross_gdp":12345678901234567890}, where the value is a number. This JSON can then be parsed by the recipient without any extra processing, provided that the recipient system does not have the same precision limitations as JavaScript.
When parsing JSON containing high-precision numbers in JavaScript, take extra care because when JSON.parse() invokes the reviver function, the value you receive is already parsed (and has lost precision). You can use the context.source parameter of the JSON.parse() reviver function to re-parse the number yourself.
jsconst parsedData = JSON.parse(str, (key, value, context) => {
  if (key === "gross_gdp") {
    // Or use the constructor of your custom high-precision number library
    return BigInt(context.source);
  }
  return value;
});
// { gross_gdp: 12345678901234567890n }
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json-objectBrowser compatibilitySee also
JSON Diff
JSON Beautifier/editor
JSON Parser
JSON Validator
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jan 20, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJSONBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe JSON namespace object contains static methods for parsing values from and converting values to JavaScript Object Notation (JSON).DescriptionUnlike most global objects, JSON is not a constructor. You cannot use it with the new operator or invoke the JSON object as a function. All properties and methods of JSON are static (just like the Math object).JavaScript and JSON differencesJSON is a syntax for serializing objects, arrays, numbers, strings, booleans, and null. It is based upon JavaScript syntax, but is distinct from JavaScript: most of JavaScript is not JSON. For example:

Objects and Arrays

Property names must be double-quoted strings; trailing commas are forbidden.

Numbers

Leading zeros are prohibited. A decimal point must be followed by at least one digit. NaN and Infinity are unsupported.


Any JSON text is a valid JavaScript expression, but only after the JSON superset revision. Before the revision, U+2028 LINE SEPARATOR and U+2029 PARAGRAPH SEPARATOR are allowed in string literals and property keys in JSON; but the same use in JavaScript string literals is a SyntaxError.
Other differences include allowing only double-quoted strings and no support for undefined or comments. For those who wish to use a more human-friendly configuration format based on JSON, there is JSON5, used by the Babel compiler, and the more commonly used YAML.
The same text may represent different values in JavaScript object literals vs. JSON as well. For more information, see Object literal syntax vs. JSON.Full JSON grammarValid JSON syntax is formally defined by the following grammar, expressed in ABNF, and copied from IETF JSON standard (RFC):
JSON-text = object / array
begin-array     = ws %x5B ws  ; [ left square bracket
begin-object    = ws %x7B ws  ; { left curly bracket
end-array       = ws %x5D ws  ; ] right square bracket
end-object      = ws %x7D ws  ; } right curly bracket
name-separator  = ws %x3A ws  ; : colon
value-separator = ws %x2C ws  ; , comma
ws = *(
     %x20 /              ; Space
     %x09 /              ; Horizontal tab
     %x0A /              ; Line feed or New line
     %x0D                ; Carriage return
     )
value = false / null / true / object / array / number / string
false = %x66.61.6c.73.65   ; false
null  = %x6e.75.6c.6c      ; null
true  = %x74.72.75.65      ; true
object = begin-object [ member *( value-separator member ) ]
         end-object
member = string name-separator value
array = begin-array [ value *( value-separator value ) ] end-array
number = [ minus ] int [ frac ] [ exp ]
decimal-point = %x2E       ; .
digit1-9 = %x31-39         ; 1-9
e = %x65 / %x45            ; e E
exp = e [ minus / plus ] 1*DIGIT
frac = decimal-point 1*DIGIT
int = zero / ( digit1-9 *DIGIT )
minus = %x2D               ; -
plus = %x2B                ; +
zero = %x30                ; 0
string = quotation-mark *char quotation-mark
char = unescaped /
    escape (
        %x22 /          ; "    quotation mark  U+0022
        %x5C /          ; \    reverse solidus U+005C
        %x2F /          ; /    solidus         U+002F
        %x62 /          ; b    backspace       U+0008
        %x66 /          ; f    form feed       U+000C
        %x6E /          ; n    line feed       U+000A
        %x72 /          ; r    carriage return U+000D
        %x74 /          ; t    tab             U+0009
        %x75 4HEXDIG )  ; uXXXX                U+XXXX
escape = %x5C              ; \
quotation-mark = %x22      ; "
unescaped = %x20-21 / %x23-5B / %x5D-10FFFF
HEXDIG = DIGIT / %x41-46 / %x61-66   ; 0-9, A-F, or a-f
       ; HEXDIG equivalent to HEXDIG rule in [RFC5234]
DIGIT = %x30-39            ; 0-9
      ; DIGIT equivalent to DIGIT rule in [RFC5234]

Insignificant whitespace may be present anywhere except within a JSONNumber (numbers must contain no whitespace) or JSONString (where it is interpreted as the corresponding character in the string, or would cause an error). The tab (U+0009), carriage return (U+000D), line feed (U+000A), and space (U+0020) characters are the only valid whitespace characters.Static properties
JSON[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "JSON". This property is used in Object.prototype.toString().

Static methods
JSON.isRawJSON()

Tests whether a value is an object returned by JSON.rawJSON().

JSON.parse()

Parse a piece of string text as JSON, optionally transforming the produced value and its properties, and return the value.

JSON.rawJSON()

Creates a "raw JSON" object containing a piece of JSON text. When serialized to JSON, the raw JSON object is treated as if it is already a piece of JSON. This text is required to be valid JSON.

JSON.stringify()

Return a JSON string corresponding to the specified value, optionally including only certain properties or replacing property values in a user-defined manner.

ExamplesExample JSONjson{
  "browsers": {
    "firefox": {
      "name": "Firefox",
      "pref_url": "about:config",
      "releases": {
        "1": {
          "release_date": "2004-11-09",
          "status": "retired",
          "engine": "Gecko",
          "engine_version": "1.7"
        }
      }
    }
  }
}

You can use the JSON.parse() method to convert the above JSON string into a JavaScript object:
jsconst jsonText = `{
  "browsers": {
    "firefox": {
      "name": "Firefox",
      "pref_url": "about:config",
      "releases": {
        "1": {
          "release_date": "2004-11-09",
          "status": "retired",
          "engine": "Gecko",
          "engine_version": "1.7"
        }
      }
    }
  }
}`;

console.log(JSON.parse(jsonText));
Lossless number serializationJSON can contain number literals of arbitrary precision. However, it is not possible to represent all JSON numbers exactly in JavaScript, because JavaScript uses floating point representation which has a fixed precision. For example, 12345678901234567890 === 12345678901234567000 in JavaScript because they have the same floating point representation. This means there is no JavaScript number that corresponds precisely to the 12345678901234567890 JSON number.
Let's assume you have a exact representation of some number (either via BigInt or a custom library):
jsconst data = {
  // Using a BigInt here to store the exact value,
  // but it can also be a custom high-precision number library,
  // if the number might not be an integer.
  gross_gdp: 12345678901234567890n,
};

You want to serialize it and then parse to the same exact number. There are several difficulties:

On the serialization side, in order to obtain a number in JSON, you have to pass a number to JSON.stringify, either via the replacer function or via the toJSON method. But, in either case, you have already lost precision during number conversion. If you pass a string to JSON.stringify, it will be serialized as a string, not a number.
On the parsing side, not all numbers can be represented exactly. For example, JSON.parse("12345678901234567890") returns 12345678901234568000 because the number is rounded to the nearest representable number. Even if you use a reviver function, the number will already be rounded before the reviver function is called.

There are, in general, two ways to ensure that numbers are losslessly converted to JSON and parsed back: one involves a JSON number, another involves a JSON string. JSON is a communication format, so if you use JSON, you are likely communicating with another system (HTTP request, storing in database, etc.). The best solution to choose depends on the recipient system.
Using JSON strings
If the recipient system does not have same JSON-handling capabilities as JavaScript, and does not support high precision numbers, you may want to serialize the number as a string, and then handle it as a string on the recipient side. This is also the only option in older JavaScript.
To specify how custom data types (including BigInt) should be serialized to JSON, either add a toJSON method to your data type, or use the replacer function of JSON.stringify().
js// Using toJSON() method
BigInt.prototype.toJSON = function () {
  return this.toString();
};
const str1 = JSON.stringify(data);

// Using JSON.stringify() with replacer
const str2 = JSON.stringify(data, (key, value) => {
  if (key === "gross_gdp") {
    return value.toString();
  }
  return value;
});

In either case, the JSON text will look like {"gross_gdp":"12345678901234567890"}, where the value is a string, not a number. Then, on the recipient side, you can parse the JSON and handle the string.
Using JSON numbers
If the recipient of this message natively supports high precision numbers (such as Python integers), passing numbers as JSON numbers is obviously better, because they can directly parse to the high precision type instead of parsing a string from JSON, and then parsing a number from the string. In JavaScript, you can serialize arbitrary data types to JSON numbers without producing a number value first (resulting in loss of precision) by using JSON.rawJSON() to precisely specify what the JSON source text should be.
js// Using toJSON() method
BigInt.prototype.toJSON = function () {
  return JSON.rawJSON(this.toString());
};
const str1 = JSON.stringify(data);

// Using JSON.stringify() with replacer
const str2 = JSON.stringify(data, (key, value) => {
  if (key === "gross_gdp") {
    return JSON.rawJSON(value.toString());
  }
  return value;
});

The text passed to JSON.rawJSON is treated as if it is already a piece of JSON, so it won't be serialized again as a string. Therefore, the JSON text will look like {"gross_gdp":12345678901234567890}, where the value is a number. This JSON can then be parsed by the recipient without any extra processing, provided that the recipient system does not have the same precision limitations as JavaScript.
When parsing JSON containing high-precision numbers in JavaScript, take extra care because when JSON.parse() invokes the reviver function, the value you receive is already parsed (and has lost precision). You can use the context.source parameter of the JSON.parse() reviver function to re-parse the number yourself.
jsconst parsedData = JSON.parse(str, (key, value, context) => {
  if (key === "gross_gdp") {
    // Or use the constructor of your custom high-precision number library
    return BigInt(context.source);
  }
  return value;
});
// { gross_gdp: 12345678901234567890n }
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json-objectBrowser compatibilitySee also
JSON Diff
JSON Beautifier/editor
JSON Parser
JSON Validator
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jan 20, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackDie JSON.stringify() statische Methode konvertiert einen JavaScript-Wert in einen JSON-String. Dabei können optional Werte ersetzt werden, falls eine Ersetzungsfunktion angegeben wird, oder es können nur die angegebenen Eigenschaften einbezogen werden, falls ein Ersetzungsarray spezifiziert wird.Probieren Sie es aus
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameter
value

Der zu konvertierende Wert in einen JSON-String.

replacer Optional

Eine Funktion, die das Verhalten des Stringifizierungsprozesses verändert, oder ein Array aus Zeichenfolgen und Zahlen, das die Eigenschaften von value spezifiziert, die in der Ausgabe enthalten sein sollen. Wenn replacer ein Array ist, werden alle Elemente in diesem Array, die keine Zeichenfolgen oder Zahlen sind (entweder primitive oder Wrapper-Objekte), einschließlich Symbol-Werte, komplett ignoriert. Wenn replacer etwas anderes als eine Funktion oder ein Array ist (z.B. null oder nicht bereitgestellt), werden alle string-bezogenen Eigenschaften des Objekts im resultierenden JSON-String enthalten.

space Optional

Eine Zeichenfolge oder Zahl, die verwendet wird, um Leerzeichen (einschließlich Einrückungen, Zeilenumbrüche etc.) in den ausgegebenen JSON-String einzufügen, um die Lesbarkeit zu erhöhen.
Ist dies eine Zahl, gibt sie die Anzahl der Leerzeichen an, die als Einrückung verwendet werden sollen, begrenzt auf 10 (das heißt, jede Zahl größer als 10 wird behandelt, als wäre sie 10). Werte kleiner als 1 bedeuten, dass kein Leerzeichen verwendet werden soll.
Ist dies eine Zeichenfolge, wird die Zeichenfolge (oder die ersten 10 Zeichen der Zeichenfolge, wenn sie länger ist) vor jedem verschachtelten Objekt oder Array eingefügt.
Wenn space etwas anderes als eine Zeichenfolge oder Zahl ist (kann entweder ein Primitiv oder ein Wrapper-Objekt sein) — z.B. null oder nicht bereitgestellt — werden keine Leerzeichen verwendet.

RückgabewertEin JSON-String, der den gegebenen Wert darstellt, oder undefined.Ausnahmen
TypeError

Wird in einem der folgenden Fälle ausgelöst:

value enthält eine zirkuläre Referenz.
Ein BigInt-Wert wird angetroffen.


BeschreibungJSON.stringify() konvertiert einen Wert in die JSON-Notation, die den Wert darstellt. Werte werden auf folgende Weise stringifiziert:


Boolean, Number, String und BigInt (erreichbar über Object()) Objekte werden während des Stringifizierens in die entsprechenden primitiven Werte konvertiert, gemäß der traditionellen Konvertierungssemantik. Symbol-Objekte (erreichbar über Object()) werden als einfache Objekte behandelt.


Der Versuch, BigInt-Werte zu serialisieren, wird einen Fehler auslösen. Hat das BigInt jedoch eine toJSON()-Methode (durch Monkey Patching: BigInt.prototype.toJSON = ...), kann diese Methode das Serialisierungsergebnis liefern. Diese Einschränkung stellt sicher, dass ein ordnungsgemäßes Serialisierungsverhalten (und sehr wahrscheinlich das zugehörige Deserialisierungsverhalten) immer explizit vom Benutzer bereitgestellt wird.


undefined, Function, und Symbol-Werte sind keine gültigen JSON-Werte. Wenn solche Werte während der Konvertierung angetroffen werden, werden sie entweder ausgelassen (wenn sie sich in einem Objekt befinden) oder in null geändert (wenn sie in einem Array gefunden werden). JSON.stringify() kann undefined zurückgeben, wenn "reine" Werte wie JSON.stringify(() => {}) oder JSON.stringify(undefined) übergeben werden.


Die Zahlen Infinity und NaN sowie der Wert null werden alle als null betrachtet. (Aber im Gegensatz zu den Werten im vorherigen Punkt werden sie niemals ausgelassen.)


Arrays werden als Arrays serialisiert (eingeschlossen in eckige Klammern). Nur Array-Indizes zwischen 0 und length - 1 (einschließlich) werden serialisiert; andere Eigenschaften werden ignoriert.


Das spezielle Roh-JSON-Objekt, das mit JSON.rawJSON() erstellt wurde, wird als das rohe JSON-Text serialisiert, das es enthält (durch Zugriff auf seine rawJSON-Eigenschaft).


Für andere Objekte:


Alle Symbol-Eigenschaften werden komplett ignoriert, auch wenn der replacer Parameter verwendet wird.


Wenn der Wert eine toJSON()-Methode hat, ist es verantwortlich zu definieren, welche Daten serialisiert werden. Anstelle des Objekts wird der Wert serialisiert, der von der toJSON()-Methode zurückgegeben wird, wenn sie aufgerufen wird. JSON.stringify() ruft toJSON mit einem Parameter auf, dem key, welcher dieselben Semantiken wie der key-Parameter der replacer-Funktion hat:

Wenn dieses Objekt ein Eigenschaftswert ist, der Eigenschaftenname.
Wenn es in einem Array ist, der Index im Array, als Zeichenfolge.
Wenn JSON.stringify() direkt auf diesem Objekt aufgerufen wurde, ein leerer String.

Alle Temporal-Objekte implementieren die toJSON()-Methode, die eine Zeichenfolge zurückgibt (dieselbe wie ein Aufruf von toString()). Daher werden sie als Zeichenfolgen serialisiert. Ähnlich implementieren Date-Objekte toJSON(), was dasselbe zurückgibt wie toISOString().


Es werden nur zählbare eigenen Eigenschaften besucht. Das bedeutet, Map, Set usw. werden zu "{}". Sie können den replacer Parameter verwenden, um sie in etwas Nützlicheres zu serialisieren.
Eigenschaften werden mit demselben Algorithmus besucht wie Object.keys(), der eine gut definierte Reihenfolge hat und stabil über Implementationen hinweg ist. Zum Beispiel wird JSON.stringify auf demselben Objekt immer denselben String erzeugen, und JSON.parse(JSON.stringify(obj)) würde ein Objekt mit derselben Schlüsselfolge wie das Original erzeugen (vorausgesetzt, dass das Objekt komplett JSON-serialisierbar ist).



Der replacer ParameterDer replacer Parameter kann entweder eine Funktion oder ein Array sein.
Als Array geben seine Elemente die Namen der Eigenschaften des Objekts an, die im resultierenden JSON-String enthalten sein sollen. Nur Zeichenfolgen und Zahlenwerte werden berücksichtigt; Symbol-Schlüssel werden ignoriert.
Als Funktion nimmt es zwei Parameter: den key und den value, der stringifiziert wird. Das Objekt, in dem der Schlüssel gefunden wurde, wird als this Kontext des replacer bereitgestellt.
Die replacer Funktion wird auch für das initial zu stringifizierende Objekt aufgerufen, in diesem Fall ist der key ein leerer String (""). Sie wird dann für jede Eigenschaft auf dem Objekt oder Array, das stringifiziert wird, aufgerufen. Array-Indizes werden in ihrer Zeichenform als key bereitgestellt. Der aktuelle Eigenschaftswert wird für die Stringifizierung durch den Rückgabewert des replacer ersetzt. Das bedeutet:

Wenn Sie eine Zahl, Zeichenfolge, Boolean oder null zurückgeben, wird dieser Wert direkt serialisiert und als Eigenschaftswert verwendet. (Das Zurückgeben eines BigInt wird ebenfalls einen Fehler auslösen.)
Wenn Sie eine Function, ein Symbol oder undefined zurückgeben, wird die Eigenschaft nicht in die Ausgabe aufgenommen.
Wenn Sie ein anderes Objekt zurückgeben, wird das Objekt rekursiv stringifiziert, wobei die replacer Funktion auf jede Eigenschaft aufgerufen wird.


Hinweis:
Wenn Sie JSON analysieren, das mit replacer Funktionen generiert wurde, möchten Sie wahrscheinlich den reviver Parameter verwenden, um die umgekehrte Operation durchzuführen.

Typischerweise würden sich Array-Elemente nicht verschieben (auch wenn das Element ein ungültiger Wert wie eine Funktion ist, wird es null statt ausgelassen). Die Verwendung der replacer Funktion ermöglicht es Ihnen, die Reihenfolge der Array-Elemente zu steuern, indem Sie ein anderes Array zurückgeben.Der space ParameterDer space Parameter kann verwendet werden, um den Abstand im endgültigen String zu steuern.

Wenn er eine Zahl ist, wird jede nachfolgende Ebene in der Stringifizierung um diese Anzahl von Leerzeichen eingezogen.
Wenn er eine Zeichenfolge ist, werden nachfolgende Ebenen mit dieser Zeichenfolge eingezogen.

Jede Einrückungsebene wird niemals länger als 10 sein. Zahlwerte von space sind auf 10 begrenzt, und Zeichenfolgenwerte sind auf 10 Zeichen gekürzt.BeispieleVerwendung von JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Verwendung einer Funktion als Ersetzerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

Wenn Sie möchten, dass der replacer ein initiales Objekt von einem Schlüssel mit einer leeren Zeichenfolge unterscheidet (da beide die leere Zeichenfolge als Schlüssel geben würden und potenziell ein Objekt als Wert), müssen Sie die Anzahl der Iterationen verfolgen (wenn es über die erste Iteration hinausgeht, ist es ein echter leerer Zeichenfolgeschlüssel).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Verwendung eines Arrays als Ersetzerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Verwendung des space ParametersRücken Sie die Ausgabe mit einem Leerzeichen ein:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Die Verwendung eines Tab-Zeichens ahmt ein standardmäßiges hübsch bedrucktes Erscheinungsbild nach:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() VerhaltenDie Definition von toJSON() für ein Objekt ermöglicht das Überschreiben seines Serialisierungsverhaltens.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Problem beim Serialisieren von zirkulären ReferenzenDa das JSON-Format keine Objektreferenzen unterstützt (obwohl ein IETF-Entwurf existiert), wird ein TypeError ausgelöst, wenn versucht wird, ein Objekt mit zirkulären Referenzen zu kodieren.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

Um zirkuläre Referenzen zu serialisieren, können Sie eine Bibliothek verwenden, die sie unterstützt (z.B. cycle.js von Douglas Crockford) oder eine Lösung selbst implementieren, die es erfordert, die zyklischen Referenzen durch serialisierbare Werte zu finden und zu ersetzen (oder zu entfernen).
Wenn Sie JSON.stringify() verwenden, um ein Objekt tief zu kopieren, möchten Sie stattdessen vielleicht structuredClone() verwenden, das zirkuläre Referenzen unterstützt. JavaScript-Engine-APIs für die binäre Serialisierung, wie v8.serialize(), unterstützen ebenfalls zirkuläre Referenzen.Verwendung von JSON.stringify() mit localStorageFalls Sie ein vom Benutzer erstelltes Objekt speichern und es wiederherstellen möchten, selbst nachdem der Browser geschlossen wurde, ist das folgende Beispiel ein Modell für die Anwendbarkeit von JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Wohlgeformtes JSON.stringify()Engines, die die wohlgeformte JSON.stringify-Spezifikation implementieren, werden alleinstehende Surrogates (jedes Code-Punkt von U+D800 bis U+DFFF) unter Verwendung von Unicode-Escape-Sequenzen anstatt buchstäblich (Ausgabe von alleinstehenden Surrogates) stringifizieren. Vor dieser Änderung konnten solche Zeichenfolgen nicht in gültigem UTF-8 oder UTF-16 kodiert werden:
jsJSON.stringify("\uD800"); // '"�"'

Aber mit dieser Änderung stellt JSON.stringify() alleinstehende Surrogates unter Verwendung von JSON-Escape-Sequenzen dar, die in validem UTF-8 oder UTF-16 kodiert werden können:
jsJSON.stringify("\uD800"); // '"\\ud800"'

Diese Änderung sollte rückwärtskompatibel sein, solange Sie das Ergebnis von JSON.stringify() an APIs wie JSON.parse() übergeben, die jeden gültigen JSON-Text akzeptieren, da sie Unicode-Escapes von alleinstehenden Surrogates genauso behandeln wie die alleinstehenden Surrogates selbst. Nur wenn Sie das Ergebnis von JSON.stringify() direkt interpretieren, müssen Sie die beiden möglichen Kodierungen dieser Code-Punkte von JSON.stringify() sorgfältig handhaben.SpezifikationenSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser-KompatibilitätSiehe auch
Polyfill des modernen JSON.stringify-Verhaltens (Symbol, wohlgeformtes Unicode, rohes JSON) in core-js
JSON.parse()
JSON.rawJSON()\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackDie JSON.stringify() statische Methode konvertiert einen JavaScript-Wert in einen JSON-String. Dabei können optional Werte ersetzt werden, falls eine Ersetzungsfunktion angegeben wird, oder es können nur die angegebenen Eigenschaften einbezogen werden, falls ein Ersetzungsarray spezifiziert wird.Probieren Sie es aus
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameter
value

Der zu konvertierende Wert in einen JSON-String.

replacer Optional

Eine Funktion, die das Verhalten des Stringifizierungsprozesses verändert, oder ein Array aus Zeichenfolgen und Zahlen, das die Eigenschaften von value spezifiziert, die in der Ausgabe enthalten sein sollen. Wenn replacer ein Array ist, werden alle Elemente in diesem Array, die keine Zeichenfolgen oder Zahlen sind (entweder primitive oder Wrapper-Objekte), einschließlich Symbol-Werte, komplett ignoriert. Wenn replacer etwas anderes als eine Funktion oder ein Array ist (z.B. null oder nicht bereitgestellt), werden alle string-bezogenen Eigenschaften des Objekts im resultierenden JSON-String enthalten.

space Optional

Eine Zeichenfolge oder Zahl, die verwendet wird, um Leerzeichen (einschließlich Einrückungen, Zeilenumbrüche etc.) in den ausgegebenen JSON-String einzufügen, um die Lesbarkeit zu erhöhen.
Ist dies eine Zahl, gibt sie die Anzahl der Leerzeichen an, die als Einrückung verwendet werden sollen, begrenzt auf 10 (das heißt, jede Zahl größer als 10 wird behandelt, als wäre sie 10). Werte kleiner als 1 bedeuten, dass kein Leerzeichen verwendet werden soll.
Ist dies eine Zeichenfolge, wird die Zeichenfolge (oder die ersten 10 Zeichen der Zeichenfolge, wenn sie länger ist) vor jedem verschachtelten Objekt oder Array eingefügt.
Wenn space etwas anderes als eine Zeichenfolge oder Zahl ist (kann entweder ein Primitiv oder ein Wrapper-Objekt sein) — z.B. null oder nicht bereitgestellt — werden keine Leerzeichen verwendet.

RückgabewertEin JSON-String, der den gegebenen Wert darstellt, oder undefined.Ausnahmen
TypeError

Wird in einem der folgenden Fälle ausgelöst:

value enthält eine zirkuläre Referenz.
Ein BigInt-Wert wird angetroffen.


BeschreibungJSON.stringify() konvertiert einen Wert in die JSON-Notation, die den Wert darstellt. Werte werden auf folgende Weise stringifiziert:


Boolean, Number, String und BigInt (erreichbar über Object()) Objekte werden während des Stringifizierens in die entsprechenden primitiven Werte konvertiert, gemäß der traditionellen Konvertierungssemantik. Symbol-Objekte (erreichbar über Object()) werden als einfache Objekte behandelt.


Der Versuch, BigInt-Werte zu serialisieren, wird einen Fehler auslösen. Hat das BigInt jedoch eine toJSON()-Methode (durch Monkey Patching: BigInt.prototype.toJSON = ...), kann diese Methode das Serialisierungsergebnis liefern. Diese Einschränkung stellt sicher, dass ein ordnungsgemäßes Serialisierungsverhalten (und sehr wahrscheinlich das zugehörige Deserialisierungsverhalten) immer explizit vom Benutzer bereitgestellt wird.


undefined, Function, und Symbol-Werte sind keine gültigen JSON-Werte. Wenn solche Werte während der Konvertierung angetroffen werden, werden sie entweder ausgelassen (wenn sie sich in einem Objekt befinden) oder in null geändert (wenn sie in einem Array gefunden werden). JSON.stringify() kann undefined zurückgeben, wenn "reine" Werte wie JSON.stringify(() => {}) oder JSON.stringify(undefined) übergeben werden.


Die Zahlen Infinity und NaN sowie der Wert null werden alle als null betrachtet. (Aber im Gegensatz zu den Werten im vorherigen Punkt werden sie niemals ausgelassen.)


Arrays werden als Arrays serialisiert (eingeschlossen in eckige Klammern). Nur Array-Indizes zwischen 0 und length - 1 (einschließlich) werden serialisiert; andere Eigenschaften werden ignoriert.


Das spezielle Roh-JSON-Objekt, das mit JSON.rawJSON() erstellt wurde, wird als das rohe JSON-Text serialisiert, das es enthält (durch Zugriff auf seine rawJSON-Eigenschaft).


Für andere Objekte:


Alle Symbol-Eigenschaften werden komplett ignoriert, auch wenn der replacer Parameter verwendet wird.


Wenn der Wert eine toJSON()-Methode hat, ist es verantwortlich zu definieren, welche Daten serialisiert werden. Anstelle des Objekts wird der Wert serialisiert, der von der toJSON()-Methode zurückgegeben wird, wenn sie aufgerufen wird. JSON.stringify() ruft toJSON mit einem Parameter auf, dem key, welcher dieselben Semantiken wie der key-Parameter der replacer-Funktion hat:

Wenn dieses Objekt ein Eigenschaftswert ist, der Eigenschaftenname.
Wenn es in einem Array ist, der Index im Array, als Zeichenfolge.
Wenn JSON.stringify() direkt auf diesem Objekt aufgerufen wurde, ein leerer String.

Alle Temporal-Objekte implementieren die toJSON()-Methode, die eine Zeichenfolge zurückgibt (dieselbe wie ein Aufruf von toString()). Daher werden sie als Zeichenfolgen serialisiert. Ähnlich implementieren Date-Objekte toJSON(), was dasselbe zurückgibt wie toISOString().


Es werden nur zählbare eigenen Eigenschaften besucht. Das bedeutet, Map, Set usw. werden zu "{}". Sie können den replacer Parameter verwenden, um sie in etwas Nützlicheres zu serialisieren.
Eigenschaften werden mit demselben Algorithmus besucht wie Object.keys(), der eine gut definierte Reihenfolge hat und stabil über Implementationen hinweg ist. Zum Beispiel wird JSON.stringify auf demselben Objekt immer denselben String erzeugen, und JSON.parse(JSON.stringify(obj)) würde ein Objekt mit derselben Schlüsselfolge wie das Original erzeugen (vorausgesetzt, dass das Objekt komplett JSON-serialisierbar ist).



Der replacer ParameterDer replacer Parameter kann entweder eine Funktion oder ein Array sein.
Als Array geben seine Elemente die Namen der Eigenschaften des Objekts an, die im resultierenden JSON-String enthalten sein sollen. Nur Zeichenfolgen und Zahlenwerte werden berücksichtigt; Symbol-Schlüssel werden ignoriert.
Als Funktion nimmt es zwei Parameter: den key und den value, der stringifiziert wird. Das Objekt, in dem der Schlüssel gefunden wurde, wird als this Kontext des replacer bereitgestellt.
Die replacer Funktion wird auch für das initial zu stringifizierende Objekt aufgerufen, in diesem Fall ist der key ein leerer String (""). Sie wird dann für jede Eigenschaft auf dem Objekt oder Array, das stringifiziert wird, aufgerufen. Array-Indizes werden in ihrer Zeichenform als key bereitgestellt. Der aktuelle Eigenschaftswert wird für die Stringifizierung durch den Rückgabewert des replacer ersetzt. Das bedeutet:

Wenn Sie eine Zahl, Zeichenfolge, Boolean oder null zurückgeben, wird dieser Wert direkt serialisiert und als Eigenschaftswert verwendet. (Das Zurückgeben eines BigInt wird ebenfalls einen Fehler auslösen.)
Wenn Sie eine Function, ein Symbol oder undefined zurückgeben, wird die Eigenschaft nicht in die Ausgabe aufgenommen.
Wenn Sie ein anderes Objekt zurückgeben, wird das Objekt rekursiv stringifiziert, wobei die replacer Funktion auf jede Eigenschaft aufgerufen wird.


Hinweis:
Wenn Sie JSON analysieren, das mit replacer Funktionen generiert wurde, möchten Sie wahrscheinlich den reviver Parameter verwenden, um die umgekehrte Operation durchzuführen.

Typischerweise würden sich Array-Elemente nicht verschieben (auch wenn das Element ein ungültiger Wert wie eine Funktion ist, wird es null statt ausgelassen). Die Verwendung der replacer Funktion ermöglicht es Ihnen, die Reihenfolge der Array-Elemente zu steuern, indem Sie ein anderes Array zurückgeben.Der space ParameterDer space Parameter kann verwendet werden, um den Abstand im endgültigen String zu steuern.

Wenn er eine Zahl ist, wird jede nachfolgende Ebene in der Stringifizierung um diese Anzahl von Leerzeichen eingezogen.
Wenn er eine Zeichenfolge ist, werden nachfolgende Ebenen mit dieser Zeichenfolge eingezogen.

Jede Einrückungsebene wird niemals länger als 10 sein. Zahlwerte von space sind auf 10 begrenzt, und Zeichenfolgenwerte sind auf 10 Zeichen gekürzt.BeispieleVerwendung von JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Verwendung einer Funktion als Ersetzerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

Wenn Sie möchten, dass der replacer ein initiales Objekt von einem Schlüssel mit einer leeren Zeichenfolge unterscheidet (da beide die leere Zeichenfolge als Schlüssel geben würden und potenziell ein Objekt als Wert), müssen Sie die Anzahl der Iterationen verfolgen (wenn es über die erste Iteration hinausgeht, ist es ein echter leerer Zeichenfolgeschlüssel).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Verwendung eines Arrays als Ersetzerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Verwendung des space ParametersRücken Sie die Ausgabe mit einem Leerzeichen ein:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Die Verwendung eines Tab-Zeichens ahmt ein standardmäßiges hübsch bedrucktes Erscheinungsbild nach:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() VerhaltenDie Definition von toJSON() für ein Objekt ermöglicht das Überschreiben seines Serialisierungsverhaltens.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Problem beim Serialisieren von zirkulären ReferenzenDa das JSON-Format keine Objektreferenzen unterstützt (obwohl ein IETF-Entwurf existiert), wird ein TypeError ausgelöst, wenn versucht wird, ein Objekt mit zirkulären Referenzen zu kodieren.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

Um zirkuläre Referenzen zu serialisieren, können Sie eine Bibliothek verwenden, die sie unterstützt (z.B. cycle.js von Douglas Crockford) oder eine Lösung selbst implementieren, die es erfordert, die zyklischen Referenzen durch serialisierbare Werte zu finden und zu ersetzen (oder zu entfernen).
Wenn Sie JSON.stringify() verwenden, um ein Objekt tief zu kopieren, möchten Sie stattdessen vielleicht structuredClone() verwenden, das zirkuläre Referenzen unterstützt. JavaScript-Engine-APIs für die binäre Serialisierung, wie v8.serialize(), unterstützen ebenfalls zirkuläre Referenzen.Verwendung von JSON.stringify() mit localStorageFalls Sie ein vom Benutzer erstelltes Objekt speichern und es wiederherstellen möchten, selbst nachdem der Browser geschlossen wurde, ist das folgende Beispiel ein Modell für die Anwendbarkeit von JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Wohlgeformtes JSON.stringify()Engines, die die wohlgeformte JSON.stringify-Spezifikation implementieren, werden alleinstehende Surrogates (jedes Code-Punkt von U+D800 bis U+DFFF) unter Verwendung von Unicode-Escape-Sequenzen anstatt buchstäblich (Ausgabe von alleinstehenden Surrogates) stringifizieren. Vor dieser Änderung konnten solche Zeichenfolgen nicht in gültigem UTF-8 oder UTF-16 kodiert werden:
jsJSON.stringify("\uD800"); // '"�"'

Aber mit dieser Änderung stellt JSON.stringify() alleinstehende Surrogates unter Verwendung von JSON-Escape-Sequenzen dar, die in validem UTF-8 oder UTF-16 kodiert werden können:
jsJSON.stringify("\uD800"); // '"\\ud800"'

Diese Änderung sollte rückwärtskompatibel sein, solange Sie das Ergebnis von JSON.stringify() an APIs wie JSON.parse() übergeben, die jeden gültigen JSON-Text akzeptieren, da sie Unicode-Escapes von alleinstehenden Surrogates genauso behandeln wie die alleinstehenden Surrogates selbst. Nur wenn Sie das Ergebnis von JSON.stringify() direkt interpretieren, müssen Sie die beiden möglichen Kodierungen dieser Code-Punkte von JSON.stringify() sorgfältig handhaben.SpezifikationenSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser-KompatibilitätSiehe auch
Polyfill des modernen JSON.stringify-Verhaltens (Symbol, wohlgeformtes Unicode, rohes JSON) in core-js
JSON.parse()
JSON.rawJSON()
MDN-Feedback-BoxWar diese Übersetzung hilfreich?JaNeinDiese Seite wurde automatisch aus dem Englischen übersetzt.Übersetzung auf GitHub anzeigen • Fehler mit dieser Übersetzung melden\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackDie JSON.stringify() statische Methode konvertiert einen JavaScript-Wert in einen JSON-String. Dabei können optional Werte ersetzt werden, falls eine Ersetzungsfunktion angegeben wird, oder es können nur die angegebenen Eigenschaften einbezogen werden, falls ein Ersetzungsarray spezifiziert wird.Probieren Sie es aus
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameter
value

Der zu konvertierende Wert in einen JSON-String.

replacer Optional

Eine Funktion, die das Verhalten des Stringifizierungsprozesses verändert, oder ein Array aus Zeichenfolgen und Zahlen, das die Eigenschaften von value spezifiziert, die in der Ausgabe enthalten sein sollen. Wenn replacer ein Array ist, werden alle Elemente in diesem Array, die keine Zeichenfolgen oder Zahlen sind (entweder primitive oder Wrapper-Objekte), einschließlich Symbol-Werte, komplett ignoriert. Wenn replacer etwas anderes als eine Funktion oder ein Array ist (z.B. null oder nicht bereitgestellt), werden alle string-bezogenen Eigenschaften des Objekts im resultierenden JSON-String enthalten.

space Optional

Eine Zeichenfolge oder Zahl, die verwendet wird, um Leerzeichen (einschließlich Einrückungen, Zeilenumbrüche etc.) in den ausgegebenen JSON-String einzufügen, um die Lesbarkeit zu erhöhen.
Ist dies eine Zahl, gibt sie die Anzahl der Leerzeichen an, die als Einrückung verwendet werden sollen, begrenzt auf 10 (das heißt, jede Zahl größer als 10 wird behandelt, als wäre sie 10). Werte kleiner als 1 bedeuten, dass kein Leerzeichen verwendet werden soll.
Ist dies eine Zeichenfolge, wird die Zeichenfolge (oder die ersten 10 Zeichen der Zeichenfolge, wenn sie länger ist) vor jedem verschachtelten Objekt oder Array eingefügt.
Wenn space etwas anderes als eine Zeichenfolge oder Zahl ist (kann entweder ein Primitiv oder ein Wrapper-Objekt sein) — z.B. null oder nicht bereitgestellt — werden keine Leerzeichen verwendet.

RückgabewertEin JSON-String, der den gegebenen Wert darstellt, oder undefined.Ausnahmen
TypeError

Wird in einem der folgenden Fälle ausgelöst:

value enthält eine zirkuläre Referenz.
Ein BigInt-Wert wird angetroffen.


BeschreibungJSON.stringify() konvertiert einen Wert in die JSON-Notation, die den Wert darstellt. Werte werden auf folgende Weise stringifiziert:


Boolean, Number, String und BigInt (erreichbar über Object()) Objekte werden während des Stringifizierens in die entsprechenden primitiven Werte konvertiert, gemäß der traditionellen Konvertierungssemantik. Symbol-Objekte (erreichbar über Object()) werden als einfache Objekte behandelt.


Der Versuch, BigInt-Werte zu serialisieren, wird einen Fehler auslösen. Hat das BigInt jedoch eine toJSON()-Methode (durch Monkey Patching: BigInt.prototype.toJSON = ...), kann diese Methode das Serialisierungsergebnis liefern. Diese Einschränkung stellt sicher, dass ein ordnungsgemäßes Serialisierungsverhalten (und sehr wahrscheinlich das zugehörige Deserialisierungsverhalten) immer explizit vom Benutzer bereitgestellt wird.


undefined, Function, und Symbol-Werte sind keine gültigen JSON-Werte. Wenn solche Werte während der Konvertierung angetroffen werden, werden sie entweder ausgelassen (wenn sie sich in einem Objekt befinden) oder in null geändert (wenn sie in einem Array gefunden werden). JSON.stringify() kann undefined zurückgeben, wenn "reine" Werte wie JSON.stringify(() => {}) oder JSON.stringify(undefined) übergeben werden.


Die Zahlen Infinity und NaN sowie der Wert null werden alle als null betrachtet. (Aber im Gegensatz zu den Werten im vorherigen Punkt werden sie niemals ausgelassen.)


Arrays werden als Arrays serialisiert (eingeschlossen in eckige Klammern). Nur Array-Indizes zwischen 0 und length - 1 (einschließlich) werden serialisiert; andere Eigenschaften werden ignoriert.


Das spezielle Roh-JSON-Objekt, das mit JSON.rawJSON() erstellt wurde, wird als das rohe JSON-Text serialisiert, das es enthält (durch Zugriff auf seine rawJSON-Eigenschaft).


Für andere Objekte:


Alle Symbol-Eigenschaften werden komplett ignoriert, auch wenn der replacer Parameter verwendet wird.


Wenn der Wert eine toJSON()-Methode hat, ist es verantwortlich zu definieren, welche Daten serialisiert werden. Anstelle des Objekts wird der Wert serialisiert, der von der toJSON()-Methode zurückgegeben wird, wenn sie aufgerufen wird. JSON.stringify() ruft toJSON mit einem Parameter auf, dem key, welcher dieselben Semantiken wie der key-Parameter der replacer-Funktion hat:

Wenn dieses Objekt ein Eigenschaftswert ist, der Eigenschaftenname.
Wenn es in einem Array ist, der Index im Array, als Zeichenfolge.
Wenn JSON.stringify() direkt auf diesem Objekt aufgerufen wurde, ein leerer String.

Alle Temporal-Objekte implementieren die toJSON()-Methode, die eine Zeichenfolge zurückgibt (dieselbe wie ein Aufruf von toString()). Daher werden sie als Zeichenfolgen serialisiert. Ähnlich implementieren Date-Objekte toJSON(), was dasselbe zurückgibt wie toISOString().


Es werden nur zählbare eigenen Eigenschaften besucht. Das bedeutet, Map, Set usw. werden zu "{}". Sie können den replacer Parameter verwenden, um sie in etwas Nützlicheres zu serialisieren.
Eigenschaften werden mit demselben Algorithmus besucht wie Object.keys(), der eine gut definierte Reihenfolge hat und stabil über Implementationen hinweg ist. Zum Beispiel wird JSON.stringify auf demselben Objekt immer denselben String erzeugen, und JSON.parse(JSON.stringify(obj)) würde ein Objekt mit derselben Schlüsselfolge wie das Original erzeugen (vorausgesetzt, dass das Objekt komplett JSON-serialisierbar ist).



Der replacer ParameterDer replacer Parameter kann entweder eine Funktion oder ein Array sein.
Als Array geben seine Elemente die Namen der Eigenschaften des Objekts an, die im resultierenden JSON-String enthalten sein sollen. Nur Zeichenfolgen und Zahlenwerte werden berücksichtigt; Symbol-Schlüssel werden ignoriert.
Als Funktion nimmt es zwei Parameter: den key und den value, der stringifiziert wird. Das Objekt, in dem der Schlüssel gefunden wurde, wird als this Kontext des replacer bereitgestellt.
Die replacer Funktion wird auch für das initial zu stringifizierende Objekt aufgerufen, in diesem Fall ist der key ein leerer String (""). Sie wird dann für jede Eigenschaft auf dem Objekt oder Array, das stringifiziert wird, aufgerufen. Array-Indizes werden in ihrer Zeichenform als key bereitgestellt. Der aktuelle Eigenschaftswert wird für die Stringifizierung durch den Rückgabewert des replacer ersetzt. Das bedeutet:

Wenn Sie eine Zahl, Zeichenfolge, Boolean oder null zurückgeben, wird dieser Wert direkt serialisiert und als Eigenschaftswert verwendet. (Das Zurückgeben eines BigInt wird ebenfalls einen Fehler auslösen.)
Wenn Sie eine Function, ein Symbol oder undefined zurückgeben, wird die Eigenschaft nicht in die Ausgabe aufgenommen.
Wenn Sie ein anderes Objekt zurückgeben, wird das Objekt rekursiv stringifiziert, wobei die replacer Funktion auf jede Eigenschaft aufgerufen wird.


Hinweis:
Wenn Sie JSON analysieren, das mit replacer Funktionen generiert wurde, möchten Sie wahrscheinlich den reviver Parameter verwenden, um die umgekehrte Operation durchzuführen.

Typischerweise würden sich Array-Elemente nicht verschieben (auch wenn das Element ein ungültiger Wert wie eine Funktion ist, wird es null statt ausgelassen). Die Verwendung der replacer Funktion ermöglicht es Ihnen, die Reihenfolge der Array-Elemente zu steuern, indem Sie ein anderes Array zurückgeben.Der space ParameterDer space Parameter kann verwendet werden, um den Abstand im endgültigen String zu steuern.

Wenn er eine Zahl ist, wird jede nachfolgende Ebene in der Stringifizierung um diese Anzahl von Leerzeichen eingezogen.
Wenn er eine Zeichenfolge ist, werden nachfolgende Ebenen mit dieser Zeichenfolge eingezogen.

Jede Einrückungsebene wird niemals länger als 10 sein. Zahlwerte von space sind auf 10 begrenzt, und Zeichenfolgenwerte sind auf 10 Zeichen gekürzt.BeispieleVerwendung von JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Verwendung einer Funktion als Ersetzerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

Wenn Sie möchten, dass der replacer ein initiales Objekt von einem Schlüssel mit einer leeren Zeichenfolge unterscheidet (da beide die leere Zeichenfolge als Schlüssel geben würden und potenziell ein Objekt als Wert), müssen Sie die Anzahl der Iterationen verfolgen (wenn es über die erste Iteration hinausgeht, ist es ein echter leerer Zeichenfolgeschlüssel).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Verwendung eines Arrays als Ersetzerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Verwendung des space ParametersRücken Sie die Ausgabe mit einem Leerzeichen ein:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Die Verwendung eines Tab-Zeichens ahmt ein standardmäßiges hübsch bedrucktes Erscheinungsbild nach:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() VerhaltenDie Definition von toJSON() für ein Objekt ermöglicht das Überschreiben seines Serialisierungsverhaltens.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Problem beim Serialisieren von zirkulären ReferenzenDa das JSON-Format keine Objektreferenzen unterstützt (obwohl ein IETF-Entwurf existiert), wird ein TypeError ausgelöst, wenn versucht wird, ein Objekt mit zirkulären Referenzen zu kodieren.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

Um zirkuläre Referenzen zu serialisieren, können Sie eine Bibliothek verwenden, die sie unterstützt (z.B. cycle.js von Douglas Crockford) oder eine Lösung selbst implementieren, die es erfordert, die zyklischen Referenzen durch serialisierbare Werte zu finden und zu ersetzen (oder zu entfernen).
Wenn Sie JSON.stringify() verwenden, um ein Objekt tief zu kopieren, möchten Sie stattdessen vielleicht structuredClone() verwenden, das zirkuläre Referenzen unterstützt. JavaScript-Engine-APIs für die binäre Serialisierung, wie v8.serialize(), unterstützen ebenfalls zirkuläre Referenzen.Verwendung von JSON.stringify() mit localStorageFalls Sie ein vom Benutzer erstelltes Objekt speichern und es wiederherstellen möchten, selbst nachdem der Browser geschlossen wurde, ist das folgende Beispiel ein Modell für die Anwendbarkeit von JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Wohlgeformtes JSON.stringify()Engines, die die wohlgeformte JSON.stringify-Spezifikation implementieren, werden alleinstehende Surrogates (jedes Code-Punkt von U+D800 bis U+DFFF) unter Verwendung von Unicode-Escape-Sequenzen anstatt buchstäblich (Ausgabe von alleinstehenden Surrogates) stringifizieren. Vor dieser Änderung konnten solche Zeichenfolgen nicht in gültigem UTF-8 oder UTF-16 kodiert werden:
jsJSON.stringify("\uD800"); // '"�"'

Aber mit dieser Änderung stellt JSON.stringify() alleinstehende Surrogates unter Verwendung von JSON-Escape-Sequenzen dar, die in validem UTF-8 oder UTF-16 kodiert werden können:
jsJSON.stringify("\uD800"); // '"\\ud800"'

Diese Änderung sollte rückwärtskompatibel sein, solange Sie das Ergebnis von JSON.stringify() an APIs wie JSON.parse() übergeben, die jeden gültigen JSON-Text akzeptieren, da sie Unicode-Escapes von alleinstehenden Surrogates genauso behandeln wie die alleinstehenden Surrogates selbst. Nur wenn Sie das Ergebnis von JSON.stringify() direkt interpretieren, müssen Sie die beiden möglichen Kodierungen dieser Code-Punkte von JSON.stringify() sorgfältig handhaben.SpezifikationenSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser-KompatibilitätSiehe auch
Polyfill des modernen JSON.stringify-Verhaltens (Symbol, wohlgeformtes Unicode, rohes JSON) in core-js
JSON.parse()
JSON.rawJSON()
MDN-Feedback-BoxWar diese Übersetzung hilfreich?JaNeinDiese Seite wurde automatisch aus dem Englischen übersetzt.Übersetzung auf GitHub anzeigen • Fehler mit dieser Übersetzung melden\n\n\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackEl método JSON.stringify() convierte un objeto o valor de JavaScript en una cadena de texto JSON, opcionalmente reemplaza valores si se indica una función de reemplazo, o si se especifican las propiedades mediante un array de reemplazo.Pruébalo
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SintaxisJSON.stringify(value[, replacer[, space]])
Parámetros
value

El valor que será convertido a una cadena JSON.

replacerOpcional

Una función que altera el comportamiento del proceso de conversión a cadena de texto, o un array de objetos String o Number que representan una lista de elementos válidos que se incluyen en la cadena JSON. Si este valor es null o no se define, todas las propiedades del objeto son incluidas en la cadena de texto JSON resultante.

spaceOpcional

Un objeto de tipo String o Number que se utiliza para insertar un espacio en blanco dentro de la cadena de salida JSON para mejorar su legibilidad.Si es de tipo Number, indica el número de espacios a usar como espacios en blanco; este número está limitado se limita a 10 (si es mayor, el valor es sólo 10). Los valores inferiores a 1 indican que no se deben utilizar espacios.Si es de tipo String, la cadena de texto (o sus 10 primeros caracteres, si es mayor) se utiliza como espacios en blanco. Si este parámetro no se define o es null, no se utilizará ningún espacio en blanco.

Valor devueltoUna cadena de texto JSON que representa el valor dado.ExcepcionesLanza una excepción TypeError ("cyclic object value") cuando encuentra una referencia circular.DescripciónJSON.stringify convierte un valor a notación JSON representándolo:

Si el valor tiene un método toJSON(), es responsable de definir qué será serializado.
Los objetos Boolean, Number, and String se convierten a sus valores primitivos, de acuerdo con la conversión semántica tradicional.
Si durante la conversión se encuentra un undefined, una Function, o un Symbol se omite (cuando se encuentra en un objeto) o se censura a null (cuando se encuentra en un array). JSON.stringify() puede devolver undefined cuando se pasan valores "puros" como JSON.stringify(function(){}) o JSON.stringify(undefined).
Todas las propiedades que utilicen Symbol en los nombres de la clave se ignoran por completo, incluso si utilizan una función replacer.
Las instancias de Date implementan la función toJSON() devolviendo una cadena de texto (igual que date.toISOString()). Por lo que son tratadas como strings.
Los números Infinity y NaN, así como el valor null, se consideran null.
El resto de instancias de Object (incluyendo Map, Set, WeakMap, y WeakSet) sólo tendrán serializadas sus propiedades enumerables.

jsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(2006, 0, 2, 15, 4, 5));
// '"2006-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// Elementos de array identificados por string no son enumerables y no tienen sentido en JSON
let a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Estructuras de datos standard
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Símbolos:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, function (k, v) {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Propiedades no enumerables:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'
El parámetro replacerEl parámetro replacer (de reemplazo) puede ser tanto una función como o un array.
Como una función toma dos parámetros: el valor y la clave que van a ser procesados. El objeto al cual pertenece la clave representa el parametro this del reemplazo.
Inicialmente es llamado con una clave vacía y representa el objeto que se va a procesar, y solo después es llamado por cada propiedad en el objeto o array que se va a procesar.
Devuelve el valor que se va a agregar a la cadena JSON, de la siguiente manera:

Si se devuelve un número, la cadena correspondiente es usada como el valor de la propiedad cuando se agrega a la cadena JSON.
Si se devuelve una cadena, esta es usuada cono el valor de la propiedad cuando se agrega a la cadena JSON.
Si se devuelve un Boolean, true o false son usados como el valor de la propiedad cuando se agrega a la cadena JSON.
Si se devuelve algún otro objeto, este es recursivamente procesado en una cadena JSON llamando a la función de reemplazo para cada propiedad, amenos que el objeto sea una función, en tal caso nada se agrega a la cadena JSON.
Si se devuelve undefined, la propiedad no se incluye en la salida de la cadena JSON.


Nota:
No se puede usar la función de reemplazo para borrar los valores de un array. Si se devuelve undefined o una función, entonces se usara null en su lugar.

Ejemplo con una función
jsfunction replacer(key, value) {
  // Filtrando propiedades
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

var foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
var jsonString = JSON.stringify(foo, replacer);
// '{"week":45, "month":7}'

El resultado en una cadena JSON sería: {"week":45,"month":7}.
Ejemplo con un array
Si el reemplazo es un array, los valores indican los nombres de las propiedades del objeto que se va a incluir en la cadena JSON resultado.
jsJSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', sólo mantiene las propiedades de "week" y de "month"
Argumento spaceEste argumento puede ser empleado para controlar el espaciado en la cadena final. Si es un número, los niveles sucesivos del proceso serán identados cada uno por tantos espacios como se indique (hasta 10). Si es una cadena, serán identados con dicha cadena (o los primeros diez caracteres de la misma).
jsJSON.stringify({ a: 2 }, null, " ");
// regresa la cadena de texto:
// '{
//  "a": 2
// }'

Usar el carácter tabulador simula la apariencia de impresión:
jsJSON.stringify({ uno: 1, dos: 2 }, null, "\t");
// devuelve el string:
// '{            \
//     "uno": 1, \
//     "dos": 2  \
// }'
Comportamiento toJSON()Si un objeto que sera estringificado tiene una propiedad llamada toJSON donde su valor es una función, entonces el método toJSON modifica el comportamiento de la estringificación JSON: en lugar del objeto que esta siendo serializado, el valor retornado por el método toJSON será serializado cuando el mismo sea llamado. Por ejemplo:
jsvar obj = {
  foo: "foo",
  toJSON: function () {
    return "bar";
  },
};
var json = JSON.stringify({ x: obj }); // '{"x":"bar"}'.
Ejemplo de como usar JSON.stringify() con localStorageEn dado caso en el cual se requiera que un objeto creado por el usuario y al cual se le permita ser restaurado incluso cuando el navegador ha sido cerrado, el siguiente ejemplo es un modelo de la aplicabilidad del metodo JSON. stringify().

Advertencia:
Las funciones no son un tipo de dato valido por lo cual estas no funcionaran. Algunos objetos como tipo DATE, se convertiran a cadenas de texto despues de ejecutar JSON.parse().

js// Creando un ejemplo de JSON
var session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Convirte el JSON string con JSON.stringify()
// entonces guarda con localStorage con el nombre de la sesión
localStorage.setItem("session", JSON.stringify(session));

// Ejemplo de como transformar el String generado usando
// JSON.stringify() y guardándolo en localStorage como objeto JSON otra vez
var restoredSession = JSON.parse(localStorage.getItem("session"));

// Ahora la variable restoredSession contiene el objeto que fue guardado
// en localStorage
console.log(restoredSession);
EspecificacionesSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyCompatibilidad con navegadoresVer también
JSON.parse()
cycle.js – Introduces two functions: JSON.decycle and JSON.retrocycle. These allow encoding and decoding of cyclical structures and DAGs into an extended and retrocompatible JSON format.\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackEl método JSON.stringify() convierte un objeto o valor de JavaScript en una cadena de texto JSON, opcionalmente reemplaza valores si se indica una función de reemplazo, o si se especifican las propiedades mediante un array de reemplazo.Pruébalo
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SintaxisJSON.stringify(value[, replacer[, space]])
Parámetros
value

El valor que será convertido a una cadena JSON.

replacerOpcional

Una función que altera el comportamiento del proceso de conversión a cadena de texto, o un array de objetos String o Number que representan una lista de elementos válidos que se incluyen en la cadena JSON. Si este valor es null o no se define, todas las propiedades del objeto son incluidas en la cadena de texto JSON resultante.

spaceOpcional

Un objeto de tipo String o Number que se utiliza para insertar un espacio en blanco dentro de la cadena de salida JSON para mejorar su legibilidad.Si es de tipo Number, indica el número de espacios a usar como espacios en blanco; este número está limitado se limita a 10 (si es mayor, el valor es sólo 10). Los valores inferiores a 1 indican que no se deben utilizar espacios.Si es de tipo String, la cadena de texto (o sus 10 primeros caracteres, si es mayor) se utiliza como espacios en blanco. Si este parámetro no se define o es null, no se utilizará ningún espacio en blanco.

Valor devueltoUna cadena de texto JSON que representa el valor dado.ExcepcionesLanza una excepción TypeError ("cyclic object value") cuando encuentra una referencia circular.DescripciónJSON.stringify convierte un valor a notación JSON representándolo:

Si el valor tiene un método toJSON(), es responsable de definir qué será serializado.
Los objetos Boolean, Number, and String se convierten a sus valores primitivos, de acuerdo con la conversión semántica tradicional.
Si durante la conversión se encuentra un undefined, una Function, o un Symbol se omite (cuando se encuentra en un objeto) o se censura a null (cuando se encuentra en un array). JSON.stringify() puede devolver undefined cuando se pasan valores "puros" como JSON.stringify(function(){}) o JSON.stringify(undefined).
Todas las propiedades que utilicen Symbol en los nombres de la clave se ignoran por completo, incluso si utilizan una función replacer.
Las instancias de Date implementan la función toJSON() devolviendo una cadena de texto (igual que date.toISOString()). Por lo que son tratadas como strings.
Los números Infinity y NaN, así como el valor null, se consideran null.
El resto de instancias de Object (incluyendo Map, Set, WeakMap, y WeakSet) sólo tendrán serializadas sus propiedades enumerables.

jsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(2006, 0, 2, 15, 4, 5));
// '"2006-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// Elementos de array identificados por string no son enumerables y no tienen sentido en JSON
let a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Estructuras de datos standard
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Símbolos:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, function (k, v) {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Propiedades no enumerables:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'
El parámetro replacerEl parámetro replacer (de reemplazo) puede ser tanto una función como o un array.
Como una función toma dos parámetros: el valor y la clave que van a ser procesados. El objeto al cual pertenece la clave representa el parametro this del reemplazo.
Inicialmente es llamado con una clave vacía y representa el objeto que se va a procesar, y solo después es llamado por cada propiedad en el objeto o array que se va a procesar.
Devuelve el valor que se va a agregar a la cadena JSON, de la siguiente manera:

Si se devuelve un número, la cadena correspondiente es usada como el valor de la propiedad cuando se agrega a la cadena JSON.
Si se devuelve una cadena, esta es usuada cono el valor de la propiedad cuando se agrega a la cadena JSON.
Si se devuelve un Boolean, true o false son usados como el valor de la propiedad cuando se agrega a la cadena JSON.
Si se devuelve algún otro objeto, este es recursivamente procesado en una cadena JSON llamando a la función de reemplazo para cada propiedad, amenos que el objeto sea una función, en tal caso nada se agrega a la cadena JSON.
Si se devuelve undefined, la propiedad no se incluye en la salida de la cadena JSON.


Nota:
No se puede usar la función de reemplazo para borrar los valores de un array. Si se devuelve undefined o una función, entonces se usara null en su lugar.

Ejemplo con una función
jsfunction replacer(key, value) {
  // Filtrando propiedades
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

var foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
var jsonString = JSON.stringify(foo, replacer);
// '{"week":45, "month":7}'

El resultado en una cadena JSON sería: {"week":45,"month":7}.
Ejemplo con un array
Si el reemplazo es un array, los valores indican los nombres de las propiedades del objeto que se va a incluir en la cadena JSON resultado.
jsJSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', sólo mantiene las propiedades de "week" y de "month"
Argumento spaceEste argumento puede ser empleado para controlar el espaciado en la cadena final. Si es un número, los niveles sucesivos del proceso serán identados cada uno por tantos espacios como se indique (hasta 10). Si es una cadena, serán identados con dicha cadena (o los primeros diez caracteres de la misma).
jsJSON.stringify({ a: 2 }, null, " ");
// regresa la cadena de texto:
// '{
//  "a": 2
// }'

Usar el carácter tabulador simula la apariencia de impresión:
jsJSON.stringify({ uno: 1, dos: 2 }, null, "\t");
// devuelve el string:
// '{            \
//     "uno": 1, \
//     "dos": 2  \
// }'
Comportamiento toJSON()Si un objeto que sera estringificado tiene una propiedad llamada toJSON donde su valor es una función, entonces el método toJSON modifica el comportamiento de la estringificación JSON: en lugar del objeto que esta siendo serializado, el valor retornado por el método toJSON será serializado cuando el mismo sea llamado. Por ejemplo:
jsvar obj = {
  foo: "foo",
  toJSON: function () {
    return "bar";
  },
};
var json = JSON.stringify({ x: obj }); // '{"x":"bar"}'.
Ejemplo de como usar JSON.stringify() con localStorageEn dado caso en el cual se requiera que un objeto creado por el usuario y al cual se le permita ser restaurado incluso cuando el navegador ha sido cerrado, el siguiente ejemplo es un modelo de la aplicabilidad del metodo JSON. stringify().

Advertencia:
Las funciones no son un tipo de dato valido por lo cual estas no funcionaran. Algunos objetos como tipo DATE, se convertiran a cadenas de texto despues de ejecutar JSON.parse().

js// Creando un ejemplo de JSON
var session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Convirte el JSON string con JSON.stringify()
// entonces guarda con localStorage con el nombre de la sesión
localStorage.setItem("session", JSON.stringify(session));

// Ejemplo de como transformar el String generado usando
// JSON.stringify() y guardándolo en localStorage como objeto JSON otra vez
var restoredSession = JSON.parse(localStorage.getItem("session"));

// Ahora la variable restoredSession contiene el objeto que fue guardado
// en localStorage
console.log(restoredSession);
EspecificacionesSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyCompatibilidad con navegadoresVer también
JSON.parse()
cycle.js – Introduces two functions: JSON.decycle and JSON.retrocycle. These allow encoding and decoding of cyclical structures and DAGs into an extended and retrocompatible JSON format.
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 31 mar 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackEl método JSON.stringify() convierte un objeto o valor de JavaScript en una cadena de texto JSON, opcionalmente reemplaza valores si se indica una función de reemplazo, o si se especifican las propiedades mediante un array de reemplazo.Pruébalo
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SintaxisJSON.stringify(value[, replacer[, space]])
Parámetros
value

El valor que será convertido a una cadena JSON.

replacerOpcional

Una función que altera el comportamiento del proceso de conversión a cadena de texto, o un array de objetos String o Number que representan una lista de elementos válidos que se incluyen en la cadena JSON. Si este valor es null o no se define, todas las propiedades del objeto son incluidas en la cadena de texto JSON resultante.

spaceOpcional

Un objeto de tipo String o Number que se utiliza para insertar un espacio en blanco dentro de la cadena de salida JSON para mejorar su legibilidad.Si es de tipo Number, indica el número de espacios a usar como espacios en blanco; este número está limitado se limita a 10 (si es mayor, el valor es sólo 10). Los valores inferiores a 1 indican que no se deben utilizar espacios.Si es de tipo String, la cadena de texto (o sus 10 primeros caracteres, si es mayor) se utiliza como espacios en blanco. Si este parámetro no se define o es null, no se utilizará ningún espacio en blanco.

Valor devueltoUna cadena de texto JSON que representa el valor dado.ExcepcionesLanza una excepción TypeError ("cyclic object value") cuando encuentra una referencia circular.DescripciónJSON.stringify convierte un valor a notación JSON representándolo:

Si el valor tiene un método toJSON(), es responsable de definir qué será serializado.
Los objetos Boolean, Number, and String se convierten a sus valores primitivos, de acuerdo con la conversión semántica tradicional.
Si durante la conversión se encuentra un undefined, una Function, o un Symbol se omite (cuando se encuentra en un objeto) o se censura a null (cuando se encuentra en un array). JSON.stringify() puede devolver undefined cuando se pasan valores "puros" como JSON.stringify(function(){}) o JSON.stringify(undefined).
Todas las propiedades que utilicen Symbol en los nombres de la clave se ignoran por completo, incluso si utilizan una función replacer.
Las instancias de Date implementan la función toJSON() devolviendo una cadena de texto (igual que date.toISOString()). Por lo que son tratadas como strings.
Los números Infinity y NaN, así como el valor null, se consideran null.
El resto de instancias de Object (incluyendo Map, Set, WeakMap, y WeakSet) sólo tendrán serializadas sus propiedades enumerables.

jsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(2006, 0, 2, 15, 4, 5));
// '"2006-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// Elementos de array identificados por string no son enumerables y no tienen sentido en JSON
let a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Estructuras de datos standard
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Símbolos:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, function (k, v) {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Propiedades no enumerables:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'
El parámetro replacerEl parámetro replacer (de reemplazo) puede ser tanto una función como o un array.
Como una función toma dos parámetros: el valor y la clave que van a ser procesados. El objeto al cual pertenece la clave representa el parametro this del reemplazo.
Inicialmente es llamado con una clave vacía y representa el objeto que se va a procesar, y solo después es llamado por cada propiedad en el objeto o array que se va a procesar.
Devuelve el valor que se va a agregar a la cadena JSON, de la siguiente manera:

Si se devuelve un número, la cadena correspondiente es usada como el valor de la propiedad cuando se agrega a la cadena JSON.
Si se devuelve una cadena, esta es usuada cono el valor de la propiedad cuando se agrega a la cadena JSON.
Si se devuelve un Boolean, true o false son usados como el valor de la propiedad cuando se agrega a la cadena JSON.
Si se devuelve algún otro objeto, este es recursivamente procesado en una cadena JSON llamando a la función de reemplazo para cada propiedad, amenos que el objeto sea una función, en tal caso nada se agrega a la cadena JSON.
Si se devuelve undefined, la propiedad no se incluye en la salida de la cadena JSON.


Nota:
No se puede usar la función de reemplazo para borrar los valores de un array. Si se devuelve undefined o una función, entonces se usara null en su lugar.

Ejemplo con una función
jsfunction replacer(key, value) {
  // Filtrando propiedades
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

var foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
var jsonString = JSON.stringify(foo, replacer);
// '{"week":45, "month":7}'

El resultado en una cadena JSON sería: {"week":45,"month":7}.
Ejemplo con un array
Si el reemplazo es un array, los valores indican los nombres de las propiedades del objeto que se va a incluir en la cadena JSON resultado.
jsJSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', sólo mantiene las propiedades de "week" y de "month"
Argumento spaceEste argumento puede ser empleado para controlar el espaciado en la cadena final. Si es un número, los niveles sucesivos del proceso serán identados cada uno por tantos espacios como se indique (hasta 10). Si es una cadena, serán identados con dicha cadena (o los primeros diez caracteres de la misma).
jsJSON.stringify({ a: 2 }, null, " ");
// regresa la cadena de texto:
// '{
//  "a": 2
// }'

Usar el carácter tabulador simula la apariencia de impresión:
jsJSON.stringify({ uno: 1, dos: 2 }, null, "\t");
// devuelve el string:
// '{            \
//     "uno": 1, \
//     "dos": 2  \
// }'
Comportamiento toJSON()Si un objeto que sera estringificado tiene una propiedad llamada toJSON donde su valor es una función, entonces el método toJSON modifica el comportamiento de la estringificación JSON: en lugar del objeto que esta siendo serializado, el valor retornado por el método toJSON será serializado cuando el mismo sea llamado. Por ejemplo:
jsvar obj = {
  foo: "foo",
  toJSON: function () {
    return "bar";
  },
};
var json = JSON.stringify({ x: obj }); // '{"x":"bar"}'.
Ejemplo de como usar JSON.stringify() con localStorageEn dado caso en el cual se requiera que un objeto creado por el usuario y al cual se le permita ser restaurado incluso cuando el navegador ha sido cerrado, el siguiente ejemplo es un modelo de la aplicabilidad del metodo JSON. stringify().

Advertencia:
Las funciones no son un tipo de dato valido por lo cual estas no funcionaran. Algunos objetos como tipo DATE, se convertiran a cadenas de texto despues de ejecutar JSON.parse().

js// Creando un ejemplo de JSON
var session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Convirte el JSON string con JSON.stringify()
// entonces guarda con localStorage con el nombre de la sesión
localStorage.setItem("session", JSON.stringify(session));

// Ejemplo de como transformar el String generado usando
// JSON.stringify() y guardándolo en localStorage como objeto JSON otra vez
var restoredSession = JSON.parse(localStorage.getItem("session"));

// Ahora la variable restoredSession contiene el objeto que fue guardado
// en localStorage
console.log(restoredSession);
EspecificacionesSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyCompatibilidad con navegadoresVer también
JSON.parse()
cycle.js – Introduces two functions: JSON.decycle and JSON.retrocycle. These allow encoding and decoding of cyclical structures and DAGs into an extended and retrocompatible JSON format.
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 31 mar 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackLa méthode JSON.stringify() convertit une valeur JavaScript en chaîne JSON. Optionnellement, elle peut remplacer des valeurs ou spécifier les propriétés à inclure si un tableau de propriétés a été fourni.Exemple interactif
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxejsJSON.stringify( valeur[, remplaçant [, espace]])
Paramètres
valeur

La valeur à convertir en chaîne JSON.

remplaçant Facultatif

Une fonction qui modifie le processus de transformation ou un tableau de chaînes de caractères et de nombres qui sont utilisés comme liste blanche pour sélectionner/filtrer les propriétés de l'objet à inclure dans la chaîne JSON. Si cette valeur est null ou n'est pas fournie, toutes les propriétés de l'objet seront inclues dans la chaîne résultante.

espace Facultatif

Un objet String ou Number qui est utilisé pour insérer des blancs dans la chaîne JSON produite afin de faciliter la lisibilité.




Si cet argument est un nombre, il indiquera le nombre d'espaces à utiliser pour l'indentation (la valeur est ramenée à 10 si elle dépasse 10).
Si l'argument est une chaîne, les 10 premiers caractères (ou la chaîne si elle est plus courte) seront utilisés pour les blancs.
Si le paramètre n'est pas fourni (ou s'il est nul), aucun blanc ne sera utilisé.
Valeur de retourUne chaîne de caractères JSON qui représente la valeur indiquée.Exceptions
Cette méthode lève une exception TypeError (« cyclic object value ») lorsqu'elle trouve une référence circulaire.
Cette méthode lève une exception TypeError (« BigInt value can't be serialized in JSON ») lorsqu'on tente de convertir une valeur BigInt en une chaîne de caractères JSON.
DescriptionLa fonction JSON.stringify() convertit un objet en JSON :

L'ordre des propriétés des objets qui ne sont pas des tableaux n'est pas garanti. Par la suite, ne pas supposer que cet ordre soit respecté.
Les objets Boolean, Number et String sont convertis en leur valeur primitive correspondante, en accord avec la sémantique traditionnelle.
Si undefined, une fonction ou un symbole est rencontré lors de la conversion , il est soit omis ( quand il se trouve dans un objet ) ou ramené à null ( quand il se trouve dans un tableau). JSON.stringify() peut également renvoyer undefined lorsqu'il reçoit des valeurs « brutes » qui ne sont pas objectifiées comme par exemple JSON.stringify(function(){}) ou JSON.stringify(undefined).
Toutes les propriétés liées aux symboles (cf. Symbol) seront complètement ignorées , même lorsque la fonction remplaçant est utilisée.
Les propriétés qui ne sont pas énumérables seront ignorées.
Les instances de Date implémentent la fonction toJSON() en renvoyant une chaîne de caractères (identique à celle renvoyée par date.toISOString()). Aussi, les dates sont traitées comme des chaînes de caractères.
Les nombres Infinity et NaN, ainsi que l'objet null sont traités comme null.
Pour les autres instances d'objets tels que Map, Set, WeakMap et WeakSet, seules les propriétés énumérables sont sérialisées.

jsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("toto"); // '"toto"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(2006, 0, 2, 15, 4, 5));
// '"2006-01-02T23:04:05.000Z"'

// Exemples
JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// Les tableaux avec des propriétés ne sont pas énumérables
// et n'ont pas de sens selon JSON
let a = ["toto", "truc"];
a["bidule"] = "youpi"; // a:[ 0: "toto", 1: "truc", bidule: "youpi"]
JSON.stringify(a);
// '["toto","truc"]'

// Symboles
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("toto")]: "toto" });
// '{}'
JSON.stringify({ [Symbol.for("toto")]: "toto" }, [Symbol.for("toto")]);
// '{}'
JSON.stringify({ [Symbol.for("toto")]: "toto" }, function (k, v) {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// '{}'
JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Structures de données classiques
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, function (k, v) {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Propriétés non énumérables
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// Échec avec BigInt
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
L'argument remplaçantL'argument remplaçant est une fonction ou un tableau. Si c'est une fonction, elle prend deux paramètres : une clé et la valeur qui est traitée pour être convertie en chaîne. L'objet dans lequel la clé a été trouvée sera fourni comme paramètre this pour la fonction. Cette fonction est d'abord appelée avec une chaîne vide comme clé représentant l'objet à transformer puis elle est appelée sur chaque propriété de l'objet ou du tableau à transformer en chaîne. Cette fonction renvoie la valeur à ajouter à la chaîne JSON :

Si la valeur renvoyée est un nombre (Number), la chaîne correspondante au nombre sera utilisée comme valeur à ajouter à la chaîne pour représenter la valeur de la propriété traitée.
Si la valeur renvoyée est une chaîne de caractères (String), cette chaîne sera utilisée pour représenter la valeur de la propriété dans la chaîne JSON.
Si la valeur renvoyée est un Boolean, "true" ou "false" sera utilisé pour représenter la valeur de la propriété et sera ajouté à la chaîne JSON.
Si la valeur renvoyée est null, null sera ajouté à la chaîne JSON.
Si la valeur renvoyée est un autre objet, cet objet sera, de façon récursive, transformé en une chaîne JSON en appelant la fonction remplaçant sur chaque propriété sauf si l'objet est une fonction auquel cas, rien n'est ajouté à la chaîne JSON.
Si la valeur renvoyée est undefined, la propriété ne sera pas incluse dans la chaîne JSON.


Note :
La fonction remplaçant ne peut pas être utilisée pour retirer des valeurs d'un tableau. Si on renvoie undefined ou une fonction, ce sera la valeur null qui sera utilisée.


Note :
Si on souhaite que la fonction remplaçant distingue un objet dont une propriété a un clé qui est « réellement » une chaîne vide, il faudra avoir un compteur pour le nombre d'itération. Si le compteur indique que la première itération est passée, alors il s'agit bien d'un clé avec une chaîne vide.

Exemple avec une fonction
jsfunction remplaçant(clé, valeur) {
  if (typeof valeur === "string") {
    return undefined;
  }
  return valeur;
}

var toto = {
  fondation: "Mozilla",
  modèle: "boîte",
  semaine: 45,
  transport: "bus",
  mois: 7,
};
console.log(JSON.stringify(toto, remplaçant)); // {"semaine":45, "mois":7}

Exemple avec un tableau
Si remplaçant est un tableau, les valeurs du tableau indiquent les propriétés de l'objet à inclure dans la chaîne JSON.
jsJSON.stringify(toto, ["semaine", "mois"]);
// '{"semaine":45,"mois":7}', on ne garde que "semaines" et "mois"
L'argument espaceL'argument espace est utilisé pour contrôler les espacements utilisés dans la chaîne finale.

Si c'est un nombre, les différents niveaux d'indentation auront autant d'espaces qu'indiqué grâce à ce paramètre (jusqu'à 10).
Si c'est une chaîne, les dix premiers caractères (ou la chaîne complète si elle est plus courte)

jsJSON.stringify({ a: 2 }, null, " ");
// '{
//  "a": 2
// }'

Dans l'exemple suivant on utilise la tabulation pour rendre lisible le résultat :
jsJSON.stringify({ uno: 1, dos: 2 }, null, "\t");
// renverra
// '{
//   "uno": 1,
//   "dos": 2
// }'
La fonction toJSON()Pour personnaliser la valeur d'un objet lors de sa conversion en JSON, on peut surcharger la méthode toJSON() : la valeur retournée par cette méthode toJSON() sera alors utilisée. JSON.stringify() invoquera la méthode toJSON() de l'objet avec un paramètre :

Si cet objet est une propriété de donnée, ce sera le nom de la propriété
Si cet objet est un tableau, ce sera l'indice de l'élément du tableau sous la forme d'une chaîne de caractères
Une chaîne vide si JSON.stringify() était directement appelé sur l'objet.

Ainsi :
jsvar obj = {
  data: "data",
  toJSON(clef) {
    if (clef) {
      return `Un objet imbriqué sous la clef '${clef}'`;
    } else {
      return this;
    }
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Un objet imbriqué sous la clef 'obj'"}'

JSON.stringify([obj]);
// '["Un objet imbriqué sous la clef '0'"]'
Le problème des références circulairesLe format JSON ne prend pas en charge les références (bien qu'un brouillon IETF existe) et une exception TypeError sera levée si on tente d'encoder un objet possédant des références circulaires.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Sérialiser un objet avec des références circulaires déclenche une "TypeError: cyclic object value"
JSON.stringify(circularReference);

Pour sérialiser les références circulaires, on peut utiliser une bibliothèque (cycle.js par exemple) ou implémenter sa propre solution (qui consistera à trouver et à remplacer le cycle par des valeurs sérialisables).Gestion des terminateurs de lignePar le passé, JSON n'était pas un sous-ensemble strict de JavaScript. En effet, en JSON, deux terminateurs de ligne (le caractère de séparation de ligne U+2028 LINE SEPARATOR et le caractère de séparation de paragraphe U+2029 PARAGRAPH SEPARATOR) n'avaient pas besoin d'être échappés dans des données JSON alors qu'ils devaient l'être en JavaScript. Cela a désormais évolué et les deux points de code peuvent apparaître tant en JSON qu'en JavaScript.
Ainsi, si on souhaite avoir une compatibilité avec les anciens moteurs JavaScript, on pourra évaluer ou utiliser les données JSON avec JSONP et la fonction utilitaire suivante :
jsfunction jsFriendlyJSONStringify(s) {
  return JSON.stringify(s)
    .replace(/\u2028/g, "\\u2028")
    .replace(/\u2029/g, "\\u2029");
}

var s = {
  a: String.fromCharCode(0x2028),
  b: String.fromCharCode(0x2029),
};

// dans Firefox, console.log enlève les échappements
// des caractères Unicode, on utilise donc alert :(
alert(jsFriendlyJSONStringify(s)); // {"a":"\u2028","b":"\u2029"}


Note :
Les propriétés des objets qui ne sont pas des tableaux ne sont pas transformées en chaînes de caractères selon un ordre particulier. Aussi, l'ordre des données en JSON ne saurait constituer une information utile.

jsvar a = JSON.stringify({ toto: "truc", bidule: "machin" });
// '{"toto":"truc","bidule":"machin"}'
var b = JSON.stringify({ bidule: "machin", toto: "truc" });
// '{"bidule":"machin","toto":"truc"}'
console.log(a !== b); // true
Utiliser JSON.stringify avec localStorageDans le cas où on souhaite enregistrer un objet créé par l'utilisateur afin de le restorer plus tard (y compris après que le navigateur ait été fermé), on peut utiliser JSON.stringify.

Attention :
Les fonctions n'ont pas de correspondances en JSON, il ne sera donc pas possible de les enregistrer de cette façon. En revanche, elles peuvent être affichées si elles ont été converties en texte avec la fonction de remplacement. De même, certains objets comme les dates seront transformées en chaîne de caractères après l'utilisation de JSON.parse().

js// On crée un objet pour l'exemple
var session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// On convertit l'objet en une chaîne JSON
// et on enregistre cette valeur avec le nom 'session'
localStorage.setItem("session", JSON.stringify(session));

// Ici, on reconvertit la chaîne en un objet
// JSON.stringify and saved in localStorage in JSON object again
var sessionRestaurée = JSON.parse(localStorage.getItem("session"));

// La variable sessionRestaurée contient désormais l'objet précédent
// qui avait été sauvegardé dans localStorage
console.log(sessionRestaurée);
Chaînes bien formées et JSON.stringify()Les moteurs, qui implémentent la spécification sur JSON.stringify() bien formé, transformeront en chaîne de caractères les éléments isolés de paires surrogates via des séquences d'échappement Unicode plutôt que d'utiliser leurs valeurs littérales. Avant cette modification de spécification, JSON.stringify() n'aurait pas encodé les éléments surrogates isolés et les chaînes produites n'étaient pas valides selon UTF-8 ou UTF-16 :
jsJSON.stringify("\uD800"); // '"�"'

Avec cette modification, les séquences d'échappement produites permettent d'avoir un contenu UTF-16 ou UTF-8 lisible :
jsJSON.stringify("\uD800"); // '"\\ud800"'

Cette modification est rétrocompatible pour toutes les opérations où le résultat de JSON.stringify() est passé à des API comme JSON.parse() qui acceptent du texte JSON valide. En effet, ces API traiteront les séquences d'échappement de surrogates isolés comme les caractères correspondants. Seul le cas où le code interprète directement le résultat de JSON.stringify() doit être adapté afin de gérer les deux encodages possibles pour ces cas.SpécificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyCompatibilité des navigateursVoir aussi
JSON.parse()
cycle.js qui ajoute deux fonctions JSON.decycle et JSON.retrocycle qui permettent d'encoder et de décoder des structures cycliques.\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackLa méthode JSON.stringify() convertit une valeur JavaScript en chaîne JSON. Optionnellement, elle peut remplacer des valeurs ou spécifier les propriétés à inclure si un tableau de propriétés a été fourni.Exemple interactif
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxejsJSON.stringify( valeur[, remplaçant [, espace]])
Paramètres
valeur

La valeur à convertir en chaîne JSON.

remplaçant Facultatif

Une fonction qui modifie le processus de transformation ou un tableau de chaînes de caractères et de nombres qui sont utilisés comme liste blanche pour sélectionner/filtrer les propriétés de l'objet à inclure dans la chaîne JSON. Si cette valeur est null ou n'est pas fournie, toutes les propriétés de l'objet seront inclues dans la chaîne résultante.

espace Facultatif

Un objet String ou Number qui est utilisé pour insérer des blancs dans la chaîne JSON produite afin de faciliter la lisibilité.




Si cet argument est un nombre, il indiquera le nombre d'espaces à utiliser pour l'indentation (la valeur est ramenée à 10 si elle dépasse 10).
Si l'argument est une chaîne, les 10 premiers caractères (ou la chaîne si elle est plus courte) seront utilisés pour les blancs.
Si le paramètre n'est pas fourni (ou s'il est nul), aucun blanc ne sera utilisé.
Valeur de retourUne chaîne de caractères JSON qui représente la valeur indiquée.Exceptions
Cette méthode lève une exception TypeError (« cyclic object value ») lorsqu'elle trouve une référence circulaire.
Cette méthode lève une exception TypeError (« BigInt value can't be serialized in JSON ») lorsqu'on tente de convertir une valeur BigInt en une chaîne de caractères JSON.
DescriptionLa fonction JSON.stringify() convertit un objet en JSON :

L'ordre des propriétés des objets qui ne sont pas des tableaux n'est pas garanti. Par la suite, ne pas supposer que cet ordre soit respecté.
Les objets Boolean, Number et String sont convertis en leur valeur primitive correspondante, en accord avec la sémantique traditionnelle.
Si undefined, une fonction ou un symbole est rencontré lors de la conversion , il est soit omis ( quand il se trouve dans un objet ) ou ramené à null ( quand il se trouve dans un tableau). JSON.stringify() peut également renvoyer undefined lorsqu'il reçoit des valeurs « brutes » qui ne sont pas objectifiées comme par exemple JSON.stringify(function(){}) ou JSON.stringify(undefined).
Toutes les propriétés liées aux symboles (cf. Symbol) seront complètement ignorées , même lorsque la fonction remplaçant est utilisée.
Les propriétés qui ne sont pas énumérables seront ignorées.
Les instances de Date implémentent la fonction toJSON() en renvoyant une chaîne de caractères (identique à celle renvoyée par date.toISOString()). Aussi, les dates sont traitées comme des chaînes de caractères.
Les nombres Infinity et NaN, ainsi que l'objet null sont traités comme null.
Pour les autres instances d'objets tels que Map, Set, WeakMap et WeakSet, seules les propriétés énumérables sont sérialisées.

jsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("toto"); // '"toto"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(2006, 0, 2, 15, 4, 5));
// '"2006-01-02T23:04:05.000Z"'

// Exemples
JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// Les tableaux avec des propriétés ne sont pas énumérables
// et n'ont pas de sens selon JSON
let a = ["toto", "truc"];
a["bidule"] = "youpi"; // a:[ 0: "toto", 1: "truc", bidule: "youpi"]
JSON.stringify(a);
// '["toto","truc"]'

// Symboles
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("toto")]: "toto" });
// '{}'
JSON.stringify({ [Symbol.for("toto")]: "toto" }, [Symbol.for("toto")]);
// '{}'
JSON.stringify({ [Symbol.for("toto")]: "toto" }, function (k, v) {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// '{}'
JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Structures de données classiques
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, function (k, v) {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Propriétés non énumérables
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// Échec avec BigInt
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
L'argument remplaçantL'argument remplaçant est une fonction ou un tableau. Si c'est une fonction, elle prend deux paramètres : une clé et la valeur qui est traitée pour être convertie en chaîne. L'objet dans lequel la clé a été trouvée sera fourni comme paramètre this pour la fonction. Cette fonction est d'abord appelée avec une chaîne vide comme clé représentant l'objet à transformer puis elle est appelée sur chaque propriété de l'objet ou du tableau à transformer en chaîne. Cette fonction renvoie la valeur à ajouter à la chaîne JSON :

Si la valeur renvoyée est un nombre (Number), la chaîne correspondante au nombre sera utilisée comme valeur à ajouter à la chaîne pour représenter la valeur de la propriété traitée.
Si la valeur renvoyée est une chaîne de caractères (String), cette chaîne sera utilisée pour représenter la valeur de la propriété dans la chaîne JSON.
Si la valeur renvoyée est un Boolean, "true" ou "false" sera utilisé pour représenter la valeur de la propriété et sera ajouté à la chaîne JSON.
Si la valeur renvoyée est null, null sera ajouté à la chaîne JSON.
Si la valeur renvoyée est un autre objet, cet objet sera, de façon récursive, transformé en une chaîne JSON en appelant la fonction remplaçant sur chaque propriété sauf si l'objet est une fonction auquel cas, rien n'est ajouté à la chaîne JSON.
Si la valeur renvoyée est undefined, la propriété ne sera pas incluse dans la chaîne JSON.


Note :
La fonction remplaçant ne peut pas être utilisée pour retirer des valeurs d'un tableau. Si on renvoie undefined ou une fonction, ce sera la valeur null qui sera utilisée.


Note :
Si on souhaite que la fonction remplaçant distingue un objet dont une propriété a un clé qui est « réellement » une chaîne vide, il faudra avoir un compteur pour le nombre d'itération. Si le compteur indique que la première itération est passée, alors il s'agit bien d'un clé avec une chaîne vide.

Exemple avec une fonction
jsfunction remplaçant(clé, valeur) {
  if (typeof valeur === "string") {
    return undefined;
  }
  return valeur;
}

var toto = {
  fondation: "Mozilla",
  modèle: "boîte",
  semaine: 45,
  transport: "bus",
  mois: 7,
};
console.log(JSON.stringify(toto, remplaçant)); // {"semaine":45, "mois":7}

Exemple avec un tableau
Si remplaçant est un tableau, les valeurs du tableau indiquent les propriétés de l'objet à inclure dans la chaîne JSON.
jsJSON.stringify(toto, ["semaine", "mois"]);
// '{"semaine":45,"mois":7}', on ne garde que "semaines" et "mois"
L'argument espaceL'argument espace est utilisé pour contrôler les espacements utilisés dans la chaîne finale.

Si c'est un nombre, les différents niveaux d'indentation auront autant d'espaces qu'indiqué grâce à ce paramètre (jusqu'à 10).
Si c'est une chaîne, les dix premiers caractères (ou la chaîne complète si elle est plus courte)

jsJSON.stringify({ a: 2 }, null, " ");
// '{
//  "a": 2
// }'

Dans l'exemple suivant on utilise la tabulation pour rendre lisible le résultat :
jsJSON.stringify({ uno: 1, dos: 2 }, null, "\t");
// renverra
// '{
//   "uno": 1,
//   "dos": 2
// }'
La fonction toJSON()Pour personnaliser la valeur d'un objet lors de sa conversion en JSON, on peut surcharger la méthode toJSON() : la valeur retournée par cette méthode toJSON() sera alors utilisée. JSON.stringify() invoquera la méthode toJSON() de l'objet avec un paramètre :

Si cet objet est une propriété de donnée, ce sera le nom de la propriété
Si cet objet est un tableau, ce sera l'indice de l'élément du tableau sous la forme d'une chaîne de caractères
Une chaîne vide si JSON.stringify() était directement appelé sur l'objet.

Ainsi :
jsvar obj = {
  data: "data",
  toJSON(clef) {
    if (clef) {
      return `Un objet imbriqué sous la clef '${clef}'`;
    } else {
      return this;
    }
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Un objet imbriqué sous la clef 'obj'"}'

JSON.stringify([obj]);
// '["Un objet imbriqué sous la clef '0'"]'
Le problème des références circulairesLe format JSON ne prend pas en charge les références (bien qu'un brouillon IETF existe) et une exception TypeError sera levée si on tente d'encoder un objet possédant des références circulaires.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Sérialiser un objet avec des références circulaires déclenche une "TypeError: cyclic object value"
JSON.stringify(circularReference);

Pour sérialiser les références circulaires, on peut utiliser une bibliothèque (cycle.js par exemple) ou implémenter sa propre solution (qui consistera à trouver et à remplacer le cycle par des valeurs sérialisables).Gestion des terminateurs de lignePar le passé, JSON n'était pas un sous-ensemble strict de JavaScript. En effet, en JSON, deux terminateurs de ligne (le caractère de séparation de ligne U+2028 LINE SEPARATOR et le caractère de séparation de paragraphe U+2029 PARAGRAPH SEPARATOR) n'avaient pas besoin d'être échappés dans des données JSON alors qu'ils devaient l'être en JavaScript. Cela a désormais évolué et les deux points de code peuvent apparaître tant en JSON qu'en JavaScript.
Ainsi, si on souhaite avoir une compatibilité avec les anciens moteurs JavaScript, on pourra évaluer ou utiliser les données JSON avec JSONP et la fonction utilitaire suivante :
jsfunction jsFriendlyJSONStringify(s) {
  return JSON.stringify(s)
    .replace(/\u2028/g, "\\u2028")
    .replace(/\u2029/g, "\\u2029");
}

var s = {
  a: String.fromCharCode(0x2028),
  b: String.fromCharCode(0x2029),
};

// dans Firefox, console.log enlève les échappements
// des caractères Unicode, on utilise donc alert :(
alert(jsFriendlyJSONStringify(s)); // {"a":"\u2028","b":"\u2029"}


Note :
Les propriétés des objets qui ne sont pas des tableaux ne sont pas transformées en chaînes de caractères selon un ordre particulier. Aussi, l'ordre des données en JSON ne saurait constituer une information utile.

jsvar a = JSON.stringify({ toto: "truc", bidule: "machin" });
// '{"toto":"truc","bidule":"machin"}'
var b = JSON.stringify({ bidule: "machin", toto: "truc" });
// '{"bidule":"machin","toto":"truc"}'
console.log(a !== b); // true
Utiliser JSON.stringify avec localStorageDans le cas où on souhaite enregistrer un objet créé par l'utilisateur afin de le restorer plus tard (y compris après que le navigateur ait été fermé), on peut utiliser JSON.stringify.

Attention :
Les fonctions n'ont pas de correspondances en JSON, il ne sera donc pas possible de les enregistrer de cette façon. En revanche, elles peuvent être affichées si elles ont été converties en texte avec la fonction de remplacement. De même, certains objets comme les dates seront transformées en chaîne de caractères après l'utilisation de JSON.parse().

js// On crée un objet pour l'exemple
var session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// On convertit l'objet en une chaîne JSON
// et on enregistre cette valeur avec le nom 'session'
localStorage.setItem("session", JSON.stringify(session));

// Ici, on reconvertit la chaîne en un objet
// JSON.stringify and saved in localStorage in JSON object again
var sessionRestaurée = JSON.parse(localStorage.getItem("session"));

// La variable sessionRestaurée contient désormais l'objet précédent
// qui avait été sauvegardé dans localStorage
console.log(sessionRestaurée);
Chaînes bien formées et JSON.stringify()Les moteurs, qui implémentent la spécification sur JSON.stringify() bien formé, transformeront en chaîne de caractères les éléments isolés de paires surrogates via des séquences d'échappement Unicode plutôt que d'utiliser leurs valeurs littérales. Avant cette modification de spécification, JSON.stringify() n'aurait pas encodé les éléments surrogates isolés et les chaînes produites n'étaient pas valides selon UTF-8 ou UTF-16 :
jsJSON.stringify("\uD800"); // '"�"'

Avec cette modification, les séquences d'échappement produites permettent d'avoir un contenu UTF-16 ou UTF-8 lisible :
jsJSON.stringify("\uD800"); // '"\\ud800"'

Cette modification est rétrocompatible pour toutes les opérations où le résultat de JSON.stringify() est passé à des API comme JSON.parse() qui acceptent du texte JSON valide. En effet, ces API traiteront les séquences d'échappement de surrogates isolés comme les caractères correspondants. Seul le cas où le code interprète directement le résultat de JSON.stringify() doit être adapté afin de gérer les deux encodages possibles pour ces cas.SpécificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyCompatibilité des navigateursVoir aussi
JSON.parse()
cycle.js qui ajoute deux fonctions JSON.decycle et JSON.retrocycle qui permettent d'encoder et de décoder des structures cycliques.
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 17 févr. 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackLa méthode JSON.stringify() convertit une valeur JavaScript en chaîne JSON. Optionnellement, elle peut remplacer des valeurs ou spécifier les propriétés à inclure si un tableau de propriétés a été fourni.Exemple interactif
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxejsJSON.stringify( valeur[, remplaçant [, espace]])
Paramètres
valeur

La valeur à convertir en chaîne JSON.

remplaçant Facultatif

Une fonction qui modifie le processus de transformation ou un tableau de chaînes de caractères et de nombres qui sont utilisés comme liste blanche pour sélectionner/filtrer les propriétés de l'objet à inclure dans la chaîne JSON. Si cette valeur est null ou n'est pas fournie, toutes les propriétés de l'objet seront inclues dans la chaîne résultante.

espace Facultatif

Un objet String ou Number qui est utilisé pour insérer des blancs dans la chaîne JSON produite afin de faciliter la lisibilité.




Si cet argument est un nombre, il indiquera le nombre d'espaces à utiliser pour l'indentation (la valeur est ramenée à 10 si elle dépasse 10).
Si l'argument est une chaîne, les 10 premiers caractères (ou la chaîne si elle est plus courte) seront utilisés pour les blancs.
Si le paramètre n'est pas fourni (ou s'il est nul), aucun blanc ne sera utilisé.
Valeur de retourUne chaîne de caractères JSON qui représente la valeur indiquée.Exceptions
Cette méthode lève une exception TypeError (« cyclic object value ») lorsqu'elle trouve une référence circulaire.
Cette méthode lève une exception TypeError (« BigInt value can't be serialized in JSON ») lorsqu'on tente de convertir une valeur BigInt en une chaîne de caractères JSON.
DescriptionLa fonction JSON.stringify() convertit un objet en JSON :

L'ordre des propriétés des objets qui ne sont pas des tableaux n'est pas garanti. Par la suite, ne pas supposer que cet ordre soit respecté.
Les objets Boolean, Number et String sont convertis en leur valeur primitive correspondante, en accord avec la sémantique traditionnelle.
Si undefined, une fonction ou un symbole est rencontré lors de la conversion , il est soit omis ( quand il se trouve dans un objet ) ou ramené à null ( quand il se trouve dans un tableau). JSON.stringify() peut également renvoyer undefined lorsqu'il reçoit des valeurs « brutes » qui ne sont pas objectifiées comme par exemple JSON.stringify(function(){}) ou JSON.stringify(undefined).
Toutes les propriétés liées aux symboles (cf. Symbol) seront complètement ignorées , même lorsque la fonction remplaçant est utilisée.
Les propriétés qui ne sont pas énumérables seront ignorées.
Les instances de Date implémentent la fonction toJSON() en renvoyant une chaîne de caractères (identique à celle renvoyée par date.toISOString()). Aussi, les dates sont traitées comme des chaînes de caractères.
Les nombres Infinity et NaN, ainsi que l'objet null sont traités comme null.
Pour les autres instances d'objets tels que Map, Set, WeakMap et WeakSet, seules les propriétés énumérables sont sérialisées.

jsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("toto"); // '"toto"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(2006, 0, 2, 15, 4, 5));
// '"2006-01-02T23:04:05.000Z"'

// Exemples
JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// Les tableaux avec des propriétés ne sont pas énumérables
// et n'ont pas de sens selon JSON
let a = ["toto", "truc"];
a["bidule"] = "youpi"; // a:[ 0: "toto", 1: "truc", bidule: "youpi"]
JSON.stringify(a);
// '["toto","truc"]'

// Symboles
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("toto")]: "toto" });
// '{}'
JSON.stringify({ [Symbol.for("toto")]: "toto" }, [Symbol.for("toto")]);
// '{}'
JSON.stringify({ [Symbol.for("toto")]: "toto" }, function (k, v) {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// '{}'
JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Structures de données classiques
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, function (k, v) {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Propriétés non énumérables
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// Échec avec BigInt
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
L'argument remplaçantL'argument remplaçant est une fonction ou un tableau. Si c'est une fonction, elle prend deux paramètres : une clé et la valeur qui est traitée pour être convertie en chaîne. L'objet dans lequel la clé a été trouvée sera fourni comme paramètre this pour la fonction. Cette fonction est d'abord appelée avec une chaîne vide comme clé représentant l'objet à transformer puis elle est appelée sur chaque propriété de l'objet ou du tableau à transformer en chaîne. Cette fonction renvoie la valeur à ajouter à la chaîne JSON :

Si la valeur renvoyée est un nombre (Number), la chaîne correspondante au nombre sera utilisée comme valeur à ajouter à la chaîne pour représenter la valeur de la propriété traitée.
Si la valeur renvoyée est une chaîne de caractères (String), cette chaîne sera utilisée pour représenter la valeur de la propriété dans la chaîne JSON.
Si la valeur renvoyée est un Boolean, "true" ou "false" sera utilisé pour représenter la valeur de la propriété et sera ajouté à la chaîne JSON.
Si la valeur renvoyée est null, null sera ajouté à la chaîne JSON.
Si la valeur renvoyée est un autre objet, cet objet sera, de façon récursive, transformé en une chaîne JSON en appelant la fonction remplaçant sur chaque propriété sauf si l'objet est une fonction auquel cas, rien n'est ajouté à la chaîne JSON.
Si la valeur renvoyée est undefined, la propriété ne sera pas incluse dans la chaîne JSON.


Note :
La fonction remplaçant ne peut pas être utilisée pour retirer des valeurs d'un tableau. Si on renvoie undefined ou une fonction, ce sera la valeur null qui sera utilisée.


Note :
Si on souhaite que la fonction remplaçant distingue un objet dont une propriété a un clé qui est « réellement » une chaîne vide, il faudra avoir un compteur pour le nombre d'itération. Si le compteur indique que la première itération est passée, alors il s'agit bien d'un clé avec une chaîne vide.

Exemple avec une fonction
jsfunction remplaçant(clé, valeur) {
  if (typeof valeur === "string") {
    return undefined;
  }
  return valeur;
}

var toto = {
  fondation: "Mozilla",
  modèle: "boîte",
  semaine: 45,
  transport: "bus",
  mois: 7,
};
console.log(JSON.stringify(toto, remplaçant)); // {"semaine":45, "mois":7}

Exemple avec un tableau
Si remplaçant est un tableau, les valeurs du tableau indiquent les propriétés de l'objet à inclure dans la chaîne JSON.
jsJSON.stringify(toto, ["semaine", "mois"]);
// '{"semaine":45,"mois":7}', on ne garde que "semaines" et "mois"
L'argument espaceL'argument espace est utilisé pour contrôler les espacements utilisés dans la chaîne finale.

Si c'est un nombre, les différents niveaux d'indentation auront autant d'espaces qu'indiqué grâce à ce paramètre (jusqu'à 10).
Si c'est une chaîne, les dix premiers caractères (ou la chaîne complète si elle est plus courte)

jsJSON.stringify({ a: 2 }, null, " ");
// '{
//  "a": 2
// }'

Dans l'exemple suivant on utilise la tabulation pour rendre lisible le résultat :
jsJSON.stringify({ uno: 1, dos: 2 }, null, "\t");
// renverra
// '{
//   "uno": 1,
//   "dos": 2
// }'
La fonction toJSON()Pour personnaliser la valeur d'un objet lors de sa conversion en JSON, on peut surcharger la méthode toJSON() : la valeur retournée par cette méthode toJSON() sera alors utilisée. JSON.stringify() invoquera la méthode toJSON() de l'objet avec un paramètre :

Si cet objet est une propriété de donnée, ce sera le nom de la propriété
Si cet objet est un tableau, ce sera l'indice de l'élément du tableau sous la forme d'une chaîne de caractères
Une chaîne vide si JSON.stringify() était directement appelé sur l'objet.

Ainsi :
jsvar obj = {
  data: "data",
  toJSON(clef) {
    if (clef) {
      return `Un objet imbriqué sous la clef '${clef}'`;
    } else {
      return this;
    }
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Un objet imbriqué sous la clef 'obj'"}'

JSON.stringify([obj]);
// '["Un objet imbriqué sous la clef '0'"]'
Le problème des références circulairesLe format JSON ne prend pas en charge les références (bien qu'un brouillon IETF existe) et une exception TypeError sera levée si on tente d'encoder un objet possédant des références circulaires.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Sérialiser un objet avec des références circulaires déclenche une "TypeError: cyclic object value"
JSON.stringify(circularReference);

Pour sérialiser les références circulaires, on peut utiliser une bibliothèque (cycle.js par exemple) ou implémenter sa propre solution (qui consistera à trouver et à remplacer le cycle par des valeurs sérialisables).Gestion des terminateurs de lignePar le passé, JSON n'était pas un sous-ensemble strict de JavaScript. En effet, en JSON, deux terminateurs de ligne (le caractère de séparation de ligne U+2028 LINE SEPARATOR et le caractère de séparation de paragraphe U+2029 PARAGRAPH SEPARATOR) n'avaient pas besoin d'être échappés dans des données JSON alors qu'ils devaient l'être en JavaScript. Cela a désormais évolué et les deux points de code peuvent apparaître tant en JSON qu'en JavaScript.
Ainsi, si on souhaite avoir une compatibilité avec les anciens moteurs JavaScript, on pourra évaluer ou utiliser les données JSON avec JSONP et la fonction utilitaire suivante :
jsfunction jsFriendlyJSONStringify(s) {
  return JSON.stringify(s)
    .replace(/\u2028/g, "\\u2028")
    .replace(/\u2029/g, "\\u2029");
}

var s = {
  a: String.fromCharCode(0x2028),
  b: String.fromCharCode(0x2029),
};

// dans Firefox, console.log enlève les échappements
// des caractères Unicode, on utilise donc alert :(
alert(jsFriendlyJSONStringify(s)); // {"a":"\u2028","b":"\u2029"}


Note :
Les propriétés des objets qui ne sont pas des tableaux ne sont pas transformées en chaînes de caractères selon un ordre particulier. Aussi, l'ordre des données en JSON ne saurait constituer une information utile.

jsvar a = JSON.stringify({ toto: "truc", bidule: "machin" });
// '{"toto":"truc","bidule":"machin"}'
var b = JSON.stringify({ bidule: "machin", toto: "truc" });
// '{"bidule":"machin","toto":"truc"}'
console.log(a !== b); // true
Utiliser JSON.stringify avec localStorageDans le cas où on souhaite enregistrer un objet créé par l'utilisateur afin de le restorer plus tard (y compris après que le navigateur ait été fermé), on peut utiliser JSON.stringify.

Attention :
Les fonctions n'ont pas de correspondances en JSON, il ne sera donc pas possible de les enregistrer de cette façon. En revanche, elles peuvent être affichées si elles ont été converties en texte avec la fonction de remplacement. De même, certains objets comme les dates seront transformées en chaîne de caractères après l'utilisation de JSON.parse().

js// On crée un objet pour l'exemple
var session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// On convertit l'objet en une chaîne JSON
// et on enregistre cette valeur avec le nom 'session'
localStorage.setItem("session", JSON.stringify(session));

// Ici, on reconvertit la chaîne en un objet
// JSON.stringify and saved in localStorage in JSON object again
var sessionRestaurée = JSON.parse(localStorage.getItem("session"));

// La variable sessionRestaurée contient désormais l'objet précédent
// qui avait été sauvegardé dans localStorage
console.log(sessionRestaurée);
Chaînes bien formées et JSON.stringify()Les moteurs, qui implémentent la spécification sur JSON.stringify() bien formé, transformeront en chaîne de caractères les éléments isolés de paires surrogates via des séquences d'échappement Unicode plutôt que d'utiliser leurs valeurs littérales. Avant cette modification de spécification, JSON.stringify() n'aurait pas encodé les éléments surrogates isolés et les chaînes produites n'étaient pas valides selon UTF-8 ou UTF-16 :
jsJSON.stringify("\uD800"); // '"�"'

Avec cette modification, les séquences d'échappement produites permettent d'avoir un contenu UTF-16 ou UTF-8 lisible :
jsJSON.stringify("\uD800"); // '"\\ud800"'

Cette modification est rétrocompatible pour toutes les opérations où le résultat de JSON.stringify() est passé à des API comme JSON.parse() qui acceptent du texte JSON valide. En effet, ces API traiteront les séquences d'échappement de surrogates isolés comme les caractères correspondants. Seul le cas où le code interprète directement le résultat de JSON.stringify() doit être adapté afin de gérer les deux encodages possibles pour ces cas.SpécificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyCompatibilité des navigateursVoir aussi
JSON.parse()
cycle.js qui ajoute deux fonctions JSON.decycle et JSON.retrocycle qui permettent d'encoder et de décoder des structures cycliques.
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 17 févr. 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackJSON.stringify() メソッドは、ある JavaScript のオブジェクトや値を JSON 文字列に変換します。置き換え関数を指定して値を置き換えたり、置き換え配列を指定して指定されたプロパティのみを含むようにしたりすることもできます。試してみましょう
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
構文jsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
引数
value

JSON 文字列に変換する値です。

replacer 省略可

文字列化の手順の挙動を変更する関数、または value のプロパティのうち出力に含めるものを指定する文字列と数値の配列です。この値が配列である場合は、文字列でも数値でもない要素（Symbol など）は完全に無視されます。文字列や数値としては、プリミティブでもラッパーオブジェクトでも使用可能です。この値が関数でも配列でもない場合（null の場合や、指定しない場合など）は、結果の JSON 文字列にオブジェクトの文字列をキーとするすべてのプロパティが含まれます。

space 省略可

文字列または数値で、出力する JSON 文字列に可読性を目的に空白 (インデントや改行など) を挿入するために使用します。
これが数値のときは、インデントとして使う空白文字の数を示します。この数の上限は 10 です（それより大きい数値は、単に 10 となります）。 1 より小さい値は空白を使わないことを示します。
これが文字列のときは、その文字列（10 文字より長い場合はその最初の 10 文字）がネストされたそれぞれのオブジェクトや配列の前に挿入されます。
これが文字列でも数値でもない場合（文字列や数値としては、プリミティブでもラッパーオブジェクトでも使用可能）、たとえば null や指定しない場合は、空白は使用されません。

返値与えられた値を表現する JSON 文字列。例外
TypeError

以下のいずれかの場合に発生します。

value が循環参照を含む場合。
長整数値に遭遇した場合


解説JSON.stringify() は値をそれを表す JSON 表記に変換します。値は以下のように変換されます。


Boolean、 Number、 String、および (Object() により得られる) BigInt の各オブジェクトは、文字列化の際に慣習的な変換セマンティクスに従い、対応するプリミティブ値に変換されます。(Object() により得られる) Symbol のオブジェクトは、プレーンオブジェクトとして扱われます。


BigInt の値を文字列化しようとすると、例外が発生します。しかし、BigInt が (モンキーパッチ BigInt.prototype.toJSON = ... により) toJSON() メソッドを持っている場合、このメソッドにより文字列化できます。この制約により、適切な文字列化の方法（そして、ほとんどの場合、対応する逆変換の方法）が常にユーザーによって明示されるようにします。


undefined、関数 (Function)、シンボル (Symbol) は有効な JSON 値ではありません。変換中にそのような値に遭遇した場合は、(オブジェクトの中で発見された場合は) 省略されたり、（配列の中で見つかった場合は） null に変換されたりします。 JSON.stringify() は JSON.stringify(() => {}) や JSON.stringify(undefined) のように「純粋」な値を渡した場合に undefined を返すことがあります。


Infinity および NaN の数値は、 null の値と同様に、すべて null と見なされます。(ただし、前述の値と違って、省略されることはありません)


配列は配列として（角括弧で囲まれ）文字列化されます。 0 から length - 1 までの添字 (両端を含みます) が文字列化され、他のプロパティは無視されます。


JSON.rawJSON() で作成した特殊な生の JSON オブジェクトは、（その rawJSON プロパティにアクセスすることで）それを含む生の JSON テキストとしてシリアライズされます。


その他のオブジェクトについては、以下の通りです。


シンボル (Symbol) がキーとなっているプロパティはすべて、引数 replacer を使用する場合でも完全に無視されます。


値が toJSON() メソッドを持っている場合は、それがデータをどう文字列化するかを決定します。オブジェクトを文字列化するかわりに、toJSON() メソッドが返す値が文字列化されます。JSON.stringify() は toJSON を 1 個の引数 key を指定して呼び出します。この引数は、replacer 関数と同じ以下の仕様です。

オブジェクトがプロパティの値の場合は、プロパティ名
配列の要素の場合は、配列の添字を表す文字列
JSON.stringify() がこのオブジェクトについて直接呼ばれた場合は、空文字列

Date のインスタンスは文字列を返す toJSON() を実装しています (date.toISOString() と同じです)。そのため、これは文字列に変換されます。


列挙可能なプロパティのみが文字列化されます。そのため、Map、Set、WeakMap、WeakSet などは "{}" に変換されます。引数 replacer を用いることで、これらをより実用的なものに変換できます。


プロパティは、Object.keys() と同じアルゴリズムで走査されます。このアルゴリズムは、完全に定義された順番を用い、実装間で一貫性があります。例えば、JSON.stringify() を同じオブジェクトに対して用いると、常に同じ文字列を生成します。また、JSON.parse(JSON.stringify(obj)) は (オブジェクトが完全に JSON に変換可能であると仮定すると) もとのオブジェクトと同じキーの順番を持つオブジェクトを生成します。

replacer 引数replacer 引数は関数または配列です。
配列の場合、その要素は結果の JSON 文字列に含めるオブジェクトのプロパティの名前を表します。文字列と数値である値のみが処理に用いられ、シンボルのキーは無視されます。
関数の場合、 key と文字列化される value の 2 つの引数を取ります。キーをもつオブジェクトが replacer のコンテキストで this として提供されます。
replacer 関数は、まず文字列化されるオブジェクトについて呼び出され、このときの key は空文字列 ("") です。その後、文字列化されるオブジェクトや配列のそれぞれのプロパティについて呼び出されます。配列の添字は、文字列として key に入ります。処理中のプロパティの値は、文字列化において replacer の返値に置き換えられます。すなわち:

数値、文字列、論理値、null を返すと、その値を直接文字列化したものがプロパティの値として使用されます。（長整数を返すと、例外が発生します。）
関数 (Function)、シンボル (Symbol)、undefined を返すと、出力にはそのプロパティが含まれなくなります。
それ以外のオブジェクトを返した場合、そのオブジェクトのそれぞれのプロパティに replacer 関数を呼び出して再帰的に文字列化します。


メモ: replacer 関数を用いて生成した JSON を解釈する際は、逆変換のために引数 reviver を用いたくなる可能性が高いでしょう。

通常、配列の要素の添字はずれません（要素が関数などの無効な値である場合も、省略されるのではなく null になります）。replacer 関数を用いると、別の配列を返すことで、配列の要素の順番を制御できます。space 引数space 引数で最終的な文字列での空白の数を調整できます。

数値であれば、レベルの階層がそれぞれその数の空白文字 (最大 10 文字) でインデントされます。
文字列であれば、レベルの階層がそれぞれこの文字列 (またはその最初の 10 文字) でインデントされます。

インデントの階層が 10 より長くなることはありません。space の値が数値の場合は最大 10 となり、文字列の場合は 10 文字に切り詰められます。例JSON.stringify の使用jsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// 文字列がキーとなった配列要素は列挙可能ではなく、JSON では意味をなさない
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// 標準データ構造
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// 型付き配列
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// シンボル:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// 列挙可能でないプロパティ:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt の値は例外が発生
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
リプレイサーとして関数を用いる例jsfunction replacer(key, value) {
  // プロパティをフィルターする
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

replacer で最初のオブジェクトと空文字列をキーとするプロパティを区別したい場合は、(両方の場合において key は空文字列となり、value はオブジェクトを取りうるので) 繰り返しの回数の記録が必要になるでしょう（最初の繰り返しより後の場合、本当に空文字列のキーです）。
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // (最初のオブジェクト以外の) 名前が "" であるプロパティをすべて取り除く
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
リプレイサーとして配列を使用jsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', "week" と "month" プロパティだけが保持される
引数 space の使用出力を空白 1 つでインデントします。
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

タブ文字を使うと、標準的な表示の整形と同様になります。

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() の挙動オブジェクトに toJSON() を定義することで、シリアライズの挙動をオーバーライドできます。
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
循環参照をシリアライズした場合の JSON.stringify() に関する問題JSON 形式はオブジェクト参照に対応していないため（IETF 草稿はありますが）、循環参照のあるオブジェクトをエンコードしようとすると TypeError が発生します。
jsconst circularReference = {};
circularReference.myself = circularReference;

// 循環参照をシリアライズすると "TypeError: cyclic object value" が発生
JSON.stringify(circularReference);

循環参照をシリアライズするためには、これに対応したライブラリを使用したり (Douglas Crockford による cycle.js など)、自分自身で解決策を実装したりする方法があります。循環参照を探索してシリアライズされた値に置き換える (または削除する) 必要があるでしょう。
JSON.stringify() をオブジェクトをディープコピーするために使っている場合は、かわりに structuredClone() を使いたくなるかもしれません。この関数は循環参照に対応しています。v8.serialize() などのバイナリシリアライズを行う JavaScript エンジンの API も、循環参照に対応しています。localStorage で JSON.stringify() を使った例ユーザーが作成したオブジェクトを格納し、ブラウザーが閉じた後に復元できるようにしたい場合は以下の例が JSON.stringify() を適用した模範例です。
js// JSON の一例を作成
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// JSON.stringify() で JSON 文字列に変換してから
// session の名前で localStorage に保存
localStorage.setItem("session", JSON.stringify(session));

// JSON.stringify() で生成されて localStorage に保存された文字列を
// 再び JSON オブジェクトに変換する方法の例
const restoredSession = JSON.parse(localStorage.getItem("session"));

// ここで変数 restoredSession には localStorage に保存されていた
// オブジェクトが入っている
console.log(restoredSession);
Well-formed JSON.stringify()well-formed JSON.stringify 仕様を実装しているエンジンは、サロゲート文字、U+D800 から U+DFFF までのすべてのコードポイントを、リテラルではなく Unicode エスケープシーケンスを使用して文字列化します。この変更前は、このような文字列は妥当な UTF-8 または UTF-16 でエンコードされていませんでした。
jsJSON.stringify("\uD800"); // '"�"'

しかし、この変更で JSON.stringify() は孤立サロゲートを JSON エスケープシーケンスによって表すようになり、妥当な UTF-8 または UTF-16 でエンコードすることができるようになりました。
jsJSON.stringify("\uD800"); // '"\\ud800"'

この変更では、サロゲート文字の Unicode エスケープをサロゲート文字と同一のものとして扱うため、 JSON.stringify() の結果を、JSON テキストを妥当である限りどのようなものでも受け付ける JSON.parse() のような API に渡したときに後方互換性があります。JSON.stringify() の結果を直接解析する場合のみ、JSON.stringify() がこれらのコードポイントに対して 2 通りのエンコーディングをする可能性があることに注意して扱う必要があります。仕様書SpecificationECMAScript® 2026 Language Specification # sec-json.stringifyブラウザーの互換性関連情報
現在の JSON.stringify の挙動 (シンボルおよび well-formed unicode) のポリフィル (core-js)
JSON.parse()
JSON.rawJSON()\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackJSON.stringify() メソッドは、ある JavaScript のオブジェクトや値を JSON 文字列に変換します。置き換え関数を指定して値を置き換えたり、置き換え配列を指定して指定されたプロパティのみを含むようにしたりすることもできます。試してみましょう
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
構文jsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
引数
value

JSON 文字列に変換する値です。

replacer 省略可

文字列化の手順の挙動を変更する関数、または value のプロパティのうち出力に含めるものを指定する文字列と数値の配列です。この値が配列である場合は、文字列でも数値でもない要素（Symbol など）は完全に無視されます。文字列や数値としては、プリミティブでもラッパーオブジェクトでも使用可能です。この値が関数でも配列でもない場合（null の場合や、指定しない場合など）は、結果の JSON 文字列にオブジェクトの文字列をキーとするすべてのプロパティが含まれます。

space 省略可

文字列または数値で、出力する JSON 文字列に可読性を目的に空白 (インデントや改行など) を挿入するために使用します。
これが数値のときは、インデントとして使う空白文字の数を示します。この数の上限は 10 です（それより大きい数値は、単に 10 となります）。 1 より小さい値は空白を使わないことを示します。
これが文字列のときは、その文字列（10 文字より長い場合はその最初の 10 文字）がネストされたそれぞれのオブジェクトや配列の前に挿入されます。
これが文字列でも数値でもない場合（文字列や数値としては、プリミティブでもラッパーオブジェクトでも使用可能）、たとえば null や指定しない場合は、空白は使用されません。

返値与えられた値を表現する JSON 文字列。例外
TypeError

以下のいずれかの場合に発生します。

value が循環参照を含む場合。
長整数値に遭遇した場合


解説JSON.stringify() は値をそれを表す JSON 表記に変換します。値は以下のように変換されます。


Boolean、 Number、 String、および (Object() により得られる) BigInt の各オブジェクトは、文字列化の際に慣習的な変換セマンティクスに従い、対応するプリミティブ値に変換されます。(Object() により得られる) Symbol のオブジェクトは、プレーンオブジェクトとして扱われます。


BigInt の値を文字列化しようとすると、例外が発生します。しかし、BigInt が (モンキーパッチ BigInt.prototype.toJSON = ... により) toJSON() メソッドを持っている場合、このメソッドにより文字列化できます。この制約により、適切な文字列化の方法（そして、ほとんどの場合、対応する逆変換の方法）が常にユーザーによって明示されるようにします。


undefined、関数 (Function)、シンボル (Symbol) は有効な JSON 値ではありません。変換中にそのような値に遭遇した場合は、(オブジェクトの中で発見された場合は) 省略されたり、（配列の中で見つかった場合は） null に変換されたりします。 JSON.stringify() は JSON.stringify(() => {}) や JSON.stringify(undefined) のように「純粋」な値を渡した場合に undefined を返すことがあります。


Infinity および NaN の数値は、 null の値と同様に、すべて null と見なされます。(ただし、前述の値と違って、省略されることはありません)


配列は配列として（角括弧で囲まれ）文字列化されます。 0 から length - 1 までの添字 (両端を含みます) が文字列化され、他のプロパティは無視されます。


JSON.rawJSON() で作成した特殊な生の JSON オブジェクトは、（その rawJSON プロパティにアクセスすることで）それを含む生の JSON テキストとしてシリアライズされます。


その他のオブジェクトについては、以下の通りです。


シンボル (Symbol) がキーとなっているプロパティはすべて、引数 replacer を使用する場合でも完全に無視されます。


値が toJSON() メソッドを持っている場合は、それがデータをどう文字列化するかを決定します。オブジェクトを文字列化するかわりに、toJSON() メソッドが返す値が文字列化されます。JSON.stringify() は toJSON を 1 個の引数 key を指定して呼び出します。この引数は、replacer 関数と同じ以下の仕様です。

オブジェクトがプロパティの値の場合は、プロパティ名
配列の要素の場合は、配列の添字を表す文字列
JSON.stringify() がこのオブジェクトについて直接呼ばれた場合は、空文字列

Date のインスタンスは文字列を返す toJSON() を実装しています (date.toISOString() と同じです)。そのため、これは文字列に変換されます。


列挙可能なプロパティのみが文字列化されます。そのため、Map、Set、WeakMap、WeakSet などは "{}" に変換されます。引数 replacer を用いることで、これらをより実用的なものに変換できます。


プロパティは、Object.keys() と同じアルゴリズムで走査されます。このアルゴリズムは、完全に定義された順番を用い、実装間で一貫性があります。例えば、JSON.stringify() を同じオブジェクトに対して用いると、常に同じ文字列を生成します。また、JSON.parse(JSON.stringify(obj)) は (オブジェクトが完全に JSON に変換可能であると仮定すると) もとのオブジェクトと同じキーの順番を持つオブジェクトを生成します。

replacer 引数replacer 引数は関数または配列です。
配列の場合、その要素は結果の JSON 文字列に含めるオブジェクトのプロパティの名前を表します。文字列と数値である値のみが処理に用いられ、シンボルのキーは無視されます。
関数の場合、 key と文字列化される value の 2 つの引数を取ります。キーをもつオブジェクトが replacer のコンテキストで this として提供されます。
replacer 関数は、まず文字列化されるオブジェクトについて呼び出され、このときの key は空文字列 ("") です。その後、文字列化されるオブジェクトや配列のそれぞれのプロパティについて呼び出されます。配列の添字は、文字列として key に入ります。処理中のプロパティの値は、文字列化において replacer の返値に置き換えられます。すなわち:

数値、文字列、論理値、null を返すと、その値を直接文字列化したものがプロパティの値として使用されます。（長整数を返すと、例外が発生します。）
関数 (Function)、シンボル (Symbol)、undefined を返すと、出力にはそのプロパティが含まれなくなります。
それ以外のオブジェクトを返した場合、そのオブジェクトのそれぞれのプロパティに replacer 関数を呼び出して再帰的に文字列化します。


メモ: replacer 関数を用いて生成した JSON を解釈する際は、逆変換のために引数 reviver を用いたくなる可能性が高いでしょう。

通常、配列の要素の添字はずれません（要素が関数などの無効な値である場合も、省略されるのではなく null になります）。replacer 関数を用いると、別の配列を返すことで、配列の要素の順番を制御できます。space 引数space 引数で最終的な文字列での空白の数を調整できます。

数値であれば、レベルの階層がそれぞれその数の空白文字 (最大 10 文字) でインデントされます。
文字列であれば、レベルの階層がそれぞれこの文字列 (またはその最初の 10 文字) でインデントされます。

インデントの階層が 10 より長くなることはありません。space の値が数値の場合は最大 10 となり、文字列の場合は 10 文字に切り詰められます。例JSON.stringify の使用jsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// 文字列がキーとなった配列要素は列挙可能ではなく、JSON では意味をなさない
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// 標準データ構造
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// 型付き配列
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// シンボル:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// 列挙可能でないプロパティ:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt の値は例外が発生
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
リプレイサーとして関数を用いる例jsfunction replacer(key, value) {
  // プロパティをフィルターする
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

replacer で最初のオブジェクトと空文字列をキーとするプロパティを区別したい場合は、(両方の場合において key は空文字列となり、value はオブジェクトを取りうるので) 繰り返しの回数の記録が必要になるでしょう（最初の繰り返しより後の場合、本当に空文字列のキーです）。
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // (最初のオブジェクト以外の) 名前が "" であるプロパティをすべて取り除く
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
リプレイサーとして配列を使用jsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', "week" と "month" プロパティだけが保持される
引数 space の使用出力を空白 1 つでインデントします。
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

タブ文字を使うと、標準的な表示の整形と同様になります。

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() の挙動オブジェクトに toJSON() を定義することで、シリアライズの挙動をオーバーライドできます。
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
循環参照をシリアライズした場合の JSON.stringify() に関する問題JSON 形式はオブジェクト参照に対応していないため（IETF 草稿はありますが）、循環参照のあるオブジェクトをエンコードしようとすると TypeError が発生します。
jsconst circularReference = {};
circularReference.myself = circularReference;

// 循環参照をシリアライズすると "TypeError: cyclic object value" が発生
JSON.stringify(circularReference);

循環参照をシリアライズするためには、これに対応したライブラリを使用したり (Douglas Crockford による cycle.js など)、自分自身で解決策を実装したりする方法があります。循環参照を探索してシリアライズされた値に置き換える (または削除する) 必要があるでしょう。
JSON.stringify() をオブジェクトをディープコピーするために使っている場合は、かわりに structuredClone() を使いたくなるかもしれません。この関数は循環参照に対応しています。v8.serialize() などのバイナリシリアライズを行う JavaScript エンジンの API も、循環参照に対応しています。localStorage で JSON.stringify() を使った例ユーザーが作成したオブジェクトを格納し、ブラウザーが閉じた後に復元できるようにしたい場合は以下の例が JSON.stringify() を適用した模範例です。
js// JSON の一例を作成
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// JSON.stringify() で JSON 文字列に変換してから
// session の名前で localStorage に保存
localStorage.setItem("session", JSON.stringify(session));

// JSON.stringify() で生成されて localStorage に保存された文字列を
// 再び JSON オブジェクトに変換する方法の例
const restoredSession = JSON.parse(localStorage.getItem("session"));

// ここで変数 restoredSession には localStorage に保存されていた
// オブジェクトが入っている
console.log(restoredSession);
Well-formed JSON.stringify()well-formed JSON.stringify 仕様を実装しているエンジンは、サロゲート文字、U+D800 から U+DFFF までのすべてのコードポイントを、リテラルではなく Unicode エスケープシーケンスを使用して文字列化します。この変更前は、このような文字列は妥当な UTF-8 または UTF-16 でエンコードされていませんでした。
jsJSON.stringify("\uD800"); // '"�"'

しかし、この変更で JSON.stringify() は孤立サロゲートを JSON エスケープシーケンスによって表すようになり、妥当な UTF-8 または UTF-16 でエンコードすることができるようになりました。
jsJSON.stringify("\uD800"); // '"\\ud800"'

この変更では、サロゲート文字の Unicode エスケープをサロゲート文字と同一のものとして扱うため、 JSON.stringify() の結果を、JSON テキストを妥当である限りどのようなものでも受け付ける JSON.parse() のような API に渡したときに後方互換性があります。JSON.stringify() の結果を直接解析する場合のみ、JSON.stringify() がこれらのコードポイントに対して 2 通りのエンコーディングをする可能性があることに注意して扱う必要があります。仕様書SpecificationECMAScript® 2026 Language Specification # sec-json.stringifyブラウザーの互換性関連情報
現在の JSON.stringify の挙動 (シンボルおよび well-formed unicode) のポリフィル (core-js)
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025年3月21日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackJSON.stringify() メソッドは、ある JavaScript のオブジェクトや値を JSON 文字列に変換します。置き換え関数を指定して値を置き換えたり、置き換え配列を指定して指定されたプロパティのみを含むようにしたりすることもできます。試してみましょう
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
構文jsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
引数
value

JSON 文字列に変換する値です。

replacer 省略可

文字列化の手順の挙動を変更する関数、または value のプロパティのうち出力に含めるものを指定する文字列と数値の配列です。この値が配列である場合は、文字列でも数値でもない要素（Symbol など）は完全に無視されます。文字列や数値としては、プリミティブでもラッパーオブジェクトでも使用可能です。この値が関数でも配列でもない場合（null の場合や、指定しない場合など）は、結果の JSON 文字列にオブジェクトの文字列をキーとするすべてのプロパティが含まれます。

space 省略可

文字列または数値で、出力する JSON 文字列に可読性を目的に空白 (インデントや改行など) を挿入するために使用します。
これが数値のときは、インデントとして使う空白文字の数を示します。この数の上限は 10 です（それより大きい数値は、単に 10 となります）。 1 より小さい値は空白を使わないことを示します。
これが文字列のときは、その文字列（10 文字より長い場合はその最初の 10 文字）がネストされたそれぞれのオブジェクトや配列の前に挿入されます。
これが文字列でも数値でもない場合（文字列や数値としては、プリミティブでもラッパーオブジェクトでも使用可能）、たとえば null や指定しない場合は、空白は使用されません。

返値与えられた値を表現する JSON 文字列。例外
TypeError

以下のいずれかの場合に発生します。

value が循環参照を含む場合。
長整数値に遭遇した場合


解説JSON.stringify() は値をそれを表す JSON 表記に変換します。値は以下のように変換されます。


Boolean、 Number、 String、および (Object() により得られる) BigInt の各オブジェクトは、文字列化の際に慣習的な変換セマンティクスに従い、対応するプリミティブ値に変換されます。(Object() により得られる) Symbol のオブジェクトは、プレーンオブジェクトとして扱われます。


BigInt の値を文字列化しようとすると、例外が発生します。しかし、BigInt が (モンキーパッチ BigInt.prototype.toJSON = ... により) toJSON() メソッドを持っている場合、このメソッドにより文字列化できます。この制約により、適切な文字列化の方法（そして、ほとんどの場合、対応する逆変換の方法）が常にユーザーによって明示されるようにします。


undefined、関数 (Function)、シンボル (Symbol) は有効な JSON 値ではありません。変換中にそのような値に遭遇した場合は、(オブジェクトの中で発見された場合は) 省略されたり、（配列の中で見つかった場合は） null に変換されたりします。 JSON.stringify() は JSON.stringify(() => {}) や JSON.stringify(undefined) のように「純粋」な値を渡した場合に undefined を返すことがあります。


Infinity および NaN の数値は、 null の値と同様に、すべて null と見なされます。(ただし、前述の値と違って、省略されることはありません)


配列は配列として（角括弧で囲まれ）文字列化されます。 0 から length - 1 までの添字 (両端を含みます) が文字列化され、他のプロパティは無視されます。


JSON.rawJSON() で作成した特殊な生の JSON オブジェクトは、（その rawJSON プロパティにアクセスすることで）それを含む生の JSON テキストとしてシリアライズされます。


その他のオブジェクトについては、以下の通りです。


シンボル (Symbol) がキーとなっているプロパティはすべて、引数 replacer を使用する場合でも完全に無視されます。


値が toJSON() メソッドを持っている場合は、それがデータをどう文字列化するかを決定します。オブジェクトを文字列化するかわりに、toJSON() メソッドが返す値が文字列化されます。JSON.stringify() は toJSON を 1 個の引数 key を指定して呼び出します。この引数は、replacer 関数と同じ以下の仕様です。

オブジェクトがプロパティの値の場合は、プロパティ名
配列の要素の場合は、配列の添字を表す文字列
JSON.stringify() がこのオブジェクトについて直接呼ばれた場合は、空文字列

Date のインスタンスは文字列を返す toJSON() を実装しています (date.toISOString() と同じです)。そのため、これは文字列に変換されます。


列挙可能なプロパティのみが文字列化されます。そのため、Map、Set、WeakMap、WeakSet などは "{}" に変換されます。引数 replacer を用いることで、これらをより実用的なものに変換できます。


プロパティは、Object.keys() と同じアルゴリズムで走査されます。このアルゴリズムは、完全に定義された順番を用い、実装間で一貫性があります。例えば、JSON.stringify() を同じオブジェクトに対して用いると、常に同じ文字列を生成します。また、JSON.parse(JSON.stringify(obj)) は (オブジェクトが完全に JSON に変換可能であると仮定すると) もとのオブジェクトと同じキーの順番を持つオブジェクトを生成します。

replacer 引数replacer 引数は関数または配列です。
配列の場合、その要素は結果の JSON 文字列に含めるオブジェクトのプロパティの名前を表します。文字列と数値である値のみが処理に用いられ、シンボルのキーは無視されます。
関数の場合、 key と文字列化される value の 2 つの引数を取ります。キーをもつオブジェクトが replacer のコンテキストで this として提供されます。
replacer 関数は、まず文字列化されるオブジェクトについて呼び出され、このときの key は空文字列 ("") です。その後、文字列化されるオブジェクトや配列のそれぞれのプロパティについて呼び出されます。配列の添字は、文字列として key に入ります。処理中のプロパティの値は、文字列化において replacer の返値に置き換えられます。すなわち:

数値、文字列、論理値、null を返すと、その値を直接文字列化したものがプロパティの値として使用されます。（長整数を返すと、例外が発生します。）
関数 (Function)、シンボル (Symbol)、undefined を返すと、出力にはそのプロパティが含まれなくなります。
それ以外のオブジェクトを返した場合、そのオブジェクトのそれぞれのプロパティに replacer 関数を呼び出して再帰的に文字列化します。


メモ: replacer 関数を用いて生成した JSON を解釈する際は、逆変換のために引数 reviver を用いたくなる可能性が高いでしょう。

通常、配列の要素の添字はずれません（要素が関数などの無効な値である場合も、省略されるのではなく null になります）。replacer 関数を用いると、別の配列を返すことで、配列の要素の順番を制御できます。space 引数space 引数で最終的な文字列での空白の数を調整できます。

数値であれば、レベルの階層がそれぞれその数の空白文字 (最大 10 文字) でインデントされます。
文字列であれば、レベルの階層がそれぞれこの文字列 (またはその最初の 10 文字) でインデントされます。

インデントの階層が 10 より長くなることはありません。space の値が数値の場合は最大 10 となり、文字列の場合は 10 文字に切り詰められます。例JSON.stringify の使用jsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// 文字列がキーとなった配列要素は列挙可能ではなく、JSON では意味をなさない
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// 標準データ構造
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// 型付き配列
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// シンボル:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// 列挙可能でないプロパティ:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt の値は例外が発生
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
リプレイサーとして関数を用いる例jsfunction replacer(key, value) {
  // プロパティをフィルターする
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

replacer で最初のオブジェクトと空文字列をキーとするプロパティを区別したい場合は、(両方の場合において key は空文字列となり、value はオブジェクトを取りうるので) 繰り返しの回数の記録が必要になるでしょう（最初の繰り返しより後の場合、本当に空文字列のキーです）。
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // (最初のオブジェクト以外の) 名前が "" であるプロパティをすべて取り除く
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
リプレイサーとして配列を使用jsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', "week" と "month" プロパティだけが保持される
引数 space の使用出力を空白 1 つでインデントします。
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

タブ文字を使うと、標準的な表示の整形と同様になります。

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() の挙動オブジェクトに toJSON() を定義することで、シリアライズの挙動をオーバーライドできます。
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
循環参照をシリアライズした場合の JSON.stringify() に関する問題JSON 形式はオブジェクト参照に対応していないため（IETF 草稿はありますが）、循環参照のあるオブジェクトをエンコードしようとすると TypeError が発生します。
jsconst circularReference = {};
circularReference.myself = circularReference;

// 循環参照をシリアライズすると "TypeError: cyclic object value" が発生
JSON.stringify(circularReference);

循環参照をシリアライズするためには、これに対応したライブラリを使用したり (Douglas Crockford による cycle.js など)、自分自身で解決策を実装したりする方法があります。循環参照を探索してシリアライズされた値に置き換える (または削除する) 必要があるでしょう。
JSON.stringify() をオブジェクトをディープコピーするために使っている場合は、かわりに structuredClone() を使いたくなるかもしれません。この関数は循環参照に対応しています。v8.serialize() などのバイナリシリアライズを行う JavaScript エンジンの API も、循環参照に対応しています。localStorage で JSON.stringify() を使った例ユーザーが作成したオブジェクトを格納し、ブラウザーが閉じた後に復元できるようにしたい場合は以下の例が JSON.stringify() を適用した模範例です。
js// JSON の一例を作成
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// JSON.stringify() で JSON 文字列に変換してから
// session の名前で localStorage に保存
localStorage.setItem("session", JSON.stringify(session));

// JSON.stringify() で生成されて localStorage に保存された文字列を
// 再び JSON オブジェクトに変換する方法の例
const restoredSession = JSON.parse(localStorage.getItem("session"));

// ここで変数 restoredSession には localStorage に保存されていた
// オブジェクトが入っている
console.log(restoredSession);
Well-formed JSON.stringify()well-formed JSON.stringify 仕様を実装しているエンジンは、サロゲート文字、U+D800 から U+DFFF までのすべてのコードポイントを、リテラルではなく Unicode エスケープシーケンスを使用して文字列化します。この変更前は、このような文字列は妥当な UTF-8 または UTF-16 でエンコードされていませんでした。
jsJSON.stringify("\uD800"); // '"�"'

しかし、この変更で JSON.stringify() は孤立サロゲートを JSON エスケープシーケンスによって表すようになり、妥当な UTF-8 または UTF-16 でエンコードすることができるようになりました。
jsJSON.stringify("\uD800"); // '"\\ud800"'

この変更では、サロゲート文字の Unicode エスケープをサロゲート文字と同一のものとして扱うため、 JSON.stringify() の結果を、JSON テキストを妥当である限りどのようなものでも受け付ける JSON.parse() のような API に渡したときに後方互換性があります。JSON.stringify() の結果を直接解析する場合のみ、JSON.stringify() がこれらのコードポイントに対して 2 通りのエンコーディングをする可能性があることに注意して扱う必要があります。仕様書SpecificationECMAScript® 2026 Language Specification # sec-json.stringifyブラウザーの互換性関連情報
現在の JSON.stringify の挙動 (シンボルおよび well-formed unicode) のポリフィル (core-js)
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025年3月21日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackJSON.stringify() 메서드는 JavaScript 값이나 객체를 JSON 문자열로 변환합니다. 선택적으로, replacer를 함수로 전달할 경우 변환 전 값을 변형할 수 있고, 배열로 전달할 경우 지정한 속성만 결과에 포함합니다.시도해 보기
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
구문js    JSON.stringify(value[, replacer[, space]])
매개변수
value

JSON 문자열로 변환할 값.

replacer Optional

문자열화 동작 방식을 변경하는 함수, 혹은 JSON 문자열에 포함될 값 객체의 속성들을 선택하기 위한 화이트리스트(whitelist)로 쓰이는 String 과 Number 객체들의 배열. 이 값이 null 이거나 제공되지 않으면, 객체의 모든 속성들이 JSON 문자열 결과에 포함된다.

space Optional

가독성을 목적으로 JSON 문자열 출력에 공백을 삽입하는데 사용되는 String 또는 Number 객체. 이것이 Number 라면, 공백으로 사용되는 스페이스(space)의 수를 나타낸다; 이 수가 10 보다 크면 10 으로 제한된다. 1 보다 작은 값은 스페이스가 사용되지 않는 것을 나타낸다. 이것이 String 이라면, 그 문자열(만약 길이가 10 보다 길다면, 첫번째 10 개의 문자)이 공백으로 사용된다. 이 매개 변수가 제공되지 않는다면(또는 null 이면), 공백이 사용되지 않는다.

반환 값주어진 값과 대응하는 JSON 문자열.예외순환 참조를 발견할 경우 TypeError(cyclic object value).설명JSON.stringify()는 값을 JSON 표기법으로 변환한다.

배열이 아닌 객체의 속성들은 어떤 특정한 순서에 따라 문자열화 될 것이라고 보장되지 않는다. 같은 객체의 문자열화에 있어서 속성의 순서에 의존하지 않는다.
Boolean, Number, String 객체들은 문자열화 될 때 전통적인 변환 의미에 따라 연관된 기본형(primitive) 값으로 변환된다.
undefined, 함수, 심볼(symbol)은 변환될 때 생략되거나(객체 안에 있을 경우) null 로 변환된다(배열 안에 있을 경우).
심볼을 키로 가지는 속성들은 replacer 함수를 사용하더라도 완전히 무시된다.
열거 불가능한 속성들은 무시된다.

jsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(2006, 0, 2, 15, 4, 5));
// '"2006-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}' or '{"y":6,"x":5}'
JSON.stringify([new Number(1), new String("false"), new Boolean(false)]);
// '[1,"false",false]'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, function (k, v) {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// '{}'

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'
replacer 매개 변수replacer 매개변수는 함수 또는 배열이 될 수 있다. 함수일 때는 문자열화 될 key 와 value, 2개의 매개변수를 받는다. key 가 발견된 객체는 리플레이서의 this 매개변수로 제공된다. 맨 처음에는 문자열화될 그 객체를 나타내는 비어 있는 key와 함께 호출되고, 그 다음에는 문자열화될 그 객체나 배열의 각 속성에 대해 호출된다. 이것은 JSON 문자열에 추가되어야 하는 값을 반환해야한다:

Number 를 반환하면, JSON 문자열에 추가될 때 그 수를 나타내는 문자열이 그 속성의 값으로 사용된다.
String 을 반환하면, 그것이 JSON 문자열에 추가될 때 속성의 값으로 사용된다.
Boolean 을 반환하면, 그것이 JSON 문자열에 추가될 때 "true" 또는 "false" 이 속성의 값으로 사용된다.
다른 객체를 반환하면, 그 객체는 replacer 함수를 각각의 속성에 대해 호출하며 순환적으로 JSON 문자열로 문자열화된다. 그 객체가 함수인 경우에는 JSON 문자열에 아무것도 추가되지 않는다.
undefined 를 반환하면, 그 속성은 JSON 문자열 결과에 포함되지 않는다.


참고: 유의: replacer 함수를 배열로부터 값을 제거하기위해 사용할 수 없다. 만약 undefined 나 함수를 반환한다면 null 이 대신 사용될 것이다.

함수에 대한 예제
jsfunction replacer(key, value) {
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

var foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
var jsonString = JSON.stringify(foo, replacer);

JSON 문자열 결과는 {"week":45,"month":7} 이다.
배열에 대한 예제
replacer 가 배열인 경우, 그 배열의 값은 JSON 문자열의 결과에 포함되는 속성의 이름을 나타낸다.
jsJSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', 단지 "week" 와 "month" 속성을 포함한다
space 매개 변수space 매개변수는 최종 문자열의 간격을 제어한다. 숫자일 경우 최대 10자 만큼의 공백 문자 크기로 들여쓰기되며, 문자열인 경우 해당 문자열 또는 처음 10자 만큼 들여쓰기 된다.
jsJSON.stringify({ a: 2 }, null, " ");
// '{
//  "a": 2
// }'

'\t'를 사용하면 일반적으로 들여쓰기 된 코드스타일과 유사함.
jsJSON.stringify({ uno: 1, dos: 2 }, null, "\t");
// returns the string:
// '{
//     "uno": 1,
//     "dos": 2
// }'
toJSON() 작동If an object being stringified has a property named toJSON whose value is a function, then the toJSON() method customizes JSON stringification behavior: instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. For example:
jsvar obj = {
  foo: "foo",
  toJSON: function () {
    return "bar";
  },
};
JSON.stringify(obj); // '"bar"'
JSON.stringify({ x: obj }); // '{"x":"bar"}'
Example of using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allowing it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():

경고 :
Functions are not a valid JSON data type so they will not work. However, they can be displayed if first converted to a string (e.g. in the replacer), via the function's toString method. Also, some objects like Date will be a string after JSON.parse().

js// Creating an example of JSON
var session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
var restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
명세서SpecificationECMAScript® 2026 Language Specification # sec-json.stringify브라우저 호환성같이 보기
JSON.parse()\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackJSON.stringify() 메서드는 JavaScript 값이나 객체를 JSON 문자열로 변환합니다. 선택적으로, replacer를 함수로 전달할 경우 변환 전 값을 변형할 수 있고, 배열로 전달할 경우 지정한 속성만 결과에 포함합니다.시도해 보기
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
구문js    JSON.stringify(value[, replacer[, space]])
매개변수
value

JSON 문자열로 변환할 값.

replacer Optional

문자열화 동작 방식을 변경하는 함수, 혹은 JSON 문자열에 포함될 값 객체의 속성들을 선택하기 위한 화이트리스트(whitelist)로 쓰이는 String 과 Number 객체들의 배열. 이 값이 null 이거나 제공되지 않으면, 객체의 모든 속성들이 JSON 문자열 결과에 포함된다.

space Optional

가독성을 목적으로 JSON 문자열 출력에 공백을 삽입하는데 사용되는 String 또는 Number 객체. 이것이 Number 라면, 공백으로 사용되는 스페이스(space)의 수를 나타낸다; 이 수가 10 보다 크면 10 으로 제한된다. 1 보다 작은 값은 스페이스가 사용되지 않는 것을 나타낸다. 이것이 String 이라면, 그 문자열(만약 길이가 10 보다 길다면, 첫번째 10 개의 문자)이 공백으로 사용된다. 이 매개 변수가 제공되지 않는다면(또는 null 이면), 공백이 사용되지 않는다.

반환 값주어진 값과 대응하는 JSON 문자열.예외순환 참조를 발견할 경우 TypeError(cyclic object value).설명JSON.stringify()는 값을 JSON 표기법으로 변환한다.

배열이 아닌 객체의 속성들은 어떤 특정한 순서에 따라 문자열화 될 것이라고 보장되지 않는다. 같은 객체의 문자열화에 있어서 속성의 순서에 의존하지 않는다.
Boolean, Number, String 객체들은 문자열화 될 때 전통적인 변환 의미에 따라 연관된 기본형(primitive) 값으로 변환된다.
undefined, 함수, 심볼(symbol)은 변환될 때 생략되거나(객체 안에 있을 경우) null 로 변환된다(배열 안에 있을 경우).
심볼을 키로 가지는 속성들은 replacer 함수를 사용하더라도 완전히 무시된다.
열거 불가능한 속성들은 무시된다.

jsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(2006, 0, 2, 15, 4, 5));
// '"2006-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}' or '{"y":6,"x":5}'
JSON.stringify([new Number(1), new String("false"), new Boolean(false)]);
// '[1,"false",false]'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, function (k, v) {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// '{}'

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'
replacer 매개 변수replacer 매개변수는 함수 또는 배열이 될 수 있다. 함수일 때는 문자열화 될 key 와 value, 2개의 매개변수를 받는다. key 가 발견된 객체는 리플레이서의 this 매개변수로 제공된다. 맨 처음에는 문자열화될 그 객체를 나타내는 비어 있는 key와 함께 호출되고, 그 다음에는 문자열화될 그 객체나 배열의 각 속성에 대해 호출된다. 이것은 JSON 문자열에 추가되어야 하는 값을 반환해야한다:

Number 를 반환하면, JSON 문자열에 추가될 때 그 수를 나타내는 문자열이 그 속성의 값으로 사용된다.
String 을 반환하면, 그것이 JSON 문자열에 추가될 때 속성의 값으로 사용된다.
Boolean 을 반환하면, 그것이 JSON 문자열에 추가될 때 "true" 또는 "false" 이 속성의 값으로 사용된다.
다른 객체를 반환하면, 그 객체는 replacer 함수를 각각의 속성에 대해 호출하며 순환적으로 JSON 문자열로 문자열화된다. 그 객체가 함수인 경우에는 JSON 문자열에 아무것도 추가되지 않는다.
undefined 를 반환하면, 그 속성은 JSON 문자열 결과에 포함되지 않는다.


참고: 유의: replacer 함수를 배열로부터 값을 제거하기위해 사용할 수 없다. 만약 undefined 나 함수를 반환한다면 null 이 대신 사용될 것이다.

함수에 대한 예제
jsfunction replacer(key, value) {
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

var foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
var jsonString = JSON.stringify(foo, replacer);

JSON 문자열 결과는 {"week":45,"month":7} 이다.
배열에 대한 예제
replacer 가 배열인 경우, 그 배열의 값은 JSON 문자열의 결과에 포함되는 속성의 이름을 나타낸다.
jsJSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', 단지 "week" 와 "month" 속성을 포함한다
space 매개 변수space 매개변수는 최종 문자열의 간격을 제어한다. 숫자일 경우 최대 10자 만큼의 공백 문자 크기로 들여쓰기되며, 문자열인 경우 해당 문자열 또는 처음 10자 만큼 들여쓰기 된다.
jsJSON.stringify({ a: 2 }, null, " ");
// '{
//  "a": 2
// }'

'\t'를 사용하면 일반적으로 들여쓰기 된 코드스타일과 유사함.
jsJSON.stringify({ uno: 1, dos: 2 }, null, "\t");
// returns the string:
// '{
//     "uno": 1,
//     "dos": 2
// }'
toJSON() 작동If an object being stringified has a property named toJSON whose value is a function, then the toJSON() method customizes JSON stringification behavior: instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. For example:
jsvar obj = {
  foo: "foo",
  toJSON: function () {
    return "bar";
  },
};
JSON.stringify(obj); // '"bar"'
JSON.stringify({ x: obj }); // '{"x":"bar"}'
Example of using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allowing it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():

경고 :
Functions are not a valid JSON data type so they will not work. However, they can be displayed if first converted to a string (e.g. in the replacer), via the function's toString method. Also, some objects like Date will be a string after JSON.parse().

js// Creating an example of JSON
var session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
var restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
명세서SpecificationECMAScript® 2026 Language Specification # sec-json.stringify브라우저 호환성같이 보기
JSON.parse()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025년 2월 11일 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackJSON.stringify() 메서드는 JavaScript 값이나 객체를 JSON 문자열로 변환합니다. 선택적으로, replacer를 함수로 전달할 경우 변환 전 값을 변형할 수 있고, 배열로 전달할 경우 지정한 속성만 결과에 포함합니다.시도해 보기
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
구문js    JSON.stringify(value[, replacer[, space]])
매개변수
value

JSON 문자열로 변환할 값.

replacer Optional

문자열화 동작 방식을 변경하는 함수, 혹은 JSON 문자열에 포함될 값 객체의 속성들을 선택하기 위한 화이트리스트(whitelist)로 쓰이는 String 과 Number 객체들의 배열. 이 값이 null 이거나 제공되지 않으면, 객체의 모든 속성들이 JSON 문자열 결과에 포함된다.

space Optional

가독성을 목적으로 JSON 문자열 출력에 공백을 삽입하는데 사용되는 String 또는 Number 객체. 이것이 Number 라면, 공백으로 사용되는 스페이스(space)의 수를 나타낸다; 이 수가 10 보다 크면 10 으로 제한된다. 1 보다 작은 값은 스페이스가 사용되지 않는 것을 나타낸다. 이것이 String 이라면, 그 문자열(만약 길이가 10 보다 길다면, 첫번째 10 개의 문자)이 공백으로 사용된다. 이 매개 변수가 제공되지 않는다면(또는 null 이면), 공백이 사용되지 않는다.

반환 값주어진 값과 대응하는 JSON 문자열.예외순환 참조를 발견할 경우 TypeError(cyclic object value).설명JSON.stringify()는 값을 JSON 표기법으로 변환한다.

배열이 아닌 객체의 속성들은 어떤 특정한 순서에 따라 문자열화 될 것이라고 보장되지 않는다. 같은 객체의 문자열화에 있어서 속성의 순서에 의존하지 않는다.
Boolean, Number, String 객체들은 문자열화 될 때 전통적인 변환 의미에 따라 연관된 기본형(primitive) 값으로 변환된다.
undefined, 함수, 심볼(symbol)은 변환될 때 생략되거나(객체 안에 있을 경우) null 로 변환된다(배열 안에 있을 경우).
심볼을 키로 가지는 속성들은 replacer 함수를 사용하더라도 완전히 무시된다.
열거 불가능한 속성들은 무시된다.

jsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(2006, 0, 2, 15, 4, 5));
// '"2006-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}' or '{"y":6,"x":5}'
JSON.stringify([new Number(1), new String("false"), new Boolean(false)]);
// '[1,"false",false]'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, function (k, v) {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// '{}'

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'
replacer 매개 변수replacer 매개변수는 함수 또는 배열이 될 수 있다. 함수일 때는 문자열화 될 key 와 value, 2개의 매개변수를 받는다. key 가 발견된 객체는 리플레이서의 this 매개변수로 제공된다. 맨 처음에는 문자열화될 그 객체를 나타내는 비어 있는 key와 함께 호출되고, 그 다음에는 문자열화될 그 객체나 배열의 각 속성에 대해 호출된다. 이것은 JSON 문자열에 추가되어야 하는 값을 반환해야한다:

Number 를 반환하면, JSON 문자열에 추가될 때 그 수를 나타내는 문자열이 그 속성의 값으로 사용된다.
String 을 반환하면, 그것이 JSON 문자열에 추가될 때 속성의 값으로 사용된다.
Boolean 을 반환하면, 그것이 JSON 문자열에 추가될 때 "true" 또는 "false" 이 속성의 값으로 사용된다.
다른 객체를 반환하면, 그 객체는 replacer 함수를 각각의 속성에 대해 호출하며 순환적으로 JSON 문자열로 문자열화된다. 그 객체가 함수인 경우에는 JSON 문자열에 아무것도 추가되지 않는다.
undefined 를 반환하면, 그 속성은 JSON 문자열 결과에 포함되지 않는다.


참고: 유의: replacer 함수를 배열로부터 값을 제거하기위해 사용할 수 없다. 만약 undefined 나 함수를 반환한다면 null 이 대신 사용될 것이다.

함수에 대한 예제
jsfunction replacer(key, value) {
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

var foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
var jsonString = JSON.stringify(foo, replacer);

JSON 문자열 결과는 {"week":45,"month":7} 이다.
배열에 대한 예제
replacer 가 배열인 경우, 그 배열의 값은 JSON 문자열의 결과에 포함되는 속성의 이름을 나타낸다.
jsJSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', 단지 "week" 와 "month" 속성을 포함한다
space 매개 변수space 매개변수는 최종 문자열의 간격을 제어한다. 숫자일 경우 최대 10자 만큼의 공백 문자 크기로 들여쓰기되며, 문자열인 경우 해당 문자열 또는 처음 10자 만큼 들여쓰기 된다.
jsJSON.stringify({ a: 2 }, null, " ");
// '{
//  "a": 2
// }'

'\t'를 사용하면 일반적으로 들여쓰기 된 코드스타일과 유사함.
jsJSON.stringify({ uno: 1, dos: 2 }, null, "\t");
// returns the string:
// '{
//     "uno": 1,
//     "dos": 2
// }'
toJSON() 작동If an object being stringified has a property named toJSON whose value is a function, then the toJSON() method customizes JSON stringification behavior: instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. For example:
jsvar obj = {
  foo: "foo",
  toJSON: function () {
    return "bar";
  },
};
JSON.stringify(obj); // '"bar"'
JSON.stringify({ x: obj }); // '{"x":"bar"}'
Example of using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allowing it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():

경고 :
Functions are not a valid JSON data type so they will not work. However, they can be displayed if first converted to a string (e.g. in the replacer), via the function's toString method. Also, some objects like Date will be a string after JSON.parse().

js// Creating an example of JSON
var session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
var restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
명세서SpecificationECMAScript® 2026 Language Specification # sec-json.stringify브라우저 호환성같이 보기
JSON.parse()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025년 2월 11일 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackResumoO método JSON.stringify() converte valores em javascript para uma String JSON. Esses valores podem ser substituidos especificando a função replacer, ou incluindo somente as propriedades específicas, quando o array do replacer for especificado.SintaxeJSON.stringify(valor[, replacer[, espaço]])
Parâmetros
valor

O valor a ser convertido para uma string JSON.

replacer Optional

Uma função que altera o comportamento do processo de transformação em string, ou um array de objetos String e Number que servem como uma lista branca para selecionar as propriedades do objeto valor a ser incluído na string JSON. Se este valor for nulo ou não fornecido, todas as propriedades do objeto são incluídas na string JSON resultante.

espaço Optional

Um objeto String ou Number que é usado para inserir espaço em branco na saída da string JSON para propósito de legibilidade. Se isto for um Number, indica o número de caracteres espaço para usar como espaço em branco; este número é limitado em 10 se for maior que isso. Valores menores que 1 indicam que nenhum espaço deve ser usado. Se isto for uma String, a string (ou os primeiros 10 caracteres da string, se for maior que isso) é usado como espaço em branco. Se esse parâmetro não for fornecido (ou for null), nenhum espaço em branco é usado.

DescriçãoJSON.stringify() converte um valor para uma notação JSON que o representa:

Se o valor tiver um método toJSON(), é responsável por definir quais dados serão serializados.
Boolean, Number, and String os objetos são convertidos para os valores primitivos correspondentes durante a stringificação, de acordo com a semântica de conversão.
Se undefined, uma função, ou um symbol é encontrado durante a conversão é omitido (quando é encontrado em um objeto) ou censurado para null (quando é encontrado em um Array). JSON.stringify pode também somente retornar undefined ao passar valores puros como JSON.stringify(function(){}) ou JSON.stringify(undefined).
Todas as propriedades com chave de símbolo serão completamente ignoradas, mesmo quando usar a função replacer.
Propriedades não enumeráveis serão ignoradas.

jsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}' or '{"y":6,"x":5}'
JSON.stringify([new Number(1), new String("false"), new Boolean(false)]);
// '[1,"false",false]'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, function (k, v) {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// '{}'
O parâmetro replacer parameterO parâmetro replacer pode ser uma função ou uma matriz. Como função, são necessários dois parâmetros, a chave e os valores que estão sendo especificados. O objeto no qual a chave foi encontrada é fornecido como substituto desse parâmetro. Inicialmente, ele é chamado com uma chave vazia que representa o objeto que está sendo codificado e, em seguida, é chamado para cada propriedade no objeto ou matriz que está sendo codificada. Ele deve retornar o valor que deve ser adicionado à cadeia JSON, da seguinte maneira:

Se você retornar um Number, a string correspondente a esse número é usada como o valor da propriedade quando adicionada à sequência JSON.
If you return a String, that string is used as the property's value when adding it to the JSON string.
If you return a Boolean, "true" or "false" is used as the property's value, as appropriate, when adding it to the JSON string.
If you return any other object, the object is recursively stringified into the JSON string, calling the replacer function on each property, unless the object is a function, in which case nothing is added to the JSON string.
If you return undefined, the property is not included in the output JSON string.


**Nota:**Você não pode usar a função replacer para remover valoeres em uma array. Se você retornar undefined, null será usado no lugar.

Exemplo de uma função
jsfunction replacer(key, value) {
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

var foo = {
  fundação: "Mozilla",
  modelo: "caixa",
  semana: 45,
  transporte: "carro",
  mês: 7,
};
var jsonString = JSON.stringify(foo, replacer);

O resultado do JSON é: {"semana":45,"mês":7}.
Exemplo em uma array
Se replacer é usado em uma array, os valores da array indicam os nomes das propriedades no objeto, que devem ser incluídas na sequência JSON resultante.
jsJSON.stringify(foo, ["semana", "mês"]);
// '{"semana":45,"mês":7}', apenas mantém as propriedades "semana" e "mês"
O argumento spaceO argumento space O argumento pode ser usado para controlar o espaçamento na sequência final. Se for um número, os níveis sucessivos na stringficação serão recuados por esse número de caracteres de espaço (até 10). Se for uma sequência, os níveis sucessivos serão recuados por essa sequência (ou pelos dez primeiros caracteres).
jsJSON.stringify({ a: 2 }, null, " ");
// '{
//  "a": 2
// }'

O uso de um caractere de tabulação imita a aparência padrão de impressão pretty-print.
jsJSON.stringify({ um: 1, dois: 2 }, null, "\t");
// r:
// '{
//     "um": 1,
//     "dois": 2
// }'
Comportamento de toJSON()Se um objeto sendo stringificado tiver uma propriedade denominada toJSON() cujo valor é uma função, o método toJSON() personaliza o comportamento da stringificação JSON, em vez de o objeto ser serializado, o valor retornado pelo método toJSON() quando chamado será serializado. Por exemplo:
jsvar obj = {
  foo: "foo",
  toJSON: function () {
    return "bar";
  },
};
JSON.stringify(obj); // '"bar"'
JSON.stringify({ x: obj }); // '{"x":"bar"}'
Exemplo de uso de JSON.stringify() com localStorageNo caso em que você deseja armazenar um objeto criado por seu usuário e permitir que ele seja restaurado mesmo após o fechamento do navegador, o exemplo a seguir é um modelo para a aplicabilidade de JSON.stringify():

Aviso:
As funções não são um tipo de dados JSON válido, portanto, elas não funcionarão. Também alguns objetos como Date será uma string depois JSON.parse().

js// Criando um exemplo em JSON
var seção = {
  telas: [],
  estado: true,
};
session.screens.push({ nome: "telaA", largura: 450, altura: 250 });
session.screens.push({ nome: "telaB", largura: 650, altura: 350 });
session.screens.push({ nome: "telaC", largura: 750, altura: 120 });
session.screens.push({ nome: "telaD", largura: 250, altura: 60 });
session.screens.push({ nome: "telaE", largura: 390, altura: 120 });
session.screens.push({ nome: "telaF", largura: 1240, altura: 650 });

// Convertendo a string JSON em JSON.stringify()
// Salvando com localStorage no nome da sessão
localStorage.setItem("seção", JSON.stringify(seção));

// Exemplo de como transformar a String gerada por meio de:
// JSON.stringify() e salva em localStorage no objeto JSON novamente
var seçãoRestaurada = JSON.parse(localStorage.getItem("seção"));

// Agora, a variável seçãoRestaurada contém o objeto que foi salvo
// no localStorage
console.log(seçãoRestaurada);
EspecificaçõesSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyCompatibilidade em navegadoresVeja também
JSON.parse()\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackResumoO método JSON.stringify() converte valores em javascript para uma String JSON. Esses valores podem ser substituidos especificando a função replacer, ou incluindo somente as propriedades específicas, quando o array do replacer for especificado.SintaxeJSON.stringify(valor[, replacer[, espaço]])
Parâmetros
valor

O valor a ser convertido para uma string JSON.

replacer Optional

Uma função que altera o comportamento do processo de transformação em string, ou um array de objetos String e Number que servem como uma lista branca para selecionar as propriedades do objeto valor a ser incluído na string JSON. Se este valor for nulo ou não fornecido, todas as propriedades do objeto são incluídas na string JSON resultante.

espaço Optional

Um objeto String ou Number que é usado para inserir espaço em branco na saída da string JSON para propósito de legibilidade. Se isto for um Number, indica o número de caracteres espaço para usar como espaço em branco; este número é limitado em 10 se for maior que isso. Valores menores que 1 indicam que nenhum espaço deve ser usado. Se isto for uma String, a string (ou os primeiros 10 caracteres da string, se for maior que isso) é usado como espaço em branco. Se esse parâmetro não for fornecido (ou for null), nenhum espaço em branco é usado.

DescriçãoJSON.stringify() converte um valor para uma notação JSON que o representa:

Se o valor tiver um método toJSON(), é responsável por definir quais dados serão serializados.
Boolean, Number, and String os objetos são convertidos para os valores primitivos correspondentes durante a stringificação, de acordo com a semântica de conversão.
Se undefined, uma função, ou um symbol é encontrado durante a conversão é omitido (quando é encontrado em um objeto) ou censurado para null (quando é encontrado em um Array). JSON.stringify pode também somente retornar undefined ao passar valores puros como JSON.stringify(function(){}) ou JSON.stringify(undefined).
Todas as propriedades com chave de símbolo serão completamente ignoradas, mesmo quando usar a função replacer.
Propriedades não enumeráveis serão ignoradas.

jsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}' or '{"y":6,"x":5}'
JSON.stringify([new Number(1), new String("false"), new Boolean(false)]);
// '[1,"false",false]'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, function (k, v) {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// '{}'
O parâmetro replacer parameterO parâmetro replacer pode ser uma função ou uma matriz. Como função, são necessários dois parâmetros, a chave e os valores que estão sendo especificados. O objeto no qual a chave foi encontrada é fornecido como substituto desse parâmetro. Inicialmente, ele é chamado com uma chave vazia que representa o objeto que está sendo codificado e, em seguida, é chamado para cada propriedade no objeto ou matriz que está sendo codificada. Ele deve retornar o valor que deve ser adicionado à cadeia JSON, da seguinte maneira:

Se você retornar um Number, a string correspondente a esse número é usada como o valor da propriedade quando adicionada à sequência JSON.
If you return a String, that string is used as the property's value when adding it to the JSON string.
If you return a Boolean, "true" or "false" is used as the property's value, as appropriate, when adding it to the JSON string.
If you return any other object, the object is recursively stringified into the JSON string, calling the replacer function on each property, unless the object is a function, in which case nothing is added to the JSON string.
If you return undefined, the property is not included in the output JSON string.


**Nota:**Você não pode usar a função replacer para remover valoeres em uma array. Se você retornar undefined, null será usado no lugar.

Exemplo de uma função
jsfunction replacer(key, value) {
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

var foo = {
  fundação: "Mozilla",
  modelo: "caixa",
  semana: 45,
  transporte: "carro",
  mês: 7,
};
var jsonString = JSON.stringify(foo, replacer);

O resultado do JSON é: {"semana":45,"mês":7}.
Exemplo em uma array
Se replacer é usado em uma array, os valores da array indicam os nomes das propriedades no objeto, que devem ser incluídas na sequência JSON resultante.
jsJSON.stringify(foo, ["semana", "mês"]);
// '{"semana":45,"mês":7}', apenas mantém as propriedades "semana" e "mês"
O argumento spaceO argumento space O argumento pode ser usado para controlar o espaçamento na sequência final. Se for um número, os níveis sucessivos na stringficação serão recuados por esse número de caracteres de espaço (até 10). Se for uma sequência, os níveis sucessivos serão recuados por essa sequência (ou pelos dez primeiros caracteres).
jsJSON.stringify({ a: 2 }, null, " ");
// '{
//  "a": 2
// }'

O uso de um caractere de tabulação imita a aparência padrão de impressão pretty-print.
jsJSON.stringify({ um: 1, dois: 2 }, null, "\t");
// r:
// '{
//     "um": 1,
//     "dois": 2
// }'
Comportamento de toJSON()Se um objeto sendo stringificado tiver uma propriedade denominada toJSON() cujo valor é uma função, o método toJSON() personaliza o comportamento da stringificação JSON, em vez de o objeto ser serializado, o valor retornado pelo método toJSON() quando chamado será serializado. Por exemplo:
jsvar obj = {
  foo: "foo",
  toJSON: function () {
    return "bar";
  },
};
JSON.stringify(obj); // '"bar"'
JSON.stringify({ x: obj }); // '{"x":"bar"}'
Exemplo de uso de JSON.stringify() com localStorageNo caso em que você deseja armazenar um objeto criado por seu usuário e permitir que ele seja restaurado mesmo após o fechamento do navegador, o exemplo a seguir é um modelo para a aplicabilidade de JSON.stringify():

Aviso:
As funções não são um tipo de dados JSON válido, portanto, elas não funcionarão. Também alguns objetos como Date será uma string depois JSON.parse().

js// Criando um exemplo em JSON
var seção = {
  telas: [],
  estado: true,
};
session.screens.push({ nome: "telaA", largura: 450, altura: 250 });
session.screens.push({ nome: "telaB", largura: 650, altura: 350 });
session.screens.push({ nome: "telaC", largura: 750, altura: 120 });
session.screens.push({ nome: "telaD", largura: 250, altura: 60 });
session.screens.push({ nome: "telaE", largura: 390, altura: 120 });
session.screens.push({ nome: "telaF", largura: 1240, altura: 650 });

// Convertendo a string JSON em JSON.stringify()
// Salvando com localStorage no nome da sessão
localStorage.setItem("seção", JSON.stringify(seção));

// Exemplo de como transformar a String gerada por meio de:
// JSON.stringify() e salva em localStorage no objeto JSON novamente
var seçãoRestaurada = JSON.parse(localStorage.getItem("seção"));

// Agora, a variável seçãoRestaurada contém o objeto que foi salvo
// no localStorage
console.log(seçãoRestaurada);
EspecificaçõesSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyCompatibilidade em navegadoresVeja também
JSON.parse()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 8 de ago. de 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackResumoO método JSON.stringify() converte valores em javascript para uma String JSON. Esses valores podem ser substituidos especificando a função replacer, ou incluindo somente as propriedades específicas, quando o array do replacer for especificado.SintaxeJSON.stringify(valor[, replacer[, espaço]])
Parâmetros
valor

O valor a ser convertido para uma string JSON.

replacer Optional

Uma função que altera o comportamento do processo de transformação em string, ou um array de objetos String e Number que servem como uma lista branca para selecionar as propriedades do objeto valor a ser incluído na string JSON. Se este valor for nulo ou não fornecido, todas as propriedades do objeto são incluídas na string JSON resultante.

espaço Optional

Um objeto String ou Number que é usado para inserir espaço em branco na saída da string JSON para propósito de legibilidade. Se isto for um Number, indica o número de caracteres espaço para usar como espaço em branco; este número é limitado em 10 se for maior que isso. Valores menores que 1 indicam que nenhum espaço deve ser usado. Se isto for uma String, a string (ou os primeiros 10 caracteres da string, se for maior que isso) é usado como espaço em branco. Se esse parâmetro não for fornecido (ou for null), nenhum espaço em branco é usado.

DescriçãoJSON.stringify() converte um valor para uma notação JSON que o representa:

Se o valor tiver um método toJSON(), é responsável por definir quais dados serão serializados.
Boolean, Number, and String os objetos são convertidos para os valores primitivos correspondentes durante a stringificação, de acordo com a semântica de conversão.
Se undefined, uma função, ou um symbol é encontrado durante a conversão é omitido (quando é encontrado em um objeto) ou censurado para null (quando é encontrado em um Array). JSON.stringify pode também somente retornar undefined ao passar valores puros como JSON.stringify(function(){}) ou JSON.stringify(undefined).
Todas as propriedades com chave de símbolo serão completamente ignoradas, mesmo quando usar a função replacer.
Propriedades não enumeráveis serão ignoradas.

jsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}' or '{"y":6,"x":5}'
JSON.stringify([new Number(1), new String("false"), new Boolean(false)]);
// '[1,"false",false]'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, function (k, v) {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// '{}'
O parâmetro replacer parameterO parâmetro replacer pode ser uma função ou uma matriz. Como função, são necessários dois parâmetros, a chave e os valores que estão sendo especificados. O objeto no qual a chave foi encontrada é fornecido como substituto desse parâmetro. Inicialmente, ele é chamado com uma chave vazia que representa o objeto que está sendo codificado e, em seguida, é chamado para cada propriedade no objeto ou matriz que está sendo codificada. Ele deve retornar o valor que deve ser adicionado à cadeia JSON, da seguinte maneira:

Se você retornar um Number, a string correspondente a esse número é usada como o valor da propriedade quando adicionada à sequência JSON.
If you return a String, that string is used as the property's value when adding it to the JSON string.
If you return a Boolean, "true" or "false" is used as the property's value, as appropriate, when adding it to the JSON string.
If you return any other object, the object is recursively stringified into the JSON string, calling the replacer function on each property, unless the object is a function, in which case nothing is added to the JSON string.
If you return undefined, the property is not included in the output JSON string.


**Nota:**Você não pode usar a função replacer para remover valoeres em uma array. Se você retornar undefined, null será usado no lugar.

Exemplo de uma função
jsfunction replacer(key, value) {
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

var foo = {
  fundação: "Mozilla",
  modelo: "caixa",
  semana: 45,
  transporte: "carro",
  mês: 7,
};
var jsonString = JSON.stringify(foo, replacer);

O resultado do JSON é: {"semana":45,"mês":7}.
Exemplo em uma array
Se replacer é usado em uma array, os valores da array indicam os nomes das propriedades no objeto, que devem ser incluídas na sequência JSON resultante.
jsJSON.stringify(foo, ["semana", "mês"]);
// '{"semana":45,"mês":7}', apenas mantém as propriedades "semana" e "mês"
O argumento spaceO argumento space O argumento pode ser usado para controlar o espaçamento na sequência final. Se for um número, os níveis sucessivos na stringficação serão recuados por esse número de caracteres de espaço (até 10). Se for uma sequência, os níveis sucessivos serão recuados por essa sequência (ou pelos dez primeiros caracteres).
jsJSON.stringify({ a: 2 }, null, " ");
// '{
//  "a": 2
// }'

O uso de um caractere de tabulação imita a aparência padrão de impressão pretty-print.
jsJSON.stringify({ um: 1, dois: 2 }, null, "\t");
// r:
// '{
//     "um": 1,
//     "dois": 2
// }'
Comportamento de toJSON()Se um objeto sendo stringificado tiver uma propriedade denominada toJSON() cujo valor é uma função, o método toJSON() personaliza o comportamento da stringificação JSON, em vez de o objeto ser serializado, o valor retornado pelo método toJSON() quando chamado será serializado. Por exemplo:
jsvar obj = {
  foo: "foo",
  toJSON: function () {
    return "bar";
  },
};
JSON.stringify(obj); // '"bar"'
JSON.stringify({ x: obj }); // '{"x":"bar"}'
Exemplo de uso de JSON.stringify() com localStorageNo caso em que você deseja armazenar um objeto criado por seu usuário e permitir que ele seja restaurado mesmo após o fechamento do navegador, o exemplo a seguir é um modelo para a aplicabilidade de JSON.stringify():

Aviso:
As funções não são um tipo de dados JSON válido, portanto, elas não funcionarão. Também alguns objetos como Date será uma string depois JSON.parse().

js// Criando um exemplo em JSON
var seção = {
  telas: [],
  estado: true,
};
session.screens.push({ nome: "telaA", largura: 450, altura: 250 });
session.screens.push({ nome: "telaB", largura: 650, altura: 350 });
session.screens.push({ nome: "telaC", largura: 750, altura: 120 });
session.screens.push({ nome: "telaD", largura: 250, altura: 60 });
session.screens.push({ nome: "telaE", largura: 390, altura: 120 });
session.screens.push({ nome: "telaF", largura: 1240, altura: 650 });

// Convertendo a string JSON em JSON.stringify()
// Salvando com localStorage no nome da sessão
localStorage.setItem("seção", JSON.stringify(seção));

// Exemplo de como transformar a String gerada por meio de:
// JSON.stringify() e salva em localStorage no objeto JSON novamente
var seçãoRestaurada = JSON.parse(localStorage.getItem("seção"));

// Agora, a variável seçãoRestaurada contém o objeto que foi salvo
// no localStorage
console.log(seçãoRestaurada);
EspecificaçõesSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyCompatibilidade em navegadoresVeja também
JSON.parse()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 8 de ago. de 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackСводкаМетод JSON.stringify() возвращает JavaScript-значение, преобразованное в JSON-строку. Возможна замена значений, если как replacer передана функция, или включение только определённых свойств, если как replacer указан массив.СинтаксисJSON.stringify(value[, replacer[, space]])
Параметры
value

Значение, преобразуемое в строку JSON.

replacer Необязательный

Если является функцией, преобразует значения и свойства по ходу их преобразования в строку; если является массивом, определяет набор свойств, включаемых в объект в окончательной строке.
Подробное описание функции replacer даётся в статье Использование родного объекта JSON руководства по JavaScript.

space Необязательный

Делает результат красиво отформатированным (расставляя пробелы).

ОписаниеМетод JSON.stringify() преобразует значение в представляющую его нотацию JSON со следующими оговорками:

Порядок преобразования в строку свойств объектов, не являющихся массивами, не гарантируется. Не полагайтесь на порядок свойств во время преобразования.
Объекты Boolean, Number и String преобразуются в соответствующие примитивные значения, в соответствии с традиционным соглашением о семантике преобразований.
Значение undefined, функция или символ, встреченные во время преобразования, будут либо опущены (если они найдены в объекте), либо превращены в null (если они найдены в массиве).
Все свойства, имеющие ключ в виде символа, будут полностью проигнорированы, даже при использовании функции replacer.

jsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}' or '{"y":6,"x":5}'
JSON.stringify([new Number(1), new String("false"), new Boolean(false)]);
// '[1,"false",false]'

// Символы:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, function (k, v) {
  if (typeof k === "symbol") {
    return "символ";
  }
});
// '{}'
Параметр spaceПараметр space может использоваться для управления форматированием отступов в конечной строке. Если он числовой, каждый последующий уровень вложенности будет дополнен отступом из пробелов, количество которых соответствует уровню (вплоть до десятого уровня). Если он строковый, каждый последующий уровень вложенности будет предваряться этой строкой (или её первыми десятью символами).
jsJSON.stringify({ a: 2 }, null, " ");
// '{
//  "a": 2
// }'

Использование символа табуляции имитирует стандартное красивое форматирование:
jsJSON.stringify({ uno: 1, dos: 2 }, null, "\t");
// вернёт строку:
// '{
//   "uno": 1,
//   "dos": 2
// }'
Поведение метода toJSON()Если преобразуемый в строку объект имеет свойство с именем toJSON и значением свойства, установленным в функцию, то этот метод toJSON() изменит стандартное поведение преобразования в JSON: вместо преобразования объекта будет использоваться значение, возвращаемое методом toJSON(). Например:

Предупреждение:
Функции не являются допустимыми данными в JSON, так что они не будут работать. Кроме того, некоторые объекты, например, объект Date, станут строками после применения JSON.parse().

jsvar obj = {
  foo: "foo",
  toJSON: function () {
    return "bar";
  },
};
JSON.stringify(obj); // '"bar"'
JSON.stringify({ x: obj }); // '{"x":"bar"}'
Пример использования метода JSON.stringify() вместе с localStorageВ случае, если вы хотите сохранить объект таким образом, чтобы его можно было восстановить даже после закрытия браузера, имеет смысл воспользоваться следующим примером, демонстрирующим применение метода JSON.stringify():
js// Создаём некоторый объект
var session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "экранА", width: 450, height: 250 });
session.screens.push({ name: "экранБ", width: 650, height: 350 });
session.screens.push({ name: "экранВ", width: 750, height: 120 });
session.screens.push({ name: "экранГ", width: 250, height: 60 });
session.screens.push({ name: "экранД", width: 390, height: 120 });
session.screens.push({ name: "экранЕ", width: 1240, height: 650 });

// Преобразуем его в строку JSON с помощью метода JSON.stringify(),
// затем сохраняем его в localStorage под именем session
localStorage.setItem("session", JSON.stringify(session));

// Пример того, как можно преобразовать строку, полученную с помощью метода
// JSON.stringify() и сохранённую в localStorage обратно в объект
var restoredSession = JSON.parse(localStorage.getItem("session"));

// Переменная restoredSession содержит объект, который был сохранён
// в localStorage
console.log(restoredSession);
Пример использования параметра replacerjsvar foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, function (key, value) {
  if (typeof value === "string") {
    return undefined; // удаляем все строковые свойства
  }
  return value;
}); // '{"week":45,"month":7}'

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', сохранились только свойства week и month
СпецификацииSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyСовместимость с браузерамиСмотрите также
Использование родного объекта JSON
JSON.parse()\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackСводкаМетод JSON.stringify() возвращает JavaScript-значение, преобразованное в JSON-строку. Возможна замена значений, если как replacer передана функция, или включение только определённых свойств, если как replacer указан массив.СинтаксисJSON.stringify(value[, replacer[, space]])
Параметры
value

Значение, преобразуемое в строку JSON.

replacer Необязательный

Если является функцией, преобразует значения и свойства по ходу их преобразования в строку; если является массивом, определяет набор свойств, включаемых в объект в окончательной строке.
Подробное описание функции replacer даётся в статье Использование родного объекта JSON руководства по JavaScript.

space Необязательный

Делает результат красиво отформатированным (расставляя пробелы).

ОписаниеМетод JSON.stringify() преобразует значение в представляющую его нотацию JSON со следующими оговорками:

Порядок преобразования в строку свойств объектов, не являющихся массивами, не гарантируется. Не полагайтесь на порядок свойств во время преобразования.
Объекты Boolean, Number и String преобразуются в соответствующие примитивные значения, в соответствии с традиционным соглашением о семантике преобразований.
Значение undefined, функция или символ, встреченные во время преобразования, будут либо опущены (если они найдены в объекте), либо превращены в null (если они найдены в массиве).
Все свойства, имеющие ключ в виде символа, будут полностью проигнорированы, даже при использовании функции replacer.

jsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}' or '{"y":6,"x":5}'
JSON.stringify([new Number(1), new String("false"), new Boolean(false)]);
// '[1,"false",false]'

// Символы:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, function (k, v) {
  if (typeof k === "symbol") {
    return "символ";
  }
});
// '{}'
Параметр spaceПараметр space может использоваться для управления форматированием отступов в конечной строке. Если он числовой, каждый последующий уровень вложенности будет дополнен отступом из пробелов, количество которых соответствует уровню (вплоть до десятого уровня). Если он строковый, каждый последующий уровень вложенности будет предваряться этой строкой (или её первыми десятью символами).
jsJSON.stringify({ a: 2 }, null, " ");
// '{
//  "a": 2
// }'

Использование символа табуляции имитирует стандартное красивое форматирование:
jsJSON.stringify({ uno: 1, dos: 2 }, null, "\t");
// вернёт строку:
// '{
//   "uno": 1,
//   "dos": 2
// }'
Поведение метода toJSON()Если преобразуемый в строку объект имеет свойство с именем toJSON и значением свойства, установленным в функцию, то этот метод toJSON() изменит стандартное поведение преобразования в JSON: вместо преобразования объекта будет использоваться значение, возвращаемое методом toJSON(). Например:

Предупреждение:
Функции не являются допустимыми данными в JSON, так что они не будут работать. Кроме того, некоторые объекты, например, объект Date, станут строками после применения JSON.parse().

jsvar obj = {
  foo: "foo",
  toJSON: function () {
    return "bar";
  },
};
JSON.stringify(obj); // '"bar"'
JSON.stringify({ x: obj }); // '{"x":"bar"}'
Пример использования метода JSON.stringify() вместе с localStorageВ случае, если вы хотите сохранить объект таким образом, чтобы его можно было восстановить даже после закрытия браузера, имеет смысл воспользоваться следующим примером, демонстрирующим применение метода JSON.stringify():
js// Создаём некоторый объект
var session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "экранА", width: 450, height: 250 });
session.screens.push({ name: "экранБ", width: 650, height: 350 });
session.screens.push({ name: "экранВ", width: 750, height: 120 });
session.screens.push({ name: "экранГ", width: 250, height: 60 });
session.screens.push({ name: "экранД", width: 390, height: 120 });
session.screens.push({ name: "экранЕ", width: 1240, height: 650 });

// Преобразуем его в строку JSON с помощью метода JSON.stringify(),
// затем сохраняем его в localStorage под именем session
localStorage.setItem("session", JSON.stringify(session));

// Пример того, как можно преобразовать строку, полученную с помощью метода
// JSON.stringify() и сохранённую в localStorage обратно в объект
var restoredSession = JSON.parse(localStorage.getItem("session"));

// Переменная restoredSession содержит объект, который был сохранён
// в localStorage
console.log(restoredSession);
Пример использования параметра replacerjsvar foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, function (key, value) {
  if (typeof value === "string") {
    return undefined; // удаляем все строковые свойства
  }
  return value;
}); // '{"week":45,"month":7}'

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', сохранились только свойства week и month
СпецификацииSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyСовместимость с браузерамиСмотрите также
Использование родного объекта JSON
JSON.parse()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 17 дек. 2024 г. by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackСводкаМетод JSON.stringify() возвращает JavaScript-значение, преобразованное в JSON-строку. Возможна замена значений, если как replacer передана функция, или включение только определённых свойств, если как replacer указан массив.СинтаксисJSON.stringify(value[, replacer[, space]])
Параметры
value

Значение, преобразуемое в строку JSON.

replacer Необязательный

Если является функцией, преобразует значения и свойства по ходу их преобразования в строку; если является массивом, определяет набор свойств, включаемых в объект в окончательной строке.
Подробное описание функции replacer даётся в статье Использование родного объекта JSON руководства по JavaScript.

space Необязательный

Делает результат красиво отформатированным (расставляя пробелы).

ОписаниеМетод JSON.stringify() преобразует значение в представляющую его нотацию JSON со следующими оговорками:

Порядок преобразования в строку свойств объектов, не являющихся массивами, не гарантируется. Не полагайтесь на порядок свойств во время преобразования.
Объекты Boolean, Number и String преобразуются в соответствующие примитивные значения, в соответствии с традиционным соглашением о семантике преобразований.
Значение undefined, функция или символ, встреченные во время преобразования, будут либо опущены (если они найдены в объекте), либо превращены в null (если они найдены в массиве).
Все свойства, имеющие ключ в виде символа, будут полностью проигнорированы, даже при использовании функции replacer.

jsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}' or '{"y":6,"x":5}'
JSON.stringify([new Number(1), new String("false"), new Boolean(false)]);
// '[1,"false",false]'

// Символы:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, function (k, v) {
  if (typeof k === "symbol") {
    return "символ";
  }
});
// '{}'
Параметр spaceПараметр space может использоваться для управления форматированием отступов в конечной строке. Если он числовой, каждый последующий уровень вложенности будет дополнен отступом из пробелов, количество которых соответствует уровню (вплоть до десятого уровня). Если он строковый, каждый последующий уровень вложенности будет предваряться этой строкой (или её первыми десятью символами).
jsJSON.stringify({ a: 2 }, null, " ");
// '{
//  "a": 2
// }'

Использование символа табуляции имитирует стандартное красивое форматирование:
jsJSON.stringify({ uno: 1, dos: 2 }, null, "\t");
// вернёт строку:
// '{
//   "uno": 1,
//   "dos": 2
// }'
Поведение метода toJSON()Если преобразуемый в строку объект имеет свойство с именем toJSON и значением свойства, установленным в функцию, то этот метод toJSON() изменит стандартное поведение преобразования в JSON: вместо преобразования объекта будет использоваться значение, возвращаемое методом toJSON(). Например:

Предупреждение:
Функции не являются допустимыми данными в JSON, так что они не будут работать. Кроме того, некоторые объекты, например, объект Date, станут строками после применения JSON.parse().

jsvar obj = {
  foo: "foo",
  toJSON: function () {
    return "bar";
  },
};
JSON.stringify(obj); // '"bar"'
JSON.stringify({ x: obj }); // '{"x":"bar"}'
Пример использования метода JSON.stringify() вместе с localStorageВ случае, если вы хотите сохранить объект таким образом, чтобы его можно было восстановить даже после закрытия браузера, имеет смысл воспользоваться следующим примером, демонстрирующим применение метода JSON.stringify():
js// Создаём некоторый объект
var session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "экранА", width: 450, height: 250 });
session.screens.push({ name: "экранБ", width: 650, height: 350 });
session.screens.push({ name: "экранВ", width: 750, height: 120 });
session.screens.push({ name: "экранГ", width: 250, height: 60 });
session.screens.push({ name: "экранД", width: 390, height: 120 });
session.screens.push({ name: "экранЕ", width: 1240, height: 650 });

// Преобразуем его в строку JSON с помощью метода JSON.stringify(),
// затем сохраняем его в localStorage под именем session
localStorage.setItem("session", JSON.stringify(session));

// Пример того, как можно преобразовать строку, полученную с помощью метода
// JSON.stringify() и сохранённую в localStorage обратно в объект
var restoredSession = JSON.parse(localStorage.getItem("session"));

// Переменная restoredSession содержит объект, который был сохранён
// в localStorage
console.log(restoredSession);
Пример использования параметра replacerjsvar foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, function (key, value) {
  if (typeof value === "string") {
    return undefined; // удаляем все строковые свойства
  }
  return value;
}); // '{"week":45,"month":7}'

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', сохранились только свойства week и month
СпецификацииSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyСовместимость с браузерамиСмотрите также
Использование родного объекта JSON
JSON.parse()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 17 дек. 2024 г. by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackJSON.stringify() 方法将一个 JavaScript 对象或值转换为 JSON 字符串，如果指定了一个 replacer 函数，则可以选择性地替换值，或者指定的 replacer 是数组，则可选择性地仅包含数组指定的属性。尝试一下
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
语法JSON.stringify(value[, replacer [, space]])
参数
value

将要序列化成 一个 JSON 字符串的值。

replacer 可选

如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为 null 或者未提供，则对象所有的属性都会被序列化。

space 可选

指定缩进用的空白字符串，用于美化输出（pretty-print）；如果参数是个数字，它代表有多少的空格；上限为 10。该值若小于 1，则意味着没有空格；如果该参数为字符串（当字符串长度超过 10 个字母，取其前 10 个字母），该字符串将被作为空格；如果该参数没有提供（或者为 null），将没有空格。

返回值一个表示给定值的 JSON 字符串。异常
当在循环引用时会抛出异常TypeError ("cyclic object value")（循环对象值）
当尝试去转换 BigInt 类型的值会抛出TypeError ("BigInt value can't be serialized in JSON")（BigInt 值不能 JSON 序列化）.
描述JSON.stringify()将值转换为相应的 JSON 格式：

转换值如果有 toJSON() 方法，该方法定义什么值将被序列化。
非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中。
布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值。
undefined、任意的函数以及 symbol 值，在序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被转换成 null（出现在数组中时）。函数、undefined 被单独转换时，会返回 undefined，如JSON.stringify(function(){}) or JSON.stringify(undefined).
对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误。
所有以 symbol 为属性键的属性都会被完全忽略掉，即便 replacer 参数中强制指定包含了它们。
Date 日期调用了 toJSON() 将其转换为了 string 字符串（同 Date.toISOString()），因此会被当做字符串处理。
NaN 和 Infinity 格式的数值及 null 都会被当做 null。
其他类型的对象，包括 Map/Set/WeakMap/WeakSet，仅会序列化可枚举的属性。
示例使用 JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify({ x: 5, y: 6 });
// "{"x":5,"y":6}"

JSON.stringify([new Number(1), new String("false"), new Boolean(false)]);
// '[1,"false",false]'

JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'

JSON.stringify([undefined, Object, Symbol("")]);
// '[null,null,null]'

JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'

JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'

JSON.stringify({ [Symbol.for("foo")]: "foo" }, function (k, v) {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});

// undefined

// 不可枚举的属性默认会被忽略：
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);

// "{"y":"y"}"
replacer 参数replacer 参数可以是一个函数或者一个数组。作为函数，它有两个参数，键（key）和值（value），它们都会被序列化。
在开始时，replacer 函数会被传入一个空字符串作为 key 值，代表着要被 stringify 的这个对象。随后每个对象或数组上的属性会被依次传入。
函数应当返回 JSON 字符串中的 value, 如下所示：

如果返回一个 Number, 转换成相应的字符串作为属性值被添加入 JSON 字符串。
如果返回一个 String, 该字符串作为属性值被添加入 JSON 字符串。
如果返回一个 Boolean, "true" 或者 "false" 作为属性值被添加入 JSON 字符串。
如果返回任何其他对象，该对象递归地序列化成 JSON 字符串，对每个属性调用 replacer 方法。除非该对象是一个函数，这种情况将不会被序列化成 JSON 字符串。
如果返回 undefined，该属性值不会在 JSON 字符串中输出。

注意： 不能用 replacer 方法，从数组中移除值（values），如若返回 undefined 或者一个函数，将会被 null 取代。
示例 (function)
function replacer(key, value) {
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

var foo = {foundation: "Mozilla", model: "box", week: 45, transport: "car", month: 7};
var jsonString = JSON.stringify(foo, replacer);

JSON 序列化结果为 {"week":45,"month":7}.
示例 (array)
如果 replacer 是一个数组，数组的值代表将被序列化成 JSON 字符串的属性名。
JSON.stringify(foo, ['week', 'month']);
// '{"week":45,"month":7}', 只保留“week”和“month”属性值。
space 参数space 参数用来控制结果字符串里面的间距。如果是一个数字，则在字符串化时每一级别会比上一级别缩进多这个数字值的空格（最多 10 个空格）；如果是一个字符串，则每一级别会比上一级别多缩进该字符串（或该字符串的前 10 个字符）。
jsJSON.stringify({ a: 2 }, null, " "); // '{\n "a": 2\n}'

使用制表符（\t）来缩进：
jsJSON.stringify({ uno: 1, dos: 2 }, null, "\t");
// '{            \
//     "uno": 1, \
//     "dos": 2  \
// }'
toJSON 方法如果一个被序列化的对象拥有 toJSON 方法，那么该 toJSON 方法就会覆盖该对象默认的序列化行为：不是该对象被序列化，而是调用 toJSON 方法后的返回值会被序列化，例如：
jsvar obj = {
  foo: "foo",
  toJSON: function () {
    return "bar";
  },
};
JSON.stringify(obj); // '"bar"'
JSON.stringify({ x: obj }); // '{"x":"bar"}'
关于序列化循环引用的问题由于 JSON 格式不支持对象引用（尽管有一个 IETF 草案存在），如果尝试编码带有循环引用的对象，将会抛出 TypeError 异常。
jsconst circularReference = {};
circularReference.myself = circularReference;

// 序列化循环引用会抛出 "TypeError: cyclic object value" 错误
JSON.stringify(circularReference);

要序列化循环引用，你可以使用支持循环引用的库（例如 Douglas Crockford 的 cycle.js），或者自己实现一个解决方案，这需要找到循环引用，并用可序列化的值替换（或移除）它们。
如果你在使用 JSON.stringify() 来深拷贝一个对象，你可能想要使用 structuredClone()，它支持循环引用。JavaScript 引擎的二进制序列化 API，比如 v8.serialize()，也支持循环引用。JSON.stringify用作 JavaScript注意 JSON 不是 JavaScript 严格意义上的子集，在 JSON 中不需要省略两条终线（Line separator 和 Paragraph separator），但在 JavaScript 中需要被省略。因此，如果 JSON 被用作 JSONP 时，下面方法可以使用：
function jsFriendlyJSONStringify (s) {
    return JSON.stringify(s).
        replace(/\u2028/g, '\\u2028').
        replace(/\u2029/g, '\\u2029');
}

var s = {
    a: String.fromCharCode(0x2028),
    b: String.fromCharCode(0x2029)
};
try {
    eval('(' + JSON.stringify(s) + ')');
} catch (e) {
    console.log(e); // "SyntaxError: unterminated string literal"
}

// No need for a catch
eval('(' + jsFriendlyJSONStringify(s) + ')');

// console.log in Firefox unescapes the Unicode if
//   logged to console, so we use alert
alert(jsFriendlyJSONStringify(s)); // {"a":"\u2028","b":"\u2029"}
使用 JSON.stringify 结合 localStorage 的例子一些时候，你想存储用户创建的一个对象，并且，即使在浏览器被关闭后仍能恢复该对象。下面的例子是 JSON.stringify 适用于这种情形的一个样板：
js// 创建一个示例数据
var session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// 使用 JSON.stringify 转换为 JSON 字符串
// 然后使用 localStorage 保存在 session 名称里
localStorage.setItem("session", JSON.stringify(session));

// 然后是如何转换通过 JSON.stringify 生成的字符串，该字符串以 JSON 格式保存在 localStorage 里
var restoredSession = JSON.parse(localStorage.getItem("session"));

// 现在 restoredSession 包含了保存在 localStorage 里的对象
console.log(restoredSession);
规范SpecificationECMAScript® 2026 Language Specification # sec-json.stringify浏览器兼容性参见
core-js 中对现代 JSON.stringify 行为（符号和良好格式的 unicode）的 polyfill
JSON.parse()\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackJSON.stringify() 方法将一个 JavaScript 对象或值转换为 JSON 字符串，如果指定了一个 replacer 函数，则可以选择性地替换值，或者指定的 replacer 是数组，则可选择性地仅包含数组指定的属性。尝试一下
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
语法JSON.stringify(value[, replacer [, space]])
参数
value

将要序列化成 一个 JSON 字符串的值。

replacer 可选

如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为 null 或者未提供，则对象所有的属性都会被序列化。

space 可选

指定缩进用的空白字符串，用于美化输出（pretty-print）；如果参数是个数字，它代表有多少的空格；上限为 10。该值若小于 1，则意味着没有空格；如果该参数为字符串（当字符串长度超过 10 个字母，取其前 10 个字母），该字符串将被作为空格；如果该参数没有提供（或者为 null），将没有空格。

返回值一个表示给定值的 JSON 字符串。异常
当在循环引用时会抛出异常TypeError ("cyclic object value")（循环对象值）
当尝试去转换 BigInt 类型的值会抛出TypeError ("BigInt value can't be serialized in JSON")（BigInt 值不能 JSON 序列化）.
描述JSON.stringify()将值转换为相应的 JSON 格式：

转换值如果有 toJSON() 方法，该方法定义什么值将被序列化。
非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中。
布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值。
undefined、任意的函数以及 symbol 值，在序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被转换成 null（出现在数组中时）。函数、undefined 被单独转换时，会返回 undefined，如JSON.stringify(function(){}) or JSON.stringify(undefined).
对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误。
所有以 symbol 为属性键的属性都会被完全忽略掉，即便 replacer 参数中强制指定包含了它们。
Date 日期调用了 toJSON() 将其转换为了 string 字符串（同 Date.toISOString()），因此会被当做字符串处理。
NaN 和 Infinity 格式的数值及 null 都会被当做 null。
其他类型的对象，包括 Map/Set/WeakMap/WeakSet，仅会序列化可枚举的属性。
示例使用 JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify({ x: 5, y: 6 });
// "{"x":5,"y":6}"

JSON.stringify([new Number(1), new String("false"), new Boolean(false)]);
// '[1,"false",false]'

JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'

JSON.stringify([undefined, Object, Symbol("")]);
// '[null,null,null]'

JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'

JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'

JSON.stringify({ [Symbol.for("foo")]: "foo" }, function (k, v) {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});

// undefined

// 不可枚举的属性默认会被忽略：
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);

// "{"y":"y"}"
replacer 参数replacer 参数可以是一个函数或者一个数组。作为函数，它有两个参数，键（key）和值（value），它们都会被序列化。
在开始时，replacer 函数会被传入一个空字符串作为 key 值，代表着要被 stringify 的这个对象。随后每个对象或数组上的属性会被依次传入。
函数应当返回 JSON 字符串中的 value, 如下所示：

如果返回一个 Number, 转换成相应的字符串作为属性值被添加入 JSON 字符串。
如果返回一个 String, 该字符串作为属性值被添加入 JSON 字符串。
如果返回一个 Boolean, "true" 或者 "false" 作为属性值被添加入 JSON 字符串。
如果返回任何其他对象，该对象递归地序列化成 JSON 字符串，对每个属性调用 replacer 方法。除非该对象是一个函数，这种情况将不会被序列化成 JSON 字符串。
如果返回 undefined，该属性值不会在 JSON 字符串中输出。

注意： 不能用 replacer 方法，从数组中移除值（values），如若返回 undefined 或者一个函数，将会被 null 取代。
示例 (function)
function replacer(key, value) {
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

var foo = {foundation: "Mozilla", model: "box", week: 45, transport: "car", month: 7};
var jsonString = JSON.stringify(foo, replacer);

JSON 序列化结果为 {"week":45,"month":7}.
示例 (array)
如果 replacer 是一个数组，数组的值代表将被序列化成 JSON 字符串的属性名。
JSON.stringify(foo, ['week', 'month']);
// '{"week":45,"month":7}', 只保留“week”和“month”属性值。
space 参数space 参数用来控制结果字符串里面的间距。如果是一个数字，则在字符串化时每一级别会比上一级别缩进多这个数字值的空格（最多 10 个空格）；如果是一个字符串，则每一级别会比上一级别多缩进该字符串（或该字符串的前 10 个字符）。
jsJSON.stringify({ a: 2 }, null, " "); // '{\n "a": 2\n}'

使用制表符（\t）来缩进：
jsJSON.stringify({ uno: 1, dos: 2 }, null, "\t");
// '{            \
//     "uno": 1, \
//     "dos": 2  \
// }'
toJSON 方法如果一个被序列化的对象拥有 toJSON 方法，那么该 toJSON 方法就会覆盖该对象默认的序列化行为：不是该对象被序列化，而是调用 toJSON 方法后的返回值会被序列化，例如：
jsvar obj = {
  foo: "foo",
  toJSON: function () {
    return "bar";
  },
};
JSON.stringify(obj); // '"bar"'
JSON.stringify({ x: obj }); // '{"x":"bar"}'
关于序列化循环引用的问题由于 JSON 格式不支持对象引用（尽管有一个 IETF 草案存在），如果尝试编码带有循环引用的对象，将会抛出 TypeError 异常。
jsconst circularReference = {};
circularReference.myself = circularReference;

// 序列化循环引用会抛出 "TypeError: cyclic object value" 错误
JSON.stringify(circularReference);

要序列化循环引用，你可以使用支持循环引用的库（例如 Douglas Crockford 的 cycle.js），或者自己实现一个解决方案，这需要找到循环引用，并用可序列化的值替换（或移除）它们。
如果你在使用 JSON.stringify() 来深拷贝一个对象，你可能想要使用 structuredClone()，它支持循环引用。JavaScript 引擎的二进制序列化 API，比如 v8.serialize()，也支持循环引用。JSON.stringify用作 JavaScript注意 JSON 不是 JavaScript 严格意义上的子集，在 JSON 中不需要省略两条终线（Line separator 和 Paragraph separator），但在 JavaScript 中需要被省略。因此，如果 JSON 被用作 JSONP 时，下面方法可以使用：
function jsFriendlyJSONStringify (s) {
    return JSON.stringify(s).
        replace(/\u2028/g, '\\u2028').
        replace(/\u2029/g, '\\u2029');
}

var s = {
    a: String.fromCharCode(0x2028),
    b: String.fromCharCode(0x2029)
};
try {
    eval('(' + JSON.stringify(s) + ')');
} catch (e) {
    console.log(e); // "SyntaxError: unterminated string literal"
}

// No need for a catch
eval('(' + jsFriendlyJSONStringify(s) + ')');

// console.log in Firefox unescapes the Unicode if
//   logged to console, so we use alert
alert(jsFriendlyJSONStringify(s)); // {"a":"\u2028","b":"\u2029"}
使用 JSON.stringify 结合 localStorage 的例子一些时候，你想存储用户创建的一个对象，并且，即使在浏览器被关闭后仍能恢复该对象。下面的例子是 JSON.stringify 适用于这种情形的一个样板：
js// 创建一个示例数据
var session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// 使用 JSON.stringify 转换为 JSON 字符串
// 然后使用 localStorage 保存在 session 名称里
localStorage.setItem("session", JSON.stringify(session));

// 然后是如何转换通过 JSON.stringify 生成的字符串，该字符串以 JSON 格式保存在 localStorage 里
var restoredSession = JSON.parse(localStorage.getItem("session"));

// 现在 restoredSession 包含了保存在 localStorage 里的对象
console.log(restoredSession);
规范SpecificationECMAScript® 2026 Language Specification # sec-json.stringify浏览器兼容性参见
core-js 中对现代 JSON.stringify 行为（符号和良好格式的 unicode）的 polyfill
JSON.parse()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025年2月12日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackJSON.stringify() 方法将一个 JavaScript 对象或值转换为 JSON 字符串，如果指定了一个 replacer 函数，则可以选择性地替换值，或者指定的 replacer 是数组，则可选择性地仅包含数组指定的属性。尝试一下
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
语法JSON.stringify(value[, replacer [, space]])
参数
value

将要序列化成 一个 JSON 字符串的值。

replacer 可选

如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为 null 或者未提供，则对象所有的属性都会被序列化。

space 可选

指定缩进用的空白字符串，用于美化输出（pretty-print）；如果参数是个数字，它代表有多少的空格；上限为 10。该值若小于 1，则意味着没有空格；如果该参数为字符串（当字符串长度超过 10 个字母，取其前 10 个字母），该字符串将被作为空格；如果该参数没有提供（或者为 null），将没有空格。

返回值一个表示给定值的 JSON 字符串。异常
当在循环引用时会抛出异常TypeError ("cyclic object value")（循环对象值）
当尝试去转换 BigInt 类型的值会抛出TypeError ("BigInt value can't be serialized in JSON")（BigInt 值不能 JSON 序列化）.
描述JSON.stringify()将值转换为相应的 JSON 格式：

转换值如果有 toJSON() 方法，该方法定义什么值将被序列化。
非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中。
布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值。
undefined、任意的函数以及 symbol 值，在序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被转换成 null（出现在数组中时）。函数、undefined 被单独转换时，会返回 undefined，如JSON.stringify(function(){}) or JSON.stringify(undefined).
对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误。
所有以 symbol 为属性键的属性都会被完全忽略掉，即便 replacer 参数中强制指定包含了它们。
Date 日期调用了 toJSON() 将其转换为了 string 字符串（同 Date.toISOString()），因此会被当做字符串处理。
NaN 和 Infinity 格式的数值及 null 都会被当做 null。
其他类型的对象，包括 Map/Set/WeakMap/WeakSet，仅会序列化可枚举的属性。
示例使用 JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify({ x: 5, y: 6 });
// "{"x":5,"y":6}"

JSON.stringify([new Number(1), new String("false"), new Boolean(false)]);
// '[1,"false",false]'

JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'

JSON.stringify([undefined, Object, Symbol("")]);
// '[null,null,null]'

JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'

JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'

JSON.stringify({ [Symbol.for("foo")]: "foo" }, function (k, v) {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});

// undefined

// 不可枚举的属性默认会被忽略：
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);

// "{"y":"y"}"
replacer 参数replacer 参数可以是一个函数或者一个数组。作为函数，它有两个参数，键（key）和值（value），它们都会被序列化。
在开始时，replacer 函数会被传入一个空字符串作为 key 值，代表着要被 stringify 的这个对象。随后每个对象或数组上的属性会被依次传入。
函数应当返回 JSON 字符串中的 value, 如下所示：

如果返回一个 Number, 转换成相应的字符串作为属性值被添加入 JSON 字符串。
如果返回一个 String, 该字符串作为属性值被添加入 JSON 字符串。
如果返回一个 Boolean, "true" 或者 "false" 作为属性值被添加入 JSON 字符串。
如果返回任何其他对象，该对象递归地序列化成 JSON 字符串，对每个属性调用 replacer 方法。除非该对象是一个函数，这种情况将不会被序列化成 JSON 字符串。
如果返回 undefined，该属性值不会在 JSON 字符串中输出。

注意： 不能用 replacer 方法，从数组中移除值（values），如若返回 undefined 或者一个函数，将会被 null 取代。
示例 (function)
function replacer(key, value) {
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

var foo = {foundation: "Mozilla", model: "box", week: 45, transport: "car", month: 7};
var jsonString = JSON.stringify(foo, replacer);

JSON 序列化结果为 {"week":45,"month":7}.
示例 (array)
如果 replacer 是一个数组，数组的值代表将被序列化成 JSON 字符串的属性名。
JSON.stringify(foo, ['week', 'month']);
// '{"week":45,"month":7}', 只保留“week”和“month”属性值。
space 参数space 参数用来控制结果字符串里面的间距。如果是一个数字，则在字符串化时每一级别会比上一级别缩进多这个数字值的空格（最多 10 个空格）；如果是一个字符串，则每一级别会比上一级别多缩进该字符串（或该字符串的前 10 个字符）。
jsJSON.stringify({ a: 2 }, null, " "); // '{\n "a": 2\n}'

使用制表符（\t）来缩进：
jsJSON.stringify({ uno: 1, dos: 2 }, null, "\t");
// '{            \
//     "uno": 1, \
//     "dos": 2  \
// }'
toJSON 方法如果一个被序列化的对象拥有 toJSON 方法，那么该 toJSON 方法就会覆盖该对象默认的序列化行为：不是该对象被序列化，而是调用 toJSON 方法后的返回值会被序列化，例如：
jsvar obj = {
  foo: "foo",
  toJSON: function () {
    return "bar";
  },
};
JSON.stringify(obj); // '"bar"'
JSON.stringify({ x: obj }); // '{"x":"bar"}'
关于序列化循环引用的问题由于 JSON 格式不支持对象引用（尽管有一个 IETF 草案存在），如果尝试编码带有循环引用的对象，将会抛出 TypeError 异常。
jsconst circularReference = {};
circularReference.myself = circularReference;

// 序列化循环引用会抛出 "TypeError: cyclic object value" 错误
JSON.stringify(circularReference);

要序列化循环引用，你可以使用支持循环引用的库（例如 Douglas Crockford 的 cycle.js），或者自己实现一个解决方案，这需要找到循环引用，并用可序列化的值替换（或移除）它们。
如果你在使用 JSON.stringify() 来深拷贝一个对象，你可能想要使用 structuredClone()，它支持循环引用。JavaScript 引擎的二进制序列化 API，比如 v8.serialize()，也支持循环引用。JSON.stringify用作 JavaScript注意 JSON 不是 JavaScript 严格意义上的子集，在 JSON 中不需要省略两条终线（Line separator 和 Paragraph separator），但在 JavaScript 中需要被省略。因此，如果 JSON 被用作 JSONP 时，下面方法可以使用：
function jsFriendlyJSONStringify (s) {
    return JSON.stringify(s).
        replace(/\u2028/g, '\\u2028').
        replace(/\u2029/g, '\\u2029');
}

var s = {
    a: String.fromCharCode(0x2028),
    b: String.fromCharCode(0x2029)
};
try {
    eval('(' + JSON.stringify(s) + ')');
} catch (e) {
    console.log(e); // "SyntaxError: unterminated string literal"
}

// No need for a catch
eval('(' + jsFriendlyJSONStringify(s) + ')');

// console.log in Firefox unescapes the Unicode if
//   logged to console, so we use alert
alert(jsFriendlyJSONStringify(s)); // {"a":"\u2028","b":"\u2029"}
使用 JSON.stringify 结合 localStorage 的例子一些时候，你想存储用户创建的一个对象，并且，即使在浏览器被关闭后仍能恢复该对象。下面的例子是 JSON.stringify 适用于这种情形的一个样板：
js// 创建一个示例数据
var session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// 使用 JSON.stringify 转换为 JSON 字符串
// 然后使用 localStorage 保存在 session 名称里
localStorage.setItem("session", JSON.stringify(session));

// 然后是如何转换通过 JSON.stringify 生成的字符串，该字符串以 JSON 格式保存在 localStorage 里
var restoredSession = JSON.parse(localStorage.getItem("session"));

// 现在 restoredSession 包含了保存在 localStorage 里的对象
console.log(restoredSession);
规范SpecificationECMAScript® 2026 Language Specification # sec-json.stringify浏览器兼容性参见
core-js 中对现代 JSON.stringify 行为（符号和良好格式的 unicode）的 polyfill
JSON.parse()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025年2月12日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJSON.isRawJSON()Limited availabilityThis feature is not Baseline because it does not work in some of the most widely-used browsers.Learn moreSee full compatibilityReport feedbackThe JSON.isRawJSON() static method tests whether a value is an object returned by JSON.rawJSON().SyntaxjsJSON.isRawJSON(value)
Parameters
value

The value to test.

Return valuetrue if value is created by JSON.rawJSON(); otherwise, false.Description"Raw JSON" objects, when serialized to JSON, are treated as if they are already a piece of JSON. Furthermore, because of the way JSON.rawJSON() works, the raw JSON is guaranteed to be syntactically valid JSON. For more information on the shape and behavior of raw JSON objects, see JSON.rawJSON(). This method exists to allow other serialization libraries to implement similar behavior to JSON.stringify() for raw JSON objects.ExamplesUsing JSON.isRawJSON()The following example demonstrates how to use JSON.isRawJSON() to test whether an object was returned by JSON.rawJSON(). It implements a custom serializer that serializes data to a YAML-like format.
jsfunction mySerializer(value, indent = "") {
  if (typeof value !== "object" || value === null) {
    return JSON.stringify(value);
  }
  if (JSON.isRawJSON(value)) {
    return value.rawJSON;
  }
  const subIndent = `${indent}  `;
  if (Array.isArray(value)) {
    return `- ${value.map((v) => mySerializer(v, subIndent)).join(`\n${indent}- `)}`;
  }
  return Object.entries(value)
    .map(([key, value]) => {
      const subValue = mySerializer(value, subIndent);
      if (subValue.includes("\n")) {
        return `${key}:\n${subIndent}${subValue}`;
      }
      return `${key}: ${subValue}`;
    })
    .join(`\n${indent}`);
}

console.log(
  mySerializer({
    name: "Josh",
    userId: JSON.rawJSON("12345678901234567890"),
    friends: [
      { name: "Alice", userId: JSON.rawJSON("9876543210987654321") },
      { name: "Bob", userId: JSON.rawJSON("56789012345678901234") },
    ],
  }),
);

// name: "Josh"
// userId: 12345678901234567890
// friends:
//   - name: "Alice"
//     userId: 9876543210987654321
//   - name: "Bob"
//     userId: 56789012345678901234

If in the above example, the userId values were not created by JSON.rawJSON(), but passed as numbers directly, then we will get loss of precision upfront because of JS floating point precision limitations.
jsconsole.log(
  mySerializer({
    name: "Josh",
    userId: 12345678901234567890,
    friends: [
      { name: "Alice", userId: 9876543210987654321 },
      { name: "Bob", userId: 56789012345678901234 },
    ],
  }),
);

// name: "Josh"
// userId: 12345678901234567000
// friends:
//   - name: "Alice"
//     userId: 9876543210987655000
//   - name: "Bob"
//     userId: 56789012345678900000
SpecificationsSpecificationJSON.parse source text access # sec-json.israwjsonBrowser compatibilitySee also
Polyfill of JSON.isRawJSON in core-js
JSON
JSON.stringify()
JSON.rawJSON()\n\nJSON.isRawJSON()Limited availabilityThis feature is not Baseline because it does not work in some of the most widely-used browsers.Learn moreSee full compatibilityReport feedbackThe JSON.isRawJSON() static method tests whether a value is an object returned by JSON.rawJSON().SyntaxjsJSON.isRawJSON(value)
Parameters
value

The value to test.

Return valuetrue if value is created by JSON.rawJSON(); otherwise, false.Description"Raw JSON" objects, when serialized to JSON, are treated as if they are already a piece of JSON. Furthermore, because of the way JSON.rawJSON() works, the raw JSON is guaranteed to be syntactically valid JSON. For more information on the shape and behavior of raw JSON objects, see JSON.rawJSON(). This method exists to allow other serialization libraries to implement similar behavior to JSON.stringify() for raw JSON objects.ExamplesUsing JSON.isRawJSON()The following example demonstrates how to use JSON.isRawJSON() to test whether an object was returned by JSON.rawJSON(). It implements a custom serializer that serializes data to a YAML-like format.
jsfunction mySerializer(value, indent = "") {
  if (typeof value !== "object" || value === null) {
    return JSON.stringify(value);
  }
  if (JSON.isRawJSON(value)) {
    return value.rawJSON;
  }
  const subIndent = `${indent}  `;
  if (Array.isArray(value)) {
    return `- ${value.map((v) => mySerializer(v, subIndent)).join(`\n${indent}- `)}`;
  }
  return Object.entries(value)
    .map(([key, value]) => {
      const subValue = mySerializer(value, subIndent);
      if (subValue.includes("\n")) {
        return `${key}:\n${subIndent}${subValue}`;
      }
      return `${key}: ${subValue}`;
    })
    .join(`\n${indent}`);
}

console.log(
  mySerializer({
    name: "Josh",
    userId: JSON.rawJSON("12345678901234567890"),
    friends: [
      { name: "Alice", userId: JSON.rawJSON("9876543210987654321") },
      { name: "Bob", userId: JSON.rawJSON("56789012345678901234") },
    ],
  }),
);

// name: "Josh"
// userId: 12345678901234567890
// friends:
//   - name: "Alice"
//     userId: 9876543210987654321
//   - name: "Bob"
//     userId: 56789012345678901234

If in the above example, the userId values were not created by JSON.rawJSON(), but passed as numbers directly, then we will get loss of precision upfront because of JS floating point precision limitations.
jsconsole.log(
  mySerializer({
    name: "Josh",
    userId: 12345678901234567890,
    friends: [
      { name: "Alice", userId: 9876543210987654321 },
      { name: "Bob", userId: 56789012345678901234 },
    ],
  }),
);

// name: "Josh"
// userId: 12345678901234567000
// friends:
//   - name: "Alice"
//     userId: 9876543210987655000
//   - name: "Bob"
//     userId: 56789012345678900000
SpecificationsSpecificationJSON.parse source text access # sec-json.israwjsonBrowser compatibilitySee also
Polyfill of JSON.isRawJSON in core-js
JSON
JSON.stringify()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Oct 9, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJSON.isRawJSON()Limited availabilityThis feature is not Baseline because it does not work in some of the most widely-used browsers.Learn moreSee full compatibilityReport feedbackThe JSON.isRawJSON() static method tests whether a value is an object returned by JSON.rawJSON().SyntaxjsJSON.isRawJSON(value)
Parameters
value

The value to test.

Return valuetrue if value is created by JSON.rawJSON(); otherwise, false.Description"Raw JSON" objects, when serialized to JSON, are treated as if they are already a piece of JSON. Furthermore, because of the way JSON.rawJSON() works, the raw JSON is guaranteed to be syntactically valid JSON. For more information on the shape and behavior of raw JSON objects, see JSON.rawJSON(). This method exists to allow other serialization libraries to implement similar behavior to JSON.stringify() for raw JSON objects.ExamplesUsing JSON.isRawJSON()The following example demonstrates how to use JSON.isRawJSON() to test whether an object was returned by JSON.rawJSON(). It implements a custom serializer that serializes data to a YAML-like format.
jsfunction mySerializer(value, indent = "") {
  if (typeof value !== "object" || value === null) {
    return JSON.stringify(value);
  }
  if (JSON.isRawJSON(value)) {
    return value.rawJSON;
  }
  const subIndent = `${indent}  `;
  if (Array.isArray(value)) {
    return `- ${value.map((v) => mySerializer(v, subIndent)).join(`\n${indent}- `)}`;
  }
  return Object.entries(value)
    .map(([key, value]) => {
      const subValue = mySerializer(value, subIndent);
      if (subValue.includes("\n")) {
        return `${key}:\n${subIndent}${subValue}`;
      }
      return `${key}: ${subValue}`;
    })
    .join(`\n${indent}`);
}

console.log(
  mySerializer({
    name: "Josh",
    userId: JSON.rawJSON("12345678901234567890"),
    friends: [
      { name: "Alice", userId: JSON.rawJSON("9876543210987654321") },
      { name: "Bob", userId: JSON.rawJSON("56789012345678901234") },
    ],
  }),
);

// name: "Josh"
// userId: 12345678901234567890
// friends:
//   - name: "Alice"
//     userId: 9876543210987654321
//   - name: "Bob"
//     userId: 56789012345678901234

If in the above example, the userId values were not created by JSON.rawJSON(), but passed as numbers directly, then we will get loss of precision upfront because of JS floating point precision limitations.
jsconsole.log(
  mySerializer({
    name: "Josh",
    userId: 12345678901234567890,
    friends: [
      { name: "Alice", userId: 9876543210987654321 },
      { name: "Bob", userId: 56789012345678901234 },
    ],
  }),
);

// name: "Josh"
// userId: 12345678901234567000
// friends:
//   - name: "Alice"
//     userId: 9876543210987655000
//   - name: "Bob"
//     userId: 56789012345678900000
SpecificationsSpecificationJSON.parse source text access # sec-json.israwjsonBrowser compatibilitySee also
Polyfill of JSON.isRawJSON in core-js
JSON
JSON.stringify()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Oct 9, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJSON.parse()Baseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe JSON.parse() static method parses a JSON string, constructing the JavaScript value or object described by the string. An optional reviver function can be provided to perform a transformation on the resulting object before it is returned.Try it
const json = '{"result":true, "count":42}';
const obj = JSON.parse(json);

console.log(obj.count);
// Expected output: 42

console.log(obj.result);
// Expected output: true
SyntaxjsJSON.parse(text)
JSON.parse(text, reviver)
Parameters
text

The string to parse as JSON. See the JSON object for a description of JSON syntax.

reviver Optional

If a function, this prescribes how each value originally produced by parsing is transformed before being returned. Non-callable values are ignored. The function is called with the following arguments:

key

The key associated with the value.

value

The value produced by parsing.

context Optional

A context object that holds state relevant to the current expression being revived. It is a new object for each invocation of the reviver function. It is only passed when reviving primitive values, but not when value is an object or array. It contains the following property:

source

The original JSON string representing this value.





Return valueThe Object, Array, string, number, boolean, or null value corresponding to the given JSON text.Exceptions
SyntaxError

Thrown if the string to parse is not valid JSON.

DescriptionJSON.parse() parses a JSON string according to the JSON grammar, then evaluates the string as if it's a JavaScript expression. The only instance where a piece of JSON text represents a different value from the same JavaScript expression is when dealing with the "__proto__" key — see Object literal syntax vs. JSON.The reviver parameterIf a reviver is specified, the value computed by parsing is transformed before being returned. Specifically, the computed value and all its properties (in a depth-first fashion, beginning with the most nested properties and proceeding to the original value itself) are individually run through the reviver.
The reviver is called with the object containing the property being processed as this (unless you define the reviver as an arrow function, in which case there's no separate this binding) and two arguments: key and value, representing the property name as a string (even for arrays) and the property value. For primitive values, an additional context parameter is passed, which contains the source text of this value. If the reviver function returns undefined (or returns no value — for example, if execution falls off the end of the function), the property is deleted from the object. Otherwise, the property is redefined to be the return value. If the reviver only transforms some values and not others, be certain to return all untransformed values as-is — otherwise, they will be deleted from the resulting object.
Similar to the replacer parameter of JSON.stringify(), for arrays and objects, reviver will be last called on the root value with an empty string as the key and the root object as the value. For other valid JSON values, reviver works similarly and is called once with an empty string as the key and the value itself as the value.
If you return another value from reviver, that value will completely replace the originally parsed value. This even applies to the root value. For example:
jsconst transformedObj1 = JSON.parse('[1,5,{"s":1}]', (key, value) => {
  return typeof value === "object" ? undefined : value;
});

console.log(transformedObj1); // undefined

There is no way to work around this generically. You cannot specially handle the case where key is an empty string, because JSON objects can also contain keys that are empty strings. You need to know very precisely what kind of transformation is needed for each key when implementing the reviver.
Note that reviver is run after the value is parsed. So, for example, numbers in JSON text will have already been converted to JavaScript numbers, and may lose precision in the process. One way to transfer large numbers without loss of precision is to serialize them as strings, and revive them to BigInts, or other appropriate arbitrary precision formats.
You can also use the context.source property to access the original JSON source text representing the value, as shown below:
jsconst bigJSON = '{"gross_gdp": 12345678901234567890}';
const bigObj = JSON.parse(bigJSON, (key, value, context) => {
  if (key === "gross_gdp") {
    // Ignore the value because it has already lost precision
    return BigInt(context.source);
  }
  return value;
});
ExamplesUsing JSON.parse()jsJSON.parse("{}"); // {}
JSON.parse("true"); // true
JSON.parse('"foo"'); // "foo"
JSON.parse('[1, 5, "false"]'); // [1, 5, "false"]
JSON.parse("null"); // null
Using the reviver parameterjsJSON.parse(
  '{"p": 5}',
  (key, value) =>
    typeof value === "number"
      ? value * 2 // return value * 2 for numbers
      : value, // return everything else unchanged
);
// { p: 10 }

JSON.parse('{"1": 1, "2": 2, "3": {"4": 4, "5": {"6": 6}}}', (key, value) => {
  console.log(key);
  return value;
});
// 1
// 2
// 4
// 6
// 5
// 3
// ""
Using reviver when paired with the replacer of JSON.stringify()In order for a value to properly round-trip (that is, it gets deserialized to the same original object), the serialization process must preserve the type information. For example, you can use the replacer parameter of JSON.stringify() for this purpose:
js// Maps are normally serialized as objects with no properties.
// We can use the replacer to specify the entries to be serialized.
const map = new Map([
  [1, "one"],
  [2, "two"],
  [3, "three"],
]);

const jsonText = JSON.stringify(map, (key, value) =>
  value instanceof Map ? Array.from(value.entries()) : value,
);

console.log(jsonText);
// [[1,"one"],[2,"two"],[3,"three"]]

const map2 = JSON.parse(jsonText, (key, value) =>
  Array.isArray(value) && value.every(Array.isArray) ? new Map(value) : value,
);

console.log(map2);
// Map { 1 => "one", 2 => "two", 3 => "three" }

Because JSON has no syntax space for annotating type metadata, in order to revive values that are not plain objects, you have to consider one of the following:

Serialize the entire object to a string and prefix it with a type tag.
"Guess" based on the structure of the data (for example, an array of two-member arrays)
If the shape of the payload is fixed, based on the property name (for example, all properties called registry hold Map objects).
Illegal JSONWhen JSON.parse receives a string that does not conform to the JSON grammar, it throws a SyntaxError.
Arrays and objects cannot have trailing commas in JSON:
jsJSON.parse("[1, 2, 3, 4, ]");
// SyntaxError: Unexpected token ] in JSON at position 13

JSON.parse('{"foo": 1, }');
// SyntaxError: Unexpected token } in JSON at position 12

JSON strings must be delimited by double (not single) quotes:
jsJSON.parse("{'foo': 1}");
// SyntaxError: Unexpected token ' in JSON at position 1

JSON.parse("'string'");
// SyntaxError: Unexpected token ' in JSON at position 0

If you are writing JSON inside a JavaScript string literal, you should either use single quotes to delimit the JavaScript string literal, or escape the double quotes that delimit the JSON string:
jsJSON.parse('{"foo": 1}'); // OK
JSON.parse("{\"foo\": 1}"); // OK
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.parseBrowser compatibilitySee also
Polyfill of modern JSON.parse behavior (reviver's context parameter) in core-js
JSON.stringify()\n\nJSON.parse()Baseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe JSON.parse() static method parses a JSON string, constructing the JavaScript value or object described by the string. An optional reviver function can be provided to perform a transformation on the resulting object before it is returned.Try it
const json = '{"result":true, "count":42}';
const obj = JSON.parse(json);

console.log(obj.count);
// Expected output: 42

console.log(obj.result);
// Expected output: true
SyntaxjsJSON.parse(text)
JSON.parse(text, reviver)
Parameters
text

The string to parse as JSON. See the JSON object for a description of JSON syntax.

reviver Optional

If a function, this prescribes how each value originally produced by parsing is transformed before being returned. Non-callable values are ignored. The function is called with the following arguments:

key

The key associated with the value.

value

The value produced by parsing.

context Optional

A context object that holds state relevant to the current expression being revived. It is a new object for each invocation of the reviver function. It is only passed when reviving primitive values, but not when value is an object or array. It contains the following property:

source

The original JSON string representing this value.





Return valueThe Object, Array, string, number, boolean, or null value corresponding to the given JSON text.Exceptions
SyntaxError

Thrown if the string to parse is not valid JSON.

DescriptionJSON.parse() parses a JSON string according to the JSON grammar, then evaluates the string as if it's a JavaScript expression. The only instance where a piece of JSON text represents a different value from the same JavaScript expression is when dealing with the "__proto__" key — see Object literal syntax vs. JSON.The reviver parameterIf a reviver is specified, the value computed by parsing is transformed before being returned. Specifically, the computed value and all its properties (in a depth-first fashion, beginning with the most nested properties and proceeding to the original value itself) are individually run through the reviver.
The reviver is called with the object containing the property being processed as this (unless you define the reviver as an arrow function, in which case there's no separate this binding) and two arguments: key and value, representing the property name as a string (even for arrays) and the property value. For primitive values, an additional context parameter is passed, which contains the source text of this value. If the reviver function returns undefined (or returns no value — for example, if execution falls off the end of the function), the property is deleted from the object. Otherwise, the property is redefined to be the return value. If the reviver only transforms some values and not others, be certain to return all untransformed values as-is — otherwise, they will be deleted from the resulting object.
Similar to the replacer parameter of JSON.stringify(), for arrays and objects, reviver will be last called on the root value with an empty string as the key and the root object as the value. For other valid JSON values, reviver works similarly and is called once with an empty string as the key and the value itself as the value.
If you return another value from reviver, that value will completely replace the originally parsed value. This even applies to the root value. For example:
jsconst transformedObj1 = JSON.parse('[1,5,{"s":1}]', (key, value) => {
  return typeof value === "object" ? undefined : value;
});

console.log(transformedObj1); // undefined

There is no way to work around this generically. You cannot specially handle the case where key is an empty string, because JSON objects can also contain keys that are empty strings. You need to know very precisely what kind of transformation is needed for each key when implementing the reviver.
Note that reviver is run after the value is parsed. So, for example, numbers in JSON text will have already been converted to JavaScript numbers, and may lose precision in the process. One way to transfer large numbers without loss of precision is to serialize them as strings, and revive them to BigInts, or other appropriate arbitrary precision formats.
You can also use the context.source property to access the original JSON source text representing the value, as shown below:
jsconst bigJSON = '{"gross_gdp": 12345678901234567890}';
const bigObj = JSON.parse(bigJSON, (key, value, context) => {
  if (key === "gross_gdp") {
    // Ignore the value because it has already lost precision
    return BigInt(context.source);
  }
  return value;
});
ExamplesUsing JSON.parse()jsJSON.parse("{}"); // {}
JSON.parse("true"); // true
JSON.parse('"foo"'); // "foo"
JSON.parse('[1, 5, "false"]'); // [1, 5, "false"]
JSON.parse("null"); // null
Using the reviver parameterjsJSON.parse(
  '{"p": 5}',
  (key, value) =>
    typeof value === "number"
      ? value * 2 // return value * 2 for numbers
      : value, // return everything else unchanged
);
// { p: 10 }

JSON.parse('{"1": 1, "2": 2, "3": {"4": 4, "5": {"6": 6}}}', (key, value) => {
  console.log(key);
  return value;
});
// 1
// 2
// 4
// 6
// 5
// 3
// ""
Using reviver when paired with the replacer of JSON.stringify()In order for a value to properly round-trip (that is, it gets deserialized to the same original object), the serialization process must preserve the type information. For example, you can use the replacer parameter of JSON.stringify() for this purpose:
js// Maps are normally serialized as objects with no properties.
// We can use the replacer to specify the entries to be serialized.
const map = new Map([
  [1, "one"],
  [2, "two"],
  [3, "three"],
]);

const jsonText = JSON.stringify(map, (key, value) =>
  value instanceof Map ? Array.from(value.entries()) : value,
);

console.log(jsonText);
// [[1,"one"],[2,"two"],[3,"three"]]

const map2 = JSON.parse(jsonText, (key, value) =>
  Array.isArray(value) && value.every(Array.isArray) ? new Map(value) : value,
);

console.log(map2);
// Map { 1 => "one", 2 => "two", 3 => "three" }

Because JSON has no syntax space for annotating type metadata, in order to revive values that are not plain objects, you have to consider one of the following:

Serialize the entire object to a string and prefix it with a type tag.
"Guess" based on the structure of the data (for example, an array of two-member arrays)
If the shape of the payload is fixed, based on the property name (for example, all properties called registry hold Map objects).
Illegal JSONWhen JSON.parse receives a string that does not conform to the JSON grammar, it throws a SyntaxError.
Arrays and objects cannot have trailing commas in JSON:
jsJSON.parse("[1, 2, 3, 4, ]");
// SyntaxError: Unexpected token ] in JSON at position 13

JSON.parse('{"foo": 1, }');
// SyntaxError: Unexpected token } in JSON at position 12

JSON strings must be delimited by double (not single) quotes:
jsJSON.parse("{'foo': 1}");
// SyntaxError: Unexpected token ' in JSON at position 1

JSON.parse("'string'");
// SyntaxError: Unexpected token ' in JSON at position 0

If you are writing JSON inside a JavaScript string literal, you should either use single quotes to delimit the JavaScript string literal, or escape the double quotes that delimit the JSON string:
jsJSON.parse('{"foo": 1}'); // OK
JSON.parse("{\"foo\": 1}"); // OK
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.parseBrowser compatibilitySee also
Polyfill of modern JSON.parse behavior (reviver's context parameter) in core-js
JSON.stringify()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJSON.parse()Baseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe JSON.parse() static method parses a JSON string, constructing the JavaScript value or object described by the string. An optional reviver function can be provided to perform a transformation on the resulting object before it is returned.Try it
const json = '{"result":true, "count":42}';
const obj = JSON.parse(json);

console.log(obj.count);
// Expected output: 42

console.log(obj.result);
// Expected output: true
SyntaxjsJSON.parse(text)
JSON.parse(text, reviver)
Parameters
text

The string to parse as JSON. See the JSON object for a description of JSON syntax.

reviver Optional

If a function, this prescribes how each value originally produced by parsing is transformed before being returned. Non-callable values are ignored. The function is called with the following arguments:

key

The key associated with the value.

value

The value produced by parsing.

context Optional

A context object that holds state relevant to the current expression being revived. It is a new object for each invocation of the reviver function. It is only passed when reviving primitive values, but not when value is an object or array. It contains the following property:

source

The original JSON string representing this value.





Return valueThe Object, Array, string, number, boolean, or null value corresponding to the given JSON text.Exceptions
SyntaxError

Thrown if the string to parse is not valid JSON.

DescriptionJSON.parse() parses a JSON string according to the JSON grammar, then evaluates the string as if it's a JavaScript expression. The only instance where a piece of JSON text represents a different value from the same JavaScript expression is when dealing with the "__proto__" key — see Object literal syntax vs. JSON.The reviver parameterIf a reviver is specified, the value computed by parsing is transformed before being returned. Specifically, the computed value and all its properties (in a depth-first fashion, beginning with the most nested properties and proceeding to the original value itself) are individually run through the reviver.
The reviver is called with the object containing the property being processed as this (unless you define the reviver as an arrow function, in which case there's no separate this binding) and two arguments: key and value, representing the property name as a string (even for arrays) and the property value. For primitive values, an additional context parameter is passed, which contains the source text of this value. If the reviver function returns undefined (or returns no value — for example, if execution falls off the end of the function), the property is deleted from the object. Otherwise, the property is redefined to be the return value. If the reviver only transforms some values and not others, be certain to return all untransformed values as-is — otherwise, they will be deleted from the resulting object.
Similar to the replacer parameter of JSON.stringify(), for arrays and objects, reviver will be last called on the root value with an empty string as the key and the root object as the value. For other valid JSON values, reviver works similarly and is called once with an empty string as the key and the value itself as the value.
If you return another value from reviver, that value will completely replace the originally parsed value. This even applies to the root value. For example:
jsconst transformedObj1 = JSON.parse('[1,5,{"s":1}]', (key, value) => {
  return typeof value === "object" ? undefined : value;
});

console.log(transformedObj1); // undefined

There is no way to work around this generically. You cannot specially handle the case where key is an empty string, because JSON objects can also contain keys that are empty strings. You need to know very precisely what kind of transformation is needed for each key when implementing the reviver.
Note that reviver is run after the value is parsed. So, for example, numbers in JSON text will have already been converted to JavaScript numbers, and may lose precision in the process. One way to transfer large numbers without loss of precision is to serialize them as strings, and revive them to BigInts, or other appropriate arbitrary precision formats.
You can also use the context.source property to access the original JSON source text representing the value, as shown below:
jsconst bigJSON = '{"gross_gdp": 12345678901234567890}';
const bigObj = JSON.parse(bigJSON, (key, value, context) => {
  if (key === "gross_gdp") {
    // Ignore the value because it has already lost precision
    return BigInt(context.source);
  }
  return value;
});
ExamplesUsing JSON.parse()jsJSON.parse("{}"); // {}
JSON.parse("true"); // true
JSON.parse('"foo"'); // "foo"
JSON.parse('[1, 5, "false"]'); // [1, 5, "false"]
JSON.parse("null"); // null
Using the reviver parameterjsJSON.parse(
  '{"p": 5}',
  (key, value) =>
    typeof value === "number"
      ? value * 2 // return value * 2 for numbers
      : value, // return everything else unchanged
);
// { p: 10 }

JSON.parse('{"1": 1, "2": 2, "3": {"4": 4, "5": {"6": 6}}}', (key, value) => {
  console.log(key);
  return value;
});
// 1
// 2
// 4
// 6
// 5
// 3
// ""
Using reviver when paired with the replacer of JSON.stringify()In order for a value to properly round-trip (that is, it gets deserialized to the same original object), the serialization process must preserve the type information. For example, you can use the replacer parameter of JSON.stringify() for this purpose:
js// Maps are normally serialized as objects with no properties.
// We can use the replacer to specify the entries to be serialized.
const map = new Map([
  [1, "one"],
  [2, "two"],
  [3, "three"],
]);

const jsonText = JSON.stringify(map, (key, value) =>
  value instanceof Map ? Array.from(value.entries()) : value,
);

console.log(jsonText);
// [[1,"one"],[2,"two"],[3,"three"]]

const map2 = JSON.parse(jsonText, (key, value) =>
  Array.isArray(value) && value.every(Array.isArray) ? new Map(value) : value,
);

console.log(map2);
// Map { 1 => "one", 2 => "two", 3 => "three" }

Because JSON has no syntax space for annotating type metadata, in order to revive values that are not plain objects, you have to consider one of the following:

Serialize the entire object to a string and prefix it with a type tag.
"Guess" based on the structure of the data (for example, an array of two-member arrays)
If the shape of the payload is fixed, based on the property name (for example, all properties called registry hold Map objects).
Illegal JSONWhen JSON.parse receives a string that does not conform to the JSON grammar, it throws a SyntaxError.
Arrays and objects cannot have trailing commas in JSON:
jsJSON.parse("[1, 2, 3, 4, ]");
// SyntaxError: Unexpected token ] in JSON at position 13

JSON.parse('{"foo": 1, }');
// SyntaxError: Unexpected token } in JSON at position 12

JSON strings must be delimited by double (not single) quotes:
jsJSON.parse("{'foo': 1}");
// SyntaxError: Unexpected token ' in JSON at position 1

JSON.parse("'string'");
// SyntaxError: Unexpected token ' in JSON at position 0

If you are writing JSON inside a JavaScript string literal, you should either use single quotes to delimit the JavaScript string literal, or escape the double quotes that delimit the JSON string:
jsJSON.parse('{"foo": 1}'); // OK
JSON.parse("{\"foo\": 1}"); // OK
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.parseBrowser compatibilitySee also
Polyfill of modern JSON.parse behavior (reviver's context parameter) in core-js
JSON.stringify()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJSON.rawJSON()Limited availabilityThis feature is not Baseline because it does not work in some of the most widely-used browsers.Learn moreSee full compatibilityReport feedbackThe JSON.rawJSON() static method creates a "raw JSON" object containing a piece of JSON text. When serialized to JSON, the raw JSON object is treated as if it is already a piece of JSON. This text is required to be valid JSON.SyntaxjsJSON.rawJSON(string)
Parameters
string

The JSON text. Must be valid JSON representing a primitive value.

Return valueAn object that can be used to create JSON text with the exact same content as the string provided, without quotes around the string itself. This object has null prototype and is frozen (so it never gets accidentally serialized as a regular object by any kind of primitive conversion), and the following property:

rawJSON

The original JSON string provided.


Furthermore, it has a private property that marks itself as a raw JSON object. This allows it to be identified by JSON.stringify() and JSON.isRawJSON().Exceptions
SyntaxError

Thrown if the string is not valid JSON, or if it represents an object or array.

DescriptionA raw JSON object can be seen as an immutable, atomic data structure like any kind of primitive. It is not a regular object and it contains no data other than the raw JSON text. It is used to "pre-serialize" data to formats that JSON.stringify itself cannot produce for various reasons. The most typical use case is the floating point number loss of precision problem. For example:
jsJSON.stringify({ value: 12345678901234567890 });
// {"value":12345678901234567000}

The value is not exactly equivalent to the original number any more! This is because JavaScript uses floating point representation for all numbers, so it cannot represent all integers exactly. The number literal 12345678901234567890 itself is already rounded to the nearest representable number when it is parsed by JavaScript.
Without JSON.rawJSON, there is no way to tell JSON.stringify to produce the number literal 12345678901234567890, because there is simply no corresponding JavaScript number value. With raw JSON, you can directly tell JSON.stringify() what a particular value should be stringified as:
jsconst rawJSON = JSON.rawJSON("12345678901234567890");
JSON.stringify({ value: rawJSON });
// {"value":12345678901234567890}

For a more complete example of this, see Lossless number serialization.
Note that although we passed a string to JSON.rawJSON(), it still becomes a number in the final JSON. This is because the string represents the verbatim JSON text. If you want to serialize a string, you should use JSON.rawJSON() with a quotes-enclosed string value:
jsconst rawJSON = JSON.rawJSON('"Hello world"');
JSON.stringify({ value: rawJSON });
// {"value":"Hello world"}

JSON.rawJSON allows you to insert arbitrary JSON text, but does not allow you to create invalid JSON. Anything that was not permitted by the JSON syntax is not permitted by JSON.rawJSON() either:
jsconst rawJSON = JSON.rawJSON('"Hello\nworld"'); // Syntax error, because line breaks are not allowed in JSON strings

Furthermore, you cannot use JSON.rawJSON() to create JSON objects or arrays.ExamplesUsing JSON.rawJSON() to create JSON expressions of different typesjsconst numJSON = JSON.rawJSON("123");
const strJSON = JSON.rawJSON('"Hello world"');
const boolJSON = JSON.rawJSON("true");
const nullJSON = JSON.rawJSON("null");

console.log(
  JSON.stringify({
    age: numJSON,
    message: strJSON,
    isActive: boolJSON,
    nothing: nullJSON,
  }),
);

// {"age":123,"message":"Hello world","isActive":true,"nothing":null}

However, you cannot use JSON.rawJSON() to create JSON objects or arrays:
jsconst arrJSON = JSON.rawJSON("[1, 2, 3]");
const objJSON = JSON.rawJSON('{"a": 1, "b": 2}');
// SyntaxError
Using JSON.rawJSON() to create escaped string literalsApart from numbers, there is only one other type that does not have a one-to-one correspondence between JavaScript values and JSON text: strings. When strings are serialized to JSON, all code points, other than those that are not legal inside JSON string literals (such as line breaks), are printed literally:
jsconsole.log(JSON.stringify({ value: "\ud83d\ude04" })); // {"value":"😄"}

This may not be desirable, because the receiver of this string may handle Unicode differently. To improve interoperability, you can explicitly specify the string to be serialized with escape sequences:
jsconst rawJSON = JSON.rawJSON('"\\ud83d\\ude04"');
const objStr = JSON.stringify({ value: rawJSON });
console.log(objStr); // {"value":"\ud83d\ude04"}
console.log(JSON.parse(objStr).value); // 😄

Note that the double backslashes in the rawJSON actually represents a single slash character.SpecificationsSpecificationJSON.parse source text access # sec-json.rawjsonBrowser compatibilitySee also
Polyfill of JSON.rawJSON in core-js
JSON
JSON.isRawJSON()
JSON.stringify()\n\nJSON.rawJSON()Limited availabilityThis feature is not Baseline because it does not work in some of the most widely-used browsers.Learn moreSee full compatibilityReport feedbackThe JSON.rawJSON() static method creates a "raw JSON" object containing a piece of JSON text. When serialized to JSON, the raw JSON object is treated as if it is already a piece of JSON. This text is required to be valid JSON.SyntaxjsJSON.rawJSON(string)
Parameters
string

The JSON text. Must be valid JSON representing a primitive value.

Return valueAn object that can be used to create JSON text with the exact same content as the string provided, without quotes around the string itself. This object has null prototype and is frozen (so it never gets accidentally serialized as a regular object by any kind of primitive conversion), and the following property:

rawJSON

The original JSON string provided.


Furthermore, it has a private property that marks itself as a raw JSON object. This allows it to be identified by JSON.stringify() and JSON.isRawJSON().Exceptions
SyntaxError

Thrown if the string is not valid JSON, or if it represents an object or array.

DescriptionA raw JSON object can be seen as an immutable, atomic data structure like any kind of primitive. It is not a regular object and it contains no data other than the raw JSON text. It is used to "pre-serialize" data to formats that JSON.stringify itself cannot produce for various reasons. The most typical use case is the floating point number loss of precision problem. For example:
jsJSON.stringify({ value: 12345678901234567890 });
// {"value":12345678901234567000}

The value is not exactly equivalent to the original number any more! This is because JavaScript uses floating point representation for all numbers, so it cannot represent all integers exactly. The number literal 12345678901234567890 itself is already rounded to the nearest representable number when it is parsed by JavaScript.
Without JSON.rawJSON, there is no way to tell JSON.stringify to produce the number literal 12345678901234567890, because there is simply no corresponding JavaScript number value. With raw JSON, you can directly tell JSON.stringify() what a particular value should be stringified as:
jsconst rawJSON = JSON.rawJSON("12345678901234567890");
JSON.stringify({ value: rawJSON });
// {"value":12345678901234567890}

For a more complete example of this, see Lossless number serialization.
Note that although we passed a string to JSON.rawJSON(), it still becomes a number in the final JSON. This is because the string represents the verbatim JSON text. If you want to serialize a string, you should use JSON.rawJSON() with a quotes-enclosed string value:
jsconst rawJSON = JSON.rawJSON('"Hello world"');
JSON.stringify({ value: rawJSON });
// {"value":"Hello world"}

JSON.rawJSON allows you to insert arbitrary JSON text, but does not allow you to create invalid JSON. Anything that was not permitted by the JSON syntax is not permitted by JSON.rawJSON() either:
jsconst rawJSON = JSON.rawJSON('"Hello\nworld"'); // Syntax error, because line breaks are not allowed in JSON strings

Furthermore, you cannot use JSON.rawJSON() to create JSON objects or arrays.ExamplesUsing JSON.rawJSON() to create JSON expressions of different typesjsconst numJSON = JSON.rawJSON("123");
const strJSON = JSON.rawJSON('"Hello world"');
const boolJSON = JSON.rawJSON("true");
const nullJSON = JSON.rawJSON("null");

console.log(
  JSON.stringify({
    age: numJSON,
    message: strJSON,
    isActive: boolJSON,
    nothing: nullJSON,
  }),
);

// {"age":123,"message":"Hello world","isActive":true,"nothing":null}

However, you cannot use JSON.rawJSON() to create JSON objects or arrays:
jsconst arrJSON = JSON.rawJSON("[1, 2, 3]");
const objJSON = JSON.rawJSON('{"a": 1, "b": 2}');
// SyntaxError
Using JSON.rawJSON() to create escaped string literalsApart from numbers, there is only one other type that does not have a one-to-one correspondence between JavaScript values and JSON text: strings. When strings are serialized to JSON, all code points, other than those that are not legal inside JSON string literals (such as line breaks), are printed literally:
jsconsole.log(JSON.stringify({ value: "\ud83d\ude04" })); // {"value":"😄"}

This may not be desirable, because the receiver of this string may handle Unicode differently. To improve interoperability, you can explicitly specify the string to be serialized with escape sequences:
jsconst rawJSON = JSON.rawJSON('"\\ud83d\\ude04"');
const objStr = JSON.stringify({ value: rawJSON });
console.log(objStr); // {"value":"\ud83d\ude04"}
console.log(JSON.parse(objStr).value); // 😄

Note that the double backslashes in the rawJSON actually represents a single slash character.SpecificationsSpecificationJSON.parse source text access # sec-json.rawjsonBrowser compatibilitySee also
Polyfill of JSON.rawJSON in core-js
JSON
JSON.isRawJSON()
JSON.stringify()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJSON.rawJSON()Limited availabilityThis feature is not Baseline because it does not work in some of the most widely-used browsers.Learn moreSee full compatibilityReport feedbackThe JSON.rawJSON() static method creates a "raw JSON" object containing a piece of JSON text. When serialized to JSON, the raw JSON object is treated as if it is already a piece of JSON. This text is required to be valid JSON.SyntaxjsJSON.rawJSON(string)
Parameters
string

The JSON text. Must be valid JSON representing a primitive value.

Return valueAn object that can be used to create JSON text with the exact same content as the string provided, without quotes around the string itself. This object has null prototype and is frozen (so it never gets accidentally serialized as a regular object by any kind of primitive conversion), and the following property:

rawJSON

The original JSON string provided.


Furthermore, it has a private property that marks itself as a raw JSON object. This allows it to be identified by JSON.stringify() and JSON.isRawJSON().Exceptions
SyntaxError

Thrown if the string is not valid JSON, or if it represents an object or array.

DescriptionA raw JSON object can be seen as an immutable, atomic data structure like any kind of primitive. It is not a regular object and it contains no data other than the raw JSON text. It is used to "pre-serialize" data to formats that JSON.stringify itself cannot produce for various reasons. The most typical use case is the floating point number loss of precision problem. For example:
jsJSON.stringify({ value: 12345678901234567890 });
// {"value":12345678901234567000}

The value is not exactly equivalent to the original number any more! This is because JavaScript uses floating point representation for all numbers, so it cannot represent all integers exactly. The number literal 12345678901234567890 itself is already rounded to the nearest representable number when it is parsed by JavaScript.
Without JSON.rawJSON, there is no way to tell JSON.stringify to produce the number literal 12345678901234567890, because there is simply no corresponding JavaScript number value. With raw JSON, you can directly tell JSON.stringify() what a particular value should be stringified as:
jsconst rawJSON = JSON.rawJSON("12345678901234567890");
JSON.stringify({ value: rawJSON });
// {"value":12345678901234567890}

For a more complete example of this, see Lossless number serialization.
Note that although we passed a string to JSON.rawJSON(), it still becomes a number in the final JSON. This is because the string represents the verbatim JSON text. If you want to serialize a string, you should use JSON.rawJSON() with a quotes-enclosed string value:
jsconst rawJSON = JSON.rawJSON('"Hello world"');
JSON.stringify({ value: rawJSON });
// {"value":"Hello world"}

JSON.rawJSON allows you to insert arbitrary JSON text, but does not allow you to create invalid JSON. Anything that was not permitted by the JSON syntax is not permitted by JSON.rawJSON() either:
jsconst rawJSON = JSON.rawJSON('"Hello\nworld"'); // Syntax error, because line breaks are not allowed in JSON strings

Furthermore, you cannot use JSON.rawJSON() to create JSON objects or arrays.ExamplesUsing JSON.rawJSON() to create JSON expressions of different typesjsconst numJSON = JSON.rawJSON("123");
const strJSON = JSON.rawJSON('"Hello world"');
const boolJSON = JSON.rawJSON("true");
const nullJSON = JSON.rawJSON("null");

console.log(
  JSON.stringify({
    age: numJSON,
    message: strJSON,
    isActive: boolJSON,
    nothing: nullJSON,
  }),
);

// {"age":123,"message":"Hello world","isActive":true,"nothing":null}

However, you cannot use JSON.rawJSON() to create JSON objects or arrays:
jsconst arrJSON = JSON.rawJSON("[1, 2, 3]");
const objJSON = JSON.rawJSON('{"a": 1, "b": 2}');
// SyntaxError
Using JSON.rawJSON() to create escaped string literalsApart from numbers, there is only one other type that does not have a one-to-one correspondence between JavaScript values and JSON text: strings. When strings are serialized to JSON, all code points, other than those that are not legal inside JSON string literals (such as line breaks), are printed literally:
jsconsole.log(JSON.stringify({ value: "\ud83d\ude04" })); // {"value":"😄"}

This may not be desirable, because the receiver of this string may handle Unicode differently. To improve interoperability, you can explicitly specify the string to be serialized with escape sequences:
jsconst rawJSON = JSON.rawJSON('"\\ud83d\\ude04"');
const objStr = JSON.stringify({ value: rawJSON });
console.log(objStr); // {"value":"\ud83d\ude04"}
console.log(JSON.parse(objStr).value); // 😄

Note that the double backslashes in the rawJSON actually represents a single slash character.SpecificationsSpecificationJSON.parse source text access # sec-json.rawjsonBrowser compatibilitySee also
Polyfill of JSON.rawJSON in core-js
JSON
JSON.isRawJSON()
JSON.stringify()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nBaseline (compatibility)Baseline identifies the availability of web platform features across popular browsers, including APIs, CSS properties, and JavaScript syntax. Baseline describes web features as being either widely available or newly available. Features that do not meet the Baseline criteria are said to have limited availability.
Baseline considers support in the following browsers:

Apple Safari (iOS)
Apple Safari (macOS)
Google Chrome (Android)
Google Chrome (desktop)
Microsoft Edge (desktop)
Mozilla Firefox (Android)
Mozilla Firefox (desktop)

Baseline is a summary of browser support. It is not a substitute for accessibility, usability, performance, security, or other testing. Baseline may not tell you if a feature works with:

Older devices and browser releases
Browsers not covered by the Baseline definition, such as operating system web views
Assistive technology, such as screen readers.
Baseline badges
Features listed as widely available have a consistent history of support in each of the Baseline browsers for at least 2.5 years.

Features listed as newly available work in at least the latest stable version of each of the Baseline browsers, but may not work with older browsers and devices.

Features listed with limited availability are not yet available in all browsers.See also
Testing
web-platform-dx/web-features repository
W3C WebDX Community Group
mdn/browser-compat-data repository
caniuse.com
a11ysupport.io\n\nBaseline (compatibility)Baseline identifies the availability of web platform features across popular browsers, including APIs, CSS properties, and JavaScript syntax. Baseline describes web features as being either widely available or newly available. Features that do not meet the Baseline criteria are said to have limited availability.
Baseline considers support in the following browsers:

Apple Safari (iOS)
Apple Safari (macOS)
Google Chrome (Android)
Google Chrome (desktop)
Microsoft Edge (desktop)
Mozilla Firefox (Android)
Mozilla Firefox (desktop)

Baseline is a summary of browser support. It is not a substitute for accessibility, usability, performance, security, or other testing. Baseline may not tell you if a feature works with:

Older devices and browser releases
Browsers not covered by the Baseline definition, such as operating system web views
Assistive technology, such as screen readers.
Baseline badges
Features listed as widely available have a consistent history of support in each of the Baseline browsers for at least 2.5 years.

Features listed as newly available work in at least the latest stable version of each of the Baseline browsers, but may not work with older browsers and devices.

Features listed with limited availability are not yet available in all browsers.See also
Testing
web-platform-dx/web-features repository
W3C WebDX Community Group
mdn/browser-compat-data repository
caniuse.com
a11ysupport.io
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Dec 19, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nBaseline (compatibility)Baseline identifies the availability of web platform features across popular browsers, including APIs, CSS properties, and JavaScript syntax. Baseline describes web features as being either widely available or newly available. Features that do not meet the Baseline criteria are said to have limited availability.
Baseline considers support in the following browsers:

Apple Safari (iOS)
Apple Safari (macOS)
Google Chrome (Android)
Google Chrome (desktop)
Microsoft Edge (desktop)
Mozilla Firefox (Android)
Mozilla Firefox (desktop)

Baseline is a summary of browser support. It is not a substitute for accessibility, usability, performance, security, or other testing. Baseline may not tell you if a feature works with:

Older devices and browser releases
Browsers not covered by the Baseline definition, such as operating system web views
Assistive technology, such as screen readers.
Baseline badges
Features listed as widely available have a consistent history of support in each of the Baseline browsers for at least 2.5 years.

Features listed as newly available work in at least the latest stable version of each of the Baseline browsers, but may not work with older browsers and devices.

Features listed with limited availability are not yet available in all browsers.See also
Testing
web-platform-dx/web-features repository
W3C WebDX Community Group
mdn/browser-compat-data repository
caniuse.com
a11ysupport.io
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Dec 19, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nSymbolBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackSymbol is a built-in object whose constructor returns a symbol primitive — also called a Symbol value or just a Symbol — that's guaranteed to be unique. Symbols are often used to add unique property keys to an object that won't collide with keys any other code might add to the object, and which are hidden from any mechanisms other code will typically use to access the object. That enables a form of weak encapsulation, or a weak form of information hiding.
Every Symbol() call is guaranteed to return a unique Symbol. Every Symbol.for("key") call will always return the same Symbol for a given value of "key". When Symbol.for("key") is called, if a Symbol with the given key can be found in the global Symbol registry, that Symbol is returned. Otherwise, a new Symbol is created, added to the global Symbol registry under the given key, and returned.DescriptionTo create a new primitive Symbol, you write Symbol() with an optional string as its description:
jsconst sym1 = Symbol();
const sym2 = Symbol("foo");
const sym3 = Symbol("foo");

The above code creates three new Symbols. Note that Symbol("foo") does not coerce the string "foo" into a Symbol. It creates a new Symbol each time:
jsSymbol("foo") === Symbol("foo"); // false

The following syntax with the new operator will throw a TypeError:
jsconst sym = new Symbol(); // TypeError

This prevents authors from creating an explicit Symbol wrapper object instead of a new Symbol value and might be surprising as creating explicit wrapper objects around primitive data types is generally possible (for example, new Boolean, new String and new Number).
If you really want to create a Symbol wrapper object, you can use the Object() function:
jsconst sym = Symbol("foo");
typeof sym; // "symbol"
const symObj = Object(sym);
typeof symObj; // "object"

Because symbols are the only primitive data type that has reference identity (that is, you cannot create the same symbol twice), they behave like objects in some way. For example, they are garbage collectable and can therefore be stored in WeakMap, WeakSet, WeakRef, and FinalizationRegistry objects.Shared Symbols in the global Symbol registryThe above syntax using the Symbol() function will create a Symbol whose value remains unique throughout the lifetime of the program. To create Symbols available across files and even across realms (each of which has its own global scope), use the methods Symbol.for() and Symbol.keyFor() to set and retrieve Symbols from the global Symbol registry.
Note that the "global Symbol registry" is only a fictitious concept and may not correspond to any internal data structure in the JavaScript engine — and even if such a registry exists, its content is not available to the JavaScript code, except through the for() and keyFor() methods.
The method Symbol.for(tokenString) takes a string key and returns a symbol value from the registry, while Symbol.keyFor(symbolValue) takes a symbol value and returns the string key corresponding to it. Each is the other's inverse, so the following is true:
jsSymbol.keyFor(Symbol.for("tokenString")) === "tokenString"; // true

Because registered symbols can be arbitrarily created anywhere, they behave almost exactly like the strings they wrap. Therefore, they are not guaranteed to be unique and are not garbage collectable. Therefore, registered symbols are disallowed in WeakMap, WeakSet, WeakRef, and FinalizationRegistry objects.Well-known SymbolsAll static properties of the Symbol constructor are Symbols themselves, whose values are constant across realms. They are known as well-known Symbols, and their purpose is to serve as "protocols" for certain built-in JavaScript operations, allowing users to customize the language's behavior. For example, if a constructor function has a method with Symbol.hasInstance as its name, this method will encode its behavior with the instanceof operator.
Prior to well-known Symbols, JavaScript used normal properties to implement certain built-in operations. For example, the JSON.stringify function will attempt to call each object's toJSON() method, and the String function will call the object's toString() and valueOf() methods. However, as more operations are added to the language, designating each operation a "magic property" can break backward compatibility and make the language's behavior harder to reason with. Well-known Symbols allow the customizations to be "invisible" from normal code, which typically only read string properties.

Note:
The spec used to use the notation @@<symbol-name> to denote well-known symbols. For example, Symbol.hasInstance was written as @@hasInstance, and the Array.prototype[Symbol.iterator]() method would be called Array.prototype[@@iterator](). This notation is no longer used in the spec, but you may still see it in older documentation or discussions.

Well-known symbols do not have the concept of garbage collectability, because they come in a fixed set and are unique throughout the lifetime of the program, similar to intrinsic objects such as Array.prototype, so they are also allowed in WeakMap, WeakSet, WeakRef, and FinalizationRegistry objects.Finding Symbol properties on objectsThe method Object.getOwnPropertySymbols() returns an array of Symbols and lets you find Symbol properties on a given object. Note that every object is initialized with no own Symbol properties, so that this array will be empty unless you've set Symbol properties on the object.Constructor
Symbol()

Returns primitive values of type Symbol. Throws an error when called with new.

Static propertiesThe static properties are all well-known Symbols. In these Symbols' descriptions, we will use language like "Symbol.hasInstance is a method determining…", but bear in mind that this is referring to the semantic of an object's method having this Symbol as the method name (because well-known Symbols act as "protocols"), not describing the value of the Symbol itself.

Symbol.asyncIterator

A method that returns the default AsyncIterator for an object. Used by for await...of.

Symbol.hasInstance

A method determining if a constructor object recognizes an object as its instance. Used by instanceof.

Symbol.isConcatSpreadable

A Boolean value indicating if an object should be flattened to its array elements. Used by Array.prototype.concat().

Symbol.iterator

A method returning the default iterator for an object. Used by for...of.

Symbol.match

A method that matches against a string, also used to determine if an object may be used as a regular expression. Used by String.prototype.match().

Symbol.matchAll

A method that returns an iterator, that yields matches of the regular expression against a string. Used by String.prototype.matchAll().

Symbol.replace

A method that replaces matched substrings of a string. Used by String.prototype.replace().

Symbol.search

A method that returns the index within a string that matches the regular expression. Used by String.prototype.search().

Symbol.species

A constructor function that is used to create derived objects.

Symbol.split

A method that splits a string at the indices that match a regular expression. Used by String.prototype.split().

Symbol.toPrimitive

A method converting an object to a primitive value.

Symbol.toStringTag

A string value used for the default description of an object. Used by Object.prototype.toString().

Symbol.unscopables

An object value of whose own and inherited property names are excluded from the with environment bindings of the associated object.

Static methods
Symbol.for()

Searches for existing registered Symbols in the global Symbol registry with the given key and returns it if found. Otherwise a new Symbol gets created and registered with key.

Symbol.keyFor()

Retrieves a shared Symbol key from the global Symbol registry for the given Symbol.

Instance propertiesThese properties are defined on Symbol.prototype and shared by all Symbol instances.

Symbol.prototype.constructor

The constructor function that created the instance object. For Symbol instances, the initial value is the Symbol constructor.

Symbol.prototype.description

A read-only string containing the description of the Symbol.

Symbol.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Symbol". This property is used in Object.prototype.toString(). However, because Symbol also has its own toString() method, this property is not used unless you call Object.prototype.toString.call() with a symbol as thisArg.

Instance methods
Symbol.prototype.toString()

Returns a string containing the description of the Symbol. Overrides the Object.prototype.toString() method.

Symbol.prototype.valueOf()

Returns the Symbol. Overrides the Object.prototype.valueOf() method.

Symbol.prototype[Symbol.toPrimitive]()

Returns the Symbol.

ExamplesUsing the typeof operator with SymbolsThe typeof operator can help you to identify Symbols.
jstypeof Symbol() === "symbol";
typeof Symbol("foo") === "symbol";
typeof Symbol.iterator === "symbol";
Symbol type conversionsSome things to note when working with type conversion of Symbols.

When trying to convert a Symbol to a number, a TypeError will be thrown
(e.g., +sym or sym | 0).
When using loose equality, Object(sym) == sym returns true.
Symbol("foo") + "bar" throws a TypeError (can't convert Symbol to string). This prevents you from silently creating a new string property name from a Symbol, for example.
The "safer" String(sym) conversion works like a call to Symbol.prototype.toString() with Symbols, but note that new String(sym) will throw.
Symbols and for...in iterationSymbols are not enumerable in for...in iterations. In addition, Object.getOwnPropertyNames() will not return Symbol object properties, however, you can use Object.getOwnPropertySymbols() to get these.
jsconst obj = {};

obj[Symbol("a")] = "a";
obj[Symbol.for("b")] = "b";
obj["c"] = "c";
obj.d = "d";

for (const i in obj) {
  console.log(i);
}
// "c" "d"
Symbols and JSON.stringify()Symbol-keyed properties will be completely ignored when using JSON.stringify():
jsJSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'

For more details, see JSON.stringify().Symbol wrapper objects as property keysWhen a Symbol wrapper object is used as a property key, this object will be coerced to its wrapped Symbol:
jsconst sym = Symbol("foo");
const obj = { [sym]: 1 };
obj[sym]; // 1
obj[Object(sym)]; // still 1
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-symbol-objectsBrowser compatibilitySee also
Polyfill of Symbol in core-js
typeof
JavaScript data types and data structures
ES6 In Depth: Symbols on hacks.mozilla.org (2015)\n\nSymbolBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackSymbol is a built-in object whose constructor returns a symbol primitive — also called a Symbol value or just a Symbol — that's guaranteed to be unique. Symbols are often used to add unique property keys to an object that won't collide with keys any other code might add to the object, and which are hidden from any mechanisms other code will typically use to access the object. That enables a form of weak encapsulation, or a weak form of information hiding.
Every Symbol() call is guaranteed to return a unique Symbol. Every Symbol.for("key") call will always return the same Symbol for a given value of "key". When Symbol.for("key") is called, if a Symbol with the given key can be found in the global Symbol registry, that Symbol is returned. Otherwise, a new Symbol is created, added to the global Symbol registry under the given key, and returned.DescriptionTo create a new primitive Symbol, you write Symbol() with an optional string as its description:
jsconst sym1 = Symbol();
const sym2 = Symbol("foo");
const sym3 = Symbol("foo");

The above code creates three new Symbols. Note that Symbol("foo") does not coerce the string "foo" into a Symbol. It creates a new Symbol each time:
jsSymbol("foo") === Symbol("foo"); // false

The following syntax with the new operator will throw a TypeError:
jsconst sym = new Symbol(); // TypeError

This prevents authors from creating an explicit Symbol wrapper object instead of a new Symbol value and might be surprising as creating explicit wrapper objects around primitive data types is generally possible (for example, new Boolean, new String and new Number).
If you really want to create a Symbol wrapper object, you can use the Object() function:
jsconst sym = Symbol("foo");
typeof sym; // "symbol"
const symObj = Object(sym);
typeof symObj; // "object"

Because symbols are the only primitive data type that has reference identity (that is, you cannot create the same symbol twice), they behave like objects in some way. For example, they are garbage collectable and can therefore be stored in WeakMap, WeakSet, WeakRef, and FinalizationRegistry objects.Shared Symbols in the global Symbol registryThe above syntax using the Symbol() function will create a Symbol whose value remains unique throughout the lifetime of the program. To create Symbols available across files and even across realms (each of which has its own global scope), use the methods Symbol.for() and Symbol.keyFor() to set and retrieve Symbols from the global Symbol registry.
Note that the "global Symbol registry" is only a fictitious concept and may not correspond to any internal data structure in the JavaScript engine — and even if such a registry exists, its content is not available to the JavaScript code, except through the for() and keyFor() methods.
The method Symbol.for(tokenString) takes a string key and returns a symbol value from the registry, while Symbol.keyFor(symbolValue) takes a symbol value and returns the string key corresponding to it. Each is the other's inverse, so the following is true:
jsSymbol.keyFor(Symbol.for("tokenString")) === "tokenString"; // true

Because registered symbols can be arbitrarily created anywhere, they behave almost exactly like the strings they wrap. Therefore, they are not guaranteed to be unique and are not garbage collectable. Therefore, registered symbols are disallowed in WeakMap, WeakSet, WeakRef, and FinalizationRegistry objects.Well-known SymbolsAll static properties of the Symbol constructor are Symbols themselves, whose values are constant across realms. They are known as well-known Symbols, and their purpose is to serve as "protocols" for certain built-in JavaScript operations, allowing users to customize the language's behavior. For example, if a constructor function has a method with Symbol.hasInstance as its name, this method will encode its behavior with the instanceof operator.
Prior to well-known Symbols, JavaScript used normal properties to implement certain built-in operations. For example, the JSON.stringify function will attempt to call each object's toJSON() method, and the String function will call the object's toString() and valueOf() methods. However, as more operations are added to the language, designating each operation a "magic property" can break backward compatibility and make the language's behavior harder to reason with. Well-known Symbols allow the customizations to be "invisible" from normal code, which typically only read string properties.

Note:
The spec used to use the notation @@<symbol-name> to denote well-known symbols. For example, Symbol.hasInstance was written as @@hasInstance, and the Array.prototype[Symbol.iterator]() method would be called Array.prototype[@@iterator](). This notation is no longer used in the spec, but you may still see it in older documentation or discussions.

Well-known symbols do not have the concept of garbage collectability, because they come in a fixed set and are unique throughout the lifetime of the program, similar to intrinsic objects such as Array.prototype, so they are also allowed in WeakMap, WeakSet, WeakRef, and FinalizationRegistry objects.Finding Symbol properties on objectsThe method Object.getOwnPropertySymbols() returns an array of Symbols and lets you find Symbol properties on a given object. Note that every object is initialized with no own Symbol properties, so that this array will be empty unless you've set Symbol properties on the object.Constructor
Symbol()

Returns primitive values of type Symbol. Throws an error when called with new.

Static propertiesThe static properties are all well-known Symbols. In these Symbols' descriptions, we will use language like "Symbol.hasInstance is a method determining…", but bear in mind that this is referring to the semantic of an object's method having this Symbol as the method name (because well-known Symbols act as "protocols"), not describing the value of the Symbol itself.

Symbol.asyncIterator

A method that returns the default AsyncIterator for an object. Used by for await...of.

Symbol.hasInstance

A method determining if a constructor object recognizes an object as its instance. Used by instanceof.

Symbol.isConcatSpreadable

A Boolean value indicating if an object should be flattened to its array elements. Used by Array.prototype.concat().

Symbol.iterator

A method returning the default iterator for an object. Used by for...of.

Symbol.match

A method that matches against a string, also used to determine if an object may be used as a regular expression. Used by String.prototype.match().

Symbol.matchAll

A method that returns an iterator, that yields matches of the regular expression against a string. Used by String.prototype.matchAll().

Symbol.replace

A method that replaces matched substrings of a string. Used by String.prototype.replace().

Symbol.search

A method that returns the index within a string that matches the regular expression. Used by String.prototype.search().

Symbol.species

A constructor function that is used to create derived objects.

Symbol.split

A method that splits a string at the indices that match a regular expression. Used by String.prototype.split().

Symbol.toPrimitive

A method converting an object to a primitive value.

Symbol.toStringTag

A string value used for the default description of an object. Used by Object.prototype.toString().

Symbol.unscopables

An object value of whose own and inherited property names are excluded from the with environment bindings of the associated object.

Static methods
Symbol.for()

Searches for existing registered Symbols in the global Symbol registry with the given key and returns it if found. Otherwise a new Symbol gets created and registered with key.

Symbol.keyFor()

Retrieves a shared Symbol key from the global Symbol registry for the given Symbol.

Instance propertiesThese properties are defined on Symbol.prototype and shared by all Symbol instances.

Symbol.prototype.constructor

The constructor function that created the instance object. For Symbol instances, the initial value is the Symbol constructor.

Symbol.prototype.description

A read-only string containing the description of the Symbol.

Symbol.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Symbol". This property is used in Object.prototype.toString(). However, because Symbol also has its own toString() method, this property is not used unless you call Object.prototype.toString.call() with a symbol as thisArg.

Instance methods
Symbol.prototype.toString()

Returns a string containing the description of the Symbol. Overrides the Object.prototype.toString() method.

Symbol.prototype.valueOf()

Returns the Symbol. Overrides the Object.prototype.valueOf() method.

Symbol.prototype[Symbol.toPrimitive]()

Returns the Symbol.

ExamplesUsing the typeof operator with SymbolsThe typeof operator can help you to identify Symbols.
jstypeof Symbol() === "symbol";
typeof Symbol("foo") === "symbol";
typeof Symbol.iterator === "symbol";
Symbol type conversionsSome things to note when working with type conversion of Symbols.

When trying to convert a Symbol to a number, a TypeError will be thrown
(e.g., +sym or sym | 0).
When using loose equality, Object(sym) == sym returns true.
Symbol("foo") + "bar" throws a TypeError (can't convert Symbol to string). This prevents you from silently creating a new string property name from a Symbol, for example.
The "safer" String(sym) conversion works like a call to Symbol.prototype.toString() with Symbols, but note that new String(sym) will throw.
Symbols and for...in iterationSymbols are not enumerable in for...in iterations. In addition, Object.getOwnPropertyNames() will not return Symbol object properties, however, you can use Object.getOwnPropertySymbols() to get these.
jsconst obj = {};

obj[Symbol("a")] = "a";
obj[Symbol.for("b")] = "b";
obj["c"] = "c";
obj.d = "d";

for (const i in obj) {
  console.log(i);
}
// "c" "d"
Symbols and JSON.stringify()Symbol-keyed properties will be completely ignored when using JSON.stringify():
jsJSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'

For more details, see JSON.stringify().Symbol wrapper objects as property keysWhen a Symbol wrapper object is used as a property key, this object will be coerced to its wrapped Symbol:
jsconst sym = Symbol("foo");
const obj = { [sym]: 1 };
obj[sym]; // 1
obj[Object(sym)]; // still 1
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-symbol-objectsBrowser compatibilitySee also
Polyfill of Symbol in core-js
typeof
JavaScript data types and data structures
ES6 In Depth: Symbols on hacks.mozilla.org (2015)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nSymbolBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackSymbol is a built-in object whose constructor returns a symbol primitive — also called a Symbol value or just a Symbol — that's guaranteed to be unique. Symbols are often used to add unique property keys to an object that won't collide with keys any other code might add to the object, and which are hidden from any mechanisms other code will typically use to access the object. That enables a form of weak encapsulation, or a weak form of information hiding.
Every Symbol() call is guaranteed to return a unique Symbol. Every Symbol.for("key") call will always return the same Symbol for a given value of "key". When Symbol.for("key") is called, if a Symbol with the given key can be found in the global Symbol registry, that Symbol is returned. Otherwise, a new Symbol is created, added to the global Symbol registry under the given key, and returned.DescriptionTo create a new primitive Symbol, you write Symbol() with an optional string as its description:
jsconst sym1 = Symbol();
const sym2 = Symbol("foo");
const sym3 = Symbol("foo");

The above code creates three new Symbols. Note that Symbol("foo") does not coerce the string "foo" into a Symbol. It creates a new Symbol each time:
jsSymbol("foo") === Symbol("foo"); // false

The following syntax with the new operator will throw a TypeError:
jsconst sym = new Symbol(); // TypeError

This prevents authors from creating an explicit Symbol wrapper object instead of a new Symbol value and might be surprising as creating explicit wrapper objects around primitive data types is generally possible (for example, new Boolean, new String and new Number).
If you really want to create a Symbol wrapper object, you can use the Object() function:
jsconst sym = Symbol("foo");
typeof sym; // "symbol"
const symObj = Object(sym);
typeof symObj; // "object"

Because symbols are the only primitive data type that has reference identity (that is, you cannot create the same symbol twice), they behave like objects in some way. For example, they are garbage collectable and can therefore be stored in WeakMap, WeakSet, WeakRef, and FinalizationRegistry objects.Shared Symbols in the global Symbol registryThe above syntax using the Symbol() function will create a Symbol whose value remains unique throughout the lifetime of the program. To create Symbols available across files and even across realms (each of which has its own global scope), use the methods Symbol.for() and Symbol.keyFor() to set and retrieve Symbols from the global Symbol registry.
Note that the "global Symbol registry" is only a fictitious concept and may not correspond to any internal data structure in the JavaScript engine — and even if such a registry exists, its content is not available to the JavaScript code, except through the for() and keyFor() methods.
The method Symbol.for(tokenString) takes a string key and returns a symbol value from the registry, while Symbol.keyFor(symbolValue) takes a symbol value and returns the string key corresponding to it. Each is the other's inverse, so the following is true:
jsSymbol.keyFor(Symbol.for("tokenString")) === "tokenString"; // true

Because registered symbols can be arbitrarily created anywhere, they behave almost exactly like the strings they wrap. Therefore, they are not guaranteed to be unique and are not garbage collectable. Therefore, registered symbols are disallowed in WeakMap, WeakSet, WeakRef, and FinalizationRegistry objects.Well-known SymbolsAll static properties of the Symbol constructor are Symbols themselves, whose values are constant across realms. They are known as well-known Symbols, and their purpose is to serve as "protocols" for certain built-in JavaScript operations, allowing users to customize the language's behavior. For example, if a constructor function has a method with Symbol.hasInstance as its name, this method will encode its behavior with the instanceof operator.
Prior to well-known Symbols, JavaScript used normal properties to implement certain built-in operations. For example, the JSON.stringify function will attempt to call each object's toJSON() method, and the String function will call the object's toString() and valueOf() methods. However, as more operations are added to the language, designating each operation a "magic property" can break backward compatibility and make the language's behavior harder to reason with. Well-known Symbols allow the customizations to be "invisible" from normal code, which typically only read string properties.

Note:
The spec used to use the notation @@<symbol-name> to denote well-known symbols. For example, Symbol.hasInstance was written as @@hasInstance, and the Array.prototype[Symbol.iterator]() method would be called Array.prototype[@@iterator](). This notation is no longer used in the spec, but you may still see it in older documentation or discussions.

Well-known symbols do not have the concept of garbage collectability, because they come in a fixed set and are unique throughout the lifetime of the program, similar to intrinsic objects such as Array.prototype, so they are also allowed in WeakMap, WeakSet, WeakRef, and FinalizationRegistry objects.Finding Symbol properties on objectsThe method Object.getOwnPropertySymbols() returns an array of Symbols and lets you find Symbol properties on a given object. Note that every object is initialized with no own Symbol properties, so that this array will be empty unless you've set Symbol properties on the object.Constructor
Symbol()

Returns primitive values of type Symbol. Throws an error when called with new.

Static propertiesThe static properties are all well-known Symbols. In these Symbols' descriptions, we will use language like "Symbol.hasInstance is a method determining…", but bear in mind that this is referring to the semantic of an object's method having this Symbol as the method name (because well-known Symbols act as "protocols"), not describing the value of the Symbol itself.

Symbol.asyncIterator

A method that returns the default AsyncIterator for an object. Used by for await...of.

Symbol.hasInstance

A method determining if a constructor object recognizes an object as its instance. Used by instanceof.

Symbol.isConcatSpreadable

A Boolean value indicating if an object should be flattened to its array elements. Used by Array.prototype.concat().

Symbol.iterator

A method returning the default iterator for an object. Used by for...of.

Symbol.match

A method that matches against a string, also used to determine if an object may be used as a regular expression. Used by String.prototype.match().

Symbol.matchAll

A method that returns an iterator, that yields matches of the regular expression against a string. Used by String.prototype.matchAll().

Symbol.replace

A method that replaces matched substrings of a string. Used by String.prototype.replace().

Symbol.search

A method that returns the index within a string that matches the regular expression. Used by String.prototype.search().

Symbol.species

A constructor function that is used to create derived objects.

Symbol.split

A method that splits a string at the indices that match a regular expression. Used by String.prototype.split().

Symbol.toPrimitive

A method converting an object to a primitive value.

Symbol.toStringTag

A string value used for the default description of an object. Used by Object.prototype.toString().

Symbol.unscopables

An object value of whose own and inherited property names are excluded from the with environment bindings of the associated object.

Static methods
Symbol.for()

Searches for existing registered Symbols in the global Symbol registry with the given key and returns it if found. Otherwise a new Symbol gets created and registered with key.

Symbol.keyFor()

Retrieves a shared Symbol key from the global Symbol registry for the given Symbol.

Instance propertiesThese properties are defined on Symbol.prototype and shared by all Symbol instances.

Symbol.prototype.constructor

The constructor function that created the instance object. For Symbol instances, the initial value is the Symbol constructor.

Symbol.prototype.description

A read-only string containing the description of the Symbol.

Symbol.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Symbol". This property is used in Object.prototype.toString(). However, because Symbol also has its own toString() method, this property is not used unless you call Object.prototype.toString.call() with a symbol as thisArg.

Instance methods
Symbol.prototype.toString()

Returns a string containing the description of the Symbol. Overrides the Object.prototype.toString() method.

Symbol.prototype.valueOf()

Returns the Symbol. Overrides the Object.prototype.valueOf() method.

Symbol.prototype[Symbol.toPrimitive]()

Returns the Symbol.

ExamplesUsing the typeof operator with SymbolsThe typeof operator can help you to identify Symbols.
jstypeof Symbol() === "symbol";
typeof Symbol("foo") === "symbol";
typeof Symbol.iterator === "symbol";
Symbol type conversionsSome things to note when working with type conversion of Symbols.

When trying to convert a Symbol to a number, a TypeError will be thrown
(e.g., +sym or sym | 0).
When using loose equality, Object(sym) == sym returns true.
Symbol("foo") + "bar" throws a TypeError (can't convert Symbol to string). This prevents you from silently creating a new string property name from a Symbol, for example.
The "safer" String(sym) conversion works like a call to Symbol.prototype.toString() with Symbols, but note that new String(sym) will throw.
Symbols and for...in iterationSymbols are not enumerable in for...in iterations. In addition, Object.getOwnPropertyNames() will not return Symbol object properties, however, you can use Object.getOwnPropertySymbols() to get these.
jsconst obj = {};

obj[Symbol("a")] = "a";
obj[Symbol.for("b")] = "b";
obj["c"] = "c";
obj.d = "d";

for (const i in obj) {
  console.log(i);
}
// "c" "d"
Symbols and JSON.stringify()Symbol-keyed properties will be completely ignored when using JSON.stringify():
jsJSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'

For more details, see JSON.stringify().Symbol wrapper objects as property keysWhen a Symbol wrapper object is used as a property key, this object will be coerced to its wrapped Symbol:
jsconst sym = Symbol("foo");
const obj = { [sym]: 1 };
obj[sym]; // 1
obj[Object(sym)]; // still 1
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-symbol-objectsBrowser compatibilitySee also
Polyfill of Symbol in core-js
typeof
JavaScript data types and data structures
ES6 In Depth: Symbols on hacks.mozilla.org (2015)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nnullBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe null value represents the intentional absence of any object value. It
is one of JavaScript's primitive values and
is treated as falsy for boolean operations.Try it
function getVowels(str) {
  const m = str.match(/[aeiou]/gi);
  if (m === null) {
    return 0;
  }
  return m.length;
}

console.log(getVowels("sky"));
// Expected output: 0
Syntaxjsnull
DescriptionThe value null is written with a literal: null.
null is not an identifier for a property of the global object, like
undefined can be. Instead,
null expresses a lack of identification, indicating that a variable points
to no object. In APIs, null is often retrieved in a place where an object
can be expected but no object is relevant.
js// foo does not exist. It is not defined and has never been initialized:
foo; //ReferenceError: foo is not defined

js// foo is known to exist now but it has no type or value:
const foo = null;
foo; //null
ExamplesDifference between null and undefinedWhen checking for null or undefined, beware of the differences between equality (==) and identity (===) operators, as the former performs
type-conversion.
jstypeof null; // "object" (not "null" for legacy reasons)
typeof undefined; // "undefined"
null === undefined; // false
null == undefined; // true
null === null; // true
null == null; // true
!null; // true
Number.isNaN(1 + null); // false
Number.isNaN(1 + undefined); // true
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-null-valueBrowser compatibilitySee also
undefined
NaN
void\n\nnullBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe null value represents the intentional absence of any object value. It
is one of JavaScript's primitive values and
is treated as falsy for boolean operations.Try it
function getVowels(str) {
  const m = str.match(/[aeiou]/gi);
  if (m === null) {
    return 0;
  }
  return m.length;
}

console.log(getVowels("sky"));
// Expected output: 0
Syntaxjsnull
DescriptionThe value null is written with a literal: null.
null is not an identifier for a property of the global object, like
undefined can be. Instead,
null expresses a lack of identification, indicating that a variable points
to no object. In APIs, null is often retrieved in a place where an object
can be expected but no object is relevant.
js// foo does not exist. It is not defined and has never been initialized:
foo; //ReferenceError: foo is not defined

js// foo is known to exist now but it has no type or value:
const foo = null;
foo; //null
ExamplesDifference between null and undefinedWhen checking for null or undefined, beware of the differences between equality (==) and identity (===) operators, as the former performs
type-conversion.
jstypeof null; // "object" (not "null" for legacy reasons)
typeof undefined; // "undefined"
null === undefined; // false
null == undefined; // true
null === null; // true
null == null; // true
!null; // true
Number.isNaN(1 + null); // false
Number.isNaN(1 + undefined); // true
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-null-valueBrowser compatibilitySee also
undefined
NaN
void
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nnullBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe null value represents the intentional absence of any object value. It
is one of JavaScript's primitive values and
is treated as falsy for boolean operations.Try it
function getVowels(str) {
  const m = str.match(/[aeiou]/gi);
  if (m === null) {
    return 0;
  }
  return m.length;
}

console.log(getVowels("sky"));
// Expected output: 0
Syntaxjsnull
DescriptionThe value null is written with a literal: null.
null is not an identifier for a property of the global object, like
undefined can be. Instead,
null expresses a lack of identification, indicating that a variable points
to no object. In APIs, null is often retrieved in a place where an object
can be expected but no object is relevant.
js// foo does not exist. It is not defined and has never been initialized:
foo; //ReferenceError: foo is not defined

js// foo is known to exist now but it has no type or value:
const foo = null;
foo; //null
ExamplesDifference between null and undefinedWhen checking for null or undefined, beware of the differences between equality (==) and identity (===) operators, as the former performs
type-conversion.
jstypeof null; // "object" (not "null" for legacy reasons)
typeof undefined; // "undefined"
null === undefined; // false
null == undefined; // true
null === null; // true
null == null; // true
!null; // true
Number.isNaN(1 + null); // false
Number.isNaN(1 + undefined); // true
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-null-valueBrowser compatibilitySee also
undefined
NaN
void
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nTypeErrorBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe TypeError object represents an error when an operation could not be performed, typically (but not exclusively) when a value is not of the expected type.
A TypeError may be thrown when:

an operand or argument passed to a function is incompatible with the type expected by that operator or function; or
when attempting to modify a value that cannot be changed; or
when attempting to use a value in an inappropriate way.

TypeError is a serializable object, so it can be cloned with structuredClone() or copied between Workers using postMessage().
TypeError is a subclass of Error.Constructor
TypeError()

Creates a new TypeError object.

Instance propertiesAlso inherits instance properties from its parent Error.
These properties are defined on TypeError.prototype and shared by all TypeError instances.

TypeError.prototype.constructor

The constructor function that created the instance object. For TypeError instances, the initial value is the TypeError constructor.

TypeError.prototype.name

Represents the name for the type of error. For TypeError.prototype.name, the initial value is "TypeError".

Instance methodsInherits instance methods from its parent Error.ExamplesCatching a TypeErrorjstry {
  null.f();
} catch (e) {
  console.log(e instanceof TypeError); // true
  console.log(e.message); // "null has no properties"
  console.log(e.name); // "TypeError"
  console.log(e.stack); // Stack of the error
}
Creating a TypeErrorjstry {
  throw new TypeError("Hello");
} catch (e) {
  console.log(e instanceof TypeError); // true
  console.log(e.message); // "Hello"
  console.log(e.name); // "TypeError"
  console.log(e.stack); // Stack of the error
}
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-native-error-types-used-in-this-standard-typeerrorBrowser compatibilitySee also
Error\n\nTypeErrorBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe TypeError object represents an error when an operation could not be performed, typically (but not exclusively) when a value is not of the expected type.
A TypeError may be thrown when:

an operand or argument passed to a function is incompatible with the type expected by that operator or function; or
when attempting to modify a value that cannot be changed; or
when attempting to use a value in an inappropriate way.

TypeError is a serializable object, so it can be cloned with structuredClone() or copied between Workers using postMessage().
TypeError is a subclass of Error.Constructor
TypeError()

Creates a new TypeError object.

Instance propertiesAlso inherits instance properties from its parent Error.
These properties are defined on TypeError.prototype and shared by all TypeError instances.

TypeError.prototype.constructor

The constructor function that created the instance object. For TypeError instances, the initial value is the TypeError constructor.

TypeError.prototype.name

Represents the name for the type of error. For TypeError.prototype.name, the initial value is "TypeError".

Instance methodsInherits instance methods from its parent Error.ExamplesCatching a TypeErrorjstry {
  null.f();
} catch (e) {
  console.log(e instanceof TypeError); // true
  console.log(e.message); // "null has no properties"
  console.log(e.name); // "TypeError"
  console.log(e.stack); // Stack of the error
}
Creating a TypeErrorjstry {
  throw new TypeError("Hello");
} catch (e) {
  console.log(e instanceof TypeError); // true
  console.log(e.message); // "Hello"
  console.log(e.name); // "TypeError"
  console.log(e.stack); // Stack of the error
}
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-native-error-types-used-in-this-standard-typeerrorBrowser compatibilitySee also
Error
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Sep 26, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nTypeErrorBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe TypeError object represents an error when an operation could not be performed, typically (but not exclusively) when a value is not of the expected type.
A TypeError may be thrown when:

an operand or argument passed to a function is incompatible with the type expected by that operator or function; or
when attempting to modify a value that cannot be changed; or
when attempting to use a value in an inappropriate way.

TypeError is a serializable object, so it can be cloned with structuredClone() or copied between Workers using postMessage().
TypeError is a subclass of Error.Constructor
TypeError()

Creates a new TypeError object.

Instance propertiesAlso inherits instance properties from its parent Error.
These properties are defined on TypeError.prototype and shared by all TypeError instances.

TypeError.prototype.constructor

The constructor function that created the instance object. For TypeError instances, the initial value is the TypeError constructor.

TypeError.prototype.name

Represents the name for the type of error. For TypeError.prototype.name, the initial value is "TypeError".

Instance methodsInherits instance methods from its parent Error.ExamplesCatching a TypeErrorjstry {
  null.f();
} catch (e) {
  console.log(e instanceof TypeError); // true
  console.log(e.message); // "null has no properties"
  console.log(e.name); // "TypeError"
  console.log(e.stack); // Stack of the error
}
Creating a TypeErrorjstry {
  throw new TypeError("Hello");
} catch (e) {
  console.log(e instanceof TypeError); // true
  console.log(e.message); // "Hello"
  console.log(e.name); // "TypeError"
  console.log(e.stack); // Stack of the error
}
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-native-error-types-used-in-this-standard-typeerrorBrowser compatibilitySee also
Error
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Sep 26, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nBigIntBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2020.Learn moreSee full compatibilityReport feedbackBigInt values represent integer values which are too high or too low to be represented by the number primitive.DescriptionA BigInt value, also sometimes just called a BigInt, is a bigint primitive, created by appending n to the end of an integer literal, or by calling the BigInt() function (without the new operator) and giving it an integer value or string value.
jsconst previouslyMaxSafeInteger = 9007199254740991n;

const alsoHuge = BigInt(9007199254740991);
// 9007199254740991n

const hugeString = BigInt("9007199254740991");
// 9007199254740991n

const hugeHex = BigInt("0x1fffffffffffff");
// 9007199254740991n

const hugeOctal = BigInt("0o377777777777777777");
// 9007199254740991n

const hugeBin = BigInt(
  "0b11111111111111111111111111111111111111111111111111111",
);
// 9007199254740991n

BigInt values are similar to Number values in some ways, but also differ in a few key matters: A BigInt value cannot be used with methods in the built-in Math object and cannot be mixed with a Number value in operations; they must be coerced to the same type. Be careful coercing values back and forth, however, as the precision of a BigInt value may be lost when it is coerced to a Number value.Type informationWhen tested against typeof, a BigInt value (bigint primitive) will give "bigint":
jstypeof 1n === "bigint"; // true
typeof BigInt("1") === "bigint"; // true

A BigInt value can also be wrapped in an Object:
jstypeof Object(1n) === "object"; // true
OperatorsMost operators support BigInts, however most do not permit operands to be of mixed types — both operands must be BigInt or neither:

Arithmetic operators: +, -, *, /, %, **
Bitwise operators: >>, <<, &, |, ^, ~
Unary negation (-)
Increment/decrement: ++, --

The boolean-returning operators allow mixing numbers and BigInts as operands:

Relational operators and equality operators: >, <, >=, <=, ==, !=, ===, !==
Logical operators only rely on the truthiness of operands

A couple of operators do not support BigInt at all:

Unary plus (+) cannot be supported due to conflicting usage in asm.js, so it has been left out in order to not break asm.js.
Unsigned right shift (>>>) is the only bitwise operator that's unsupported, as every BigInt value is signed.

Special cases:

Addition (+) involving a string and a BigInt returns a string.
Division (/) truncates fractional components towards zero, since BigInt is unable to represent fractional quantities.

jsconst previousMaxSafe = BigInt(Number.MAX_SAFE_INTEGER); // 9007199254740991n
const maxPlusOne = previousMaxSafe + 1n; // 9007199254740992n
const theFuture = previousMaxSafe + 2n; // 9007199254740993n, this works now!
const prod = previousMaxSafe * 2n; // 18014398509481982n
const diff = prod - 10n; // 18014398509481972n
const mod = prod % 10n; // 2n
const bigN = 2n ** 54n; // 18014398509481984n
bigN * -1n; // -18014398509481984n
const expected = 4n / 2n; // 2n
const truncated = 5n / 2n; // 2n, not 2.5n
ComparisonsA BigInt value is not strictly equal to a Number value, but it is loosely so:
js0n === 0; // false
0n == 0; // true

A Number value and a BigInt value may be compared as usual:
js1n < 2; // true
2n > 1; // true
2 > 2; // false
2n > 2; // false
2n >= 2; // true

BigInt values and Number values may be mixed in arrays and sorted:
jsconst mixed = [4n, 6, -12n, 10, 4, 0, 0n];
// [4n, 6, -12n, 10, 4, 0, 0n]

mixed.sort(); // default sorting behavior
// [ -12n, 0, 0n, 10, 4n, 4, 6 ]

mixed.sort((a, b) => a - b);
// won't work since subtraction will not work with mixed types
// TypeError: can't convert BigInt value to Number value

// sort with an appropriate numeric comparator
mixed.sort((a, b) => (a < b ? -1 : a > b ? 1 : 0));
// [ -12n, 0, 0n, 4n, 4, 6, 10 ]

Note that comparisons with Object-wrapped BigInt values act as with other objects, only indicating equality when the same object instance is compared:
jsObject(0n) === 0n; // false
Object(0n) === Object(0n); // false

const o = Object(0n);
o === o; // true

Because coercing between Number values and BigInt values can lead to loss of precision, the following are recommended:

Only use a BigInt value when values greater than 253 are reasonably expected.
Don't coerce between BigInt values and Number values.
ConditionalsA BigInt value follows the same conversion rules as Numbers when:

it is converted to a Boolean: via the Boolean function;
when used with logical operators ||, &&, and !; or
within a conditional test like an if statement.

Namely, only 0n is falsy; everything else is truthy.
jsif (0n) {
  console.log("Hello from the if!");
} else {
  console.log("Hello from the else!");
}
// "Hello from the else!"

0n || 12n; // 12n
0n && 12n; // 0n
Boolean(0n); // false
Boolean(12n); // true
!12n; // false
!0n; // true
CryptographyThe operations supported on BigInt values are not constant-time and are thus open to timing attacks. JavaScript BigInts therefore could be dangerous for use in cryptography without mitigating factors. As a very generic example, an attacker could measure the time difference between 101n ** 65537n and 17n ** 9999n, and deduce the magnitude of secrets, such as private keys, based on the time elapsed. If you still have to use BigInts, take a look at the Timing attack FAQ for general advice regarding the issue.Use within JSONUsing JSON.stringify() with any BigInt value will raise a TypeError, as BigInt values aren't serialized in JSON by default. However, JSON.stringify() specifically leaves a backdoor for BigInt values: it would try to call the BigInt's toJSON() method. (It doesn't do so for any other primitive values.) Therefore, you can implement your own toJSON() method (which is one of the few cases where patching built-in objects is not explicitly discouraged):
jsBigInt.prototype.toJSON = function () {
  return { $bigint: this.toString() };
};

Instead of throwing, JSON.stringify() now produces a string like this:
jsconsole.log(JSON.stringify({ a: 1n }));
// {"a":{"$bigint":"1"}}

If you do not wish to patch BigInt.prototype, you can use the replacer parameter of JSON.stringify to serialize BigInt values:
jsconst replacer = (key, value) =>
  typeof value === "bigint" ? { $bigint: value.toString() } : value;

const data = {
  number: 1,
  big: 18014398509481982n,
};
const stringified = JSON.stringify(data, replacer);

console.log(stringified);
// {"number":1,"big":{"$bigint":"18014398509481982"}}

You can then use the reviver parameter of JSON.parse to handle them:
jsconst reviver = (key, value) =>
  value !== null &&
  typeof value === "object" &&
  "$bigint" in value &&
  typeof value.$bigint === "string"
    ? BigInt(value.$bigint)
    : value;

const payload = '{"number":1,"big":{"$bigint":"18014398509481982"}}';
const parsed = JSON.parse(payload, reviver);

console.log(parsed);
// { number: 1, big: 18014398509481982n }


Note:
While it's possible to make the replacer of JSON.stringify() generic and properly serialize BigInt values for all objects as shown above, the reviver of JSON.parse() has to be used with caution, because the serialization is irreversible: it's not possible to distinguish between an object that happens to have a property called $bigint and an actual BigInt.
In addition, the example above creates an entire object during replacing and reviving, which may have performance or storage implications for larger objects containing many BigInts. If you know the shape of the payload, it may be better to just serialize them as strings and revive them based on the property key's name instead.

In fact, JSON allows number literals that are arbitrarily long; they just cannot be parsed to full precision in JavaScript. If you are communicating with another program in a language that supports longer integers (such as 64-bit integers), and you want to transmit the BigInt as a JSON number instead of a JSON string, see Lossless number serialization.BigInt coercionMany built-in operations that expect BigInts first coerce their arguments to BigInts. The operation can be summarized as follows:

BigInts are returned as-is.
undefined and null throw a TypeError.
true turns into 1n; false turns into 0n.
Strings are converted by parsing them as if they contain an integer literal. Any parsing failure results in a SyntaxError. The syntax is a subset of string numeric literals, where decimal points or exponent indicators are not allowed.
Numbers throw a TypeError to prevent unintended implicit coercion causing loss of precision.
Symbols throw a TypeError.
Objects are first converted to a primitive by calling their [Symbol.toPrimitive]() (with "number" as hint), valueOf(), and toString() methods, in that order. The resulting primitive is then converted to a BigInt.

The best way to achieve nearly the same effect in JavaScript is through the BigInt() function: BigInt(x) uses the same algorithm to convert x, except that Numbers don't throw a TypeError, but are converted to BigInts if they are integers.
Note that built-in operations expecting BigInts often truncate the BigInt to a fixed width after coercion. This includes BigInt.asIntN(), BigInt.asUintN(), and methods of BigInt64Array and BigUint64Array.Constructor
BigInt()

Returns primitive values of type BigInt. Throws an error when called with new.

Static methods
BigInt.asIntN()

Clamps a BigInt value to a signed integer value, and returns that value.

BigInt.asUintN()

Clamps a BigInt value to an unsigned integer value, and returns that value.

Instance propertiesThese properties are defined on BigInt.prototype and shared by all BigInt instances.

BigInt.prototype.constructor

The constructor function that created the instance object. For BigInt instances, the initial value is the BigInt constructor.

BigInt.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "BigInt". This property is used in Object.prototype.toString(). However, because BigInt also has its own toString() method, this property is not used unless you call Object.prototype.toString.call() with a BigInt as thisArg.

Instance methods
BigInt.prototype.toLocaleString()

Returns a string with a language-sensitive representation of this BigInt value. Overrides the Object.prototype.toLocaleString() method.

BigInt.prototype.toString()

Returns a string representing this BigInt value in the specified radix (base). Overrides the Object.prototype.toString() method.

BigInt.prototype.valueOf()

Returns this BigInt value. Overrides the Object.prototype.valueOf() method.

ExamplesCalculating Primesjs// Returns true if the passed BigInt value is a prime number
function isPrime(p) {
  for (let i = 2n; i * i <= p; i++) {
    if (p % i === 0n) return false;
  }
  return true;
}

// Takes a BigInt value as an argument, returns nth prime number as a BigInt value
function nthPrime(nth) {
  let maybePrime = 2n;
  let prime = 0n;

  while (nth >= 0n) {
    if (isPrime(maybePrime)) {
      nth--;
      prime = maybePrime;
    }
    maybePrime++;
  }

  return prime;
}

nthPrime(20n);
// 73n
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-bigint-objectsBrowser compatibilitySee also
Number
Number.MAX_SAFE_INTEGER\n\nBigIntBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2020.Learn moreSee full compatibilityReport feedbackBigInt values represent integer values which are too high or too low to be represented by the number primitive.DescriptionA BigInt value, also sometimes just called a BigInt, is a bigint primitive, created by appending n to the end of an integer literal, or by calling the BigInt() function (without the new operator) and giving it an integer value or string value.
jsconst previouslyMaxSafeInteger = 9007199254740991n;

const alsoHuge = BigInt(9007199254740991);
// 9007199254740991n

const hugeString = BigInt("9007199254740991");
// 9007199254740991n

const hugeHex = BigInt("0x1fffffffffffff");
// 9007199254740991n

const hugeOctal = BigInt("0o377777777777777777");
// 9007199254740991n

const hugeBin = BigInt(
  "0b11111111111111111111111111111111111111111111111111111",
);
// 9007199254740991n

BigInt values are similar to Number values in some ways, but also differ in a few key matters: A BigInt value cannot be used with methods in the built-in Math object and cannot be mixed with a Number value in operations; they must be coerced to the same type. Be careful coercing values back and forth, however, as the precision of a BigInt value may be lost when it is coerced to a Number value.Type informationWhen tested against typeof, a BigInt value (bigint primitive) will give "bigint":
jstypeof 1n === "bigint"; // true
typeof BigInt("1") === "bigint"; // true

A BigInt value can also be wrapped in an Object:
jstypeof Object(1n) === "object"; // true
OperatorsMost operators support BigInts, however most do not permit operands to be of mixed types — both operands must be BigInt or neither:

Arithmetic operators: +, -, *, /, %, **
Bitwise operators: >>, <<, &, |, ^, ~
Unary negation (-)
Increment/decrement: ++, --

The boolean-returning operators allow mixing numbers and BigInts as operands:

Relational operators and equality operators: >, <, >=, <=, ==, !=, ===, !==
Logical operators only rely on the truthiness of operands

A couple of operators do not support BigInt at all:

Unary plus (+) cannot be supported due to conflicting usage in asm.js, so it has been left out in order to not break asm.js.
Unsigned right shift (>>>) is the only bitwise operator that's unsupported, as every BigInt value is signed.

Special cases:

Addition (+) involving a string and a BigInt returns a string.
Division (/) truncates fractional components towards zero, since BigInt is unable to represent fractional quantities.

jsconst previousMaxSafe = BigInt(Number.MAX_SAFE_INTEGER); // 9007199254740991n
const maxPlusOne = previousMaxSafe + 1n; // 9007199254740992n
const theFuture = previousMaxSafe + 2n; // 9007199254740993n, this works now!
const prod = previousMaxSafe * 2n; // 18014398509481982n
const diff = prod - 10n; // 18014398509481972n
const mod = prod % 10n; // 2n
const bigN = 2n ** 54n; // 18014398509481984n
bigN * -1n; // -18014398509481984n
const expected = 4n / 2n; // 2n
const truncated = 5n / 2n; // 2n, not 2.5n
ComparisonsA BigInt value is not strictly equal to a Number value, but it is loosely so:
js0n === 0; // false
0n == 0; // true

A Number value and a BigInt value may be compared as usual:
js1n < 2; // true
2n > 1; // true
2 > 2; // false
2n > 2; // false
2n >= 2; // true

BigInt values and Number values may be mixed in arrays and sorted:
jsconst mixed = [4n, 6, -12n, 10, 4, 0, 0n];
// [4n, 6, -12n, 10, 4, 0, 0n]

mixed.sort(); // default sorting behavior
// [ -12n, 0, 0n, 10, 4n, 4, 6 ]

mixed.sort((a, b) => a - b);
// won't work since subtraction will not work with mixed types
// TypeError: can't convert BigInt value to Number value

// sort with an appropriate numeric comparator
mixed.sort((a, b) => (a < b ? -1 : a > b ? 1 : 0));
// [ -12n, 0, 0n, 4n, 4, 6, 10 ]

Note that comparisons with Object-wrapped BigInt values act as with other objects, only indicating equality when the same object instance is compared:
jsObject(0n) === 0n; // false
Object(0n) === Object(0n); // false

const o = Object(0n);
o === o; // true

Because coercing between Number values and BigInt values can lead to loss of precision, the following are recommended:

Only use a BigInt value when values greater than 253 are reasonably expected.
Don't coerce between BigInt values and Number values.
ConditionalsA BigInt value follows the same conversion rules as Numbers when:

it is converted to a Boolean: via the Boolean function;
when used with logical operators ||, &&, and !; or
within a conditional test like an if statement.

Namely, only 0n is falsy; everything else is truthy.
jsif (0n) {
  console.log("Hello from the if!");
} else {
  console.log("Hello from the else!");
}
// "Hello from the else!"

0n || 12n; // 12n
0n && 12n; // 0n
Boolean(0n); // false
Boolean(12n); // true
!12n; // false
!0n; // true
CryptographyThe operations supported on BigInt values are not constant-time and are thus open to timing attacks. JavaScript BigInts therefore could be dangerous for use in cryptography without mitigating factors. As a very generic example, an attacker could measure the time difference between 101n ** 65537n and 17n ** 9999n, and deduce the magnitude of secrets, such as private keys, based on the time elapsed. If you still have to use BigInts, take a look at the Timing attack FAQ for general advice regarding the issue.Use within JSONUsing JSON.stringify() with any BigInt value will raise a TypeError, as BigInt values aren't serialized in JSON by default. However, JSON.stringify() specifically leaves a backdoor for BigInt values: it would try to call the BigInt's toJSON() method. (It doesn't do so for any other primitive values.) Therefore, you can implement your own toJSON() method (which is one of the few cases where patching built-in objects is not explicitly discouraged):
jsBigInt.prototype.toJSON = function () {
  return { $bigint: this.toString() };
};

Instead of throwing, JSON.stringify() now produces a string like this:
jsconsole.log(JSON.stringify({ a: 1n }));
// {"a":{"$bigint":"1"}}

If you do not wish to patch BigInt.prototype, you can use the replacer parameter of JSON.stringify to serialize BigInt values:
jsconst replacer = (key, value) =>
  typeof value === "bigint" ? { $bigint: value.toString() } : value;

const data = {
  number: 1,
  big: 18014398509481982n,
};
const stringified = JSON.stringify(data, replacer);

console.log(stringified);
// {"number":1,"big":{"$bigint":"18014398509481982"}}

You can then use the reviver parameter of JSON.parse to handle them:
jsconst reviver = (key, value) =>
  value !== null &&
  typeof value === "object" &&
  "$bigint" in value &&
  typeof value.$bigint === "string"
    ? BigInt(value.$bigint)
    : value;

const payload = '{"number":1,"big":{"$bigint":"18014398509481982"}}';
const parsed = JSON.parse(payload, reviver);

console.log(parsed);
// { number: 1, big: 18014398509481982n }


Note:
While it's possible to make the replacer of JSON.stringify() generic and properly serialize BigInt values for all objects as shown above, the reviver of JSON.parse() has to be used with caution, because the serialization is irreversible: it's not possible to distinguish between an object that happens to have a property called $bigint and an actual BigInt.
In addition, the example above creates an entire object during replacing and reviving, which may have performance or storage implications for larger objects containing many BigInts. If you know the shape of the payload, it may be better to just serialize them as strings and revive them based on the property key's name instead.

In fact, JSON allows number literals that are arbitrarily long; they just cannot be parsed to full precision in JavaScript. If you are communicating with another program in a language that supports longer integers (such as 64-bit integers), and you want to transmit the BigInt as a JSON number instead of a JSON string, see Lossless number serialization.BigInt coercionMany built-in operations that expect BigInts first coerce their arguments to BigInts. The operation can be summarized as follows:

BigInts are returned as-is.
undefined and null throw a TypeError.
true turns into 1n; false turns into 0n.
Strings are converted by parsing them as if they contain an integer literal. Any parsing failure results in a SyntaxError. The syntax is a subset of string numeric literals, where decimal points or exponent indicators are not allowed.
Numbers throw a TypeError to prevent unintended implicit coercion causing loss of precision.
Symbols throw a TypeError.
Objects are first converted to a primitive by calling their [Symbol.toPrimitive]() (with "number" as hint), valueOf(), and toString() methods, in that order. The resulting primitive is then converted to a BigInt.

The best way to achieve nearly the same effect in JavaScript is through the BigInt() function: BigInt(x) uses the same algorithm to convert x, except that Numbers don't throw a TypeError, but are converted to BigInts if they are integers.
Note that built-in operations expecting BigInts often truncate the BigInt to a fixed width after coercion. This includes BigInt.asIntN(), BigInt.asUintN(), and methods of BigInt64Array and BigUint64Array.Constructor
BigInt()

Returns primitive values of type BigInt. Throws an error when called with new.

Static methods
BigInt.asIntN()

Clamps a BigInt value to a signed integer value, and returns that value.

BigInt.asUintN()

Clamps a BigInt value to an unsigned integer value, and returns that value.

Instance propertiesThese properties are defined on BigInt.prototype and shared by all BigInt instances.

BigInt.prototype.constructor

The constructor function that created the instance object. For BigInt instances, the initial value is the BigInt constructor.

BigInt.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "BigInt". This property is used in Object.prototype.toString(). However, because BigInt also has its own toString() method, this property is not used unless you call Object.prototype.toString.call() with a BigInt as thisArg.

Instance methods
BigInt.prototype.toLocaleString()

Returns a string with a language-sensitive representation of this BigInt value. Overrides the Object.prototype.toLocaleString() method.

BigInt.prototype.toString()

Returns a string representing this BigInt value in the specified radix (base). Overrides the Object.prototype.toString() method.

BigInt.prototype.valueOf()

Returns this BigInt value. Overrides the Object.prototype.valueOf() method.

ExamplesCalculating Primesjs// Returns true if the passed BigInt value is a prime number
function isPrime(p) {
  for (let i = 2n; i * i <= p; i++) {
    if (p % i === 0n) return false;
  }
  return true;
}

// Takes a BigInt value as an argument, returns nth prime number as a BigInt value
function nthPrime(nth) {
  let maybePrime = 2n;
  let prime = 0n;

  while (nth >= 0n) {
    if (isPrime(maybePrime)) {
      nth--;
      prime = maybePrime;
    }
    maybePrime++;
  }

  return prime;
}

nthPrime(20n);
// 73n
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-bigint-objectsBrowser compatibilitySee also
Number
Number.MAX_SAFE_INTEGER
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nBigIntBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2020.Learn moreSee full compatibilityReport feedbackBigInt values represent integer values which are too high or too low to be represented by the number primitive.DescriptionA BigInt value, also sometimes just called a BigInt, is a bigint primitive, created by appending n to the end of an integer literal, or by calling the BigInt() function (without the new operator) and giving it an integer value or string value.
jsconst previouslyMaxSafeInteger = 9007199254740991n;

const alsoHuge = BigInt(9007199254740991);
// 9007199254740991n

const hugeString = BigInt("9007199254740991");
// 9007199254740991n

const hugeHex = BigInt("0x1fffffffffffff");
// 9007199254740991n

const hugeOctal = BigInt("0o377777777777777777");
// 9007199254740991n

const hugeBin = BigInt(
  "0b11111111111111111111111111111111111111111111111111111",
);
// 9007199254740991n

BigInt values are similar to Number values in some ways, but also differ in a few key matters: A BigInt value cannot be used with methods in the built-in Math object and cannot be mixed with a Number value in operations; they must be coerced to the same type. Be careful coercing values back and forth, however, as the precision of a BigInt value may be lost when it is coerced to a Number value.Type informationWhen tested against typeof, a BigInt value (bigint primitive) will give "bigint":
jstypeof 1n === "bigint"; // true
typeof BigInt("1") === "bigint"; // true

A BigInt value can also be wrapped in an Object:
jstypeof Object(1n) === "object"; // true
OperatorsMost operators support BigInts, however most do not permit operands to be of mixed types — both operands must be BigInt or neither:

Arithmetic operators: +, -, *, /, %, **
Bitwise operators: >>, <<, &, |, ^, ~
Unary negation (-)
Increment/decrement: ++, --

The boolean-returning operators allow mixing numbers and BigInts as operands:

Relational operators and equality operators: >, <, >=, <=, ==, !=, ===, !==
Logical operators only rely on the truthiness of operands

A couple of operators do not support BigInt at all:

Unary plus (+) cannot be supported due to conflicting usage in asm.js, so it has been left out in order to not break asm.js.
Unsigned right shift (>>>) is the only bitwise operator that's unsupported, as every BigInt value is signed.

Special cases:

Addition (+) involving a string and a BigInt returns a string.
Division (/) truncates fractional components towards zero, since BigInt is unable to represent fractional quantities.

jsconst previousMaxSafe = BigInt(Number.MAX_SAFE_INTEGER); // 9007199254740991n
const maxPlusOne = previousMaxSafe + 1n; // 9007199254740992n
const theFuture = previousMaxSafe + 2n; // 9007199254740993n, this works now!
const prod = previousMaxSafe * 2n; // 18014398509481982n
const diff = prod - 10n; // 18014398509481972n
const mod = prod % 10n; // 2n
const bigN = 2n ** 54n; // 18014398509481984n
bigN * -1n; // -18014398509481984n
const expected = 4n / 2n; // 2n
const truncated = 5n / 2n; // 2n, not 2.5n
ComparisonsA BigInt value is not strictly equal to a Number value, but it is loosely so:
js0n === 0; // false
0n == 0; // true

A Number value and a BigInt value may be compared as usual:
js1n < 2; // true
2n > 1; // true
2 > 2; // false
2n > 2; // false
2n >= 2; // true

BigInt values and Number values may be mixed in arrays and sorted:
jsconst mixed = [4n, 6, -12n, 10, 4, 0, 0n];
// [4n, 6, -12n, 10, 4, 0, 0n]

mixed.sort(); // default sorting behavior
// [ -12n, 0, 0n, 10, 4n, 4, 6 ]

mixed.sort((a, b) => a - b);
// won't work since subtraction will not work with mixed types
// TypeError: can't convert BigInt value to Number value

// sort with an appropriate numeric comparator
mixed.sort((a, b) => (a < b ? -1 : a > b ? 1 : 0));
// [ -12n, 0, 0n, 4n, 4, 6, 10 ]

Note that comparisons with Object-wrapped BigInt values act as with other objects, only indicating equality when the same object instance is compared:
jsObject(0n) === 0n; // false
Object(0n) === Object(0n); // false

const o = Object(0n);
o === o; // true

Because coercing between Number values and BigInt values can lead to loss of precision, the following are recommended:

Only use a BigInt value when values greater than 253 are reasonably expected.
Don't coerce between BigInt values and Number values.
ConditionalsA BigInt value follows the same conversion rules as Numbers when:

it is converted to a Boolean: via the Boolean function;
when used with logical operators ||, &&, and !; or
within a conditional test like an if statement.

Namely, only 0n is falsy; everything else is truthy.
jsif (0n) {
  console.log("Hello from the if!");
} else {
  console.log("Hello from the else!");
}
// "Hello from the else!"

0n || 12n; // 12n
0n && 12n; // 0n
Boolean(0n); // false
Boolean(12n); // true
!12n; // false
!0n; // true
CryptographyThe operations supported on BigInt values are not constant-time and are thus open to timing attacks. JavaScript BigInts therefore could be dangerous for use in cryptography without mitigating factors. As a very generic example, an attacker could measure the time difference between 101n ** 65537n and 17n ** 9999n, and deduce the magnitude of secrets, such as private keys, based on the time elapsed. If you still have to use BigInts, take a look at the Timing attack FAQ for general advice regarding the issue.Use within JSONUsing JSON.stringify() with any BigInt value will raise a TypeError, as BigInt values aren't serialized in JSON by default. However, JSON.stringify() specifically leaves a backdoor for BigInt values: it would try to call the BigInt's toJSON() method. (It doesn't do so for any other primitive values.) Therefore, you can implement your own toJSON() method (which is one of the few cases where patching built-in objects is not explicitly discouraged):
jsBigInt.prototype.toJSON = function () {
  return { $bigint: this.toString() };
};

Instead of throwing, JSON.stringify() now produces a string like this:
jsconsole.log(JSON.stringify({ a: 1n }));
// {"a":{"$bigint":"1"}}

If you do not wish to patch BigInt.prototype, you can use the replacer parameter of JSON.stringify to serialize BigInt values:
jsconst replacer = (key, value) =>
  typeof value === "bigint" ? { $bigint: value.toString() } : value;

const data = {
  number: 1,
  big: 18014398509481982n,
};
const stringified = JSON.stringify(data, replacer);

console.log(stringified);
// {"number":1,"big":{"$bigint":"18014398509481982"}}

You can then use the reviver parameter of JSON.parse to handle them:
jsconst reviver = (key, value) =>
  value !== null &&
  typeof value === "object" &&
  "$bigint" in value &&
  typeof value.$bigint === "string"
    ? BigInt(value.$bigint)
    : value;

const payload = '{"number":1,"big":{"$bigint":"18014398509481982"}}';
const parsed = JSON.parse(payload, reviver);

console.log(parsed);
// { number: 1, big: 18014398509481982n }


Note:
While it's possible to make the replacer of JSON.stringify() generic and properly serialize BigInt values for all objects as shown above, the reviver of JSON.parse() has to be used with caution, because the serialization is irreversible: it's not possible to distinguish between an object that happens to have a property called $bigint and an actual BigInt.
In addition, the example above creates an entire object during replacing and reviving, which may have performance or storage implications for larger objects containing many BigInts. If you know the shape of the payload, it may be better to just serialize them as strings and revive them based on the property key's name instead.

In fact, JSON allows number literals that are arbitrarily long; they just cannot be parsed to full precision in JavaScript. If you are communicating with another program in a language that supports longer integers (such as 64-bit integers), and you want to transmit the BigInt as a JSON number instead of a JSON string, see Lossless number serialization.BigInt coercionMany built-in operations that expect BigInts first coerce their arguments to BigInts. The operation can be summarized as follows:

BigInts are returned as-is.
undefined and null throw a TypeError.
true turns into 1n; false turns into 0n.
Strings are converted by parsing them as if they contain an integer literal. Any parsing failure results in a SyntaxError. The syntax is a subset of string numeric literals, where decimal points or exponent indicators are not allowed.
Numbers throw a TypeError to prevent unintended implicit coercion causing loss of precision.
Symbols throw a TypeError.
Objects are first converted to a primitive by calling their [Symbol.toPrimitive]() (with "number" as hint), valueOf(), and toString() methods, in that order. The resulting primitive is then converted to a BigInt.

The best way to achieve nearly the same effect in JavaScript is through the BigInt() function: BigInt(x) uses the same algorithm to convert x, except that Numbers don't throw a TypeError, but are converted to BigInts if they are integers.
Note that built-in operations expecting BigInts often truncate the BigInt to a fixed width after coercion. This includes BigInt.asIntN(), BigInt.asUintN(), and methods of BigInt64Array and BigUint64Array.Constructor
BigInt()

Returns primitive values of type BigInt. Throws an error when called with new.

Static methods
BigInt.asIntN()

Clamps a BigInt value to a signed integer value, and returns that value.

BigInt.asUintN()

Clamps a BigInt value to an unsigned integer value, and returns that value.

Instance propertiesThese properties are defined on BigInt.prototype and shared by all BigInt instances.

BigInt.prototype.constructor

The constructor function that created the instance object. For BigInt instances, the initial value is the BigInt constructor.

BigInt.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "BigInt". This property is used in Object.prototype.toString(). However, because BigInt also has its own toString() method, this property is not used unless you call Object.prototype.toString.call() with a BigInt as thisArg.

Instance methods
BigInt.prototype.toLocaleString()

Returns a string with a language-sensitive representation of this BigInt value. Overrides the Object.prototype.toLocaleString() method.

BigInt.prototype.toString()

Returns a string representing this BigInt value in the specified radix (base). Overrides the Object.prototype.toString() method.

BigInt.prototype.valueOf()

Returns this BigInt value. Overrides the Object.prototype.valueOf() method.

ExamplesCalculating Primesjs// Returns true if the passed BigInt value is a prime number
function isPrime(p) {
  for (let i = 2n; i * i <= p; i++) {
    if (p % i === 0n) return false;
  }
  return true;
}

// Takes a BigInt value as an argument, returns nth prime number as a BigInt value
function nthPrime(nth) {
  let maybePrime = 2n;
  let prime = 0n;

  while (nth >= 0n) {
    if (isPrime(maybePrime)) {
      nth--;
      prime = maybePrime;
    }
    maybePrime++;
  }

  return prime;
}

nthPrime(20n);
// 73n
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-bigint-objectsBrowser compatibilitySee also
Number
Number.MAX_SAFE_INTEGER
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nBooleanBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackBoolean values can be one of two values: true or false, representing the truth value of a logical proposition.DescriptionBoolean values are typically produced by relational operators, equality operators, and logical NOT (!). They can also be produced by functions that represent conditions, such as Array.isArray(). Note that binary logical operators such as && and || return the values of the operands, which may or may not be boolean values.
Boolean values are typically used in conditional testing, such as the condition for if...else and while statements, the conditional operator (? :), or the predicate return value of Array.prototype.filter().
You would rarely need to explicitly convert something to a boolean value, as JavaScript does this automatically in boolean contexts, so you can use any value as if it's a boolean, based on its truthiness. You are also encouraged to use if (condition) and if (!condition) instead of if (condition === true) or if (condition === false) in your own code so you can take advantage of this convention. However, making sure that values representing conditions are always booleans can help clarify the intent of your code.
js// Do this:
// This always returns a boolean value
const isObject = (obj) => !!obj && typeof obj === "object";

// Or this:
const isObject = (obj) => Boolean(obj) && typeof obj === "object";

// Or this:
const isObject = (obj) => obj !== null && typeof obj === "object";

// Instead of this:
// This may return falsy values that are not equal to false
const isObject = (obj) => obj && typeof obj === "object";
Boolean primitives and Boolean objectsFor converting non-boolean values to boolean, use Boolean as a function or use the double NOT operator. Do not use the Boolean() constructor with new.
jsconst good = Boolean(expression);
const good2 = !!expression;

jsconst bad = new Boolean(expression); // don't use this!

This is because all objects, including a Boolean object whose wrapped value is false, are truthy and evaluate to true in places such as conditional statements. (See also the boolean coercion section below.)
jsif (new Boolean(true)) {
  console.log("This log is printed.");
}

if (new Boolean(false)) {
  console.log("This log is ALSO printed.");
}

const myFalse = new Boolean(false); // myFalse is a Boolean object (not the primitive value false)
const g = Boolean(myFalse); // g is true
const myString = new String("Hello"); // myString is a String object
const s = Boolean(myString); // s is true


Warning:
You should rarely find yourself using Boolean as a constructor.
Boolean coercionMany built-in operations that expect booleans first coerce their arguments to booleans. The operation can be summarized as follows:

Booleans are returned as-is.
undefined turns into false.
null turns into false.
0, -0, and NaN turn into false; other numbers turn into true.
0n turns into false; other BigInts turn into true.
The empty string "" turns into false; other strings turn into true.
Symbols turn into true.
All objects become true.


Note:
A legacy behavior makes document.all return false when used as a boolean, despite it being an object. This property is legacy and non-standard and should not be used.


Note:
Unlike other type conversions like string coercion or number coercion, boolean coercion does not attempt to convert objects to primitives by calling user methods.

In other words, there are only a handful of values that get coerced to false — these are called falsy values. All other values are called truthy values. A value's truthiness is important when used with logical operators, conditional statements, or any boolean context.
There are two ways to achieve the same effect in JavaScript.

Double NOT: !!x negates x twice, which converts x to a boolean using the same algorithm as above.
The Boolean() function: Boolean(x) uses the same algorithm as above to convert x.

Note that truthiness is not the same as being loosely equal to true or false.
jsif ([]) {
  console.log("[] is truthy");
}
if ([] == false) {
  console.log("[] == false");
}
// [] is truthy
// [] == false

[] is truthy, but it's also loosely equal to false. It's truthy, because all objects are truthy. However, when comparing with false, which is a primitive, [] is also converted to a primitive, which is "" via Array.prototype.toString(). Comparing strings and booleans results in both being converted to numbers, and they both become 0, so [] == false is true. In general, falsiness and == false differ in the following cases:

NaN, undefined, and null are falsy but not loosely equal to false.
"0" (and other string literals that are not "" but get coerced to 0) is truthy but loosely equal to false.
Objects are always truthy, but their primitive representation may be loosely equal to false.

Truthy values are even more unlikely to be loosely equal to true. All values are either truthy or falsy, but most values are loosely equal to neither true nor false.Constructor
Boolean()

Creates Boolean objects. When called as a function, it returns primitive values of type Boolean.

Instance propertiesThese properties are defined on Boolean.prototype and shared by all Boolean instances.

Boolean.prototype.constructor

The constructor function that created the instance object. For Boolean instances, the initial value is the Boolean constructor.

Instance methods
Boolean.prototype.toString()

Returns a string of either true or false depending upon the value of the object. Overrides the Object.prototype.toString() method.

Boolean.prototype.valueOf()

Returns the primitive value of the Boolean object. Overrides the Object.prototype.valueOf() method.

ExamplesCreating false valuesjsconst bNoParam = Boolean();
const bZero = Boolean(0);
const bNull = Boolean(null);
const bEmptyString = Boolean("");
const bfalse = Boolean(false);
Creating true valuesjsconst btrue = Boolean(true);
const btrueString = Boolean("true");
const bfalseString = Boolean("false");
const bSuLin = Boolean("Su Lin");
const bArrayProto = Boolean([]);
const bObjProto = Boolean({});
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-boolean-objectsBrowser compatibilitySee also
Boolean
Boolean primitives
Boolean data type on Wikipedia\n\nBooleanBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackBoolean values can be one of two values: true or false, representing the truth value of a logical proposition.DescriptionBoolean values are typically produced by relational operators, equality operators, and logical NOT (!). They can also be produced by functions that represent conditions, such as Array.isArray(). Note that binary logical operators such as && and || return the values of the operands, which may or may not be boolean values.
Boolean values are typically used in conditional testing, such as the condition for if...else and while statements, the conditional operator (? :), or the predicate return value of Array.prototype.filter().
You would rarely need to explicitly convert something to a boolean value, as JavaScript does this automatically in boolean contexts, so you can use any value as if it's a boolean, based on its truthiness. You are also encouraged to use if (condition) and if (!condition) instead of if (condition === true) or if (condition === false) in your own code so you can take advantage of this convention. However, making sure that values representing conditions are always booleans can help clarify the intent of your code.
js// Do this:
// This always returns a boolean value
const isObject = (obj) => !!obj && typeof obj === "object";

// Or this:
const isObject = (obj) => Boolean(obj) && typeof obj === "object";

// Or this:
const isObject = (obj) => obj !== null && typeof obj === "object";

// Instead of this:
// This may return falsy values that are not equal to false
const isObject = (obj) => obj && typeof obj === "object";
Boolean primitives and Boolean objectsFor converting non-boolean values to boolean, use Boolean as a function or use the double NOT operator. Do not use the Boolean() constructor with new.
jsconst good = Boolean(expression);
const good2 = !!expression;

jsconst bad = new Boolean(expression); // don't use this!

This is because all objects, including a Boolean object whose wrapped value is false, are truthy and evaluate to true in places such as conditional statements. (See also the boolean coercion section below.)
jsif (new Boolean(true)) {
  console.log("This log is printed.");
}

if (new Boolean(false)) {
  console.log("This log is ALSO printed.");
}

const myFalse = new Boolean(false); // myFalse is a Boolean object (not the primitive value false)
const g = Boolean(myFalse); // g is true
const myString = new String("Hello"); // myString is a String object
const s = Boolean(myString); // s is true


Warning:
You should rarely find yourself using Boolean as a constructor.
Boolean coercionMany built-in operations that expect booleans first coerce their arguments to booleans. The operation can be summarized as follows:

Booleans are returned as-is.
undefined turns into false.
null turns into false.
0, -0, and NaN turn into false; other numbers turn into true.
0n turns into false; other BigInts turn into true.
The empty string "" turns into false; other strings turn into true.
Symbols turn into true.
All objects become true.


Note:
A legacy behavior makes document.all return false when used as a boolean, despite it being an object. This property is legacy and non-standard and should not be used.


Note:
Unlike other type conversions like string coercion or number coercion, boolean coercion does not attempt to convert objects to primitives by calling user methods.

In other words, there are only a handful of values that get coerced to false — these are called falsy values. All other values are called truthy values. A value's truthiness is important when used with logical operators, conditional statements, or any boolean context.
There are two ways to achieve the same effect in JavaScript.

Double NOT: !!x negates x twice, which converts x to a boolean using the same algorithm as above.
The Boolean() function: Boolean(x) uses the same algorithm as above to convert x.

Note that truthiness is not the same as being loosely equal to true or false.
jsif ([]) {
  console.log("[] is truthy");
}
if ([] == false) {
  console.log("[] == false");
}
// [] is truthy
// [] == false

[] is truthy, but it's also loosely equal to false. It's truthy, because all objects are truthy. However, when comparing with false, which is a primitive, [] is also converted to a primitive, which is "" via Array.prototype.toString(). Comparing strings and booleans results in both being converted to numbers, and they both become 0, so [] == false is true. In general, falsiness and == false differ in the following cases:

NaN, undefined, and null are falsy but not loosely equal to false.
"0" (and other string literals that are not "" but get coerced to 0) is truthy but loosely equal to false.
Objects are always truthy, but their primitive representation may be loosely equal to false.

Truthy values are even more unlikely to be loosely equal to true. All values are either truthy or falsy, but most values are loosely equal to neither true nor false.Constructor
Boolean()

Creates Boolean objects. When called as a function, it returns primitive values of type Boolean.

Instance propertiesThese properties are defined on Boolean.prototype and shared by all Boolean instances.

Boolean.prototype.constructor

The constructor function that created the instance object. For Boolean instances, the initial value is the Boolean constructor.

Instance methods
Boolean.prototype.toString()

Returns a string of either true or false depending upon the value of the object. Overrides the Object.prototype.toString() method.

Boolean.prototype.valueOf()

Returns the primitive value of the Boolean object. Overrides the Object.prototype.valueOf() method.

ExamplesCreating false valuesjsconst bNoParam = Boolean();
const bZero = Boolean(0);
const bNull = Boolean(null);
const bEmptyString = Boolean("");
const bfalse = Boolean(false);
Creating true valuesjsconst btrue = Boolean(true);
const btrueString = Boolean("true");
const bfalseString = Boolean("false");
const bSuLin = Boolean("Su Lin");
const bArrayProto = Boolean([]);
const bObjProto = Boolean({});
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-boolean-objectsBrowser compatibilitySee also
Boolean
Boolean primitives
Boolean data type on Wikipedia
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nBooleanBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackBoolean values can be one of two values: true or false, representing the truth value of a logical proposition.DescriptionBoolean values are typically produced by relational operators, equality operators, and logical NOT (!). They can also be produced by functions that represent conditions, such as Array.isArray(). Note that binary logical operators such as && and || return the values of the operands, which may or may not be boolean values.
Boolean values are typically used in conditional testing, such as the condition for if...else and while statements, the conditional operator (? :), or the predicate return value of Array.prototype.filter().
You would rarely need to explicitly convert something to a boolean value, as JavaScript does this automatically in boolean contexts, so you can use any value as if it's a boolean, based on its truthiness. You are also encouraged to use if (condition) and if (!condition) instead of if (condition === true) or if (condition === false) in your own code so you can take advantage of this convention. However, making sure that values representing conditions are always booleans can help clarify the intent of your code.
js// Do this:
// This always returns a boolean value
const isObject = (obj) => !!obj && typeof obj === "object";

// Or this:
const isObject = (obj) => Boolean(obj) && typeof obj === "object";

// Or this:
const isObject = (obj) => obj !== null && typeof obj === "object";

// Instead of this:
// This may return falsy values that are not equal to false
const isObject = (obj) => obj && typeof obj === "object";
Boolean primitives and Boolean objectsFor converting non-boolean values to boolean, use Boolean as a function or use the double NOT operator. Do not use the Boolean() constructor with new.
jsconst good = Boolean(expression);
const good2 = !!expression;

jsconst bad = new Boolean(expression); // don't use this!

This is because all objects, including a Boolean object whose wrapped value is false, are truthy and evaluate to true in places such as conditional statements. (See also the boolean coercion section below.)
jsif (new Boolean(true)) {
  console.log("This log is printed.");
}

if (new Boolean(false)) {
  console.log("This log is ALSO printed.");
}

const myFalse = new Boolean(false); // myFalse is a Boolean object (not the primitive value false)
const g = Boolean(myFalse); // g is true
const myString = new String("Hello"); // myString is a String object
const s = Boolean(myString); // s is true


Warning:
You should rarely find yourself using Boolean as a constructor.
Boolean coercionMany built-in operations that expect booleans first coerce their arguments to booleans. The operation can be summarized as follows:

Booleans are returned as-is.
undefined turns into false.
null turns into false.
0, -0, and NaN turn into false; other numbers turn into true.
0n turns into false; other BigInts turn into true.
The empty string "" turns into false; other strings turn into true.
Symbols turn into true.
All objects become true.


Note:
A legacy behavior makes document.all return false when used as a boolean, despite it being an object. This property is legacy and non-standard and should not be used.


Note:
Unlike other type conversions like string coercion or number coercion, boolean coercion does not attempt to convert objects to primitives by calling user methods.

In other words, there are only a handful of values that get coerced to false — these are called falsy values. All other values are called truthy values. A value's truthiness is important when used with logical operators, conditional statements, or any boolean context.
There are two ways to achieve the same effect in JavaScript.

Double NOT: !!x negates x twice, which converts x to a boolean using the same algorithm as above.
The Boolean() function: Boolean(x) uses the same algorithm as above to convert x.

Note that truthiness is not the same as being loosely equal to true or false.
jsif ([]) {
  console.log("[] is truthy");
}
if ([] == false) {
  console.log("[] == false");
}
// [] is truthy
// [] == false

[] is truthy, but it's also loosely equal to false. It's truthy, because all objects are truthy. However, when comparing with false, which is a primitive, [] is also converted to a primitive, which is "" via Array.prototype.toString(). Comparing strings and booleans results in both being converted to numbers, and they both become 0, so [] == false is true. In general, falsiness and == false differ in the following cases:

NaN, undefined, and null are falsy but not loosely equal to false.
"0" (and other string literals that are not "" but get coerced to 0) is truthy but loosely equal to false.
Objects are always truthy, but their primitive representation may be loosely equal to false.

Truthy values are even more unlikely to be loosely equal to true. All values are either truthy or falsy, but most values are loosely equal to neither true nor false.Constructor
Boolean()

Creates Boolean objects. When called as a function, it returns primitive values of type Boolean.

Instance propertiesThese properties are defined on Boolean.prototype and shared by all Boolean instances.

Boolean.prototype.constructor

The constructor function that created the instance object. For Boolean instances, the initial value is the Boolean constructor.

Instance methods
Boolean.prototype.toString()

Returns a string of either true or false depending upon the value of the object. Overrides the Object.prototype.toString() method.

Boolean.prototype.valueOf()

Returns the primitive value of the Boolean object. Overrides the Object.prototype.valueOf() method.

ExamplesCreating false valuesjsconst bNoParam = Boolean();
const bZero = Boolean(0);
const bNull = Boolean(null);
const bEmptyString = Boolean("");
const bfalse = Boolean(false);
Creating true valuesjsconst btrue = Boolean(true);
const btrueString = Boolean("true");
const bfalseString = Boolean("false");
const bSuLin = Boolean("Su Lin");
const bArrayProto = Boolean([]);
const bObjProto = Boolean({});
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-boolean-objectsBrowser compatibilitySee also
Boolean
Boolean primitives
Boolean data type on Wikipedia
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nNumberBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackNumber values represent floating-point numbers like 37 or -9.25.
The Number constructor contains constants and methods for working with numbers. Values of other types can be converted to numbers using the Number() function.DescriptionNumbers are most commonly expressed in literal forms like 255 or 3.14159. The lexical grammar contains a more detailed reference.
js255; // two-hundred and fifty-five
255.0; // same number
255 === 255.0; // true
255 === 0xff; // true (hexadecimal notation)
255 === 0b11111111; // true (binary notation)
255 === 0.255e3; // true (decimal exponential notation)

A number literal like 37 in JavaScript code is a floating-point value, not an integer. There is no separate integer type in common everyday use. (JavaScript also has a BigInt type, but it's not designed to replace Number for everyday uses. 37 is still a number, not a BigInt.)
When used as a function, Number(value) converts a string or other value to the Number type. If the value can't be converted, it returns NaN.
jsNumber("123"); // returns the number 123
Number("123") === 123; // true

Number("unicorn"); // NaN
Number(undefined); // NaN
Number encodingThe JavaScript Number type is a double-precision 64-bit binary format IEEE 754 value, like double in Java or C#. This means it can represent fractional values, but there are some limits to the stored number's magnitude and precision. Very briefly, an IEEE 754 double-precision number uses 64 bits to represent 3 parts:

1 bit for the sign (positive or negative)
11 bits for the exponent (-1022 to 1023)
52 bits for the mantissa (representing a number between 0 and 1)

The mantissa (also called significand) is the part of the number representing the actual value (significant digits). The exponent is the power of 2 that the mantissa should be multiplied by. Thinking about it as scientific notation:


  Number=(−1)sign⋅(1+mantissa)⋅2exponent\text{Number} = ({-1})^{\text{sign}} \cdot (1 + \text{mantissa}) \cdot 2^{\text{exponent}}


The mantissa is stored with 52 bits, interpreted as digits after 1.… in a binary fractional number. Therefore, the mantissa's precision is 2-52 (obtainable via Number.EPSILON), or about 15 to 17 decimal places; arithmetic above that level of precision is subject to rounding.
The largest value a number can hold is 21023 × (2 - 2-52) (with the exponent being 1023 and the mantissa being 0.1111… in base 2), which is obtainable via Number.MAX_VALUE. Values higher than that are replaced with the special number constant Infinity.
Integers can only be represented without loss of precision in the range -253 + 1 to 253 - 1, inclusive (obtainable via Number.MIN_SAFE_INTEGER and Number.MAX_SAFE_INTEGER), because the mantissa can only hold 53 bits (including the leading 1).
More details on this are described in the ECMAScript standard.Number coercionMany built-in operations that expect numbers first coerce their arguments to numbers (which is largely why Number objects behave similarly to number primitives). The operation can be summarized as follows:

Numbers are returned as-is.
undefined turns into NaN.
null turns into 0.
true turns into 1; false turns into 0.
Strings are converted by parsing them as if they contain a number literal. Parsing failure results in NaN. There are some minor differences compared to an actual number literal:

Leading and trailing whitespace/line terminators are ignored.
A leading 0 digit does not cause the number to become an octal literal (or get rejected in strict mode).
+ and - are allowed at the start of the string to indicate its sign. (In actual code, they "look like" part of the literal, but are actually separate unary operators.) However, the sign can only appear once, and must not be followed by whitespace.
Infinity and -Infinity are recognized as literals. In actual code, they are global variables.
Empty or whitespace-only strings are converted to 0.
Numeric separators are not allowed.


BigInts throw a TypeError to prevent unintended implicit coercion causing loss of precision.
Symbols throw a TypeError.
Objects are first converted to a primitive by calling their [Symbol.toPrimitive]() (with "number" as hint), valueOf(), and toString() methods, in that order. The resulting primitive is then converted to a number.

There are two ways to achieve nearly the same effect in JavaScript.

Unary plus: +x does exactly the number coercion steps explained above to convert x.
The Number() function: Number(x) uses the same algorithm to convert x, except that BigInts don't throw a TypeError, but return their number value, with possible loss of precision.

Number.parseFloat() and Number.parseInt() are similar to Number() but only convert strings, and have slightly different parsing rules. For example, parseInt() doesn't recognize the decimal point, and parseFloat() doesn't recognize the 0x prefix.
Integer conversion
Some operations expect integers, most notably those that work with array/string indices, date/time components, and number radixes. After performing the number coercion steps above, the result is truncated to an integer (by discarding the fractional part). If the number is ±Infinity, it's returned as-is. If the number is NaN or -0, it's returned as 0. The result is therefore always an integer (which is not -0) or ±Infinity.
Notably, when converted to integers, both undefined and null become 0, because undefined is converted to NaN, which also becomes 0.
Fixed-width number conversion
JavaScript has some lower-level functions that deal with the binary encoding of integer numbers, most notably bitwise operators and TypedArray objects. Bitwise operators always convert the operands to 32-bit integers. In these cases, after converting the value to a number, the number is then normalized to the given width by first truncating the fractional part and then taking the lowest bits in the integer's two's complement encoding.
jsnew Int32Array([1.1, 1.9, -1.1, -1.9]); // Int32Array(4) [ 1, 1, -1, -1 ]

new Int8Array([257, -257]); // Int8Array(2) [ 1, -1 ]
// 257 = 0001 0000 0001
//     =      0000 0001 (mod 2^8)
//     = 1
// -257 = 1110 1111 1111
//      =      1111 1111 (mod 2^8)
//      = -1 (as signed integer)

new Uint8Array([257, -257]); // Uint8Array(2) [ 1, 255 ]
// -257 = 1110 1111 1111
//      =      1111 1111 (mod 2^8)
//      = 255 (as unsigned integer)
Constructor
Number()

Creates Number objects. When called as a function, it returns primitive values of type Number.

Static properties
Number.EPSILON

The smallest interval between two representable numbers.

Number.MAX_SAFE_INTEGER

The maximum safe integer in JavaScript (253 - 1).

Number.MAX_VALUE

The largest positive representable number.

Number.MIN_SAFE_INTEGER

The minimum safe integer in JavaScript (-(253 - 1)).

Number.MIN_VALUE

The smallest positive representable number—that is, the positive number closest to zero (without actually being zero).

Number.NaN

Special "Not a Number" value.

Number.NEGATIVE_INFINITY

Special value representing negative infinity. Returned on overflow.

Number.POSITIVE_INFINITY

Special value representing infinity. Returned on overflow.

Static methods
Number.isFinite()

Determine whether the passed value is a finite number.

Number.isInteger()

Determine whether the passed value is an integer.

Number.isNaN()

Determine whether the passed value is NaN.

Number.isSafeInteger()

Determine whether the passed value is a safe integer (number between -(253 - 1) and 253 - 1).

Number.parseFloat()

This is the same as the global parseFloat() function.

Number.parseInt()

This is the same as the global parseInt() function.

Instance propertiesThese properties are defined on Number.prototype and shared by all Number instances.

Number.prototype.constructor

The constructor function that created the instance object. For Number instances, the initial value is the Number constructor.

Instance methods
Number.prototype.toExponential()

Returns a string representing the number in exponential notation.

Number.prototype.toFixed()

Returns a string representing the number in fixed-point notation.

Number.prototype.toLocaleString()

Returns a string with a language sensitive representation of this number. Overrides the Object.prototype.toLocaleString() method.

Number.prototype.toPrecision()

Returns a string representing the number to a specified precision in fixed-point or exponential notation.

Number.prototype.toString()

Returns a string representing the specified object in the specified radix ("base"). Overrides the Object.prototype.toString() method.

Number.prototype.valueOf()

Returns the primitive value of the specified object. Overrides the Object.prototype.valueOf() method.

ExamplesUsing the Number object to assign values to numeric variablesThe following example uses the Number object's properties to assign values to several numeric variables:
jsconst biggestNum = Number.MAX_VALUE;
const smallestNum = Number.MIN_VALUE;
const infiniteNum = Number.POSITIVE_INFINITY;
const negInfiniteNum = Number.NEGATIVE_INFINITY;
const notANum = Number.NaN;
Integer range for NumberThe following example shows the minimum and maximum integer values that can be represented as Number object.
jsconst biggestInt = Number.MAX_SAFE_INTEGER; // (2**53 - 1) => 9007199254740991
const smallestInt = Number.MIN_SAFE_INTEGER; // -(2**53 - 1) => -9007199254740991

When parsing data that has been serialized to JSON, integer values falling outside of this range can be expected to become corrupted when JSON parser coerces them to Number type.
A possible workaround is to use String instead.
Larger numbers can be represented using the BigInt type.Using Number() to convert a Date objectThe following example converts the Date object to a numerical value using Number as a function:
jsconst d = new Date("1995-12-17T03:24:00");
console.log(Number(d));

This logs 819199440000.Convert numeric strings and null to numbersjsNumber("123"); // 123
Number("123") === 123; // true
Number("12.3"); // 12.3
Number("12.00"); // 12
Number("123e-1"); // 12.3
Number(""); // 0
Number(null); // 0
Number("0x11"); // 17
Number("0b11"); // 3
Number("0o11"); // 9
Number("foo"); // NaN
Number("100a"); // NaN
Number("-Infinity"); // -Infinity
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-number-objectsBrowser compatibilitySee also
Polyfill of modern Number behavior (with support binary and octal literals) in core-js
NaN
Arithmetic operators
Math
BigInt\n\nNumberBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackNumber values represent floating-point numbers like 37 or -9.25.
The Number constructor contains constants and methods for working with numbers. Values of other types can be converted to numbers using the Number() function.DescriptionNumbers are most commonly expressed in literal forms like 255 or 3.14159. The lexical grammar contains a more detailed reference.
js255; // two-hundred and fifty-five
255.0; // same number
255 === 255.0; // true
255 === 0xff; // true (hexadecimal notation)
255 === 0b11111111; // true (binary notation)
255 === 0.255e3; // true (decimal exponential notation)

A number literal like 37 in JavaScript code is a floating-point value, not an integer. There is no separate integer type in common everyday use. (JavaScript also has a BigInt type, but it's not designed to replace Number for everyday uses. 37 is still a number, not a BigInt.)
When used as a function, Number(value) converts a string or other value to the Number type. If the value can't be converted, it returns NaN.
jsNumber("123"); // returns the number 123
Number("123") === 123; // true

Number("unicorn"); // NaN
Number(undefined); // NaN
Number encodingThe JavaScript Number type is a double-precision 64-bit binary format IEEE 754 value, like double in Java or C#. This means it can represent fractional values, but there are some limits to the stored number's magnitude and precision. Very briefly, an IEEE 754 double-precision number uses 64 bits to represent 3 parts:

1 bit for the sign (positive or negative)
11 bits for the exponent (-1022 to 1023)
52 bits for the mantissa (representing a number between 0 and 1)

The mantissa (also called significand) is the part of the number representing the actual value (significant digits). The exponent is the power of 2 that the mantissa should be multiplied by. Thinking about it as scientific notation:


  Number=(−1)sign⋅(1+mantissa)⋅2exponent\text{Number} = ({-1})^{\text{sign}} \cdot (1 + \text{mantissa}) \cdot 2^{\text{exponent}}


The mantissa is stored with 52 bits, interpreted as digits after 1.… in a binary fractional number. Therefore, the mantissa's precision is 2-52 (obtainable via Number.EPSILON), or about 15 to 17 decimal places; arithmetic above that level of precision is subject to rounding.
The largest value a number can hold is 21023 × (2 - 2-52) (with the exponent being 1023 and the mantissa being 0.1111… in base 2), which is obtainable via Number.MAX_VALUE. Values higher than that are replaced with the special number constant Infinity.
Integers can only be represented without loss of precision in the range -253 + 1 to 253 - 1, inclusive (obtainable via Number.MIN_SAFE_INTEGER and Number.MAX_SAFE_INTEGER), because the mantissa can only hold 53 bits (including the leading 1).
More details on this are described in the ECMAScript standard.Number coercionMany built-in operations that expect numbers first coerce their arguments to numbers (which is largely why Number objects behave similarly to number primitives). The operation can be summarized as follows:

Numbers are returned as-is.
undefined turns into NaN.
null turns into 0.
true turns into 1; false turns into 0.
Strings are converted by parsing them as if they contain a number literal. Parsing failure results in NaN. There are some minor differences compared to an actual number literal:

Leading and trailing whitespace/line terminators are ignored.
A leading 0 digit does not cause the number to become an octal literal (or get rejected in strict mode).
+ and - are allowed at the start of the string to indicate its sign. (In actual code, they "look like" part of the literal, but are actually separate unary operators.) However, the sign can only appear once, and must not be followed by whitespace.
Infinity and -Infinity are recognized as literals. In actual code, they are global variables.
Empty or whitespace-only strings are converted to 0.
Numeric separators are not allowed.


BigInts throw a TypeError to prevent unintended implicit coercion causing loss of precision.
Symbols throw a TypeError.
Objects are first converted to a primitive by calling their [Symbol.toPrimitive]() (with "number" as hint), valueOf(), and toString() methods, in that order. The resulting primitive is then converted to a number.

There are two ways to achieve nearly the same effect in JavaScript.

Unary plus: +x does exactly the number coercion steps explained above to convert x.
The Number() function: Number(x) uses the same algorithm to convert x, except that BigInts don't throw a TypeError, but return their number value, with possible loss of precision.

Number.parseFloat() and Number.parseInt() are similar to Number() but only convert strings, and have slightly different parsing rules. For example, parseInt() doesn't recognize the decimal point, and parseFloat() doesn't recognize the 0x prefix.
Integer conversion
Some operations expect integers, most notably those that work with array/string indices, date/time components, and number radixes. After performing the number coercion steps above, the result is truncated to an integer (by discarding the fractional part). If the number is ±Infinity, it's returned as-is. If the number is NaN or -0, it's returned as 0. The result is therefore always an integer (which is not -0) or ±Infinity.
Notably, when converted to integers, both undefined and null become 0, because undefined is converted to NaN, which also becomes 0.
Fixed-width number conversion
JavaScript has some lower-level functions that deal with the binary encoding of integer numbers, most notably bitwise operators and TypedArray objects. Bitwise operators always convert the operands to 32-bit integers. In these cases, after converting the value to a number, the number is then normalized to the given width by first truncating the fractional part and then taking the lowest bits in the integer's two's complement encoding.
jsnew Int32Array([1.1, 1.9, -1.1, -1.9]); // Int32Array(4) [ 1, 1, -1, -1 ]

new Int8Array([257, -257]); // Int8Array(2) [ 1, -1 ]
// 257 = 0001 0000 0001
//     =      0000 0001 (mod 2^8)
//     = 1
// -257 = 1110 1111 1111
//      =      1111 1111 (mod 2^8)
//      = -1 (as signed integer)

new Uint8Array([257, -257]); // Uint8Array(2) [ 1, 255 ]
// -257 = 1110 1111 1111
//      =      1111 1111 (mod 2^8)
//      = 255 (as unsigned integer)
Constructor
Number()

Creates Number objects. When called as a function, it returns primitive values of type Number.

Static properties
Number.EPSILON

The smallest interval between two representable numbers.

Number.MAX_SAFE_INTEGER

The maximum safe integer in JavaScript (253 - 1).

Number.MAX_VALUE

The largest positive representable number.

Number.MIN_SAFE_INTEGER

The minimum safe integer in JavaScript (-(253 - 1)).

Number.MIN_VALUE

The smallest positive representable number—that is, the positive number closest to zero (without actually being zero).

Number.NaN

Special "Not a Number" value.

Number.NEGATIVE_INFINITY

Special value representing negative infinity. Returned on overflow.

Number.POSITIVE_INFINITY

Special value representing infinity. Returned on overflow.

Static methods
Number.isFinite()

Determine whether the passed value is a finite number.

Number.isInteger()

Determine whether the passed value is an integer.

Number.isNaN()

Determine whether the passed value is NaN.

Number.isSafeInteger()

Determine whether the passed value is a safe integer (number between -(253 - 1) and 253 - 1).

Number.parseFloat()

This is the same as the global parseFloat() function.

Number.parseInt()

This is the same as the global parseInt() function.

Instance propertiesThese properties are defined on Number.prototype and shared by all Number instances.

Number.prototype.constructor

The constructor function that created the instance object. For Number instances, the initial value is the Number constructor.

Instance methods
Number.prototype.toExponential()

Returns a string representing the number in exponential notation.

Number.prototype.toFixed()

Returns a string representing the number in fixed-point notation.

Number.prototype.toLocaleString()

Returns a string with a language sensitive representation of this number. Overrides the Object.prototype.toLocaleString() method.

Number.prototype.toPrecision()

Returns a string representing the number to a specified precision in fixed-point or exponential notation.

Number.prototype.toString()

Returns a string representing the specified object in the specified radix ("base"). Overrides the Object.prototype.toString() method.

Number.prototype.valueOf()

Returns the primitive value of the specified object. Overrides the Object.prototype.valueOf() method.

ExamplesUsing the Number object to assign values to numeric variablesThe following example uses the Number object's properties to assign values to several numeric variables:
jsconst biggestNum = Number.MAX_VALUE;
const smallestNum = Number.MIN_VALUE;
const infiniteNum = Number.POSITIVE_INFINITY;
const negInfiniteNum = Number.NEGATIVE_INFINITY;
const notANum = Number.NaN;
Integer range for NumberThe following example shows the minimum and maximum integer values that can be represented as Number object.
jsconst biggestInt = Number.MAX_SAFE_INTEGER; // (2**53 - 1) => 9007199254740991
const smallestInt = Number.MIN_SAFE_INTEGER; // -(2**53 - 1) => -9007199254740991

When parsing data that has been serialized to JSON, integer values falling outside of this range can be expected to become corrupted when JSON parser coerces them to Number type.
A possible workaround is to use String instead.
Larger numbers can be represented using the BigInt type.Using Number() to convert a Date objectThe following example converts the Date object to a numerical value using Number as a function:
jsconst d = new Date("1995-12-17T03:24:00");
console.log(Number(d));

This logs 819199440000.Convert numeric strings and null to numbersjsNumber("123"); // 123
Number("123") === 123; // true
Number("12.3"); // 12.3
Number("12.00"); // 12
Number("123e-1"); // 12.3
Number(""); // 0
Number(null); // 0
Number("0x11"); // 17
Number("0b11"); // 3
Number("0o11"); // 9
Number("foo"); // NaN
Number("100a"); // NaN
Number("-Infinity"); // -Infinity
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-number-objectsBrowser compatibilitySee also
Polyfill of modern Number behavior (with support binary and octal literals) in core-js
NaN
Arithmetic operators
Math
BigInt
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nNumberBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackNumber values represent floating-point numbers like 37 or -9.25.
The Number constructor contains constants and methods for working with numbers. Values of other types can be converted to numbers using the Number() function.DescriptionNumbers are most commonly expressed in literal forms like 255 or 3.14159. The lexical grammar contains a more detailed reference.
js255; // two-hundred and fifty-five
255.0; // same number
255 === 255.0; // true
255 === 0xff; // true (hexadecimal notation)
255 === 0b11111111; // true (binary notation)
255 === 0.255e3; // true (decimal exponential notation)

A number literal like 37 in JavaScript code is a floating-point value, not an integer. There is no separate integer type in common everyday use. (JavaScript also has a BigInt type, but it's not designed to replace Number for everyday uses. 37 is still a number, not a BigInt.)
When used as a function, Number(value) converts a string or other value to the Number type. If the value can't be converted, it returns NaN.
jsNumber("123"); // returns the number 123
Number("123") === 123; // true

Number("unicorn"); // NaN
Number(undefined); // NaN
Number encodingThe JavaScript Number type is a double-precision 64-bit binary format IEEE 754 value, like double in Java or C#. This means it can represent fractional values, but there are some limits to the stored number's magnitude and precision. Very briefly, an IEEE 754 double-precision number uses 64 bits to represent 3 parts:

1 bit for the sign (positive or negative)
11 bits for the exponent (-1022 to 1023)
52 bits for the mantissa (representing a number between 0 and 1)

The mantissa (also called significand) is the part of the number representing the actual value (significant digits). The exponent is the power of 2 that the mantissa should be multiplied by. Thinking about it as scientific notation:


  Number=(−1)sign⋅(1+mantissa)⋅2exponent\text{Number} = ({-1})^{\text{sign}} \cdot (1 + \text{mantissa}) \cdot 2^{\text{exponent}}


The mantissa is stored with 52 bits, interpreted as digits after 1.… in a binary fractional number. Therefore, the mantissa's precision is 2-52 (obtainable via Number.EPSILON), or about 15 to 17 decimal places; arithmetic above that level of precision is subject to rounding.
The largest value a number can hold is 21023 × (2 - 2-52) (with the exponent being 1023 and the mantissa being 0.1111… in base 2), which is obtainable via Number.MAX_VALUE. Values higher than that are replaced with the special number constant Infinity.
Integers can only be represented without loss of precision in the range -253 + 1 to 253 - 1, inclusive (obtainable via Number.MIN_SAFE_INTEGER and Number.MAX_SAFE_INTEGER), because the mantissa can only hold 53 bits (including the leading 1).
More details on this are described in the ECMAScript standard.Number coercionMany built-in operations that expect numbers first coerce their arguments to numbers (which is largely why Number objects behave similarly to number primitives). The operation can be summarized as follows:

Numbers are returned as-is.
undefined turns into NaN.
null turns into 0.
true turns into 1; false turns into 0.
Strings are converted by parsing them as if they contain a number literal. Parsing failure results in NaN. There are some minor differences compared to an actual number literal:

Leading and trailing whitespace/line terminators are ignored.
A leading 0 digit does not cause the number to become an octal literal (or get rejected in strict mode).
+ and - are allowed at the start of the string to indicate its sign. (In actual code, they "look like" part of the literal, but are actually separate unary operators.) However, the sign can only appear once, and must not be followed by whitespace.
Infinity and -Infinity are recognized as literals. In actual code, they are global variables.
Empty or whitespace-only strings are converted to 0.
Numeric separators are not allowed.


BigInts throw a TypeError to prevent unintended implicit coercion causing loss of precision.
Symbols throw a TypeError.
Objects are first converted to a primitive by calling their [Symbol.toPrimitive]() (with "number" as hint), valueOf(), and toString() methods, in that order. The resulting primitive is then converted to a number.

There are two ways to achieve nearly the same effect in JavaScript.

Unary plus: +x does exactly the number coercion steps explained above to convert x.
The Number() function: Number(x) uses the same algorithm to convert x, except that BigInts don't throw a TypeError, but return their number value, with possible loss of precision.

Number.parseFloat() and Number.parseInt() are similar to Number() but only convert strings, and have slightly different parsing rules. For example, parseInt() doesn't recognize the decimal point, and parseFloat() doesn't recognize the 0x prefix.
Integer conversion
Some operations expect integers, most notably those that work with array/string indices, date/time components, and number radixes. After performing the number coercion steps above, the result is truncated to an integer (by discarding the fractional part). If the number is ±Infinity, it's returned as-is. If the number is NaN or -0, it's returned as 0. The result is therefore always an integer (which is not -0) or ±Infinity.
Notably, when converted to integers, both undefined and null become 0, because undefined is converted to NaN, which also becomes 0.
Fixed-width number conversion
JavaScript has some lower-level functions that deal with the binary encoding of integer numbers, most notably bitwise operators and TypedArray objects. Bitwise operators always convert the operands to 32-bit integers. In these cases, after converting the value to a number, the number is then normalized to the given width by first truncating the fractional part and then taking the lowest bits in the integer's two's complement encoding.
jsnew Int32Array([1.1, 1.9, -1.1, -1.9]); // Int32Array(4) [ 1, 1, -1, -1 ]

new Int8Array([257, -257]); // Int8Array(2) [ 1, -1 ]
// 257 = 0001 0000 0001
//     =      0000 0001 (mod 2^8)
//     = 1
// -257 = 1110 1111 1111
//      =      1111 1111 (mod 2^8)
//      = -1 (as signed integer)

new Uint8Array([257, -257]); // Uint8Array(2) [ 1, 255 ]
// -257 = 1110 1111 1111
//      =      1111 1111 (mod 2^8)
//      = 255 (as unsigned integer)
Constructor
Number()

Creates Number objects. When called as a function, it returns primitive values of type Number.

Static properties
Number.EPSILON

The smallest interval between two representable numbers.

Number.MAX_SAFE_INTEGER

The maximum safe integer in JavaScript (253 - 1).

Number.MAX_VALUE

The largest positive representable number.

Number.MIN_SAFE_INTEGER

The minimum safe integer in JavaScript (-(253 - 1)).

Number.MIN_VALUE

The smallest positive representable number—that is, the positive number closest to zero (without actually being zero).

Number.NaN

Special "Not a Number" value.

Number.NEGATIVE_INFINITY

Special value representing negative infinity. Returned on overflow.

Number.POSITIVE_INFINITY

Special value representing infinity. Returned on overflow.

Static methods
Number.isFinite()

Determine whether the passed value is a finite number.

Number.isInteger()

Determine whether the passed value is an integer.

Number.isNaN()

Determine whether the passed value is NaN.

Number.isSafeInteger()

Determine whether the passed value is a safe integer (number between -(253 - 1) and 253 - 1).

Number.parseFloat()

This is the same as the global parseFloat() function.

Number.parseInt()

This is the same as the global parseInt() function.

Instance propertiesThese properties are defined on Number.prototype and shared by all Number instances.

Number.prototype.constructor

The constructor function that created the instance object. For Number instances, the initial value is the Number constructor.

Instance methods
Number.prototype.toExponential()

Returns a string representing the number in exponential notation.

Number.prototype.toFixed()

Returns a string representing the number in fixed-point notation.

Number.prototype.toLocaleString()

Returns a string with a language sensitive representation of this number. Overrides the Object.prototype.toLocaleString() method.

Number.prototype.toPrecision()

Returns a string representing the number to a specified precision in fixed-point or exponential notation.

Number.prototype.toString()

Returns a string representing the specified object in the specified radix ("base"). Overrides the Object.prototype.toString() method.

Number.prototype.valueOf()

Returns the primitive value of the specified object. Overrides the Object.prototype.valueOf() method.

ExamplesUsing the Number object to assign values to numeric variablesThe following example uses the Number object's properties to assign values to several numeric variables:
jsconst biggestNum = Number.MAX_VALUE;
const smallestNum = Number.MIN_VALUE;
const infiniteNum = Number.POSITIVE_INFINITY;
const negInfiniteNum = Number.NEGATIVE_INFINITY;
const notANum = Number.NaN;
Integer range for NumberThe following example shows the minimum and maximum integer values that can be represented as Number object.
jsconst biggestInt = Number.MAX_SAFE_INTEGER; // (2**53 - 1) => 9007199254740991
const smallestInt = Number.MIN_SAFE_INTEGER; // -(2**53 - 1) => -9007199254740991

When parsing data that has been serialized to JSON, integer values falling outside of this range can be expected to become corrupted when JSON parser coerces them to Number type.
A possible workaround is to use String instead.
Larger numbers can be represented using the BigInt type.Using Number() to convert a Date objectThe following example converts the Date object to a numerical value using Number as a function:
jsconst d = new Date("1995-12-17T03:24:00");
console.log(Number(d));

This logs 819199440000.Convert numeric strings and null to numbersjsNumber("123"); // 123
Number("123") === 123; // true
Number("12.3"); // 12.3
Number("12.00"); // 12
Number("123e-1"); // 12.3
Number(""); // 0
Number(null); // 0
Number("0x11"); // 17
Number("0b11"); // 3
Number("0o11"); // 9
Number("foo"); // NaN
Number("100a"); // NaN
Number("-Infinity"); // -Infinity
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-number-objectsBrowser compatibilitySee also
Polyfill of modern Number behavior (with support binary and octal literals) in core-js
NaN
Arithmetic operators
Math
BigInt
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nStringBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe String object is used to represent and manipulate a
sequence of characters.DescriptionStrings are useful for holding data that can be represented in text form. Some of the
most-used operations on strings are to check their length, to build and concatenate them using the
+ and += string operators,
checking for the existence or location of substrings with the
indexOf() method, or extracting substrings
with the substring() method.Creating stringsStrings can be created as primitives, from string literals, or as objects, using the
String() constructor:
jsconst string1 = "A string primitive";
const string2 = 'Also a string primitive';
const string3 = `Yet another string primitive`;

jsconst string4 = new String("A String object");

String primitives and string objects share many behaviors, but have other important differences and caveats.
See "String primitives and String objects" below.
String literals can be specified using single or double quotes, which are treated
identically, or using the backtick character `. This last form specifies a template literal:
with this form you can interpolate expressions. For more information on the syntax of string literals, see lexical grammar.Character accessThere are two ways to access an individual character in a string. The first is the
charAt() method:
js"cat".charAt(1); // gives value "a"

The other way is to treat the string as an array-like object, where individual characters correspond to a numerical index:
js"cat"[1]; // gives value "a"

When using bracket notation for character access, attempting to delete or assign a
value to these properties will not succeed. The properties involved are neither writable
nor configurable. (See Object.defineProperty() for more information.)Comparing stringsUse the less-than and greater-than operators to compare strings:
jsconst a = "a";
const b = "b";
if (a < b) {
  // true
  console.log(`${a} is less than ${b}`);
} else if (a > b) {
  console.log(`${a} is greater than ${b}`);
} else {
  console.log(`${a} and ${b} are equal.`);
}

Note that all comparison operators, including === and ==, compare strings case-sensitively. A common way to compare strings case-insensitively is to convert both to the same case (upper or lower) before comparing them.
jsfunction areEqualCaseInsensitive(str1, str2) {
  return str1.toUpperCase() === str2.toUpperCase();
}

The choice of whether to transform by toUpperCase() or toLowerCase() is mostly arbitrary, and neither one is fully robust when extending beyond the Latin alphabet. For example, the German lowercase letter ß and ss are both transformed to SS by toUpperCase(), while the Turkish letter ı would be falsely reported as unequal to I by toLowerCase() unless specifically using toLocaleLowerCase("tr").
jsconst areEqualInUpperCase = (str1, str2) =>
  str1.toUpperCase() === str2.toUpperCase();
const areEqualInLowerCase = (str1, str2) =>
  str1.toLowerCase() === str2.toLowerCase();

areEqualInUpperCase("ß", "ss"); // true; should be false
areEqualInLowerCase("ı", "I"); // false; should be true

A locale-aware and robust solution for testing case-insensitive equality is to use the Intl.Collator API or the string's localeCompare() method — they share the same interface — with the sensitivity option set to "accent" or "base".
jsconst areEqual = (str1, str2, locale = "en-US") =>
  str1.localeCompare(str2, locale, { sensitivity: "accent" }) === 0;

areEqual("ß", "ss", "de"); // false
areEqual("ı", "I", "tr"); // true

The localeCompare() method enables string comparison in a similar fashion as strcmp() — it allows sorting strings in a locale-aware manner.String primitives and String objectsNote that JavaScript distinguishes between String objects and
primitive string values. (The same is true of
Boolean and Numbers.)
String literals (denoted by double or single quotes) and strings returned from
String calls in a non-constructor context (that is, called without using
the new keyword) are primitive strings. In contexts where a
method is to be invoked on a primitive string or a property lookup occurs, JavaScript
will automatically wrap the string primitive and call the method or perform the property
lookup on the wrapper object instead.
jsconst strPrim = "foo"; // A literal is a string primitive
const strPrim2 = String(1); // Coerced into the string primitive "1"
const strPrim3 = String(true); // Coerced into the string primitive "true"
const strObj = new String(strPrim); // String with new returns a string wrapper object.

console.log(typeof strPrim); // "string"
console.log(typeof strPrim2); // "string"
console.log(typeof strPrim3); // "string"
console.log(typeof strObj); // "object"


Warning:
You should rarely find yourself using String as a constructor.

String primitives and String objects also give different results when
using eval(). Primitives passed to
eval are treated as source code; String objects are treated as
all other objects are, by returning the object. For example:
jsconst s1 = "2 + 2"; // creates a string primitive
const s2 = new String("2 + 2"); // creates a String object
console.log(eval(s1)); // returns the number 4
console.log(eval(s2)); // returns the string "2 + 2"

For these reasons, the code may break when it encounters String objects
when it expects a primitive string instead, although generally, authors need not worry
about the distinction.
A String object can always be converted to its primitive counterpart with
the valueOf() method.
jsconsole.log(eval(s2.valueOf())); // returns the number 4
String coercionMany built-in operations that expect strings first coerce their arguments to strings (which is largely why String objects behave similarly to string primitives). The operation can be summarized as follows:

Strings are returned as-is.
undefined turns into "undefined".
null turns into "null".
true turns into "true"; false turns into "false".
Numbers are converted with the same algorithm as toString(10).
BigInts are converted with the same algorithm as toString(10).
Symbols throw a TypeError.
Objects are first converted to a primitive by calling its [Symbol.toPrimitive]() (with "string" as hint), toString(), and valueOf() methods, in that order. The resulting primitive is then converted to a string.

There are several ways to achieve nearly the same effect in JavaScript.

Template literal: `${x}` does exactly the string coercion steps explained above for the embedded expression.
The String() function: String(x) uses the same algorithm to convert x, except that Symbols don't throw a TypeError, but return "Symbol(description)", where description is the description of the Symbol.
Using the + operator: "" + x coerces its operand to a primitive instead of a string, and, for some objects, has entirely different behaviors from normal string coercion. See its reference page for more details.

Depending on your use case, you may want to use `${x}` (to mimic built-in behavior) or String(x) (to handle symbol values without throwing an error), but you should not use "" + x.UTF-16 characters, Unicode code points, and grapheme clustersStrings are represented fundamentally as sequences of UTF-16 code units. In UTF-16 encoding, every code unit is exact 16 bits long. This means there are a maximum of 216, or 65536 possible characters representable as single UTF-16 code units. This character set is called the basic multilingual plane (BMP), and includes the most common characters like the Latin, Greek, Cyrillic alphabets, as well as many East Asian characters. Each code unit can be written in a string with \u followed by exactly four hex digits.
However, the entire Unicode character set is much, much bigger than 65536. The extra characters are stored in UTF-16 as surrogate pairs, which are pairs of 16-bit code units that represent a single character. To avoid ambiguity, the two parts of the pair must be between 0xD800 and 0xDFFF, and these code units are not used to encode single-code-unit characters. (More precisely, leading surrogates, also called high-surrogate code units, have values between 0xD800 and 0xDBFF, inclusive, while trailing surrogates, also called low-surrogate code units, have values between 0xDC00 and 0xDFFF, inclusive.) Each Unicode character, comprised of one or two UTF-16 code units, is also called a Unicode code point. Each Unicode code point can be written in a string with \u{xxxxxx} where xxxxxx represents 1–6 hex digits.
A "lone surrogate" is a 16-bit code unit satisfying one of the descriptions below:

It is in the range 0xD800–0xDBFF, inclusive (i.e., is a leading surrogate), but it is the last code unit in the string, or the next code unit is not a trailing surrogate.
It is in the range 0xDC00–0xDFFF, inclusive (i.e., is a trailing surrogate), but it is the first code unit in the string, or the previous code unit is not a leading surrogate.

Lone surrogates do not represent any Unicode character. Although most JavaScript built-in methods handle them correctly because they all work based on UTF-16 code units, lone surrogates are often not valid values when interacting with other systems — for example, encodeURI() will throw a URIError for lone surrogates, because URI encoding uses UTF-8 encoding, which does not have any encoding for lone surrogates. Strings not containing any lone surrogates are called well-formed strings, and are safe to be used with functions that do not deal with UTF-16 (such as encodeURI() or TextEncoder). You can check if a string is well-formed with the isWellFormed() method, or sanitize lone surrogates with the toWellFormed() method.
On top of Unicode characters, there are certain sequences of Unicode characters that should be treated as one visual unit, known as a grapheme cluster. The most common case is emojis: many emojis that have a range of variations are actually formed by multiple emojis, usually joined by the <ZWJ> (U+200D) character.
You must be careful which level of characters you are iterating on. For example, split("") will split by UTF-16 code units and will separate surrogate pairs. String indexes also refer to the index of each UTF-16 code unit. On the other hand, [Symbol.iterator]() iterates by Unicode code points. Iterating through grapheme clusters will require some custom code.
js"😄".split(""); // ['\ud83d', '\ude04']; splits into two lone surrogates

// "Backhand Index Pointing Right: Dark Skin Tone"
[..."👉🏿"]; // ['👉', '🏿']
// splits into the basic "Backhand Index Pointing Right" emoji and
// the "Dark skin tone" emoji

// "Family: Man, Boy"
[..."👨‍👦"]; // [ '👨', '‍', '👦' ]
// splits into the "Man" and "Boy" emoji, joined by a ZWJ

// The United Nations flag
[..."🇺🇳"]; // [ '🇺', '🇳' ]
// splits into two "region indicator" letters "U" and "N".
// All flag emojis are formed by joining two region indicator letters
Constructor
String()

Creates String objects. When called as a function, it returns primitive values of type String.

Static methods
String.fromCharCode()

Returns a string created by using the specified sequence of Unicode values.

String.fromCodePoint()

Returns a string created by using the specified sequence of code points.

String.raw()

Returns a string created from a raw template string.

Instance propertiesThese properties are defined on String.prototype and shared by all String instances.

String.prototype.constructor

The constructor function that created the instance object. For String instances, the initial value is the String constructor.


These properties are own properties of each String instance.

length

Reflects the length of the string. Read-only.

Instance methods
String.prototype.at()

Returns the character (exactly one UTF-16 code unit) at the specified index. Accepts negative integers, which count back from the last string character.

String.prototype.charAt()

Returns the character (exactly one UTF-16 code unit) at the specified
index.

String.prototype.charCodeAt()

Returns a number that is the UTF-16 code unit value at the given
index.

String.prototype.codePointAt()

Returns a nonnegative integer Number that is the code point value of the UTF-16
encoded code point starting at the specified pos.

String.prototype.concat()

Combines the text of two (or more) strings and returns a new string.

String.prototype.endsWith()

Determines whether a string ends with the characters of the string
searchString.

String.prototype.includes()

Determines whether the calling string contains searchString.

String.prototype.indexOf()

Returns the index within this string of the first
occurrence of searchValue, or -1 if not found.

String.prototype.isWellFormed()

Returns a boolean indicating whether this string contains any lone surrogates.

String.prototype.lastIndexOf()

Returns the index within this string of the last
occurrence of searchValue, or -1 if not found.

String.prototype.localeCompare()

Returns a number indicating whether the reference string
compareString comes before, after, or is equivalent to the
given string in sort order.

String.prototype.match()

Used to match regular expression regexp against a string.

String.prototype.matchAll()

Returns an iterator of all regexp's matches.

String.prototype.normalize()

Returns the Unicode Normalization Form of the calling string value.

String.prototype.padEnd()

Pads the current string from the end with a given string and returns a new string of
the length targetLength.

String.prototype.padStart()

Pads the current string from the start with a given string and returns a new string
of the length targetLength.

String.prototype.repeat()

Returns a string consisting of the elements of the object repeated
count times.

String.prototype.replace()

Used to replace occurrences of searchFor using
replaceWith. searchFor may be a string
or Regular Expression, and replaceWith may be a string or
function.

String.prototype.replaceAll()

Used to replace all occurrences of searchFor using
replaceWith. searchFor may be a string
or Regular Expression, and replaceWith may be a string or
function.

String.prototype.search()

Search for a match between a regular expression regexp and
the calling string.

String.prototype.slice()

Extracts a section of a string and returns a new string.

String.prototype.split()

Returns an array of strings populated by splitting the calling string at occurrences
of the substring sep.

String.prototype.startsWith()

Determines whether the calling string begins with the characters of string
searchString.

String.prototype.substr() 
Deprecated


Returns a portion of the string, starting at the specified index and extending for a given number of characters afterwards.

String.prototype.substring()

Returns a new string containing characters of the calling string from (or between)
the specified index (or indices).

String.prototype.toLocaleLowerCase()

The characters within a string are converted to lowercase while respecting the
current locale.
For most languages, this will return the same as
toLowerCase().

String.prototype.toLocaleUpperCase()

The characters within a string are converted to uppercase while respecting the
current locale.
For most languages, this will return the same as
toUpperCase().

String.prototype.toLowerCase()

Returns the calling string value converted to lowercase.

String.prototype.toString()

Returns a string representing the specified object. Overrides the
Object.prototype.toString() method.

String.prototype.toUpperCase()

Returns the calling string value converted to uppercase.

String.prototype.toWellFormed()

Returns a string where all lone surrogates of this string are replaced with the Unicode replacement character U+FFFD.

String.prototype.trim()

Trims whitespace from the beginning and end of the string.

String.prototype.trimEnd()

Trims whitespace from the end of the string.

String.prototype.trimStart()

Trims whitespace from the beginning of the string.

String.prototype.valueOf()

Returns the primitive value of the specified object. Overrides the
Object.prototype.valueOf() method.

String.prototype[Symbol.iterator]()

Returns a new iterator object that iterates over the code points of a String value,
returning each code point as a String value.

HTML wrapper methods
Warning:
Deprecated. Avoid these methods.
They are of limited use, as they are based on a very old HTML standard and provide only a subset of the currently available HTML tags and attributes. Many of them create deprecated or non-standard markup today. In addition, they do string concatenation without any validation or sanitation, which makes them a potential security threat when directly inserted using innerHTML. Use DOM APIs such as document.createElement() instead.


String.prototype.anchor() 
Deprecated


<a name="name"> (hypertext target)

String.prototype.big() 
Deprecated

<big>
String.prototype.blink() 
Deprecated


<blink>

String.prototype.bold() 
Deprecated

<b>
String.prototype.fixed() 
Deprecated

<tt>
String.prototype.fontcolor() 
Deprecated


<font color="color">

String.prototype.fontsize() 
Deprecated


<font size="size">

String.prototype.italics() 
Deprecated

<i>
String.prototype.link() 
Deprecated


<a href="url"> (link to URL)

String.prototype.small() 
Deprecated

<small>
String.prototype.strike() 
Deprecated

<strike>
String.prototype.sub() 
Deprecated

<sub>
String.prototype.sup() 
Deprecated

<sup>

Note that these methods do not check if the string itself contains HTML tags, so it's possible to create invalid HTML:
js"</b>".bold(); // <b></b></b>

The only escaping they do is to replace " in the attribute value (for anchor(), fontcolor(), fontsize(), and link()) with &quot;.
js"foo".anchor('"Hello"'); // <a name="&quot;Hello&quot;">foo</a>
ExamplesString conversionThe String() function is a more reliable way of converting values to strings than calling the toString() method of the value, as the former works when used on null and undefined. For example:
js// You cannot access properties on null or undefined

const nullVar = null;
nullVar.toString(); // TypeError: Cannot read properties of null
String(nullVar); // "null"

const undefinedVar = undefined;
undefinedVar.toString(); // TypeError: Cannot read properties of undefined
String(undefinedVar); // "undefined"
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-string-objectsBrowser compatibilitySee also
Numbers and strings guide
RegExp\n\nStringBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe String object is used to represent and manipulate a
sequence of characters.DescriptionStrings are useful for holding data that can be represented in text form. Some of the
most-used operations on strings are to check their length, to build and concatenate them using the
+ and += string operators,
checking for the existence or location of substrings with the
indexOf() method, or extracting substrings
with the substring() method.Creating stringsStrings can be created as primitives, from string literals, or as objects, using the
String() constructor:
jsconst string1 = "A string primitive";
const string2 = 'Also a string primitive';
const string3 = `Yet another string primitive`;

jsconst string4 = new String("A String object");

String primitives and string objects share many behaviors, but have other important differences and caveats.
See "String primitives and String objects" below.
String literals can be specified using single or double quotes, which are treated
identically, or using the backtick character `. This last form specifies a template literal:
with this form you can interpolate expressions. For more information on the syntax of string literals, see lexical grammar.Character accessThere are two ways to access an individual character in a string. The first is the
charAt() method:
js"cat".charAt(1); // gives value "a"

The other way is to treat the string as an array-like object, where individual characters correspond to a numerical index:
js"cat"[1]; // gives value "a"

When using bracket notation for character access, attempting to delete or assign a
value to these properties will not succeed. The properties involved are neither writable
nor configurable. (See Object.defineProperty() for more information.)Comparing stringsUse the less-than and greater-than operators to compare strings:
jsconst a = "a";
const b = "b";
if (a < b) {
  // true
  console.log(`${a} is less than ${b}`);
} else if (a > b) {
  console.log(`${a} is greater than ${b}`);
} else {
  console.log(`${a} and ${b} are equal.`);
}

Note that all comparison operators, including === and ==, compare strings case-sensitively. A common way to compare strings case-insensitively is to convert both to the same case (upper or lower) before comparing them.
jsfunction areEqualCaseInsensitive(str1, str2) {
  return str1.toUpperCase() === str2.toUpperCase();
}

The choice of whether to transform by toUpperCase() or toLowerCase() is mostly arbitrary, and neither one is fully robust when extending beyond the Latin alphabet. For example, the German lowercase letter ß and ss are both transformed to SS by toUpperCase(), while the Turkish letter ı would be falsely reported as unequal to I by toLowerCase() unless specifically using toLocaleLowerCase("tr").
jsconst areEqualInUpperCase = (str1, str2) =>
  str1.toUpperCase() === str2.toUpperCase();
const areEqualInLowerCase = (str1, str2) =>
  str1.toLowerCase() === str2.toLowerCase();

areEqualInUpperCase("ß", "ss"); // true; should be false
areEqualInLowerCase("ı", "I"); // false; should be true

A locale-aware and robust solution for testing case-insensitive equality is to use the Intl.Collator API or the string's localeCompare() method — they share the same interface — with the sensitivity option set to "accent" or "base".
jsconst areEqual = (str1, str2, locale = "en-US") =>
  str1.localeCompare(str2, locale, { sensitivity: "accent" }) === 0;

areEqual("ß", "ss", "de"); // false
areEqual("ı", "I", "tr"); // true

The localeCompare() method enables string comparison in a similar fashion as strcmp() — it allows sorting strings in a locale-aware manner.String primitives and String objectsNote that JavaScript distinguishes between String objects and
primitive string values. (The same is true of
Boolean and Numbers.)
String literals (denoted by double or single quotes) and strings returned from
String calls in a non-constructor context (that is, called without using
the new keyword) are primitive strings. In contexts where a
method is to be invoked on a primitive string or a property lookup occurs, JavaScript
will automatically wrap the string primitive and call the method or perform the property
lookup on the wrapper object instead.
jsconst strPrim = "foo"; // A literal is a string primitive
const strPrim2 = String(1); // Coerced into the string primitive "1"
const strPrim3 = String(true); // Coerced into the string primitive "true"
const strObj = new String(strPrim); // String with new returns a string wrapper object.

console.log(typeof strPrim); // "string"
console.log(typeof strPrim2); // "string"
console.log(typeof strPrim3); // "string"
console.log(typeof strObj); // "object"


Warning:
You should rarely find yourself using String as a constructor.

String primitives and String objects also give different results when
using eval(). Primitives passed to
eval are treated as source code; String objects are treated as
all other objects are, by returning the object. For example:
jsconst s1 = "2 + 2"; // creates a string primitive
const s2 = new String("2 + 2"); // creates a String object
console.log(eval(s1)); // returns the number 4
console.log(eval(s2)); // returns the string "2 + 2"

For these reasons, the code may break when it encounters String objects
when it expects a primitive string instead, although generally, authors need not worry
about the distinction.
A String object can always be converted to its primitive counterpart with
the valueOf() method.
jsconsole.log(eval(s2.valueOf())); // returns the number 4
String coercionMany built-in operations that expect strings first coerce their arguments to strings (which is largely why String objects behave similarly to string primitives). The operation can be summarized as follows:

Strings are returned as-is.
undefined turns into "undefined".
null turns into "null".
true turns into "true"; false turns into "false".
Numbers are converted with the same algorithm as toString(10).
BigInts are converted with the same algorithm as toString(10).
Symbols throw a TypeError.
Objects are first converted to a primitive by calling its [Symbol.toPrimitive]() (with "string" as hint), toString(), and valueOf() methods, in that order. The resulting primitive is then converted to a string.

There are several ways to achieve nearly the same effect in JavaScript.

Template literal: `${x}` does exactly the string coercion steps explained above for the embedded expression.
The String() function: String(x) uses the same algorithm to convert x, except that Symbols don't throw a TypeError, but return "Symbol(description)", where description is the description of the Symbol.
Using the + operator: "" + x coerces its operand to a primitive instead of a string, and, for some objects, has entirely different behaviors from normal string coercion. See its reference page for more details.

Depending on your use case, you may want to use `${x}` (to mimic built-in behavior) or String(x) (to handle symbol values without throwing an error), but you should not use "" + x.UTF-16 characters, Unicode code points, and grapheme clustersStrings are represented fundamentally as sequences of UTF-16 code units. In UTF-16 encoding, every code unit is exact 16 bits long. This means there are a maximum of 216, or 65536 possible characters representable as single UTF-16 code units. This character set is called the basic multilingual plane (BMP), and includes the most common characters like the Latin, Greek, Cyrillic alphabets, as well as many East Asian characters. Each code unit can be written in a string with \u followed by exactly four hex digits.
However, the entire Unicode character set is much, much bigger than 65536. The extra characters are stored in UTF-16 as surrogate pairs, which are pairs of 16-bit code units that represent a single character. To avoid ambiguity, the two parts of the pair must be between 0xD800 and 0xDFFF, and these code units are not used to encode single-code-unit characters. (More precisely, leading surrogates, also called high-surrogate code units, have values between 0xD800 and 0xDBFF, inclusive, while trailing surrogates, also called low-surrogate code units, have values between 0xDC00 and 0xDFFF, inclusive.) Each Unicode character, comprised of one or two UTF-16 code units, is also called a Unicode code point. Each Unicode code point can be written in a string with \u{xxxxxx} where xxxxxx represents 1–6 hex digits.
A "lone surrogate" is a 16-bit code unit satisfying one of the descriptions below:

It is in the range 0xD800–0xDBFF, inclusive (i.e., is a leading surrogate), but it is the last code unit in the string, or the next code unit is not a trailing surrogate.
It is in the range 0xDC00–0xDFFF, inclusive (i.e., is a trailing surrogate), but it is the first code unit in the string, or the previous code unit is not a leading surrogate.

Lone surrogates do not represent any Unicode character. Although most JavaScript built-in methods handle them correctly because they all work based on UTF-16 code units, lone surrogates are often not valid values when interacting with other systems — for example, encodeURI() will throw a URIError for lone surrogates, because URI encoding uses UTF-8 encoding, which does not have any encoding for lone surrogates. Strings not containing any lone surrogates are called well-formed strings, and are safe to be used with functions that do not deal with UTF-16 (such as encodeURI() or TextEncoder). You can check if a string is well-formed with the isWellFormed() method, or sanitize lone surrogates with the toWellFormed() method.
On top of Unicode characters, there are certain sequences of Unicode characters that should be treated as one visual unit, known as a grapheme cluster. The most common case is emojis: many emojis that have a range of variations are actually formed by multiple emojis, usually joined by the <ZWJ> (U+200D) character.
You must be careful which level of characters you are iterating on. For example, split("") will split by UTF-16 code units and will separate surrogate pairs. String indexes also refer to the index of each UTF-16 code unit. On the other hand, [Symbol.iterator]() iterates by Unicode code points. Iterating through grapheme clusters will require some custom code.
js"😄".split(""); // ['\ud83d', '\ude04']; splits into two lone surrogates

// "Backhand Index Pointing Right: Dark Skin Tone"
[..."👉🏿"]; // ['👉', '🏿']
// splits into the basic "Backhand Index Pointing Right" emoji and
// the "Dark skin tone" emoji

// "Family: Man, Boy"
[..."👨‍👦"]; // [ '👨', '‍', '👦' ]
// splits into the "Man" and "Boy" emoji, joined by a ZWJ

// The United Nations flag
[..."🇺🇳"]; // [ '🇺', '🇳' ]
// splits into two "region indicator" letters "U" and "N".
// All flag emojis are formed by joining two region indicator letters
Constructor
String()

Creates String objects. When called as a function, it returns primitive values of type String.

Static methods
String.fromCharCode()

Returns a string created by using the specified sequence of Unicode values.

String.fromCodePoint()

Returns a string created by using the specified sequence of code points.

String.raw()

Returns a string created from a raw template string.

Instance propertiesThese properties are defined on String.prototype and shared by all String instances.

String.prototype.constructor

The constructor function that created the instance object. For String instances, the initial value is the String constructor.


These properties are own properties of each String instance.

length

Reflects the length of the string. Read-only.

Instance methods
String.prototype.at()

Returns the character (exactly one UTF-16 code unit) at the specified index. Accepts negative integers, which count back from the last string character.

String.prototype.charAt()

Returns the character (exactly one UTF-16 code unit) at the specified
index.

String.prototype.charCodeAt()

Returns a number that is the UTF-16 code unit value at the given
index.

String.prototype.codePointAt()

Returns a nonnegative integer Number that is the code point value of the UTF-16
encoded code point starting at the specified pos.

String.prototype.concat()

Combines the text of two (or more) strings and returns a new string.

String.prototype.endsWith()

Determines whether a string ends with the characters of the string
searchString.

String.prototype.includes()

Determines whether the calling string contains searchString.

String.prototype.indexOf()

Returns the index within this string of the first
occurrence of searchValue, or -1 if not found.

String.prototype.isWellFormed()

Returns a boolean indicating whether this string contains any lone surrogates.

String.prototype.lastIndexOf()

Returns the index within this string of the last
occurrence of searchValue, or -1 if not found.

String.prototype.localeCompare()

Returns a number indicating whether the reference string
compareString comes before, after, or is equivalent to the
given string in sort order.

String.prototype.match()

Used to match regular expression regexp against a string.

String.prototype.matchAll()

Returns an iterator of all regexp's matches.

String.prototype.normalize()

Returns the Unicode Normalization Form of the calling string value.

String.prototype.padEnd()

Pads the current string from the end with a given string and returns a new string of
the length targetLength.

String.prototype.padStart()

Pads the current string from the start with a given string and returns a new string
of the length targetLength.

String.prototype.repeat()

Returns a string consisting of the elements of the object repeated
count times.

String.prototype.replace()

Used to replace occurrences of searchFor using
replaceWith. searchFor may be a string
or Regular Expression, and replaceWith may be a string or
function.

String.prototype.replaceAll()

Used to replace all occurrences of searchFor using
replaceWith. searchFor may be a string
or Regular Expression, and replaceWith may be a string or
function.

String.prototype.search()

Search for a match between a regular expression regexp and
the calling string.

String.prototype.slice()

Extracts a section of a string and returns a new string.

String.prototype.split()

Returns an array of strings populated by splitting the calling string at occurrences
of the substring sep.

String.prototype.startsWith()

Determines whether the calling string begins with the characters of string
searchString.

String.prototype.substr() 
Deprecated


Returns a portion of the string, starting at the specified index and extending for a given number of characters afterwards.

String.prototype.substring()

Returns a new string containing characters of the calling string from (or between)
the specified index (or indices).

String.prototype.toLocaleLowerCase()

The characters within a string are converted to lowercase while respecting the
current locale.
For most languages, this will return the same as
toLowerCase().

String.prototype.toLocaleUpperCase()

The characters within a string are converted to uppercase while respecting the
current locale.
For most languages, this will return the same as
toUpperCase().

String.prototype.toLowerCase()

Returns the calling string value converted to lowercase.

String.prototype.toString()

Returns a string representing the specified object. Overrides the
Object.prototype.toString() method.

String.prototype.toUpperCase()

Returns the calling string value converted to uppercase.

String.prototype.toWellFormed()

Returns a string where all lone surrogates of this string are replaced with the Unicode replacement character U+FFFD.

String.prototype.trim()

Trims whitespace from the beginning and end of the string.

String.prototype.trimEnd()

Trims whitespace from the end of the string.

String.prototype.trimStart()

Trims whitespace from the beginning of the string.

String.prototype.valueOf()

Returns the primitive value of the specified object. Overrides the
Object.prototype.valueOf() method.

String.prototype[Symbol.iterator]()

Returns a new iterator object that iterates over the code points of a String value,
returning each code point as a String value.

HTML wrapper methods
Warning:
Deprecated. Avoid these methods.
They are of limited use, as they are based on a very old HTML standard and provide only a subset of the currently available HTML tags and attributes. Many of them create deprecated or non-standard markup today. In addition, they do string concatenation without any validation or sanitation, which makes them a potential security threat when directly inserted using innerHTML. Use DOM APIs such as document.createElement() instead.


String.prototype.anchor() 
Deprecated


<a name="name"> (hypertext target)

String.prototype.big() 
Deprecated

<big>
String.prototype.blink() 
Deprecated


<blink>

String.prototype.bold() 
Deprecated

<b>
String.prototype.fixed() 
Deprecated

<tt>
String.prototype.fontcolor() 
Deprecated


<font color="color">

String.prototype.fontsize() 
Deprecated


<font size="size">

String.prototype.italics() 
Deprecated

<i>
String.prototype.link() 
Deprecated


<a href="url"> (link to URL)

String.prototype.small() 
Deprecated

<small>
String.prototype.strike() 
Deprecated

<strike>
String.prototype.sub() 
Deprecated

<sub>
String.prototype.sup() 
Deprecated

<sup>

Note that these methods do not check if the string itself contains HTML tags, so it's possible to create invalid HTML:
js"</b>".bold(); // <b></b></b>

The only escaping they do is to replace " in the attribute value (for anchor(), fontcolor(), fontsize(), and link()) with &quot;.
js"foo".anchor('"Hello"'); // <a name="&quot;Hello&quot;">foo</a>
ExamplesString conversionThe String() function is a more reliable way of converting values to strings than calling the toString() method of the value, as the former works when used on null and undefined. For example:
js// You cannot access properties on null or undefined

const nullVar = null;
nullVar.toString(); // TypeError: Cannot read properties of null
String(nullVar); // "null"

const undefinedVar = undefined;
undefinedVar.toString(); // TypeError: Cannot read properties of undefined
String(undefinedVar); // "undefined"
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-string-objectsBrowser compatibilitySee also
Numbers and strings guide
RegExp
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nStringBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe String object is used to represent and manipulate a
sequence of characters.DescriptionStrings are useful for holding data that can be represented in text form. Some of the
most-used operations on strings are to check their length, to build and concatenate them using the
+ and += string operators,
checking for the existence or location of substrings with the
indexOf() method, or extracting substrings
with the substring() method.Creating stringsStrings can be created as primitives, from string literals, or as objects, using the
String() constructor:
jsconst string1 = "A string primitive";
const string2 = 'Also a string primitive';
const string3 = `Yet another string primitive`;

jsconst string4 = new String("A String object");

String primitives and string objects share many behaviors, but have other important differences and caveats.
See "String primitives and String objects" below.
String literals can be specified using single or double quotes, which are treated
identically, or using the backtick character `. This last form specifies a template literal:
with this form you can interpolate expressions. For more information on the syntax of string literals, see lexical grammar.Character accessThere are two ways to access an individual character in a string. The first is the
charAt() method:
js"cat".charAt(1); // gives value "a"

The other way is to treat the string as an array-like object, where individual characters correspond to a numerical index:
js"cat"[1]; // gives value "a"

When using bracket notation for character access, attempting to delete or assign a
value to these properties will not succeed. The properties involved are neither writable
nor configurable. (See Object.defineProperty() for more information.)Comparing stringsUse the less-than and greater-than operators to compare strings:
jsconst a = "a";
const b = "b";
if (a < b) {
  // true
  console.log(`${a} is less than ${b}`);
} else if (a > b) {
  console.log(`${a} is greater than ${b}`);
} else {
  console.log(`${a} and ${b} are equal.`);
}

Note that all comparison operators, including === and ==, compare strings case-sensitively. A common way to compare strings case-insensitively is to convert both to the same case (upper or lower) before comparing them.
jsfunction areEqualCaseInsensitive(str1, str2) {
  return str1.toUpperCase() === str2.toUpperCase();
}

The choice of whether to transform by toUpperCase() or toLowerCase() is mostly arbitrary, and neither one is fully robust when extending beyond the Latin alphabet. For example, the German lowercase letter ß and ss are both transformed to SS by toUpperCase(), while the Turkish letter ı would be falsely reported as unequal to I by toLowerCase() unless specifically using toLocaleLowerCase("tr").
jsconst areEqualInUpperCase = (str1, str2) =>
  str1.toUpperCase() === str2.toUpperCase();
const areEqualInLowerCase = (str1, str2) =>
  str1.toLowerCase() === str2.toLowerCase();

areEqualInUpperCase("ß", "ss"); // true; should be false
areEqualInLowerCase("ı", "I"); // false; should be true

A locale-aware and robust solution for testing case-insensitive equality is to use the Intl.Collator API or the string's localeCompare() method — they share the same interface — with the sensitivity option set to "accent" or "base".
jsconst areEqual = (str1, str2, locale = "en-US") =>
  str1.localeCompare(str2, locale, { sensitivity: "accent" }) === 0;

areEqual("ß", "ss", "de"); // false
areEqual("ı", "I", "tr"); // true

The localeCompare() method enables string comparison in a similar fashion as strcmp() — it allows sorting strings in a locale-aware manner.String primitives and String objectsNote that JavaScript distinguishes between String objects and
primitive string values. (The same is true of
Boolean and Numbers.)
String literals (denoted by double or single quotes) and strings returned from
String calls in a non-constructor context (that is, called without using
the new keyword) are primitive strings. In contexts where a
method is to be invoked on a primitive string or a property lookup occurs, JavaScript
will automatically wrap the string primitive and call the method or perform the property
lookup on the wrapper object instead.
jsconst strPrim = "foo"; // A literal is a string primitive
const strPrim2 = String(1); // Coerced into the string primitive "1"
const strPrim3 = String(true); // Coerced into the string primitive "true"
const strObj = new String(strPrim); // String with new returns a string wrapper object.

console.log(typeof strPrim); // "string"
console.log(typeof strPrim2); // "string"
console.log(typeof strPrim3); // "string"
console.log(typeof strObj); // "object"


Warning:
You should rarely find yourself using String as a constructor.

String primitives and String objects also give different results when
using eval(). Primitives passed to
eval are treated as source code; String objects are treated as
all other objects are, by returning the object. For example:
jsconst s1 = "2 + 2"; // creates a string primitive
const s2 = new String("2 + 2"); // creates a String object
console.log(eval(s1)); // returns the number 4
console.log(eval(s2)); // returns the string "2 + 2"

For these reasons, the code may break when it encounters String objects
when it expects a primitive string instead, although generally, authors need not worry
about the distinction.
A String object can always be converted to its primitive counterpart with
the valueOf() method.
jsconsole.log(eval(s2.valueOf())); // returns the number 4
String coercionMany built-in operations that expect strings first coerce their arguments to strings (which is largely why String objects behave similarly to string primitives). The operation can be summarized as follows:

Strings are returned as-is.
undefined turns into "undefined".
null turns into "null".
true turns into "true"; false turns into "false".
Numbers are converted with the same algorithm as toString(10).
BigInts are converted with the same algorithm as toString(10).
Symbols throw a TypeError.
Objects are first converted to a primitive by calling its [Symbol.toPrimitive]() (with "string" as hint), toString(), and valueOf() methods, in that order. The resulting primitive is then converted to a string.

There are several ways to achieve nearly the same effect in JavaScript.

Template literal: `${x}` does exactly the string coercion steps explained above for the embedded expression.
The String() function: String(x) uses the same algorithm to convert x, except that Symbols don't throw a TypeError, but return "Symbol(description)", where description is the description of the Symbol.
Using the + operator: "" + x coerces its operand to a primitive instead of a string, and, for some objects, has entirely different behaviors from normal string coercion. See its reference page for more details.

Depending on your use case, you may want to use `${x}` (to mimic built-in behavior) or String(x) (to handle symbol values without throwing an error), but you should not use "" + x.UTF-16 characters, Unicode code points, and grapheme clustersStrings are represented fundamentally as sequences of UTF-16 code units. In UTF-16 encoding, every code unit is exact 16 bits long. This means there are a maximum of 216, or 65536 possible characters representable as single UTF-16 code units. This character set is called the basic multilingual plane (BMP), and includes the most common characters like the Latin, Greek, Cyrillic alphabets, as well as many East Asian characters. Each code unit can be written in a string with \u followed by exactly four hex digits.
However, the entire Unicode character set is much, much bigger than 65536. The extra characters are stored in UTF-16 as surrogate pairs, which are pairs of 16-bit code units that represent a single character. To avoid ambiguity, the two parts of the pair must be between 0xD800 and 0xDFFF, and these code units are not used to encode single-code-unit characters. (More precisely, leading surrogates, also called high-surrogate code units, have values between 0xD800 and 0xDBFF, inclusive, while trailing surrogates, also called low-surrogate code units, have values between 0xDC00 and 0xDFFF, inclusive.) Each Unicode character, comprised of one or two UTF-16 code units, is also called a Unicode code point. Each Unicode code point can be written in a string with \u{xxxxxx} where xxxxxx represents 1–6 hex digits.
A "lone surrogate" is a 16-bit code unit satisfying one of the descriptions below:

It is in the range 0xD800–0xDBFF, inclusive (i.e., is a leading surrogate), but it is the last code unit in the string, or the next code unit is not a trailing surrogate.
It is in the range 0xDC00–0xDFFF, inclusive (i.e., is a trailing surrogate), but it is the first code unit in the string, or the previous code unit is not a leading surrogate.

Lone surrogates do not represent any Unicode character. Although most JavaScript built-in methods handle them correctly because they all work based on UTF-16 code units, lone surrogates are often not valid values when interacting with other systems — for example, encodeURI() will throw a URIError for lone surrogates, because URI encoding uses UTF-8 encoding, which does not have any encoding for lone surrogates. Strings not containing any lone surrogates are called well-formed strings, and are safe to be used with functions that do not deal with UTF-16 (such as encodeURI() or TextEncoder). You can check if a string is well-formed with the isWellFormed() method, or sanitize lone surrogates with the toWellFormed() method.
On top of Unicode characters, there are certain sequences of Unicode characters that should be treated as one visual unit, known as a grapheme cluster. The most common case is emojis: many emojis that have a range of variations are actually formed by multiple emojis, usually joined by the <ZWJ> (U+200D) character.
You must be careful which level of characters you are iterating on. For example, split("") will split by UTF-16 code units and will separate surrogate pairs. String indexes also refer to the index of each UTF-16 code unit. On the other hand, [Symbol.iterator]() iterates by Unicode code points. Iterating through grapheme clusters will require some custom code.
js"😄".split(""); // ['\ud83d', '\ude04']; splits into two lone surrogates

// "Backhand Index Pointing Right: Dark Skin Tone"
[..."👉🏿"]; // ['👉', '🏿']
// splits into the basic "Backhand Index Pointing Right" emoji and
// the "Dark skin tone" emoji

// "Family: Man, Boy"
[..."👨‍👦"]; // [ '👨', '‍', '👦' ]
// splits into the "Man" and "Boy" emoji, joined by a ZWJ

// The United Nations flag
[..."🇺🇳"]; // [ '🇺', '🇳' ]
// splits into two "region indicator" letters "U" and "N".
// All flag emojis are formed by joining two region indicator letters
Constructor
String()

Creates String objects. When called as a function, it returns primitive values of type String.

Static methods
String.fromCharCode()

Returns a string created by using the specified sequence of Unicode values.

String.fromCodePoint()

Returns a string created by using the specified sequence of code points.

String.raw()

Returns a string created from a raw template string.

Instance propertiesThese properties are defined on String.prototype and shared by all String instances.

String.prototype.constructor

The constructor function that created the instance object. For String instances, the initial value is the String constructor.


These properties are own properties of each String instance.

length

Reflects the length of the string. Read-only.

Instance methods
String.prototype.at()

Returns the character (exactly one UTF-16 code unit) at the specified index. Accepts negative integers, which count back from the last string character.

String.prototype.charAt()

Returns the character (exactly one UTF-16 code unit) at the specified
index.

String.prototype.charCodeAt()

Returns a number that is the UTF-16 code unit value at the given
index.

String.prototype.codePointAt()

Returns a nonnegative integer Number that is the code point value of the UTF-16
encoded code point starting at the specified pos.

String.prototype.concat()

Combines the text of two (or more) strings and returns a new string.

String.prototype.endsWith()

Determines whether a string ends with the characters of the string
searchString.

String.prototype.includes()

Determines whether the calling string contains searchString.

String.prototype.indexOf()

Returns the index within this string of the first
occurrence of searchValue, or -1 if not found.

String.prototype.isWellFormed()

Returns a boolean indicating whether this string contains any lone surrogates.

String.prototype.lastIndexOf()

Returns the index within this string of the last
occurrence of searchValue, or -1 if not found.

String.prototype.localeCompare()

Returns a number indicating whether the reference string
compareString comes before, after, or is equivalent to the
given string in sort order.

String.prototype.match()

Used to match regular expression regexp against a string.

String.prototype.matchAll()

Returns an iterator of all regexp's matches.

String.prototype.normalize()

Returns the Unicode Normalization Form of the calling string value.

String.prototype.padEnd()

Pads the current string from the end with a given string and returns a new string of
the length targetLength.

String.prototype.padStart()

Pads the current string from the start with a given string and returns a new string
of the length targetLength.

String.prototype.repeat()

Returns a string consisting of the elements of the object repeated
count times.

String.prototype.replace()

Used to replace occurrences of searchFor using
replaceWith. searchFor may be a string
or Regular Expression, and replaceWith may be a string or
function.

String.prototype.replaceAll()

Used to replace all occurrences of searchFor using
replaceWith. searchFor may be a string
or Regular Expression, and replaceWith may be a string or
function.

String.prototype.search()

Search for a match between a regular expression regexp and
the calling string.

String.prototype.slice()

Extracts a section of a string and returns a new string.

String.prototype.split()

Returns an array of strings populated by splitting the calling string at occurrences
of the substring sep.

String.prototype.startsWith()

Determines whether the calling string begins with the characters of string
searchString.

String.prototype.substr() 
Deprecated


Returns a portion of the string, starting at the specified index and extending for a given number of characters afterwards.

String.prototype.substring()

Returns a new string containing characters of the calling string from (or between)
the specified index (or indices).

String.prototype.toLocaleLowerCase()

The characters within a string are converted to lowercase while respecting the
current locale.
For most languages, this will return the same as
toLowerCase().

String.prototype.toLocaleUpperCase()

The characters within a string are converted to uppercase while respecting the
current locale.
For most languages, this will return the same as
toUpperCase().

String.prototype.toLowerCase()

Returns the calling string value converted to lowercase.

String.prototype.toString()

Returns a string representing the specified object. Overrides the
Object.prototype.toString() method.

String.prototype.toUpperCase()

Returns the calling string value converted to uppercase.

String.prototype.toWellFormed()

Returns a string where all lone surrogates of this string are replaced with the Unicode replacement character U+FFFD.

String.prototype.trim()

Trims whitespace from the beginning and end of the string.

String.prototype.trimEnd()

Trims whitespace from the end of the string.

String.prototype.trimStart()

Trims whitespace from the beginning of the string.

String.prototype.valueOf()

Returns the primitive value of the specified object. Overrides the
Object.prototype.valueOf() method.

String.prototype[Symbol.iterator]()

Returns a new iterator object that iterates over the code points of a String value,
returning each code point as a String value.

HTML wrapper methods
Warning:
Deprecated. Avoid these methods.
They are of limited use, as they are based on a very old HTML standard and provide only a subset of the currently available HTML tags and attributes. Many of them create deprecated or non-standard markup today. In addition, they do string concatenation without any validation or sanitation, which makes them a potential security threat when directly inserted using innerHTML. Use DOM APIs such as document.createElement() instead.


String.prototype.anchor() 
Deprecated


<a name="name"> (hypertext target)

String.prototype.big() 
Deprecated

<big>
String.prototype.blink() 
Deprecated


<blink>

String.prototype.bold() 
Deprecated

<b>
String.prototype.fixed() 
Deprecated

<tt>
String.prototype.fontcolor() 
Deprecated


<font color="color">

String.prototype.fontsize() 
Deprecated


<font size="size">

String.prototype.italics() 
Deprecated

<i>
String.prototype.link() 
Deprecated


<a href="url"> (link to URL)

String.prototype.small() 
Deprecated

<small>
String.prototype.strike() 
Deprecated

<strike>
String.prototype.sub() 
Deprecated

<sub>
String.prototype.sup() 
Deprecated

<sup>

Note that these methods do not check if the string itself contains HTML tags, so it's possible to create invalid HTML:
js"</b>".bold(); // <b></b></b>

The only escaping they do is to replace " in the attribute value (for anchor(), fontcolor(), fontsize(), and link()) with &quot;.
js"foo".anchor('"Hello"'); // <a name="&quot;Hello&quot;">foo</a>
ExamplesString conversionThe String() function is a more reliable way of converting values to strings than calling the toString() method of the value, as the former works when used on null and undefined. For example:
js// You cannot access properties on null or undefined

const nullVar = null;
nullVar.toString(); // TypeError: Cannot read properties of null
String(nullVar); // "null"

const undefinedVar = undefined;
undefinedVar.toString(); // TypeError: Cannot read properties of undefined
String(undefinedVar); // "undefined"
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-string-objectsBrowser compatibilitySee also
Numbers and strings guide
RegExp
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nObject() constructorBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe Object() constructor turns the input into an object. Its behavior depends on the input's type.Syntaxjsnew Object()
new Object(value)

Object()
Object(value)


Note: Object() can be called with or without new, but sometimes with different effects. See Return value.
Parameters
value Optional

Any value.

Return valueWhen the Object() constructor itself is called or constructed, its return value is an object:

If the value is null or undefined, it creates and returns an empty object.
If the value is an object already, it returns the value.
Otherwise, it returns an object of a type that corresponds to the given value. For example, passing a BigInt primitive returns a BigInt wrapper object.

When Object() is constructed but new.target is not the Object constructor itself, the behavior is slightly different — it initializes a new object with new.target.prototype as its prototype. Any argument value is ignored. This may happen, for example, when Object() is implicitly called via super() in the constructor of a class that extends Object. In this case, even if you pass a number to super(), the this value inside the constructor does not become a Number instance.ExamplesCreating a new Objectjsconst o = new Object();
o.foo = 42;

console.log(o);
// { foo: 42 }
Using Object given undefined and null typesThe following examples store an empty Object object in o:
jsconst o = new Object();

jsconst o = new Object(undefined);

jsconst o = new Object(null);
Obtaining wrapper objects for BigInt and SymbolThe BigInt() and Symbol() constructors throw an error when called with new, to prevent the common mistake of creating a wrapper object instead of the primitive value. The only way to create a wrapper object for these types is to call Object() with them:
jsconst numberObj = new Number(1);
console.log(typeof numberObj); // "object"

const bigintObj = Object(1n);
console.log(typeof bigintObj); // "object"

const symbolObj = Object(Symbol("foo"));
console.log(typeof symbolObj); // "object"
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object-constructorBrowser compatibilitySee also
Object initializer\n\nObject() constructorBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe Object() constructor turns the input into an object. Its behavior depends on the input's type.Syntaxjsnew Object()
new Object(value)

Object()
Object(value)


Note: Object() can be called with or without new, but sometimes with different effects. See Return value.
Parameters
value Optional

Any value.

Return valueWhen the Object() constructor itself is called or constructed, its return value is an object:

If the value is null or undefined, it creates and returns an empty object.
If the value is an object already, it returns the value.
Otherwise, it returns an object of a type that corresponds to the given value. For example, passing a BigInt primitive returns a BigInt wrapper object.

When Object() is constructed but new.target is not the Object constructor itself, the behavior is slightly different — it initializes a new object with new.target.prototype as its prototype. Any argument value is ignored. This may happen, for example, when Object() is implicitly called via super() in the constructor of a class that extends Object. In this case, even if you pass a number to super(), the this value inside the constructor does not become a Number instance.ExamplesCreating a new Objectjsconst o = new Object();
o.foo = 42;

console.log(o);
// { foo: 42 }
Using Object given undefined and null typesThe following examples store an empty Object object in o:
jsconst o = new Object();

jsconst o = new Object(undefined);

jsconst o = new Object(null);
Obtaining wrapper objects for BigInt and SymbolThe BigInt() and Symbol() constructors throw an error when called with new, to prevent the common mistake of creating a wrapper object instead of the primitive value. The only way to create a wrapper object for these types is to call Object() with them:
jsconst numberObj = new Number(1);
console.log(typeof numberObj); // "object"

const bigintObj = Object(1n);
console.log(typeof bigintObj); // "object"

const symbolObj = Object(Symbol("foo"));
console.log(typeof symbolObj); // "object"
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object-constructorBrowser compatibilitySee also
Object initializer
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Sep 8, 2023 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nObject() constructorBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe Object() constructor turns the input into an object. Its behavior depends on the input's type.Syntaxjsnew Object()
new Object(value)

Object()
Object(value)


Note: Object() can be called with or without new, but sometimes with different effects. See Return value.
Parameters
value Optional

Any value.

Return valueWhen the Object() constructor itself is called or constructed, its return value is an object:

If the value is null or undefined, it creates and returns an empty object.
If the value is an object already, it returns the value.
Otherwise, it returns an object of a type that corresponds to the given value. For example, passing a BigInt primitive returns a BigInt wrapper object.

When Object() is constructed but new.target is not the Object constructor itself, the behavior is slightly different — it initializes a new object with new.target.prototype as its prototype. Any argument value is ignored. This may happen, for example, when Object() is implicitly called via super() in the constructor of a class that extends Object. In this case, even if you pass a number to super(), the this value inside the constructor does not become a Number instance.ExamplesCreating a new Objectjsconst o = new Object();
o.foo = 42;

console.log(o);
// { foo: 42 }
Using Object given undefined and null typesThe following examples store an empty Object object in o:
jsconst o = new Object();

jsconst o = new Object(undefined);

jsconst o = new Object(null);
Obtaining wrapper objects for BigInt and SymbolThe BigInt() and Symbol() constructors throw an error when called with new, to prevent the common mistake of creating a wrapper object instead of the primitive value. The only way to create a wrapper object for these types is to call Object() with them:
jsconst numberObj = new Number(1);
console.log(typeof numberObj); // "object"

const bigintObj = Object(1n);
console.log(typeof bigintObj); // "object"

const symbolObj = Object(Symbol("foo"));
console.log(typeof symbolObj); // "object"
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object-constructorBrowser compatibilitySee also
Object initializer
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Sep 8, 2023 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nundefinedBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe undefined global property represents the primitive
value undefined. It is one of JavaScript's
primitive types.Try it
function test(t) {
  if (t === undefined) {
    return "Undefined value!";
  }
  return t;
}

let x;

console.log(test(x));
// Expected output: "Undefined value!"
ValueThe primitive value undefined.
Property attributes of undefinedWritablenoEnumerablenoConfigurablenoDescriptionundefined is a property of the global object. That is, it is a variable in global scope.
In all non-legacy browsers, undefined is a non-configurable, non-writable property. Even when this is not the case, avoid overriding it.
A variable that has not been assigned a value is of type undefined. A
method or statement also returns undefined if the variable that is being
evaluated does not have an assigned value. A function returns undefined if
a value was not returned.

Note:
While you can use undefined as an identifier (variable name) in any scope other than the global scope (because undefined is not a reserved word), doing so is a very bad idea that will make your code difficult to maintain and debug.
js// DON'T DO THIS

(() => {
  const undefined = "foo";
  console.log(undefined, typeof undefined); // foo string
})();

((undefined) => {
  console.log(undefined, typeof undefined); // foo string
})("foo");

ExamplesStrict equality and undefinedYou can use undefined and the strict equality and inequality operators to
determine whether a variable has a value. In the following code, the variable
x is not initialized, and the if statement evaluates to true.
jslet x;
if (x === undefined) {
  // these statements execute
} else {
  // these statements do not execute
}


Note:
The strict equality operator (as opposed to the
standard equality operator) must be used here, because
x == undefined also checks whether x is null,
while strict equality doesn't. This is because null is not equivalent to
undefined.
See Equality comparison and sameness for details.
typeof operator and undefinedAlternatively, typeof can be used:
jslet x;
if (typeof x === "undefined") {
  // these statements execute
}

One reason to use typeof is that it does not throw an
error if the variable has not been declared.
js// x has not been declared before
// evaluates to true without errors
if (typeof x === "undefined") {
  // these statements execute
}

// Throws a ReferenceError
if (x === undefined) {
}

However, there is another alternative. JavaScript is a statically scoped language, so
knowing if a variable is declared can be read by seeing whether it is declared in an
enclosing context.
The global scope is bound to the global object, so
checking the existence of a variable in the global context can be done by checking the
existence of a property on the global object, using the
in operator, for instance:
jsif ("x" in window) {
  // These statements execute only if x is defined globally
}
void operator and undefinedThe void operator is a third alternative.
jslet x;
if (x === void 0) {
  // these statements execute
}

// y has not been declared before
if (y === void 0) {
  // throws Uncaught ReferenceError: y is not defined
}
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-undefinedBrowser compatibilitySee also
JavaScript data types and data structures
null\n\nundefinedBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe undefined global property represents the primitive
value undefined. It is one of JavaScript's
primitive types.Try it
function test(t) {
  if (t === undefined) {
    return "Undefined value!";
  }
  return t;
}

let x;

console.log(test(x));
// Expected output: "Undefined value!"
ValueThe primitive value undefined.
Property attributes of undefinedWritablenoEnumerablenoConfigurablenoDescriptionundefined is a property of the global object. That is, it is a variable in global scope.
In all non-legacy browsers, undefined is a non-configurable, non-writable property. Even when this is not the case, avoid overriding it.
A variable that has not been assigned a value is of type undefined. A
method or statement also returns undefined if the variable that is being
evaluated does not have an assigned value. A function returns undefined if
a value was not returned.

Note:
While you can use undefined as an identifier (variable name) in any scope other than the global scope (because undefined is not a reserved word), doing so is a very bad idea that will make your code difficult to maintain and debug.
js// DON'T DO THIS

(() => {
  const undefined = "foo";
  console.log(undefined, typeof undefined); // foo string
})();

((undefined) => {
  console.log(undefined, typeof undefined); // foo string
})("foo");

ExamplesStrict equality and undefinedYou can use undefined and the strict equality and inequality operators to
determine whether a variable has a value. In the following code, the variable
x is not initialized, and the if statement evaluates to true.
jslet x;
if (x === undefined) {
  // these statements execute
} else {
  // these statements do not execute
}


Note:
The strict equality operator (as opposed to the
standard equality operator) must be used here, because
x == undefined also checks whether x is null,
while strict equality doesn't. This is because null is not equivalent to
undefined.
See Equality comparison and sameness for details.
typeof operator and undefinedAlternatively, typeof can be used:
jslet x;
if (typeof x === "undefined") {
  // these statements execute
}

One reason to use typeof is that it does not throw an
error if the variable has not been declared.
js// x has not been declared before
// evaluates to true without errors
if (typeof x === "undefined") {
  // these statements execute
}

// Throws a ReferenceError
if (x === undefined) {
}

However, there is another alternative. JavaScript is a statically scoped language, so
knowing if a variable is declared can be read by seeing whether it is declared in an
enclosing context.
The global scope is bound to the global object, so
checking the existence of a variable in the global context can be done by checking the
existence of a property on the global object, using the
in operator, for instance:
jsif ("x" in window) {
  // These statements execute only if x is defined globally
}
void operator and undefinedThe void operator is a third alternative.
jslet x;
if (x === void 0) {
  // these statements execute
}

// y has not been declared before
if (y === void 0) {
  // throws Uncaught ReferenceError: y is not defined
}
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-undefinedBrowser compatibilitySee also
JavaScript data types and data structures
null
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nundefinedBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe undefined global property represents the primitive
value undefined. It is one of JavaScript's
primitive types.Try it
function test(t) {
  if (t === undefined) {
    return "Undefined value!";
  }
  return t;
}

let x;

console.log(test(x));
// Expected output: "Undefined value!"
ValueThe primitive value undefined.
Property attributes of undefinedWritablenoEnumerablenoConfigurablenoDescriptionundefined is a property of the global object. That is, it is a variable in global scope.
In all non-legacy browsers, undefined is a non-configurable, non-writable property. Even when this is not the case, avoid overriding it.
A variable that has not been assigned a value is of type undefined. A
method or statement also returns undefined if the variable that is being
evaluated does not have an assigned value. A function returns undefined if
a value was not returned.

Note:
While you can use undefined as an identifier (variable name) in any scope other than the global scope (because undefined is not a reserved word), doing so is a very bad idea that will make your code difficult to maintain and debug.
js// DON'T DO THIS

(() => {
  const undefined = "foo";
  console.log(undefined, typeof undefined); // foo string
})();

((undefined) => {
  console.log(undefined, typeof undefined); // foo string
})("foo");

ExamplesStrict equality and undefinedYou can use undefined and the strict equality and inequality operators to
determine whether a variable has a value. In the following code, the variable
x is not initialized, and the if statement evaluates to true.
jslet x;
if (x === undefined) {
  // these statements execute
} else {
  // these statements do not execute
}


Note:
The strict equality operator (as opposed to the
standard equality operator) must be used here, because
x == undefined also checks whether x is null,
while strict equality doesn't. This is because null is not equivalent to
undefined.
See Equality comparison and sameness for details.
typeof operator and undefinedAlternatively, typeof can be used:
jslet x;
if (typeof x === "undefined") {
  // these statements execute
}

One reason to use typeof is that it does not throw an
error if the variable has not been declared.
js// x has not been declared before
// evaluates to true without errors
if (typeof x === "undefined") {
  // these statements execute
}

// Throws a ReferenceError
if (x === undefined) {
}

However, there is another alternative. JavaScript is a statically scoped language, so
knowing if a variable is declared can be read by seeing whether it is declared in an
enclosing context.
The global scope is bound to the global object, so
checking the existence of a variable in the global context can be done by checking the
existence of a property on the global object, using the
in operator, for instance:
jsif ("x" in window) {
  // These statements execute only if x is defined globally
}
void operator and undefinedThe void operator is a third alternative.
jslet x;
if (x === void 0) {
  // these statements execute
}

// y has not been declared before
if (y === void 0) {
  // throws Uncaught ReferenceError: y is not defined
}
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-undefinedBrowser compatibilitySee also
JavaScript data types and data structures
null
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nFunctionBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Function object provides methods for functions. In JavaScript, every function is actually a Function object.Constructor
Function()

Creates a new Function object. Calling the constructor directly can create functions dynamically but suffers from security and similar (but far less significant) performance issues to eval(). However, unlike eval(), the Function constructor creates functions that execute in the global scope only.

Instance propertiesThese properties are defined on Function.prototype and shared by all Function instances.

Function.prototype.arguments 
Deprecated
 
Non-standard


Represents the arguments passed to this function. For strict, arrow, async, and generator functions, accessing the arguments property throws a TypeError. Use the arguments object inside function closures instead.

Function.prototype.caller 
Deprecated
 
Non-standard


Represents the function that invoked this function. For strict, arrow, async, and generator functions, accessing the caller property throws a TypeError.

Function.prototype.constructor

The constructor function that created the instance object. For Function instances, the initial value is the Function constructor.


These properties are own properties of each Function instance.

displayName 
Non-standard
 Optional

The display name of the function.

length

Specifies the number of arguments expected by the function.

name

The name of the function.

prototype

Used when the function is used as a constructor with the new operator. It will become the new object's prototype.

Instance methods
Function.prototype.apply()

Calls a function with a given this value and optional arguments provided as an array (or an array-like object).

Function.prototype.bind()

Creates a new function that, when called, has its this keyword set to a provided value, optionally with a given sequence of arguments preceding any provided when the new function is called.

Function.prototype.call()

Calls a function with a given this value and optional arguments.

Function.prototype.toString()

Returns a string representing the source code of the function.
Overrides the Object.prototype.toString method.

Function.prototype[Symbol.hasInstance]()

Specifies the default procedure for determining if a constructor function recognizes an object as one of the constructor's instances. Called by the instanceof operator.

ExamplesDifference between Function constructor and function declarationFunctions created with the Function constructor do not create closures to their creation contexts; they always are created in the global scope. When running them, they will only be able to access their own local variables and global ones, not the ones from the scope in which the Function constructor was created. This is different from using eval() with code for a function expression.
js// Create a global property with `var`
var x = 10;

function createFunction1() {
  const x = 20;
  return new Function("return x;"); // this `x` refers to global `x`
}

function createFunction2() {
  const x = 20;
  function f() {
    return x; // this `x` refers to the local `x` above
  }
  return f;
}

const f1 = createFunction1();
console.log(f1()); // 10
const f2 = createFunction2();
console.log(f2()); // 20

While this code works in web browsers, f1() will produce a ReferenceError in Node.js, as x will not be found. This is because the top-level scope in Node is not the global scope, and x will be local to the module.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-function-objectsBrowser compatibilitySee also
function
function expression
AsyncFunction
AsyncGeneratorFunction
GeneratorFunction
Functions\n\nFunctionBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Function object provides methods for functions. In JavaScript, every function is actually a Function object.Constructor
Function()

Creates a new Function object. Calling the constructor directly can create functions dynamically but suffers from security and similar (but far less significant) performance issues to eval(). However, unlike eval(), the Function constructor creates functions that execute in the global scope only.

Instance propertiesThese properties are defined on Function.prototype and shared by all Function instances.

Function.prototype.arguments 
Deprecated
 
Non-standard


Represents the arguments passed to this function. For strict, arrow, async, and generator functions, accessing the arguments property throws a TypeError. Use the arguments object inside function closures instead.

Function.prototype.caller 
Deprecated
 
Non-standard


Represents the function that invoked this function. For strict, arrow, async, and generator functions, accessing the caller property throws a TypeError.

Function.prototype.constructor

The constructor function that created the instance object. For Function instances, the initial value is the Function constructor.


These properties are own properties of each Function instance.

displayName 
Non-standard
 Optional

The display name of the function.

length

Specifies the number of arguments expected by the function.

name

The name of the function.

prototype

Used when the function is used as a constructor with the new operator. It will become the new object's prototype.

Instance methods
Function.prototype.apply()

Calls a function with a given this value and optional arguments provided as an array (or an array-like object).

Function.prototype.bind()

Creates a new function that, when called, has its this keyword set to a provided value, optionally with a given sequence of arguments preceding any provided when the new function is called.

Function.prototype.call()

Calls a function with a given this value and optional arguments.

Function.prototype.toString()

Returns a string representing the source code of the function.
Overrides the Object.prototype.toString method.

Function.prototype[Symbol.hasInstance]()

Specifies the default procedure for determining if a constructor function recognizes an object as one of the constructor's instances. Called by the instanceof operator.

ExamplesDifference between Function constructor and function declarationFunctions created with the Function constructor do not create closures to their creation contexts; they always are created in the global scope. When running them, they will only be able to access their own local variables and global ones, not the ones from the scope in which the Function constructor was created. This is different from using eval() with code for a function expression.
js// Create a global property with `var`
var x = 10;

function createFunction1() {
  const x = 20;
  return new Function("return x;"); // this `x` refers to global `x`
}

function createFunction2() {
  const x = 20;
  function f() {
    return x; // this `x` refers to the local `x` above
  }
  return f;
}

const f1 = createFunction1();
console.log(f1()); // 10
const f2 = createFunction2();
console.log(f2()); // 20

While this code works in web browsers, f1() will produce a ReferenceError in Node.js, as x will not be found. This is because the top-level scope in Node is not the global scope, and x will be local to the module.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-function-objectsBrowser compatibilitySee also
function
function expression
AsyncFunction
AsyncGeneratorFunction
GeneratorFunction
Functions
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jul 15, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nFunctionBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Function object provides methods for functions. In JavaScript, every function is actually a Function object.Constructor
Function()

Creates a new Function object. Calling the constructor directly can create functions dynamically but suffers from security and similar (but far less significant) performance issues to eval(). However, unlike eval(), the Function constructor creates functions that execute in the global scope only.

Instance propertiesThese properties are defined on Function.prototype and shared by all Function instances.

Function.prototype.arguments 
Deprecated
 
Non-standard


Represents the arguments passed to this function. For strict, arrow, async, and generator functions, accessing the arguments property throws a TypeError. Use the arguments object inside function closures instead.

Function.prototype.caller 
Deprecated
 
Non-standard


Represents the function that invoked this function. For strict, arrow, async, and generator functions, accessing the caller property throws a TypeError.

Function.prototype.constructor

The constructor function that created the instance object. For Function instances, the initial value is the Function constructor.


These properties are own properties of each Function instance.

displayName 
Non-standard
 Optional

The display name of the function.

length

Specifies the number of arguments expected by the function.

name

The name of the function.

prototype

Used when the function is used as a constructor with the new operator. It will become the new object's prototype.

Instance methods
Function.prototype.apply()

Calls a function with a given this value and optional arguments provided as an array (or an array-like object).

Function.prototype.bind()

Creates a new function that, when called, has its this keyword set to a provided value, optionally with a given sequence of arguments preceding any provided when the new function is called.

Function.prototype.call()

Calls a function with a given this value and optional arguments.

Function.prototype.toString()

Returns a string representing the source code of the function.
Overrides the Object.prototype.toString method.

Function.prototype[Symbol.hasInstance]()

Specifies the default procedure for determining if a constructor function recognizes an object as one of the constructor's instances. Called by the instanceof operator.

ExamplesDifference between Function constructor and function declarationFunctions created with the Function constructor do not create closures to their creation contexts; they always are created in the global scope. When running them, they will only be able to access their own local variables and global ones, not the ones from the scope in which the Function constructor was created. This is different from using eval() with code for a function expression.
js// Create a global property with `var`
var x = 10;

function createFunction1() {
  const x = 20;
  return new Function("return x;"); // this `x` refers to global `x`
}

function createFunction2() {
  const x = 20;
  function f() {
    return x; // this `x` refers to the local `x` above
  }
  return f;
}

const f1 = createFunction1();
console.log(f1()); // 10
const f2 = createFunction2();
console.log(f2()); // 20

While this code works in web browsers, f1() will produce a ReferenceError in Node.js, as x will not be found. This is because the top-level scope in Node is not the global scope, and x will be local to the module.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-function-objectsBrowser compatibilitySee also
function
function expression
AsyncFunction
AsyncGeneratorFunction
GeneratorFunction
Functions
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jul 15, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nInfinityBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe Infinity global property is a numeric value representing infinity.Try it
const maxNumber = Math.pow(10, 1000); // Max positive number

if (maxNumber === Infinity) {
  console.log("Let's call it Infinity!");
  // Expected output: "Let's call it Infinity!"
}

console.log(1 / maxNumber);
// Expected output: 0
ValueThe same number value as Number.POSITIVE_INFINITY.
Property attributes of InfinityWritablenoEnumerablenoConfigurablenoDescriptionInfinity is a property of the global object. In other words, it is a variable in global scope.
The value Infinity (positive infinity) is greater than any other number.
This value behaves slightly differently than mathematical infinity; see Number.POSITIVE_INFINITY for details.ExamplesUsing Infinityjsconsole.log(Infinity); /* Infinity */
console.log(Infinity + 1); /* Infinity */
console.log(Math.pow(10, 1000)); /* Infinity */
console.log(Math.log(0)); /* -Infinity */
console.log(1 / Infinity); /* 0 */
console.log(1 / 0); /* Infinity */
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-value-properties-of-the-global-object-infinityBrowser compatibilitySee also
Number.NEGATIVE_INFINITY
Number.POSITIVE_INFINITY
Number.isFinite\n\nInfinityBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe Infinity global property is a numeric value representing infinity.Try it
const maxNumber = Math.pow(10, 1000); // Max positive number

if (maxNumber === Infinity) {
  console.log("Let's call it Infinity!");
  // Expected output: "Let's call it Infinity!"
}

console.log(1 / maxNumber);
// Expected output: 0
ValueThe same number value as Number.POSITIVE_INFINITY.
Property attributes of InfinityWritablenoEnumerablenoConfigurablenoDescriptionInfinity is a property of the global object. In other words, it is a variable in global scope.
The value Infinity (positive infinity) is greater than any other number.
This value behaves slightly differently than mathematical infinity; see Number.POSITIVE_INFINITY for details.ExamplesUsing Infinityjsconsole.log(Infinity); /* Infinity */
console.log(Infinity + 1); /* Infinity */
console.log(Math.pow(10, 1000)); /* Infinity */
console.log(Math.log(0)); /* -Infinity */
console.log(1 / Infinity); /* 0 */
console.log(1 / 0); /* Infinity */
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-value-properties-of-the-global-object-infinityBrowser compatibilitySee also
Number.NEGATIVE_INFINITY
Number.POSITIVE_INFINITY
Number.isFinite
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nInfinityBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe Infinity global property is a numeric value representing infinity.Try it
const maxNumber = Math.pow(10, 1000); // Max positive number

if (maxNumber === Infinity) {
  console.log("Let's call it Infinity!");
  // Expected output: "Let's call it Infinity!"
}

console.log(1 / maxNumber);
// Expected output: 0
ValueThe same number value as Number.POSITIVE_INFINITY.
Property attributes of InfinityWritablenoEnumerablenoConfigurablenoDescriptionInfinity is a property of the global object. In other words, it is a variable in global scope.
The value Infinity (positive infinity) is greater than any other number.
This value behaves slightly differently than mathematical infinity; see Number.POSITIVE_INFINITY for details.ExamplesUsing Infinityjsconsole.log(Infinity); /* Infinity */
console.log(Infinity + 1); /* Infinity */
console.log(Math.pow(10, 1000)); /* Infinity */
console.log(Math.log(0)); /* -Infinity */
console.log(1 / Infinity); /* 0 */
console.log(1 / 0); /* Infinity */
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-value-properties-of-the-global-object-infinityBrowser compatibilitySee also
Number.NEGATIVE_INFINITY
Number.POSITIVE_INFINITY
Number.isFinite
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nNaNBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe NaN global property is a value representing Not-A-Number.Try it
function sanitize(x) {
  if (isNaN(x)) {
    return NaN;
  }
  return x;
}

console.log(sanitize("1"));
// Expected output: "1"

console.log(sanitize("NotANumber"));
// Expected output: NaN
ValueThe same number value as Number.NaN.
Property attributes of NaNWritablenoEnumerablenoConfigurablenoDescriptionNaN is a property of the global object. In other words, it is a variable in global scope.
In modern browsers, NaN is a non-configurable, non-writable property. Even when this is not the case, avoid overriding it.
There are five different types of operations that return NaN:

Failed number conversion (e.g., explicit ones like parseInt("blabla"), Number(undefined), or implicit ones like Math.abs(undefined))
Math operation where the result is not a real number (e.g., Math.sqrt(-1))
Indeterminate form (e.g., 0 * Infinity, 1 ** Infinity, Infinity / Infinity, Infinity - Infinity)
A method or expression whose operand is or gets coerced to NaN (e.g., 7 ** NaN, 7 * "blabla") — this means NaN is contagious
Other cases where an invalid value is to be represented as a number (e.g., an invalid Date new Date("blabla").getTime(), "".charCodeAt(1))

NaN and its behaviors are not invented by JavaScript. Its semantics in floating point arithmetic (including that NaN !== NaN) are specified by IEEE 754. NaN's behaviors include:

If NaN is involved in a mathematical operation (but not bitwise operations), the result is usually also NaN. (See counter-example below.)
When NaN is one of the operands of any relational comparison (>, <, >=, <=), the result is always false.
NaN compares unequal (via ==, !=, ===, and !==) to any other value — including to another NaN value.

NaN is also one of the falsy values in JavaScript.ExamplesTesting against NaNTo tell if a value is NaN, use Number.isNaN() or isNaN() to most clearly determine whether a value is NaN — or, since NaN is the only value that compares unequal to itself, you can perform a self-comparison like x !== x.
jsNaN === NaN; // false
Number.NaN === NaN; // false
isNaN(NaN); // true
isNaN(Number.NaN); // true
Number.isNaN(NaN); // true

function valueIsNaN(v) {
  return v !== v;
}
valueIsNaN(1); // false
valueIsNaN(NaN); // true
valueIsNaN(Number.NaN); // true

However, do note the difference between isNaN() and Number.isNaN(): the former will return true if the value is currently NaN, or if it is going to be NaN after it is coerced to a number, while the latter will return true only if the value is currently NaN:
jsisNaN("hello world"); // true
Number.isNaN("hello world"); // false

For the same reason, using a BigInt value will throw an error with isNaN() and not with Number.isNaN():
jsisNaN(1n); // TypeError: Conversion from 'BigInt' to 'number' is not allowed.
Number.isNaN(1n); // false

Additionally, some array methods cannot find NaN, while others can. Namely, the index-finding ones (indexOf(), lastIndexOf()) cannot find NaN, while the value-finding ones (includes()) can:
jsconst arr = [2, 4, NaN, 12];
arr.indexOf(NaN); // -1
arr.includes(NaN); // true

// Methods accepting a properly defined predicate can always find NaN
arr.findIndex((n) => Number.isNaN(n)); // 2

For more information about NaN and its comparison, see Equality comparison and sameness.Observably distinct NaN valuesIt's possible to produce two floating point numbers with different binary representations but are both NaN, because in IEEE 754 encoding, any floating point number with exponent 0x7ff and a non-zero mantissa is NaN. In JavaScript, you can do bit-level manipulation using typed arrays.
jsconst f2b = (x) => new Uint8Array(new Float64Array([x]).buffer);
const b2f = (x) => new Float64Array(x.buffer)[0];
// Get a byte representation of NaN
const n = f2b(NaN);
const m = f2b(NaN);
// Change the sign bit, which doesn't matter for NaN
n[7] += 2 ** 7;
// n[0] += 2**7; for big endian processors
const nan2 = b2f(n);
console.log(nan2); // NaN
console.log(Object.is(nan2, NaN)); // true
console.log(f2b(NaN)); // Uint8Array(8) [0, 0, 0, 0, 0, 0, 248, 127]
console.log(f2b(nan2)); // Uint8Array(8) [0, 0, 0, 0, 0, 0, 248, 255]
// Change the first bit, which is the least significant bit of the mantissa and doesn't matter for NaN
m[0] = 1;
// m[7] = 1; for big endian processors
const nan3 = b2f(m);
console.log(nan3); // NaN
console.log(Object.is(nan3, NaN)); // true
console.log(f2b(NaN)); // Uint8Array(8) [0, 0, 0, 0, 0, 0, 248, 127]
console.log(f2b(nan3)); // Uint8Array(8) [1, 0, 0, 0, 0, 0, 248, 127]
Silently escaping NaNNaN propagates through mathematical operations, so it's usually sufficient to test for NaN once at the end of calculation to detect error conditions. The only case where NaN gets silently escaped is when using exponentiation with an exponent of 0, which immediately returns 1 without testing the base's value.
jsNaN ** 0 === 1; // true
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-value-properties-of-the-global-object-nanBrowser compatibilitySee also
Number.NaN
Number.isNaN()
isNaN()\n\nNaNBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe NaN global property is a value representing Not-A-Number.Try it
function sanitize(x) {
  if (isNaN(x)) {
    return NaN;
  }
  return x;
}

console.log(sanitize("1"));
// Expected output: "1"

console.log(sanitize("NotANumber"));
// Expected output: NaN
ValueThe same number value as Number.NaN.
Property attributes of NaNWritablenoEnumerablenoConfigurablenoDescriptionNaN is a property of the global object. In other words, it is a variable in global scope.
In modern browsers, NaN is a non-configurable, non-writable property. Even when this is not the case, avoid overriding it.
There are five different types of operations that return NaN:

Failed number conversion (e.g., explicit ones like parseInt("blabla"), Number(undefined), or implicit ones like Math.abs(undefined))
Math operation where the result is not a real number (e.g., Math.sqrt(-1))
Indeterminate form (e.g., 0 * Infinity, 1 ** Infinity, Infinity / Infinity, Infinity - Infinity)
A method or expression whose operand is or gets coerced to NaN (e.g., 7 ** NaN, 7 * "blabla") — this means NaN is contagious
Other cases where an invalid value is to be represented as a number (e.g., an invalid Date new Date("blabla").getTime(), "".charCodeAt(1))

NaN and its behaviors are not invented by JavaScript. Its semantics in floating point arithmetic (including that NaN !== NaN) are specified by IEEE 754. NaN's behaviors include:

If NaN is involved in a mathematical operation (but not bitwise operations), the result is usually also NaN. (See counter-example below.)
When NaN is one of the operands of any relational comparison (>, <, >=, <=), the result is always false.
NaN compares unequal (via ==, !=, ===, and !==) to any other value — including to another NaN value.

NaN is also one of the falsy values in JavaScript.ExamplesTesting against NaNTo tell if a value is NaN, use Number.isNaN() or isNaN() to most clearly determine whether a value is NaN — or, since NaN is the only value that compares unequal to itself, you can perform a self-comparison like x !== x.
jsNaN === NaN; // false
Number.NaN === NaN; // false
isNaN(NaN); // true
isNaN(Number.NaN); // true
Number.isNaN(NaN); // true

function valueIsNaN(v) {
  return v !== v;
}
valueIsNaN(1); // false
valueIsNaN(NaN); // true
valueIsNaN(Number.NaN); // true

However, do note the difference between isNaN() and Number.isNaN(): the former will return true if the value is currently NaN, or if it is going to be NaN after it is coerced to a number, while the latter will return true only if the value is currently NaN:
jsisNaN("hello world"); // true
Number.isNaN("hello world"); // false

For the same reason, using a BigInt value will throw an error with isNaN() and not with Number.isNaN():
jsisNaN(1n); // TypeError: Conversion from 'BigInt' to 'number' is not allowed.
Number.isNaN(1n); // false

Additionally, some array methods cannot find NaN, while others can. Namely, the index-finding ones (indexOf(), lastIndexOf()) cannot find NaN, while the value-finding ones (includes()) can:
jsconst arr = [2, 4, NaN, 12];
arr.indexOf(NaN); // -1
arr.includes(NaN); // true

// Methods accepting a properly defined predicate can always find NaN
arr.findIndex((n) => Number.isNaN(n)); // 2

For more information about NaN and its comparison, see Equality comparison and sameness.Observably distinct NaN valuesIt's possible to produce two floating point numbers with different binary representations but are both NaN, because in IEEE 754 encoding, any floating point number with exponent 0x7ff and a non-zero mantissa is NaN. In JavaScript, you can do bit-level manipulation using typed arrays.
jsconst f2b = (x) => new Uint8Array(new Float64Array([x]).buffer);
const b2f = (x) => new Float64Array(x.buffer)[0];
// Get a byte representation of NaN
const n = f2b(NaN);
const m = f2b(NaN);
// Change the sign bit, which doesn't matter for NaN
n[7] += 2 ** 7;
// n[0] += 2**7; for big endian processors
const nan2 = b2f(n);
console.log(nan2); // NaN
console.log(Object.is(nan2, NaN)); // true
console.log(f2b(NaN)); // Uint8Array(8) [0, 0, 0, 0, 0, 0, 248, 127]
console.log(f2b(nan2)); // Uint8Array(8) [0, 0, 0, 0, 0, 0, 248, 255]
// Change the first bit, which is the least significant bit of the mantissa and doesn't matter for NaN
m[0] = 1;
// m[7] = 1; for big endian processors
const nan3 = b2f(m);
console.log(nan3); // NaN
console.log(Object.is(nan3, NaN)); // true
console.log(f2b(NaN)); // Uint8Array(8) [0, 0, 0, 0, 0, 0, 248, 127]
console.log(f2b(nan3)); // Uint8Array(8) [1, 0, 0, 0, 0, 0, 248, 127]
Silently escaping NaNNaN propagates through mathematical operations, so it's usually sufficient to test for NaN once at the end of calculation to detect error conditions. The only case where NaN gets silently escaped is when using exponentiation with an exponent of 0, which immediately returns 1 without testing the base's value.
jsNaN ** 0 === 1; // true
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-value-properties-of-the-global-object-nanBrowser compatibilitySee also
Number.NaN
Number.isNaN()
isNaN()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nNaNBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe NaN global property is a value representing Not-A-Number.Try it
function sanitize(x) {
  if (isNaN(x)) {
    return NaN;
  }
  return x;
}

console.log(sanitize("1"));
// Expected output: "1"

console.log(sanitize("NotANumber"));
// Expected output: NaN
ValueThe same number value as Number.NaN.
Property attributes of NaNWritablenoEnumerablenoConfigurablenoDescriptionNaN is a property of the global object. In other words, it is a variable in global scope.
In modern browsers, NaN is a non-configurable, non-writable property. Even when this is not the case, avoid overriding it.
There are five different types of operations that return NaN:

Failed number conversion (e.g., explicit ones like parseInt("blabla"), Number(undefined), or implicit ones like Math.abs(undefined))
Math operation where the result is not a real number (e.g., Math.sqrt(-1))
Indeterminate form (e.g., 0 * Infinity, 1 ** Infinity, Infinity / Infinity, Infinity - Infinity)
A method or expression whose operand is or gets coerced to NaN (e.g., 7 ** NaN, 7 * "blabla") — this means NaN is contagious
Other cases where an invalid value is to be represented as a number (e.g., an invalid Date new Date("blabla").getTime(), "".charCodeAt(1))

NaN and its behaviors are not invented by JavaScript. Its semantics in floating point arithmetic (including that NaN !== NaN) are specified by IEEE 754. NaN's behaviors include:

If NaN is involved in a mathematical operation (but not bitwise operations), the result is usually also NaN. (See counter-example below.)
When NaN is one of the operands of any relational comparison (>, <, >=, <=), the result is always false.
NaN compares unequal (via ==, !=, ===, and !==) to any other value — including to another NaN value.

NaN is also one of the falsy values in JavaScript.ExamplesTesting against NaNTo tell if a value is NaN, use Number.isNaN() or isNaN() to most clearly determine whether a value is NaN — or, since NaN is the only value that compares unequal to itself, you can perform a self-comparison like x !== x.
jsNaN === NaN; // false
Number.NaN === NaN; // false
isNaN(NaN); // true
isNaN(Number.NaN); // true
Number.isNaN(NaN); // true

function valueIsNaN(v) {
  return v !== v;
}
valueIsNaN(1); // false
valueIsNaN(NaN); // true
valueIsNaN(Number.NaN); // true

However, do note the difference between isNaN() and Number.isNaN(): the former will return true if the value is currently NaN, or if it is going to be NaN after it is coerced to a number, while the latter will return true only if the value is currently NaN:
jsisNaN("hello world"); // true
Number.isNaN("hello world"); // false

For the same reason, using a BigInt value will throw an error with isNaN() and not with Number.isNaN():
jsisNaN(1n); // TypeError: Conversion from 'BigInt' to 'number' is not allowed.
Number.isNaN(1n); // false

Additionally, some array methods cannot find NaN, while others can. Namely, the index-finding ones (indexOf(), lastIndexOf()) cannot find NaN, while the value-finding ones (includes()) can:
jsconst arr = [2, 4, NaN, 12];
arr.indexOf(NaN); // -1
arr.includes(NaN); // true

// Methods accepting a properly defined predicate can always find NaN
arr.findIndex((n) => Number.isNaN(n)); // 2

For more information about NaN and its comparison, see Equality comparison and sameness.Observably distinct NaN valuesIt's possible to produce two floating point numbers with different binary representations but are both NaN, because in IEEE 754 encoding, any floating point number with exponent 0x7ff and a non-zero mantissa is NaN. In JavaScript, you can do bit-level manipulation using typed arrays.
jsconst f2b = (x) => new Uint8Array(new Float64Array([x]).buffer);
const b2f = (x) => new Float64Array(x.buffer)[0];
// Get a byte representation of NaN
const n = f2b(NaN);
const m = f2b(NaN);
// Change the sign bit, which doesn't matter for NaN
n[7] += 2 ** 7;
// n[0] += 2**7; for big endian processors
const nan2 = b2f(n);
console.log(nan2); // NaN
console.log(Object.is(nan2, NaN)); // true
console.log(f2b(NaN)); // Uint8Array(8) [0, 0, 0, 0, 0, 0, 248, 127]
console.log(f2b(nan2)); // Uint8Array(8) [0, 0, 0, 0, 0, 0, 248, 255]
// Change the first bit, which is the least significant bit of the mantissa and doesn't matter for NaN
m[0] = 1;
// m[7] = 1; for big endian processors
const nan3 = b2f(m);
console.log(nan3); // NaN
console.log(Object.is(nan3, NaN)); // true
console.log(f2b(NaN)); // Uint8Array(8) [0, 0, 0, 0, 0, 0, 248, 127]
console.log(f2b(nan3)); // Uint8Array(8) [1, 0, 0, 0, 0, 0, 248, 127]
Silently escaping NaNNaN propagates through mathematical operations, so it's usually sufficient to test for NaN once at the end of calculation to detect error conditions. The only case where NaN gets silently escaped is when using exponentiation with an exponent of 0, which immediately returns 1 without testing the base's value.
jsNaN ** 0 === 1; // true
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-value-properties-of-the-global-object-nanBrowser compatibilitySee also
Number.NaN
Number.isNaN()
isNaN()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nTemporalLimited availabilityThis feature is not Baseline because it does not work in some of the most widely-used browsers.Learn moreSee full compatibilityReport feedbackExperimental: This is an experimental technologyCheck the Browser compatibility table carefully before using this in production.
The Temporal object enables date and time management in various scenarios, including built-in time zone and calendar representation, wall-clock time conversions, arithmetics, formatting, and more. It is designed as a full replacement for the Date object.DescriptionUnlike most global objects, Temporal is not a constructor. You cannot use it with the new operator or invoke the Temporal object as a function. All properties and methods of Temporal are static (just like the Math object).
Temporal has an intricate and powerful API. It exposes over 200 utility methods via several classes, so it could appear very complex. We will provide a high-level overview of how these APIs are related to each other.Background and conceptsJavaScript has had the Date object for handling date and time since its first days. However, the Date API is based on the poorly designed java.util.Date class from Java, which was replaced in the early 2010s; but, because of JavaScript's goal of backward compatibility, Date sticks around in the language.
The important lesson to preface the whole introduction is that date handling is complex. Most of the problems of Date are fixable by adding more methods, but a fundamental design flaw remains: it exposes so many methods on the same object that developers are often confused about what to use, leading to unexpected pitfalls. A well-designed API not only needs to do more, but also should do less with each level of abstraction, because preventing misuse is as important as enabling use cases.
Date objects wear two hats simultaneously:

As a timestamp: the number of milliseconds or nanoseconds elapsed since a fixed point in time (known as the epoch).
As a combination of components: year, month, day, hour, minute, second, millisecond, and nanosecond. The year, month, and day identifiers only make sense with reference to a calendar system. The whole combination maps to a unique instant in history when associated with a time zone. Date objects provide methods for reading and modifying these components.

Time zones underlie a significant number of date-related bugs. When interacting with a Date via the "combination of components" model, the time can only be in two time zones: UTC and local (device), and there's no way to specify an arbitrary time zone. Also lacking is the concept of "no time zone": this is known as a calendar date (for dates) or wall-clock time (for times), which is a time you "read off a calendar or clock". For example, if you are setting a daily wake up alarm, you will want to set it to "8:00AM" regardless of whether it is daylight saving time or not, whether you have traveled to a different time zone, etc.
A second feature lacking from Date is a calendar system. Most people may be familiar with the Gregorian calendar, where there are two eras, BC and AD; there are 12 months; each month has a different number of days; there's a leap year every 4 years; and so on. However, some of these concepts may not apply when you are working with another calendar system, such as the Hebrew calendar, the Chinese calendar, the Japanese calendar, etc. With Date, you can only work with the Gregorian calendar model.
There are many other undesirable legacies about Date, such as all setters being mutating (which often causes unwanted side effects), the date time string format being impossible to parse in a consistent way, etc. In the end, the best solution is to build a new API from scratch, which is what Temporal is.API overviewTemporal is a namespace, like Intl. It contains several classes and namespaces, each of which is designed to handle a specific aspect of date and time management. The classes can be grouped as such:

Representing a time duration (a difference between two time points): Temporal.Duration
Representing a time point:

Representing a unique instant in history:

As a timestamp: Temporal.Instant
As a date-time component combination paired with a time zone: Temporal.ZonedDateTime


Representing a time-zone-unaware date/time (which are all prefixed with "Plain"):

Date (year, month, day) + time (hour, minute, second, millisecond, microsecond, nanosecond): Temporal.PlainDateTime (Note: ZonedDateTime is equivalent to PlainDateTime plus a time zone)

Date (year, month, day): Temporal.PlainDate

Year, month: Temporal.PlainYearMonth
Month, day: Temporal.PlainMonthDay


Time (hour, minute, second, millisecond, microsecond, nanosecond): Temporal.PlainTime







Furthermore, there's also another utility namespace, Temporal.Now, which provides methods for getting the current time in various formats.Shared class interfaceThere are many classes in the Temporal namespace, but they share many similar methods. The following table lists all methods of each class (except conversion methods):




Instant
ZonedDateTime
PlainDateTime
PlainDate
PlainTime
PlainYearMonth
PlainMonthDay




Construction
Instant()Instant.from()Instant.fromEpochMilliseconds()Instant.fromEpochNanoseconds()
ZonedDateTime()ZonedDateTime.from()
PlainDateTime()PlainDateTime.from()
PlainDate()PlainDate.from()
PlainTime()PlainTime.from()
PlainYearMonth()PlainYearMonth.from()
PlainMonthDay()PlainMonthDay.from()


Updater
N/A
with()withCalendar()withTimeZone()withPlainTime()
with()withCalendar()withPlainTime()
with()withCalendar()
with()
with()
with()


Arithmetic
add()subtract()since()until()
add()subtract()since()until()
add()subtract()since()until()
add()subtract()since()until()
add()subtract()since()until()
add()subtract()since()until()
N/A


Rounding
round()
round()
round()
N/A
round()
N/A
N/A


Comparison
equals()Instant.compare()
equals()ZonedDateTime.compare()
equals()PlainDateTime.compare()
equals()PlainDate.compare()
equals()PlainTime.compare()
equals()PlainYearMonth.compare()
equals()


Serialization
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()



The following table summarizes which properties are available on each class, giving you a sense of what information each class can represent.




Instant
ZonedDateTime
PlainDateTime
PlainDate
PlainTime
PlainYearMonth
PlainMonthDay




Calendar
N/A
calendarId
calendarId
calendarId
N/A
calendarId
calendarId


Year-related
N/A
eraeraYearyearinLeapYearmonthsInYeardaysInYear
eraeraYearyearinLeapYearmonthsInYeardaysInYear
eraeraYearyearinLeapYearmonthsInYeardaysInYear
N/A
eraeraYearyearinLeapYearmonthsInYeardaysInYear
N/A


Month-related
N/A
monthmonthCodedaysInMonth
monthmonthCodedaysInMonth
monthmonthCodedaysInMonth
N/A
monthmonthCodedaysInMonth
monthCode


Week-related
N/A
weekOfYearyearOfWeekdaysInWeek
weekOfYearyearOfWeekdaysInWeek
weekOfYearyearOfWeekdaysInWeek
N/A
N/A
N/A


Day-related
N/A
daydayOfWeekdayOfYear
daydayOfWeekdayOfYear
daydayOfWeekdayOfYear
N/A
N/A
day


Time components
N/A
hourminutesecondmillisecondmicrosecondnanosecond
hourminutesecondmillisecondmicrosecondnanosecond
N/A
hourminutesecondmillisecondmicrosecondnanosecond
N/A
N/A


Time zone
N/A
timeZoneIdoffsetoffsetNanosecondshoursInDaygetTimeZoneTransition()startOfDay()
N/A
N/A
N/A
N/A
N/A


Epoch time
epochMillisecondsepochNanoseconds
epochMillisecondsepochNanoseconds
N/A
N/A
N/A
N/A
N/A


Conversion between classesThe table below summarizes all conversion methods that exist on each class.




How to convert from...


Instant
ZonedDateTime
PlainDateTime
PlainDate
PlainTime
PlainYearMonth
PlainMonthDay

to...Instant/toInstant()Convert to ZonedDateTime first
ZonedDateTimetoZonedDateTimeISO()/toZonedDateTime()toZonedDateTime()PlainDate#toZonedDateTime() (pass as argument)Convert to PlainDate first
PlainDateTimeConvert to ZonedDateTime firsttoPlainDateTime()/toPlainDateTime()PlainDate#toPlainDateTime() (pass as argument)
PlainDatetoPlainDate()toPlainDate()/No overlap in informationtoPlainDate()toPlainDate()
PlainTimetoPlainTime()toPlainTime()No overlap in information/No overlap in information
PlainYearMonthConvert to PlainDate firsttoPlainYearMonth()No overlap in information/Convert to PlainDate first
PlainMonthDaytoPlainMonthDay()Convert to PlainDate first/


With these tables, you should have a basic idea of how to navigate the Temporal API.CalendarsA calendar is a way to organize days, typically into periods of weeks, months, years, and eras. Most of the world uses the Gregorian calendar, but there are many other calendars in use, especially in religious and cultural contexts. By default, all calendar-aware Temporal objects use the ISO 8601 calendar system, which is based on the Gregorian calendar and defines additional week-numbering rules. Intl.supportedValuesOf() lists most of the calendars likely to be supported by browsers. Here we provide a brief overview of how calendar systems are formed to help you internalize what factors may vary between calendars.
There are three prominent periodic events on Earth: its rotation around the sun (365.242 days for one revolution), the moon's rotation around the Earth (29.53 days from new moon to new moon), and its rotation around its axis (24 hours from sunrise to sunrise). Every culture has the same measure of a "day", which is 24 hours. Occasional changes such as daylight saving time are not part of the calendar, but are part of the time zone's information.

Some calendars primarily define one year as 365.242 days on average, by defining years to have 365 days, and adding an extra day, the leap day, about every 4 years. Then, the year may be further divided into parts called months. These calendars are called solar calendars. The Gregorian calendar and the Solar Hijri calendar are solar calendars.
Some calendars primarily define one month as 29.5 days on average, by defining months to alternate between 29 and 30 days. Then, 12 months may be grouped into a year of 354 days. These calendars are called lunar calendars. The Islamic calendar is a lunar calendar. Because a lunar year is artificial and does not correlate with the season cycle, lunar calendars are generally rarer.
Some calendars also primarily define months based on lunar cycles, like lunar calendars. Then, to compensate for the 11-day discrepancy with the solar year, an extra month, the leap month, is added about every 3 years. These calendars are called lunisolar calendars. The Hebrew calendar and the Chinese calendar are lunisolar calendars.

In Temporal, every date under one calendar system is uniquely identified by three components: year, month, and day. While year is typically a positive integer, it may also be zero or negative, and increases monotonically with time. The year 1 (or 0, if it exists) is known as the calendar epoch, and is arbitrary for each calendar. month is a positive integer that increments by 1 every time, starting at 1 and ending at date.monthsInYear, then resetting back to 1 as the year advances. day is also a positive integer, but it may not start at 1 or increment by 1 every time, because political changes may cause days to be skipped or repeated. But in general, day monotonically increases and resets as the month advances.
In addition to year, a year can also be uniquely identified by the combination of era and eraYear, for calendars that use eras. For example, the Gregorian calendar uses the era "CE" (Common Era) and "BCE" (Before Common Era), and the year -1 is the same as { era: "bce", eraYear: 1 }. era is a lowercase string, and eraYear is an arbitrary integer that may be zero or negative, or even decrease with time (usually for the oldest era).

Note:
Always use era and eraYear as a pair; don't use one property without also using the other. In addition, to avoid conflicts, don't combine year and era/eraYear when designating a year. Pick one year representation and use it consistently.
Be careful of the following incorrect assumptions about years:

Don't assume that era and eraYear are always present; they may be undefined.
Don't assume that era is a user-friendly string; use toLocaleString() to format your date instead.
Don't assume that two year values from different calendars are comparable; use the compare() static method instead.
Don't assume that years have 365/366 days and 12 months; use daysInYear and monthsInYear instead.
Don't assume that leap years (inLeapYear is true) have one extra day; they may have an extra month.


In addition to month, a month in a year can also be uniquely identified by the monthCode. monthCode usually maps to the month's name, but month does not. For example, in the case of lunisolar calendars, two months with the same monthCode, where one belongs to a leap year and the other one does not, will have different month values if they come after the leap month, due to the insertion of an extra month.

Note:
To avoid conflicts, don't combine month and monthCode when designating a month. Pick one month representation and use it consistently. month is more useful if you need the order of months in a year (e.g., when looping through the months), while monthCode is more useful if you need the name of the month (e.g., when storing birthdays).
Be careful of the following incorrect assumptions about months:

Don't assume that monthCode and month always correspond.
Don't assume the number of days in a month; use daysInMonth instead.
Don't assume that monthCode is a user-friendly string; use toLocaleString() to format your date instead.
Generally, don't cache the name of months in an array or object. Even though monthCode usually maps to the month's name within one calendar, we recommend always computing the month's name using, for example, date.toLocaleString("en-US", { calendar: date.calendarId, month: "long" }).


In addition to day (which is a month-based index), a day in a year can also be uniquely identified by the dayOfYear. dayOfYear is a positive integer that increments by 1 every time, starting at 1 and ending at date.daysInYear.
The concept of a "week" is not connected with any astronomical event, but is a cultural construct. While the most common length is 7 days, weeks can also have 4, 5, 6, 8, or more days — or even lack a fixed number of days altogether. To get the specific number of days of the week of a date, use the date's daysInWeek. Temporal identifies weeks by the combination of weekOfYear and yearOfWeek. weekOfYear is a positive integer that increments by 1 every time, starting at 1, then resetting back to 1 as the year advances. yearOfWeek is generally the same as year, but may be different at the start or end of each year, because one week may cross two years, and yearOfWeek picks one of the two years based on the calendar's rules.

Note:
Always use weekOfYear and yearOfWeek as a pair; don't use weekOfYear and year.
Be careful of the following incorrect assumptions about weeks:

Don't assume that weekOfYear and yearOfWeek are always present; they may be undefined.
Don't assume that weeks are always 7 days long; use daysInWeek instead.
Note that the current Temporal API does not support year-week dates, so you can't construct dates using these properties or serialize dates to year-week representations. They are only informational properties.

RFC 9557 formatAll Temporal classes can be serialized and deserialized using the format specified in RFC 9557, which is based on ISO 8601 / RFC 3339. The format, in its full form, is as follows (spaces are only for readability and should not be present in the actual string):
YYYY-MM-DD T HH:mm:ss.sssssssss Z/±HH:mm [time_zone_id] [u-ca=calendar_id]

Different classes have different requirements for the presence of each component, so you will find a section titled "RFC 9557 format" in each class's documentation, which specifies the format recognized by that class.
This is very similar to the date time string format used by Date, which is also based on ISO 8601. The main addition is the ability to specify micro- and nanosecond components, and the ability to specify the time zone and calendar system.Representable datesAll Temporal objects that represent a specific calendar date impose a similar limit on the range of representable dates, which is ±108 days (inclusive) from the Unix epoch, or the range of instants from -271821-04-20T00:00:00 to +275760-09-13T00:00:00. This is the same range as valid dates. More specifically:

Temporal.Instant and Temporal.ZonedDateTime apply this limit directly on its epochNanoseconds value.
Temporal.PlainDateTime interprets the date-time in the UTC time zone and requires it to be ±(108 + 1) days (exclusive) from the Unix epoch, so its valid range is -271821-04-19T00:00:00 to +275760-09-14T00:00:00, exclusive. This allows any ZonedDateTime to be converted to a PlainDateTime regardless of its offset.
Temporal.PlainDate applies the same check as PlainDateTime to the noon (12:00:00) of that date, so its valid range is -271821-04-19 to +275760-09-13. This allows any PlainDateTime to be converted to a PlainDate regardless of its time, and vice versa.
Temporal.PlainYearMonth has the valid range of -271821-04 to +275760-09. This allows any PlainDate to be converted to a PlainYearMonth regardless of its date (except if a non-ISO month's first day falls in the ISO month -271821-03).

The Temporal objects will refuse to construct an instance representing a date/time beyond this limit. This includes:

Using the constructor or from() static method.
Using the with() method to update calendar fields.
Using add(), subtract(), round(), or any other method to derive new instances.
Static properties
Temporal.Duration 
Experimental


Represents a difference between two time points, which can be used in date/time arithmetic. It is fundamentally represented as a combination of years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, and nanoseconds values.

Temporal.Instant 
Experimental


Represents a unique point in time, with nanosecond precision. It is fundamentally represented as the number of nanoseconds since the Unix epoch (midnight at the beginning of January 1, 1970, UTC), without any time zone or calendar system.

Temporal.Now 
Experimental


Provides methods for getting the current time in various formats.

Temporal.PlainDate 
Experimental


Represents a calendar date (a date without a time or time zone); for example, an event on a calendar which happens during the whole day no matter which time zone it's happening in. It is fundamentally represented as an ISO 8601 calendar date, with year, month, and day fields, and an associated calendar system.

Temporal.PlainDateTime 
Experimental


Represents a date (calendar date) and time (wall-clock time) without a time zone. It is fundamentally represented as a combination of a date (with an associated calendar system) and a time.

Temporal.PlainMonthDay 
Experimental


Represents the month and day of a calendar date, without a year or time zone; for example, an event on a calendar that recurs every year and happens during the whole day. It is fundamentally represented as an ISO 8601 calendar date, with year, month, and day fields, and an associated calendar system. The year is used to disambiguate the month-day in non-ISO calendar systems.

Temporal.PlainTime 
Experimental


Represents a time without a date or time zone; for example, a recurring event that happens at the same time every day. It is fundamentally represented as a combination of hour, minute, second, millisecond, microsecond, and nanosecond values.

Temporal.PlainYearMonth 
Experimental


Represents the year and month of a calendar date, without a day or time zone; for example, an event on a calendar that happens during the whole month. It is fundamentally represented as an ISO 8601 calendar date, with year, month, and day fields, and an associated calendar system. The day is used to disambiguate the year-month in non-ISO calendar systems.

Temporal.ZonedDateTime 
Experimental


Represents a date and time with a time zone. It is fundamentally represented as a combination of an instant, a time zone, and a calendar system.

Temporal[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Temporal". This property is used in Object.prototype.toString().

SpecificationsSpecificationTemporal proposal # sec-temporal-introBrowser compatibilitySee also
Intl.DateTimeFormat
Intl.RelativeTimeFormat
Intl.DurationFormat\n\nTemporalLimited availabilityThis feature is not Baseline because it does not work in some of the most widely-used browsers.Learn moreSee full compatibilityReport feedbackExperimental: This is an experimental technologyCheck the Browser compatibility table carefully before using this in production.
The Temporal object enables date and time management in various scenarios, including built-in time zone and calendar representation, wall-clock time conversions, arithmetics, formatting, and more. It is designed as a full replacement for the Date object.DescriptionUnlike most global objects, Temporal is not a constructor. You cannot use it with the new operator or invoke the Temporal object as a function. All properties and methods of Temporal are static (just like the Math object).
Temporal has an intricate and powerful API. It exposes over 200 utility methods via several classes, so it could appear very complex. We will provide a high-level overview of how these APIs are related to each other.Background and conceptsJavaScript has had the Date object for handling date and time since its first days. However, the Date API is based on the poorly designed java.util.Date class from Java, which was replaced in the early 2010s; but, because of JavaScript's goal of backward compatibility, Date sticks around in the language.
The important lesson to preface the whole introduction is that date handling is complex. Most of the problems of Date are fixable by adding more methods, but a fundamental design flaw remains: it exposes so many methods on the same object that developers are often confused about what to use, leading to unexpected pitfalls. A well-designed API not only needs to do more, but also should do less with each level of abstraction, because preventing misuse is as important as enabling use cases.
Date objects wear two hats simultaneously:

As a timestamp: the number of milliseconds or nanoseconds elapsed since a fixed point in time (known as the epoch).
As a combination of components: year, month, day, hour, minute, second, millisecond, and nanosecond. The year, month, and day identifiers only make sense with reference to a calendar system. The whole combination maps to a unique instant in history when associated with a time zone. Date objects provide methods for reading and modifying these components.

Time zones underlie a significant number of date-related bugs. When interacting with a Date via the "combination of components" model, the time can only be in two time zones: UTC and local (device), and there's no way to specify an arbitrary time zone. Also lacking is the concept of "no time zone": this is known as a calendar date (for dates) or wall-clock time (for times), which is a time you "read off a calendar or clock". For example, if you are setting a daily wake up alarm, you will want to set it to "8:00AM" regardless of whether it is daylight saving time or not, whether you have traveled to a different time zone, etc.
A second feature lacking from Date is a calendar system. Most people may be familiar with the Gregorian calendar, where there are two eras, BC and AD; there are 12 months; each month has a different number of days; there's a leap year every 4 years; and so on. However, some of these concepts may not apply when you are working with another calendar system, such as the Hebrew calendar, the Chinese calendar, the Japanese calendar, etc. With Date, you can only work with the Gregorian calendar model.
There are many other undesirable legacies about Date, such as all setters being mutating (which often causes unwanted side effects), the date time string format being impossible to parse in a consistent way, etc. In the end, the best solution is to build a new API from scratch, which is what Temporal is.API overviewTemporal is a namespace, like Intl. It contains several classes and namespaces, each of which is designed to handle a specific aspect of date and time management. The classes can be grouped as such:

Representing a time duration (a difference between two time points): Temporal.Duration
Representing a time point:

Representing a unique instant in history:

As a timestamp: Temporal.Instant
As a date-time component combination paired with a time zone: Temporal.ZonedDateTime


Representing a time-zone-unaware date/time (which are all prefixed with "Plain"):

Date (year, month, day) + time (hour, minute, second, millisecond, microsecond, nanosecond): Temporal.PlainDateTime (Note: ZonedDateTime is equivalent to PlainDateTime plus a time zone)

Date (year, month, day): Temporal.PlainDate

Year, month: Temporal.PlainYearMonth
Month, day: Temporal.PlainMonthDay


Time (hour, minute, second, millisecond, microsecond, nanosecond): Temporal.PlainTime







Furthermore, there's also another utility namespace, Temporal.Now, which provides methods for getting the current time in various formats.Shared class interfaceThere are many classes in the Temporal namespace, but they share many similar methods. The following table lists all methods of each class (except conversion methods):




Instant
ZonedDateTime
PlainDateTime
PlainDate
PlainTime
PlainYearMonth
PlainMonthDay




Construction
Instant()Instant.from()Instant.fromEpochMilliseconds()Instant.fromEpochNanoseconds()
ZonedDateTime()ZonedDateTime.from()
PlainDateTime()PlainDateTime.from()
PlainDate()PlainDate.from()
PlainTime()PlainTime.from()
PlainYearMonth()PlainYearMonth.from()
PlainMonthDay()PlainMonthDay.from()


Updater
N/A
with()withCalendar()withTimeZone()withPlainTime()
with()withCalendar()withPlainTime()
with()withCalendar()
with()
with()
with()


Arithmetic
add()subtract()since()until()
add()subtract()since()until()
add()subtract()since()until()
add()subtract()since()until()
add()subtract()since()until()
add()subtract()since()until()
N/A


Rounding
round()
round()
round()
N/A
round()
N/A
N/A


Comparison
equals()Instant.compare()
equals()ZonedDateTime.compare()
equals()PlainDateTime.compare()
equals()PlainDate.compare()
equals()PlainTime.compare()
equals()PlainYearMonth.compare()
equals()


Serialization
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()



The following table summarizes which properties are available on each class, giving you a sense of what information each class can represent.




Instant
ZonedDateTime
PlainDateTime
PlainDate
PlainTime
PlainYearMonth
PlainMonthDay




Calendar
N/A
calendarId
calendarId
calendarId
N/A
calendarId
calendarId


Year-related
N/A
eraeraYearyearinLeapYearmonthsInYeardaysInYear
eraeraYearyearinLeapYearmonthsInYeardaysInYear
eraeraYearyearinLeapYearmonthsInYeardaysInYear
N/A
eraeraYearyearinLeapYearmonthsInYeardaysInYear
N/A


Month-related
N/A
monthmonthCodedaysInMonth
monthmonthCodedaysInMonth
monthmonthCodedaysInMonth
N/A
monthmonthCodedaysInMonth
monthCode


Week-related
N/A
weekOfYearyearOfWeekdaysInWeek
weekOfYearyearOfWeekdaysInWeek
weekOfYearyearOfWeekdaysInWeek
N/A
N/A
N/A


Day-related
N/A
daydayOfWeekdayOfYear
daydayOfWeekdayOfYear
daydayOfWeekdayOfYear
N/A
N/A
day


Time components
N/A
hourminutesecondmillisecondmicrosecondnanosecond
hourminutesecondmillisecondmicrosecondnanosecond
N/A
hourminutesecondmillisecondmicrosecondnanosecond
N/A
N/A


Time zone
N/A
timeZoneIdoffsetoffsetNanosecondshoursInDaygetTimeZoneTransition()startOfDay()
N/A
N/A
N/A
N/A
N/A


Epoch time
epochMillisecondsepochNanoseconds
epochMillisecondsepochNanoseconds
N/A
N/A
N/A
N/A
N/A


Conversion between classesThe table below summarizes all conversion methods that exist on each class.




How to convert from...


Instant
ZonedDateTime
PlainDateTime
PlainDate
PlainTime
PlainYearMonth
PlainMonthDay

to...Instant/toInstant()Convert to ZonedDateTime first
ZonedDateTimetoZonedDateTimeISO()/toZonedDateTime()toZonedDateTime()PlainDate#toZonedDateTime() (pass as argument)Convert to PlainDate first
PlainDateTimeConvert to ZonedDateTime firsttoPlainDateTime()/toPlainDateTime()PlainDate#toPlainDateTime() (pass as argument)
PlainDatetoPlainDate()toPlainDate()/No overlap in informationtoPlainDate()toPlainDate()
PlainTimetoPlainTime()toPlainTime()No overlap in information/No overlap in information
PlainYearMonthConvert to PlainDate firsttoPlainYearMonth()No overlap in information/Convert to PlainDate first
PlainMonthDaytoPlainMonthDay()Convert to PlainDate first/


With these tables, you should have a basic idea of how to navigate the Temporal API.CalendarsA calendar is a way to organize days, typically into periods of weeks, months, years, and eras. Most of the world uses the Gregorian calendar, but there are many other calendars in use, especially in religious and cultural contexts. By default, all calendar-aware Temporal objects use the ISO 8601 calendar system, which is based on the Gregorian calendar and defines additional week-numbering rules. Intl.supportedValuesOf() lists most of the calendars likely to be supported by browsers. Here we provide a brief overview of how calendar systems are formed to help you internalize what factors may vary between calendars.
There are three prominent periodic events on Earth: its rotation around the sun (365.242 days for one revolution), the moon's rotation around the Earth (29.53 days from new moon to new moon), and its rotation around its axis (24 hours from sunrise to sunrise). Every culture has the same measure of a "day", which is 24 hours. Occasional changes such as daylight saving time are not part of the calendar, but are part of the time zone's information.

Some calendars primarily define one year as 365.242 days on average, by defining years to have 365 days, and adding an extra day, the leap day, about every 4 years. Then, the year may be further divided into parts called months. These calendars are called solar calendars. The Gregorian calendar and the Solar Hijri calendar are solar calendars.
Some calendars primarily define one month as 29.5 days on average, by defining months to alternate between 29 and 30 days. Then, 12 months may be grouped into a year of 354 days. These calendars are called lunar calendars. The Islamic calendar is a lunar calendar. Because a lunar year is artificial and does not correlate with the season cycle, lunar calendars are generally rarer.
Some calendars also primarily define months based on lunar cycles, like lunar calendars. Then, to compensate for the 11-day discrepancy with the solar year, an extra month, the leap month, is added about every 3 years. These calendars are called lunisolar calendars. The Hebrew calendar and the Chinese calendar are lunisolar calendars.

In Temporal, every date under one calendar system is uniquely identified by three components: year, month, and day. While year is typically a positive integer, it may also be zero or negative, and increases monotonically with time. The year 1 (or 0, if it exists) is known as the calendar epoch, and is arbitrary for each calendar. month is a positive integer that increments by 1 every time, starting at 1 and ending at date.monthsInYear, then resetting back to 1 as the year advances. day is also a positive integer, but it may not start at 1 or increment by 1 every time, because political changes may cause days to be skipped or repeated. But in general, day monotonically increases and resets as the month advances.
In addition to year, a year can also be uniquely identified by the combination of era and eraYear, for calendars that use eras. For example, the Gregorian calendar uses the era "CE" (Common Era) and "BCE" (Before Common Era), and the year -1 is the same as { era: "bce", eraYear: 1 }. era is a lowercase string, and eraYear is an arbitrary integer that may be zero or negative, or even decrease with time (usually for the oldest era).

Note:
Always use era and eraYear as a pair; don't use one property without also using the other. In addition, to avoid conflicts, don't combine year and era/eraYear when designating a year. Pick one year representation and use it consistently.
Be careful of the following incorrect assumptions about years:

Don't assume that era and eraYear are always present; they may be undefined.
Don't assume that era is a user-friendly string; use toLocaleString() to format your date instead.
Don't assume that two year values from different calendars are comparable; use the compare() static method instead.
Don't assume that years have 365/366 days and 12 months; use daysInYear and monthsInYear instead.
Don't assume that leap years (inLeapYear is true) have one extra day; they may have an extra month.


In addition to month, a month in a year can also be uniquely identified by the monthCode. monthCode usually maps to the month's name, but month does not. For example, in the case of lunisolar calendars, two months with the same monthCode, where one belongs to a leap year and the other one does not, will have different month values if they come after the leap month, due to the insertion of an extra month.

Note:
To avoid conflicts, don't combine month and monthCode when designating a month. Pick one month representation and use it consistently. month is more useful if you need the order of months in a year (e.g., when looping through the months), while monthCode is more useful if you need the name of the month (e.g., when storing birthdays).
Be careful of the following incorrect assumptions about months:

Don't assume that monthCode and month always correspond.
Don't assume the number of days in a month; use daysInMonth instead.
Don't assume that monthCode is a user-friendly string; use toLocaleString() to format your date instead.
Generally, don't cache the name of months in an array or object. Even though monthCode usually maps to the month's name within one calendar, we recommend always computing the month's name using, for example, date.toLocaleString("en-US", { calendar: date.calendarId, month: "long" }).


In addition to day (which is a month-based index), a day in a year can also be uniquely identified by the dayOfYear. dayOfYear is a positive integer that increments by 1 every time, starting at 1 and ending at date.daysInYear.
The concept of a "week" is not connected with any astronomical event, but is a cultural construct. While the most common length is 7 days, weeks can also have 4, 5, 6, 8, or more days — or even lack a fixed number of days altogether. To get the specific number of days of the week of a date, use the date's daysInWeek. Temporal identifies weeks by the combination of weekOfYear and yearOfWeek. weekOfYear is a positive integer that increments by 1 every time, starting at 1, then resetting back to 1 as the year advances. yearOfWeek is generally the same as year, but may be different at the start or end of each year, because one week may cross two years, and yearOfWeek picks one of the two years based on the calendar's rules.

Note:
Always use weekOfYear and yearOfWeek as a pair; don't use weekOfYear and year.
Be careful of the following incorrect assumptions about weeks:

Don't assume that weekOfYear and yearOfWeek are always present; they may be undefined.
Don't assume that weeks are always 7 days long; use daysInWeek instead.
Note that the current Temporal API does not support year-week dates, so you can't construct dates using these properties or serialize dates to year-week representations. They are only informational properties.

RFC 9557 formatAll Temporal classes can be serialized and deserialized using the format specified in RFC 9557, which is based on ISO 8601 / RFC 3339. The format, in its full form, is as follows (spaces are only for readability and should not be present in the actual string):
YYYY-MM-DD T HH:mm:ss.sssssssss Z/±HH:mm [time_zone_id] [u-ca=calendar_id]

Different classes have different requirements for the presence of each component, so you will find a section titled "RFC 9557 format" in each class's documentation, which specifies the format recognized by that class.
This is very similar to the date time string format used by Date, which is also based on ISO 8601. The main addition is the ability to specify micro- and nanosecond components, and the ability to specify the time zone and calendar system.Representable datesAll Temporal objects that represent a specific calendar date impose a similar limit on the range of representable dates, which is ±108 days (inclusive) from the Unix epoch, or the range of instants from -271821-04-20T00:00:00 to +275760-09-13T00:00:00. This is the same range as valid dates. More specifically:

Temporal.Instant and Temporal.ZonedDateTime apply this limit directly on its epochNanoseconds value.
Temporal.PlainDateTime interprets the date-time in the UTC time zone and requires it to be ±(108 + 1) days (exclusive) from the Unix epoch, so its valid range is -271821-04-19T00:00:00 to +275760-09-14T00:00:00, exclusive. This allows any ZonedDateTime to be converted to a PlainDateTime regardless of its offset.
Temporal.PlainDate applies the same check as PlainDateTime to the noon (12:00:00) of that date, so its valid range is -271821-04-19 to +275760-09-13. This allows any PlainDateTime to be converted to a PlainDate regardless of its time, and vice versa.
Temporal.PlainYearMonth has the valid range of -271821-04 to +275760-09. This allows any PlainDate to be converted to a PlainYearMonth regardless of its date (except if a non-ISO month's first day falls in the ISO month -271821-03).

The Temporal objects will refuse to construct an instance representing a date/time beyond this limit. This includes:

Using the constructor or from() static method.
Using the with() method to update calendar fields.
Using add(), subtract(), round(), or any other method to derive new instances.
Static properties
Temporal.Duration 
Experimental


Represents a difference between two time points, which can be used in date/time arithmetic. It is fundamentally represented as a combination of years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, and nanoseconds values.

Temporal.Instant 
Experimental


Represents a unique point in time, with nanosecond precision. It is fundamentally represented as the number of nanoseconds since the Unix epoch (midnight at the beginning of January 1, 1970, UTC), without any time zone or calendar system.

Temporal.Now 
Experimental


Provides methods for getting the current time in various formats.

Temporal.PlainDate 
Experimental


Represents a calendar date (a date without a time or time zone); for example, an event on a calendar which happens during the whole day no matter which time zone it's happening in. It is fundamentally represented as an ISO 8601 calendar date, with year, month, and day fields, and an associated calendar system.

Temporal.PlainDateTime 
Experimental


Represents a date (calendar date) and time (wall-clock time) without a time zone. It is fundamentally represented as a combination of a date (with an associated calendar system) and a time.

Temporal.PlainMonthDay 
Experimental


Represents the month and day of a calendar date, without a year or time zone; for example, an event on a calendar that recurs every year and happens during the whole day. It is fundamentally represented as an ISO 8601 calendar date, with year, month, and day fields, and an associated calendar system. The year is used to disambiguate the month-day in non-ISO calendar systems.

Temporal.PlainTime 
Experimental


Represents a time without a date or time zone; for example, a recurring event that happens at the same time every day. It is fundamentally represented as a combination of hour, minute, second, millisecond, microsecond, and nanosecond values.

Temporal.PlainYearMonth 
Experimental


Represents the year and month of a calendar date, without a day or time zone; for example, an event on a calendar that happens during the whole month. It is fundamentally represented as an ISO 8601 calendar date, with year, month, and day fields, and an associated calendar system. The day is used to disambiguate the year-month in non-ISO calendar systems.

Temporal.ZonedDateTime 
Experimental


Represents a date and time with a time zone. It is fundamentally represented as a combination of an instant, a time zone, and a calendar system.

Temporal[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Temporal". This property is used in Object.prototype.toString().

SpecificationsSpecificationTemporal proposal # sec-temporal-introBrowser compatibilitySee also
Intl.DateTimeFormat
Intl.RelativeTimeFormat
Intl.DurationFormat
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nTemporalLimited availabilityThis feature is not Baseline because it does not work in some of the most widely-used browsers.Learn moreSee full compatibilityReport feedbackExperimental: This is an experimental technologyCheck the Browser compatibility table carefully before using this in production.
The Temporal object enables date and time management in various scenarios, including built-in time zone and calendar representation, wall-clock time conversions, arithmetics, formatting, and more. It is designed as a full replacement for the Date object.DescriptionUnlike most global objects, Temporal is not a constructor. You cannot use it with the new operator or invoke the Temporal object as a function. All properties and methods of Temporal are static (just like the Math object).
Temporal has an intricate and powerful API. It exposes over 200 utility methods via several classes, so it could appear very complex. We will provide a high-level overview of how these APIs are related to each other.Background and conceptsJavaScript has had the Date object for handling date and time since its first days. However, the Date API is based on the poorly designed java.util.Date class from Java, which was replaced in the early 2010s; but, because of JavaScript's goal of backward compatibility, Date sticks around in the language.
The important lesson to preface the whole introduction is that date handling is complex. Most of the problems of Date are fixable by adding more methods, but a fundamental design flaw remains: it exposes so many methods on the same object that developers are often confused about what to use, leading to unexpected pitfalls. A well-designed API not only needs to do more, but also should do less with each level of abstraction, because preventing misuse is as important as enabling use cases.
Date objects wear two hats simultaneously:

As a timestamp: the number of milliseconds or nanoseconds elapsed since a fixed point in time (known as the epoch).
As a combination of components: year, month, day, hour, minute, second, millisecond, and nanosecond. The year, month, and day identifiers only make sense with reference to a calendar system. The whole combination maps to a unique instant in history when associated with a time zone. Date objects provide methods for reading and modifying these components.

Time zones underlie a significant number of date-related bugs. When interacting with a Date via the "combination of components" model, the time can only be in two time zones: UTC and local (device), and there's no way to specify an arbitrary time zone. Also lacking is the concept of "no time zone": this is known as a calendar date (for dates) or wall-clock time (for times), which is a time you "read off a calendar or clock". For example, if you are setting a daily wake up alarm, you will want to set it to "8:00AM" regardless of whether it is daylight saving time or not, whether you have traveled to a different time zone, etc.
A second feature lacking from Date is a calendar system. Most people may be familiar with the Gregorian calendar, where there are two eras, BC and AD; there are 12 months; each month has a different number of days; there's a leap year every 4 years; and so on. However, some of these concepts may not apply when you are working with another calendar system, such as the Hebrew calendar, the Chinese calendar, the Japanese calendar, etc. With Date, you can only work with the Gregorian calendar model.
There are many other undesirable legacies about Date, such as all setters being mutating (which often causes unwanted side effects), the date time string format being impossible to parse in a consistent way, etc. In the end, the best solution is to build a new API from scratch, which is what Temporal is.API overviewTemporal is a namespace, like Intl. It contains several classes and namespaces, each of which is designed to handle a specific aspect of date and time management. The classes can be grouped as such:

Representing a time duration (a difference between two time points): Temporal.Duration
Representing a time point:

Representing a unique instant in history:

As a timestamp: Temporal.Instant
As a date-time component combination paired with a time zone: Temporal.ZonedDateTime


Representing a time-zone-unaware date/time (which are all prefixed with "Plain"):

Date (year, month, day) + time (hour, minute, second, millisecond, microsecond, nanosecond): Temporal.PlainDateTime (Note: ZonedDateTime is equivalent to PlainDateTime plus a time zone)

Date (year, month, day): Temporal.PlainDate

Year, month: Temporal.PlainYearMonth
Month, day: Temporal.PlainMonthDay


Time (hour, minute, second, millisecond, microsecond, nanosecond): Temporal.PlainTime







Furthermore, there's also another utility namespace, Temporal.Now, which provides methods for getting the current time in various formats.Shared class interfaceThere are many classes in the Temporal namespace, but they share many similar methods. The following table lists all methods of each class (except conversion methods):




Instant
ZonedDateTime
PlainDateTime
PlainDate
PlainTime
PlainYearMonth
PlainMonthDay




Construction
Instant()Instant.from()Instant.fromEpochMilliseconds()Instant.fromEpochNanoseconds()
ZonedDateTime()ZonedDateTime.from()
PlainDateTime()PlainDateTime.from()
PlainDate()PlainDate.from()
PlainTime()PlainTime.from()
PlainYearMonth()PlainYearMonth.from()
PlainMonthDay()PlainMonthDay.from()


Updater
N/A
with()withCalendar()withTimeZone()withPlainTime()
with()withCalendar()withPlainTime()
with()withCalendar()
with()
with()
with()


Arithmetic
add()subtract()since()until()
add()subtract()since()until()
add()subtract()since()until()
add()subtract()since()until()
add()subtract()since()until()
add()subtract()since()until()
N/A


Rounding
round()
round()
round()
N/A
round()
N/A
N/A


Comparison
equals()Instant.compare()
equals()ZonedDateTime.compare()
equals()PlainDateTime.compare()
equals()PlainDate.compare()
equals()PlainTime.compare()
equals()PlainYearMonth.compare()
equals()


Serialization
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()



The following table summarizes which properties are available on each class, giving you a sense of what information each class can represent.




Instant
ZonedDateTime
PlainDateTime
PlainDate
PlainTime
PlainYearMonth
PlainMonthDay




Calendar
N/A
calendarId
calendarId
calendarId
N/A
calendarId
calendarId


Year-related
N/A
eraeraYearyearinLeapYearmonthsInYeardaysInYear
eraeraYearyearinLeapYearmonthsInYeardaysInYear
eraeraYearyearinLeapYearmonthsInYeardaysInYear
N/A
eraeraYearyearinLeapYearmonthsInYeardaysInYear
N/A


Month-related
N/A
monthmonthCodedaysInMonth
monthmonthCodedaysInMonth
monthmonthCodedaysInMonth
N/A
monthmonthCodedaysInMonth
monthCode


Week-related
N/A
weekOfYearyearOfWeekdaysInWeek
weekOfYearyearOfWeekdaysInWeek
weekOfYearyearOfWeekdaysInWeek
N/A
N/A
N/A


Day-related
N/A
daydayOfWeekdayOfYear
daydayOfWeekdayOfYear
daydayOfWeekdayOfYear
N/A
N/A
day


Time components
N/A
hourminutesecondmillisecondmicrosecondnanosecond
hourminutesecondmillisecondmicrosecondnanosecond
N/A
hourminutesecondmillisecondmicrosecondnanosecond
N/A
N/A


Time zone
N/A
timeZoneIdoffsetoffsetNanosecondshoursInDaygetTimeZoneTransition()startOfDay()
N/A
N/A
N/A
N/A
N/A


Epoch time
epochMillisecondsepochNanoseconds
epochMillisecondsepochNanoseconds
N/A
N/A
N/A
N/A
N/A


Conversion between classesThe table below summarizes all conversion methods that exist on each class.




How to convert from...


Instant
ZonedDateTime
PlainDateTime
PlainDate
PlainTime
PlainYearMonth
PlainMonthDay

to...Instant/toInstant()Convert to ZonedDateTime first
ZonedDateTimetoZonedDateTimeISO()/toZonedDateTime()toZonedDateTime()PlainDate#toZonedDateTime() (pass as argument)Convert to PlainDate first
PlainDateTimeConvert to ZonedDateTime firsttoPlainDateTime()/toPlainDateTime()PlainDate#toPlainDateTime() (pass as argument)
PlainDatetoPlainDate()toPlainDate()/No overlap in informationtoPlainDate()toPlainDate()
PlainTimetoPlainTime()toPlainTime()No overlap in information/No overlap in information
PlainYearMonthConvert to PlainDate firsttoPlainYearMonth()No overlap in information/Convert to PlainDate first
PlainMonthDaytoPlainMonthDay()Convert to PlainDate first/


With these tables, you should have a basic idea of how to navigate the Temporal API.CalendarsA calendar is a way to organize days, typically into periods of weeks, months, years, and eras. Most of the world uses the Gregorian calendar, but there are many other calendars in use, especially in religious and cultural contexts. By default, all calendar-aware Temporal objects use the ISO 8601 calendar system, which is based on the Gregorian calendar and defines additional week-numbering rules. Intl.supportedValuesOf() lists most of the calendars likely to be supported by browsers. Here we provide a brief overview of how calendar systems are formed to help you internalize what factors may vary between calendars.
There are three prominent periodic events on Earth: its rotation around the sun (365.242 days for one revolution), the moon's rotation around the Earth (29.53 days from new moon to new moon), and its rotation around its axis (24 hours from sunrise to sunrise). Every culture has the same measure of a "day", which is 24 hours. Occasional changes such as daylight saving time are not part of the calendar, but are part of the time zone's information.

Some calendars primarily define one year as 365.242 days on average, by defining years to have 365 days, and adding an extra day, the leap day, about every 4 years. Then, the year may be further divided into parts called months. These calendars are called solar calendars. The Gregorian calendar and the Solar Hijri calendar are solar calendars.
Some calendars primarily define one month as 29.5 days on average, by defining months to alternate between 29 and 30 days. Then, 12 months may be grouped into a year of 354 days. These calendars are called lunar calendars. The Islamic calendar is a lunar calendar. Because a lunar year is artificial and does not correlate with the season cycle, lunar calendars are generally rarer.
Some calendars also primarily define months based on lunar cycles, like lunar calendars. Then, to compensate for the 11-day discrepancy with the solar year, an extra month, the leap month, is added about every 3 years. These calendars are called lunisolar calendars. The Hebrew calendar and the Chinese calendar are lunisolar calendars.

In Temporal, every date under one calendar system is uniquely identified by three components: year, month, and day. While year is typically a positive integer, it may also be zero or negative, and increases monotonically with time. The year 1 (or 0, if it exists) is known as the calendar epoch, and is arbitrary for each calendar. month is a positive integer that increments by 1 every time, starting at 1 and ending at date.monthsInYear, then resetting back to 1 as the year advances. day is also a positive integer, but it may not start at 1 or increment by 1 every time, because political changes may cause days to be skipped or repeated. But in general, day monotonically increases and resets as the month advances.
In addition to year, a year can also be uniquely identified by the combination of era and eraYear, for calendars that use eras. For example, the Gregorian calendar uses the era "CE" (Common Era) and "BCE" (Before Common Era), and the year -1 is the same as { era: "bce", eraYear: 1 }. era is a lowercase string, and eraYear is an arbitrary integer that may be zero or negative, or even decrease with time (usually for the oldest era).

Note:
Always use era and eraYear as a pair; don't use one property without also using the other. In addition, to avoid conflicts, don't combine year and era/eraYear when designating a year. Pick one year representation and use it consistently.
Be careful of the following incorrect assumptions about years:

Don't assume that era and eraYear are always present; they may be undefined.
Don't assume that era is a user-friendly string; use toLocaleString() to format your date instead.
Don't assume that two year values from different calendars are comparable; use the compare() static method instead.
Don't assume that years have 365/366 days and 12 months; use daysInYear and monthsInYear instead.
Don't assume that leap years (inLeapYear is true) have one extra day; they may have an extra month.


In addition to month, a month in a year can also be uniquely identified by the monthCode. monthCode usually maps to the month's name, but month does not. For example, in the case of lunisolar calendars, two months with the same monthCode, where one belongs to a leap year and the other one does not, will have different month values if they come after the leap month, due to the insertion of an extra month.

Note:
To avoid conflicts, don't combine month and monthCode when designating a month. Pick one month representation and use it consistently. month is more useful if you need the order of months in a year (e.g., when looping through the months), while monthCode is more useful if you need the name of the month (e.g., when storing birthdays).
Be careful of the following incorrect assumptions about months:

Don't assume that monthCode and month always correspond.
Don't assume the number of days in a month; use daysInMonth instead.
Don't assume that monthCode is a user-friendly string; use toLocaleString() to format your date instead.
Generally, don't cache the name of months in an array or object. Even though monthCode usually maps to the month's name within one calendar, we recommend always computing the month's name using, for example, date.toLocaleString("en-US", { calendar: date.calendarId, month: "long" }).


In addition to day (which is a month-based index), a day in a year can also be uniquely identified by the dayOfYear. dayOfYear is a positive integer that increments by 1 every time, starting at 1 and ending at date.daysInYear.
The concept of a "week" is not connected with any astronomical event, but is a cultural construct. While the most common length is 7 days, weeks can also have 4, 5, 6, 8, or more days — or even lack a fixed number of days altogether. To get the specific number of days of the week of a date, use the date's daysInWeek. Temporal identifies weeks by the combination of weekOfYear and yearOfWeek. weekOfYear is a positive integer that increments by 1 every time, starting at 1, then resetting back to 1 as the year advances. yearOfWeek is generally the same as year, but may be different at the start or end of each year, because one week may cross two years, and yearOfWeek picks one of the two years based on the calendar's rules.

Note:
Always use weekOfYear and yearOfWeek as a pair; don't use weekOfYear and year.
Be careful of the following incorrect assumptions about weeks:

Don't assume that weekOfYear and yearOfWeek are always present; they may be undefined.
Don't assume that weeks are always 7 days long; use daysInWeek instead.
Note that the current Temporal API does not support year-week dates, so you can't construct dates using these properties or serialize dates to year-week representations. They are only informational properties.

RFC 9557 formatAll Temporal classes can be serialized and deserialized using the format specified in RFC 9557, which is based on ISO 8601 / RFC 3339. The format, in its full form, is as follows (spaces are only for readability and should not be present in the actual string):
YYYY-MM-DD T HH:mm:ss.sssssssss Z/±HH:mm [time_zone_id] [u-ca=calendar_id]

Different classes have different requirements for the presence of each component, so you will find a section titled "RFC 9557 format" in each class's documentation, which specifies the format recognized by that class.
This is very similar to the date time string format used by Date, which is also based on ISO 8601. The main addition is the ability to specify micro- and nanosecond components, and the ability to specify the time zone and calendar system.Representable datesAll Temporal objects that represent a specific calendar date impose a similar limit on the range of representable dates, which is ±108 days (inclusive) from the Unix epoch, or the range of instants from -271821-04-20T00:00:00 to +275760-09-13T00:00:00. This is the same range as valid dates. More specifically:

Temporal.Instant and Temporal.ZonedDateTime apply this limit directly on its epochNanoseconds value.
Temporal.PlainDateTime interprets the date-time in the UTC time zone and requires it to be ±(108 + 1) days (exclusive) from the Unix epoch, so its valid range is -271821-04-19T00:00:00 to +275760-09-14T00:00:00, exclusive. This allows any ZonedDateTime to be converted to a PlainDateTime regardless of its offset.
Temporal.PlainDate applies the same check as PlainDateTime to the noon (12:00:00) of that date, so its valid range is -271821-04-19 to +275760-09-13. This allows any PlainDateTime to be converted to a PlainDate regardless of its time, and vice versa.
Temporal.PlainYearMonth has the valid range of -271821-04 to +275760-09. This allows any PlainDate to be converted to a PlainYearMonth regardless of its date (except if a non-ISO month's first day falls in the ISO month -271821-03).

The Temporal objects will refuse to construct an instance representing a date/time beyond this limit. This includes:

Using the constructor or from() static method.
Using the with() method to update calendar fields.
Using add(), subtract(), round(), or any other method to derive new instances.
Static properties
Temporal.Duration 
Experimental


Represents a difference between two time points, which can be used in date/time arithmetic. It is fundamentally represented as a combination of years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, and nanoseconds values.

Temporal.Instant 
Experimental


Represents a unique point in time, with nanosecond precision. It is fundamentally represented as the number of nanoseconds since the Unix epoch (midnight at the beginning of January 1, 1970, UTC), without any time zone or calendar system.

Temporal.Now 
Experimental


Provides methods for getting the current time in various formats.

Temporal.PlainDate 
Experimental


Represents a calendar date (a date without a time or time zone); for example, an event on a calendar which happens during the whole day no matter which time zone it's happening in. It is fundamentally represented as an ISO 8601 calendar date, with year, month, and day fields, and an associated calendar system.

Temporal.PlainDateTime 
Experimental


Represents a date (calendar date) and time (wall-clock time) without a time zone. It is fundamentally represented as a combination of a date (with an associated calendar system) and a time.

Temporal.PlainMonthDay 
Experimental


Represents the month and day of a calendar date, without a year or time zone; for example, an event on a calendar that recurs every year and happens during the whole day. It is fundamentally represented as an ISO 8601 calendar date, with year, month, and day fields, and an associated calendar system. The year is used to disambiguate the month-day in non-ISO calendar systems.

Temporal.PlainTime 
Experimental


Represents a time without a date or time zone; for example, a recurring event that happens at the same time every day. It is fundamentally represented as a combination of hour, minute, second, millisecond, microsecond, and nanosecond values.

Temporal.PlainYearMonth 
Experimental


Represents the year and month of a calendar date, without a day or time zone; for example, an event on a calendar that happens during the whole month. It is fundamentally represented as an ISO 8601 calendar date, with year, month, and day fields, and an associated calendar system. The day is used to disambiguate the year-month in non-ISO calendar systems.

Temporal.ZonedDateTime 
Experimental


Represents a date and time with a time zone. It is fundamentally represented as a combination of an instant, a time zone, and a calendar system.

Temporal[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Temporal". This property is used in Object.prototype.toString().

SpecificationsSpecificationTemporal proposal # sec-temporal-introBrowser compatibilitySee also
Intl.DateTimeFormat
Intl.RelativeTimeFormat
Intl.DurationFormat
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nDateBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackJavaScript Date objects represent a single moment in time in a platform-independent format. Date objects encapsulate an integral number that represents milliseconds since the midnight at the beginning of January 1, 1970, UTC (the epoch).

Note:
With the introduction of the Temporal API, the Date object is considered a legacy feature. Consider using Temporal for new code and migrate existing code over to it if possible (check the browser compatibility. We will be writing a usage guide soon!
DescriptionThe epoch, timestamps, and invalid dateA JavaScript date is fundamentally specified as the time in milliseconds that has elapsed since the epoch, which is defined as the midnight at the beginning of January 1, 1970, UTC (equivalent to the UNIX epoch). This timestamp is timezone-agnostic and uniquely defines an instant in history.

Note:
While the time value at the heart of a Date object is UTC, the basic methods to fetch the date and time or its components all work in the local (i.e., host system) time zone and offset.

The maximum timestamp representable by a Date object is slightly smaller than the maximum safe integer (Number.MAX_SAFE_INTEGER, which is 9,007,199,254,740,991). A Date object can represent a maximum of ±8,640,000,000,000,000 milliseconds, or ±100,000,000 (one hundred million) days, relative to the epoch. This is the range from April 20, 271821 BC to September 13, 275760 AD. Any attempt to represent a time outside this range results in the Date object holding a timestamp value of NaN, which is an "Invalid Date".
jsconsole.log(new Date(8.64e15).toString()); // "Sat Sep 13 275760 00:00:00 GMT+0000 (Coordinated Universal Time)"
console.log(new Date(8.64e15 + 1).toString()); // "Invalid Date"

There are various methods that allow you to interact with the timestamp stored in the date:

You can interact with the timestamp value directly using the getTime() and setTime() methods.
The valueOf() and [Symbol.toPrimitive]() (when passed "number") methods — which are automatically called in number coercion — return the timestamp, causing Date objects to behave like their timestamps when used in number contexts.
All static methods (Date.now(), Date.parse(), and Date.UTC()) return timestamps instead of Date objects.
The Date() constructor can be called with a timestamp as the only argument.
Date components and time zonesA date is represented internally as a single number, the timestamp. When interacting with it, the timestamp needs to be interpreted as a structured date-and-time representation. There are always two ways to interpret a timestamp: as a local time or as a Coordinated Universal Time (UTC), the global standard time defined by the World Time Standard. The local timezone is not stored in the date object, but is determined by the host environment (user's device).

Note:
UTC should not be confused with the Greenwich Mean Time (GMT), because they are not always equal — this is explained in more detail in the linked Wikipedia page.

For example, the timestamp 0 represents a unique instant in history, but it can be interpreted in two ways:

As a UTC time, it is midnight at the beginning of January 1, 1970, UTC,
As a local time in New York (UTC-5), it is 19:00:00 on December 31, 1969.

The getTimezoneOffset() method returns the difference between UTC and the local time in minutes. Note that the timezone offset does not only depend on the current timezone, but also on the time represented by the Date object, because of daylight saving time and historical changes. In essence, the timezone offset is the offset from UTC time, at the time represented by the Date object and at the location of the host environment.
There are two groups of Date methods: one group gets and sets various date components by interpreting the timestamp as a local time, while the other uses UTC.

  
    
      Component
      Local
      UTC
    
    
      Get
      Set
      Get
      Set
    
  
  
    
      Year
      getFullYear()
      setFullYear()
      getUTCFullYear()
      setUTCFullYear()
    
    
      Month
      getMonth()
      setMonth()
      getUTCMonth()
      setUTCMonth()
    
    
      Date (of month)
      getDate()
      setDate()
      getUTCDate()
      setUTCDate()
    
    
      Hours
      getHours()
      setHours()
      getUTCHours()
      setUTCHours()
    
    
      Minutes
      getMinutes()
      setMinutes()
      getUTCMinutes()
      setUTCMinutes()
    
    
      Seconds
      getSeconds()
      setSeconds()
      getUTCSeconds()
      setUTCSeconds()
    
    
      Milliseconds
      getMilliseconds()
      setMilliseconds()
      getUTCMilliseconds()
      setUTCMilliseconds()
    
    
      Day (of week)
      getDay()
      N/A
      getUTCDay()
      N/A
    
  

The Date() constructor can be called with two or more arguments, in which case they are interpreted as the year, month, day, hour, minute, second, and millisecond, respectively, in local time. Date.UTC() works similarly, but it interprets the components as UTC time and also accepts a single argument representing the year.

Note:
Some methods, including the Date() constructor, Date.UTC(), and the deprecated getYear()/setYear() methods, interpret a two-digit year as a year in the 1900s. For example, new Date(99, 5, 24) is interpreted as June 24, 1999, not June 24, 99. See Interpretation of two-digit years for more information.

When a segment overflows or underflows its expected range, it usually "carries over to" or "borrows from" the higher segment. For example, if the month is set to 12 (months are zero-based, so December is 11), it become the January of the next year. If the day of month is set to 0, it becomes the last day of the previous month. This also applies to dates specified with the date time string format.Date time string formatThere are many ways to format a date as a string. The JavaScript specification only specifies one format to be universally supported: the date time string format, a simplification of the ISO 8601 calendar date extended format. The format is as follows:
YYYY-MM-DDTHH:mm:ss.sssZ


YYYY is the year, with four digits (0000 to 9999), or as an expanded year of + or - followed by six digits. The sign is required for expanded years. -000000 is explicitly disallowed as a valid year.
MM is the month, with two digits (01 to 12). Defaults to 01.
DD is the day of the month, with two digits (01 to 31). Defaults to 01.
T is a literal character, which indicates the beginning of the time part of the string. The T is required when specifying the time part.
HH is the hour, with two digits (00 to 23). As a special case, 24:00:00 is allowed, and is interpreted as midnight at the beginning of the next day. Defaults to 00.
mm is the minute, with two digits (00 to 59). Defaults to 00.
ss is the second, with two digits (00 to 59). Defaults to 00.
sss is the millisecond, with three digits (000 to 999). Defaults to 000.
Z is the timezone offset, which can either be the literal character Z (indicating UTC), or + or - followed by HH:mm, the offset in hours and minutes from UTC.

Various components can be omitted, so the following are all valid:

Date-only form: YYYY, YYYY-MM, YYYY-MM-DD
Date-time form: one of the above date-only forms, followed by T, followed by HH:mm, HH:mm:ss, or HH:mm:ss.sss. Each combination can be followed by a time zone offset.

For example, "2011-10-10" (date-only form), "2011-10-10T14:48:00" (date-time form), or "2011-10-10T14:48:00.000+09:00" (date-time form with milliseconds and time zone) are all valid date time strings.
When the time zone offset is absent, date-only forms are interpreted as a UTC time and date-time forms are interpreted as a local time. The interpretation as a UTC time is due to a historical spec error that was not consistent with ISO 8601 but could not be changed due to web compatibility. See Broken Parser – A Web Reality Issue.
Date.parse() and the Date() constructor both accept strings in the date time string format as input. Furthermore, implementations are allowed to support other date formats when the input fails to match this format.
The toISOString() method returns a string representation of the date in the date time string format, with the time zone offset always set to Z (UTC).

Note:
You are encouraged to make sure your input conforms to the date time string format above for maximum compatibility, because support for other formats is not guaranteed. However, there are some formats that are supported in all major implementations — like RFC 2822 format — in which case their usage can be acceptable. Always conduct cross-browser tests to ensure your code works in all target browsers. A library can help if many different formats are to be accommodated.

Non-standard strings can be parsed in any way as desired by the implementation, including the time zone — most implementations use the local time zone by default. Implementations are not required to return invalid date for out-of-bounds date components, although they usually do. A string may have in-bounds date components (with the bounds defined above), but does not represent a date in reality (for example, "February 30"). Implementations behave inconsistently in this case. The Date.parse() page offers more examples about these non-standard cases.Other ways to format a date
toISOString() returns a string in the format 1970-01-01T00:00:00.000Z (the date time string format introduced above, which is simplified ISO 8601). toJSON() calls toISOString() and returns the result.
toString() returns a string in the format Thu Jan 01 1970 00:00:00 GMT+0000 (Coordinated Universal Time), while toDateString() and toTimeString() return the date and time parts of the string, respectively. [Symbol.toPrimitive]() (when passed "string" or "default") calls toString() and returns the result.
toUTCString() returns a string in the format Thu, 01 Jan 1970 00:00:00 GMT (generalized RFC 7231).
toLocaleDateString(), toLocaleTimeString(), and toLocaleString() use locale-specific date and time formats, usually provided by the Intl API.

See the Formats of toString method return values section for examples.Constructor
Date()

When called as a constructor, returns a new Date object. When called as a function, returns a string representation of the current date and time.

Static methods
Date.now()

Returns the numeric value corresponding to the current time—the number of milliseconds since January 1, 1970 00:00:00 UTC, with leap seconds ignored.

Date.parse()

Parses a string representation of a date and returns the number of milliseconds since January 1, 1970 00:00:00 UTC, with leap seconds ignored.

Date.UTC()

Accepts the same parameters as the longest form of the constructor (i.e., 2 to 7) and returns the number of milliseconds since January 1, 1970 00:00:00 UTC, with leap seconds ignored.

Instance propertiesThese properties are defined on Date.prototype and shared by all Date instances.

Date.prototype.constructor

The constructor function that created the instance object. For Date instances, the initial value is the Date constructor.

Instance methods
Date.prototype.getDate()

Returns the day of the month (1 – 31) for the specified date according to local time.

Date.prototype.getDay()

Returns the day of the week (0 – 6) for the specified date according to local time.

Date.prototype.getFullYear()

Returns the year (4 digits for 4-digit years) of the specified date according to local time.

Date.prototype.getHours()

Returns the hour (0 – 23) in the specified date according to local time.

Date.prototype.getMilliseconds()

Returns the milliseconds (0 – 999) in the specified date according to local time.

Date.prototype.getMinutes()

Returns the minutes (0 – 59) in the specified date according to local time.

Date.prototype.getMonth()

Returns the month (0 – 11) in the specified date according to local time.

Date.prototype.getSeconds()

Returns the seconds (0 – 59) in the specified date according to local time.

Date.prototype.getTime()

Returns the numeric value of the specified date as the number of milliseconds since January 1, 1970 00:00:00 UTC. (Negative values are returned for prior times.)

Date.prototype.getTimezoneOffset()

Returns the time-zone offset in minutes for the current locale.

Date.prototype.getUTCDate()

Returns the day (date) of the month (1 – 31) in the specified date according to universal time.

Date.prototype.getUTCDay()

Returns the day of the week (0 – 6) in the specified date according to universal time.

Date.prototype.getUTCFullYear()

Returns the year (4 digits for 4-digit years) in the specified date according to universal time.

Date.prototype.getUTCHours()

Returns the hours (0 – 23) in the specified date according to universal time.

Date.prototype.getUTCMilliseconds()

Returns the milliseconds (0 – 999) in the specified date according to universal time.

Date.prototype.getUTCMinutes()

Returns the minutes (0 – 59) in the specified date according to universal time.

Date.prototype.getUTCMonth()

Returns the month (0 – 11) in the specified date according to universal time.

Date.prototype.getUTCSeconds()

Returns the seconds (0 – 59) in the specified date according to universal time.

Date.prototype.getYear() 
Deprecated


Returns the year (usually 2–3 digits) in the specified date according to local time. Use getFullYear() instead.

Date.prototype.setDate()

Sets the day of the month for a specified date according to local time.

Date.prototype.setFullYear()

Sets the full year (e.g., 4 digits for 4-digit years) for a specified date according to local time.

Date.prototype.setHours()

Sets the hours for a specified date according to local time.

Date.prototype.setMilliseconds()

Sets the milliseconds for a specified date according to local time.

Date.prototype.setMinutes()

Sets the minutes for a specified date according to local time.

Date.prototype.setMonth()

Sets the month for a specified date according to local time.

Date.prototype.setSeconds()

Sets the seconds for a specified date according to local time.

Date.prototype.setTime()

Sets the Date object to the time represented by the number of milliseconds since January 1, 1970 00:00:00 UTC. Use negative numbers for times prior.

Date.prototype.setUTCDate()

Sets the day of the month for a specified date according to universal time.

Date.prototype.setUTCFullYear()

Sets the full year (e.g., 4 digits for 4-digit years) for a specified date according to universal time.

Date.prototype.setUTCHours()

Sets the hour for a specified date according to universal time.

Date.prototype.setUTCMilliseconds()

Sets the milliseconds for a specified date according to universal time.

Date.prototype.setUTCMinutes()

Sets the minutes for a specified date according to universal time.

Date.prototype.setUTCMonth()

Sets the month for a specified date according to universal time.

Date.prototype.setUTCSeconds()

Sets the seconds for a specified date according to universal time.

Date.prototype.setYear() 
Deprecated


Sets the year (usually 2–3 digits) for a specified date according to local time. Use setFullYear() instead.

Date.prototype.toDateString()

Returns the "date" portion of the Date as a human-readable string like 'Thu Apr 12 2018'.

Date.prototype.toISOString()

Converts a date to a string following the ISO 8601 Extended Format.

Date.prototype.toJSON()

Returns a string representing the Date using toISOString(). Intended to be implicitly called by JSON.stringify().

Date.prototype.toLocaleDateString()

Returns a string with a locality sensitive representation of the date portion of this date based on system settings.

Date.prototype.toLocaleString()

Returns a string with a locality-sensitive representation of this date. Overrides the Object.prototype.toLocaleString() method.

Date.prototype.toLocaleTimeString()

Returns a string with a locality-sensitive representation of the time portion of this date, based on system settings.

Date.prototype.toString()

Returns a string representing the specified Date object. Overrides the Object.prototype.toString() method.

Date.prototype.toTemporalInstant() 
Experimental


Returns a new Temporal.Instant object with the same epochMilliseconds value as this date's timestamp.

Date.prototype.toTimeString()

Returns the "time" portion of the Date as a human-readable string.

Date.prototype.toUTCString()

Converts a date to a string using the UTC timezone.

Date.prototype.valueOf()

Returns the primitive value of a Date object. Overrides the Object.prototype.valueOf() method.

Date.prototype[Symbol.toPrimitive]()

Converts this Date object to a primitive value.

ExamplesSeveral ways to create a Date objectThe following examples show several ways to create JavaScript dates:

Note:
Creating a date from a string has a lot of behavior inconsistencies. See date time string format for caveats on using different formats.

jsconst today = new Date();
const birthday = new Date("December 17, 1995 03:24:00"); // DISCOURAGED: may not work in all runtimes
const birthday2 = new Date("1995-12-17T03:24:00"); // This is standardized and will work reliably
const birthday3 = new Date(1995, 11, 17); // the month is 0-indexed
const birthday4 = new Date(1995, 11, 17, 3, 24, 0);
const birthday5 = new Date(628021800000); // passing epoch timestamp
Formats of toString method return valuesjsconst date = new Date("2020-05-12T23:50:21.817Z");
date.toString(); // Tue May 12 2020 18:50:21 GMT-0500 (Central Daylight Time)
date.toDateString(); // Tue May 12 2020
date.toTimeString(); // 18:50:21 GMT-0500 (Central Daylight Time)
date[Symbol.toPrimitive]("string"); // Tue May 12 2020 18:50:21 GMT-0500 (Central Daylight Time)

date.toISOString(); // 2020-05-12T23:50:21.817Z
date.toJSON(); // 2020-05-12T23:50:21.817Z

date.toUTCString(); // Tue, 12 May 2020 23:50:21 GMT

date.toLocaleString(); // 5/12/2020, 6:50:21 PM
date.toLocaleDateString(); // 5/12/2020
date.toLocaleTimeString(); // 6:50:21 PM
To get Date, Month and Year or Timejsconst date = new Date("2000-01-17T16:45:30");
const [month, day, year] = [
  date.getMonth(),
  date.getDate(),
  date.getFullYear(),
];
// [0, 17, 2000] as month are 0-indexed
const [hour, minutes, seconds] = [
  date.getHours(),
  date.getMinutes(),
  date.getSeconds(),
];
// [16, 45, 30]
Interpretation of two-digit yearsnew Date() exhibits legacy undesirable, inconsistent behavior with two-digit year values; specifically, when a new Date() call is given a two-digit year value, that year value does not get treated as a literal year and used as-is but instead gets interpreted as a relative offset — in some cases as an offset from the year 1900, but in other cases, as an offset from the year 2000.
jslet date = new Date(98, 1); // Sun Feb 01 1998 00:00:00 GMT+0000 (GMT)
date = new Date(22, 1); // Wed Feb 01 1922 00:00:00 GMT+0000 (GMT)
date = new Date("2/1/22"); // Tue Feb 01 2022 00:00:00 GMT+0000 (GMT)

// Legacy method; always interprets two-digit year values as relative to 1900
date.setYear(98);
date.toString(); // Sun Feb 01 1998 00:00:00 GMT+0000 (GMT)
date.setYear(22);
date.toString(); // Wed Feb 01 1922 00:00:00 GMT+0000 (GMT)

So, to create and get dates between the years 0 and 99, instead use the preferred setFullYear() and getFullYear() methods:.
js// Preferred method; never interprets any value as being a relative offset,
// but instead uses the year value as-is
date.setFullYear(98);
date.getFullYear(); // 98 (not 1998)
date.setFullYear(22);
date.getFullYear(); // 22 (not 1922, not 2022)
Calculating elapsed timeThe following examples show how to determine the elapsed time between two JavaScript dates in milliseconds.
Due to the differing lengths of days (due to daylight saving changeover), months, and years, expressing elapsed time in units greater than hours, minutes, and seconds requires addressing a number of issues, and should be thoroughly researched before being attempted.
js// Using Date objects
const start = Date.now();

// The event to time goes here:
doSomethingForALongTime();
const end = Date.now();
const elapsed = end - start; // elapsed time in milliseconds

js// Using built-in methods
const start = new Date();

// The event to time goes here:
doSomethingForALongTime();
const end = new Date();
const elapsed = end.getTime() - start.getTime(); // elapsed time in milliseconds

js// To test a function and get back its return
function printElapsedTime(testFn) {
  const startTime = Date.now();
  const result = testFn();
  const endTime = Date.now();

  console.log(`Elapsed time: ${String(endTime - startTime)} milliseconds`);
  return result;
}

const yourFunctionReturn = printElapsedTime(yourFunction);


Note:
In browsers that support the Performance API's high-resolution time feature, Performance.now() can provide more reliable and precise measurements of elapsed time than Date.now().
Get the number of seconds since the ECMAScript Epochjsconst seconds = Math.floor(Date.now() / 1000);

In this case, it's important to return only an integer—so a simple division won't do. It's also important to only return actually elapsed seconds. (That's why this code uses Math.floor(), and not Math.round().)SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-date-objectsBrowser compatibilitySee also
Date()\n\nDateBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackJavaScript Date objects represent a single moment in time in a platform-independent format. Date objects encapsulate an integral number that represents milliseconds since the midnight at the beginning of January 1, 1970, UTC (the epoch).

Note:
With the introduction of the Temporal API, the Date object is considered a legacy feature. Consider using Temporal for new code and migrate existing code over to it if possible (check the browser compatibility. We will be writing a usage guide soon!
DescriptionThe epoch, timestamps, and invalid dateA JavaScript date is fundamentally specified as the time in milliseconds that has elapsed since the epoch, which is defined as the midnight at the beginning of January 1, 1970, UTC (equivalent to the UNIX epoch). This timestamp is timezone-agnostic and uniquely defines an instant in history.

Note:
While the time value at the heart of a Date object is UTC, the basic methods to fetch the date and time or its components all work in the local (i.e., host system) time zone and offset.

The maximum timestamp representable by a Date object is slightly smaller than the maximum safe integer (Number.MAX_SAFE_INTEGER, which is 9,007,199,254,740,991). A Date object can represent a maximum of ±8,640,000,000,000,000 milliseconds, or ±100,000,000 (one hundred million) days, relative to the epoch. This is the range from April 20, 271821 BC to September 13, 275760 AD. Any attempt to represent a time outside this range results in the Date object holding a timestamp value of NaN, which is an "Invalid Date".
jsconsole.log(new Date(8.64e15).toString()); // "Sat Sep 13 275760 00:00:00 GMT+0000 (Coordinated Universal Time)"
console.log(new Date(8.64e15 + 1).toString()); // "Invalid Date"

There are various methods that allow you to interact with the timestamp stored in the date:

You can interact with the timestamp value directly using the getTime() and setTime() methods.
The valueOf() and [Symbol.toPrimitive]() (when passed "number") methods — which are automatically called in number coercion — return the timestamp, causing Date objects to behave like their timestamps when used in number contexts.
All static methods (Date.now(), Date.parse(), and Date.UTC()) return timestamps instead of Date objects.
The Date() constructor can be called with a timestamp as the only argument.
Date components and time zonesA date is represented internally as a single number, the timestamp. When interacting with it, the timestamp needs to be interpreted as a structured date-and-time representation. There are always two ways to interpret a timestamp: as a local time or as a Coordinated Universal Time (UTC), the global standard time defined by the World Time Standard. The local timezone is not stored in the date object, but is determined by the host environment (user's device).

Note:
UTC should not be confused with the Greenwich Mean Time (GMT), because they are not always equal — this is explained in more detail in the linked Wikipedia page.

For example, the timestamp 0 represents a unique instant in history, but it can be interpreted in two ways:

As a UTC time, it is midnight at the beginning of January 1, 1970, UTC,
As a local time in New York (UTC-5), it is 19:00:00 on December 31, 1969.

The getTimezoneOffset() method returns the difference between UTC and the local time in minutes. Note that the timezone offset does not only depend on the current timezone, but also on the time represented by the Date object, because of daylight saving time and historical changes. In essence, the timezone offset is the offset from UTC time, at the time represented by the Date object and at the location of the host environment.
There are two groups of Date methods: one group gets and sets various date components by interpreting the timestamp as a local time, while the other uses UTC.

  
    
      Component
      Local
      UTC
    
    
      Get
      Set
      Get
      Set
    
  
  
    
      Year
      getFullYear()
      setFullYear()
      getUTCFullYear()
      setUTCFullYear()
    
    
      Month
      getMonth()
      setMonth()
      getUTCMonth()
      setUTCMonth()
    
    
      Date (of month)
      getDate()
      setDate()
      getUTCDate()
      setUTCDate()
    
    
      Hours
      getHours()
      setHours()
      getUTCHours()
      setUTCHours()
    
    
      Minutes
      getMinutes()
      setMinutes()
      getUTCMinutes()
      setUTCMinutes()
    
    
      Seconds
      getSeconds()
      setSeconds()
      getUTCSeconds()
      setUTCSeconds()
    
    
      Milliseconds
      getMilliseconds()
      setMilliseconds()
      getUTCMilliseconds()
      setUTCMilliseconds()
    
    
      Day (of week)
      getDay()
      N/A
      getUTCDay()
      N/A
    
  

The Date() constructor can be called with two or more arguments, in which case they are interpreted as the year, month, day, hour, minute, second, and millisecond, respectively, in local time. Date.UTC() works similarly, but it interprets the components as UTC time and also accepts a single argument representing the year.

Note:
Some methods, including the Date() constructor, Date.UTC(), and the deprecated getYear()/setYear() methods, interpret a two-digit year as a year in the 1900s. For example, new Date(99, 5, 24) is interpreted as June 24, 1999, not June 24, 99. See Interpretation of two-digit years for more information.

When a segment overflows or underflows its expected range, it usually "carries over to" or "borrows from" the higher segment. For example, if the month is set to 12 (months are zero-based, so December is 11), it become the January of the next year. If the day of month is set to 0, it becomes the last day of the previous month. This also applies to dates specified with the date time string format.Date time string formatThere are many ways to format a date as a string. The JavaScript specification only specifies one format to be universally supported: the date time string format, a simplification of the ISO 8601 calendar date extended format. The format is as follows:
YYYY-MM-DDTHH:mm:ss.sssZ


YYYY is the year, with four digits (0000 to 9999), or as an expanded year of + or - followed by six digits. The sign is required for expanded years. -000000 is explicitly disallowed as a valid year.
MM is the month, with two digits (01 to 12). Defaults to 01.
DD is the day of the month, with two digits (01 to 31). Defaults to 01.
T is a literal character, which indicates the beginning of the time part of the string. The T is required when specifying the time part.
HH is the hour, with two digits (00 to 23). As a special case, 24:00:00 is allowed, and is interpreted as midnight at the beginning of the next day. Defaults to 00.
mm is the minute, with two digits (00 to 59). Defaults to 00.
ss is the second, with two digits (00 to 59). Defaults to 00.
sss is the millisecond, with three digits (000 to 999). Defaults to 000.
Z is the timezone offset, which can either be the literal character Z (indicating UTC), or + or - followed by HH:mm, the offset in hours and minutes from UTC.

Various components can be omitted, so the following are all valid:

Date-only form: YYYY, YYYY-MM, YYYY-MM-DD
Date-time form: one of the above date-only forms, followed by T, followed by HH:mm, HH:mm:ss, or HH:mm:ss.sss. Each combination can be followed by a time zone offset.

For example, "2011-10-10" (date-only form), "2011-10-10T14:48:00" (date-time form), or "2011-10-10T14:48:00.000+09:00" (date-time form with milliseconds and time zone) are all valid date time strings.
When the time zone offset is absent, date-only forms are interpreted as a UTC time and date-time forms are interpreted as a local time. The interpretation as a UTC time is due to a historical spec error that was not consistent with ISO 8601 but could not be changed due to web compatibility. See Broken Parser – A Web Reality Issue.
Date.parse() and the Date() constructor both accept strings in the date time string format as input. Furthermore, implementations are allowed to support other date formats when the input fails to match this format.
The toISOString() method returns a string representation of the date in the date time string format, with the time zone offset always set to Z (UTC).

Note:
You are encouraged to make sure your input conforms to the date time string format above for maximum compatibility, because support for other formats is not guaranteed. However, there are some formats that are supported in all major implementations — like RFC 2822 format — in which case their usage can be acceptable. Always conduct cross-browser tests to ensure your code works in all target browsers. A library can help if many different formats are to be accommodated.

Non-standard strings can be parsed in any way as desired by the implementation, including the time zone — most implementations use the local time zone by default. Implementations are not required to return invalid date for out-of-bounds date components, although they usually do. A string may have in-bounds date components (with the bounds defined above), but does not represent a date in reality (for example, "February 30"). Implementations behave inconsistently in this case. The Date.parse() page offers more examples about these non-standard cases.Other ways to format a date
toISOString() returns a string in the format 1970-01-01T00:00:00.000Z (the date time string format introduced above, which is simplified ISO 8601). toJSON() calls toISOString() and returns the result.
toString() returns a string in the format Thu Jan 01 1970 00:00:00 GMT+0000 (Coordinated Universal Time), while toDateString() and toTimeString() return the date and time parts of the string, respectively. [Symbol.toPrimitive]() (when passed "string" or "default") calls toString() and returns the result.
toUTCString() returns a string in the format Thu, 01 Jan 1970 00:00:00 GMT (generalized RFC 7231).
toLocaleDateString(), toLocaleTimeString(), and toLocaleString() use locale-specific date and time formats, usually provided by the Intl API.

See the Formats of toString method return values section for examples.Constructor
Date()

When called as a constructor, returns a new Date object. When called as a function, returns a string representation of the current date and time.

Static methods
Date.now()

Returns the numeric value corresponding to the current time—the number of milliseconds since January 1, 1970 00:00:00 UTC, with leap seconds ignored.

Date.parse()

Parses a string representation of a date and returns the number of milliseconds since January 1, 1970 00:00:00 UTC, with leap seconds ignored.

Date.UTC()

Accepts the same parameters as the longest form of the constructor (i.e., 2 to 7) and returns the number of milliseconds since January 1, 1970 00:00:00 UTC, with leap seconds ignored.

Instance propertiesThese properties are defined on Date.prototype and shared by all Date instances.

Date.prototype.constructor

The constructor function that created the instance object. For Date instances, the initial value is the Date constructor.

Instance methods
Date.prototype.getDate()

Returns the day of the month (1 – 31) for the specified date according to local time.

Date.prototype.getDay()

Returns the day of the week (0 – 6) for the specified date according to local time.

Date.prototype.getFullYear()

Returns the year (4 digits for 4-digit years) of the specified date according to local time.

Date.prototype.getHours()

Returns the hour (0 – 23) in the specified date according to local time.

Date.prototype.getMilliseconds()

Returns the milliseconds (0 – 999) in the specified date according to local time.

Date.prototype.getMinutes()

Returns the minutes (0 – 59) in the specified date according to local time.

Date.prototype.getMonth()

Returns the month (0 – 11) in the specified date according to local time.

Date.prototype.getSeconds()

Returns the seconds (0 – 59) in the specified date according to local time.

Date.prototype.getTime()

Returns the numeric value of the specified date as the number of milliseconds since January 1, 1970 00:00:00 UTC. (Negative values are returned for prior times.)

Date.prototype.getTimezoneOffset()

Returns the time-zone offset in minutes for the current locale.

Date.prototype.getUTCDate()

Returns the day (date) of the month (1 – 31) in the specified date according to universal time.

Date.prototype.getUTCDay()

Returns the day of the week (0 – 6) in the specified date according to universal time.

Date.prototype.getUTCFullYear()

Returns the year (4 digits for 4-digit years) in the specified date according to universal time.

Date.prototype.getUTCHours()

Returns the hours (0 – 23) in the specified date according to universal time.

Date.prototype.getUTCMilliseconds()

Returns the milliseconds (0 – 999) in the specified date according to universal time.

Date.prototype.getUTCMinutes()

Returns the minutes (0 – 59) in the specified date according to universal time.

Date.prototype.getUTCMonth()

Returns the month (0 – 11) in the specified date according to universal time.

Date.prototype.getUTCSeconds()

Returns the seconds (0 – 59) in the specified date according to universal time.

Date.prototype.getYear() 
Deprecated


Returns the year (usually 2–3 digits) in the specified date according to local time. Use getFullYear() instead.

Date.prototype.setDate()

Sets the day of the month for a specified date according to local time.

Date.prototype.setFullYear()

Sets the full year (e.g., 4 digits for 4-digit years) for a specified date according to local time.

Date.prototype.setHours()

Sets the hours for a specified date according to local time.

Date.prototype.setMilliseconds()

Sets the milliseconds for a specified date according to local time.

Date.prototype.setMinutes()

Sets the minutes for a specified date according to local time.

Date.prototype.setMonth()

Sets the month for a specified date according to local time.

Date.prototype.setSeconds()

Sets the seconds for a specified date according to local time.

Date.prototype.setTime()

Sets the Date object to the time represented by the number of milliseconds since January 1, 1970 00:00:00 UTC. Use negative numbers for times prior.

Date.prototype.setUTCDate()

Sets the day of the month for a specified date according to universal time.

Date.prototype.setUTCFullYear()

Sets the full year (e.g., 4 digits for 4-digit years) for a specified date according to universal time.

Date.prototype.setUTCHours()

Sets the hour for a specified date according to universal time.

Date.prototype.setUTCMilliseconds()

Sets the milliseconds for a specified date according to universal time.

Date.prototype.setUTCMinutes()

Sets the minutes for a specified date according to universal time.

Date.prototype.setUTCMonth()

Sets the month for a specified date according to universal time.

Date.prototype.setUTCSeconds()

Sets the seconds for a specified date according to universal time.

Date.prototype.setYear() 
Deprecated


Sets the year (usually 2–3 digits) for a specified date according to local time. Use setFullYear() instead.

Date.prototype.toDateString()

Returns the "date" portion of the Date as a human-readable string like 'Thu Apr 12 2018'.

Date.prototype.toISOString()

Converts a date to a string following the ISO 8601 Extended Format.

Date.prototype.toJSON()

Returns a string representing the Date using toISOString(). Intended to be implicitly called by JSON.stringify().

Date.prototype.toLocaleDateString()

Returns a string with a locality sensitive representation of the date portion of this date based on system settings.

Date.prototype.toLocaleString()

Returns a string with a locality-sensitive representation of this date. Overrides the Object.prototype.toLocaleString() method.

Date.prototype.toLocaleTimeString()

Returns a string with a locality-sensitive representation of the time portion of this date, based on system settings.

Date.prototype.toString()

Returns a string representing the specified Date object. Overrides the Object.prototype.toString() method.

Date.prototype.toTemporalInstant() 
Experimental


Returns a new Temporal.Instant object with the same epochMilliseconds value as this date's timestamp.

Date.prototype.toTimeString()

Returns the "time" portion of the Date as a human-readable string.

Date.prototype.toUTCString()

Converts a date to a string using the UTC timezone.

Date.prototype.valueOf()

Returns the primitive value of a Date object. Overrides the Object.prototype.valueOf() method.

Date.prototype[Symbol.toPrimitive]()

Converts this Date object to a primitive value.

ExamplesSeveral ways to create a Date objectThe following examples show several ways to create JavaScript dates:

Note:
Creating a date from a string has a lot of behavior inconsistencies. See date time string format for caveats on using different formats.

jsconst today = new Date();
const birthday = new Date("December 17, 1995 03:24:00"); // DISCOURAGED: may not work in all runtimes
const birthday2 = new Date("1995-12-17T03:24:00"); // This is standardized and will work reliably
const birthday3 = new Date(1995, 11, 17); // the month is 0-indexed
const birthday4 = new Date(1995, 11, 17, 3, 24, 0);
const birthday5 = new Date(628021800000); // passing epoch timestamp
Formats of toString method return valuesjsconst date = new Date("2020-05-12T23:50:21.817Z");
date.toString(); // Tue May 12 2020 18:50:21 GMT-0500 (Central Daylight Time)
date.toDateString(); // Tue May 12 2020
date.toTimeString(); // 18:50:21 GMT-0500 (Central Daylight Time)
date[Symbol.toPrimitive]("string"); // Tue May 12 2020 18:50:21 GMT-0500 (Central Daylight Time)

date.toISOString(); // 2020-05-12T23:50:21.817Z
date.toJSON(); // 2020-05-12T23:50:21.817Z

date.toUTCString(); // Tue, 12 May 2020 23:50:21 GMT

date.toLocaleString(); // 5/12/2020, 6:50:21 PM
date.toLocaleDateString(); // 5/12/2020
date.toLocaleTimeString(); // 6:50:21 PM
To get Date, Month and Year or Timejsconst date = new Date("2000-01-17T16:45:30");
const [month, day, year] = [
  date.getMonth(),
  date.getDate(),
  date.getFullYear(),
];
// [0, 17, 2000] as month are 0-indexed
const [hour, minutes, seconds] = [
  date.getHours(),
  date.getMinutes(),
  date.getSeconds(),
];
// [16, 45, 30]
Interpretation of two-digit yearsnew Date() exhibits legacy undesirable, inconsistent behavior with two-digit year values; specifically, when a new Date() call is given a two-digit year value, that year value does not get treated as a literal year and used as-is but instead gets interpreted as a relative offset — in some cases as an offset from the year 1900, but in other cases, as an offset from the year 2000.
jslet date = new Date(98, 1); // Sun Feb 01 1998 00:00:00 GMT+0000 (GMT)
date = new Date(22, 1); // Wed Feb 01 1922 00:00:00 GMT+0000 (GMT)
date = new Date("2/1/22"); // Tue Feb 01 2022 00:00:00 GMT+0000 (GMT)

// Legacy method; always interprets two-digit year values as relative to 1900
date.setYear(98);
date.toString(); // Sun Feb 01 1998 00:00:00 GMT+0000 (GMT)
date.setYear(22);
date.toString(); // Wed Feb 01 1922 00:00:00 GMT+0000 (GMT)

So, to create and get dates between the years 0 and 99, instead use the preferred setFullYear() and getFullYear() methods:.
js// Preferred method; never interprets any value as being a relative offset,
// but instead uses the year value as-is
date.setFullYear(98);
date.getFullYear(); // 98 (not 1998)
date.setFullYear(22);
date.getFullYear(); // 22 (not 1922, not 2022)
Calculating elapsed timeThe following examples show how to determine the elapsed time between two JavaScript dates in milliseconds.
Due to the differing lengths of days (due to daylight saving changeover), months, and years, expressing elapsed time in units greater than hours, minutes, and seconds requires addressing a number of issues, and should be thoroughly researched before being attempted.
js// Using Date objects
const start = Date.now();

// The event to time goes here:
doSomethingForALongTime();
const end = Date.now();
const elapsed = end - start; // elapsed time in milliseconds

js// Using built-in methods
const start = new Date();

// The event to time goes here:
doSomethingForALongTime();
const end = new Date();
const elapsed = end.getTime() - start.getTime(); // elapsed time in milliseconds

js// To test a function and get back its return
function printElapsedTime(testFn) {
  const startTime = Date.now();
  const result = testFn();
  const endTime = Date.now();

  console.log(`Elapsed time: ${String(endTime - startTime)} milliseconds`);
  return result;
}

const yourFunctionReturn = printElapsedTime(yourFunction);


Note:
In browsers that support the Performance API's high-resolution time feature, Performance.now() can provide more reliable and precise measurements of elapsed time than Date.now().
Get the number of seconds since the ECMAScript Epochjsconst seconds = Math.floor(Date.now() / 1000);

In this case, it's important to return only an integer—so a simple division won't do. It's also important to only return actually elapsed seconds. (That's why this code uses Math.floor(), and not Math.round().)SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-date-objectsBrowser compatibilitySee also
Date()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nDateBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackJavaScript Date objects represent a single moment in time in a platform-independent format. Date objects encapsulate an integral number that represents milliseconds since the midnight at the beginning of January 1, 1970, UTC (the epoch).

Note:
With the introduction of the Temporal API, the Date object is considered a legacy feature. Consider using Temporal for new code and migrate existing code over to it if possible (check the browser compatibility. We will be writing a usage guide soon!
DescriptionThe epoch, timestamps, and invalid dateA JavaScript date is fundamentally specified as the time in milliseconds that has elapsed since the epoch, which is defined as the midnight at the beginning of January 1, 1970, UTC (equivalent to the UNIX epoch). This timestamp is timezone-agnostic and uniquely defines an instant in history.

Note:
While the time value at the heart of a Date object is UTC, the basic methods to fetch the date and time or its components all work in the local (i.e., host system) time zone and offset.

The maximum timestamp representable by a Date object is slightly smaller than the maximum safe integer (Number.MAX_SAFE_INTEGER, which is 9,007,199,254,740,991). A Date object can represent a maximum of ±8,640,000,000,000,000 milliseconds, or ±100,000,000 (one hundred million) days, relative to the epoch. This is the range from April 20, 271821 BC to September 13, 275760 AD. Any attempt to represent a time outside this range results in the Date object holding a timestamp value of NaN, which is an "Invalid Date".
jsconsole.log(new Date(8.64e15).toString()); // "Sat Sep 13 275760 00:00:00 GMT+0000 (Coordinated Universal Time)"
console.log(new Date(8.64e15 + 1).toString()); // "Invalid Date"

There are various methods that allow you to interact with the timestamp stored in the date:

You can interact with the timestamp value directly using the getTime() and setTime() methods.
The valueOf() and [Symbol.toPrimitive]() (when passed "number") methods — which are automatically called in number coercion — return the timestamp, causing Date objects to behave like their timestamps when used in number contexts.
All static methods (Date.now(), Date.parse(), and Date.UTC()) return timestamps instead of Date objects.
The Date() constructor can be called with a timestamp as the only argument.
Date components and time zonesA date is represented internally as a single number, the timestamp. When interacting with it, the timestamp needs to be interpreted as a structured date-and-time representation. There are always two ways to interpret a timestamp: as a local time or as a Coordinated Universal Time (UTC), the global standard time defined by the World Time Standard. The local timezone is not stored in the date object, but is determined by the host environment (user's device).

Note:
UTC should not be confused with the Greenwich Mean Time (GMT), because they are not always equal — this is explained in more detail in the linked Wikipedia page.

For example, the timestamp 0 represents a unique instant in history, but it can be interpreted in two ways:

As a UTC time, it is midnight at the beginning of January 1, 1970, UTC,
As a local time in New York (UTC-5), it is 19:00:00 on December 31, 1969.

The getTimezoneOffset() method returns the difference between UTC and the local time in minutes. Note that the timezone offset does not only depend on the current timezone, but also on the time represented by the Date object, because of daylight saving time and historical changes. In essence, the timezone offset is the offset from UTC time, at the time represented by the Date object and at the location of the host environment.
There are two groups of Date methods: one group gets and sets various date components by interpreting the timestamp as a local time, while the other uses UTC.

  
    
      Component
      Local
      UTC
    
    
      Get
      Set
      Get
      Set
    
  
  
    
      Year
      getFullYear()
      setFullYear()
      getUTCFullYear()
      setUTCFullYear()
    
    
      Month
      getMonth()
      setMonth()
      getUTCMonth()
      setUTCMonth()
    
    
      Date (of month)
      getDate()
      setDate()
      getUTCDate()
      setUTCDate()
    
    
      Hours
      getHours()
      setHours()
      getUTCHours()
      setUTCHours()
    
    
      Minutes
      getMinutes()
      setMinutes()
      getUTCMinutes()
      setUTCMinutes()
    
    
      Seconds
      getSeconds()
      setSeconds()
      getUTCSeconds()
      setUTCSeconds()
    
    
      Milliseconds
      getMilliseconds()
      setMilliseconds()
      getUTCMilliseconds()
      setUTCMilliseconds()
    
    
      Day (of week)
      getDay()
      N/A
      getUTCDay()
      N/A
    
  

The Date() constructor can be called with two or more arguments, in which case they are interpreted as the year, month, day, hour, minute, second, and millisecond, respectively, in local time. Date.UTC() works similarly, but it interprets the components as UTC time and also accepts a single argument representing the year.

Note:
Some methods, including the Date() constructor, Date.UTC(), and the deprecated getYear()/setYear() methods, interpret a two-digit year as a year in the 1900s. For example, new Date(99, 5, 24) is interpreted as June 24, 1999, not June 24, 99. See Interpretation of two-digit years for more information.

When a segment overflows or underflows its expected range, it usually "carries over to" or "borrows from" the higher segment. For example, if the month is set to 12 (months are zero-based, so December is 11), it become the January of the next year. If the day of month is set to 0, it becomes the last day of the previous month. This also applies to dates specified with the date time string format.Date time string formatThere are many ways to format a date as a string. The JavaScript specification only specifies one format to be universally supported: the date time string format, a simplification of the ISO 8601 calendar date extended format. The format is as follows:
YYYY-MM-DDTHH:mm:ss.sssZ


YYYY is the year, with four digits (0000 to 9999), or as an expanded year of + or - followed by six digits. The sign is required for expanded years. -000000 is explicitly disallowed as a valid year.
MM is the month, with two digits (01 to 12). Defaults to 01.
DD is the day of the month, with two digits (01 to 31). Defaults to 01.
T is a literal character, which indicates the beginning of the time part of the string. The T is required when specifying the time part.
HH is the hour, with two digits (00 to 23). As a special case, 24:00:00 is allowed, and is interpreted as midnight at the beginning of the next day. Defaults to 00.
mm is the minute, with two digits (00 to 59). Defaults to 00.
ss is the second, with two digits (00 to 59). Defaults to 00.
sss is the millisecond, with three digits (000 to 999). Defaults to 000.
Z is the timezone offset, which can either be the literal character Z (indicating UTC), or + or - followed by HH:mm, the offset in hours and minutes from UTC.

Various components can be omitted, so the following are all valid:

Date-only form: YYYY, YYYY-MM, YYYY-MM-DD
Date-time form: one of the above date-only forms, followed by T, followed by HH:mm, HH:mm:ss, or HH:mm:ss.sss. Each combination can be followed by a time zone offset.

For example, "2011-10-10" (date-only form), "2011-10-10T14:48:00" (date-time form), or "2011-10-10T14:48:00.000+09:00" (date-time form with milliseconds and time zone) are all valid date time strings.
When the time zone offset is absent, date-only forms are interpreted as a UTC time and date-time forms are interpreted as a local time. The interpretation as a UTC time is due to a historical spec error that was not consistent with ISO 8601 but could not be changed due to web compatibility. See Broken Parser – A Web Reality Issue.
Date.parse() and the Date() constructor both accept strings in the date time string format as input. Furthermore, implementations are allowed to support other date formats when the input fails to match this format.
The toISOString() method returns a string representation of the date in the date time string format, with the time zone offset always set to Z (UTC).

Note:
You are encouraged to make sure your input conforms to the date time string format above for maximum compatibility, because support for other formats is not guaranteed. However, there are some formats that are supported in all major implementations — like RFC 2822 format — in which case their usage can be acceptable. Always conduct cross-browser tests to ensure your code works in all target browsers. A library can help if many different formats are to be accommodated.

Non-standard strings can be parsed in any way as desired by the implementation, including the time zone — most implementations use the local time zone by default. Implementations are not required to return invalid date for out-of-bounds date components, although they usually do. A string may have in-bounds date components (with the bounds defined above), but does not represent a date in reality (for example, "February 30"). Implementations behave inconsistently in this case. The Date.parse() page offers more examples about these non-standard cases.Other ways to format a date
toISOString() returns a string in the format 1970-01-01T00:00:00.000Z (the date time string format introduced above, which is simplified ISO 8601). toJSON() calls toISOString() and returns the result.
toString() returns a string in the format Thu Jan 01 1970 00:00:00 GMT+0000 (Coordinated Universal Time), while toDateString() and toTimeString() return the date and time parts of the string, respectively. [Symbol.toPrimitive]() (when passed "string" or "default") calls toString() and returns the result.
toUTCString() returns a string in the format Thu, 01 Jan 1970 00:00:00 GMT (generalized RFC 7231).
toLocaleDateString(), toLocaleTimeString(), and toLocaleString() use locale-specific date and time formats, usually provided by the Intl API.

See the Formats of toString method return values section for examples.Constructor
Date()

When called as a constructor, returns a new Date object. When called as a function, returns a string representation of the current date and time.

Static methods
Date.now()

Returns the numeric value corresponding to the current time—the number of milliseconds since January 1, 1970 00:00:00 UTC, with leap seconds ignored.

Date.parse()

Parses a string representation of a date and returns the number of milliseconds since January 1, 1970 00:00:00 UTC, with leap seconds ignored.

Date.UTC()

Accepts the same parameters as the longest form of the constructor (i.e., 2 to 7) and returns the number of milliseconds since January 1, 1970 00:00:00 UTC, with leap seconds ignored.

Instance propertiesThese properties are defined on Date.prototype and shared by all Date instances.

Date.prototype.constructor

The constructor function that created the instance object. For Date instances, the initial value is the Date constructor.

Instance methods
Date.prototype.getDate()

Returns the day of the month (1 – 31) for the specified date according to local time.

Date.prototype.getDay()

Returns the day of the week (0 – 6) for the specified date according to local time.

Date.prototype.getFullYear()

Returns the year (4 digits for 4-digit years) of the specified date according to local time.

Date.prototype.getHours()

Returns the hour (0 – 23) in the specified date according to local time.

Date.prototype.getMilliseconds()

Returns the milliseconds (0 – 999) in the specified date according to local time.

Date.prototype.getMinutes()

Returns the minutes (0 – 59) in the specified date according to local time.

Date.prototype.getMonth()

Returns the month (0 – 11) in the specified date according to local time.

Date.prototype.getSeconds()

Returns the seconds (0 – 59) in the specified date according to local time.

Date.prototype.getTime()

Returns the numeric value of the specified date as the number of milliseconds since January 1, 1970 00:00:00 UTC. (Negative values are returned for prior times.)

Date.prototype.getTimezoneOffset()

Returns the time-zone offset in minutes for the current locale.

Date.prototype.getUTCDate()

Returns the day (date) of the month (1 – 31) in the specified date according to universal time.

Date.prototype.getUTCDay()

Returns the day of the week (0 – 6) in the specified date according to universal time.

Date.prototype.getUTCFullYear()

Returns the year (4 digits for 4-digit years) in the specified date according to universal time.

Date.prototype.getUTCHours()

Returns the hours (0 – 23) in the specified date according to universal time.

Date.prototype.getUTCMilliseconds()

Returns the milliseconds (0 – 999) in the specified date according to universal time.

Date.prototype.getUTCMinutes()

Returns the minutes (0 – 59) in the specified date according to universal time.

Date.prototype.getUTCMonth()

Returns the month (0 – 11) in the specified date according to universal time.

Date.prototype.getUTCSeconds()

Returns the seconds (0 – 59) in the specified date according to universal time.

Date.prototype.getYear() 
Deprecated


Returns the year (usually 2–3 digits) in the specified date according to local time. Use getFullYear() instead.

Date.prototype.setDate()

Sets the day of the month for a specified date according to local time.

Date.prototype.setFullYear()

Sets the full year (e.g., 4 digits for 4-digit years) for a specified date according to local time.

Date.prototype.setHours()

Sets the hours for a specified date according to local time.

Date.prototype.setMilliseconds()

Sets the milliseconds for a specified date according to local time.

Date.prototype.setMinutes()

Sets the minutes for a specified date according to local time.

Date.prototype.setMonth()

Sets the month for a specified date according to local time.

Date.prototype.setSeconds()

Sets the seconds for a specified date according to local time.

Date.prototype.setTime()

Sets the Date object to the time represented by the number of milliseconds since January 1, 1970 00:00:00 UTC. Use negative numbers for times prior.

Date.prototype.setUTCDate()

Sets the day of the month for a specified date according to universal time.

Date.prototype.setUTCFullYear()

Sets the full year (e.g., 4 digits for 4-digit years) for a specified date according to universal time.

Date.prototype.setUTCHours()

Sets the hour for a specified date according to universal time.

Date.prototype.setUTCMilliseconds()

Sets the milliseconds for a specified date according to universal time.

Date.prototype.setUTCMinutes()

Sets the minutes for a specified date according to universal time.

Date.prototype.setUTCMonth()

Sets the month for a specified date according to universal time.

Date.prototype.setUTCSeconds()

Sets the seconds for a specified date according to universal time.

Date.prototype.setYear() 
Deprecated


Sets the year (usually 2–3 digits) for a specified date according to local time. Use setFullYear() instead.

Date.prototype.toDateString()

Returns the "date" portion of the Date as a human-readable string like 'Thu Apr 12 2018'.

Date.prototype.toISOString()

Converts a date to a string following the ISO 8601 Extended Format.

Date.prototype.toJSON()

Returns a string representing the Date using toISOString(). Intended to be implicitly called by JSON.stringify().

Date.prototype.toLocaleDateString()

Returns a string with a locality sensitive representation of the date portion of this date based on system settings.

Date.prototype.toLocaleString()

Returns a string with a locality-sensitive representation of this date. Overrides the Object.prototype.toLocaleString() method.

Date.prototype.toLocaleTimeString()

Returns a string with a locality-sensitive representation of the time portion of this date, based on system settings.

Date.prototype.toString()

Returns a string representing the specified Date object. Overrides the Object.prototype.toString() method.

Date.prototype.toTemporalInstant() 
Experimental


Returns a new Temporal.Instant object with the same epochMilliseconds value as this date's timestamp.

Date.prototype.toTimeString()

Returns the "time" portion of the Date as a human-readable string.

Date.prototype.toUTCString()

Converts a date to a string using the UTC timezone.

Date.prototype.valueOf()

Returns the primitive value of a Date object. Overrides the Object.prototype.valueOf() method.

Date.prototype[Symbol.toPrimitive]()

Converts this Date object to a primitive value.

ExamplesSeveral ways to create a Date objectThe following examples show several ways to create JavaScript dates:

Note:
Creating a date from a string has a lot of behavior inconsistencies. See date time string format for caveats on using different formats.

jsconst today = new Date();
const birthday = new Date("December 17, 1995 03:24:00"); // DISCOURAGED: may not work in all runtimes
const birthday2 = new Date("1995-12-17T03:24:00"); // This is standardized and will work reliably
const birthday3 = new Date(1995, 11, 17); // the month is 0-indexed
const birthday4 = new Date(1995, 11, 17, 3, 24, 0);
const birthday5 = new Date(628021800000); // passing epoch timestamp
Formats of toString method return valuesjsconst date = new Date("2020-05-12T23:50:21.817Z");
date.toString(); // Tue May 12 2020 18:50:21 GMT-0500 (Central Daylight Time)
date.toDateString(); // Tue May 12 2020
date.toTimeString(); // 18:50:21 GMT-0500 (Central Daylight Time)
date[Symbol.toPrimitive]("string"); // Tue May 12 2020 18:50:21 GMT-0500 (Central Daylight Time)

date.toISOString(); // 2020-05-12T23:50:21.817Z
date.toJSON(); // 2020-05-12T23:50:21.817Z

date.toUTCString(); // Tue, 12 May 2020 23:50:21 GMT

date.toLocaleString(); // 5/12/2020, 6:50:21 PM
date.toLocaleDateString(); // 5/12/2020
date.toLocaleTimeString(); // 6:50:21 PM
To get Date, Month and Year or Timejsconst date = new Date("2000-01-17T16:45:30");
const [month, day, year] = [
  date.getMonth(),
  date.getDate(),
  date.getFullYear(),
];
// [0, 17, 2000] as month are 0-indexed
const [hour, minutes, seconds] = [
  date.getHours(),
  date.getMinutes(),
  date.getSeconds(),
];
// [16, 45, 30]
Interpretation of two-digit yearsnew Date() exhibits legacy undesirable, inconsistent behavior with two-digit year values; specifically, when a new Date() call is given a two-digit year value, that year value does not get treated as a literal year and used as-is but instead gets interpreted as a relative offset — in some cases as an offset from the year 1900, but in other cases, as an offset from the year 2000.
jslet date = new Date(98, 1); // Sun Feb 01 1998 00:00:00 GMT+0000 (GMT)
date = new Date(22, 1); // Wed Feb 01 1922 00:00:00 GMT+0000 (GMT)
date = new Date("2/1/22"); // Tue Feb 01 2022 00:00:00 GMT+0000 (GMT)

// Legacy method; always interprets two-digit year values as relative to 1900
date.setYear(98);
date.toString(); // Sun Feb 01 1998 00:00:00 GMT+0000 (GMT)
date.setYear(22);
date.toString(); // Wed Feb 01 1922 00:00:00 GMT+0000 (GMT)

So, to create and get dates between the years 0 and 99, instead use the preferred setFullYear() and getFullYear() methods:.
js// Preferred method; never interprets any value as being a relative offset,
// but instead uses the year value as-is
date.setFullYear(98);
date.getFullYear(); // 98 (not 1998)
date.setFullYear(22);
date.getFullYear(); // 22 (not 1922, not 2022)
Calculating elapsed timeThe following examples show how to determine the elapsed time between two JavaScript dates in milliseconds.
Due to the differing lengths of days (due to daylight saving changeover), months, and years, expressing elapsed time in units greater than hours, minutes, and seconds requires addressing a number of issues, and should be thoroughly researched before being attempted.
js// Using Date objects
const start = Date.now();

// The event to time goes here:
doSomethingForALongTime();
const end = Date.now();
const elapsed = end - start; // elapsed time in milliseconds

js// Using built-in methods
const start = new Date();

// The event to time goes here:
doSomethingForALongTime();
const end = new Date();
const elapsed = end.getTime() - start.getTime(); // elapsed time in milliseconds

js// To test a function and get back its return
function printElapsedTime(testFn) {
  const startTime = Date.now();
  const result = testFn();
  const endTime = Date.now();

  console.log(`Elapsed time: ${String(endTime - startTime)} milliseconds`);
  return result;
}

const yourFunctionReturn = printElapsedTime(yourFunction);


Note:
In browsers that support the Performance API's high-resolution time feature, Performance.now() can provide more reliable and precise measurements of elapsed time than Date.now().
Get the number of seconds since the ECMAScript Epochjsconst seconds = Math.floor(Date.now() / 1000);

In this case, it's important to return only an integer—so a simple division won't do. It's also important to only return actually elapsed seconds. (That's why this code uses Math.floor(), and not Math.round().)SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-date-objectsBrowser compatibilitySee also
Date()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nDate.prototype.toISOString()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe toISOString() method of Date instances returns a string representing this date in the date time string format, a simplified format based on ISO 8601, which is always 24 or 27 characters long (YYYY-MM-DDTHH:mm:ss.sssZ or ±YYYYYY-MM-DDTHH:mm:ss.sssZ, respectively). The timezone is always UTC, as denoted by the suffix Z.Try it
const event = new Date("05 October 2011 14:48 UTC");
console.log(event.toString());
// Expected output: "Wed Oct 05 2011 16:48:00 GMT+0200 (CEST)"
// Note: your timezone may vary

console.log(event.toISOString());
// Expected output: "2011-10-05T14:48:00.000Z"
SyntaxjstoISOString()
ParametersNone.Return valueA string representing the given date in the date time string format according to universal time. It's the same format as the one required to be recognized by Date.parse().Exceptions
RangeError

Thrown if the date is invalid or if it corresponds to a year that cannot be represented in the date string format.

ExamplesUsing toISOString()jsconst d = new Date(0);

console.log(d.toISOString()); // "1970-01-01T00:00:00.000Z"
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-date.prototype.toisostringBrowser compatibilitySee also
Date.prototype.toLocaleDateString()
Date.prototype.toString()
Date.prototype.toUTCString()\n\nDate.prototype.toISOString()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe toISOString() method of Date instances returns a string representing this date in the date time string format, a simplified format based on ISO 8601, which is always 24 or 27 characters long (YYYY-MM-DDTHH:mm:ss.sssZ or ±YYYYYY-MM-DDTHH:mm:ss.sssZ, respectively). The timezone is always UTC, as denoted by the suffix Z.Try it
const event = new Date("05 October 2011 14:48 UTC");
console.log(event.toString());
// Expected output: "Wed Oct 05 2011 16:48:00 GMT+0200 (CEST)"
// Note: your timezone may vary

console.log(event.toISOString());
// Expected output: "2011-10-05T14:48:00.000Z"
SyntaxjstoISOString()
ParametersNone.Return valueA string representing the given date in the date time string format according to universal time. It's the same format as the one required to be recognized by Date.parse().Exceptions
RangeError

Thrown if the date is invalid or if it corresponds to a year that cannot be represented in the date string format.

ExamplesUsing toISOString()jsconst d = new Date(0);

console.log(d.toISOString()); // "1970-01-01T00:00:00.000Z"
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-date.prototype.toisostringBrowser compatibilitySee also
Date.prototype.toLocaleDateString()
Date.prototype.toString()
Date.prototype.toUTCString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nDate.prototype.toISOString()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe toISOString() method of Date instances returns a string representing this date in the date time string format, a simplified format based on ISO 8601, which is always 24 or 27 characters long (YYYY-MM-DDTHH:mm:ss.sssZ or ±YYYYYY-MM-DDTHH:mm:ss.sssZ, respectively). The timezone is always UTC, as denoted by the suffix Z.Try it
const event = new Date("05 October 2011 14:48 UTC");
console.log(event.toString());
// Expected output: "Wed Oct 05 2011 16:48:00 GMT+0200 (CEST)"
// Note: your timezone may vary

console.log(event.toISOString());
// Expected output: "2011-10-05T14:48:00.000Z"
SyntaxjstoISOString()
ParametersNone.Return valueA string representing the given date in the date time string format according to universal time. It's the same format as the one required to be recognized by Date.parse().Exceptions
RangeError

Thrown if the date is invalid or if it corresponds to a year that cannot be represented in the date string format.

ExamplesUsing toISOString()jsconst d = new Date(0);

console.log(d.toISOString()); // "1970-01-01T00:00:00.000Z"
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-date.prototype.toisostringBrowser compatibilitySee also
Date.prototype.toLocaleDateString()
Date.prototype.toString()
Date.prototype.toUTCString()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nEnumerability and ownership of propertiesEvery property in JavaScript objects can be classified by three factors:

Enumerable or non-enumerable;
String or symbol;
Own property or inherited property from the prototype chain.

Enumerable properties are those properties whose internal enumerable flag is set to true, which is the default for properties created via simple assignment or via a property initializer. Properties defined via Object.defineProperty and such are not enumerable by default. Most iteration means (such as for...in loops and Object.keys) only visit enumerable keys.
Ownership of properties is determined by whether the property belongs to the object directly and not to its prototype chain.
All properties, enumerable or not, string or symbol, own or inherited, can be accessed with dot notation or bracket notation. In this section, we will focus on the means provided by JavaScript to visit a group of object properties one-by-one.Querying object propertiesThere are four built-in ways to query a property of an object. They all support both string and symbol keys. The following table summarizes when each method returns true.




Enumerable, own
Enumerable, inherited
Non-enumerable, own
Non-enumerable, inherited




propertyIsEnumerable()
true ✅
false ❌
false ❌
false ❌


hasOwnProperty()
true ✅
false ❌
true ✅
false ❌


Object.hasOwn()
true ✅
false ❌
true ✅
false ❌


in
true ✅
true ✅
true ✅
true ✅


Traversing object propertiesThere are many methods in JavaScript that traverse a group of properties of an object. Sometimes, these properties are returned as an array; sometimes, they are iterated one-by-one in a loop; sometimes, they are used for constructing or mutating another object. The following table summarizes when a property may be visited.
Methods that only visit string properties or only symbol properties will have an extra note. ✅ means a property of this type will be visited; ❌ means it will not.




Enumerable, own
Enumerable, inherited
Non-enumerable, own
Non-enumerable, inherited




Object.keysObject.valuesObject.entries
✅(strings)
❌
❌
❌


Object.getOwnPropertyNames
✅(strings)
❌
✅(strings)
❌


Object.getOwnPropertySymbols
✅(symbols)
❌
✅(symbols)
❌


Object.getOwnPropertyDescriptors
✅
❌
✅
❌


Reflect.ownKeys
✅
❌
✅
❌


for...in
✅(strings)
✅(strings)
❌
❌


Object.assign(After the first parameter)
✅
❌
❌
❌


Object spread
✅
❌
❌
❌


Obtaining properties by enumerability/ownershipNote that this is not the most efficient algorithm for all cases, but useful for a quick demonstration.

Detection can occur by SimplePropertyRetriever.theGetMethodYouWant(obj).includes(prop)
Iteration can occur by SimplePropertyRetriever.theGetMethodYouWant(obj).forEach((value, prop) => {}); (or use filter(), map(), etc.)

jsconst SimplePropertyRetriever = {
  getOwnEnumProps(obj) {
    return this._getPropertyNames(obj, true, false, this._enumerable);
    // Or could use for...in filtered with Object.hasOwn or just this: return Object.keys(obj);
  },
  getOwnNonEnumProps(obj) {
    return this._getPropertyNames(obj, true, false, this._notEnumerable);
  },
  getOwnProps(obj) {
    return this._getPropertyNames(
      obj,
      true,
      false,
      this._enumerableAndNotEnumerable,
    );
    // Or just use: return Object.getOwnPropertyNames(obj);
  },
  getPrototypeEnumProps(obj) {
    return this._getPropertyNames(obj, false, true, this._enumerable);
  },
  getPrototypeNonEnumProps(obj) {
    return this._getPropertyNames(obj, false, true, this._notEnumerable);
  },
  getPrototypeProps(obj) {
    return this._getPropertyNames(
      obj,
      false,
      true,
      this._enumerableAndNotEnumerable,
    );
  },
  getOwnAndPrototypeEnumProps(obj) {
    return this._getPropertyNames(obj, true, true, this._enumerable);
    // Or could use unfiltered for...in
  },
  getOwnAndPrototypeNonEnumProps(obj) {
    return this._getPropertyNames(obj, true, true, this._notEnumerable);
  },
  getOwnAndPrototypeEnumAndNonEnumProps(obj) {
    return this._getPropertyNames(
      obj,
      true,
      true,
      this._enumerableAndNotEnumerable,
    );
  },
  // Private static property checker callbacks
  _enumerable(obj, prop) {
    return Object.prototype.propertyIsEnumerable.call(obj, prop);
  },
  _notEnumerable(obj, prop) {
    return !Object.prototype.propertyIsEnumerable.call(obj, prop);
  },
  _enumerableAndNotEnumerable(obj, prop) {
    return true;
  },
  // Inspired by http://stackoverflow.com/a/8024294/271577
  _getPropertyNames(obj, iterateSelf, iteratePrototype, shouldInclude) {
    const props = [];
    do {
      if (iterateSelf) {
        Object.getOwnPropertyNames(obj).forEach((prop) => {
          if (props.indexOf(prop) === -1 && shouldInclude(obj, prop)) {
            props.push(prop);
          }
        });
      }
      if (!iteratePrototype) {
        break;
      }
      iterateSelf = true;
      obj = Object.getPrototypeOf(obj);
    } while (obj);
    return props;
  },
};
See also
in
for...in
Object.prototype.hasOwnProperty()
Object.prototype.propertyIsEnumerable()
Object.getOwnPropertyNames()
Object.getOwnPropertySymbols()
Object.keys()
Object.getOwnPropertyDescriptors()
Object.hasOwn()
Reflect.ownKeys()\n\nEnumerability and ownership of propertiesEvery property in JavaScript objects can be classified by three factors:

Enumerable or non-enumerable;
String or symbol;
Own property or inherited property from the prototype chain.

Enumerable properties are those properties whose internal enumerable flag is set to true, which is the default for properties created via simple assignment or via a property initializer. Properties defined via Object.defineProperty and such are not enumerable by default. Most iteration means (such as for...in loops and Object.keys) only visit enumerable keys.
Ownership of properties is determined by whether the property belongs to the object directly and not to its prototype chain.
All properties, enumerable or not, string or symbol, own or inherited, can be accessed with dot notation or bracket notation. In this section, we will focus on the means provided by JavaScript to visit a group of object properties one-by-one.Querying object propertiesThere are four built-in ways to query a property of an object. They all support both string and symbol keys. The following table summarizes when each method returns true.




Enumerable, own
Enumerable, inherited
Non-enumerable, own
Non-enumerable, inherited




propertyIsEnumerable()
true ✅
false ❌
false ❌
false ❌


hasOwnProperty()
true ✅
false ❌
true ✅
false ❌


Object.hasOwn()
true ✅
false ❌
true ✅
false ❌


in
true ✅
true ✅
true ✅
true ✅


Traversing object propertiesThere are many methods in JavaScript that traverse a group of properties of an object. Sometimes, these properties are returned as an array; sometimes, they are iterated one-by-one in a loop; sometimes, they are used for constructing or mutating another object. The following table summarizes when a property may be visited.
Methods that only visit string properties or only symbol properties will have an extra note. ✅ means a property of this type will be visited; ❌ means it will not.




Enumerable, own
Enumerable, inherited
Non-enumerable, own
Non-enumerable, inherited




Object.keysObject.valuesObject.entries
✅(strings)
❌
❌
❌


Object.getOwnPropertyNames
✅(strings)
❌
✅(strings)
❌


Object.getOwnPropertySymbols
✅(symbols)
❌
✅(symbols)
❌


Object.getOwnPropertyDescriptors
✅
❌
✅
❌


Reflect.ownKeys
✅
❌
✅
❌


for...in
✅(strings)
✅(strings)
❌
❌


Object.assign(After the first parameter)
✅
❌
❌
❌


Object spread
✅
❌
❌
❌


Obtaining properties by enumerability/ownershipNote that this is not the most efficient algorithm for all cases, but useful for a quick demonstration.

Detection can occur by SimplePropertyRetriever.theGetMethodYouWant(obj).includes(prop)
Iteration can occur by SimplePropertyRetriever.theGetMethodYouWant(obj).forEach((value, prop) => {}); (or use filter(), map(), etc.)

jsconst SimplePropertyRetriever = {
  getOwnEnumProps(obj) {
    return this._getPropertyNames(obj, true, false, this._enumerable);
    // Or could use for...in filtered with Object.hasOwn or just this: return Object.keys(obj);
  },
  getOwnNonEnumProps(obj) {
    return this._getPropertyNames(obj, true, false, this._notEnumerable);
  },
  getOwnProps(obj) {
    return this._getPropertyNames(
      obj,
      true,
      false,
      this._enumerableAndNotEnumerable,
    );
    // Or just use: return Object.getOwnPropertyNames(obj);
  },
  getPrototypeEnumProps(obj) {
    return this._getPropertyNames(obj, false, true, this._enumerable);
  },
  getPrototypeNonEnumProps(obj) {
    return this._getPropertyNames(obj, false, true, this._notEnumerable);
  },
  getPrototypeProps(obj) {
    return this._getPropertyNames(
      obj,
      false,
      true,
      this._enumerableAndNotEnumerable,
    );
  },
  getOwnAndPrototypeEnumProps(obj) {
    return this._getPropertyNames(obj, true, true, this._enumerable);
    // Or could use unfiltered for...in
  },
  getOwnAndPrototypeNonEnumProps(obj) {
    return this._getPropertyNames(obj, true, true, this._notEnumerable);
  },
  getOwnAndPrototypeEnumAndNonEnumProps(obj) {
    return this._getPropertyNames(
      obj,
      true,
      true,
      this._enumerableAndNotEnumerable,
    );
  },
  // Private static property checker callbacks
  _enumerable(obj, prop) {
    return Object.prototype.propertyIsEnumerable.call(obj, prop);
  },
  _notEnumerable(obj, prop) {
    return !Object.prototype.propertyIsEnumerable.call(obj, prop);
  },
  _enumerableAndNotEnumerable(obj, prop) {
    return true;
  },
  // Inspired by http://stackoverflow.com/a/8024294/271577
  _getPropertyNames(obj, iterateSelf, iteratePrototype, shouldInclude) {
    const props = [];
    do {
      if (iterateSelf) {
        Object.getOwnPropertyNames(obj).forEach((prop) => {
          if (props.indexOf(prop) === -1 && shouldInclude(obj, prop)) {
            props.push(prop);
          }
        });
      }
      if (!iteratePrototype) {
        break;
      }
      iterateSelf = true;
      obj = Object.getPrototypeOf(obj);
    } while (obj);
    return props;
  },
};
See also
in
for...in
Object.prototype.hasOwnProperty()
Object.prototype.propertyIsEnumerable()
Object.getOwnPropertyNames()
Object.getOwnPropertySymbols()
Object.keys()
Object.getOwnPropertyDescriptors()
Object.hasOwn()
Reflect.ownKeys()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nEnumerability and ownership of propertiesEvery property in JavaScript objects can be classified by three factors:

Enumerable or non-enumerable;
String or symbol;
Own property or inherited property from the prototype chain.

Enumerable properties are those properties whose internal enumerable flag is set to true, which is the default for properties created via simple assignment or via a property initializer. Properties defined via Object.defineProperty and such are not enumerable by default. Most iteration means (such as for...in loops and Object.keys) only visit enumerable keys.
Ownership of properties is determined by whether the property belongs to the object directly and not to its prototype chain.
All properties, enumerable or not, string or symbol, own or inherited, can be accessed with dot notation or bracket notation. In this section, we will focus on the means provided by JavaScript to visit a group of object properties one-by-one.Querying object propertiesThere are four built-in ways to query a property of an object. They all support both string and symbol keys. The following table summarizes when each method returns true.




Enumerable, own
Enumerable, inherited
Non-enumerable, own
Non-enumerable, inherited




propertyIsEnumerable()
true ✅
false ❌
false ❌
false ❌


hasOwnProperty()
true ✅
false ❌
true ✅
false ❌


Object.hasOwn()
true ✅
false ❌
true ✅
false ❌


in
true ✅
true ✅
true ✅
true ✅


Traversing object propertiesThere are many methods in JavaScript that traverse a group of properties of an object. Sometimes, these properties are returned as an array; sometimes, they are iterated one-by-one in a loop; sometimes, they are used for constructing or mutating another object. The following table summarizes when a property may be visited.
Methods that only visit string properties or only symbol properties will have an extra note. ✅ means a property of this type will be visited; ❌ means it will not.




Enumerable, own
Enumerable, inherited
Non-enumerable, own
Non-enumerable, inherited




Object.keysObject.valuesObject.entries
✅(strings)
❌
❌
❌


Object.getOwnPropertyNames
✅(strings)
❌
✅(strings)
❌


Object.getOwnPropertySymbols
✅(symbols)
❌
✅(symbols)
❌


Object.getOwnPropertyDescriptors
✅
❌
✅
❌


Reflect.ownKeys
✅
❌
✅
❌


for...in
✅(strings)
✅(strings)
❌
❌


Object.assign(After the first parameter)
✅
❌
❌
❌


Object spread
✅
❌
❌
❌


Obtaining properties by enumerability/ownershipNote that this is not the most efficient algorithm for all cases, but useful for a quick demonstration.

Detection can occur by SimplePropertyRetriever.theGetMethodYouWant(obj).includes(prop)
Iteration can occur by SimplePropertyRetriever.theGetMethodYouWant(obj).forEach((value, prop) => {}); (or use filter(), map(), etc.)

jsconst SimplePropertyRetriever = {
  getOwnEnumProps(obj) {
    return this._getPropertyNames(obj, true, false, this._enumerable);
    // Or could use for...in filtered with Object.hasOwn or just this: return Object.keys(obj);
  },
  getOwnNonEnumProps(obj) {
    return this._getPropertyNames(obj, true, false, this._notEnumerable);
  },
  getOwnProps(obj) {
    return this._getPropertyNames(
      obj,
      true,
      false,
      this._enumerableAndNotEnumerable,
    );
    // Or just use: return Object.getOwnPropertyNames(obj);
  },
  getPrototypeEnumProps(obj) {
    return this._getPropertyNames(obj, false, true, this._enumerable);
  },
  getPrototypeNonEnumProps(obj) {
    return this._getPropertyNames(obj, false, true, this._notEnumerable);
  },
  getPrototypeProps(obj) {
    return this._getPropertyNames(
      obj,
      false,
      true,
      this._enumerableAndNotEnumerable,
    );
  },
  getOwnAndPrototypeEnumProps(obj) {
    return this._getPropertyNames(obj, true, true, this._enumerable);
    // Or could use unfiltered for...in
  },
  getOwnAndPrototypeNonEnumProps(obj) {
    return this._getPropertyNames(obj, true, true, this._notEnumerable);
  },
  getOwnAndPrototypeEnumAndNonEnumProps(obj) {
    return this._getPropertyNames(
      obj,
      true,
      true,
      this._enumerableAndNotEnumerable,
    );
  },
  // Private static property checker callbacks
  _enumerable(obj, prop) {
    return Object.prototype.propertyIsEnumerable.call(obj, prop);
  },
  _notEnumerable(obj, prop) {
    return !Object.prototype.propertyIsEnumerable.call(obj, prop);
  },
  _enumerableAndNotEnumerable(obj, prop) {
    return true;
  },
  // Inspired by http://stackoverflow.com/a/8024294/271577
  _getPropertyNames(obj, iterateSelf, iteratePrototype, shouldInclude) {
    const props = [];
    do {
      if (iterateSelf) {
        Object.getOwnPropertyNames(obj).forEach((prop) => {
          if (props.indexOf(prop) === -1 && shouldInclude(obj, prop)) {
            props.push(prop);
          }
        });
      }
      if (!iteratePrototype) {
        break;
      }
      iterateSelf = true;
      obj = Object.getPrototypeOf(obj);
    } while (obj);
    return props;
  },
};
See also
in
for...in
Object.prototype.hasOwnProperty()
Object.prototype.propertyIsEnumerable()
Object.getOwnPropertyNames()
Object.getOwnPropertySymbols()
Object.keys()
Object.getOwnPropertyDescriptors()
Object.hasOwn()
Reflect.ownKeys()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nMapBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Map object holds key-value pairs and remembers the original insertion order of the keys.
Any value (both objects and primitive values) may be used as either a key or a value.Try it
const map1 = new Map();

map1.set("a", 1);
map1.set("b", 2);
map1.set("c", 3);

console.log(map1.get("a"));
// Expected output: 1

map1.set("a", 97);

console.log(map1.get("a"));
// Expected output: 97

console.log(map1.size);
// Expected output: 3

map1.delete("b");

console.log(map1.size);
// Expected output: 2
DescriptionMap objects are collections of key-value pairs. A key in the Map may only occur once; it is unique in the Map's collection. A Map object is iterated by key-value pairs — a for...of loop returns a 2-member array of [key, value] for each iteration. Iteration happens in insertion order, which corresponds to the order in which each key-value pair was first inserted into the map by the set() method (that is, there wasn't a key with the same value already in the map when set() was called).
The specification requires maps to be implemented "that, on average, provide access times that are sublinear on the number of elements in the collection". Therefore, it could be represented internally as a hash table (with O(1) lookup), a search tree (with O(log(N)) lookup), or any other data structure, as long as the complexity is better than O(N).Key equalityValue equality is based on the SameValueZero algorithm. (It used to use SameValue, which treated 0 and -0 as different. Check browser compatibility.) This means NaN is considered the same as NaN (even though NaN !== NaN) and all other values are considered equal according to the semantics of the === operator.Objects vs. MapsObject is similar to Map—both let you set keys to
values, retrieve those values, delete keys, and detect whether something is
stored at a key. For this reason (and because there were no built-in
alternatives), Object has been used as Map historically.
However, there are important differences that make Map preferable in some
cases:

  
    
      
      Map
      Object
    
  
  
    
      Accidental Keys
      
        A Map does not contain any keys by default. It only
        contains what is explicitly put into it.
      
      
        
          An Object has a prototype, so it contains default keys
          that could collide with your own keys if you're not careful.
        
        
          
            Note: This can be bypassed by using
            Object.create(null),
            but this is seldom done.
          
        
      
    
    
      Security
      
        A Map is safe to use with user-provided keys and values.
      
      
        
          Setting user-provided key-value pairs on an Object may allow
          an attacker to override the object's prototype, which can lead to
          
            object injection attacks
          . Like the accidental keys issue, this can also be mitigated by using
          a null-prototype object.
        
      
    
    
      Key Types
      
        A Map's keys can be any value (including functions,
        objects, or any primitive).
      
      
        The keys of an Object must be either a
        String or a Symbol.
      
    
    
      Key Order
      
        
          The keys in Map are ordered in a straightforward
          way: A Map object iterates entries, keys, and values in
          the order of entry insertion.
        
      
      
        
          Although the keys of an ordinary Object are ordered now,
          this was not always the case, and the order is complex. As a result,
          it's best not to rely on property order.
        
        
          The order was first defined for own properties only in ECMAScript
          2015; ECMAScript 2020 defines order for inherited properties as well.
          But note that no single mechanism
          iterates
          all of an object's properties; the various mechanisms
          each include different subsets of properties.
          (for-in
          includes only enumerable string-keyed properties;
          Object.keys includes only own, enumerable,
          string-keyed properties;
          Object.getOwnPropertyNames includes own,
          string-keyed properties even if non-enumerable;
          Object.getOwnPropertySymbols does the same
          for just Symbol-keyed properties, etc.)
        
      
    
    
      Size
      
        The number of items in a Map is easily retrieved from its
        size property.
      
      
        Determining the number of items in an Object is more roundabout and less efficient. A common way to do it is through the length of the array returned from Object.keys().
      
    
    
      Iteration
      
        A Map is an
        iterable, so it can be directly iterated.
      
      
        
          Object does not implement an iteration protocol, and so objects are not directly iterable using the JavaScript
          for...of
          statement (by default).
        
        
          Note:
          
            
              An object can implement the iteration protocol, or you can get an
              iterable for an object using Object.keys or Object.entries.
            
            
              The
              for...in
              statement allows you to iterate over the
              enumerable properties of an object.
            
          
        
      
    
    
      Performance
      
        
          Performs better in scenarios involving frequent additions and removals
          of key-value pairs.
        
      
      
        
          Not optimized for frequent additions and removals of key-value pairs.
        
      
    
    
      Serialization and parsing
      
        No native support for serialization or parsing.
        
          (But you can build your own serialization and parsing support for
          Map by using JSON.stringify()
          with its replacer argument, and by using
          JSON.parse() with its
          reviver argument. See the Stack Overflow question
          How do you JSON.stringify an ES6 Map?).
        
      
      
        
          Native support for serialization from Object to
          JSON, using JSON.stringify().
        
        
          Native support for parsing from JSON to Object,
          using JSON.parse().
        
      
    
  
Setting object propertiesSetting Object properties works for Map objects as well, and can cause
considerable confusion.
Therefore, this appears to work in a way:
jsconst wrongMap = new Map();
wrongMap["bla"] = "blaa";
wrongMap["bla2"] = "blaaa2";

console.log(wrongMap); // Map { bla: 'blaa', bla2: 'blaaa2' }

But that way of setting a property does not interact with the Map data
structure. It uses the feature of the generic object. The value of 'bla' is not
stored in the Map for queries. Other operations on the data fail:
jswrongMap.has("bla"); // false
wrongMap.delete("bla"); // false
console.log(wrongMap); // Map { bla: 'blaa', bla2: 'blaaa2' }

The correct usage for storing data in the Map is through the set(key, value)
method.
jsconst contacts = new Map();
contacts.set("Jessie", { phone: "213-555-1234", address: "123 N 1st Ave" });
contacts.has("Jessie"); // true
contacts.get("Hilary"); // undefined
contacts.set("Hilary", { phone: "617-555-4321", address: "321 S 2nd St" });
contacts.get("Jessie"); // {phone: "213-555-1234", address: "123 N 1st Ave"}
contacts.delete("Raymond"); // false
contacts.delete("Jessie"); // true
console.log(contacts.size); // 1
Map-like browser APIsBrowser Map-like objects (or "maplike objects") are Web API interfaces that behave in many ways like a Map.
Just like Map, entries can be iterated in the same order that they were added to the object.
Map-like objects and Map also have properties and methods that share the same name and behavior.
However unlike Map they only allow specific predefined types for the keys and values of each entry.
The allowed types are set in the specification IDL definition.
For example, RTCStatsReport is a Map-like object that must use strings for keys and objects for values.
This is defined in the specification IDL below:
webidlinterface RTCStatsReport {
  readonly maplike<DOMString, object>;
};

Map-like objects are either read-only or read-writable (see the readonly keyword in the IDL above).

Read-only Map-like objects have the property size, and the methods: entries(), forEach(), get(), has(), keys(), values(), and Symbol.iterator().
Writeable Map-like objects additionally have the methods: clear(), delete(), and set().

The methods and properties have the same behavior as the equivalent entities in Map, except for the restriction on the types of the keys and values.
The following are examples of read-only Map-like browser objects:

AudioParamMap
RTCStatsReport
EventCounts
KeyboardLayoutMap
MIDIInputMap
MIDIOutputMap
Constructor
Map()

Creates a new Map object.

Static properties
Map[Symbol.species]

The constructor function that is used to create derived objects.

Static methods
Map.groupBy()

Groups the elements of a given iterable using the values returned by a provided callback function. The final returned Map uses the unique values from the test function as keys, which can be used to get the array of elements in each group.

Instance propertiesThese properties are defined on Map.prototype and shared by all Map instances.

Map.prototype.constructor

The constructor function that created the instance object. For Map instances, the initial value is the Map constructor.

Map.prototype.size

Returns the number of key/value pairs in the Map object.

Map.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Map". This property is used in Object.prototype.toString().

Instance methods
Map.prototype.clear()

Removes all key-value pairs from the Map object.

Map.prototype.delete()

Returns true if an element in the Map object existed and has been
removed, or false if the element does not exist. map.has(key)
will return false afterwards.

Map.prototype.entries()

Returns a new Iterator object that contains a two-member array of [key, value] for each element in the Map object in insertion order.

Map.prototype.forEach()

Calls callbackFn once for each key-value pair present in the Map object, in insertion order. If a thisArg parameter is provided to forEach, it will be used as the this value for each callback.

Map.prototype.get()

Returns the value associated to the passed key, or undefined if there is none.

Map.prototype.has()

Returns a boolean indicating whether a value has been associated with the passed key in the Map object or not.

Map.prototype.keys()

Returns a new Iterator object that contains the keys for each element in the Map object in insertion order.

Map.prototype.set()

Sets the value for the passed key in the Map object. Returns the Map object.

Map.prototype.values()

Returns a new Iterator object that contains the values for each element in the Map object in insertion order.

Map.prototype[Symbol.iterator]()

Returns a new Iterator object that contains a two-member array of [key, value] for each element in the Map object in insertion order.

ExamplesUsing the Map objectjsconst myMap = new Map();

const keyString = "a string";
const keyObj = {};
const keyFunc = function () {};

// setting the values
myMap.set(keyString, "value associated with 'a string'");
myMap.set(keyObj, "value associated with keyObj");
myMap.set(keyFunc, "value associated with keyFunc");

console.log(myMap.size); // 3

// getting the values
console.log(myMap.get(keyString)); // "value associated with 'a string'"
console.log(myMap.get(keyObj)); // "value associated with keyObj"
console.log(myMap.get(keyFunc)); // "value associated with keyFunc"

console.log(myMap.get("a string")); // "value associated with 'a string'", because keyString === 'a string'
console.log(myMap.get({})); // undefined, because keyObj !== {}
console.log(myMap.get(function () {})); // undefined, because keyFunc !== function () {}
Using NaN as Map keysNaN can also be used as a key. Even though every NaN is
not equal to itself (NaN !== NaN is true), the following example works because
NaNs are indistinguishable from each other:
jsconst myMap = new Map();
myMap.set(NaN, "not a number");

myMap.get(NaN);
// "not a number"

const otherNaN = Number("foo");
myMap.get(otherNaN);
// "not a number"
Iterating Map with for...ofMaps can be iterated using a for...of loop:
jsconst myMap = new Map();
myMap.set(0, "zero");
myMap.set(1, "one");

for (const [key, value] of myMap) {
  console.log(`${key} = ${value}`);
}
// 0 = zero
// 1 = one

for (const key of myMap.keys()) {
  console.log(key);
}
// 0
// 1

for (const value of myMap.values()) {
  console.log(value);
}
// zero
// one

for (const [key, value] of myMap.entries()) {
  console.log(`${key} = ${value}`);
}
// 0 = zero
// 1 = one
Iterating Map with forEach()Maps can be iterated using the
forEach() method:
jsmyMap.forEach((value, key) => {
  console.log(`${key} = ${value}`);
});
// 0 = zero
// 1 = one
Relation with Array objectsjsconst kvArray = [
  ["key1", "value1"],
  ["key2", "value2"],
];

// Use the regular Map constructor to transform a 2D key-value Array into a map
const myMap = new Map(kvArray);

console.log(myMap.get("key1")); // "value1"

// Use Array.from() to transform a map into a 2D key-value Array
console.log(Array.from(myMap)); // Will show you exactly the same Array as kvArray

// A succinct way to do the same, using the spread syntax
console.log([...myMap]);

// Or use the keys() or values() iterators, and convert them to an array
console.log(Array.from(myMap.keys())); // ["key1", "key2"]
Cloning and merging MapsJust like Arrays, Maps can be cloned:
jsconst original = new Map([[1, "one"]]);

const clone = new Map(original);

console.log(clone.get(1)); // one
console.log(original === clone); // false (useful for shallow comparison)


Note:
Keep in mind that the data itself is not cloned. In other words, it is only a shallow copy of the Map.

Maps can be merged, maintaining key uniqueness:
jsconst first = new Map([
  [1, "one"],
  [2, "two"],
  [3, "three"],
]);

const second = new Map([
  [1, "uno"],
  [2, "dos"],
]);

// Merge two maps. The last repeated key wins.
// Spread syntax essentially converts a Map to an Array
const merged = new Map([...first, ...second]);

console.log(merged.get(1)); // uno
console.log(merged.get(2)); // dos
console.log(merged.get(3)); // three

Maps can be merged with Arrays, too:
jsconst first = new Map([
  [1, "one"],
  [2, "two"],
  [3, "three"],
]);

const second = new Map([
  [1, "uno"],
  [2, "dos"],
]);

// Merge maps with an array. The last repeated key wins.
const merged = new Map([...first, ...second, [1, "un"]]);

console.log(merged.get(1)); // un
console.log(merged.get(2)); // dos
console.log(merged.get(3)); // three
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-map-objectsBrowser compatibilitySee also
Polyfill for Map in core-js
es-shims polyfill of Map
Set
WeakMap
WeakSet\n\nMapBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Map object holds key-value pairs and remembers the original insertion order of the keys.
Any value (both objects and primitive values) may be used as either a key or a value.Try it
const map1 = new Map();

map1.set("a", 1);
map1.set("b", 2);
map1.set("c", 3);

console.log(map1.get("a"));
// Expected output: 1

map1.set("a", 97);

console.log(map1.get("a"));
// Expected output: 97

console.log(map1.size);
// Expected output: 3

map1.delete("b");

console.log(map1.size);
// Expected output: 2
DescriptionMap objects are collections of key-value pairs. A key in the Map may only occur once; it is unique in the Map's collection. A Map object is iterated by key-value pairs — a for...of loop returns a 2-member array of [key, value] for each iteration. Iteration happens in insertion order, which corresponds to the order in which each key-value pair was first inserted into the map by the set() method (that is, there wasn't a key with the same value already in the map when set() was called).
The specification requires maps to be implemented "that, on average, provide access times that are sublinear on the number of elements in the collection". Therefore, it could be represented internally as a hash table (with O(1) lookup), a search tree (with O(log(N)) lookup), or any other data structure, as long as the complexity is better than O(N).Key equalityValue equality is based on the SameValueZero algorithm. (It used to use SameValue, which treated 0 and -0 as different. Check browser compatibility.) This means NaN is considered the same as NaN (even though NaN !== NaN) and all other values are considered equal according to the semantics of the === operator.Objects vs. MapsObject is similar to Map—both let you set keys to
values, retrieve those values, delete keys, and detect whether something is
stored at a key. For this reason (and because there were no built-in
alternatives), Object has been used as Map historically.
However, there are important differences that make Map preferable in some
cases:

  
    
      
      Map
      Object
    
  
  
    
      Accidental Keys
      
        A Map does not contain any keys by default. It only
        contains what is explicitly put into it.
      
      
        
          An Object has a prototype, so it contains default keys
          that could collide with your own keys if you're not careful.
        
        
          
            Note: This can be bypassed by using
            Object.create(null),
            but this is seldom done.
          
        
      
    
    
      Security
      
        A Map is safe to use with user-provided keys and values.
      
      
        
          Setting user-provided key-value pairs on an Object may allow
          an attacker to override the object's prototype, which can lead to
          
            object injection attacks
          . Like the accidental keys issue, this can also be mitigated by using
          a null-prototype object.
        
      
    
    
      Key Types
      
        A Map's keys can be any value (including functions,
        objects, or any primitive).
      
      
        The keys of an Object must be either a
        String or a Symbol.
      
    
    
      Key Order
      
        
          The keys in Map are ordered in a straightforward
          way: A Map object iterates entries, keys, and values in
          the order of entry insertion.
        
      
      
        
          Although the keys of an ordinary Object are ordered now,
          this was not always the case, and the order is complex. As a result,
          it's best not to rely on property order.
        
        
          The order was first defined for own properties only in ECMAScript
          2015; ECMAScript 2020 defines order for inherited properties as well.
          But note that no single mechanism
          iterates
          all of an object's properties; the various mechanisms
          each include different subsets of properties.
          (for-in
          includes only enumerable string-keyed properties;
          Object.keys includes only own, enumerable,
          string-keyed properties;
          Object.getOwnPropertyNames includes own,
          string-keyed properties even if non-enumerable;
          Object.getOwnPropertySymbols does the same
          for just Symbol-keyed properties, etc.)
        
      
    
    
      Size
      
        The number of items in a Map is easily retrieved from its
        size property.
      
      
        Determining the number of items in an Object is more roundabout and less efficient. A common way to do it is through the length of the array returned from Object.keys().
      
    
    
      Iteration
      
        A Map is an
        iterable, so it can be directly iterated.
      
      
        
          Object does not implement an iteration protocol, and so objects are not directly iterable using the JavaScript
          for...of
          statement (by default).
        
        
          Note:
          
            
              An object can implement the iteration protocol, or you can get an
              iterable for an object using Object.keys or Object.entries.
            
            
              The
              for...in
              statement allows you to iterate over the
              enumerable properties of an object.
            
          
        
      
    
    
      Performance
      
        
          Performs better in scenarios involving frequent additions and removals
          of key-value pairs.
        
      
      
        
          Not optimized for frequent additions and removals of key-value pairs.
        
      
    
    
      Serialization and parsing
      
        No native support for serialization or parsing.
        
          (But you can build your own serialization and parsing support for
          Map by using JSON.stringify()
          with its replacer argument, and by using
          JSON.parse() with its
          reviver argument. See the Stack Overflow question
          How do you JSON.stringify an ES6 Map?).
        
      
      
        
          Native support for serialization from Object to
          JSON, using JSON.stringify().
        
        
          Native support for parsing from JSON to Object,
          using JSON.parse().
        
      
    
  
Setting object propertiesSetting Object properties works for Map objects as well, and can cause
considerable confusion.
Therefore, this appears to work in a way:
jsconst wrongMap = new Map();
wrongMap["bla"] = "blaa";
wrongMap["bla2"] = "blaaa2";

console.log(wrongMap); // Map { bla: 'blaa', bla2: 'blaaa2' }

But that way of setting a property does not interact with the Map data
structure. It uses the feature of the generic object. The value of 'bla' is not
stored in the Map for queries. Other operations on the data fail:
jswrongMap.has("bla"); // false
wrongMap.delete("bla"); // false
console.log(wrongMap); // Map { bla: 'blaa', bla2: 'blaaa2' }

The correct usage for storing data in the Map is through the set(key, value)
method.
jsconst contacts = new Map();
contacts.set("Jessie", { phone: "213-555-1234", address: "123 N 1st Ave" });
contacts.has("Jessie"); // true
contacts.get("Hilary"); // undefined
contacts.set("Hilary", { phone: "617-555-4321", address: "321 S 2nd St" });
contacts.get("Jessie"); // {phone: "213-555-1234", address: "123 N 1st Ave"}
contacts.delete("Raymond"); // false
contacts.delete("Jessie"); // true
console.log(contacts.size); // 1
Map-like browser APIsBrowser Map-like objects (or "maplike objects") are Web API interfaces that behave in many ways like a Map.
Just like Map, entries can be iterated in the same order that they were added to the object.
Map-like objects and Map also have properties and methods that share the same name and behavior.
However unlike Map they only allow specific predefined types for the keys and values of each entry.
The allowed types are set in the specification IDL definition.
For example, RTCStatsReport is a Map-like object that must use strings for keys and objects for values.
This is defined in the specification IDL below:
webidlinterface RTCStatsReport {
  readonly maplike<DOMString, object>;
};

Map-like objects are either read-only or read-writable (see the readonly keyword in the IDL above).

Read-only Map-like objects have the property size, and the methods: entries(), forEach(), get(), has(), keys(), values(), and Symbol.iterator().
Writeable Map-like objects additionally have the methods: clear(), delete(), and set().

The methods and properties have the same behavior as the equivalent entities in Map, except for the restriction on the types of the keys and values.
The following are examples of read-only Map-like browser objects:

AudioParamMap
RTCStatsReport
EventCounts
KeyboardLayoutMap
MIDIInputMap
MIDIOutputMap
Constructor
Map()

Creates a new Map object.

Static properties
Map[Symbol.species]

The constructor function that is used to create derived objects.

Static methods
Map.groupBy()

Groups the elements of a given iterable using the values returned by a provided callback function. The final returned Map uses the unique values from the test function as keys, which can be used to get the array of elements in each group.

Instance propertiesThese properties are defined on Map.prototype and shared by all Map instances.

Map.prototype.constructor

The constructor function that created the instance object. For Map instances, the initial value is the Map constructor.

Map.prototype.size

Returns the number of key/value pairs in the Map object.

Map.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Map". This property is used in Object.prototype.toString().

Instance methods
Map.prototype.clear()

Removes all key-value pairs from the Map object.

Map.prototype.delete()

Returns true if an element in the Map object existed and has been
removed, or false if the element does not exist. map.has(key)
will return false afterwards.

Map.prototype.entries()

Returns a new Iterator object that contains a two-member array of [key, value] for each element in the Map object in insertion order.

Map.prototype.forEach()

Calls callbackFn once for each key-value pair present in the Map object, in insertion order. If a thisArg parameter is provided to forEach, it will be used as the this value for each callback.

Map.prototype.get()

Returns the value associated to the passed key, or undefined if there is none.

Map.prototype.has()

Returns a boolean indicating whether a value has been associated with the passed key in the Map object or not.

Map.prototype.keys()

Returns a new Iterator object that contains the keys for each element in the Map object in insertion order.

Map.prototype.set()

Sets the value for the passed key in the Map object. Returns the Map object.

Map.prototype.values()

Returns a new Iterator object that contains the values for each element in the Map object in insertion order.

Map.prototype[Symbol.iterator]()

Returns a new Iterator object that contains a two-member array of [key, value] for each element in the Map object in insertion order.

ExamplesUsing the Map objectjsconst myMap = new Map();

const keyString = "a string";
const keyObj = {};
const keyFunc = function () {};

// setting the values
myMap.set(keyString, "value associated with 'a string'");
myMap.set(keyObj, "value associated with keyObj");
myMap.set(keyFunc, "value associated with keyFunc");

console.log(myMap.size); // 3

// getting the values
console.log(myMap.get(keyString)); // "value associated with 'a string'"
console.log(myMap.get(keyObj)); // "value associated with keyObj"
console.log(myMap.get(keyFunc)); // "value associated with keyFunc"

console.log(myMap.get("a string")); // "value associated with 'a string'", because keyString === 'a string'
console.log(myMap.get({})); // undefined, because keyObj !== {}
console.log(myMap.get(function () {})); // undefined, because keyFunc !== function () {}
Using NaN as Map keysNaN can also be used as a key. Even though every NaN is
not equal to itself (NaN !== NaN is true), the following example works because
NaNs are indistinguishable from each other:
jsconst myMap = new Map();
myMap.set(NaN, "not a number");

myMap.get(NaN);
// "not a number"

const otherNaN = Number("foo");
myMap.get(otherNaN);
// "not a number"
Iterating Map with for...ofMaps can be iterated using a for...of loop:
jsconst myMap = new Map();
myMap.set(0, "zero");
myMap.set(1, "one");

for (const [key, value] of myMap) {
  console.log(`${key} = ${value}`);
}
// 0 = zero
// 1 = one

for (const key of myMap.keys()) {
  console.log(key);
}
// 0
// 1

for (const value of myMap.values()) {
  console.log(value);
}
// zero
// one

for (const [key, value] of myMap.entries()) {
  console.log(`${key} = ${value}`);
}
// 0 = zero
// 1 = one
Iterating Map with forEach()Maps can be iterated using the
forEach() method:
jsmyMap.forEach((value, key) => {
  console.log(`${key} = ${value}`);
});
// 0 = zero
// 1 = one
Relation with Array objectsjsconst kvArray = [
  ["key1", "value1"],
  ["key2", "value2"],
];

// Use the regular Map constructor to transform a 2D key-value Array into a map
const myMap = new Map(kvArray);

console.log(myMap.get("key1")); // "value1"

// Use Array.from() to transform a map into a 2D key-value Array
console.log(Array.from(myMap)); // Will show you exactly the same Array as kvArray

// A succinct way to do the same, using the spread syntax
console.log([...myMap]);

// Or use the keys() or values() iterators, and convert them to an array
console.log(Array.from(myMap.keys())); // ["key1", "key2"]
Cloning and merging MapsJust like Arrays, Maps can be cloned:
jsconst original = new Map([[1, "one"]]);

const clone = new Map(original);

console.log(clone.get(1)); // one
console.log(original === clone); // false (useful for shallow comparison)


Note:
Keep in mind that the data itself is not cloned. In other words, it is only a shallow copy of the Map.

Maps can be merged, maintaining key uniqueness:
jsconst first = new Map([
  [1, "one"],
  [2, "two"],
  [3, "three"],
]);

const second = new Map([
  [1, "uno"],
  [2, "dos"],
]);

// Merge two maps. The last repeated key wins.
// Spread syntax essentially converts a Map to an Array
const merged = new Map([...first, ...second]);

console.log(merged.get(1)); // uno
console.log(merged.get(2)); // dos
console.log(merged.get(3)); // three

Maps can be merged with Arrays, too:
jsconst first = new Map([
  [1, "one"],
  [2, "two"],
  [3, "three"],
]);

const second = new Map([
  [1, "uno"],
  [2, "dos"],
]);

// Merge maps with an array. The last repeated key wins.
const merged = new Map([...first, ...second, [1, "un"]]);

console.log(merged.get(1)); // un
console.log(merged.get(2)); // dos
console.log(merged.get(3)); // three
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-map-objectsBrowser compatibilitySee also
Polyfill for Map in core-js
es-shims polyfill of Map
Set
WeakMap
WeakSet
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 2, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nMapBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Map object holds key-value pairs and remembers the original insertion order of the keys.
Any value (both objects and primitive values) may be used as either a key or a value.Try it
const map1 = new Map();

map1.set("a", 1);
map1.set("b", 2);
map1.set("c", 3);

console.log(map1.get("a"));
// Expected output: 1

map1.set("a", 97);

console.log(map1.get("a"));
// Expected output: 97

console.log(map1.size);
// Expected output: 3

map1.delete("b");

console.log(map1.size);
// Expected output: 2
DescriptionMap objects are collections of key-value pairs. A key in the Map may only occur once; it is unique in the Map's collection. A Map object is iterated by key-value pairs — a for...of loop returns a 2-member array of [key, value] for each iteration. Iteration happens in insertion order, which corresponds to the order in which each key-value pair was first inserted into the map by the set() method (that is, there wasn't a key with the same value already in the map when set() was called).
The specification requires maps to be implemented "that, on average, provide access times that are sublinear on the number of elements in the collection". Therefore, it could be represented internally as a hash table (with O(1) lookup), a search tree (with O(log(N)) lookup), or any other data structure, as long as the complexity is better than O(N).Key equalityValue equality is based on the SameValueZero algorithm. (It used to use SameValue, which treated 0 and -0 as different. Check browser compatibility.) This means NaN is considered the same as NaN (even though NaN !== NaN) and all other values are considered equal according to the semantics of the === operator.Objects vs. MapsObject is similar to Map—both let you set keys to
values, retrieve those values, delete keys, and detect whether something is
stored at a key. For this reason (and because there were no built-in
alternatives), Object has been used as Map historically.
However, there are important differences that make Map preferable in some
cases:

  
    
      
      Map
      Object
    
  
  
    
      Accidental Keys
      
        A Map does not contain any keys by default. It only
        contains what is explicitly put into it.
      
      
        
          An Object has a prototype, so it contains default keys
          that could collide with your own keys if you're not careful.
        
        
          
            Note: This can be bypassed by using
            Object.create(null),
            but this is seldom done.
          
        
      
    
    
      Security
      
        A Map is safe to use with user-provided keys and values.
      
      
        
          Setting user-provided key-value pairs on an Object may allow
          an attacker to override the object's prototype, which can lead to
          
            object injection attacks
          . Like the accidental keys issue, this can also be mitigated by using
          a null-prototype object.
        
      
    
    
      Key Types
      
        A Map's keys can be any value (including functions,
        objects, or any primitive).
      
      
        The keys of an Object must be either a
        String or a Symbol.
      
    
    
      Key Order
      
        
          The keys in Map are ordered in a straightforward
          way: A Map object iterates entries, keys, and values in
          the order of entry insertion.
        
      
      
        
          Although the keys of an ordinary Object are ordered now,
          this was not always the case, and the order is complex. As a result,
          it's best not to rely on property order.
        
        
          The order was first defined for own properties only in ECMAScript
          2015; ECMAScript 2020 defines order for inherited properties as well.
          But note that no single mechanism
          iterates
          all of an object's properties; the various mechanisms
          each include different subsets of properties.
          (for-in
          includes only enumerable string-keyed properties;
          Object.keys includes only own, enumerable,
          string-keyed properties;
          Object.getOwnPropertyNames includes own,
          string-keyed properties even if non-enumerable;
          Object.getOwnPropertySymbols does the same
          for just Symbol-keyed properties, etc.)
        
      
    
    
      Size
      
        The number of items in a Map is easily retrieved from its
        size property.
      
      
        Determining the number of items in an Object is more roundabout and less efficient. A common way to do it is through the length of the array returned from Object.keys().
      
    
    
      Iteration
      
        A Map is an
        iterable, so it can be directly iterated.
      
      
        
          Object does not implement an iteration protocol, and so objects are not directly iterable using the JavaScript
          for...of
          statement (by default).
        
        
          Note:
          
            
              An object can implement the iteration protocol, or you can get an
              iterable for an object using Object.keys or Object.entries.
            
            
              The
              for...in
              statement allows you to iterate over the
              enumerable properties of an object.
            
          
        
      
    
    
      Performance
      
        
          Performs better in scenarios involving frequent additions and removals
          of key-value pairs.
        
      
      
        
          Not optimized for frequent additions and removals of key-value pairs.
        
      
    
    
      Serialization and parsing
      
        No native support for serialization or parsing.
        
          (But you can build your own serialization and parsing support for
          Map by using JSON.stringify()
          with its replacer argument, and by using
          JSON.parse() with its
          reviver argument. See the Stack Overflow question
          How do you JSON.stringify an ES6 Map?).
        
      
      
        
          Native support for serialization from Object to
          JSON, using JSON.stringify().
        
        
          Native support for parsing from JSON to Object,
          using JSON.parse().
        
      
    
  
Setting object propertiesSetting Object properties works for Map objects as well, and can cause
considerable confusion.
Therefore, this appears to work in a way:
jsconst wrongMap = new Map();
wrongMap["bla"] = "blaa";
wrongMap["bla2"] = "blaaa2";

console.log(wrongMap); // Map { bla: 'blaa', bla2: 'blaaa2' }

But that way of setting a property does not interact with the Map data
structure. It uses the feature of the generic object. The value of 'bla' is not
stored in the Map for queries. Other operations on the data fail:
jswrongMap.has("bla"); // false
wrongMap.delete("bla"); // false
console.log(wrongMap); // Map { bla: 'blaa', bla2: 'blaaa2' }

The correct usage for storing data in the Map is through the set(key, value)
method.
jsconst contacts = new Map();
contacts.set("Jessie", { phone: "213-555-1234", address: "123 N 1st Ave" });
contacts.has("Jessie"); // true
contacts.get("Hilary"); // undefined
contacts.set("Hilary", { phone: "617-555-4321", address: "321 S 2nd St" });
contacts.get("Jessie"); // {phone: "213-555-1234", address: "123 N 1st Ave"}
contacts.delete("Raymond"); // false
contacts.delete("Jessie"); // true
console.log(contacts.size); // 1
Map-like browser APIsBrowser Map-like objects (or "maplike objects") are Web API interfaces that behave in many ways like a Map.
Just like Map, entries can be iterated in the same order that they were added to the object.
Map-like objects and Map also have properties and methods that share the same name and behavior.
However unlike Map they only allow specific predefined types for the keys and values of each entry.
The allowed types are set in the specification IDL definition.
For example, RTCStatsReport is a Map-like object that must use strings for keys and objects for values.
This is defined in the specification IDL below:
webidlinterface RTCStatsReport {
  readonly maplike<DOMString, object>;
};

Map-like objects are either read-only or read-writable (see the readonly keyword in the IDL above).

Read-only Map-like objects have the property size, and the methods: entries(), forEach(), get(), has(), keys(), values(), and Symbol.iterator().
Writeable Map-like objects additionally have the methods: clear(), delete(), and set().

The methods and properties have the same behavior as the equivalent entities in Map, except for the restriction on the types of the keys and values.
The following are examples of read-only Map-like browser objects:

AudioParamMap
RTCStatsReport
EventCounts
KeyboardLayoutMap
MIDIInputMap
MIDIOutputMap
Constructor
Map()

Creates a new Map object.

Static properties
Map[Symbol.species]

The constructor function that is used to create derived objects.

Static methods
Map.groupBy()

Groups the elements of a given iterable using the values returned by a provided callback function. The final returned Map uses the unique values from the test function as keys, which can be used to get the array of elements in each group.

Instance propertiesThese properties are defined on Map.prototype and shared by all Map instances.

Map.prototype.constructor

The constructor function that created the instance object. For Map instances, the initial value is the Map constructor.

Map.prototype.size

Returns the number of key/value pairs in the Map object.

Map.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Map". This property is used in Object.prototype.toString().

Instance methods
Map.prototype.clear()

Removes all key-value pairs from the Map object.

Map.prototype.delete()

Returns true if an element in the Map object existed and has been
removed, or false if the element does not exist. map.has(key)
will return false afterwards.

Map.prototype.entries()

Returns a new Iterator object that contains a two-member array of [key, value] for each element in the Map object in insertion order.

Map.prototype.forEach()

Calls callbackFn once for each key-value pair present in the Map object, in insertion order. If a thisArg parameter is provided to forEach, it will be used as the this value for each callback.

Map.prototype.get()

Returns the value associated to the passed key, or undefined if there is none.

Map.prototype.has()

Returns a boolean indicating whether a value has been associated with the passed key in the Map object or not.

Map.prototype.keys()

Returns a new Iterator object that contains the keys for each element in the Map object in insertion order.

Map.prototype.set()

Sets the value for the passed key in the Map object. Returns the Map object.

Map.prototype.values()

Returns a new Iterator object that contains the values for each element in the Map object in insertion order.

Map.prototype[Symbol.iterator]()

Returns a new Iterator object that contains a two-member array of [key, value] for each element in the Map object in insertion order.

ExamplesUsing the Map objectjsconst myMap = new Map();

const keyString = "a string";
const keyObj = {};
const keyFunc = function () {};

// setting the values
myMap.set(keyString, "value associated with 'a string'");
myMap.set(keyObj, "value associated with keyObj");
myMap.set(keyFunc, "value associated with keyFunc");

console.log(myMap.size); // 3

// getting the values
console.log(myMap.get(keyString)); // "value associated with 'a string'"
console.log(myMap.get(keyObj)); // "value associated with keyObj"
console.log(myMap.get(keyFunc)); // "value associated with keyFunc"

console.log(myMap.get("a string")); // "value associated with 'a string'", because keyString === 'a string'
console.log(myMap.get({})); // undefined, because keyObj !== {}
console.log(myMap.get(function () {})); // undefined, because keyFunc !== function () {}
Using NaN as Map keysNaN can also be used as a key. Even though every NaN is
not equal to itself (NaN !== NaN is true), the following example works because
NaNs are indistinguishable from each other:
jsconst myMap = new Map();
myMap.set(NaN, "not a number");

myMap.get(NaN);
// "not a number"

const otherNaN = Number("foo");
myMap.get(otherNaN);
// "not a number"
Iterating Map with for...ofMaps can be iterated using a for...of loop:
jsconst myMap = new Map();
myMap.set(0, "zero");
myMap.set(1, "one");

for (const [key, value] of myMap) {
  console.log(`${key} = ${value}`);
}
// 0 = zero
// 1 = one

for (const key of myMap.keys()) {
  console.log(key);
}
// 0
// 1

for (const value of myMap.values()) {
  console.log(value);
}
// zero
// one

for (const [key, value] of myMap.entries()) {
  console.log(`${key} = ${value}`);
}
// 0 = zero
// 1 = one
Iterating Map with forEach()Maps can be iterated using the
forEach() method:
jsmyMap.forEach((value, key) => {
  console.log(`${key} = ${value}`);
});
// 0 = zero
// 1 = one
Relation with Array objectsjsconst kvArray = [
  ["key1", "value1"],
  ["key2", "value2"],
];

// Use the regular Map constructor to transform a 2D key-value Array into a map
const myMap = new Map(kvArray);

console.log(myMap.get("key1")); // "value1"

// Use Array.from() to transform a map into a 2D key-value Array
console.log(Array.from(myMap)); // Will show you exactly the same Array as kvArray

// A succinct way to do the same, using the spread syntax
console.log([...myMap]);

// Or use the keys() or values() iterators, and convert them to an array
console.log(Array.from(myMap.keys())); // ["key1", "key2"]
Cloning and merging MapsJust like Arrays, Maps can be cloned:
jsconst original = new Map([[1, "one"]]);

const clone = new Map(original);

console.log(clone.get(1)); // one
console.log(original === clone); // false (useful for shallow comparison)


Note:
Keep in mind that the data itself is not cloned. In other words, it is only a shallow copy of the Map.

Maps can be merged, maintaining key uniqueness:
jsconst first = new Map([
  [1, "one"],
  [2, "two"],
  [3, "three"],
]);

const second = new Map([
  [1, "uno"],
  [2, "dos"],
]);

// Merge two maps. The last repeated key wins.
// Spread syntax essentially converts a Map to an Array
const merged = new Map([...first, ...second]);

console.log(merged.get(1)); // uno
console.log(merged.get(2)); // dos
console.log(merged.get(3)); // three

Maps can be merged with Arrays, too:
jsconst first = new Map([
  [1, "one"],
  [2, "two"],
  [3, "three"],
]);

const second = new Map([
  [1, "uno"],
  [2, "dos"],
]);

// Merge maps with an array. The last repeated key wins.
const merged = new Map([...first, ...second, [1, "un"]]);

console.log(merged.get(1)); // un
console.log(merged.get(2)); // dos
console.log(merged.get(3)); // three
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-map-objectsBrowser compatibilitySee also
Polyfill for Map in core-js
es-shims polyfill of Map
Set
WeakMap
WeakSet
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 2, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nSetBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Set object lets you store unique values of any type, whether primitive values or object references.DescriptionSet objects are collections of values. A value in the set may only occur once; it is unique in the set's collection. You can iterate through the elements of a set in insertion order. The insertion order corresponds to the order in which each element was inserted into the set by the add() method successfully (that is, there wasn't an identical element already in the set when add() was called).
The specification requires sets to be implemented "that, on average, provide access times that are sublinear on the number of elements in the collection". Therefore, it could be represented internally as a hash table (with O(1) lookup), a search tree (with O(log(N)) lookup), or any other data structure, as long as the complexity is better than O(N).Value equalityValue equality is based on the SameValueZero algorithm. (It used to use SameValue, which treated 0 and -0 as different. Check browser compatibility.) This means NaN is considered the same as NaN (even though NaN !== NaN) and all other values are considered equal according to the semantics of the === operator.PerformanceThe has method checks if a value is in the set, using an approach that is, on average, quicker than testing most of the elements that have previously been added to the set. In particular, it is, on average, faster than the Array.prototype.includes method when an array has a length equal to a set's size.Set compositionThe Set object provides some methods that allow you to compose sets like you would with mathematical operations. These methods include:

  
    
      Method
      Return type
      Mathematical equivalent
      Venn diagram
    
  
  
    
      A.difference(B)
      Set
      
        A∖BA etminus B
      
      
    
    
      A.intersection(B)
      Set
      
        A∩BA\cap B
      
      
    
    
      A.symmetricDifference(B)
      Set
      
        (A∖B)∪(B∖A)(A etminus B)\cup(B etminus A)
      
      
    
    
      A.union(B)
      Set
      
        A∪BA\cup B
      
      
    
    
      A.isDisjointFrom(B)
      Boolean
      
        A∩B=∅A\cap B = \empty
      
      
    
    
      A.isSubsetOf(B)
      Boolean
      
        A⊆BA ubseteq B
      
      
    
    
      A.isSupersetOf(B)
      Boolean
      
        A⊇BA upseteq B
      
      
    
  

To make them more generalizable, these methods don't just accept Set objects, but anything that's set-like.Set-like objectsAll set composition methods require this to be an actual Set instance, but their arguments just need to be set-like. A set-like object is an object that provides the following:

A size property that contains a number.
A has() method that takes an element and returns a boolean.
A keys() method that returns an iterator of the elements in the set.

For example, Map objects are set-like because they also have size, has(), and keys(), so they behave just like sets of keys when used in set methods:
jsconst a = new Set([1, 2, 3]);
const b = new Map([
  [1, "one"],
  [2, "two"],
  [4, "four"],
]);
console.log(a.union(b)); // Set(4) {1, 2, 3, 4}


Note:
The set-like protocol invokes the keys() method instead of [Symbol.iterator]() to produce elements. This is to make maps valid set-like objects, because for maps, the iterator produces entries but the has() method takes keys.

Arrays are not set-like because they don't have a has() method or the size property, and their keys() method produces indices instead of elements. WeakSet objects are also not set-like because they don't have a keys() method.Set-like browser APIsBrowser Set-like objects (or "setlike objects") are Web API interfaces that behave in many ways like a Set.
Just like Set, elements can be iterated in the same order that they were added to the object.
Set-like objects and Set also have properties and methods that share the same name and behavior.
However unlike Set they only allow a specific predefined type for each entry.
The allowed types are set in the specification IDL definition.
For example, GPUSupportedFeatures is a Set-like object that must use strings as the key/value.
This is defined in the specification IDL below:
webidlinterface GPUSupportedFeatures {
  readonly setlike<DOMString>;
};

Set-like objects are either read-only or read-writable (see the readonly keyword in the IDL above).

Read-only Set-like objects have the property size, and the methods: entries(), forEach(), has(), keys(), values(), and Symbol.iterator().
Writeable Set-like objects additionally have the methods: clear(), delete(), and add().

The methods and properties have the same behavior as the equivalent entities in Set, except for the restriction on the types of the entry.
The following are examples of read-only Set-like browser objects:

GPUSupportedFeatures
XRAnchorSet

The following are examples of writable Set-like browser objects:

CustomStateSet
FontFaceSet
Highlight
Constructor
Set()

Creates a new Set object.

Static properties
Set[Symbol.species]

The constructor function that is used to create derived objects.

Instance propertiesThese properties are defined on Set.prototype and shared by all Set instances.

Set.prototype.constructor

The constructor function that created the instance object. For Set instances, the initial value is the Set constructor.

Set.prototype.size

Returns the number of values in the Set object.

Set.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Set". This property is used in Object.prototype.toString().

Instance methods
Set.prototype.add()

Inserts a new element with a specified value in to a Set object, if there isn't an element with the same value already in the Set.

Set.prototype.clear()

Removes all elements from the Set object.

Set.prototype.delete()

Removes the element associated to the value and returns a boolean asserting whether an element was successfully removed or not. Set.prototype.has(value) will return false afterwards.

Set.prototype.difference()

Takes a set and returns a new set containing elements in this set but not in the given set.

Set.prototype.entries()

Returns a new iterator object that contains an array of [value, value] for each element in the Set object, in insertion order. This is similar to the Map object, so that each entry's key is the same as its value for a Set.

Set.prototype.forEach()

Calls callbackFn once for each value present in the Set object, in insertion order. If a thisArg parameter is provided, it will be used as the this value for each invocation of callbackFn.

Set.prototype.has()

Returns a boolean asserting whether an element is present with the given value in the Set object or not.

Set.prototype.intersection()

Takes a set and returns a new set containing elements in both this set and the given set.

Set.prototype.isDisjointFrom()

Takes a set and returns a boolean indicating if this set has no elements in common with the given set.

Set.prototype.isSubsetOf()

Takes a set and returns a boolean indicating if all elements of this set are in the given set.

Set.prototype.isSupersetOf()

Takes a set and returns a boolean indicating if all elements of the given set are in this set.

Set.prototype.keys()

An alias for Set.prototype.values().

Set.prototype.symmetricDifference()

Takes a set and returns a new set containing elements which are in either this set or the given set, but not in both.

Set.prototype.union()

Takes a set and returns a new set containing elements which are in either or both of this set and the given set.

Set.prototype.values()

Returns a new iterator object that yields the values for each element in the Set object in insertion order.

Set.prototype[Symbol.iterator]()

Returns a new iterator object that yields the values for each element in the Set object in insertion order.

ExamplesUsing the Set objectjsconst mySet1 = new Set();

mySet1.add(1); // Set(1) { 1 }
mySet1.add(5); // Set(2) { 1, 5 }
mySet1.add(5); // Set(2) { 1, 5 }
mySet1.add("some text"); // Set(3) { 1, 5, 'some text' }
const o = { a: 1, b: 2 };
mySet1.add(o);

mySet1.add({ a: 1, b: 2 }); // o is referencing a different object, so this is okay

mySet1.has(1); // true
mySet1.has(3); // false, since 3 has not been added to the set
mySet1.has(5); // true
mySet1.has(Math.sqrt(25)); // true
mySet1.has("Some Text".toLowerCase()); // true
mySet1.has(o); // true

mySet1.size; // 5

mySet1.delete(5); // removes 5 from the set
mySet1.has(5); // false, 5 has been removed

mySet1.size; // 4, since we just removed one value

mySet1.add(5); // Set(5) { 1, 'some text', {...}, {...}, 5 } - a previously deleted item will be added as a new item, it will not retain its original position before deletion

console.log(mySet1); // Set(5) { 1, "some text", {…}, {…}, 5 }
Iterating setsThe iteration over a set visits elements in insertion order.
jsfor (const item of mySet1) {
  console.log(item);
}
// 1, "some text", { "a": 1, "b": 2 }, { "a": 1, "b": 2 }, 5

for (const item of mySet1.keys()) {
  console.log(item);
}
// 1, "some text", { "a": 1, "b": 2 }, { "a": 1, "b": 2 }, 5

for (const item of mySet1.values()) {
  console.log(item);
}
// 1, "some text", { "a": 1, "b": 2 }, { "a": 1, "b": 2 }, 5

// key and value are the same here
for (const [key, value] of mySet1.entries()) {
  console.log(key);
}
// 1, "some text", { "a": 1, "b": 2 }, { "a": 1, "b": 2 }, 5

// Convert Set object to an Array object, with Array.from
const myArr = Array.from(mySet1); // [1, "some text", {"a": 1, "b": 2}, {"a": 1, "b": 2}, 5]

// the following will also work if run in an HTML document
mySet1.add(document.body);
mySet1.has(document.querySelector("body")); // true

// converting between Set and Array
const mySet2 = new Set([1, 2, 3, 4]);
console.log(mySet2.size); // 4
console.log([...mySet2]); // [1, 2, 3, 4]

// intersect can be simulated via
const intersection = new Set([...mySet1].filter((x) => mySet2.has(x)));

// difference can be simulated via
const difference = new Set([...mySet1].filter((x) => !mySet2.has(x)));

// Iterate set entries with forEach()
mySet2.forEach((value) => {
  console.log(value);
});
// 1
// 2
// 3
// 4
Implementing basic set operationsjsfunction isSuperset(set, subset) {
  for (const elem of subset) {
    if (!set.has(elem)) {
      return false;
    }
  }
  return true;
}

function union(setA, setB) {
  const _union = new Set(setA);
  for (const elem of setB) {
    _union.add(elem);
  }
  return _union;
}

function intersection(setA, setB) {
  const _intersection = new Set();
  for (const elem of setB) {
    if (setA.has(elem)) {
      _intersection.add(elem);
    }
  }
  return _intersection;
}

function symmetricDifference(setA, setB) {
  const _difference = new Set(setA);
  for (const elem of setB) {
    if (_difference.has(elem)) {
      _difference.delete(elem);
    } else {
      _difference.add(elem);
    }
  }
  return _difference;
}

function difference(setA, setB) {
  const _difference = new Set(setA);
  for (const elem of setB) {
    _difference.delete(elem);
  }
  return _difference;
}

// Examples
const setA = new Set([1, 2, 3, 4]);
const setB = new Set([2, 3]);
const setC = new Set([3, 4, 5, 6]);

isSuperset(setA, setB); // returns true
union(setA, setC); // returns Set {1, 2, 3, 4, 5, 6}
intersection(setA, setC); // returns Set {3, 4}
symmetricDifference(setA, setC); // returns Set {1, 2, 5, 6}
difference(setA, setC); // returns Set {1, 2}
Relation to arraysjsconst myArray = ["value1", "value2", "value3"];

// Use the regular Set constructor to transform an Array into a Set
const mySet = new Set(myArray);

mySet.has("value1"); // returns true

// Use the spread syntax to transform a set into an Array.
console.log([...mySet]); // Will show you exactly the same Array as myArray
Remove duplicate elements from an arrayjs// Use to remove duplicate elements from an array
const numbers = [2, 13, 4, 4, 2, 13, 13, 4, 4, 5, 5, 6, 6, 7, 5, 32, 13, 4, 5];

console.log([...new Set(numbers)]); // [2, 13, 4, 5, 6, 7, 32]
Relation to stringsjs// Case sensitive (set will contain "F" and "f")
new Set("Firefox"); // Set(7) [ "F", "i", "r", "e", "f", "o", "x" ]

// Duplicate omission ("f" occurs twice in the string but set will contain only one)
new Set("firefox"); // Set(6) [ "f", "i", "r", "e", "o", "x" ]
Use a set to ensure the uniqueness of a list of valuesjsconst array = Array.from(document.querySelectorAll("[id]")).map((e) => e.id);

const set = new Set(array);
console.assert(set.size === array.length);
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-set-objectsBrowser compatibilitySee also
Polyfill of Set in core-js
es-shims polyfill of Set
Map
WeakMap
WeakSet\n\nSetBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Set object lets you store unique values of any type, whether primitive values or object references.DescriptionSet objects are collections of values. A value in the set may only occur once; it is unique in the set's collection. You can iterate through the elements of a set in insertion order. The insertion order corresponds to the order in which each element was inserted into the set by the add() method successfully (that is, there wasn't an identical element already in the set when add() was called).
The specification requires sets to be implemented "that, on average, provide access times that are sublinear on the number of elements in the collection". Therefore, it could be represented internally as a hash table (with O(1) lookup), a search tree (with O(log(N)) lookup), or any other data structure, as long as the complexity is better than O(N).Value equalityValue equality is based on the SameValueZero algorithm. (It used to use SameValue, which treated 0 and -0 as different. Check browser compatibility.) This means NaN is considered the same as NaN (even though NaN !== NaN) and all other values are considered equal according to the semantics of the === operator.PerformanceThe has method checks if a value is in the set, using an approach that is, on average, quicker than testing most of the elements that have previously been added to the set. In particular, it is, on average, faster than the Array.prototype.includes method when an array has a length equal to a set's size.Set compositionThe Set object provides some methods that allow you to compose sets like you would with mathematical operations. These methods include:

  
    
      Method
      Return type
      Mathematical equivalent
      Venn diagram
    
  
  
    
      A.difference(B)
      Set
      
        A∖BA etminus B
      
      
    
    
      A.intersection(B)
      Set
      
        A∩BA\cap B
      
      
    
    
      A.symmetricDifference(B)
      Set
      
        (A∖B)∪(B∖A)(A etminus B)\cup(B etminus A)
      
      
    
    
      A.union(B)
      Set
      
        A∪BA\cup B
      
      
    
    
      A.isDisjointFrom(B)
      Boolean
      
        A∩B=∅A\cap B = \empty
      
      
    
    
      A.isSubsetOf(B)
      Boolean
      
        A⊆BA ubseteq B
      
      
    
    
      A.isSupersetOf(B)
      Boolean
      
        A⊇BA upseteq B
      
      
    
  

To make them more generalizable, these methods don't just accept Set objects, but anything that's set-like.Set-like objectsAll set composition methods require this to be an actual Set instance, but their arguments just need to be set-like. A set-like object is an object that provides the following:

A size property that contains a number.
A has() method that takes an element and returns a boolean.
A keys() method that returns an iterator of the elements in the set.

For example, Map objects are set-like because they also have size, has(), and keys(), so they behave just like sets of keys when used in set methods:
jsconst a = new Set([1, 2, 3]);
const b = new Map([
  [1, "one"],
  [2, "two"],
  [4, "four"],
]);
console.log(a.union(b)); // Set(4) {1, 2, 3, 4}


Note:
The set-like protocol invokes the keys() method instead of [Symbol.iterator]() to produce elements. This is to make maps valid set-like objects, because for maps, the iterator produces entries but the has() method takes keys.

Arrays are not set-like because they don't have a has() method or the size property, and their keys() method produces indices instead of elements. WeakSet objects are also not set-like because they don't have a keys() method.Set-like browser APIsBrowser Set-like objects (or "setlike objects") are Web API interfaces that behave in many ways like a Set.
Just like Set, elements can be iterated in the same order that they were added to the object.
Set-like objects and Set also have properties and methods that share the same name and behavior.
However unlike Set they only allow a specific predefined type for each entry.
The allowed types are set in the specification IDL definition.
For example, GPUSupportedFeatures is a Set-like object that must use strings as the key/value.
This is defined in the specification IDL below:
webidlinterface GPUSupportedFeatures {
  readonly setlike<DOMString>;
};

Set-like objects are either read-only or read-writable (see the readonly keyword in the IDL above).

Read-only Set-like objects have the property size, and the methods: entries(), forEach(), has(), keys(), values(), and Symbol.iterator().
Writeable Set-like objects additionally have the methods: clear(), delete(), and add().

The methods and properties have the same behavior as the equivalent entities in Set, except for the restriction on the types of the entry.
The following are examples of read-only Set-like browser objects:

GPUSupportedFeatures
XRAnchorSet

The following are examples of writable Set-like browser objects:

CustomStateSet
FontFaceSet
Highlight
Constructor
Set()

Creates a new Set object.

Static properties
Set[Symbol.species]

The constructor function that is used to create derived objects.

Instance propertiesThese properties are defined on Set.prototype and shared by all Set instances.

Set.prototype.constructor

The constructor function that created the instance object. For Set instances, the initial value is the Set constructor.

Set.prototype.size

Returns the number of values in the Set object.

Set.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Set". This property is used in Object.prototype.toString().

Instance methods
Set.prototype.add()

Inserts a new element with a specified value in to a Set object, if there isn't an element with the same value already in the Set.

Set.prototype.clear()

Removes all elements from the Set object.

Set.prototype.delete()

Removes the element associated to the value and returns a boolean asserting whether an element was successfully removed or not. Set.prototype.has(value) will return false afterwards.

Set.prototype.difference()

Takes a set and returns a new set containing elements in this set but not in the given set.

Set.prototype.entries()

Returns a new iterator object that contains an array of [value, value] for each element in the Set object, in insertion order. This is similar to the Map object, so that each entry's key is the same as its value for a Set.

Set.prototype.forEach()

Calls callbackFn once for each value present in the Set object, in insertion order. If a thisArg parameter is provided, it will be used as the this value for each invocation of callbackFn.

Set.prototype.has()

Returns a boolean asserting whether an element is present with the given value in the Set object or not.

Set.prototype.intersection()

Takes a set and returns a new set containing elements in both this set and the given set.

Set.prototype.isDisjointFrom()

Takes a set and returns a boolean indicating if this set has no elements in common with the given set.

Set.prototype.isSubsetOf()

Takes a set and returns a boolean indicating if all elements of this set are in the given set.

Set.prototype.isSupersetOf()

Takes a set and returns a boolean indicating if all elements of the given set are in this set.

Set.prototype.keys()

An alias for Set.prototype.values().

Set.prototype.symmetricDifference()

Takes a set and returns a new set containing elements which are in either this set or the given set, but not in both.

Set.prototype.union()

Takes a set and returns a new set containing elements which are in either or both of this set and the given set.

Set.prototype.values()

Returns a new iterator object that yields the values for each element in the Set object in insertion order.

Set.prototype[Symbol.iterator]()

Returns a new iterator object that yields the values for each element in the Set object in insertion order.

ExamplesUsing the Set objectjsconst mySet1 = new Set();

mySet1.add(1); // Set(1) { 1 }
mySet1.add(5); // Set(2) { 1, 5 }
mySet1.add(5); // Set(2) { 1, 5 }
mySet1.add("some text"); // Set(3) { 1, 5, 'some text' }
const o = { a: 1, b: 2 };
mySet1.add(o);

mySet1.add({ a: 1, b: 2 }); // o is referencing a different object, so this is okay

mySet1.has(1); // true
mySet1.has(3); // false, since 3 has not been added to the set
mySet1.has(5); // true
mySet1.has(Math.sqrt(25)); // true
mySet1.has("Some Text".toLowerCase()); // true
mySet1.has(o); // true

mySet1.size; // 5

mySet1.delete(5); // removes 5 from the set
mySet1.has(5); // false, 5 has been removed

mySet1.size; // 4, since we just removed one value

mySet1.add(5); // Set(5) { 1, 'some text', {...}, {...}, 5 } - a previously deleted item will be added as a new item, it will not retain its original position before deletion

console.log(mySet1); // Set(5) { 1, "some text", {…}, {…}, 5 }
Iterating setsThe iteration over a set visits elements in insertion order.
jsfor (const item of mySet1) {
  console.log(item);
}
// 1, "some text", { "a": 1, "b": 2 }, { "a": 1, "b": 2 }, 5

for (const item of mySet1.keys()) {
  console.log(item);
}
// 1, "some text", { "a": 1, "b": 2 }, { "a": 1, "b": 2 }, 5

for (const item of mySet1.values()) {
  console.log(item);
}
// 1, "some text", { "a": 1, "b": 2 }, { "a": 1, "b": 2 }, 5

// key and value are the same here
for (const [key, value] of mySet1.entries()) {
  console.log(key);
}
// 1, "some text", { "a": 1, "b": 2 }, { "a": 1, "b": 2 }, 5

// Convert Set object to an Array object, with Array.from
const myArr = Array.from(mySet1); // [1, "some text", {"a": 1, "b": 2}, {"a": 1, "b": 2}, 5]

// the following will also work if run in an HTML document
mySet1.add(document.body);
mySet1.has(document.querySelector("body")); // true

// converting between Set and Array
const mySet2 = new Set([1, 2, 3, 4]);
console.log(mySet2.size); // 4
console.log([...mySet2]); // [1, 2, 3, 4]

// intersect can be simulated via
const intersection = new Set([...mySet1].filter((x) => mySet2.has(x)));

// difference can be simulated via
const difference = new Set([...mySet1].filter((x) => !mySet2.has(x)));

// Iterate set entries with forEach()
mySet2.forEach((value) => {
  console.log(value);
});
// 1
// 2
// 3
// 4
Implementing basic set operationsjsfunction isSuperset(set, subset) {
  for (const elem of subset) {
    if (!set.has(elem)) {
      return false;
    }
  }
  return true;
}

function union(setA, setB) {
  const _union = new Set(setA);
  for (const elem of setB) {
    _union.add(elem);
  }
  return _union;
}

function intersection(setA, setB) {
  const _intersection = new Set();
  for (const elem of setB) {
    if (setA.has(elem)) {
      _intersection.add(elem);
    }
  }
  return _intersection;
}

function symmetricDifference(setA, setB) {
  const _difference = new Set(setA);
  for (const elem of setB) {
    if (_difference.has(elem)) {
      _difference.delete(elem);
    } else {
      _difference.add(elem);
    }
  }
  return _difference;
}

function difference(setA, setB) {
  const _difference = new Set(setA);
  for (const elem of setB) {
    _difference.delete(elem);
  }
  return _difference;
}

// Examples
const setA = new Set([1, 2, 3, 4]);
const setB = new Set([2, 3]);
const setC = new Set([3, 4, 5, 6]);

isSuperset(setA, setB); // returns true
union(setA, setC); // returns Set {1, 2, 3, 4, 5, 6}
intersection(setA, setC); // returns Set {3, 4}
symmetricDifference(setA, setC); // returns Set {1, 2, 5, 6}
difference(setA, setC); // returns Set {1, 2}
Relation to arraysjsconst myArray = ["value1", "value2", "value3"];

// Use the regular Set constructor to transform an Array into a Set
const mySet = new Set(myArray);

mySet.has("value1"); // returns true

// Use the spread syntax to transform a set into an Array.
console.log([...mySet]); // Will show you exactly the same Array as myArray
Remove duplicate elements from an arrayjs// Use to remove duplicate elements from an array
const numbers = [2, 13, 4, 4, 2, 13, 13, 4, 4, 5, 5, 6, 6, 7, 5, 32, 13, 4, 5];

console.log([...new Set(numbers)]); // [2, 13, 4, 5, 6, 7, 32]
Relation to stringsjs// Case sensitive (set will contain "F" and "f")
new Set("Firefox"); // Set(7) [ "F", "i", "r", "e", "f", "o", "x" ]

// Duplicate omission ("f" occurs twice in the string but set will contain only one)
new Set("firefox"); // Set(6) [ "f", "i", "r", "e", "o", "x" ]
Use a set to ensure the uniqueness of a list of valuesjsconst array = Array.from(document.querySelectorAll("[id]")).map((e) => e.id);

const set = new Set(array);
console.assert(set.size === array.length);
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-set-objectsBrowser compatibilitySee also
Polyfill of Set in core-js
es-shims polyfill of Set
Map
WeakMap
WeakSet
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 2, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nSetBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Set object lets you store unique values of any type, whether primitive values or object references.DescriptionSet objects are collections of values. A value in the set may only occur once; it is unique in the set's collection. You can iterate through the elements of a set in insertion order. The insertion order corresponds to the order in which each element was inserted into the set by the add() method successfully (that is, there wasn't an identical element already in the set when add() was called).
The specification requires sets to be implemented "that, on average, provide access times that are sublinear on the number of elements in the collection". Therefore, it could be represented internally as a hash table (with O(1) lookup), a search tree (with O(log(N)) lookup), or any other data structure, as long as the complexity is better than O(N).Value equalityValue equality is based on the SameValueZero algorithm. (It used to use SameValue, which treated 0 and -0 as different. Check browser compatibility.) This means NaN is considered the same as NaN (even though NaN !== NaN) and all other values are considered equal according to the semantics of the === operator.PerformanceThe has method checks if a value is in the set, using an approach that is, on average, quicker than testing most of the elements that have previously been added to the set. In particular, it is, on average, faster than the Array.prototype.includes method when an array has a length equal to a set's size.Set compositionThe Set object provides some methods that allow you to compose sets like you would with mathematical operations. These methods include:

  
    
      Method
      Return type
      Mathematical equivalent
      Venn diagram
    
  
  
    
      A.difference(B)
      Set
      
        A∖BA etminus B
      
      
    
    
      A.intersection(B)
      Set
      
        A∩BA\cap B
      
      
    
    
      A.symmetricDifference(B)
      Set
      
        (A∖B)∪(B∖A)(A etminus B)\cup(B etminus A)
      
      
    
    
      A.union(B)
      Set
      
        A∪BA\cup B
      
      
    
    
      A.isDisjointFrom(B)
      Boolean
      
        A∩B=∅A\cap B = \empty
      
      
    
    
      A.isSubsetOf(B)
      Boolean
      
        A⊆BA ubseteq B
      
      
    
    
      A.isSupersetOf(B)
      Boolean
      
        A⊇BA upseteq B
      
      
    
  

To make them more generalizable, these methods don't just accept Set objects, but anything that's set-like.Set-like objectsAll set composition methods require this to be an actual Set instance, but their arguments just need to be set-like. A set-like object is an object that provides the following:

A size property that contains a number.
A has() method that takes an element and returns a boolean.
A keys() method that returns an iterator of the elements in the set.

For example, Map objects are set-like because they also have size, has(), and keys(), so they behave just like sets of keys when used in set methods:
jsconst a = new Set([1, 2, 3]);
const b = new Map([
  [1, "one"],
  [2, "two"],
  [4, "four"],
]);
console.log(a.union(b)); // Set(4) {1, 2, 3, 4}


Note:
The set-like protocol invokes the keys() method instead of [Symbol.iterator]() to produce elements. This is to make maps valid set-like objects, because for maps, the iterator produces entries but the has() method takes keys.

Arrays are not set-like because they don't have a has() method or the size property, and their keys() method produces indices instead of elements. WeakSet objects are also not set-like because they don't have a keys() method.Set-like browser APIsBrowser Set-like objects (or "setlike objects") are Web API interfaces that behave in many ways like a Set.
Just like Set, elements can be iterated in the same order that they were added to the object.
Set-like objects and Set also have properties and methods that share the same name and behavior.
However unlike Set they only allow a specific predefined type for each entry.
The allowed types are set in the specification IDL definition.
For example, GPUSupportedFeatures is a Set-like object that must use strings as the key/value.
This is defined in the specification IDL below:
webidlinterface GPUSupportedFeatures {
  readonly setlike<DOMString>;
};

Set-like objects are either read-only or read-writable (see the readonly keyword in the IDL above).

Read-only Set-like objects have the property size, and the methods: entries(), forEach(), has(), keys(), values(), and Symbol.iterator().
Writeable Set-like objects additionally have the methods: clear(), delete(), and add().

The methods and properties have the same behavior as the equivalent entities in Set, except for the restriction on the types of the entry.
The following are examples of read-only Set-like browser objects:

GPUSupportedFeatures
XRAnchorSet

The following are examples of writable Set-like browser objects:

CustomStateSet
FontFaceSet
Highlight
Constructor
Set()

Creates a new Set object.

Static properties
Set[Symbol.species]

The constructor function that is used to create derived objects.

Instance propertiesThese properties are defined on Set.prototype and shared by all Set instances.

Set.prototype.constructor

The constructor function that created the instance object. For Set instances, the initial value is the Set constructor.

Set.prototype.size

Returns the number of values in the Set object.

Set.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Set". This property is used in Object.prototype.toString().

Instance methods
Set.prototype.add()

Inserts a new element with a specified value in to a Set object, if there isn't an element with the same value already in the Set.

Set.prototype.clear()

Removes all elements from the Set object.

Set.prototype.delete()

Removes the element associated to the value and returns a boolean asserting whether an element was successfully removed or not. Set.prototype.has(value) will return false afterwards.

Set.prototype.difference()

Takes a set and returns a new set containing elements in this set but not in the given set.

Set.prototype.entries()

Returns a new iterator object that contains an array of [value, value] for each element in the Set object, in insertion order. This is similar to the Map object, so that each entry's key is the same as its value for a Set.

Set.prototype.forEach()

Calls callbackFn once for each value present in the Set object, in insertion order. If a thisArg parameter is provided, it will be used as the this value for each invocation of callbackFn.

Set.prototype.has()

Returns a boolean asserting whether an element is present with the given value in the Set object or not.

Set.prototype.intersection()

Takes a set and returns a new set containing elements in both this set and the given set.

Set.prototype.isDisjointFrom()

Takes a set and returns a boolean indicating if this set has no elements in common with the given set.

Set.prototype.isSubsetOf()

Takes a set and returns a boolean indicating if all elements of this set are in the given set.

Set.prototype.isSupersetOf()

Takes a set and returns a boolean indicating if all elements of the given set are in this set.

Set.prototype.keys()

An alias for Set.prototype.values().

Set.prototype.symmetricDifference()

Takes a set and returns a new set containing elements which are in either this set or the given set, but not in both.

Set.prototype.union()

Takes a set and returns a new set containing elements which are in either or both of this set and the given set.

Set.prototype.values()

Returns a new iterator object that yields the values for each element in the Set object in insertion order.

Set.prototype[Symbol.iterator]()

Returns a new iterator object that yields the values for each element in the Set object in insertion order.

ExamplesUsing the Set objectjsconst mySet1 = new Set();

mySet1.add(1); // Set(1) { 1 }
mySet1.add(5); // Set(2) { 1, 5 }
mySet1.add(5); // Set(2) { 1, 5 }
mySet1.add("some text"); // Set(3) { 1, 5, 'some text' }
const o = { a: 1, b: 2 };
mySet1.add(o);

mySet1.add({ a: 1, b: 2 }); // o is referencing a different object, so this is okay

mySet1.has(1); // true
mySet1.has(3); // false, since 3 has not been added to the set
mySet1.has(5); // true
mySet1.has(Math.sqrt(25)); // true
mySet1.has("Some Text".toLowerCase()); // true
mySet1.has(o); // true

mySet1.size; // 5

mySet1.delete(5); // removes 5 from the set
mySet1.has(5); // false, 5 has been removed

mySet1.size; // 4, since we just removed one value

mySet1.add(5); // Set(5) { 1, 'some text', {...}, {...}, 5 } - a previously deleted item will be added as a new item, it will not retain its original position before deletion

console.log(mySet1); // Set(5) { 1, "some text", {…}, {…}, 5 }
Iterating setsThe iteration over a set visits elements in insertion order.
jsfor (const item of mySet1) {
  console.log(item);
}
// 1, "some text", { "a": 1, "b": 2 }, { "a": 1, "b": 2 }, 5

for (const item of mySet1.keys()) {
  console.log(item);
}
// 1, "some text", { "a": 1, "b": 2 }, { "a": 1, "b": 2 }, 5

for (const item of mySet1.values()) {
  console.log(item);
}
// 1, "some text", { "a": 1, "b": 2 }, { "a": 1, "b": 2 }, 5

// key and value are the same here
for (const [key, value] of mySet1.entries()) {
  console.log(key);
}
// 1, "some text", { "a": 1, "b": 2 }, { "a": 1, "b": 2 }, 5

// Convert Set object to an Array object, with Array.from
const myArr = Array.from(mySet1); // [1, "some text", {"a": 1, "b": 2}, {"a": 1, "b": 2}, 5]

// the following will also work if run in an HTML document
mySet1.add(document.body);
mySet1.has(document.querySelector("body")); // true

// converting between Set and Array
const mySet2 = new Set([1, 2, 3, 4]);
console.log(mySet2.size); // 4
console.log([...mySet2]); // [1, 2, 3, 4]

// intersect can be simulated via
const intersection = new Set([...mySet1].filter((x) => mySet2.has(x)));

// difference can be simulated via
const difference = new Set([...mySet1].filter((x) => !mySet2.has(x)));

// Iterate set entries with forEach()
mySet2.forEach((value) => {
  console.log(value);
});
// 1
// 2
// 3
// 4
Implementing basic set operationsjsfunction isSuperset(set, subset) {
  for (const elem of subset) {
    if (!set.has(elem)) {
      return false;
    }
  }
  return true;
}

function union(setA, setB) {
  const _union = new Set(setA);
  for (const elem of setB) {
    _union.add(elem);
  }
  return _union;
}

function intersection(setA, setB) {
  const _intersection = new Set();
  for (const elem of setB) {
    if (setA.has(elem)) {
      _intersection.add(elem);
    }
  }
  return _intersection;
}

function symmetricDifference(setA, setB) {
  const _difference = new Set(setA);
  for (const elem of setB) {
    if (_difference.has(elem)) {
      _difference.delete(elem);
    } else {
      _difference.add(elem);
    }
  }
  return _difference;
}

function difference(setA, setB) {
  const _difference = new Set(setA);
  for (const elem of setB) {
    _difference.delete(elem);
  }
  return _difference;
}

// Examples
const setA = new Set([1, 2, 3, 4]);
const setB = new Set([2, 3]);
const setC = new Set([3, 4, 5, 6]);

isSuperset(setA, setB); // returns true
union(setA, setC); // returns Set {1, 2, 3, 4, 5, 6}
intersection(setA, setC); // returns Set {3, 4}
symmetricDifference(setA, setC); // returns Set {1, 2, 5, 6}
difference(setA, setC); // returns Set {1, 2}
Relation to arraysjsconst myArray = ["value1", "value2", "value3"];

// Use the regular Set constructor to transform an Array into a Set
const mySet = new Set(myArray);

mySet.has("value1"); // returns true

// Use the spread syntax to transform a set into an Array.
console.log([...mySet]); // Will show you exactly the same Array as myArray
Remove duplicate elements from an arrayjs// Use to remove duplicate elements from an array
const numbers = [2, 13, 4, 4, 2, 13, 13, 4, 4, 5, 5, 6, 6, 7, 5, 32, 13, 4, 5];

console.log([...new Set(numbers)]); // [2, 13, 4, 5, 6, 7, 32]
Relation to stringsjs// Case sensitive (set will contain "F" and "f")
new Set("Firefox"); // Set(7) [ "F", "i", "r", "e", "f", "o", "x" ]

// Duplicate omission ("f" occurs twice in the string but set will contain only one)
new Set("firefox"); // Set(6) [ "f", "i", "r", "e", "o", "x" ]
Use a set to ensure the uniqueness of a list of valuesjsconst array = Array.from(document.querySelectorAll("[id]")).map((e) => e.id);

const set = new Set(array);
console.assert(set.size === array.length);
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-set-objectsBrowser compatibilitySee also
Polyfill of Set in core-js
es-shims polyfill of Set
Map
WeakMap
WeakSet
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 2, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nObject.keys()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe Object.keys() static method returns an array of a given object's own enumerable string-keyed property names.Try it
const object1 = {
  a: "somestring",
  b: 42,
  c: false,
};

console.log(Object.keys(object1));
// Expected output: Array ["a", "b", "c"]
SyntaxjsObject.keys(obj)
Parameters
obj

An object.

Return valueAn array of strings representing the given object's own enumerable string-keyed property keys.DescriptionObject.keys() returns an array whose elements are strings corresponding to the enumerable string-keyed property names found directly upon object. This is the same as iterating with a for...in loop, except that a for...in loop enumerates properties in the prototype chain as well. The order of the array returned by Object.keys() is the same as that provided by a for...in loop.
If you need the property values, use Object.values() instead. If you need both the property keys and values, use Object.entries() instead.ExamplesUsing Object.keys()js// Basic array
const arr = ["a", "b", "c"];
console.log(Object.keys(arr)); // ['0', '1', '2']

// Array-like object
const obj = { 0: "a", 1: "b", 2: "c" };
console.log(Object.keys(obj)); // ['0', '1', '2']

// Array-like object with random key ordering
const anObj = { 100: "a", 2: "b", 7: "c" };
console.log(Object.keys(anObj)); // ['2', '7', '100']

// getFoo is a non-enumerable property
const myObj = Object.create(
  {},
  {
    getFoo: {
      value() {
        return this.foo;
      },
    },
  },
);
myObj.foo = 1;
console.log(Object.keys(myObj)); // ['foo']

If you want all string-keyed own properties, including non-enumerable ones, see Object.getOwnPropertyNames().Using Object.keys() on primitivesNon-object arguments are coerced to objects. undefined and null cannot be coerced to objects and throw a TypeError upfront. Only strings may have own enumerable properties, while all other primitives return an empty array.
js// Strings have indices as enumerable own properties
console.log(Object.keys("foo")); // ['0', '1', '2']

// Other primitives except undefined and null have no own properties
console.log(Object.keys(100)); // []


Note:
In ES5, passing a non-object to Object.keys() threw a TypeError.
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object.keysBrowser compatibilitySee also
Polyfill of Object.keys in core-js
es-shims polyfill of Object.keys
Enumerability and ownership of properties
Object.entries()
Object.values()
Object.prototype.propertyIsEnumerable()
Object.create()
Object.getOwnPropertyNames()
Map.prototype.keys()\n\nObject.keys()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe Object.keys() static method returns an array of a given object's own enumerable string-keyed property names.Try it
const object1 = {
  a: "somestring",
  b: 42,
  c: false,
};

console.log(Object.keys(object1));
// Expected output: Array ["a", "b", "c"]
SyntaxjsObject.keys(obj)
Parameters
obj

An object.

Return valueAn array of strings representing the given object's own enumerable string-keyed property keys.DescriptionObject.keys() returns an array whose elements are strings corresponding to the enumerable string-keyed property names found directly upon object. This is the same as iterating with a for...in loop, except that a for...in loop enumerates properties in the prototype chain as well. The order of the array returned by Object.keys() is the same as that provided by a for...in loop.
If you need the property values, use Object.values() instead. If you need both the property keys and values, use Object.entries() instead.ExamplesUsing Object.keys()js// Basic array
const arr = ["a", "b", "c"];
console.log(Object.keys(arr)); // ['0', '1', '2']

// Array-like object
const obj = { 0: "a", 1: "b", 2: "c" };
console.log(Object.keys(obj)); // ['0', '1', '2']

// Array-like object with random key ordering
const anObj = { 100: "a", 2: "b", 7: "c" };
console.log(Object.keys(anObj)); // ['2', '7', '100']

// getFoo is a non-enumerable property
const myObj = Object.create(
  {},
  {
    getFoo: {
      value() {
        return this.foo;
      },
    },
  },
);
myObj.foo = 1;
console.log(Object.keys(myObj)); // ['foo']

If you want all string-keyed own properties, including non-enumerable ones, see Object.getOwnPropertyNames().Using Object.keys() on primitivesNon-object arguments are coerced to objects. undefined and null cannot be coerced to objects and throw a TypeError upfront. Only strings may have own enumerable properties, while all other primitives return an empty array.
js// Strings have indices as enumerable own properties
console.log(Object.keys("foo")); // ['0', '1', '2']

// Other primitives except undefined and null have no own properties
console.log(Object.keys(100)); // []


Note:
In ES5, passing a non-object to Object.keys() threw a TypeError.
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object.keysBrowser compatibilitySee also
Polyfill of Object.keys in core-js
es-shims polyfill of Object.keys
Enumerability and ownership of properties
Object.entries()
Object.values()
Object.prototype.propertyIsEnumerable()
Object.create()
Object.getOwnPropertyNames()
Map.prototype.keys()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nObject.keys()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe Object.keys() static method returns an array of a given object's own enumerable string-keyed property names.Try it
const object1 = {
  a: "somestring",
  b: 42,
  c: false,
};

console.log(Object.keys(object1));
// Expected output: Array ["a", "b", "c"]
SyntaxjsObject.keys(obj)
Parameters
obj

An object.

Return valueAn array of strings representing the given object's own enumerable string-keyed property keys.DescriptionObject.keys() returns an array whose elements are strings corresponding to the enumerable string-keyed property names found directly upon object. This is the same as iterating with a for...in loop, except that a for...in loop enumerates properties in the prototype chain as well. The order of the array returned by Object.keys() is the same as that provided by a for...in loop.
If you need the property values, use Object.values() instead. If you need both the property keys and values, use Object.entries() instead.ExamplesUsing Object.keys()js// Basic array
const arr = ["a", "b", "c"];
console.log(Object.keys(arr)); // ['0', '1', '2']

// Array-like object
const obj = { 0: "a", 1: "b", 2: "c" };
console.log(Object.keys(obj)); // ['0', '1', '2']

// Array-like object with random key ordering
const anObj = { 100: "a", 2: "b", 7: "c" };
console.log(Object.keys(anObj)); // ['2', '7', '100']

// getFoo is a non-enumerable property
const myObj = Object.create(
  {},
  {
    getFoo: {
      value() {
        return this.foo;
      },
    },
  },
);
myObj.foo = 1;
console.log(Object.keys(myObj)); // ['foo']

If you want all string-keyed own properties, including non-enumerable ones, see Object.getOwnPropertyNames().Using Object.keys() on primitivesNon-object arguments are coerced to objects. undefined and null cannot be coerced to objects and throw a TypeError upfront. Only strings may have own enumerable properties, while all other primitives return an empty array.
js// Strings have indices as enumerable own properties
console.log(Object.keys("foo")); // ['0', '1', '2']

// Other primitives except undefined and null have no own properties
console.log(Object.keys(100)); // []


Note:
In ES5, passing a non-object to Object.keys() threw a TypeError.
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-object.keysBrowser compatibilitySee also
Polyfill of Object.keys in core-js
es-shims polyfill of Object.keys
Enumerability and ownership of properties
Object.entries()
Object.values()
Object.prototype.propertyIsEnumerable()
Object.create()
Object.getOwnPropertyNames()
Map.prototype.keys()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJSON.parse()Baseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe JSON.parse() static method parses a JSON string, constructing the JavaScript value or object described by the string. An optional reviver function can be provided to perform a transformation on the resulting object before it is returned.Try it
const json = '{"result":true, "count":42}';
const obj = JSON.parse(json);

console.log(obj.count);
// Expected output: 42

console.log(obj.result);
// Expected output: true
SyntaxjsJSON.parse(text)
JSON.parse(text, reviver)
Parameters
text

The string to parse as JSON. See the JSON object for a description of JSON syntax.

reviver Optional

If a function, this prescribes how each value originally produced by parsing is transformed before being returned. Non-callable values are ignored. The function is called with the following arguments:

key

The key associated with the value.

value

The value produced by parsing.

context Optional

A context object that holds state relevant to the current expression being revived. It is a new object for each invocation of the reviver function. It is only passed when reviving primitive values, but not when value is an object or array. It contains the following property:

source

The original JSON string representing this value.





Return valueThe Object, Array, string, number, boolean, or null value corresponding to the given JSON text.Exceptions
SyntaxError

Thrown if the string to parse is not valid JSON.

DescriptionJSON.parse() parses a JSON string according to the JSON grammar, then evaluates the string as if it's a JavaScript expression. The only instance where a piece of JSON text represents a different value from the same JavaScript expression is when dealing with the "__proto__" key — see Object literal syntax vs. JSON.The reviver parameterIf a reviver is specified, the value computed by parsing is transformed before being returned. Specifically, the computed value and all its properties (in a depth-first fashion, beginning with the most nested properties and proceeding to the original value itself) are individually run through the reviver.
The reviver is called with the object containing the property being processed as this (unless you define the reviver as an arrow function, in which case there's no separate this binding) and two arguments: key and value, representing the property name as a string (even for arrays) and the property value. For primitive values, an additional context parameter is passed, which contains the source text of this value. If the reviver function returns undefined (or returns no value — for example, if execution falls off the end of the function), the property is deleted from the object. Otherwise, the property is redefined to be the return value. If the reviver only transforms some values and not others, be certain to return all untransformed values as-is — otherwise, they will be deleted from the resulting object.
Similar to the replacer parameter of JSON.stringify(), for arrays and objects, reviver will be last called on the root value with an empty string as the key and the root object as the value. For other valid JSON values, reviver works similarly and is called once with an empty string as the key and the value itself as the value.
If you return another value from reviver, that value will completely replace the originally parsed value. This even applies to the root value. For example:
jsconst transformedObj1 = JSON.parse('[1,5,{"s":1}]', (key, value) => {
  return typeof value === "object" ? undefined : value;
});

console.log(transformedObj1); // undefined

There is no way to work around this generically. You cannot specially handle the case where key is an empty string, because JSON objects can also contain keys that are empty strings. You need to know very precisely what kind of transformation is needed for each key when implementing the reviver.
Note that reviver is run after the value is parsed. So, for example, numbers in JSON text will have already been converted to JavaScript numbers, and may lose precision in the process. One way to transfer large numbers without loss of precision is to serialize them as strings, and revive them to BigInts, or other appropriate arbitrary precision formats.
You can also use the context.source property to access the original JSON source text representing the value, as shown below:
jsconst bigJSON = '{"gross_gdp": 12345678901234567890}';
const bigObj = JSON.parse(bigJSON, (key, value, context) => {
  if (key === "gross_gdp") {
    // Ignore the value because it has already lost precision
    return BigInt(context.source);
  }
  return value;
});
ExamplesUsing JSON.parse()jsJSON.parse("{}"); // {}
JSON.parse("true"); // true
JSON.parse('"foo"'); // "foo"
JSON.parse('[1, 5, "false"]'); // [1, 5, "false"]
JSON.parse("null"); // null
Using the reviver parameterjsJSON.parse(
  '{"p": 5}',
  (key, value) =>
    typeof value === "number"
      ? value * 2 // return value * 2 for numbers
      : value, // return everything else unchanged
);
// { p: 10 }

JSON.parse('{"1": 1, "2": 2, "3": {"4": 4, "5": {"6": 6}}}', (key, value) => {
  console.log(key);
  return value;
});
// 1
// 2
// 4
// 6
// 5
// 3
// ""
Using reviver when paired with the replacer of JSON.stringify()In order for a value to properly round-trip (that is, it gets deserialized to the same original object), the serialization process must preserve the type information. For example, you can use the replacer parameter of JSON.stringify() for this purpose:
js// Maps are normally serialized as objects with no properties.
// We can use the replacer to specify the entries to be serialized.
const map = new Map([
  [1, "one"],
  [2, "two"],
  [3, "three"],
]);

const jsonText = JSON.stringify(map, (key, value) =>
  value instanceof Map ? Array.from(value.entries()) : value,
);

console.log(jsonText);
// [[1,"one"],[2,"two"],[3,"three"]]

const map2 = JSON.parse(jsonText, (key, value) =>
  Array.isArray(value) && value.every(Array.isArray) ? new Map(value) : value,
);

console.log(map2);
// Map { 1 => "one", 2 => "two", 3 => "three" }

Because JSON has no syntax space for annotating type metadata, in order to revive values that are not plain objects, you have to consider one of the following:

Serialize the entire object to a string and prefix it with a type tag.
"Guess" based on the structure of the data (for example, an array of two-member arrays)
If the shape of the payload is fixed, based on the property name (for example, all properties called registry hold Map objects).
Illegal JSONWhen JSON.parse receives a string that does not conform to the JSON grammar, it throws a SyntaxError.
Arrays and objects cannot have trailing commas in JSON:
jsJSON.parse("[1, 2, 3, 4, ]");
// SyntaxError: Unexpected token ] in JSON at position 13

JSON.parse('{"foo": 1, }');
// SyntaxError: Unexpected token } in JSON at position 12

JSON strings must be delimited by double (not single) quotes:
jsJSON.parse("{'foo': 1}");
// SyntaxError: Unexpected token ' in JSON at position 1

JSON.parse("'string'");
// SyntaxError: Unexpected token ' in JSON at position 0

If you are writing JSON inside a JavaScript string literal, you should either use single quotes to delimit the JavaScript string literal, or escape the double quotes that delimit the JSON string:
jsJSON.parse('{"foo": 1}'); // OK
JSON.parse("{\"foo\": 1}"); // OK
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.parseBrowser compatibilitySee also
Polyfill of modern JSON.parse behavior (reviver's context parameter) in core-js
JSON.stringify()\n\nJSON.parse()Baseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe JSON.parse() static method parses a JSON string, constructing the JavaScript value or object described by the string. An optional reviver function can be provided to perform a transformation on the resulting object before it is returned.Try it
const json = '{"result":true, "count":42}';
const obj = JSON.parse(json);

console.log(obj.count);
// Expected output: 42

console.log(obj.result);
// Expected output: true
SyntaxjsJSON.parse(text)
JSON.parse(text, reviver)
Parameters
text

The string to parse as JSON. See the JSON object for a description of JSON syntax.

reviver Optional

If a function, this prescribes how each value originally produced by parsing is transformed before being returned. Non-callable values are ignored. The function is called with the following arguments:

key

The key associated with the value.

value

The value produced by parsing.

context Optional

A context object that holds state relevant to the current expression being revived. It is a new object for each invocation of the reviver function. It is only passed when reviving primitive values, but not when value is an object or array. It contains the following property:

source

The original JSON string representing this value.





Return valueThe Object, Array, string, number, boolean, or null value corresponding to the given JSON text.Exceptions
SyntaxError

Thrown if the string to parse is not valid JSON.

DescriptionJSON.parse() parses a JSON string according to the JSON grammar, then evaluates the string as if it's a JavaScript expression. The only instance where a piece of JSON text represents a different value from the same JavaScript expression is when dealing with the "__proto__" key — see Object literal syntax vs. JSON.The reviver parameterIf a reviver is specified, the value computed by parsing is transformed before being returned. Specifically, the computed value and all its properties (in a depth-first fashion, beginning with the most nested properties and proceeding to the original value itself) are individually run through the reviver.
The reviver is called with the object containing the property being processed as this (unless you define the reviver as an arrow function, in which case there's no separate this binding) and two arguments: key and value, representing the property name as a string (even for arrays) and the property value. For primitive values, an additional context parameter is passed, which contains the source text of this value. If the reviver function returns undefined (or returns no value — for example, if execution falls off the end of the function), the property is deleted from the object. Otherwise, the property is redefined to be the return value. If the reviver only transforms some values and not others, be certain to return all untransformed values as-is — otherwise, they will be deleted from the resulting object.
Similar to the replacer parameter of JSON.stringify(), for arrays and objects, reviver will be last called on the root value with an empty string as the key and the root object as the value. For other valid JSON values, reviver works similarly and is called once with an empty string as the key and the value itself as the value.
If you return another value from reviver, that value will completely replace the originally parsed value. This even applies to the root value. For example:
jsconst transformedObj1 = JSON.parse('[1,5,{"s":1}]', (key, value) => {
  return typeof value === "object" ? undefined : value;
});

console.log(transformedObj1); // undefined

There is no way to work around this generically. You cannot specially handle the case where key is an empty string, because JSON objects can also contain keys that are empty strings. You need to know very precisely what kind of transformation is needed for each key when implementing the reviver.
Note that reviver is run after the value is parsed. So, for example, numbers in JSON text will have already been converted to JavaScript numbers, and may lose precision in the process. One way to transfer large numbers without loss of precision is to serialize them as strings, and revive them to BigInts, or other appropriate arbitrary precision formats.
You can also use the context.source property to access the original JSON source text representing the value, as shown below:
jsconst bigJSON = '{"gross_gdp": 12345678901234567890}';
const bigObj = JSON.parse(bigJSON, (key, value, context) => {
  if (key === "gross_gdp") {
    // Ignore the value because it has already lost precision
    return BigInt(context.source);
  }
  return value;
});
ExamplesUsing JSON.parse()jsJSON.parse("{}"); // {}
JSON.parse("true"); // true
JSON.parse('"foo"'); // "foo"
JSON.parse('[1, 5, "false"]'); // [1, 5, "false"]
JSON.parse("null"); // null
Using the reviver parameterjsJSON.parse(
  '{"p": 5}',
  (key, value) =>
    typeof value === "number"
      ? value * 2 // return value * 2 for numbers
      : value, // return everything else unchanged
);
// { p: 10 }

JSON.parse('{"1": 1, "2": 2, "3": {"4": 4, "5": {"6": 6}}}', (key, value) => {
  console.log(key);
  return value;
});
// 1
// 2
// 4
// 6
// 5
// 3
// ""
Using reviver when paired with the replacer of JSON.stringify()In order for a value to properly round-trip (that is, it gets deserialized to the same original object), the serialization process must preserve the type information. For example, you can use the replacer parameter of JSON.stringify() for this purpose:
js// Maps are normally serialized as objects with no properties.
// We can use the replacer to specify the entries to be serialized.
const map = new Map([
  [1, "one"],
  [2, "two"],
  [3, "three"],
]);

const jsonText = JSON.stringify(map, (key, value) =>
  value instanceof Map ? Array.from(value.entries()) : value,
);

console.log(jsonText);
// [[1,"one"],[2,"two"],[3,"three"]]

const map2 = JSON.parse(jsonText, (key, value) =>
  Array.isArray(value) && value.every(Array.isArray) ? new Map(value) : value,
);

console.log(map2);
// Map { 1 => "one", 2 => "two", 3 => "three" }

Because JSON has no syntax space for annotating type metadata, in order to revive values that are not plain objects, you have to consider one of the following:

Serialize the entire object to a string and prefix it with a type tag.
"Guess" based on the structure of the data (for example, an array of two-member arrays)
If the shape of the payload is fixed, based on the property name (for example, all properties called registry hold Map objects).
Illegal JSONWhen JSON.parse receives a string that does not conform to the JSON grammar, it throws a SyntaxError.
Arrays and objects cannot have trailing commas in JSON:
jsJSON.parse("[1, 2, 3, 4, ]");
// SyntaxError: Unexpected token ] in JSON at position 13

JSON.parse('{"foo": 1, }');
// SyntaxError: Unexpected token } in JSON at position 12

JSON strings must be delimited by double (not single) quotes:
jsJSON.parse("{'foo': 1}");
// SyntaxError: Unexpected token ' in JSON at position 1

JSON.parse("'string'");
// SyntaxError: Unexpected token ' in JSON at position 0

If you are writing JSON inside a JavaScript string literal, you should either use single quotes to delimit the JavaScript string literal, or escape the double quotes that delimit the JSON string:
jsJSON.parse('{"foo": 1}'); // OK
JSON.parse("{\"foo\": 1}"); // OK
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.parseBrowser compatibilitySee also
Polyfill of modern JSON.parse behavior (reviver's context parameter) in core-js
JSON.stringify()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJSON.parse()Baseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe JSON.parse() static method parses a JSON string, constructing the JavaScript value or object described by the string. An optional reviver function can be provided to perform a transformation on the resulting object before it is returned.Try it
const json = '{"result":true, "count":42}';
const obj = JSON.parse(json);

console.log(obj.count);
// Expected output: 42

console.log(obj.result);
// Expected output: true
SyntaxjsJSON.parse(text)
JSON.parse(text, reviver)
Parameters
text

The string to parse as JSON. See the JSON object for a description of JSON syntax.

reviver Optional

If a function, this prescribes how each value originally produced by parsing is transformed before being returned. Non-callable values are ignored. The function is called with the following arguments:

key

The key associated with the value.

value

The value produced by parsing.

context Optional

A context object that holds state relevant to the current expression being revived. It is a new object for each invocation of the reviver function. It is only passed when reviving primitive values, but not when value is an object or array. It contains the following property:

source

The original JSON string representing this value.





Return valueThe Object, Array, string, number, boolean, or null value corresponding to the given JSON text.Exceptions
SyntaxError

Thrown if the string to parse is not valid JSON.

DescriptionJSON.parse() parses a JSON string according to the JSON grammar, then evaluates the string as if it's a JavaScript expression. The only instance where a piece of JSON text represents a different value from the same JavaScript expression is when dealing with the "__proto__" key — see Object literal syntax vs. JSON.The reviver parameterIf a reviver is specified, the value computed by parsing is transformed before being returned. Specifically, the computed value and all its properties (in a depth-first fashion, beginning with the most nested properties and proceeding to the original value itself) are individually run through the reviver.
The reviver is called with the object containing the property being processed as this (unless you define the reviver as an arrow function, in which case there's no separate this binding) and two arguments: key and value, representing the property name as a string (even for arrays) and the property value. For primitive values, an additional context parameter is passed, which contains the source text of this value. If the reviver function returns undefined (or returns no value — for example, if execution falls off the end of the function), the property is deleted from the object. Otherwise, the property is redefined to be the return value. If the reviver only transforms some values and not others, be certain to return all untransformed values as-is — otherwise, they will be deleted from the resulting object.
Similar to the replacer parameter of JSON.stringify(), for arrays and objects, reviver will be last called on the root value with an empty string as the key and the root object as the value. For other valid JSON values, reviver works similarly and is called once with an empty string as the key and the value itself as the value.
If you return another value from reviver, that value will completely replace the originally parsed value. This even applies to the root value. For example:
jsconst transformedObj1 = JSON.parse('[1,5,{"s":1}]', (key, value) => {
  return typeof value === "object" ? undefined : value;
});

console.log(transformedObj1); // undefined

There is no way to work around this generically. You cannot specially handle the case where key is an empty string, because JSON objects can also contain keys that are empty strings. You need to know very precisely what kind of transformation is needed for each key when implementing the reviver.
Note that reviver is run after the value is parsed. So, for example, numbers in JSON text will have already been converted to JavaScript numbers, and may lose precision in the process. One way to transfer large numbers without loss of precision is to serialize them as strings, and revive them to BigInts, or other appropriate arbitrary precision formats.
You can also use the context.source property to access the original JSON source text representing the value, as shown below:
jsconst bigJSON = '{"gross_gdp": 12345678901234567890}';
const bigObj = JSON.parse(bigJSON, (key, value, context) => {
  if (key === "gross_gdp") {
    // Ignore the value because it has already lost precision
    return BigInt(context.source);
  }
  return value;
});
ExamplesUsing JSON.parse()jsJSON.parse("{}"); // {}
JSON.parse("true"); // true
JSON.parse('"foo"'); // "foo"
JSON.parse('[1, 5, "false"]'); // [1, 5, "false"]
JSON.parse("null"); // null
Using the reviver parameterjsJSON.parse(
  '{"p": 5}',
  (key, value) =>
    typeof value === "number"
      ? value * 2 // return value * 2 for numbers
      : value, // return everything else unchanged
);
// { p: 10 }

JSON.parse('{"1": 1, "2": 2, "3": {"4": 4, "5": {"6": 6}}}', (key, value) => {
  console.log(key);
  return value;
});
// 1
// 2
// 4
// 6
// 5
// 3
// ""
Using reviver when paired with the replacer of JSON.stringify()In order for a value to properly round-trip (that is, it gets deserialized to the same original object), the serialization process must preserve the type information. For example, you can use the replacer parameter of JSON.stringify() for this purpose:
js// Maps are normally serialized as objects with no properties.
// We can use the replacer to specify the entries to be serialized.
const map = new Map([
  [1, "one"],
  [2, "two"],
  [3, "three"],
]);

const jsonText = JSON.stringify(map, (key, value) =>
  value instanceof Map ? Array.from(value.entries()) : value,
);

console.log(jsonText);
// [[1,"one"],[2,"two"],[3,"three"]]

const map2 = JSON.parse(jsonText, (key, value) =>
  Array.isArray(value) && value.every(Array.isArray) ? new Map(value) : value,
);

console.log(map2);
// Map { 1 => "one", 2 => "two", 3 => "three" }

Because JSON has no syntax space for annotating type metadata, in order to revive values that are not plain objects, you have to consider one of the following:

Serialize the entire object to a string and prefix it with a type tag.
"Guess" based on the structure of the data (for example, an array of two-member arrays)
If the shape of the payload is fixed, based on the property name (for example, all properties called registry hold Map objects).
Illegal JSONWhen JSON.parse receives a string that does not conform to the JSON grammar, it throws a SyntaxError.
Arrays and objects cannot have trailing commas in JSON:
jsJSON.parse("[1, 2, 3, 4, ]");
// SyntaxError: Unexpected token ] in JSON at position 13

JSON.parse('{"foo": 1, }');
// SyntaxError: Unexpected token } in JSON at position 12

JSON strings must be delimited by double (not single) quotes:
jsJSON.parse("{'foo': 1}");
// SyntaxError: Unexpected token ' in JSON at position 1

JSON.parse("'string'");
// SyntaxError: Unexpected token ' in JSON at position 0

If you are writing JSON inside a JavaScript string literal, you should either use single quotes to delimit the JavaScript string literal, or escape the double quotes that delimit the JSON string:
jsJSON.parse('{"foo": 1}'); // OK
JSON.parse("{\"foo\": 1}"); // OK
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.parseBrowser compatibilitySee also
Polyfill of modern JSON.parse behavior (reviver's context parameter) in core-js
JSON.stringify()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nWindow: structuredClone() methodBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2022.Learn moreSee full compatibilityReport feedbackThe structuredClone() method of the Window interface creates a deep clone of a given value using the structured clone algorithm.
The method also allows transferable objects in the original value to be transferred rather than cloned to the new object.
Transferred objects are detached from the original object and attached to the new object; they are no longer accessible in the original object.SyntaxjsstructuredClone(value)
structuredClone(value, options)
Parameters
value

The object to be cloned.
This can be any structured-cloneable type.

options Optional

An object with the following properties:

transfer

An array of transferable objects that will be moved rather than cloned to the returned object.



Return valueA deep copy of the original value.Exceptions
DataCloneError DOMException

Thrown if any part of the input value is not serializable.

DescriptionThis function can be used to deep copy JavaScript values.
It also supports circular references, as shown below:
js// Create an object with a value and a circular reference to itself.
const original = { name: "MDN" };
original.itself = original;

// Clone it
const clone = structuredClone(original);

console.assert(clone !== original); // the objects are not the same (not same identity)
console.assert(clone.name === "MDN"); // they do have the same values
console.assert(clone.itself === clone); // and the circular reference is preserved
Transferring valuesTransferable objects (only) can be transferred rather than duplicated in the cloned object, using the transfer property of the options parameter. Transferring makes the original object unusable.

Note:
A scenario where this might be useful is when asynchronously validating some data in a buffer before saving it.
To avoid the buffer being modified before the data is saved, you can clone the buffer and validate that data.
If you also transfer the data, any attempts to modify the original buffer will fail, preventing its accidental misuse.

The following code shows how to clone an array and transfer its underlying resources to the new object.
On return, the original uInt8Array.buffer will be cleared.
js// 16MB = 1024 * 1024 * 16
const uInt8Array = Uint8Array.from({ length: 1024 * 1024 * 16 }, (v, i) => i);

const transferred = structuredClone(uInt8Array, {
  transfer: [uInt8Array.buffer],
});
console.log(uInt8Array.byteLength); // 0

You can clone any number of objects and transfer any subset of those objects.
For example, the code below would transfer arrayBuffer1 from the passed in value, but not arrayBuffer2.
jsconst transferred = structuredClone(
  { x: { y: { z: arrayBuffer1, w: arrayBuffer2 } } },
  { transfer: [arrayBuffer1] },
);
ExamplesCloning an objectIn this example, we clone an object with one member, which is an array. After cloning, changes to each object do not affect the other object.
jsconst mushrooms1 = {
  amanita: ["muscaria", "virosa"],
};

const mushrooms2 = structuredClone(mushrooms1);

mushrooms2.amanita.push("pantherina");
mushrooms1.amanita.pop();

console.log(mushrooms2.amanita); // ["muscaria", "virosa", "pantherina"]
console.log(mushrooms1.amanita); // ["muscaria"]
Transferring an objectIn this example we create an ArrayBuffer and then clone the object it is a member of, transferring the buffer. We can use the buffer in the cloned object, but if we try to use the original buffer we will get an exception.
js// Create an ArrayBuffer with a size in bytes
const buffer1 = new ArrayBuffer(16);

const object1 = {
  buffer: buffer1,
};

// Clone the object containing the buffer, and transfer it
const object2 = structuredClone(object1, { transfer: [buffer1] });

// Create an array from the cloned buffer
const int32View2 = new Int32Array(object2.buffer);
int32View2[0] = 42;
console.log(int32View2[0]);

// Creating an array from the original buffer throws a TypeError
const int32View1 = new Int32Array(object1.buffer);
SpecificationsSpecificationHTML # dom-structuredcloneBrowser compatibilitySee also
A polyfill of structuredClone is available in core-js
Structured clone algorithm
Structured clone polyfill\n\nWindow: structuredClone() methodBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2022.Learn moreSee full compatibilityReport feedbackThe structuredClone() method of the Window interface creates a deep clone of a given value using the structured clone algorithm.
The method also allows transferable objects in the original value to be transferred rather than cloned to the new object.
Transferred objects are detached from the original object and attached to the new object; they are no longer accessible in the original object.SyntaxjsstructuredClone(value)
structuredClone(value, options)
Parameters
value

The object to be cloned.
This can be any structured-cloneable type.

options Optional

An object with the following properties:

transfer

An array of transferable objects that will be moved rather than cloned to the returned object.



Return valueA deep copy of the original value.Exceptions
DataCloneError DOMException

Thrown if any part of the input value is not serializable.

DescriptionThis function can be used to deep copy JavaScript values.
It also supports circular references, as shown below:
js// Create an object with a value and a circular reference to itself.
const original = { name: "MDN" };
original.itself = original;

// Clone it
const clone = structuredClone(original);

console.assert(clone !== original); // the objects are not the same (not same identity)
console.assert(clone.name === "MDN"); // they do have the same values
console.assert(clone.itself === clone); // and the circular reference is preserved
Transferring valuesTransferable objects (only) can be transferred rather than duplicated in the cloned object, using the transfer property of the options parameter. Transferring makes the original object unusable.

Note:
A scenario where this might be useful is when asynchronously validating some data in a buffer before saving it.
To avoid the buffer being modified before the data is saved, you can clone the buffer and validate that data.
If you also transfer the data, any attempts to modify the original buffer will fail, preventing its accidental misuse.

The following code shows how to clone an array and transfer its underlying resources to the new object.
On return, the original uInt8Array.buffer will be cleared.
js// 16MB = 1024 * 1024 * 16
const uInt8Array = Uint8Array.from({ length: 1024 * 1024 * 16 }, (v, i) => i);

const transferred = structuredClone(uInt8Array, {
  transfer: [uInt8Array.buffer],
});
console.log(uInt8Array.byteLength); // 0

You can clone any number of objects and transfer any subset of those objects.
For example, the code below would transfer arrayBuffer1 from the passed in value, but not arrayBuffer2.
jsconst transferred = structuredClone(
  { x: { y: { z: arrayBuffer1, w: arrayBuffer2 } } },
  { transfer: [arrayBuffer1] },
);
ExamplesCloning an objectIn this example, we clone an object with one member, which is an array. After cloning, changes to each object do not affect the other object.
jsconst mushrooms1 = {
  amanita: ["muscaria", "virosa"],
};

const mushrooms2 = structuredClone(mushrooms1);

mushrooms2.amanita.push("pantherina");
mushrooms1.amanita.pop();

console.log(mushrooms2.amanita); // ["muscaria", "virosa", "pantherina"]
console.log(mushrooms1.amanita); // ["muscaria"]
Transferring an objectIn this example we create an ArrayBuffer and then clone the object it is a member of, transferring the buffer. We can use the buffer in the cloned object, but if we try to use the original buffer we will get an exception.
js// Create an ArrayBuffer with a size in bytes
const buffer1 = new ArrayBuffer(16);

const object1 = {
  buffer: buffer1,
};

// Clone the object containing the buffer, and transfer it
const object2 = structuredClone(object1, { transfer: [buffer1] });

// Create an array from the cloned buffer
const int32View2 = new Int32Array(object2.buffer);
int32View2[0] = 42;
console.log(int32View2[0]);

// Creating an array from the original buffer throws a TypeError
const int32View1 = new Int32Array(object1.buffer);
SpecificationsSpecificationHTML # dom-structuredcloneBrowser compatibilitySee also
A polyfill of structuredClone is available in core-js
Structured clone algorithm
Structured clone polyfill
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Sep 26, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWindow: structuredClone() methodBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2022.Learn moreSee full compatibilityReport feedbackThe structuredClone() method of the Window interface creates a deep clone of a given value using the structured clone algorithm.
The method also allows transferable objects in the original value to be transferred rather than cloned to the new object.
Transferred objects are detached from the original object and attached to the new object; they are no longer accessible in the original object.SyntaxjsstructuredClone(value)
structuredClone(value, options)
Parameters
value

The object to be cloned.
This can be any structured-cloneable type.

options Optional

An object with the following properties:

transfer

An array of transferable objects that will be moved rather than cloned to the returned object.



Return valueA deep copy of the original value.Exceptions
DataCloneError DOMException

Thrown if any part of the input value is not serializable.

DescriptionThis function can be used to deep copy JavaScript values.
It also supports circular references, as shown below:
js// Create an object with a value and a circular reference to itself.
const original = { name: "MDN" };
original.itself = original;

// Clone it
const clone = structuredClone(original);

console.assert(clone !== original); // the objects are not the same (not same identity)
console.assert(clone.name === "MDN"); // they do have the same values
console.assert(clone.itself === clone); // and the circular reference is preserved
Transferring valuesTransferable objects (only) can be transferred rather than duplicated in the cloned object, using the transfer property of the options parameter. Transferring makes the original object unusable.

Note:
A scenario where this might be useful is when asynchronously validating some data in a buffer before saving it.
To avoid the buffer being modified before the data is saved, you can clone the buffer and validate that data.
If you also transfer the data, any attempts to modify the original buffer will fail, preventing its accidental misuse.

The following code shows how to clone an array and transfer its underlying resources to the new object.
On return, the original uInt8Array.buffer will be cleared.
js// 16MB = 1024 * 1024 * 16
const uInt8Array = Uint8Array.from({ length: 1024 * 1024 * 16 }, (v, i) => i);

const transferred = structuredClone(uInt8Array, {
  transfer: [uInt8Array.buffer],
});
console.log(uInt8Array.byteLength); // 0

You can clone any number of objects and transfer any subset of those objects.
For example, the code below would transfer arrayBuffer1 from the passed in value, but not arrayBuffer2.
jsconst transferred = structuredClone(
  { x: { y: { z: arrayBuffer1, w: arrayBuffer2 } } },
  { transfer: [arrayBuffer1] },
);
ExamplesCloning an objectIn this example, we clone an object with one member, which is an array. After cloning, changes to each object do not affect the other object.
jsconst mushrooms1 = {
  amanita: ["muscaria", "virosa"],
};

const mushrooms2 = structuredClone(mushrooms1);

mushrooms2.amanita.push("pantherina");
mushrooms1.amanita.pop();

console.log(mushrooms2.amanita); // ["muscaria", "virosa", "pantherina"]
console.log(mushrooms1.amanita); // ["muscaria"]
Transferring an objectIn this example we create an ArrayBuffer and then clone the object it is a member of, transferring the buffer. We can use the buffer in the cloned object, but if we try to use the original buffer we will get an exception.
js// Create an ArrayBuffer with a size in bytes
const buffer1 = new ArrayBuffer(16);

const object1 = {
  buffer: buffer1,
};

// Clone the object containing the buffer, and transfer it
const object2 = structuredClone(object1, { transfer: [buffer1] });

// Create an array from the cloned buffer
const int32View2 = new Int32Array(object2.buffer);
int32View2[0] = 42;
console.log(int32View2[0]);

// Creating an array from the original buffer throws a TypeError
const int32View1 = new Int32Array(object1.buffer);
SpecificationsSpecificationHTML # dom-structuredcloneBrowser compatibilitySee also
A polyfill of structuredClone is available in core-js
Structured clone algorithm
Structured clone polyfill
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Sep 26, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJSON.stringify()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.Try it
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'

console.log(
  JSON.stringify([new Number(3), new String("false"), new Boolean(false)]),
);
// Expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }));
// Expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// Expected output: '"2006-01-02T15:04:05.000Z"'
SyntaxjsJSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
Parameters
value

The value to convert to a JSON string.

replacer Optional

A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string.

space Optional

A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes.
If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array.
If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used.

Return valueA JSON string representing the given value, or undefined.Exceptions
TypeError

Thrown in one of the following cases:

value contains a circular reference.
A BigInt value is encountered.


DescriptionJSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:


Boolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.


Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.


undefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined).


The numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)


Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.


The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property).


For other objects:


All Symbol-keyed properties will be completely ignored, even when using the replacer parameter.


If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:

if this object is a property value, the property name
if it is in an array, the index in the array, as a string
if JSON.stringify() was directly called on this object, an empty string

All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString()). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON(), which returns the same as toISOString().


Only enumerable own properties are visited. This means Map, Set, etc. will become "{}". You can use the replacer parameter to serialize them to something more useful.
Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).



The replacer parameterThe replacer parameter can be either a function or an array.
As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored.
As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer's this context.
The replacer function is called for the initial object being stringified as well, in which case the key is an empty string (""). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key. The current property value will be replaced with the replacer's return value for stringification. This means:

If you return a number, string, boolean, or null, that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)
If you return a Function, Symbol, or undefined, the property is not included in the output.
If you return any other object, the object is recursively stringified, calling the replacer function on each property.


Note:
When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation.

Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array.The space parameterThe space parameter may be used to control spacing in the final string.

If it is a number, successive levels in the stringification will each be indented by this many space characters.
If it is a string, successive levels will be indented by this string.

Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters.ExamplesUsing JSON.stringifyjsJSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify(new Date(1906, 0, 2, 15, 4, 5));
// '"1906-01-02T15:04:05.000Z"'

JSON.stringify({ x: 5, y: 6 });
// '{"x":5,"y":6}'
JSON.stringify([new Number(3), new String("false"), new Boolean(false)]);
// '[3,"false",false]'

// String-keyed array elements are not enumerable and make no sense in JSON
const a = ["foo", "bar"];
a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]
JSON.stringify(a);
// '["foo","bar"]'

JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] });
// '{"x":[10,null,null,null]}'

// Standard data structures
JSON.stringify([
  new Set([1]),
  new Map([[1, 2]]),
  new WeakSet([{ a: 1 }]),
  new WeakMap([[{ a: 1 }, 2]]),
]);
// '[{},{},{},{}]'

// TypedArray
JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);
// '[{"0":1},{"0":1},{"0":1}]'
JSON.stringify([
  new Uint8Array([1]),
  new Uint8ClampedArray([1]),
  new Uint16Array([1]),
  new Uint32Array([1]),
]);
// '[{"0":1},{"0":1},{"0":1},{"0":1}]'
JSON.stringify([new Float32Array([1]), new Float64Array([1])]);
// '[{"0":1},{"0":1}]'

// toJSON()
JSON.stringify({
  x: 5,
  y: 6,
  toJSON() {
    return this.x + this.y;
  },
});
// '11'

// Symbols:
JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'
JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});
// undefined

// Non-enumerable properties:
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);
// '{"y":"y"}'

// BigInt values throw
JSON.stringify({ x: 2n });
// TypeError: BigInt value can't be serialized in JSON
Using a function as replacerjsfunction replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'

If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key).
jsfunction makeReplacer() {
  let isInitial = true;

  return (key, value) => {
    if (isInitial) {
      isInitial = false;
      return value;
    }
    if (key === "") {
      // Omit all properties with name "" (except the initial object)
      return undefined;
    }
    return value;
  };
}

const replacer = makeReplacer();
console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}"
Using an array as replacerjsconst foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
Using the space parameterIndent the output with one space:
jsconsole.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/

Using a tab character mimics standard pretty-print appearance:

jsconsole.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t"));
/*
{
	"uno": 1,
	"dos": 2
}
*/

toJSON() behaviorDefining toJSON() for an object allows overriding its serialization behavior.
jsconst obj = {
  data: "data",

  toJSON(key) {
    return key ? `Now I am a nested object under key '${key}'` : this;
  },
};

JSON.stringify(obj);
// '{"data":"data"}'

JSON.stringify({ obj });
// '{"obj":"Now I am a nested object under key 'obj'"}'

JSON.stringify([obj]);
// '["Now I am a nested object under key '0'"]'
Issue with serializing circular referencesSince the JSON format doesn't support object references (although an IETF draft exists), a TypeError will be thrown if one attempts to encode an object with circular references.
jsconst circularReference = {};
circularReference.myself = circularReference;

// Serializing circular references throws "TypeError: cyclic object value"
JSON.stringify(circularReference);

To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values.
If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone(), which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize(), also support circular references.Using JSON.stringify() with localStorageIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify():
js// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });
session.screens.push({ name: "screenD", width: 250, height: 60 });
session.screens.push({ name: "screenE", width: 390, height: 120 });
session.screens.push({ name: "screenF", width: 1240, height: 650 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
Well-formed JSON.stringify()Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"�"'

But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16:
jsJSON.stringify("\uD800"); // '"\\ud800"'

This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify()'s two possible encodings of these code points.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-json.stringifyBrowser compatibilitySee also
Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js
JSON.parse()
JSON.rawJSON()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nResources for Developers, by DevelopersDocumenting web technologies, including CSS, HTML, and JavaScript, since 2005.Search MDNClear search inputSearchFeatured articlesBlogJavaScript Temporal is comingA new way to handle dates and times is being added to JavaScript. Let's take a look at Temporal, what problems it solves, the current state, and what you'll find in the new documentation about it on MDN.
CSSCSS anchor positioningThe CSS anchor positioning module defines features that allow you to tether elements together. Certain elements are defined as anchor elements; anchor-positioned elements can then have their size and position set based on the size and location of the anchor elements to which they are bound.
Web APIsUsing the View Transition APIThis article explains the theory behind how the View Transition API works, how to create view transitions and customize the transition animations, and how to manipulate active view transitions. This covers view transitions for both DOM state updates in a single-page app (SPA), and navigating between documents in a multi-page app (MPA).
JavaScriptTemporalThe Temporal object enables date and time management in various scenarios, including built-in time zone and calendar representation, wall-clock time conversions, arithmetics, formatting, and more. It is designed as a full replacement for the Date object.
Latest newsMDN 2024 content projectsdeveloper.mozilla.org3 months agoA new learning experience on MDNdeveloper.mozilla.org4 months agoIntroducing the new MDN Community pagedeveloper.mozilla.org6 months agoRecent contributionszh-CN: create `webRequest.CertificateInfo`mdn/translated-contenta day ago[zh-tw] Global attributes classmdn/translated-contenta day agozh-cn: add new page for br instructionmdn/translated-content13 hours agozh-cn: add new page for block instructionmdn/translated-content13 hours agozh-cn: add new page for call instructionmdn/translated-content13 hours agoFix title typomdn/content8 hours agosimplify WritableStream examplemdn/content7 hours agoMake all JS articles reachable via sidebarmdn/content5 hours agoAdd more links to the Wasm sidebarmdn/contentan hour agoMerge Transforming_XML_with_XSLT subarticles into itselfmdn/contentan hour agoContributor SpotlightYash Raj BhartiMDN resonates with my passion to build a consistent and open web, where developers can learn and grow.Get involved →\n\nResources for Developers, by DevelopersDocumenting web technologies, including CSS, HTML, and JavaScript, since 2005.Search MDNClear search inputSearchFeatured articlesBlogJavaScript Temporal is comingA new way to handle dates and times is being added to JavaScript. Let's take a look at Temporal, what problems it solves, the current state, and what you'll find in the new documentation about it on MDN.
CSSCSS anchor positioningThe CSS anchor positioning module defines features that allow you to tether elements together. Certain elements are defined as anchor elements; anchor-positioned elements can then have their size and position set based on the size and location of the anchor elements to which they are bound.
Web APIsUsing the View Transition APIThis article explains the theory behind how the View Transition API works, how to create view transitions and customize the transition animations, and how to manipulate active view transitions. This covers view transitions for both DOM state updates in a single-page app (SPA), and navigating between documents in a multi-page app (MPA).
JavaScriptTemporalThe Temporal object enables date and time management in various scenarios, including built-in time zone and calendar representation, wall-clock time conversions, arithmetics, formatting, and more. It is designed as a full replacement for the Date object.
Latest newsMDN 2024 content projectsdeveloper.mozilla.org3 months agoA new learning experience on MDNdeveloper.mozilla.org4 months agoIntroducing the new MDN Community pagedeveloper.mozilla.org6 months agoRecent contributionszh-CN: create `webRequest.CertificateInfo`mdn/translated-contenta day ago[zh-tw] Global attributes classmdn/translated-contenta day agozh-cn: add new page for br instructionmdn/translated-content13 hours agozh-cn: add new page for block instructionmdn/translated-content13 hours agozh-cn: add new page for call instructionmdn/translated-content13 hours agoFix title typomdn/content8 hours agosimplify WritableStream examplemdn/content7 hours agoMake all JS articles reachable via sidebarmdn/content5 hours agoAdd more links to the Wasm sidebarmdn/contentan hour agoMerge Transforming_XML_with_XSLT subarticles into itselfmdn/contentan hour agoContributor SpotlightYash Raj BhartiMDN resonates with my passion to build a consistent and open web, where developers can learn and grow.Get involved →\n\n\n\nAbout MDN
Empowering developers worldwide to build a better, open web

45K Pages of content
7 Languages
46M Monthly pageviews
Who we areMDN is an open-source, collaborative project owned by Mozilla Corporation and
developed by Mozilla, in partnership with a global community of volunteers and
partners. Mozilla’s MDN team leads the platform’s development, content strategy,
and overall direction, while the community actively
contributes to content creation, translations, and browser compatibility
improvements, ensuring MDN remains a vital and evolving resource for all.What we offerOur journeyOur core valuesOur teamOur partners

MDN Web Docs
Your comprehensive resource for web development documentation, covering
everything from CSS, HTML,
JavaScript, Web APIs, and
other web technologies.


MDN Learn
Ideal for beginners, MDN Learn offers guides and a
structured curriculum to kickstart your web development
journey. Enhance your learning with interactive courses from our partner,
Scrimba.


MDN Blog
Stay updated with the latest in web development. Our blog
features updates, tips, tutorials from web experts, MDN announcements, and
curated sponsored content.


MDN Plus
Experience a personalized MDN with our premium subscription service. Enjoy
features like AI-powered assistance and
Collections to streamline your workflow.


MDN Tools
Experiment and learn with tools like Playground for live coding
and HTTP Observatory for analyzing website security,
designed to enhance your development experience.

From our beginnings to becoming the go-to resource for web developers worldwide,
here's how we've evolved:


2005
Launched as
DevMo by Mozilla,
a community-driven wiki dedicated to documenting open web standards.



2010
Rebranded as
Mozilla Developer Network (MDN),
reinforcing our commitment to the developer community.



2017
Achieved a milestone when major tech companies began contributing and
supporting web documentation on our platform, solidifying MDN as the central
hub for web development knowledge.


2020
Transitioned from its wiki-based origins to a modern,
GitHub-hosted project with the launch of Yari,
modernizing our infrastructure and workflows.



2022
Unveiled a
major redesign and
introduced
MDN Plus,
offering personalized features for an enhanced user experience.



2023/2024
Launched new tools, including Playground for coding experiments, AI Help for
easier content discovery, and HTTP Observatory for website security scans. We
also introduced a Blog to cover interesting topics beyond MDN’s core focus,
and a Curriculum to provide a structured approach to learning web development.


Discover more
We had fun exploring the
internet archives
and putting together a fast-forward trip through our transformation!























Accurate and reliable
MDN is built on the fundamental principle of accuracy, which has established
it as the trusted source of web documentation globally. We are committed to
providing expertly curated and rigorously reviewed content to maintain the
highest standards of quality and accuracy. Our dedication is backed by the
best developer community in the world—a passionate group of contributors who
help us enhance and refine our documentation. We welcome the knowledge and
experience of our diverse developer community to ensure that millions of users
can rely on MDN daily for up-to-date and accurate information.


Collaborative and community-driven
MDN is a Mozilla project that is powered by its global community. We are a
diverse group of developers, writers, and technologists working together to
build resources for a better web. Our open-source approach welcomes
contributions from anyone. Each of the individuals who have
contributed over the past decades has strengthened MDN. Through our GitHub
repository, contributors can make changes and get their work reviewed and
integrated into MDN’s content.


Inclusive and dynamic
MDN is committed to providing documentation for a wide range of web
technologies while continuously adapting to the changing landscape of web
development. We strive to create content that’s relevant and valuable to
developers working across different browsers and platforms. We are dedicated
to regularly updating our resources to reflect the latest standards and best
practices, helping developers stay current in a rapidly changing field.


Our mission
At MDN, our mission is to provide developers with the resources they need to
create innovative and accessible web experiences. We offer a free,
high-quality, and comprehensive platform that includes documentation on
essential web technologies like CSS,
HTML, JavaScript, and
Web APIs. Our learning materials
are tailored for a diverse audience—from beginners and students to professors
teaching web development.

From technical writers and engineers to product and community managers, we are a
diverse group dedicated to driving MDN’s mission, growth, and success. Get to
know the people behind MDN and discover what motivates us to keep you at the
forefront of web development!

Joe Walker

Senior Director

@joewalker
Joe is based in London and has been at Mozilla since 2009. He got interested in Mozilla after suddenly being anointed as the maintainer of Venkman, a precursor to Firebug. He later worked on and managed Firebug and Firefox DevTools. Since 2020, he's managed various teams across Firefox Web Platform, including looking after the core parts of Firefox that you don't usually see—like JavaScript and the DOM. In 2025, he took on the leadership of MDN as well. Joe sometimes works from his office at the bottom of a disused canal, with three chickens and a few newts for company.



Ruth John

Senior Manager

@Rumyra
Based in the UK, Ruth has been working on MDN since 2017. Starting out as a
contracting technical writer documenting fun Web APIs, she joined the team
full-time in 2021 and now heads up the content and community teams. She has
always been a big supporter of the web platform due to her long experience as
a front-end developer and cares deeply about the accuracy and usefulness of
MDN for its developer audience. In her spare time, you can find her walking
her dog Yoshi or in her studio, where she enjoys sewing, sculpting, painting,
and anything else that takes her away from a screen.



Florian Dieminger

Senior Engineering Manager

@fiji-flo
A Berlin resident and a long-time Mozilian, Florian was an active community
member before he joined the Mozilla staff in 2018. His passion for the web
spans across front-end, back-end, browser-engine and anything in-between. He
is a nerd outside of work too and is rediscovering online gaming. He loves
spending time with his family.



Dipika Bhattacharya

Staff Technical Writer

@dipikabh
Dipika works out of Toronto. She joined the MDN team in 2022, bringing her
background in instructional design to the role. She is passionate about
delivering clear and concise documentation to make complex concepts easy to
understand, paying special attention to how information is organized and
presented. She cares about improving the clarity, usability, and
discoverability of MDN’s documentation. Outside of work, she loves exploring
the city, discovering unique coffee shops, and trying different cuisines.



Vadim Makeev

Staff Technical Writer

@pepelsbey
Based in Berlin, Vadim has been working on MDN since 2023. He combines his
previous experience as a front-end developer with a deep passion for browsers
and the web platform. Before joining Mozilla, he worked as a DevRel for the
Opera browser, authored front-end courses, and was also involved in organizing
conferences and meetups. In his spare time, he goes on bikepacking trips,
hangs out on punk gigs, and records podcasts and videos in his home studio.



Brian Smith

Staff Technical Writer

@bsmth
Brian has been with MDN since 2022. He lives in Berlin. With around 20 years
of experience hacking on web technologies and working full-time as a technical
writer since 2016, Brian is passionate about open-source software and writing
docs that make complex concepts fun and easy to grasp for people of all
levels. Before joining Mozilla, Brian worked on a TypeScript-like language
specification, a time series database, and REST API documentation for cloud
services. Outside of work, he enjoys exploring new European destinations with
family, discovering local coffee shops, and using music gear as long as it
doesn't have a screen.



Dave Letorey


Technical Writer





@dletorey


Based in London, UK, Dave has been with MDN since 2022 where he's been focused
on Firefox release documentation, particularly HTML, CSS and SVG updates. He's
passionate about web standards, accessibility, performance and digital
inclusion. He is constantly learning about new web technologies and standards.
Outside of work he loves live music and tries to attend as many gigs and music
festivals as he can. He particularly loves post-punk, indie, house and techno.
He also attends many conferences and meetups and is an organizer of
London Web Standards &
State of the Browser. He also has a large
collection of red hats, so is easy to spot in the wild. He is never happier
than when in a field with his friends.




Chris Mills

Technical Writer and Product Strategist

@chrisdavidmills
Based in Greenfield, UK, Chris has been part of MDN since 2013, initially as a
technical writer and then as the writers' team lead until 2021. He came back
on board as a contractor in 2022 to document new technologies and contribute
to various MDN products and initiatives. Chris loves tinkering with CSS and
JavaScript and is passionate about accessibility and semantics. Outside work,
he is obsessed with loud, heavy music, and plays drums and guitar. He enjoys
cycling, country walks, and spending time with his wife and three awesome
kids.



Hamish Willee

Technical Writer

@hamishwillee
Based in Melbourne, Australia, Hamish has been with MDN since 2014, initially
on short-term contracts for various projects. From 2020, he’s been focused on
Firefox release documentation, particularly Web API and HTTP updates, while
also contributing to other aspects of the open-source project. He’s passionate
about efficient processes that maximize time for creating clear, concise, and
maintainable documentation. Hamish values that his writing reaches thousands
of developers and enjoys working with the diverse community to make expert
knowledge accessible to everyone in a clear format. Outside work, he brews
beer, reads science fiction and fantasy, enjoys running, and likes drones.



Andi Pieper

Staff Software Engineer

@argl
Andi lives in Berlin. He joined the MDN team in 2023. He is focused on keeping
up the high quality of MDN and ensuring that it remains an accessible,
competent, and friendly help for anyone concerned with the web, regardless of
their level of expertise. Growing up with the internet of the 90s, Andi has
worked on a multitude of projects on the web over the years, occasionally
veering off into desktop and mobile development. Apart from his daytime
obligations, he enjoys creating organized noise.



Claas Augner

Senior Software Engineer

@caugner
Based in Paris, Claas has been working as a Software Engineer in the MDN team
since 2022. He is passionate about clean code and continuous improvement. He
enjoys entertaining (the team), and maintaining (the platform). Outside of
work, he loves baking rye sourdough breads and playing cooperative board
games.



Leo McArdle

Senior Software Engineer

@LeoMcA
A London-based long-term Mozilla contributor, Leo has been working on MDN
since 2022 and volunteering for Mozilla since around 2008. As a self-taught
developer, largely through MDN, he cares about making the website discoverable
and functional for everyone. In his free time, he can be found cycling around
the city, photographing panoramas, or watching almost every sport imaginable,
from cricket to karting.



Pranshu Khanna

Staff Community Manager

@pransh15
Pranshu has been a long-term contributor to Mozilla as a Rep. Based in Berlin,
he joined the MDN team in 2024. He works on moderating, growing and managing
MDN’s awesome community. Pranshu is passionate about building a healthy and
inclusive community for developers and helping them build better. Before
working at Mozilla, Pranshu gained extensive experience in growing developer
communities for startups, organizing conferences like GraphQL Conf. 2021 &
2022, and running global programs for devs and students around AI, Web, and
DevOps. In his free time, he likes to play football in any form - physical,
digital, and fantasy.



Anuja Rajput

Senior User Experience Designer

@AnujaRajput727
Located in London, Anuja has been a part of the MDN team since 2023. With over
8 years of experience, she has passionately contributed to various phases of
product development, including design, business analysis, and testing. She is
empathetic and deeply cares about understanding users' perspectives and pain
points. She combines her work experience with her creative skills to enhance
her UX designs. In her free time, she enjoys painting, sketching, and travel
sketching.



Sonal Sood

Senior Product Manager

@s-sood
Sonal lives in Berlin. She has been with MDN since 2022. As a product manager,
she is adept at identifying and prioritizing features that truly meet users'
needs. With a strong background in data analysis and product management, she
is always focused on delivering valuable and impactful products that make a
difference. In her free time, Sonal enjoys cycling, running, and practicing
yoga.



Miruna Curtean

Quality Assurance

@mirunacurtean
Miruna calls Cluj-Napoca, Romania home. Contracting with Mozilla since 2019,
she worked on Firefox Add-ons and Mozilla Support before switching to MDN
in 2022. She focuses on analyzing requirements and community issues, building
comprehensive test bases, and ensuring delivered features meet requirements.
Before Mozilla, she worked in game development and e-commerce but found
greater joy in website development, particularly inspired by its community
aspect. Outside of work, Miruna enjoys story-based entertainment including
books, movies, shows, anime, and podcasts.


Product Advisory Board

Rachel Andrew

Content Lead at Google

Rachel has been working on the web as a developer since 1996 and writing about web development for almost as long. She now works for Google as Content Lead for Chrome Developer Relations, owning the content strategy of web.dev and developer.chrome.com, and is also a lead on the Baseline project. Rachel is a CSS Working Group member and specification editor, and in the past has been a contributor to MDN as a contractor for Mozilla and for Google.
Photo © Drew McLellan.



Robert Nyman

Web Developer Relations at Google

Robert wants to make the web the best platform for developers and has always been heavily invested in the community and helping developers succeed. Prior to Google, Robert was a technical evangelist at Mozilla, focused on the Open Web and the company's various products and initiatives. He's a co-founder of Open Web Docs, lives in Stockholm, has a passion for traveling and meeting people, and has given presentations in 42 countries.



Patrick Brosset

Senior Product Manager, Microsoft Edge

Patrick Brosset is a senior Product Manager on the Microsoft Edge web platform team, where he drives efforts around developer advocacy, documentation, and evangelism for the web platform. Patrick has worked with the web for more than 20 years, and on web browsers at Mozilla and Microsoft, including on developer tools, web apps, and the rendering engine for over a decade. He is a member of the Governing Committee at Open Web Docs, and a co-chair of the W3C WebDX Community Group.



Dominique Hazael-Massieux

Web Technology Expert including Web, W3C

Dominique Hazael-Massieux is part of the W3C staff, leading W3C
efforts in developer relations. Dom has been working for W3C since 2000,
and in addition to dev rel, is currently involved in the standardization
of WebRTC, WebNN and looking over the systemic impact of AI on the Web.
Dom also sits on the W3C Board of Directors and on the Open Web Docs
Governing Committee.



Carmen Cañas

Technical Project Manager, Bocoup

Carmen Cañas is part of the worker-owner team at Bocoup where she manages web platform projects and product development projects with a special focus on accessibility and privacy. Before joining Bocoup, she spent over 10 years building open source projects in Latin America and Africa, with a focus on implementing open data standards for publishing government data.  Carmen lives between Cuzcatlán (El Salvador) and Tkaronto (Toronto).



Laura Morinigo

Web Developer Advocate

Laura is a software developer, advocate, and mentor, passionate about sharing her knowledge and connecting with tech communities worldwide. She has been recognized as a Google Developer Expert and a Woman Techmakers Ambassador for her contributions. As a mentor, she has supported startups in accelerator programs like Google Launchpad and the United Nations’ World Food Programme. Currently, Laura contributes to web standards and advocates for advanced web features, helping developers build more inclusive and impactful web applications.




Open Web Docs
Open Web Docs (OWD), an independent open source organization, is one of the most productive contributors to MDN Web Docs. OWD contributes as part of their mission to support “web platform documentation for the benefit of web developers & designers worldwide.” The team at OWD has led or contributed to many projects to improve documentation on MDN. They're an invaluable partner in the day-to-day work of making MDN. Read more about OWD’s activities in their 2024 Impact and Transparency Report and get continuous updates on their Mastodon account.

Florian Scholz

Director

@Elchi3
Florian Scholz is the Director of Open Web Docs. He began volunteer editing MDN as a teen in 2009 and previously worked at Mozilla as MDN's Lead Content Strategist, Technical Writer & Documentation Engineer from 2013 until 2020. He's one of the creators of the browser compatibility data (BCD) project and it makes him happy when open source projects collaborate. He lives in Bremen, Germany; not Berlin. Other than submitting and reviewing PRs on GitHub, he enjoys listening to wave and post-punk music.



Will Bamberg

Sr. Technical Writer and Documentation Engineer

@wbamberg
Will Bamberg is a perfectionist and professional pedant who has been writing about the web for a long time, mostly on MDN. He enjoys learning about new aspects of the web platform and then turning that knowledge into accessible documentation. He believes that writing good documentation depends on understanding what it's like for someone who is learning something new or looking for the answer to their question.



Estelle Weyl

Sr. Technical Writer and Developer Advocate

@estelle
Estelle Weyl is a Sr. Technical Writer and Developer Advocate on the Open Web Docs team. She is a frontend engineer, writing CSS, JS and HTML since 1999. Estelle has always been a web standardista, advocating for a free, accessible, and performant web. Estelle has been documenting and teaching web standards since 2007, writing numerous books, blogs, and tutorials. She’s typing with her cat (who thinks he's a dog) and dog (who thinks she's a cat) in San Francisco.



Queen Vinyl Da.i'gyu-Kazotetsu

Compat Data Engineer

@queengooborg
Vinyl works for Open Web Docs leading the browser compatibility data (BCD) project that millions of developers around the world rely on. Previously a contractor at Google and Mozilla and a long-time BCD community member, Vinyl has a lot of experience with compatibility on the open web. She was already the number #1 contributor to the BCD repository before officially joining our team! When she's not submitting pull requests to BCD, she's usually slicing blocks to the music in Beat Saber or staffing at various conventions across the globe.


Global impactServing over 15 million users monthly from around the globe, MDN connects
developers with the tools and information they need to easily build projects on
the open web.


Educational influence: Our resources are integral to many coding bootcamps and
university courses worldwide.


Trusted reference: Platforms like freeCodeCamp and Codecademy frequently link
to MDN articles as authoritative references.


Industry standard: Tools like Can I use leverage
MDN’s browser compatibility data
for up-to-date information on web feature support across browsers.


Collaborative partnerships: We work closely with partners such as
Open Web Docs,
Microsoft,
Google, Igalia,
W3C, and others to drive web innovation and serve the
common good.

Join us in building a better webBe a part of our mission to foster innovation and inclusivity on the web.
Start contributing today and make a lasting impact
on the global developer community.\n\nAbout MDN
Empowering developers worldwide to build a better, open web

45K Pages of content
7 Languages
46M Monthly pageviews
Who we areMDN is an open-source, collaborative project owned by Mozilla Corporation and
developed by Mozilla, in partnership with a global community of volunteers and
partners. Mozilla’s MDN team leads the platform’s development, content strategy,
and overall direction, while the community actively
contributes to content creation, translations, and browser compatibility
improvements, ensuring MDN remains a vital and evolving resource for all.What we offerOur journeyOur core valuesOur teamOur partners

MDN Web Docs
Your comprehensive resource for web development documentation, covering
everything from CSS, HTML,
JavaScript, Web APIs, and
other web technologies.


MDN Learn
Ideal for beginners, MDN Learn offers guides and a
structured curriculum to kickstart your web development
journey. Enhance your learning with interactive courses from our partner,
Scrimba.


MDN Blog
Stay updated with the latest in web development. Our blog
features updates, tips, tutorials from web experts, MDN announcements, and
curated sponsored content.


MDN Plus
Experience a personalized MDN with our premium subscription service. Enjoy
features like AI-powered assistance and
Collections to streamline your workflow.


MDN Tools
Experiment and learn with tools like Playground for live coding
and HTTP Observatory for analyzing website security,
designed to enhance your development experience.

From our beginnings to becoming the go-to resource for web developers worldwide,
here's how we've evolved:


2005
Launched as
DevMo by Mozilla,
a community-driven wiki dedicated to documenting open web standards.



2010
Rebranded as
Mozilla Developer Network (MDN),
reinforcing our commitment to the developer community.



2017
Achieved a milestone when major tech companies began contributing and
supporting web documentation on our platform, solidifying MDN as the central
hub for web development knowledge.


2020
Transitioned from its wiki-based origins to a modern,
GitHub-hosted project with the launch of Yari,
modernizing our infrastructure and workflows.



2022
Unveiled a
major redesign and
introduced
MDN Plus,
offering personalized features for an enhanced user experience.



2023/2024
Launched new tools, including Playground for coding experiments, AI Help for
easier content discovery, and HTTP Observatory for website security scans. We
also introduced a Blog to cover interesting topics beyond MDN’s core focus,
and a Curriculum to provide a structured approach to learning web development.


Discover more
We had fun exploring the
internet archives
and putting together a fast-forward trip through our transformation!























Accurate and reliable
MDN is built on the fundamental principle of accuracy, which has established
it as the trusted source of web documentation globally. We are committed to
providing expertly curated and rigorously reviewed content to maintain the
highest standards of quality and accuracy. Our dedication is backed by the
best developer community in the world—a passionate group of contributors who
help us enhance and refine our documentation. We welcome the knowledge and
experience of our diverse developer community to ensure that millions of users
can rely on MDN daily for up-to-date and accurate information.


Collaborative and community-driven
MDN is a Mozilla project that is powered by its global community. We are a
diverse group of developers, writers, and technologists working together to
build resources for a better web. Our open-source approach welcomes
contributions from anyone. Each of the individuals who have
contributed over the past decades has strengthened MDN. Through our GitHub
repository, contributors can make changes and get their work reviewed and
integrated into MDN’s content.


Inclusive and dynamic
MDN is committed to providing documentation for a wide range of web
technologies while continuously adapting to the changing landscape of web
development. We strive to create content that’s relevant and valuable to
developers working across different browsers and platforms. We are dedicated
to regularly updating our resources to reflect the latest standards and best
practices, helping developers stay current in a rapidly changing field.


Our mission
At MDN, our mission is to provide developers with the resources they need to
create innovative and accessible web experiences. We offer a free,
high-quality, and comprehensive platform that includes documentation on
essential web technologies like CSS,
HTML, JavaScript, and
Web APIs. Our learning materials
are tailored for a diverse audience—from beginners and students to professors
teaching web development.

From technical writers and engineers to product and community managers, we are a
diverse group dedicated to driving MDN’s mission, growth, and success. Get to
know the people behind MDN and discover what motivates us to keep you at the
forefront of web development!

Joe Walker

Senior Director

@joewalker
Joe is based in London and has been at Mozilla since 2009. He got interested in Mozilla after suddenly being anointed as the maintainer of Venkman, a precursor to Firebug. He later worked on and managed Firebug and Firefox DevTools. Since 2020, he's managed various teams across Firefox Web Platform, including looking after the core parts of Firefox that you don't usually see—like JavaScript and the DOM. In 2025, he took on the leadership of MDN as well. Joe sometimes works from his office at the bottom of a disused canal, with three chickens and a few newts for company.



Ruth John

Senior Manager

@Rumyra
Based in the UK, Ruth has been working on MDN since 2017. Starting out as a
contracting technical writer documenting fun Web APIs, she joined the team
full-time in 2021 and now heads up the content and community teams. She has
always been a big supporter of the web platform due to her long experience as
a front-end developer and cares deeply about the accuracy and usefulness of
MDN for its developer audience. In her spare time, you can find her walking
her dog Yoshi or in her studio, where she enjoys sewing, sculpting, painting,
and anything else that takes her away from a screen.



Florian Dieminger

Senior Engineering Manager

@fiji-flo
A Berlin resident and a long-time Mozilian, Florian was an active community
member before he joined the Mozilla staff in 2018. His passion for the web
spans across front-end, back-end, browser-engine and anything in-between. He
is a nerd outside of work too and is rediscovering online gaming. He loves
spending time with his family.



Dipika Bhattacharya

Staff Technical Writer

@dipikabh
Dipika works out of Toronto. She joined the MDN team in 2022, bringing her
background in instructional design to the role. She is passionate about
delivering clear and concise documentation to make complex concepts easy to
understand, paying special attention to how information is organized and
presented. She cares about improving the clarity, usability, and
discoverability of MDN’s documentation. Outside of work, she loves exploring
the city, discovering unique coffee shops, and trying different cuisines.



Vadim Makeev

Staff Technical Writer

@pepelsbey
Based in Berlin, Vadim has been working on MDN since 2023. He combines his
previous experience as a front-end developer with a deep passion for browsers
and the web platform. Before joining Mozilla, he worked as a DevRel for the
Opera browser, authored front-end courses, and was also involved in organizing
conferences and meetups. In his spare time, he goes on bikepacking trips,
hangs out on punk gigs, and records podcasts and videos in his home studio.



Brian Smith

Staff Technical Writer

@bsmth
Brian has been with MDN since 2022. He lives in Berlin. With around 20 years
of experience hacking on web technologies and working full-time as a technical
writer since 2016, Brian is passionate about open-source software and writing
docs that make complex concepts fun and easy to grasp for people of all
levels. Before joining Mozilla, Brian worked on a TypeScript-like language
specification, a time series database, and REST API documentation for cloud
services. Outside of work, he enjoys exploring new European destinations with
family, discovering local coffee shops, and using music gear as long as it
doesn't have a screen.



Dave Letorey


Technical Writer





@dletorey


Based in London, UK, Dave has been with MDN since 2022 where he's been focused
on Firefox release documentation, particularly HTML, CSS and SVG updates. He's
passionate about web standards, accessibility, performance and digital
inclusion. He is constantly learning about new web technologies and standards.
Outside of work he loves live music and tries to attend as many gigs and music
festivals as he can. He particularly loves post-punk, indie, house and techno.
He also attends many conferences and meetups and is an organizer of
London Web Standards &
State of the Browser. He also has a large
collection of red hats, so is easy to spot in the wild. He is never happier
than when in a field with his friends.




Chris Mills

Technical Writer and Product Strategist

@chrisdavidmills
Based in Greenfield, UK, Chris has been part of MDN since 2013, initially as a
technical writer and then as the writers' team lead until 2021. He came back
on board as a contractor in 2022 to document new technologies and contribute
to various MDN products and initiatives. Chris loves tinkering with CSS and
JavaScript and is passionate about accessibility and semantics. Outside work,
he is obsessed with loud, heavy music, and plays drums and guitar. He enjoys
cycling, country walks, and spending time with his wife and three awesome
kids.



Hamish Willee

Technical Writer

@hamishwillee
Based in Melbourne, Australia, Hamish has been with MDN since 2014, initially
on short-term contracts for various projects. From 2020, he’s been focused on
Firefox release documentation, particularly Web API and HTTP updates, while
also contributing to other aspects of the open-source project. He’s passionate
about efficient processes that maximize time for creating clear, concise, and
maintainable documentation. Hamish values that his writing reaches thousands
of developers and enjoys working with the diverse community to make expert
knowledge accessible to everyone in a clear format. Outside work, he brews
beer, reads science fiction and fantasy, enjoys running, and likes drones.



Andi Pieper

Staff Software Engineer

@argl
Andi lives in Berlin. He joined the MDN team in 2023. He is focused on keeping
up the high quality of MDN and ensuring that it remains an accessible,
competent, and friendly help for anyone concerned with the web, regardless of
their level of expertise. Growing up with the internet of the 90s, Andi has
worked on a multitude of projects on the web over the years, occasionally
veering off into desktop and mobile development. Apart from his daytime
obligations, he enjoys creating organized noise.



Claas Augner

Senior Software Engineer

@caugner
Based in Paris, Claas has been working as a Software Engineer in the MDN team
since 2022. He is passionate about clean code and continuous improvement. He
enjoys entertaining (the team), and maintaining (the platform). Outside of
work, he loves baking rye sourdough breads and playing cooperative board
games.



Leo McArdle

Senior Software Engineer

@LeoMcA
A London-based long-term Mozilla contributor, Leo has been working on MDN
since 2022 and volunteering for Mozilla since around 2008. As a self-taught
developer, largely through MDN, he cares about making the website discoverable
and functional for everyone. In his free time, he can be found cycling around
the city, photographing panoramas, or watching almost every sport imaginable,
from cricket to karting.



Pranshu Khanna

Staff Community Manager

@pransh15
Pranshu has been a long-term contributor to Mozilla as a Rep. Based in Berlin,
he joined the MDN team in 2024. He works on moderating, growing and managing
MDN’s awesome community. Pranshu is passionate about building a healthy and
inclusive community for developers and helping them build better. Before
working at Mozilla, Pranshu gained extensive experience in growing developer
communities for startups, organizing conferences like GraphQL Conf. 2021 &
2022, and running global programs for devs and students around AI, Web, and
DevOps. In his free time, he likes to play football in any form - physical,
digital, and fantasy.



Anuja Rajput

Senior User Experience Designer

@AnujaRajput727
Located in London, Anuja has been a part of the MDN team since 2023. With over
8 years of experience, she has passionately contributed to various phases of
product development, including design, business analysis, and testing. She is
empathetic and deeply cares about understanding users' perspectives and pain
points. She combines her work experience with her creative skills to enhance
her UX designs. In her free time, she enjoys painting, sketching, and travel
sketching.



Sonal Sood

Senior Product Manager

@s-sood
Sonal lives in Berlin. She has been with MDN since 2022. As a product manager,
she is adept at identifying and prioritizing features that truly meet users'
needs. With a strong background in data analysis and product management, she
is always focused on delivering valuable and impactful products that make a
difference. In her free time, Sonal enjoys cycling, running, and practicing
yoga.



Miruna Curtean

Quality Assurance

@mirunacurtean
Miruna calls Cluj-Napoca, Romania home. Contracting with Mozilla since 2019,
she worked on Firefox Add-ons and Mozilla Support before switching to MDN
in 2022. She focuses on analyzing requirements and community issues, building
comprehensive test bases, and ensuring delivered features meet requirements.
Before Mozilla, she worked in game development and e-commerce but found
greater joy in website development, particularly inspired by its community
aspect. Outside of work, Miruna enjoys story-based entertainment including
books, movies, shows, anime, and podcasts.


Product Advisory Board

Rachel Andrew

Content Lead at Google

Rachel has been working on the web as a developer since 1996 and writing about web development for almost as long. She now works for Google as Content Lead for Chrome Developer Relations, owning the content strategy of web.dev and developer.chrome.com, and is also a lead on the Baseline project. Rachel is a CSS Working Group member and specification editor, and in the past has been a contributor to MDN as a contractor for Mozilla and for Google.
Photo © Drew McLellan.



Robert Nyman

Web Developer Relations at Google

Robert wants to make the web the best platform for developers and has always been heavily invested in the community and helping developers succeed. Prior to Google, Robert was a technical evangelist at Mozilla, focused on the Open Web and the company's various products and initiatives. He's a co-founder of Open Web Docs, lives in Stockholm, has a passion for traveling and meeting people, and has given presentations in 42 countries.



Patrick Brosset

Senior Product Manager, Microsoft Edge

Patrick Brosset is a senior Product Manager on the Microsoft Edge web platform team, where he drives efforts around developer advocacy, documentation, and evangelism for the web platform. Patrick has worked with the web for more than 20 years, and on web browsers at Mozilla and Microsoft, including on developer tools, web apps, and the rendering engine for over a decade. He is a member of the Governing Committee at Open Web Docs, and a co-chair of the W3C WebDX Community Group.



Dominique Hazael-Massieux

Web Technology Expert including Web, W3C

Dominique Hazael-Massieux is part of the W3C staff, leading W3C
efforts in developer relations. Dom has been working for W3C since 2000,
and in addition to dev rel, is currently involved in the standardization
of WebRTC, WebNN and looking over the systemic impact of AI on the Web.
Dom also sits on the W3C Board of Directors and on the Open Web Docs
Governing Committee.



Carmen Cañas

Technical Project Manager, Bocoup

Carmen Cañas is part of the worker-owner team at Bocoup where she manages web platform projects and product development projects with a special focus on accessibility and privacy. Before joining Bocoup, she spent over 10 years building open source projects in Latin America and Africa, with a focus on implementing open data standards for publishing government data.  Carmen lives between Cuzcatlán (El Salvador) and Tkaronto (Toronto).



Laura Morinigo

Web Developer Advocate

Laura is a software developer, advocate, and mentor, passionate about sharing her knowledge and connecting with tech communities worldwide. She has been recognized as a Google Developer Expert and a Woman Techmakers Ambassador for her contributions. As a mentor, she has supported startups in accelerator programs like Google Launchpad and the United Nations’ World Food Programme. Currently, Laura contributes to web standards and advocates for advanced web features, helping developers build more inclusive and impactful web applications.




Open Web Docs
Open Web Docs (OWD), an independent open source organization, is one of the most productive contributors to MDN Web Docs. OWD contributes as part of their mission to support “web platform documentation for the benefit of web developers & designers worldwide.” The team at OWD has led or contributed to many projects to improve documentation on MDN. They're an invaluable partner in the day-to-day work of making MDN. Read more about OWD’s activities in their 2024 Impact and Transparency Report and get continuous updates on their Mastodon account.

Florian Scholz

Director

@Elchi3
Florian Scholz is the Director of Open Web Docs. He began volunteer editing MDN as a teen in 2009 and previously worked at Mozilla as MDN's Lead Content Strategist, Technical Writer & Documentation Engineer from 2013 until 2020. He's one of the creators of the browser compatibility data (BCD) project and it makes him happy when open source projects collaborate. He lives in Bremen, Germany; not Berlin. Other than submitting and reviewing PRs on GitHub, he enjoys listening to wave and post-punk music.



Will Bamberg

Sr. Technical Writer and Documentation Engineer

@wbamberg
Will Bamberg is a perfectionist and professional pedant who has been writing about the web for a long time, mostly on MDN. He enjoys learning about new aspects of the web platform and then turning that knowledge into accessible documentation. He believes that writing good documentation depends on understanding what it's like for someone who is learning something new or looking for the answer to their question.



Estelle Weyl

Sr. Technical Writer and Developer Advocate

@estelle
Estelle Weyl is a Sr. Technical Writer and Developer Advocate on the Open Web Docs team. She is a frontend engineer, writing CSS, JS and HTML since 1999. Estelle has always been a web standardista, advocating for a free, accessible, and performant web. Estelle has been documenting and teaching web standards since 2007, writing numerous books, blogs, and tutorials. She’s typing with her cat (who thinks he's a dog) and dog (who thinks she's a cat) in San Francisco.



Queen Vinyl Da.i'gyu-Kazotetsu

Compat Data Engineer

@queengooborg
Vinyl works for Open Web Docs leading the browser compatibility data (BCD) project that millions of developers around the world rely on. Previously a contractor at Google and Mozilla and a long-time BCD community member, Vinyl has a lot of experience with compatibility on the open web. She was already the number #1 contributor to the BCD repository before officially joining our team! When she's not submitting pull requests to BCD, she's usually slicing blocks to the music in Beat Saber or staffing at various conventions across the globe.


Global impactServing over 15 million users monthly from around the globe, MDN connects
developers with the tools and information they need to easily build projects on
the open web.


Educational influence: Our resources are integral to many coding bootcamps and
university courses worldwide.


Trusted reference: Platforms like freeCodeCamp and Codecademy frequently link
to MDN articles as authoritative references.


Industry standard: Tools like Can I use leverage
MDN’s browser compatibility data
for up-to-date information on web feature support across browsers.


Collaborative partnerships: We work closely with partners such as
Open Web Docs,
Microsoft,
Google, Igalia,
W3C, and others to drive web innovation and serve the
common good.

Join us in building a better webBe a part of our mission to foster innovation and inclusivity on the web.
Start contributing today and make a lasting impact
on the global developer community.\n\n\n\n\n\n\n\n\n\nCreating and working on issuesAs a contributor, you can report and work on issues.
After you report an issue, the issue gets triaged. Issue triaging is typically done by people assigned the role of a maintainer or an owner.General guidelines for participationWhile reporting an issue or participating in a conversation in an issue, always ensure that your inputs are contributing to the overall progress of the project. Consider whether the issues you open and your comments in an issue are constructive and on topic and are not just adding noise.
Do the following:

Before filing an issue, consider if you need to discuss it with the staff/community. Use discussions to gain different viewpoints and to converge on an agreed-upon course of action. This helps to keep issues focused and productive.
After filing an issue, try to fix the problem yourself. Read our contribution guide to learn more.
If you have a question, you can ask it in the MDN Web Docs chat rooms instead of filing an issue.

Avoid doing the following:

Complicating issues by trying to discuss multiple topics or by making off-topic comments.
Opening lots of issues asking vague questions.
Asking questions without trying to solve the problem yourself first.
Guidelines for reporting an issueIssues are used to track bugs. An issue must be a single actionable task or a collection of related actionable tasks and must have a clear outcome.Before filing an issueIf you think you've found a bug with the content on MDN Web Docs or with the look and feel of the website, search the current open issues in the relevant repository and make sure nobody else has reported the issue.Reporting an issueDepending on the type of problem you've discovered, you can report it by filing an issue on one of the main MDN GitHub repositories.
If the information you provide in the issue is incomplete, you might be asked to provide more details during the issue triaging process.
Here are some hints for opening issues:

Choose the appropriate category to report the issue. For example, to report a content bug, use the Content issue template in the mdn/content repository.
Provide sufficient information while reporting the issue:

Issue title must convey succinctly the required action.
Issue description must clearly describe the bug and the action required to resolve the issue. It must also list the task or sub-tasks to be completed to resolve the issue. Some other guidelines include:

Use the description field to indicate the status of the task or sub-tasks by using checklists.
Update the status of a task in the issue description instead of commenting on the issue. Use task lists in the description if an issue has multiple parts. This helps others who may otherwise need to scroll through comments on the issue to determine the status of various tasks.
Comments in an issue should be limited to details or context that help resolve the issue.




If you find yourself in one of the following situations, move the conversation to MDN's discussion on GitHub:

A discussion needs to take place to clarify an issue.
A discussion begins after opening the issue.
The issue has no clear consensus on its resolution.
The requirements for completing the task expand while it's being resolved or the work is unclear.


For minor bugs, you can make the changes yourself and submit a pull request.
Creating a task list issueIf the issue you're opening is not to report a bug but to perform a series of tasks, you can create the issue as a task list.
Explain the context or reason for performing the tasks in the description.
Ensure that you list all the actionable tasks as a checklist.
For example:
md// Issue title
Ensure sections follow the order defined in the CSS property template

### Description

The CSS property page template is defined [here](/en-US/docs/MDN/Writing_guidelines/Page_structures/Page_types/CSS_property_page_template).
The task list in this issue will be used to compare the documented CSS properties with the template and track changes to the property pages for compliance.

### List of pages checked

- [x] [accent-color](/en-US/docs/Web/CSS/accent-color) - checked, okay
- [ ] [backdrop-filter](/en-US/docs/Web/CSS/backdrop-filter)
- [ ] [letter-spacing](/en-US/docs/Web/CSS/letter-spacing) - open pull request to move `Accessibility concerns` and `Internationalization concerns` sections before the `Specifications` section.
Guidelines for working on an issueRemember that if you take on an issue, the expectation is for the work to be completed in a timely manner. If you're not able to make any progress for a week after being assigned or can no longer complete the required task, leave a comment and unassign yourself from the issue.
These are the general steps for working on an issue:


Find an issue: If you're looking to contribute, search for issues with good first issue, help wanted or p3 label. Most repositories have issues with these labels. You are welcome to browse and pick an issue that is suitable for your skill set. Another useful place to look for issues to work on is the MDN Contributors Task Board. This project view lists open issues from multiple repositories. You can filter the list based on the topics (Labels column) you're interested in. See the description of some of the labels that get applied during the issue triage process.

Note:
An issue with the needs triage label indicates that the MDN Web Docs core team has not reviewed the issue yet, and you shouldn't begin work on it.



Assign the issue to yourself: After finding an issue you'd like to work on, make sure that the issue is not assigned to anybody else. Add a comment saying you would like to work on the issue, and if you are able to, assign the issue to yourself.


Do the research: Most issues need some investigation before work can start.

Scope out the work that needs to be done. If you need to ask questions, ask them in the MDN Web Docs chat rooms.
If the issue is well-described, and the work is pretty obvious, go ahead and do it.
If the issue is not well-described, and/or you are not sure what is needed, feel free to @mention the poster and ask for more information.



Make the changes: Fork and branch the repository. Do your work and open a pull request in the repository. Reference the issue in the pull request description. Depending on the files you've updated in the pull request, a reviewer will be assigned to your pull request automatically. (Teams per topic area are defined in the CODEOWNERS file).
After opening the pull request, if you find you no longer have the time to make changes or incorporate review feedback, let the team know as soon as possible in a comment in the pull request. This will help the team assign another interested contributor to complete the work on the pull request and close the linked issue.


After your pull request has been reviewed and merged, you can mark the linked issue as closed. If you opened the pull request with Fixes #<issue> verbiage, the issue will be closed automatically when the pull request is merged.

Fixing issues yourselfIf you spot a bug — whether it's a problem with the website's look and feel or an error in documentation — you can try to fix it yourself. Learn how you can contribute by going through our contribution guide.
If the bug is small, such as a typo or a minor sentence improvement, or involves an uncontroversial fix, submit a pull request with the changes.
For all other type of bugs, begin by opening the issue. Add a comment about your intent to work on the issue and if possible, describe your proposed solution or steps to fix the issue.
Wait for the issue to be triaged, so that the MDN Web Docs team can verify that the issue is legit and approves your proposed solution.

Note:
If you open a pull request before the issue has been triaged, your time and effort might go waste if the linked issue is deemed invalid or the solution does not match the one expected by the MDN Web Docs team.
After the issue is triaged, assign the issue to yourself.

Using the guidelines on working on an issue, try to fix the problem by updating the appropriate source, such as:

The MDN Web Docs content (in English) in the mdn/content repository
The MDN Web Docs translated content in the mdn/translated-content repository
The MDN Web Docs frontend in the mdn/yari repository

Each repository includes useful information to guide you on how to contribute.
For more information, see our main GitHub repositories.Guidelines for triaging issuesIf you are a maintainer or an owner in the MDN Web Docs GitHub organization, you are responsible for triaging issues in one or more MDN Web Docs repository.
The overall process for triaging includes some general and some issue-specific tasks.General triaging tasks

When an issue is opened, the needs triage label is set on the issue automatically. You can search for this label to look for issues that need to be triaged. Contributors or anybody else should not work on the issue until the issue has been triaged. (Triagers should remember to remove the needs triage label after triaging the issue.)


In the mdn/content repository, an additional Content: label, such as Content:CSS or Content:WebAPI, is set on the issue automatically. This gets set based on the MDN URL mentioned in the issue. You can use the content-specific label to look for issues to be triaged in your specific topic area.


If an issue concerns an active, non-en-US locale, set the appropriate label, such as l10n-fr, l10n-zh, or l10n-ja. The teams for those locales will pick these issues up and triage them.


You don't need to actively triage issues all the time. Set aside time, say 30 minutes every week, to triage issues on a regular basis in your area of responsibility. Triaging doesn't have to be done as part of a synchronous meeting or even at the same time as everyone else, but it should be done regularly to make sure that the backlog of untriaged bugs doesn't get too high.


Apart from triaging incoming issues every week, review the list of old bugs to see if there are any that are stalled, need closing, or are no longer relevant. The idle label is automatically set on issues that have had no activity for 30 days.

Check assigned issues that are still open to see if the assignee is making progress. If there is no progress after a week of being assigned, ask them if they still have time to work on the issue. If another week passes by without any progress, unassign them and leave a comment indicating that you're making the issue available for other interested contributors.
If a pull request has been opened to fix the issue but has not been reviewed for a week, give the reviewer a gentle ping to ask if they can get to it.
If a pull request to fix the issue is waiting on review comments to be addressed after a week, then ask the author if they can respond to their review. If another week goes by, either fix the review comments yourself if you have time, or close the pull request and unassign the related issue.


Issue-specific triaging tasksThese are the guidelines to follow while triaging each issue.
Review if the issue is valid
These are some of the things to keep in mind while reviewing the validity of an issue:

Check if the issue raised is valid and if the fix will improve the content for the readers and the website.
Evaluate if the impact of the fix will be small or site-wide.
Evaluate if the fix for the issue will need a discussion first, in which case, point the author to open a discussion instead.
Check if the issue complies with our writing guidelines and templates.
Check whether suggestions for adding links comply with our external links policy.

Review the issue for completeness of information
Review each issue against the following checklist to ensure that the issue contains the described information for someone to start working on the bug:

URL of the MDN Web Docs page with the problem or URL of an example MDN Web Docs page if the problem exists on multiple pages
The specific heading or section on the MDN Web Docs page where the problem was found
A clear description of the incorrect, unhelpful, incomplete, or missing information

If any of the above information is not present, then you should ask the author of the issue to provide these details, and add the needs info label to the issue. Resume triaging the issue only after those details have been provided (after which, you can remove the needs info label). It is okay to wait for up to a week to get a response from the author.
Set a priority label
For each bug, set a priority label based on the severity of the issue to help people who want to work on the most important issues or areas.


Critical issue: This type of issue needs to be fixed as soon as possible, regardless of where it appears on the site. This type of issue could damage MDN's reputation severely and/or harm users. Examples of this issue include an incorrect code snippet, which if used in production, could create a severe security problem and undesirable content such as malware, profanity, pornography, hate speech, or links to such content.

Label: p0 (will be addressed immediately)



Major issue: This type of issue could severely affect a page's usefulness. For example, a significant amount of out-of-date information, a complex and important code example that doesn't work, a significant amount of prose that is badly written and hard to understand, or a large number of broken links.

Labels: p1 (will be addressed soon) and p2 (will be addressed soon, but higher priority items will take precedence)



Minor issue: This is a type of improvement issue that can make the existing content better but does not affect learning or only has a minor effect on learning. Since these types of issues are not actively planned for, help from contributors to fix these issues is welcome and much appreciated. Fixing some of these issues can also provide the necessary practice to beginner contributors who are starting to get familiar with the contribution process. Examples include typos, bad grammar, a broken link, a small amount of out-of-date information or badly-written prose, or a code snippet that doesn't work.

Labels: p3 (no visibility when the issue will be addressed)



In general, critical issues should be fixed immediately and are most likely handled by MDN Web Docs staff and peers.
Add helpful information
If possible, add information that can help contributors to fix the issue. The information can be in the form of steps, general approach, links to other similar fixed issues, or reading resources. A well-laid out plan or steps is especially required in issues that are labeled good first issue and can help ramp up new contributors quickly. You can time-box this task to 5-10 minutes.
For example, as a triager, you can add the following information to the issue you are triaging:
mdTo whoever fixes this issue, it looks like the following is needed:

- Update the first paragraph below heading X to correct the problem with Y
- Add a description of X
- Update the compatibility data at Link-X

Set other labels
Next, set the following labels as appropriate:


effort: small, effort: medium, effort: large: Some contributors like to search for bugs based on the time and effort that will be needed to fix the bug. So where possible, you should try to provide an estimate of the required effort.


good first issue: Set this label on the issue if the fix for the issue is really simple and if fixing the issue would provide good practice for a newcomer who is getting used to the process.


help wanted: Set this label if the issue requires help from someone who knows about or is familiar with the topic. This is a popular label and some contributors use it to search for issues to work on in open source projects in their areas of familiarity or expertise.


broken link external: Set this label if the issue involves a broken link to an external page.


document not written: Set this label if the issue involves a necessary document that has not been written yet, usually because a link points to it.


needs content update: Set this label if the issue fix in another repository will need an equivalent fix in the mdn/content repository.

Note:
After the triage process is complete, remove the needs triage label.\n\nCreating and working on issuesAs a contributor, you can report and work on issues.
After you report an issue, the issue gets triaged. Issue triaging is typically done by people assigned the role of a maintainer or an owner.General guidelines for participationWhile reporting an issue or participating in a conversation in an issue, always ensure that your inputs are contributing to the overall progress of the project. Consider whether the issues you open and your comments in an issue are constructive and on topic and are not just adding noise.
Do the following:

Before filing an issue, consider if you need to discuss it with the staff/community. Use discussions to gain different viewpoints and to converge on an agreed-upon course of action. This helps to keep issues focused and productive.
After filing an issue, try to fix the problem yourself. Read our contribution guide to learn more.
If you have a question, you can ask it in the MDN Web Docs chat rooms instead of filing an issue.

Avoid doing the following:

Complicating issues by trying to discuss multiple topics or by making off-topic comments.
Opening lots of issues asking vague questions.
Asking questions without trying to solve the problem yourself first.
Guidelines for reporting an issueIssues are used to track bugs. An issue must be a single actionable task or a collection of related actionable tasks and must have a clear outcome.Before filing an issueIf you think you've found a bug with the content on MDN Web Docs or with the look and feel of the website, search the current open issues in the relevant repository and make sure nobody else has reported the issue.Reporting an issueDepending on the type of problem you've discovered, you can report it by filing an issue on one of the main MDN GitHub repositories.
If the information you provide in the issue is incomplete, you might be asked to provide more details during the issue triaging process.
Here are some hints for opening issues:

Choose the appropriate category to report the issue. For example, to report a content bug, use the Content issue template in the mdn/content repository.
Provide sufficient information while reporting the issue:

Issue title must convey succinctly the required action.
Issue description must clearly describe the bug and the action required to resolve the issue. It must also list the task or sub-tasks to be completed to resolve the issue. Some other guidelines include:

Use the description field to indicate the status of the task or sub-tasks by using checklists.
Update the status of a task in the issue description instead of commenting on the issue. Use task lists in the description if an issue has multiple parts. This helps others who may otherwise need to scroll through comments on the issue to determine the status of various tasks.
Comments in an issue should be limited to details or context that help resolve the issue.




If you find yourself in one of the following situations, move the conversation to MDN's discussion on GitHub:

A discussion needs to take place to clarify an issue.
A discussion begins after opening the issue.
The issue has no clear consensus on its resolution.
The requirements for completing the task expand while it's being resolved or the work is unclear.


For minor bugs, you can make the changes yourself and submit a pull request.
Creating a task list issueIf the issue you're opening is not to report a bug but to perform a series of tasks, you can create the issue as a task list.
Explain the context or reason for performing the tasks in the description.
Ensure that you list all the actionable tasks as a checklist.
For example:
md// Issue title
Ensure sections follow the order defined in the CSS property template

### Description

The CSS property page template is defined [here](/en-US/docs/MDN/Writing_guidelines/Page_structures/Page_types/CSS_property_page_template).
The task list in this issue will be used to compare the documented CSS properties with the template and track changes to the property pages for compliance.

### List of pages checked

- [x] [accent-color](/en-US/docs/Web/CSS/accent-color) - checked, okay
- [ ] [backdrop-filter](/en-US/docs/Web/CSS/backdrop-filter)
- [ ] [letter-spacing](/en-US/docs/Web/CSS/letter-spacing) - open pull request to move `Accessibility concerns` and `Internationalization concerns` sections before the `Specifications` section.
Guidelines for working on an issueRemember that if you take on an issue, the expectation is for the work to be completed in a timely manner. If you're not able to make any progress for a week after being assigned or can no longer complete the required task, leave a comment and unassign yourself from the issue.
These are the general steps for working on an issue:


Find an issue: If you're looking to contribute, search for issues with good first issue, help wanted or p3 label. Most repositories have issues with these labels. You are welcome to browse and pick an issue that is suitable for your skill set. Another useful place to look for issues to work on is the MDN Contributors Task Board. This project view lists open issues from multiple repositories. You can filter the list based on the topics (Labels column) you're interested in. See the description of some of the labels that get applied during the issue triage process.

Note:
An issue with the needs triage label indicates that the MDN Web Docs core team has not reviewed the issue yet, and you shouldn't begin work on it.



Assign the issue to yourself: After finding an issue you'd like to work on, make sure that the issue is not assigned to anybody else. Add a comment saying you would like to work on the issue, and if you are able to, assign the issue to yourself.


Do the research: Most issues need some investigation before work can start.

Scope out the work that needs to be done. If you need to ask questions, ask them in the MDN Web Docs chat rooms.
If the issue is well-described, and the work is pretty obvious, go ahead and do it.
If the issue is not well-described, and/or you are not sure what is needed, feel free to @mention the poster and ask for more information.



Make the changes: Fork and branch the repository. Do your work and open a pull request in the repository. Reference the issue in the pull request description. Depending on the files you've updated in the pull request, a reviewer will be assigned to your pull request automatically. (Teams per topic area are defined in the CODEOWNERS file).
After opening the pull request, if you find you no longer have the time to make changes or incorporate review feedback, let the team know as soon as possible in a comment in the pull request. This will help the team assign another interested contributor to complete the work on the pull request and close the linked issue.


After your pull request has been reviewed and merged, you can mark the linked issue as closed. If you opened the pull request with Fixes #<issue> verbiage, the issue will be closed automatically when the pull request is merged.

Fixing issues yourselfIf you spot a bug — whether it's a problem with the website's look and feel or an error in documentation — you can try to fix it yourself. Learn how you can contribute by going through our contribution guide.
If the bug is small, such as a typo or a minor sentence improvement, or involves an uncontroversial fix, submit a pull request with the changes.
For all other type of bugs, begin by opening the issue. Add a comment about your intent to work on the issue and if possible, describe your proposed solution or steps to fix the issue.
Wait for the issue to be triaged, so that the MDN Web Docs team can verify that the issue is legit and approves your proposed solution.

Note:
If you open a pull request before the issue has been triaged, your time and effort might go waste if the linked issue is deemed invalid or the solution does not match the one expected by the MDN Web Docs team.
After the issue is triaged, assign the issue to yourself.

Using the guidelines on working on an issue, try to fix the problem by updating the appropriate source, such as:

The MDN Web Docs content (in English) in the mdn/content repository
The MDN Web Docs translated content in the mdn/translated-content repository
The MDN Web Docs frontend in the mdn/yari repository

Each repository includes useful information to guide you on how to contribute.
For more information, see our main GitHub repositories.Guidelines for triaging issuesIf you are a maintainer or an owner in the MDN Web Docs GitHub organization, you are responsible for triaging issues in one or more MDN Web Docs repository.
The overall process for triaging includes some general and some issue-specific tasks.General triaging tasks

When an issue is opened, the needs triage label is set on the issue automatically. You can search for this label to look for issues that need to be triaged. Contributors or anybody else should not work on the issue until the issue has been triaged. (Triagers should remember to remove the needs triage label after triaging the issue.)


In the mdn/content repository, an additional Content: label, such as Content:CSS or Content:WebAPI, is set on the issue automatically. This gets set based on the MDN URL mentioned in the issue. You can use the content-specific label to look for issues to be triaged in your specific topic area.


If an issue concerns an active, non-en-US locale, set the appropriate label, such as l10n-fr, l10n-zh, or l10n-ja. The teams for those locales will pick these issues up and triage them.


You don't need to actively triage issues all the time. Set aside time, say 30 minutes every week, to triage issues on a regular basis in your area of responsibility. Triaging doesn't have to be done as part of a synchronous meeting or even at the same time as everyone else, but it should be done regularly to make sure that the backlog of untriaged bugs doesn't get too high.


Apart from triaging incoming issues every week, review the list of old bugs to see if there are any that are stalled, need closing, or are no longer relevant. The idle label is automatically set on issues that have had no activity for 30 days.

Check assigned issues that are still open to see if the assignee is making progress. If there is no progress after a week of being assigned, ask them if they still have time to work on the issue. If another week passes by without any progress, unassign them and leave a comment indicating that you're making the issue available for other interested contributors.
If a pull request has been opened to fix the issue but has not been reviewed for a week, give the reviewer a gentle ping to ask if they can get to it.
If a pull request to fix the issue is waiting on review comments to be addressed after a week, then ask the author if they can respond to their review. If another week goes by, either fix the review comments yourself if you have time, or close the pull request and unassign the related issue.


Issue-specific triaging tasksThese are the guidelines to follow while triaging each issue.
Review if the issue is valid
These are some of the things to keep in mind while reviewing the validity of an issue:

Check if the issue raised is valid and if the fix will improve the content for the readers and the website.
Evaluate if the impact of the fix will be small or site-wide.
Evaluate if the fix for the issue will need a discussion first, in which case, point the author to open a discussion instead.
Check if the issue complies with our writing guidelines and templates.
Check whether suggestions for adding links comply with our external links policy.

Review the issue for completeness of information
Review each issue against the following checklist to ensure that the issue contains the described information for someone to start working on the bug:

URL of the MDN Web Docs page with the problem or URL of an example MDN Web Docs page if the problem exists on multiple pages
The specific heading or section on the MDN Web Docs page where the problem was found
A clear description of the incorrect, unhelpful, incomplete, or missing information

If any of the above information is not present, then you should ask the author of the issue to provide these details, and add the needs info label to the issue. Resume triaging the issue only after those details have been provided (after which, you can remove the needs info label). It is okay to wait for up to a week to get a response from the author.
Set a priority label
For each bug, set a priority label based on the severity of the issue to help people who want to work on the most important issues or areas.


Critical issue: This type of issue needs to be fixed as soon as possible, regardless of where it appears on the site. This type of issue could damage MDN's reputation severely and/or harm users. Examples of this issue include an incorrect code snippet, which if used in production, could create a severe security problem and undesirable content such as malware, profanity, pornography, hate speech, or links to such content.

Label: p0 (will be addressed immediately)



Major issue: This type of issue could severely affect a page's usefulness. For example, a significant amount of out-of-date information, a complex and important code example that doesn't work, a significant amount of prose that is badly written and hard to understand, or a large number of broken links.

Labels: p1 (will be addressed soon) and p2 (will be addressed soon, but higher priority items will take precedence)



Minor issue: This is a type of improvement issue that can make the existing content better but does not affect learning or only has a minor effect on learning. Since these types of issues are not actively planned for, help from contributors to fix these issues is welcome and much appreciated. Fixing some of these issues can also provide the necessary practice to beginner contributors who are starting to get familiar with the contribution process. Examples include typos, bad grammar, a broken link, a small amount of out-of-date information or badly-written prose, or a code snippet that doesn't work.

Labels: p3 (no visibility when the issue will be addressed)



In general, critical issues should be fixed immediately and are most likely handled by MDN Web Docs staff and peers.
Add helpful information
If possible, add information that can help contributors to fix the issue. The information can be in the form of steps, general approach, links to other similar fixed issues, or reading resources. A well-laid out plan or steps is especially required in issues that are labeled good first issue and can help ramp up new contributors quickly. You can time-box this task to 5-10 minutes.
For example, as a triager, you can add the following information to the issue you are triaging:
mdTo whoever fixes this issue, it looks like the following is needed:

- Update the first paragraph below heading X to correct the problem with Y
- Add a description of X
- Update the compatibility data at Link-X

Set other labels
Next, set the following labels as appropriate:


effort: small, effort: medium, effort: large: Some contributors like to search for bugs based on the time and effort that will be needed to fix the bug. So where possible, you should try to provide an estimate of the required effort.


good first issue: Set this label on the issue if the fix for the issue is really simple and if fixing the issue would provide good practice for a newcomer who is getting used to the process.


help wanted: Set this label if the issue requires help from someone who knows about or is familiar with the topic. This is a popular label and some contributors use it to search for issues to work on in open source projects in their areas of familiarity or expertise.


broken link external: Set this label if the issue involves a broken link to an external page.


document not written: Set this label if the issue involves a necessary document that has not been written yet, usually because a link points to it.


needs content update: Set this label if the issue fix in another repository will need an equivalent fix in the mdn/content repository.

Note:
After the triage process is complete, remove the needs triage label.


Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 7, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nCreating and working on issuesAs a contributor, you can report and work on issues.
After you report an issue, the issue gets triaged. Issue triaging is typically done by people assigned the role of a maintainer or an owner.General guidelines for participationWhile reporting an issue or participating in a conversation in an issue, always ensure that your inputs are contributing to the overall progress of the project. Consider whether the issues you open and your comments in an issue are constructive and on topic and are not just adding noise.
Do the following:

Before filing an issue, consider if you need to discuss it with the staff/community. Use discussions to gain different viewpoints and to converge on an agreed-upon course of action. This helps to keep issues focused and productive.
After filing an issue, try to fix the problem yourself. Read our contribution guide to learn more.
If you have a question, you can ask it in the MDN Web Docs chat rooms instead of filing an issue.

Avoid doing the following:

Complicating issues by trying to discuss multiple topics or by making off-topic comments.
Opening lots of issues asking vague questions.
Asking questions without trying to solve the problem yourself first.
Guidelines for reporting an issueIssues are used to track bugs. An issue must be a single actionable task or a collection of related actionable tasks and must have a clear outcome.Before filing an issueIf you think you've found a bug with the content on MDN Web Docs or with the look and feel of the website, search the current open issues in the relevant repository and make sure nobody else has reported the issue.Reporting an issueDepending on the type of problem you've discovered, you can report it by filing an issue on one of the main MDN GitHub repositories.
If the information you provide in the issue is incomplete, you might be asked to provide more details during the issue triaging process.
Here are some hints for opening issues:

Choose the appropriate category to report the issue. For example, to report a content bug, use the Content issue template in the mdn/content repository.
Provide sufficient information while reporting the issue:

Issue title must convey succinctly the required action.
Issue description must clearly describe the bug and the action required to resolve the issue. It must also list the task or sub-tasks to be completed to resolve the issue. Some other guidelines include:

Use the description field to indicate the status of the task or sub-tasks by using checklists.
Update the status of a task in the issue description instead of commenting on the issue. Use task lists in the description if an issue has multiple parts. This helps others who may otherwise need to scroll through comments on the issue to determine the status of various tasks.
Comments in an issue should be limited to details or context that help resolve the issue.




If you find yourself in one of the following situations, move the conversation to MDN's discussion on GitHub:

A discussion needs to take place to clarify an issue.
A discussion begins after opening the issue.
The issue has no clear consensus on its resolution.
The requirements for completing the task expand while it's being resolved or the work is unclear.


For minor bugs, you can make the changes yourself and submit a pull request.
Creating a task list issueIf the issue you're opening is not to report a bug but to perform a series of tasks, you can create the issue as a task list.
Explain the context or reason for performing the tasks in the description.
Ensure that you list all the actionable tasks as a checklist.
For example:
md// Issue title
Ensure sections follow the order defined in the CSS property template

### Description

The CSS property page template is defined [here](/en-US/docs/MDN/Writing_guidelines/Page_structures/Page_types/CSS_property_page_template).
The task list in this issue will be used to compare the documented CSS properties with the template and track changes to the property pages for compliance.

### List of pages checked

- [x] [accent-color](/en-US/docs/Web/CSS/accent-color) - checked, okay
- [ ] [backdrop-filter](/en-US/docs/Web/CSS/backdrop-filter)
- [ ] [letter-spacing](/en-US/docs/Web/CSS/letter-spacing) - open pull request to move `Accessibility concerns` and `Internationalization concerns` sections before the `Specifications` section.
Guidelines for working on an issueRemember that if you take on an issue, the expectation is for the work to be completed in a timely manner. If you're not able to make any progress for a week after being assigned or can no longer complete the required task, leave a comment and unassign yourself from the issue.
These are the general steps for working on an issue:


Find an issue: If you're looking to contribute, search for issues with good first issue, help wanted or p3 label. Most repositories have issues with these labels. You are welcome to browse and pick an issue that is suitable for your skill set. Another useful place to look for issues to work on is the MDN Contributors Task Board. This project view lists open issues from multiple repositories. You can filter the list based on the topics (Labels column) you're interested in. See the description of some of the labels that get applied during the issue triage process.

Note:
An issue with the needs triage label indicates that the MDN Web Docs core team has not reviewed the issue yet, and you shouldn't begin work on it.



Assign the issue to yourself: After finding an issue you'd like to work on, make sure that the issue is not assigned to anybody else. Add a comment saying you would like to work on the issue, and if you are able to, assign the issue to yourself.


Do the research: Most issues need some investigation before work can start.

Scope out the work that needs to be done. If you need to ask questions, ask them in the MDN Web Docs chat rooms.
If the issue is well-described, and the work is pretty obvious, go ahead and do it.
If the issue is not well-described, and/or you are not sure what is needed, feel free to @mention the poster and ask for more information.



Make the changes: Fork and branch the repository. Do your work and open a pull request in the repository. Reference the issue in the pull request description. Depending on the files you've updated in the pull request, a reviewer will be assigned to your pull request automatically. (Teams per topic area are defined in the CODEOWNERS file).
After opening the pull request, if you find you no longer have the time to make changes or incorporate review feedback, let the team know as soon as possible in a comment in the pull request. This will help the team assign another interested contributor to complete the work on the pull request and close the linked issue.


After your pull request has been reviewed and merged, you can mark the linked issue as closed. If you opened the pull request with Fixes #<issue> verbiage, the issue will be closed automatically when the pull request is merged.

Fixing issues yourselfIf you spot a bug — whether it's a problem with the website's look and feel or an error in documentation — you can try to fix it yourself. Learn how you can contribute by going through our contribution guide.
If the bug is small, such as a typo or a minor sentence improvement, or involves an uncontroversial fix, submit a pull request with the changes.
For all other type of bugs, begin by opening the issue. Add a comment about your intent to work on the issue and if possible, describe your proposed solution or steps to fix the issue.
Wait for the issue to be triaged, so that the MDN Web Docs team can verify that the issue is legit and approves your proposed solution.

Note:
If you open a pull request before the issue has been triaged, your time and effort might go waste if the linked issue is deemed invalid or the solution does not match the one expected by the MDN Web Docs team.
After the issue is triaged, assign the issue to yourself.

Using the guidelines on working on an issue, try to fix the problem by updating the appropriate source, such as:

The MDN Web Docs content (in English) in the mdn/content repository
The MDN Web Docs translated content in the mdn/translated-content repository
The MDN Web Docs frontend in the mdn/yari repository

Each repository includes useful information to guide you on how to contribute.
For more information, see our main GitHub repositories.Guidelines for triaging issuesIf you are a maintainer or an owner in the MDN Web Docs GitHub organization, you are responsible for triaging issues in one or more MDN Web Docs repository.
The overall process for triaging includes some general and some issue-specific tasks.General triaging tasks

When an issue is opened, the needs triage label is set on the issue automatically. You can search for this label to look for issues that need to be triaged. Contributors or anybody else should not work on the issue until the issue has been triaged. (Triagers should remember to remove the needs triage label after triaging the issue.)


In the mdn/content repository, an additional Content: label, such as Content:CSS or Content:WebAPI, is set on the issue automatically. This gets set based on the MDN URL mentioned in the issue. You can use the content-specific label to look for issues to be triaged in your specific topic area.


If an issue concerns an active, non-en-US locale, set the appropriate label, such as l10n-fr, l10n-zh, or l10n-ja. The teams for those locales will pick these issues up and triage them.


You don't need to actively triage issues all the time. Set aside time, say 30 minutes every week, to triage issues on a regular basis in your area of responsibility. Triaging doesn't have to be done as part of a synchronous meeting or even at the same time as everyone else, but it should be done regularly to make sure that the backlog of untriaged bugs doesn't get too high.


Apart from triaging incoming issues every week, review the list of old bugs to see if there are any that are stalled, need closing, or are no longer relevant. The idle label is automatically set on issues that have had no activity for 30 days.

Check assigned issues that are still open to see if the assignee is making progress. If there is no progress after a week of being assigned, ask them if they still have time to work on the issue. If another week passes by without any progress, unassign them and leave a comment indicating that you're making the issue available for other interested contributors.
If a pull request has been opened to fix the issue but has not been reviewed for a week, give the reviewer a gentle ping to ask if they can get to it.
If a pull request to fix the issue is waiting on review comments to be addressed after a week, then ask the author if they can respond to their review. If another week goes by, either fix the review comments yourself if you have time, or close the pull request and unassign the related issue.


Issue-specific triaging tasksThese are the guidelines to follow while triaging each issue.
Review if the issue is valid
These are some of the things to keep in mind while reviewing the validity of an issue:

Check if the issue raised is valid and if the fix will improve the content for the readers and the website.
Evaluate if the impact of the fix will be small or site-wide.
Evaluate if the fix for the issue will need a discussion first, in which case, point the author to open a discussion instead.
Check if the issue complies with our writing guidelines and templates.
Check whether suggestions for adding links comply with our external links policy.

Review the issue for completeness of information
Review each issue against the following checklist to ensure that the issue contains the described information for someone to start working on the bug:

URL of the MDN Web Docs page with the problem or URL of an example MDN Web Docs page if the problem exists on multiple pages
The specific heading or section on the MDN Web Docs page where the problem was found
A clear description of the incorrect, unhelpful, incomplete, or missing information

If any of the above information is not present, then you should ask the author of the issue to provide these details, and add the needs info label to the issue. Resume triaging the issue only after those details have been provided (after which, you can remove the needs info label). It is okay to wait for up to a week to get a response from the author.
Set a priority label
For each bug, set a priority label based on the severity of the issue to help people who want to work on the most important issues or areas.


Critical issue: This type of issue needs to be fixed as soon as possible, regardless of where it appears on the site. This type of issue could damage MDN's reputation severely and/or harm users. Examples of this issue include an incorrect code snippet, which if used in production, could create a severe security problem and undesirable content such as malware, profanity, pornography, hate speech, or links to such content.

Label: p0 (will be addressed immediately)



Major issue: This type of issue could severely affect a page's usefulness. For example, a significant amount of out-of-date information, a complex and important code example that doesn't work, a significant amount of prose that is badly written and hard to understand, or a large number of broken links.

Labels: p1 (will be addressed soon) and p2 (will be addressed soon, but higher priority items will take precedence)



Minor issue: This is a type of improvement issue that can make the existing content better but does not affect learning or only has a minor effect on learning. Since these types of issues are not actively planned for, help from contributors to fix these issues is welcome and much appreciated. Fixing some of these issues can also provide the necessary practice to beginner contributors who are starting to get familiar with the contribution process. Examples include typos, bad grammar, a broken link, a small amount of out-of-date information or badly-written prose, or a code snippet that doesn't work.

Labels: p3 (no visibility when the issue will be addressed)



In general, critical issues should be fixed immediately and are most likely handled by MDN Web Docs staff and peers.
Add helpful information
If possible, add information that can help contributors to fix the issue. The information can be in the form of steps, general approach, links to other similar fixed issues, or reading resources. A well-laid out plan or steps is especially required in issues that are labeled good first issue and can help ramp up new contributors quickly. You can time-box this task to 5-10 minutes.
For example, as a triager, you can add the following information to the issue you are triaging:
mdTo whoever fixes this issue, it looks like the following is needed:

- Update the first paragraph below heading X to correct the problem with Y
- Add a description of X
- Update the compatibility data at Link-X

Set other labels
Next, set the following labels as appropriate:


effort: small, effort: medium, effort: large: Some contributors like to search for bugs based on the time and effort that will be needed to fix the bug. So where possible, you should try to provide an estimate of the required effort.


good first issue: Set this label on the issue if the fix for the issue is really simple and if fixing the issue would provide good practice for a newcomer who is getting used to the process.


help wanted: Set this label if the issue requires help from someone who knows about or is familiar with the topic. This is a popular label and some contributors use it to search for issues to work on in open source projects in their areas of familiarity or expertise.


broken link external: Set this label if the issue involves a broken link to an external page.


document not written: Set this label if the issue involves a necessary document that has not been written yet, usually because a link points to it.


needs content update: Set this label if the issue fix in another repository will need an equivalent fix in the mdn/content repository.

Note:
After the triage process is complete, remove the needs triage label.


Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 7, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nMDN Community
Where web enthusiasts learn, collaborate, and create

Start contributing
Join MDN Discord



45K+ Total contributors
200+ Weekly commits
7 Language communities
MDN's community powers the webMDN’s strength comes from the passion and dedication of our global community.
Since our founding in 2005, we’ve grown into a thriving network. Together, we’ve
created a comprehensive, open, and free resource that serves web developers
across the globe. With volunteers leading translation efforts in
7 languages, we’re
truly international.Meet our contributorsWe are an open-source community dedicated to building resources for a better
web. Our diverse contributors, including developers, technical writers,
students, educators, designers, and more, come from various backgrounds and
platforms. Anyone can contribute, and each contribution strengthens our
community, driving innovation and improving this vital resource for developers
worldwide.

Join us
View all contributors



Jason Lam, 林家祥 https://github.com/JasonLamv-t Grantit
Nicolò Ribaudo https://github.com/nicolo-ribaudo Igalia
Joshua Chen https://github.com/Josh-Cena
Kimchanmin https://github.com/c17an SK Planet
Gibbeum Yoon https://github.com/givvemee
Jongha Kim https://github.com/wisedog
Qizhe ZHANG https://github.com/PassionPenguin
Artem Shibakov https://github.com/saionaro Bright Data
HoChan Lee https://github.com/hochan222 11STREET
Sangchul Lee https://github.com/1ilsang WoowaBros
Park Sunhee https://github.com/sunhpark42 WoowaBros
FU CHUNHUI https://github.com/fuchunhui Baidu
Estelle Weyl https://github.com/estelle Open Web Docs
Yitao Yin https://github.com/yin1999 Northwestern Polytechnical University
Florian Scholz https://github.com/Elchi3 Open Web Docs

Contributor spotlight


There are many other things I like about MDN: the openness of its
governance, the respect for contributors' work, the professional
conversations, and the always timely reviews. MDN has consistently
demonstrated the ideal form of an open-source project.

Joshua Chen (MDN contributor)



MDN Web Docs has the most up-to-date and accurate information and the
content is presented in an easy-to-understand manner. I also like that it's
available in many languages (very important!).

Yuji (MDN contributor)



There are millions of web developers in China, and many of them begin their
developer journey at MDN Web Docs. Contributing to MDN Web Docs is an
excellent way to help people who are starting out.

YiTao Yin (MDN contributor)


If you wish to be a part of the featured contributors here,
let us know. If you’re featured here
and would like to opt-out,
please file an issue on GitHub.Learn how to get startedWe collaborate on GitHub, our project's home, on
various tasks such as writing and improving documentation, fixing bugs, and
providing review feedback. It starts here, with you. Want to start right away,
but not sure how? Follow
our guide
to make your first contribution.
Watch this video on
how to get started with contributing to MDN.
Video from the community team on contributing to MDNJoin us in shaping a better webBecome part of this globally cherished group that’s dedicated to documenting web
technologies. Whether you’re an expert or a beginner, there’s a place for you in
our inclusive community. Check out some of the ways you can contribute and
engage.


Fix issues
Submit pull requests to fix reported issues.
Squash bugs


Improve content
Fix inaccuracies and fill in missing information.
Start writing


Localize content
Participate in translating content into one of our supported languages.
Find your locale


Answer questions
Share your knowledge and expertise and guide fellow learners.
Help on Discord

Help us fix open issuesNew to MDN or open-source projects? Tackle our beginner-friendly issues to help
improve MDN.TitleRepositoryJoin the conversation

Chat with us on Discord
Connect with the community. Engage with domain experts. Help others learn.
Join MDN Discord


Join our Community Call
Every month, get exclusive updates from the MDN team. Share your ideas and
contributions.
RSVP to the next community call


While working in Mozilla spaces and communities, please adhere to the
Mozilla Community Participation Guidelines,
which promote respect, inclusion, and a harassment-free environment for all
community members.Licensing and reuseMDN's resources are freely available under various open-source licenses. For
detailed information on reusing MDN content, check out our
Attribution and Copyright Licensing
page.\n\nMDN Community
Where web enthusiasts learn, collaborate, and create

Start contributing
Join MDN Discord



45K+ Total contributors
200+ Weekly commits
7 Language communities
MDN's community powers the webMDN’s strength comes from the passion and dedication of our global community.
Since our founding in 2005, we’ve grown into a thriving network. Together, we’ve
created a comprehensive, open, and free resource that serves web developers
across the globe. With volunteers leading translation efforts in
7 languages, we’re
truly international.Meet our contributorsWe are an open-source community dedicated to building resources for a better
web. Our diverse contributors, including developers, technical writers,
students, educators, designers, and more, come from various backgrounds and
platforms. Anyone can contribute, and each contribution strengthens our
community, driving innovation and improving this vital resource for developers
worldwide.

Join us
View all contributors



Jason Lam, 林家祥 https://github.com/JasonLamv-t Grantit
Nicolò Ribaudo https://github.com/nicolo-ribaudo Igalia
Joshua Chen https://github.com/Josh-Cena
Kimchanmin https://github.com/c17an SK Planet
Gibbeum Yoon https://github.com/givvemee
Jongha Kim https://github.com/wisedog
Qizhe ZHANG https://github.com/PassionPenguin
Artem Shibakov https://github.com/saionaro Bright Data
HoChan Lee https://github.com/hochan222 11STREET
Sangchul Lee https://github.com/1ilsang WoowaBros
Park Sunhee https://github.com/sunhpark42 WoowaBros
FU CHUNHUI https://github.com/fuchunhui Baidu
Estelle Weyl https://github.com/estelle Open Web Docs
Yitao Yin https://github.com/yin1999 Northwestern Polytechnical University
Florian Scholz https://github.com/Elchi3 Open Web Docs

Contributor spotlight


There are many other things I like about MDN: the openness of its
governance, the respect for contributors' work, the professional
conversations, and the always timely reviews. MDN has consistently
demonstrated the ideal form of an open-source project.

Joshua Chen (MDN contributor)



MDN Web Docs has the most up-to-date and accurate information and the
content is presented in an easy-to-understand manner. I also like that it's
available in many languages (very important!).

Yuji (MDN contributor)



There are millions of web developers in China, and many of them begin their
developer journey at MDN Web Docs. Contributing to MDN Web Docs is an
excellent way to help people who are starting out.

YiTao Yin (MDN contributor)


If you wish to be a part of the featured contributors here,
let us know. If you’re featured here
and would like to opt-out,
please file an issue on GitHub.Learn how to get startedWe collaborate on GitHub, our project's home, on
various tasks such as writing and improving documentation, fixing bugs, and
providing review feedback. It starts here, with you. Want to start right away,
but not sure how? Follow
our guide
to make your first contribution.
Watch this video on
how to get started with contributing to MDN.
Video from the community team on contributing to MDNJoin us in shaping a better webBecome part of this globally cherished group that’s dedicated to documenting web
technologies. Whether you’re an expert or a beginner, there’s a place for you in
our inclusive community. Check out some of the ways you can contribute and
engage.


Fix issues
Submit pull requests to fix reported issues.
Squash bugs


Improve content
Fix inaccuracies and fill in missing information.
Start writing


Localize content
Participate in translating content into one of our supported languages.
Find your locale


Answer questions
Share your knowledge and expertise and guide fellow learners.
Help on Discord

Help us fix open issuesNew to MDN or open-source projects? Tackle our beginner-friendly issues to help
improve MDN.TitleRepositoryJoin the conversation

Chat with us on Discord
Connect with the community. Engage with domain experts. Help others learn.
Join MDN Discord


Join our Community Call
Every month, get exclusive updates from the MDN team. Share your ideas and
contributions.
RSVP to the next community call


While working in Mozilla spaces and communities, please adhere to the
Mozilla Community Participation Guidelines,
which promote respect, inclusion, and a harassment-free environment for all
community members.Licensing and reuseMDN's resources are freely available under various open-source licenses. For
detailed information on reusing MDN content, check out our
Attribution and Copyright Licensing
page.\n\n\n\n\n\nLearn web developmentThe essential skillset for new front-end developersWelcome to MDN Learning Web Development (also known as Learn). This resource provides a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer, along with challenges and further recommended resources.About Learn web development

Teaches the essential skills and knowledge every front-end developer needs for career success and industry relevance, as defined in the MDN Curriculum.


Created by the MDN community and refined with insights from students, educators, and developers from the broader web community.


Designed to take you from "beginner" to "comfortable" (not "beginner" to "expert"), giving you enough knowledge to use more advanced resources (such as the rest of MDN).



Note:
Last updated: December 2024 (see changelog).
Don't know where to get started?
Never coded before?

Our Getting started modules provide setup tutorials and essential concepts and background information for complete beginners. You should start here if you are a complete beginner (i.e., you've not installed a code editor or written any code yet).

Want to master the essentials?

Our Core modules provide a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer.

Beyond the basics?

Our Extension modules cover useful additional skills to learn as you start to expand your knowledge and develop specialisms. Go onto these after you finish our Core.

Working at a school?

Use our modules to guide your teaching, check out our Educators page for more ideas, or enroll your students in Scrimba's Frontend Developer Career PathMDN learning partner.

Getting our code examplesThe code examples you'll encounter in the Learning Area are all available on GitHub:

The easiest way to get them is to download a ZIP of the latest main code branch.
If you are familiar with Git and GitHub, you could also choose to clone the repository.
Contact usIf you want to get in touch with us about anything, use the communication channels. We'd love to hear from you about anything you think is wrong or missing on the site, requests for new learning topics, requests for help with items you don't understand, or any other questions or concerns.
If you're interested in helping develop/improve the content, take a look at how you can help and get in touch! We are more than happy to talk to you, whether you are a learner, teacher, experienced web developer, or someone else interested in helping to improve the learning experience.See also
The Frontend Developer Career Path MDN learning partner

Scrimba's Frontend Developer Career Path teaches all you need to know to be a competent front-end web developer, with fun interactive lessons and challenges, knowledgeable teachers, and a supportive community. Go from zero to landing your first front-end job! Many of the course components are available as standalone free versions.

Codecademy

A great interactive site for learning programming languages from scratch.

freeCodeCamp.org

Interactive site with tutorials and projects to learn web development.

Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.\n\nLearn web developmentThe essential skillset for new front-end developersWelcome to MDN Learning Web Development (also known as Learn). This resource provides a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer, along with challenges and further recommended resources.About Learn web development

Teaches the essential skills and knowledge every front-end developer needs for career success and industry relevance, as defined in the MDN Curriculum.


Created by the MDN community and refined with insights from students, educators, and developers from the broader web community.


Designed to take you from "beginner" to "comfortable" (not "beginner" to "expert"), giving you enough knowledge to use more advanced resources (such as the rest of MDN).



Note:
Last updated: December 2024 (see changelog).
Don't know where to get started?
Never coded before?

Our Getting started modules provide setup tutorials and essential concepts and background information for complete beginners. You should start here if you are a complete beginner (i.e., you've not installed a code editor or written any code yet).

Want to master the essentials?

Our Core modules provide a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer.

Beyond the basics?

Our Extension modules cover useful additional skills to learn as you start to expand your knowledge and develop specialisms. Go onto these after you finish our Core.

Working at a school?

Use our modules to guide your teaching, check out our Educators page for more ideas, or enroll your students in Scrimba's Frontend Developer Career PathMDN learning partner.

Getting our code examplesThe code examples you'll encounter in the Learning Area are all available on GitHub:

The easiest way to get them is to download a ZIP of the latest main code branch.
If you are familiar with Git and GitHub, you could also choose to clone the repository.
Contact usIf you want to get in touch with us about anything, use the communication channels. We'd love to hear from you about anything you think is wrong or missing on the site, requests for new learning topics, requests for help with items you don't understand, or any other questions or concerns.
If you're interested in helping develop/improve the content, take a look at how you can help and get in touch! We are more than happy to talk to you, whether you are a learner, teacher, experienced web developer, or someone else interested in helping to improve the learning experience.See also
The Frontend Developer Career Path MDN learning partner

Scrimba's Frontend Developer Career Path teaches all you need to know to be a competent front-end web developer, with fun interactive lessons and challenges, knowledgeable teachers, and a supportive community. Go from zero to landing your first front-end job! Many of the course components are available as standalone free versions.

Codecademy

A great interactive site for learning programming languages from scratch.

freeCodeCamp.org

Interactive site with tutorials and projects to learn web development.

Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 15, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nLearn web developmentThe essential skillset for new front-end developersWelcome to MDN Learning Web Development (also known as Learn). This resource provides a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer, along with challenges and further recommended resources.About Learn web development

Teaches the essential skills and knowledge every front-end developer needs for career success and industry relevance, as defined in the MDN Curriculum.


Created by the MDN community and refined with insights from students, educators, and developers from the broader web community.


Designed to take you from "beginner" to "comfortable" (not "beginner" to "expert"), giving you enough knowledge to use more advanced resources (such as the rest of MDN).



Note:
Last updated: December 2024 (see changelog).
Don't know where to get started?
Never coded before?

Our Getting started modules provide setup tutorials and essential concepts and background information for complete beginners. You should start here if you are a complete beginner (i.e., you've not installed a code editor or written any code yet).

Want to master the essentials?

Our Core modules provide a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer.

Beyond the basics?

Our Extension modules cover useful additional skills to learn as you start to expand your knowledge and develop specialisms. Go onto these after you finish our Core.

Working at a school?

Use our modules to guide your teaching, check out our Educators page for more ideas, or enroll your students in Scrimba's Frontend Developer Career PathMDN learning partner.

Getting our code examplesThe code examples you'll encounter in the Learning Area are all available on GitHub:

The easiest way to get them is to download a ZIP of the latest main code branch.
If you are familiar with Git and GitHub, you could also choose to clone the repository.
Contact usIf you want to get in touch with us about anything, use the communication channels. We'd love to hear from you about anything you think is wrong or missing on the site, requests for new learning topics, requests for help with items you don't understand, or any other questions or concerns.
If you're interested in helping develop/improve the content, take a look at how you can help and get in touch! We are more than happy to talk to you, whether you are a learner, teacher, experienced web developer, or someone else interested in helping to improve the learning experience.See also
The Frontend Developer Career Path MDN learning partner

Scrimba's Frontend Developer Career Path teaches all you need to know to be a competent front-end web developer, with fun interactive lessons and challenges, knowledgeable teachers, and a supportive community. Go from zero to landing your first front-end job! Many of the course components are available as standalone free versions.

Codecademy

A great interactive site for learning programming languages from scratch.

freeCodeCamp.org

Interactive site with tutorials and projects to learn web development.

Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 15, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nAttribution and copyright licensingMDN Web Docs content is available free of charge and is available under various open-source licenses.Using MDN Web Docs contentThis section covers the types of content we provide and the copyrights and licenses that are in effect for each type if you choose to reuse any of it.Documentation
Note:
The content on MDN Web Docs has been prepared with the contributions of authors from both inside and outside Mozilla. Unless otherwise indicated, the content is available under the terms of the Creative Commons Attribution-ShareAlike license (CC-BY-SA), v2.5 or any later version.

Your reuse of the content here is published under the same license as the original content – CC-BY-SA v2.5 or any later version.
When reusing the content on MDN Web Docs, you need to ensure that attribution is given to the material as well as to "Mozilla Contributors".
Good attribution is the title of the document, with a hyperlink (online) or URL (in print) to the specific page of the content being sourced, and any modifications you've made briefly described.
For example, to provide attribution for this page, you can write:

"Attributions and copyright licensing" by Mozilla Contributors, licensed under CC-BY-SA 2.5.

You may also want to link "Mozilla Contributors" to a contributors.txt file linked in the page footer you're referencing for a list of authors, if reasonable.
See Recommended practices for attribution for more details.Code samplesCode samples added on or after August 20, 2010 are in the public domain CC0. No licensing notice is necessary but if you need one, you can use: Any copyright is dedicated to the Public Domain: https://creativecommons.org/publicdomain/zero/1.0/
Code samples added before August 20, 2010 are available under the MIT license; you should insert the following attribution information into the MIT template: "© <date of last wiki page revision> <name of person who put it in the wiki>".
Since the launch of the new Yari MDN platform on December 14 2020, there is currently no way to determine which one you need. We are working on this and will update this content soon. Your contributionsIf you wish to contribute to MDN Web Docs, you agree that your documentation is available under the Attribution-ShareAlike license (or occasionally an alternative license already specified by the page you are editing) and that your code samples are available under Creative Commons CC-0 (a Public Domain dedication).

Warning:
No new pages may be created using alternate licenses.

Copyright for contributed materials remains with the author unless the author assigns it to someone else.
If you have any questions or concerns about anything discussed here, please contact the MDN Web Docs team.Logos, trademarks, service marks, and wordmarksThe rights in the logos, trademarks, and service marks of the Mozilla Foundation, as well as the look and feel of this website, are not licensed under the Creative Commons license, and to the extent they are works of authorship (like logos and graphic design), they are not included in the work that is licensed under those terms. If you use the text of documents and wish to also use any of these rights, or if you have any other questions about complying with our licensing terms for this collection, you should contact the Mozilla Foundation here: licensing@mozilla.org.Using content from elsewhere on MDN Web DocsIn general, we do not approve of copying content from other sources and putting it on MDN.
MDN should be made up of original content wherever possible.
If we receive a pull request and discover that it contains plagiarized content, we will close it and request that the submitter resubmit the change with the content rewritten into their own words.Reusing or republishing your content on MDN
Note:
Unless there is a good reason to republish the content, we will probably say "no".
The MDN writing team's decision is final.

If someone wants to donate an article to MDN that they previously published on their blog or it makes sense to copy a complex reference sheet to MDN, there may be justification for republishing it. For these cases, discuss your plan with the MDN team beforehand:

Create a GitHub issue that explains your intention.

Describe what you would like to copy or republish.
Provide a URL to the resource.
Explain why you think it's appropriate.



If the content is published under a closed license:

If you hold the rights to the content, state this and your express agreement to republish it on MDN.
If you do not hold the rights to the content, include the author/publisher on the issue if possible, or include details of how they could be contacted so we can ask them for permission to republish the content.

If the content is published under an open license:

Say what it is, and link to the license so we can check whether it is compatible with MDN's license.
Linking to MDN Web Docs articlesWe regularly get users asking us questions about how to link to MDN Web Docs and whether or not it is even allowed. The short answer is: yes, you can link to MDN Web Docs! Not only is the hypertext link the essence of the web, it is both a way to point your users to valuable resources as well as a show of trust toward the work our community does.\n\nAttribution and copyright licensingMDN Web Docs content is available free of charge and is available under various open-source licenses.Using MDN Web Docs contentThis section covers the types of content we provide and the copyrights and licenses that are in effect for each type if you choose to reuse any of it.Documentation
Note:
The content on MDN Web Docs has been prepared with the contributions of authors from both inside and outside Mozilla. Unless otherwise indicated, the content is available under the terms of the Creative Commons Attribution-ShareAlike license (CC-BY-SA), v2.5 or any later version.

Your reuse of the content here is published under the same license as the original content – CC-BY-SA v2.5 or any later version.
When reusing the content on MDN Web Docs, you need to ensure that attribution is given to the material as well as to "Mozilla Contributors".
Good attribution is the title of the document, with a hyperlink (online) or URL (in print) to the specific page of the content being sourced, and any modifications you've made briefly described.
For example, to provide attribution for this page, you can write:

"Attributions and copyright licensing" by Mozilla Contributors, licensed under CC-BY-SA 2.5.

You may also want to link "Mozilla Contributors" to a contributors.txt file linked in the page footer you're referencing for a list of authors, if reasonable.
See Recommended practices for attribution for more details.Code samplesCode samples added on or after August 20, 2010 are in the public domain CC0. No licensing notice is necessary but if you need one, you can use: Any copyright is dedicated to the Public Domain: https://creativecommons.org/publicdomain/zero/1.0/
Code samples added before August 20, 2010 are available under the MIT license; you should insert the following attribution information into the MIT template: "© <date of last wiki page revision> <name of person who put it in the wiki>".
Since the launch of the new Yari MDN platform on December 14 2020, there is currently no way to determine which one you need. We are working on this and will update this content soon. Your contributionsIf you wish to contribute to MDN Web Docs, you agree that your documentation is available under the Attribution-ShareAlike license (or occasionally an alternative license already specified by the page you are editing) and that your code samples are available under Creative Commons CC-0 (a Public Domain dedication).

Warning:
No new pages may be created using alternate licenses.

Copyright for contributed materials remains with the author unless the author assigns it to someone else.
If you have any questions or concerns about anything discussed here, please contact the MDN Web Docs team.Logos, trademarks, service marks, and wordmarksThe rights in the logos, trademarks, and service marks of the Mozilla Foundation, as well as the look and feel of this website, are not licensed under the Creative Commons license, and to the extent they are works of authorship (like logos and graphic design), they are not included in the work that is licensed under those terms. If you use the text of documents and wish to also use any of these rights, or if you have any other questions about complying with our licensing terms for this collection, you should contact the Mozilla Foundation here: licensing@mozilla.org.Using content from elsewhere on MDN Web DocsIn general, we do not approve of copying content from other sources and putting it on MDN.
MDN should be made up of original content wherever possible.
If we receive a pull request and discover that it contains plagiarized content, we will close it and request that the submitter resubmit the change with the content rewritten into their own words.Reusing or republishing your content on MDN
Note:
Unless there is a good reason to republish the content, we will probably say "no".
The MDN writing team's decision is final.

If someone wants to donate an article to MDN that they previously published on their blog or it makes sense to copy a complex reference sheet to MDN, there may be justification for republishing it. For these cases, discuss your plan with the MDN team beforehand:

Create a GitHub issue that explains your intention.

Describe what you would like to copy or republish.
Provide a URL to the resource.
Explain why you think it's appropriate.



If the content is published under a closed license:

If you hold the rights to the content, state this and your express agreement to republish it on MDN.
If you do not hold the rights to the content, include the author/publisher on the issue if possible, or include details of how they could be contacted so we can ask them for permission to republish the content.

If the content is published under an open license:

Say what it is, and link to the license so we can check whether it is compatible with MDN's license.
Linking to MDN Web Docs articlesWe regularly get users asking us questions about how to link to MDN Web Docs and whether or not it is even allowed. The short answer is: yes, you can link to MDN Web Docs! Not only is the hypertext link the essence of the web, it is both a way to point your users to valuable resources as well as a show of trust toward the work our community does.Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 19, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nAttribution and copyright licensingMDN Web Docs content is available free of charge and is available under various open-source licenses.Using MDN Web Docs contentThis section covers the types of content we provide and the copyrights and licenses that are in effect for each type if you choose to reuse any of it.Documentation
Note:
The content on MDN Web Docs has been prepared with the contributions of authors from both inside and outside Mozilla. Unless otherwise indicated, the content is available under the terms of the Creative Commons Attribution-ShareAlike license (CC-BY-SA), v2.5 or any later version.

Your reuse of the content here is published under the same license as the original content – CC-BY-SA v2.5 or any later version.
When reusing the content on MDN Web Docs, you need to ensure that attribution is given to the material as well as to "Mozilla Contributors".
Good attribution is the title of the document, with a hyperlink (online) or URL (in print) to the specific page of the content being sourced, and any modifications you've made briefly described.
For example, to provide attribution for this page, you can write:

"Attributions and copyright licensing" by Mozilla Contributors, licensed under CC-BY-SA 2.5.

You may also want to link "Mozilla Contributors" to a contributors.txt file linked in the page footer you're referencing for a list of authors, if reasonable.
See Recommended practices for attribution for more details.Code samplesCode samples added on or after August 20, 2010 are in the public domain CC0. No licensing notice is necessary but if you need one, you can use: Any copyright is dedicated to the Public Domain: https://creativecommons.org/publicdomain/zero/1.0/
Code samples added before August 20, 2010 are available under the MIT license; you should insert the following attribution information into the MIT template: "© <date of last wiki page revision> <name of person who put it in the wiki>".
Since the launch of the new Yari MDN platform on December 14 2020, there is currently no way to determine which one you need. We are working on this and will update this content soon. Your contributionsIf you wish to contribute to MDN Web Docs, you agree that your documentation is available under the Attribution-ShareAlike license (or occasionally an alternative license already specified by the page you are editing) and that your code samples are available under Creative Commons CC-0 (a Public Domain dedication).

Warning:
No new pages may be created using alternate licenses.

Copyright for contributed materials remains with the author unless the author assigns it to someone else.
If you have any questions or concerns about anything discussed here, please contact the MDN Web Docs team.Logos, trademarks, service marks, and wordmarksThe rights in the logos, trademarks, and service marks of the Mozilla Foundation, as well as the look and feel of this website, are not licensed under the Creative Commons license, and to the extent they are works of authorship (like logos and graphic design), they are not included in the work that is licensed under those terms. If you use the text of documents and wish to also use any of these rights, or if you have any other questions about complying with our licensing terms for this collection, you should contact the Mozilla Foundation here: licensing@mozilla.org.Using content from elsewhere on MDN Web DocsIn general, we do not approve of copying content from other sources and putting it on MDN.
MDN should be made up of original content wherever possible.
If we receive a pull request and discover that it contains plagiarized content, we will close it and request that the submitter resubmit the change with the content rewritten into their own words.Reusing or republishing your content on MDN
Note:
Unless there is a good reason to republish the content, we will probably say "no".
The MDN writing team's decision is final.

If someone wants to donate an article to MDN that they previously published on their blog or it makes sense to copy a complex reference sheet to MDN, there may be justification for republishing it. For these cases, discuss your plan with the MDN team beforehand:

Create a GitHub issue that explains your intention.

Describe what you would like to copy or republish.
Provide a URL to the resource.
Explain why you think it's appropriate.



If the content is published under a closed license:

If you hold the rights to the content, state this and your express agreement to republish it on MDN.
If you do not hold the rights to the content, include the author/publisher on the issue if possible, or include details of how they could be contacted so we can ask them for permission to republish the content.

If the content is published under an open license:

Say what it is, and link to the license so we can check whether it is compatible with MDN's license.
Linking to MDN Web Docs articlesWe regularly get users asking us questions about how to link to MDN Web Docs and whether or not it is even allowed. The short answer is: yes, you can link to MDN Web Docs! Not only is the hypertext link the essence of the web, it is both a way to point your users to valuable resources as well as a show of trust toward the work our community does.Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 19, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nResources for Developers, by DevelopersDocumenting web technologies, including CSS, HTML, and JavaScript, since 2005.Search MDNClear search inputSearchFeatured articlesBlogJavaScript Temporal is comingA new way to handle dates and times is being added to JavaScript. Let's take a look at Temporal, what problems it solves, the current state, and what you'll find in the new documentation about it on MDN.
CSSCSS anchor positioningThe CSS anchor positioning module defines features that allow you to tether elements together. Certain elements are defined as anchor elements; anchor-positioned elements can then have their size and position set based on the size and location of the anchor elements to which they are bound.
Web APIsUsing the View Transition APIThis article explains the theory behind how the View Transition API works, how to create view transitions and customize the transition animations, and how to manipulate active view transitions. This covers view transitions for both DOM state updates in a single-page app (SPA), and navigating between documents in a multi-page app (MPA).
JavaScriptTemporalThe Temporal object enables date and time management in various scenarios, including built-in time zone and calendar representation, wall-clock time conversions, arithmetics, formatting, and more. It is designed as a full replacement for the Date object.
Latest newsMDN 2024 content projectsdeveloper.mozilla.org3 months agoA new learning experience on MDNdeveloper.mozilla.org4 months agoIntroducing the new MDN Community pagedeveloper.mozilla.org6 months agoRecent contributionszh-CN: create `webRequest.CertificateInfo`mdn/translated-contenta day ago[zh-tw] Global attributes classmdn/translated-contenta day agozh-cn: add new page for br instructionmdn/translated-content13 hours agozh-cn: add new page for block instructionmdn/translated-content13 hours agozh-cn: add new page for call instructionmdn/translated-content13 hours agoFix title typomdn/content8 hours agosimplify WritableStream examplemdn/content7 hours agoMake all JS articles reachable via sidebarmdn/content5 hours agoAdd more links to the Wasm sidebarmdn/contentan hour agoMerge Transforming_XML_with_XSLT subarticles into itselfmdn/contentan hour agoContributor SpotlightYash Raj BhartiMDN resonates with my passion to build a consistent and open web, where developers can learn and grow.Get involved →\n\nResources for Developers, by DevelopersDocumenting web technologies, including CSS, HTML, and JavaScript, since 2005.Search MDNClear search inputSearchFeatured articlesBlogJavaScript Temporal is comingA new way to handle dates and times is being added to JavaScript. Let's take a look at Temporal, what problems it solves, the current state, and what you'll find in the new documentation about it on MDN.
CSSCSS anchor positioningThe CSS anchor positioning module defines features that allow you to tether elements together. Certain elements are defined as anchor elements; anchor-positioned elements can then have their size and position set based on the size and location of the anchor elements to which they are bound.
Web APIsUsing the View Transition APIThis article explains the theory behind how the View Transition API works, how to create view transitions and customize the transition animations, and how to manipulate active view transitions. This covers view transitions for both DOM state updates in a single-page app (SPA), and navigating between documents in a multi-page app (MPA).
JavaScriptTemporalThe Temporal object enables date and time management in various scenarios, including built-in time zone and calendar representation, wall-clock time conversions, arithmetics, formatting, and more. It is designed as a full replacement for the Date object.
Latest newsMDN 2024 content projectsdeveloper.mozilla.org3 months agoA new learning experience on MDNdeveloper.mozilla.org4 months agoIntroducing the new MDN Community pagedeveloper.mozilla.org6 months agoRecent contributionszh-CN: create `webRequest.CertificateInfo`mdn/translated-contenta day ago[zh-tw] Global attributes classmdn/translated-contenta day agozh-cn: add new page for br instructionmdn/translated-content13 hours agozh-cn: add new page for block instructionmdn/translated-content13 hours agozh-cn: add new page for call instructionmdn/translated-content13 hours agoFix title typomdn/content8 hours agosimplify WritableStream examplemdn/content7 hours agoMake all JS articles reachable via sidebarmdn/content5 hours agoAdd more links to the Wasm sidebarmdn/contentan hour agoMerge Transforming_XML_with_XSLT subarticles into itselfmdn/contentan hour agoContributor SpotlightYash Raj BhartiMDN resonates with my passion to build a consistent and open web, where developers can learn and grow.Get involved →\n\n\n\nResources for Developers, by DevelopersDocumenting web technologies, including CSS, HTML, and JavaScript, since 2005.Search MDNClear search inputSearchFeatured articlesBlogJavaScript Temporal is comingA new way to handle dates and times is being added to JavaScript. Let's take a look at Temporal, what problems it solves, the current state, and what you'll find in the new documentation about it on MDN.
CSSCSS anchor positioningThe CSS anchor positioning module defines features that allow you to tether elements together. Certain elements are defined as anchor elements; anchor-positioned elements can then have their size and position set based on the size and location of the anchor elements to which they are bound.
Web APIsUsing the View Transition APIThis article explains the theory behind how the View Transition API works, how to create view transitions and customize the transition animations, and how to manipulate active view transitions. This covers view transitions for both DOM state updates in a single-page app (SPA), and navigating between documents in a multi-page app (MPA).
JavaScriptTemporalThe Temporal object enables date and time management in various scenarios, including built-in time zone and calendar representation, wall-clock time conversions, arithmetics, formatting, and more. It is designed as a full replacement for the Date object.
Latest newsMDN 2024 content projectsdeveloper.mozilla.org3 months agoA new learning experience on MDNdeveloper.mozilla.org4 months agoIntroducing the new MDN Community pagedeveloper.mozilla.org6 months agoRecent contributionszh-CN: create `webRequest.CertificateInfo`mdn/translated-contenta day ago[zh-tw] Global attributes classmdn/translated-contenta day agozh-cn: add new page for br instructionmdn/translated-content13 hours agozh-cn: add new page for block instructionmdn/translated-content13 hours agozh-cn: add new page for call instructionmdn/translated-content13 hours agoFix title typomdn/content8 hours agosimplify WritableStream examplemdn/content7 hours agoMake all JS articles reachable via sidebarmdn/content5 hours agoAdd more links to the Wasm sidebarmdn/contentan hour agoMerge Transforming_XML_with_XSLT subarticles into itselfmdn/contentan hour agoContributor SpotlightYash Raj BhartiMDN resonates with my passion to build a consistent and open web, where developers can learn and grow.Get involved →\n\nResources for Developers, by DevelopersDocumenting web technologies, including CSS, HTML, and JavaScript, since 2005.Search MDNClear search inputSearchFeatured articlesBlogJavaScript Temporal is comingA new way to handle dates and times is being added to JavaScript. Let's take a look at Temporal, what problems it solves, the current state, and what you'll find in the new documentation about it on MDN.
CSSCSS anchor positioningThe CSS anchor positioning module defines features that allow you to tether elements together. Certain elements are defined as anchor elements; anchor-positioned elements can then have their size and position set based on the size and location of the anchor elements to which they are bound.
Web APIsUsing the View Transition APIThis article explains the theory behind how the View Transition API works, how to create view transitions and customize the transition animations, and how to manipulate active view transitions. This covers view transitions for both DOM state updates in a single-page app (SPA), and navigating between documents in a multi-page app (MPA).
JavaScriptTemporalThe Temporal object enables date and time management in various scenarios, including built-in time zone and calendar representation, wall-clock time conversions, arithmetics, formatting, and more. It is designed as a full replacement for the Date object.
Latest newsMDN 2024 content projectsdeveloper.mozilla.org3 months agoA new learning experience on MDNdeveloper.mozilla.org4 months agoIntroducing the new MDN Community pagedeveloper.mozilla.org6 months agoRecent contributionszh-CN: create `webRequest.CertificateInfo`mdn/translated-contenta day ago[zh-tw] Global attributes classmdn/translated-contenta day agozh-cn: add new page for br instructionmdn/translated-content13 hours agozh-cn: add new page for block instructionmdn/translated-content13 hours agozh-cn: add new page for call instructionmdn/translated-content13 hours agoFix title typomdn/content8 hours agosimplify WritableStream examplemdn/content7 hours agoMake all JS articles reachable via sidebarmdn/content5 hours agoAdd more links to the Wasm sidebarmdn/contentan hour agoMerge Transforming_XML_with_XSLT subarticles into itselfmdn/contentan hour agoContributor SpotlightYash Raj BhartiMDN resonates with my passion to build a consistent and open web, where developers can learn and grow.Get involved →\n\n\n\n\n\nJavaScript Temporal is comingBrian SmithJanuary 24, 20255 minute readImplementations of the new JavaScript Temporal object are starting to be shipped in experimental releases of browsers.
This is big news for web developers because working with dates and times in JavaScript will be hugely simplified and modernized.
Applications that rely on scheduling, internationalization, or time-sensitive data will be able to use built-ins for efficient, precise and consistent dates, times, durations, and calendars.
We're a long way away from stable, cross-browser support, and there may be changes as implementations develop, but we can already take a look at Temporal as it stands now, why it's exciting, and what problems it solves.
To help you get up to speed, there are over 270 pages of Temporal docs on MDN added this week, with detailed explanations and examples.What is JavaScript Temporal?To understand Temporal, we can look at JavaScript's Date object.
When JavaScript was created in 1995, the Date object was copied from Java's early, flawed java.util.Date implementation.
Java replaced this implementation in 1997, but JavaScript is stuck with the same API for almost 30 years, despite known problems.
The major issues with JavaScript's Date object are that it only supports the user's local time and UTC, and there's no time zone support.
Additionally, its parsing behavior is very unreliable, and Date itself is mutable, which can introduce hard-to-trace bugs.
There are other problems like calculations across Daylight Saving Time (DST) and historical calendar changes, which are notoriously difficult to work with.
All of these issues make working with dates and times in JavaScript complex and prone to bugs, which can have serious consequences for some systems.
Most developers rely on dedicated libraries like Moment.js and date-fns for better handling of dates and times in their applications.
Temporal is designed as a full replacement for the Date object, making date and time management reliable and predictable.
Temporal adds support for time zone and calendar representations, many built-in methods for conversions, comparisons and computations, formatting, and more.
The API surface has over 200 utility methods, and you can find information about all of them in the Temporal docs on MDN.Core conceptsIn Temporal, the key concepts are that it has instants (unique points in history), wall-clock times (regional time), and durations.
The APIs have this overall structure to handle these concepts:

Duration: Temporal.Duration the difference between two points in time
Points in time:

Unique points in time:

As a timestamp: Temporal.Instant
A date-time with a time zone: Temporal.ZonedDateTime


Time-zone-unaware date/time ("Plain"):

Full date and time: Temporal.PlainDateTime

Just the date: Temporal.PlainDate

Year and month: Temporal.PlainYearMonth
Month and day: Temporal.PlainMonthDay


Just the time: Temporal.PlainTime






Now: using Temporal.now to get the current time as various class instances, or in a specific format
Temporal examplesSome of the most basic usages of Temporal include getting current dates and times as an ISO string, but we can see from the example below, that we can now provide time zones with many methods, which takes care of complex calculations you may be doing yourself:
js// The current date in the system's time zone
const dateTime = Temporal.Now.plainDateTimeISO();
console.log(dateTime); // e.g.: 2025-01-22T11:46:36.144

// The current date in the "America/New_York" time zone
const dateTimeInNewYork = Temporal.Now.plainDateTimeISO("America/New_York");
console.log(dateTimeInNewYork);
// e.g.: 2025-01-22T05:47:02.555

Working with different calendars is also simplified, as it's possible to create dates in calendar systems other than Gregorian, such as Hebrew, Chinese, and Islamic, for example.
The code below helps you find out when the next Chinese New Year is (which is quite soon!):
js// Chinese New Years are on 1/1 in the Chinese calendar
const chineseNewYear = Temporal.PlainMonthDay.from({
  monthCode: "M01",
  day: 1,
  calendar: "chinese",
});
const currentYear = Temporal.Now.plainDateISO().withCalendar("chinese").year;
let nextCNY = chineseNewYear.toPlainDate({ year: currentYear });
// If nextCNY is before the current date, move forward by 1 year
if (Temporal.PlainDate.compare(nextCNY, Temporal.Now.plainDateISO()) <= 0) {
  nextCNY = nextCNY.add({ years: 1 });
}
console.log(
  `The next Chinese New Year is on ${nextCNY.withCalendar("iso8601").toLocaleString()}`,
);
// The next Chinese New Year is on 1/29/2025 (at the time of writing)

Working with Unix timestamps is a very common use case as many systems (APIs, databases) use the format to represent times.
The following example shows how to take a Unix Epoch timestamp in milliseconds, create an instant from it, get the current time with Temporal.Now, then calculate how many hours from now until the Unix timestamp:
js// 1851222399924 is our timestamp
const launch = Temporal.Instant.fromEpochMilliseconds(1851222399924);
const now = Temporal.Now.instant();
const duration = now.until(launch, { smallestUnit: "hour" });
console.log(`It will be ${duration.toLocaleString("en-US")} until the launch`);
// "It will be 31,600 hr until the launch" <- @js-temporal/polyfill
// "It will be PT31600H until the launch" <- Firefox Nightly

Currently, toLocaleString doesn't output a locale-sensitive string in the Firefox implementation, so durations above (PT31600H) are returned as a non-locale-sensitive duration format.
This may change as it's more of a design decision rather than a technical limitation as formatting the duration is possible, so the polyfill and Firefox implementations may eventually converge.
There's a lot to highlight, but one pattern that I thought was interesting in the API is the compare() methods, which allow you to sort durations in an elegant and efficient way:
jsconst durations = [
  Temporal.Duration.from({ hours: 1 }),
  Temporal.Duration.from({ hours: 2 }),
  Temporal.Duration.from({ hours: 1, minutes: 30 }),
  Temporal.Duration.from({ hours: 1, minutes: 45 }),
];

durations.sort(Temporal.Duration.compare);
console.log(durations.map((d) => d.toString()));
// [ 'PT1H', 'PT1H30M', 'PT1H45M', 'PT2H' ]
Trying Temporal and browser supportSupport is slowly starting to be included in experimental browser releases, and Firefox appears to have the most mature implementation at this point.
In Firefox, Temporal is being built into the Nightly version behind the javascript.options.experimental.temporal preference.
If you want to see the full compatibility story, you can check the (quite epic) Temporal object Browser Compatibility section.
Here are the main browser bugs that track Temporal implementations:

Firefox: Build temporal in Nightly by default
Safari: [JSC] Implement Temporal
Chrome: Implement the Temporal proposal

Additionally, you can visit https://tc39.es/proposal-temporal/docs/ which has @js-temporal/polyfill available.
That means, you can open the developer tools on the TC39 docs page, and try some of the examples in the console in any browser without changing flags or preferences.
With experimental implementations landing, now is a good time to try out Temporal and become familiar with what will be the modern approach to handling dates and times in JavaScript.Acknowledgements
Thanks to Eric Meyer for his work on the topic.
It's been roughly 4 years since Eric's efforts to document browser compatibility data and scaffold the documentation in his fork of mdn/content.
Joshua Chen for picking up the torch from Eric and getting a pull request together for the MDN documentation.
André Bargull for the work on the Firefox Temporal implementation.
See also
Fixing JavaScript Date – Getting Started by Maggie Pint (2017)
Previous Post Fix your website's Largest Contentful Paint by optimizing image loadingNext Post Implications of Global Privacy ControlPrevious Post Fix your website's Largest Contentful Paint by optimizing image loadingNext Post Implications of Global Privacy Control\n\nIn this articleWhat is JavaScript Temporal?Core conceptsTemporal examplesTrying Temporal and browser supportAcknowledgementsSee alsoJavaScript Temporal is comingBrian SmithJanuary 24, 20255 minute readImplementations of the new JavaScript Temporal object are starting to be shipped in experimental releases of browsers.
This is big news for web developers because working with dates and times in JavaScript will be hugely simplified and modernized.
Applications that rely on scheduling, internationalization, or time-sensitive data will be able to use built-ins for efficient, precise and consistent dates, times, durations, and calendars.
We're a long way away from stable, cross-browser support, and there may be changes as implementations develop, but we can already take a look at Temporal as it stands now, why it's exciting, and what problems it solves.
To help you get up to speed, there are over 270 pages of Temporal docs on MDN added this week, with detailed explanations and examples.What is JavaScript Temporal?To understand Temporal, we can look at JavaScript's Date object.
When JavaScript was created in 1995, the Date object was copied from Java's early, flawed java.util.Date implementation.
Java replaced this implementation in 1997, but JavaScript is stuck with the same API for almost 30 years, despite known problems.
The major issues with JavaScript's Date object are that it only supports the user's local time and UTC, and there's no time zone support.
Additionally, its parsing behavior is very unreliable, and Date itself is mutable, which can introduce hard-to-trace bugs.
There are other problems like calculations across Daylight Saving Time (DST) and historical calendar changes, which are notoriously difficult to work with.
All of these issues make working with dates and times in JavaScript complex and prone to bugs, which can have serious consequences for some systems.
Most developers rely on dedicated libraries like Moment.js and date-fns for better handling of dates and times in their applications.
Temporal is designed as a full replacement for the Date object, making date and time management reliable and predictable.
Temporal adds support for time zone and calendar representations, many built-in methods for conversions, comparisons and computations, formatting, and more.
The API surface has over 200 utility methods, and you can find information about all of them in the Temporal docs on MDN.Core conceptsIn Temporal, the key concepts are that it has instants (unique points in history), wall-clock times (regional time), and durations.
The APIs have this overall structure to handle these concepts:

Duration: Temporal.Duration the difference between two points in time
Points in time:

Unique points in time:

As a timestamp: Temporal.Instant
A date-time with a time zone: Temporal.ZonedDateTime


Time-zone-unaware date/time ("Plain"):

Full date and time: Temporal.PlainDateTime

Just the date: Temporal.PlainDate

Year and month: Temporal.PlainYearMonth
Month and day: Temporal.PlainMonthDay


Just the time: Temporal.PlainTime






Now: using Temporal.now to get the current time as various class instances, or in a specific format
Temporal examplesSome of the most basic usages of Temporal include getting current dates and times as an ISO string, but we can see from the example below, that we can now provide time zones with many methods, which takes care of complex calculations you may be doing yourself:
js// The current date in the system's time zone
const dateTime = Temporal.Now.plainDateTimeISO();
console.log(dateTime); // e.g.: 2025-01-22T11:46:36.144

// The current date in the "America/New_York" time zone
const dateTimeInNewYork = Temporal.Now.plainDateTimeISO("America/New_York");
console.log(dateTimeInNewYork);
// e.g.: 2025-01-22T05:47:02.555

Working with different calendars is also simplified, as it's possible to create dates in calendar systems other than Gregorian, such as Hebrew, Chinese, and Islamic, for example.
The code below helps you find out when the next Chinese New Year is (which is quite soon!):
js// Chinese New Years are on 1/1 in the Chinese calendar
const chineseNewYear = Temporal.PlainMonthDay.from({
  monthCode: "M01",
  day: 1,
  calendar: "chinese",
});
const currentYear = Temporal.Now.plainDateISO().withCalendar("chinese").year;
let nextCNY = chineseNewYear.toPlainDate({ year: currentYear });
// If nextCNY is before the current date, move forward by 1 year
if (Temporal.PlainDate.compare(nextCNY, Temporal.Now.plainDateISO()) <= 0) {
  nextCNY = nextCNY.add({ years: 1 });
}
console.log(
  `The next Chinese New Year is on ${nextCNY.withCalendar("iso8601").toLocaleString()}`,
);
// The next Chinese New Year is on 1/29/2025 (at the time of writing)

Working with Unix timestamps is a very common use case as many systems (APIs, databases) use the format to represent times.
The following example shows how to take a Unix Epoch timestamp in milliseconds, create an instant from it, get the current time with Temporal.Now, then calculate how many hours from now until the Unix timestamp:
js// 1851222399924 is our timestamp
const launch = Temporal.Instant.fromEpochMilliseconds(1851222399924);
const now = Temporal.Now.instant();
const duration = now.until(launch, { smallestUnit: "hour" });
console.log(`It will be ${duration.toLocaleString("en-US")} until the launch`);
// "It will be 31,600 hr until the launch" <- @js-temporal/polyfill
// "It will be PT31600H until the launch" <- Firefox Nightly

Currently, toLocaleString doesn't output a locale-sensitive string in the Firefox implementation, so durations above (PT31600H) are returned as a non-locale-sensitive duration format.
This may change as it's more of a design decision rather than a technical limitation as formatting the duration is possible, so the polyfill and Firefox implementations may eventually converge.
There's a lot to highlight, but one pattern that I thought was interesting in the API is the compare() methods, which allow you to sort durations in an elegant and efficient way:
jsconst durations = [
  Temporal.Duration.from({ hours: 1 }),
  Temporal.Duration.from({ hours: 2 }),
  Temporal.Duration.from({ hours: 1, minutes: 30 }),
  Temporal.Duration.from({ hours: 1, minutes: 45 }),
];

durations.sort(Temporal.Duration.compare);
console.log(durations.map((d) => d.toString()));
// [ 'PT1H', 'PT1H30M', 'PT1H45M', 'PT2H' ]
Trying Temporal and browser supportSupport is slowly starting to be included in experimental browser releases, and Firefox appears to have the most mature implementation at this point.
In Firefox, Temporal is being built into the Nightly version behind the javascript.options.experimental.temporal preference.
If you want to see the full compatibility story, you can check the (quite epic) Temporal object Browser Compatibility section.
Here are the main browser bugs that track Temporal implementations:

Firefox: Build temporal in Nightly by default
Safari: [JSC] Implement Temporal
Chrome: Implement the Temporal proposal

Additionally, you can visit https://tc39.es/proposal-temporal/docs/ which has @js-temporal/polyfill available.
That means, you can open the developer tools on the TC39 docs page, and try some of the examples in the console in any browser without changing flags or preferences.
With experimental implementations landing, now is a good time to try out Temporal and become familiar with what will be the modern approach to handling dates and times in JavaScript.Acknowledgements
Thanks to Eric Meyer for his work on the topic.
It's been roughly 4 years since Eric's efforts to document browser compatibility data and scaffold the documentation in his fork of mdn/content.
Joshua Chen for picking up the torch from Eric and getting a pull request together for the MDN documentation.
André Bargull for the work on the Firefox Temporal implementation.
See also
Fixing JavaScript Date – Getting Started by Maggie Pint (2017)
Previous Post Fix your website's Largest Contentful Paint by optimizing image loadingNext Post Implications of Global Privacy Control\n\nJavaScript Temporal is comingBrian SmithJanuary 24, 20255 minute readImplementations of the new JavaScript Temporal object are starting to be shipped in experimental releases of browsers.
This is big news for web developers because working with dates and times in JavaScript will be hugely simplified and modernized.
Applications that rely on scheduling, internationalization, or time-sensitive data will be able to use built-ins for efficient, precise and consistent dates, times, durations, and calendars.
We're a long way away from stable, cross-browser support, and there may be changes as implementations develop, but we can already take a look at Temporal as it stands now, why it's exciting, and what problems it solves.
To help you get up to speed, there are over 270 pages of Temporal docs on MDN added this week, with detailed explanations and examples.What is JavaScript Temporal?To understand Temporal, we can look at JavaScript's Date object.
When JavaScript was created in 1995, the Date object was copied from Java's early, flawed java.util.Date implementation.
Java replaced this implementation in 1997, but JavaScript is stuck with the same API for almost 30 years, despite known problems.
The major issues with JavaScript's Date object are that it only supports the user's local time and UTC, and there's no time zone support.
Additionally, its parsing behavior is very unreliable, and Date itself is mutable, which can introduce hard-to-trace bugs.
There are other problems like calculations across Daylight Saving Time (DST) and historical calendar changes, which are notoriously difficult to work with.
All of these issues make working with dates and times in JavaScript complex and prone to bugs, which can have serious consequences for some systems.
Most developers rely on dedicated libraries like Moment.js and date-fns for better handling of dates and times in their applications.
Temporal is designed as a full replacement for the Date object, making date and time management reliable and predictable.
Temporal adds support for time zone and calendar representations, many built-in methods for conversions, comparisons and computations, formatting, and more.
The API surface has over 200 utility methods, and you can find information about all of them in the Temporal docs on MDN.Core conceptsIn Temporal, the key concepts are that it has instants (unique points in history), wall-clock times (regional time), and durations.
The APIs have this overall structure to handle these concepts:

Duration: Temporal.Duration the difference between two points in time
Points in time:

Unique points in time:

As a timestamp: Temporal.Instant
A date-time with a time zone: Temporal.ZonedDateTime


Time-zone-unaware date/time ("Plain"):

Full date and time: Temporal.PlainDateTime

Just the date: Temporal.PlainDate

Year and month: Temporal.PlainYearMonth
Month and day: Temporal.PlainMonthDay


Just the time: Temporal.PlainTime






Now: using Temporal.now to get the current time as various class instances, or in a specific format
Temporal examplesSome of the most basic usages of Temporal include getting current dates and times as an ISO string, but we can see from the example below, that we can now provide time zones with many methods, which takes care of complex calculations you may be doing yourself:
js// The current date in the system's time zone
const dateTime = Temporal.Now.plainDateTimeISO();
console.log(dateTime); // e.g.: 2025-01-22T11:46:36.144

// The current date in the "America/New_York" time zone
const dateTimeInNewYork = Temporal.Now.plainDateTimeISO("America/New_York");
console.log(dateTimeInNewYork);
// e.g.: 2025-01-22T05:47:02.555

Working with different calendars is also simplified, as it's possible to create dates in calendar systems other than Gregorian, such as Hebrew, Chinese, and Islamic, for example.
The code below helps you find out when the next Chinese New Year is (which is quite soon!):
js// Chinese New Years are on 1/1 in the Chinese calendar
const chineseNewYear = Temporal.PlainMonthDay.from({
  monthCode: "M01",
  day: 1,
  calendar: "chinese",
});
const currentYear = Temporal.Now.plainDateISO().withCalendar("chinese").year;
let nextCNY = chineseNewYear.toPlainDate({ year: currentYear });
// If nextCNY is before the current date, move forward by 1 year
if (Temporal.PlainDate.compare(nextCNY, Temporal.Now.plainDateISO()) <= 0) {
  nextCNY = nextCNY.add({ years: 1 });
}
console.log(
  `The next Chinese New Year is on ${nextCNY.withCalendar("iso8601").toLocaleString()}`,
);
// The next Chinese New Year is on 1/29/2025 (at the time of writing)

Working with Unix timestamps is a very common use case as many systems (APIs, databases) use the format to represent times.
The following example shows how to take a Unix Epoch timestamp in milliseconds, create an instant from it, get the current time with Temporal.Now, then calculate how many hours from now until the Unix timestamp:
js// 1851222399924 is our timestamp
const launch = Temporal.Instant.fromEpochMilliseconds(1851222399924);
const now = Temporal.Now.instant();
const duration = now.until(launch, { smallestUnit: "hour" });
console.log(`It will be ${duration.toLocaleString("en-US")} until the launch`);
// "It will be 31,600 hr until the launch" <- @js-temporal/polyfill
// "It will be PT31600H until the launch" <- Firefox Nightly

Currently, toLocaleString doesn't output a locale-sensitive string in the Firefox implementation, so durations above (PT31600H) are returned as a non-locale-sensitive duration format.
This may change as it's more of a design decision rather than a technical limitation as formatting the duration is possible, so the polyfill and Firefox implementations may eventually converge.
There's a lot to highlight, but one pattern that I thought was interesting in the API is the compare() methods, which allow you to sort durations in an elegant and efficient way:
jsconst durations = [
  Temporal.Duration.from({ hours: 1 }),
  Temporal.Duration.from({ hours: 2 }),
  Temporal.Duration.from({ hours: 1, minutes: 30 }),
  Temporal.Duration.from({ hours: 1, minutes: 45 }),
];

durations.sort(Temporal.Duration.compare);
console.log(durations.map((d) => d.toString()));
// [ 'PT1H', 'PT1H30M', 'PT1H45M', 'PT2H' ]
Trying Temporal and browser supportSupport is slowly starting to be included in experimental browser releases, and Firefox appears to have the most mature implementation at this point.
In Firefox, Temporal is being built into the Nightly version behind the javascript.options.experimental.temporal preference.
If you want to see the full compatibility story, you can check the (quite epic) Temporal object Browser Compatibility section.
Here are the main browser bugs that track Temporal implementations:

Firefox: Build temporal in Nightly by default
Safari: [JSC] Implement Temporal
Chrome: Implement the Temporal proposal

Additionally, you can visit https://tc39.es/proposal-temporal/docs/ which has @js-temporal/polyfill available.
That means, you can open the developer tools on the TC39 docs page, and try some of the examples in the console in any browser without changing flags or preferences.
With experimental implementations landing, now is a good time to try out Temporal and become familiar with what will be the modern approach to handling dates and times in JavaScript.Acknowledgements
Thanks to Eric Meyer for his work on the topic.
It's been roughly 4 years since Eric's efforts to document browser compatibility data and scaffold the documentation in his fork of mdn/content.
Joshua Chen for picking up the torch from Eric and getting a pull request together for the MDN documentation.
André Bargull for the work on the Firefox Temporal implementation.
See also
Fixing JavaScript Date – Getting Started by Maggie Pint (2017)
Previous Post Fix your website's Largest Contentful Paint by optimizing image loadingNext Post Implications of Global Privacy Control\n\n\n\nCSS anchor positioningThe CSS anchor positioning module defines features that allow you to tether elements together. Certain elements are defined as anchor elements; anchor-positioned elements can then have their size and position set based on the size and location of the anchor elements to which they are bound.
In addition, the specification provides CSS-only mechanisms to:

Specify a set of alternative positions for an anchored element; when the default rendering position causes it to overflow its containing block and/or be rendered offscreen, the browser will try rendering the anchored element in the alternative positions instead.
Declare conditions under which anchor-positioned elements should be hidden, in situations where it is not appropriate to tether them to anchor elements.
ReferenceProperties
anchor-name
position-anchor
position-area
position-try-fallbacks
position-try-order
position-try shorthand
position-visibility


Note:
The CSS anchor positioning module introduces the anchor-scope property that has not yet been implemented.
At-rules and descriptors
@position-try
Functions
anchor()
anchor-size()
Data types and values
anchor-center
<anchor-side>
<anchor-size>
<position-area>
<try-size>
<try-tactic>
HTML attributes
anchor 
Non-standard

Interfaces
CSSPositionTryDescriptors
CSSPositionTryRule
HTMLElement.anchorElement 
Non-standard

Guides
Using CSS anchor positioning

An introductory guide to fundamental anchor positioning concepts, including associating, positioning, and sizing elements relative to their anchor.

Handling overflow: try fallbacks and conditional hiding

A guide to the mechanisms CSS anchor positioning provides to prevent anchor-positioned elements from overflowing their containing elements or the viewport, including position try fallback options and conditionally hiding elements.

Related concepts
CSS logical properties and values module:

inset-block-start
inset-block-end
inset-inline-start
inset-inline-end
inset-block
inset-inline
inset shorthand
inline-size
min-block-size
min-inline-size
block-size
max-block-size
max-inline-size
margin-block
margin-block-end
margin-block-start
margin-inline
margin-inline-end
margin-inline-start
Inset properties glossary term


CSS positioned layout module:

top
left
bottom
right


CSS box model module:

width
height
min-width
min-height
max-width
max-height
margin
margin-bottom
margin-left
margin-right
margin-top


CSS box alignment module:

align-items
align-self
justify-items
justify-self
place-items
place-self


SpecificationsSpecificationCSS Anchor Positioning See also
CSS scroll anchoring module
Learn: CSS positioning
CSS logical properties and values module
Learn: Sizing items in CSS\n\nCSS anchor positioningThe CSS anchor positioning module defines features that allow you to tether elements together. Certain elements are defined as anchor elements; anchor-positioned elements can then have their size and position set based on the size and location of the anchor elements to which they are bound.
In addition, the specification provides CSS-only mechanisms to:

Specify a set of alternative positions for an anchored element; when the default rendering position causes it to overflow its containing block and/or be rendered offscreen, the browser will try rendering the anchored element in the alternative positions instead.
Declare conditions under which anchor-positioned elements should be hidden, in situations where it is not appropriate to tether them to anchor elements.
ReferenceProperties
anchor-name
position-anchor
position-area
position-try-fallbacks
position-try-order
position-try shorthand
position-visibility


Note:
The CSS anchor positioning module introduces the anchor-scope property that has not yet been implemented.
At-rules and descriptors
@position-try
Functions
anchor()
anchor-size()
Data types and values
anchor-center
<anchor-side>
<anchor-size>
<position-area>
<try-size>
<try-tactic>
HTML attributes
anchor 
Non-standard

Interfaces
CSSPositionTryDescriptors
CSSPositionTryRule
HTMLElement.anchorElement 
Non-standard

Guides
Using CSS anchor positioning

An introductory guide to fundamental anchor positioning concepts, including associating, positioning, and sizing elements relative to their anchor.

Handling overflow: try fallbacks and conditional hiding

A guide to the mechanisms CSS anchor positioning provides to prevent anchor-positioned elements from overflowing their containing elements or the viewport, including position try fallback options and conditionally hiding elements.

Related concepts
CSS logical properties and values module:

inset-block-start
inset-block-end
inset-inline-start
inset-inline-end
inset-block
inset-inline
inset shorthand
inline-size
min-block-size
min-inline-size
block-size
max-block-size
max-inline-size
margin-block
margin-block-end
margin-block-start
margin-inline
margin-inline-end
margin-inline-start
Inset properties glossary term


CSS positioned layout module:

top
left
bottom
right


CSS box model module:

width
height
min-width
min-height
max-width
max-height
margin
margin-bottom
margin-left
margin-right
margin-top


CSS box alignment module:

align-items
align-self
justify-items
justify-self
place-items
place-self


SpecificationsSpecificationCSS Anchor Positioning See also
CSS scroll anchoring module
Learn: CSS positioning
CSS logical properties and values module
Learn: Sizing items in CSS
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nCSS anchor positioningThe CSS anchor positioning module defines features that allow you to tether elements together. Certain elements are defined as anchor elements; anchor-positioned elements can then have their size and position set based on the size and location of the anchor elements to which they are bound.
In addition, the specification provides CSS-only mechanisms to:

Specify a set of alternative positions for an anchored element; when the default rendering position causes it to overflow its containing block and/or be rendered offscreen, the browser will try rendering the anchored element in the alternative positions instead.
Declare conditions under which anchor-positioned elements should be hidden, in situations where it is not appropriate to tether them to anchor elements.
ReferenceProperties
anchor-name
position-anchor
position-area
position-try-fallbacks
position-try-order
position-try shorthand
position-visibility


Note:
The CSS anchor positioning module introduces the anchor-scope property that has not yet been implemented.
At-rules and descriptors
@position-try
Functions
anchor()
anchor-size()
Data types and values
anchor-center
<anchor-side>
<anchor-size>
<position-area>
<try-size>
<try-tactic>
HTML attributes
anchor 
Non-standard

Interfaces
CSSPositionTryDescriptors
CSSPositionTryRule
HTMLElement.anchorElement 
Non-standard

Guides
Using CSS anchor positioning

An introductory guide to fundamental anchor positioning concepts, including associating, positioning, and sizing elements relative to their anchor.

Handling overflow: try fallbacks and conditional hiding

A guide to the mechanisms CSS anchor positioning provides to prevent anchor-positioned elements from overflowing their containing elements or the viewport, including position try fallback options and conditionally hiding elements.

Related concepts
CSS logical properties and values module:

inset-block-start
inset-block-end
inset-inline-start
inset-inline-end
inset-block
inset-inline
inset shorthand
inline-size
min-block-size
min-inline-size
block-size
max-block-size
max-inline-size
margin-block
margin-block-end
margin-block-start
margin-inline
margin-inline-end
margin-inline-start
Inset properties glossary term


CSS positioned layout module:

top
left
bottom
right


CSS box model module:

width
height
min-width
min-height
max-width
max-height
margin
margin-bottom
margin-left
margin-right
margin-top


CSS box alignment module:

align-items
align-self
justify-items
justify-self
place-items
place-self


SpecificationsSpecificationCSS Anchor Positioning See also
CSS scroll anchoring module
Learn: CSS positioning
CSS logical properties and values module
Learn: Sizing items in CSS
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nUsing the View Transition APIThis article explains the theory behind how the View Transition API works, how to create view transitions and customize the transition animations, and how to manipulate active view transitions. This covers view transitions for both DOM state updates in a single-page app (SPA), and navigating between documents in a multi-page app (MPA).The view transition processLet's walk through the process by which a view transition works:


A view transition is triggered. How this is done depends on the type of view transition:

In the case of same-document transitions (SPAs), a view transition is triggered by passing the function that would trigger the view change DOM update as a callback to the document.startViewTransition() method.
In the case of cross-document transitions (MPAs), a view transition is triggered by initiating navigation to a new document. Both the current and destination documents of the navigation need to be on the same origin, and opt-in to the view transition by including a @view-transition at rule in their CSS with a navigation descriptor of auto.

Note:
An active view transition has an associated ViewTransition instance (for example, returned by startViewTransition() in the case of same-document (SPA) transitions). The ViewTransition object includes several promises, allowing you to run code in response to different parts of the view transition process being reached. See Controlling view transitions with JavaScript for more information.





On the current (old page) view, the API captures snapshots of elements that have a view-transition-name declared on them.


The view change occurs:


In the case of same-document transitions (SPAs), the callback passed to startViewTransition() is invoked, which causes the DOM to change.
When the callback has run successfully, the ViewTransition.updateCallbackDone promise fulfills, allowing you to respond to the DOM updating.


In the case of cross-document transitions (MPAs), the navigation occurs between the current and destination documents.




The API captures snapshots from the new view as a live representation.
At this point, the view transition is about to run, and the ViewTransition.ready promise fulfills, allowing you to respond by running a custom JavaScript animation instead of the default, for example.


The old page snapshots animate "out", while the new view snapshots animate "in". By default, the old view snapshots animate from opacity 1 to 0, and the new view snapshots animate from opacity 0 to 1, which creates a cross-fade.


When the transition animations have reached their end states, the ViewTransition.finished promise fulfills, allowing you to respond.



Note:
If the document's page visibility state is hidden (for example if the document is obscured by a window, the browser is minimized, or another browser tab is active) during a document.startViewTransition() call, the view transition is skipped entirely.
The view transition pseudo-element treeTo handle creating the outbound and inbound transition animations, the API constructs a pseudo-element tree with the following structure:
::view-transition
└─ ::view-transition-group(root)
  └─ ::view-transition-image-pair(root)
      ├─ ::view-transition-old(root)
      └─ ::view-transition-new(root)


Note:
A ::view-transition-group subtree is created for every captured view-transition-name.

In the case of same-document transitions (SPAs), the pseudo-element tree is made available in the document. In the case of cross-document transitions (MPAs), the pseudo-element tree is made available in the destination document only.
The most interesting parts of the tree structure are as follows:


::view-transition is the root of view transitions overlay, which contains all view transition snapshot groups and sits over the top of all other page content.


A ::view-transition-group acts as a container for each view transition snapshot group. The root argument specifies the default snapshot group — the view transition animation will apply to the snapshot whose view-transition-name is root. By default, this is the :root element, because the default browser styles define this:
css:root {
  view-transition-name: root;
}

Be aware however that page authors can change this by unsetting the above, and setting view-transition-name: root on a different element.


::view-transition-old targets the static snapshot of the old page element, and ::view-transition-new targets the live snapshot of the new page element. Both of these render as replaced content, in the same manner as an <img> or <video>, meaning that they can be styled with handy properties like object-fit and object-position.



Note:
It is possible to target different DOM elements with different custom view transition animations by setting a different view-transition-name on each one. In such cases, a ::view-transition-group is created for each one. See Different animations for different elements for an example.


Note:
As you'll see later, to customize the outbound and inbound animations you need to target the ::view-transition-old and ::view-transition-new pseudo-elements with your animations, respectively.
Creating a basic view transitionThis section illustrates how to create a basic view transition, in both the SPA and MPA case.Basic SPA view transitionAs an example, an SPA may include functionality to fetch new content and update the DOM in response to an event of some kind, such as a navigation link being clicked or an update being pushed from the server. In our View Transitions SPA demo we've simplified this to a displayNewImage() function that shows a new full-size image based on the thumbnail that was clicked. We've encapsulated this inside an updateView() function that only calls the View Transition API if the browser supports it:
jsfunction updateView(event) {
  // Handle the difference in whether the event is fired on the <a> or the <img>
  const targetIdentifier = event.target.firstChild || event.target;

  const displayNewImage = () => {
    const mainSrc = `${targetIdentifier.src.split("_th.jpg")[0]}.jpg`;
    galleryImg.src = mainSrc;
    galleryCaption.textContent = targetIdentifier.alt;
  };

  // Fallback for browsers that don't support View Transitions:
  if (!document.startViewTransition) {
    displayNewImage();
    return;
  }

  // With View Transitions:
  const transition = document.startViewTransition(() => displayNewImage());
}

This code is enough to handle the transition between displayed images. Supporting browsers will show the change from old to new images and captions as a smooth cross-fade (the default view transition). It will still work in non-supporting browsers but without the nice animation.Basic MPA view transitionWhen creating a cross-document (MPA) view transition, the process is even simpler than for SPAs. No JavaScript is required, as the view update is triggered by a cross-document, same-origin navigation rather than a JavaScript-initiated DOM change. To enable a basic MPA view transition, you need to specify a @view-transition at-rule in the CSS for both the current and destination documents to opt them in, like so:
css@view-transition {
  navigation: auto;
}

Our View Transitions MPA demo shows this at-rule in action, and additionally demonstrates how to customize the outbound and inbound animations of the view transition.

Note:
Currently MPA view transitions can only be created between same-origin documents, but this restriction may be relaxed in future implementations.
Customizing your animationsThe View Transitions pseudo-elements have default CSS Animations applied (which are detailed in their reference pages).
Most appearance transitions are given a default smooth cross-fade animation, as mentioned above. There are some exceptions:

height and width transitions have a smooth scaling animation applied.
position and transform transitions have a smooth movement animation applied.

You can modify the default animations in any way you want using regular CSS — target the "from" animation with ::view-transition-old, and the "to" animation with ::view-transition-new.
For example, to change the speed of both:
css::view-transition-old(root),
::view-transition-new(root) {
  animation-duration: 0.5s;
}

It is recommended that you target the ::view-transition-group() with such styles in cases where you want to apply them to ::view-transition-old() and ::view-transition-new(). Because of the pseudo-element hierarchy and default user-agent styling, the styles will be inherited by both. For example:
css::view-transition-group(root) {
  animation-duration: 0.5s;
}


Note:
This is also a good option for safeguarding your code — ::view-transition-group() also animates and you could end up with different durations for the group/image-pair pseudo-elements versus the old and new pseudo-elements.

In the case of cross-document (MPA) transitions, the pseudo-elements need to be included in the destination document only for the view transition to work. If you want to use the view transition in both directions, you'll need to include it in both, of course.
Our View Transitions MPA demo includes the above CSS, but takes the customization a step further, defining custom animations and applying them to the ::view-transition-old(root) and ::view-transition-new(root) pseudo-elements. The result is that the default cross-fade transition is swapped out for a "swipe up" transition when navigation occurs:
css/* Create a custom animation */

@keyframes move-out {
  from {
    transform: translateY(0%);
  }

  to {
    transform: translateY(-100%);
  }
}

@keyframes move-in {
  from {
    transform: translateY(100%);
  }

  to {
    transform: translateY(0%);
  }
}

/* Apply the custom animation to the old and new page states */

::view-transition-old(root) {
  animation: 0.4s ease-in both move-out;
}

::view-transition-new(root) {
  animation: 0.4s ease-in both move-in;
}
Different animations for different elementsBy default, all of the different elements that change during the view update are transitioned using the same animation. If you want some elements to animate differently from the default root animation, you can separate them out using the view-transition-name property. For example, in our View Transitions SPA demo the <figcaption> elements are given a view-transition-name of figure-caption to separate them from the rest of the page in terms of view transitions:
cssfigcaption {
  view-transition-name: figure-caption;
}

With this CSS applied, the generated pseudo-element tree will now look like this:
::view-transition
├─ ::view-transition-group(root)
│ └─ ::view-transition-image-pair(root)
│     ├─ ::view-transition-old(root)
│     └─ ::view-transition-new(root)
└─ ::view-transition-group(figure-caption)
  └─ ::view-transition-image-pair(figure-caption)
      ├─ ::view-transition-old(figure-caption)
      └─ ::view-transition-new(figure-caption)

The existence of the second set of pseudo-elements allows separate view transition styling to be applied just to the <figcaption>. The different old and new view captures are handled separately from one another.

Note:
The value of view-transition-name can be anything you want except for none — the none value specifically means that the element will not participate in a view transition.
view-transition-name values must also be unique. If two rendered elements have the same view-transition-name at the same time, ViewTransition.ready will reject and the transition will be skipped.

The following code applies a custom animation just to the <figcaption>:
css@keyframes grow-x {
  from {
    transform: scaleX(0);
  }
  to {
    transform: scaleX(1);
  }
}

@keyframes shrink-x {
  from {
    transform: scaleX(1);
  }
  to {
    transform: scaleX(0);
  }
}

::view-transition-group(figure-caption) {
  height: auto;
  right: 0;
  left: auto;
  transform-origin: right center;
}

::view-transition-old(figure-caption) {
  animation: 0.25s linear both shrink-x;
}

::view-transition-new(figure-caption) {
  animation: 0.25s 0.25s linear both grow-x;
}

Here we've created a custom CSS animation and applied it to the ::view-transition-old(figure-caption) and ::view-transition-new(figure-caption) pseudo-elements. We've also added a number of other styles to both to keep them in the same place and stop the default styling from interfering with our custom animations.

Note:
You can use * as the identifier in a pseudo-element to target all snapshot pseudo-elements, regardless of what name they have. For example:
css::view-transition-group(*) {
  animation-duration: 2s;
}

Taking advantage of the default animation stylesNote that we also discovered another transition option that is simpler and produced a nicer result than the above. Our final <figcaption> view transition ended up looking like this:
cssfigcaption {
  view-transition-name: figure-caption;
}

::view-transition-group(figure-caption) {
  height: 100%;
}

This works because, by default, ::view-transition-group transitions width and height between the old and new views with a smooth scale. We just needed to set a fixed height on both states to make it work.

Note: Smooth transitions with the View Transition API contains several other customization examples.
Controlling view transitions with JavaScriptA view transition has an associated ViewTransition object instance, which contains several promise members allowing you to run JavaScript in response to different states of the transition being reached. For example, ViewTransition.ready fulfills once the pseudo-element tree is created and the animation is about to start, whereas ViewTransition.finished fulfills once the animation is finished, and the new page view is visible and interactive to the user.
The ViewTransition can be accessed like so:


In the case of same-document (SPA) transitions, the document.startViewTransition() method returns the ViewTransition associated with the transition.


In the case of cross-document (MPA) transitions:

A pageswap event is fired when a document is about to be unloaded due to a navigation. Its event object (PageSwapEvent) provides access to the ViewTransition via the PageSwapEvent.viewTransition property, as well as a NavigationActivation via PageSwapEvent.activation containing the navigation type and current and destination document history entries.

Note:
If the navigation has a cross-origin URL anywhere in the redirect chain, the activation property returns null.


A pagereveal event is fired when a document is first rendered, either when loading a fresh document from the network or activating a document (either from back/forward cache (bfcache) or prerender). Its event object (PageRevealEvent) provides access to the ViewTransition via the PageRevealEvent.viewTransition property.



Let's have a look at some example code to show how these features could be used.A JavaScript-powered custom same-document (SPA) transitionThe following JavaScript could be used to create a circular reveal view transition emanating from the position of the user's cursor on click, with animation provided by the Web Animations API.
js// Store the last click event
let lastClick;
addEventListener("click", (event) => (lastClick = event));

function spaNavigate(data) {
  // Fallback for browsers that don't support this API:
  if (!document.startViewTransition) {
    updateTheDOMSomehow(data);
    return;
  }

  // Get the click position, or fallback to the middle of the screen
  const x = lastClick?.clientX ?? innerWidth / 2;
  const y = lastClick?.clientY ?? innerHeight / 2;
  // Get the distance to the furthest corner
  const endRadius = Math.hypot(
    Math.max(x, innerWidth - x),
    Math.max(y, innerHeight - y),
  );

  // Create a transition:
  const transition = document.startViewTransition(() => {
    updateTheDOMSomehow(data);
  });

  // Wait for the pseudo-elements to be created:
  transition.ready.then(() => {
    // Animate the root's new view
    document.documentElement.animate(
      {
        clipPath: [
          `circle(0 at ${x}px ${y}px)`,
          `circle(${endRadius}px at ${x}px ${y}px)`,
        ],
      },
      {
        duration: 500,
        easing: "ease-in",
        // Specify which pseudo-element to animate
        pseudoElement: "::view-transition-new(root)",
      },
    );
  });
}

This animation also requires the following CSS, to turn off the default CSS animation and stop the old and new view states from blending in any way (the new state "wipes" right over the top of the old state, rather than transitioning in):
css::view-transition-image-pair(root) {
  isolation: auto;
}

::view-transition-old(root),
::view-transition-new(root) {
  animation: none;
  mix-blend-mode: normal;
  display: block;
}
A JavaScript-powered custom cross-document (MPA) transitionThe List of Chrome DevRel team members demo provides a basic set of team profile pages, and demonstrates how to use the pageswap and pagereveal events to customize the outgoing and inbound animations of a cross-document view transition based on the "from" and "to" URLs.
The pageswap event listener looks as follows. This sets view transition names on the elements on the outbound page that link to the profile pages. When navigating from the home page to a profile page, custom animations are provided only for the linked element that is clicked in each case.
jswindow.addEventListener("pageswap", async (e) => {
  // Only run this if an active view transition exists
  if (e.viewTransition) {
    const currentUrl = e.activation.from?.url
      ? new URL(e.activation.from.url)
      : null;
    const targetUrl = new URL(e.activation.entry.url);

    // Going from profile page to homepage
    // ~> The big img and title are the ones!
    if (isProfilePage(currentUrl) && isHomePage(targetUrl)) {
      // Set view-transition-name values on the elements to animate
      document.querySelector(`#detail main h1`).style.viewTransitionName =
        "name";
      document.querySelector(`#detail main img`).style.viewTransitionName =
        "avatar";

      // Remove view-transition-names after snapshots have been taken
      // Stops naming conflicts resulting from the page state persisting in BFCache
      await e.viewTransition.finished;
      document.querySelector(`#detail main h1`).style.viewTransitionName =
        "none";
      document.querySelector(`#detail main img`).style.viewTransitionName =
        "none";
    }

    // Going to profile page
    // ~> The clicked items are the ones!
    if (isProfilePage(targetUrl)) {
      const profile = extractProfileNameFromUrl(targetUrl);

      // Set view-transition-name values on the elements to animate
      document.querySelector(`#${profile} span`).style.viewTransitionName =
        "name";
      document.querySelector(`#${profile} img`).style.viewTransitionName =
        "avatar";

      // Remove view-transition-names after snapshots have been taken
      // Stops naming conflicts resulting from the page state persisting in BFCache
      await e.viewTransition.finished;
      document.querySelector(`#${profile} span`).style.viewTransitionName =
        "none";
      document.querySelector(`#${profile} img`).style.viewTransitionName =
        "none";
    }
  }
});


Note:
We remove the view-transition-name values after snapshots have been taken in each case. If we left them set, they would persist in the page state saved in the bfcache upon navigation. If the back button was then pressed, the pagereveal event handler of the page being navigated back to would then attempt to set the same view-transition-name values on different elements. If multiple elements have the same view-transition-name set, the view transition is skipped.

The pagereveal event listener looks as follows. This works in a similar way to the pageswap event listener, although bear in mind that here we are customizing the "to" animation, for page elements on the new page.
jswindow.addEventListener("pagereveal", async (e) => {
  // If the "from" history entry does not exist, return
  if (!navigation.activation.from) return;

  // Only run this if an active view transition exists
  if (e.viewTransition) {
    const fromUrl = new URL(navigation.activation.from.url);
    const currentUrl = new URL(navigation.activation.entry.url);

    // Went from profile page to homepage
    // ~> Set VT names on the relevant list item
    if (isProfilePage(fromUrl) && isHomePage(currentUrl)) {
      const profile = extractProfileNameFromUrl(fromUrl);

      // Set view-transition-name values on the elements to animate
      document.querySelector(`#${profile} span`).style.viewTransitionName =
        "name";
      document.querySelector(`#${profile} img`).style.viewTransitionName =
        "avatar";

      // Remove names after snapshots have been taken
      // so that we're ready for the next navigation
      await e.viewTransition.ready;
      document.querySelector(`#${profile} span`).style.viewTransitionName =
        "none";
      document.querySelector(`#${profile} img`).style.viewTransitionName =
        "none";
    }

    // Went to profile page
    // ~> Set VT names on the main title and image
    if (isProfilePage(currentUrl)) {
      // Set view-transition-name values on the elements to animate
      document.querySelector(`#detail main h1`).style.viewTransitionName =
        "name";
      document.querySelector(`#detail main img`).style.viewTransitionName =
        "avatar";

      // Remove names after snapshots have been taken
      // so that we're ready for the next navigation
      await e.viewTransition.ready;
      document.querySelector(`#detail main h1`).style.viewTransitionName =
        "none";
      document.querySelector(`#detail main img`).style.viewTransitionName =
        "none";
    }
  }
});
Stabilizing page state to make cross-document transitions consistentBefore running a cross-document transition, you ideally want to wait until the state of the page stabilizes, relying on render blocking to ensure that:

Critical styles are loaded and applied.
Critical scripts are loaded and run.
The HTML visible for the user's initial view of the page has been parsed, so it renders consistently.

Styles are render blocked by default, and scripts can be render blocked using the blocking="render" attribute.
To ensure that your initial HTML has been parsed and will always render consistently before the transition animation runs, you can use <link rel="expect">. In this element, you include the following attributes:

rel="expect" to indicate that you want to use this <link> element to render block some HTML on the page.
href="#element-id" to indicate the ID of the element you want to render block.
blocking="render" to render block the specified HTML.

Let's explore what this looks like with an example HTML document:
html<!doctype html>
<html lang="en">
  <head>
    <!-- This will be render-blocking by default -->
    <link rel="stylesheet" href="style.css" />

    <!-- Marking critical scripts as render blocking will
         ensure they're run before the view transition is activated -->
    <script async href="layout.js" blocking="render"></script>

    <!-- Use rel="expect" and blocking="render" to ensure the
         #lead-content element is visible and fully parsed before
         activating the transition -->
    <link rel="expect" href="#lead-content" blocking="render" />
  </head>
  <body>
    <h1>Page title</h1>
    <nav>...</nav>
    <div id="lead-content">
      <section id="first-section">The first section</section>
      <section>The second section</section>
    </div>
  </body>
</html>

The result is that document rendering is blocked until the lead content <div> has been parsed, ensuring a consistent view transition.
You can also specify a media attribute on <link rel="expect"> elements. For example, you might want to block rendering on a smaller amount of content when loading the page on a narrow-screen device, than on a wide-screen device. This makes sense — on a mobile, less content will be visible when the page first loads than in the case of a desktop.
This could be achieved with the following HTML:
html<link
  rel="expect"
  href="#lead-content"
  blocking="render"
  media="screen and (min-width: 641px)" />
<link
  rel="expect"
  href="#first-section"
  blocking="render"
  media="screen and (max-width: 640px)" />\n\nUsing the View Transition APIThis article explains the theory behind how the View Transition API works, how to create view transitions and customize the transition animations, and how to manipulate active view transitions. This covers view transitions for both DOM state updates in a single-page app (SPA), and navigating between documents in a multi-page app (MPA).The view transition processLet's walk through the process by which a view transition works:


A view transition is triggered. How this is done depends on the type of view transition:

In the case of same-document transitions (SPAs), a view transition is triggered by passing the function that would trigger the view change DOM update as a callback to the document.startViewTransition() method.
In the case of cross-document transitions (MPAs), a view transition is triggered by initiating navigation to a new document. Both the current and destination documents of the navigation need to be on the same origin, and opt-in to the view transition by including a @view-transition at rule in their CSS with a navigation descriptor of auto.

Note:
An active view transition has an associated ViewTransition instance (for example, returned by startViewTransition() in the case of same-document (SPA) transitions). The ViewTransition object includes several promises, allowing you to run code in response to different parts of the view transition process being reached. See Controlling view transitions with JavaScript for more information.





On the current (old page) view, the API captures snapshots of elements that have a view-transition-name declared on them.


The view change occurs:


In the case of same-document transitions (SPAs), the callback passed to startViewTransition() is invoked, which causes the DOM to change.
When the callback has run successfully, the ViewTransition.updateCallbackDone promise fulfills, allowing you to respond to the DOM updating.


In the case of cross-document transitions (MPAs), the navigation occurs between the current and destination documents.




The API captures snapshots from the new view as a live representation.
At this point, the view transition is about to run, and the ViewTransition.ready promise fulfills, allowing you to respond by running a custom JavaScript animation instead of the default, for example.


The old page snapshots animate "out", while the new view snapshots animate "in". By default, the old view snapshots animate from opacity 1 to 0, and the new view snapshots animate from opacity 0 to 1, which creates a cross-fade.


When the transition animations have reached their end states, the ViewTransition.finished promise fulfills, allowing you to respond.



Note:
If the document's page visibility state is hidden (for example if the document is obscured by a window, the browser is minimized, or another browser tab is active) during a document.startViewTransition() call, the view transition is skipped entirely.
The view transition pseudo-element treeTo handle creating the outbound and inbound transition animations, the API constructs a pseudo-element tree with the following structure:
::view-transition
└─ ::view-transition-group(root)
  └─ ::view-transition-image-pair(root)
      ├─ ::view-transition-old(root)
      └─ ::view-transition-new(root)


Note:
A ::view-transition-group subtree is created for every captured view-transition-name.

In the case of same-document transitions (SPAs), the pseudo-element tree is made available in the document. In the case of cross-document transitions (MPAs), the pseudo-element tree is made available in the destination document only.
The most interesting parts of the tree structure are as follows:


::view-transition is the root of view transitions overlay, which contains all view transition snapshot groups and sits over the top of all other page content.


A ::view-transition-group acts as a container for each view transition snapshot group. The root argument specifies the default snapshot group — the view transition animation will apply to the snapshot whose view-transition-name is root. By default, this is the :root element, because the default browser styles define this:
css:root {
  view-transition-name: root;
}

Be aware however that page authors can change this by unsetting the above, and setting view-transition-name: root on a different element.


::view-transition-old targets the static snapshot of the old page element, and ::view-transition-new targets the live snapshot of the new page element. Both of these render as replaced content, in the same manner as an <img> or <video>, meaning that they can be styled with handy properties like object-fit and object-position.



Note:
It is possible to target different DOM elements with different custom view transition animations by setting a different view-transition-name on each one. In such cases, a ::view-transition-group is created for each one. See Different animations for different elements for an example.


Note:
As you'll see later, to customize the outbound and inbound animations you need to target the ::view-transition-old and ::view-transition-new pseudo-elements with your animations, respectively.
Creating a basic view transitionThis section illustrates how to create a basic view transition, in both the SPA and MPA case.Basic SPA view transitionAs an example, an SPA may include functionality to fetch new content and update the DOM in response to an event of some kind, such as a navigation link being clicked or an update being pushed from the server. In our View Transitions SPA demo we've simplified this to a displayNewImage() function that shows a new full-size image based on the thumbnail that was clicked. We've encapsulated this inside an updateView() function that only calls the View Transition API if the browser supports it:
jsfunction updateView(event) {
  // Handle the difference in whether the event is fired on the <a> or the <img>
  const targetIdentifier = event.target.firstChild || event.target;

  const displayNewImage = () => {
    const mainSrc = `${targetIdentifier.src.split("_th.jpg")[0]}.jpg`;
    galleryImg.src = mainSrc;
    galleryCaption.textContent = targetIdentifier.alt;
  };

  // Fallback for browsers that don't support View Transitions:
  if (!document.startViewTransition) {
    displayNewImage();
    return;
  }

  // With View Transitions:
  const transition = document.startViewTransition(() => displayNewImage());
}

This code is enough to handle the transition between displayed images. Supporting browsers will show the change from old to new images and captions as a smooth cross-fade (the default view transition). It will still work in non-supporting browsers but without the nice animation.Basic MPA view transitionWhen creating a cross-document (MPA) view transition, the process is even simpler than for SPAs. No JavaScript is required, as the view update is triggered by a cross-document, same-origin navigation rather than a JavaScript-initiated DOM change. To enable a basic MPA view transition, you need to specify a @view-transition at-rule in the CSS for both the current and destination documents to opt them in, like so:
css@view-transition {
  navigation: auto;
}

Our View Transitions MPA demo shows this at-rule in action, and additionally demonstrates how to customize the outbound and inbound animations of the view transition.

Note:
Currently MPA view transitions can only be created between same-origin documents, but this restriction may be relaxed in future implementations.
Customizing your animationsThe View Transitions pseudo-elements have default CSS Animations applied (which are detailed in their reference pages).
Most appearance transitions are given a default smooth cross-fade animation, as mentioned above. There are some exceptions:

height and width transitions have a smooth scaling animation applied.
position and transform transitions have a smooth movement animation applied.

You can modify the default animations in any way you want using regular CSS — target the "from" animation with ::view-transition-old, and the "to" animation with ::view-transition-new.
For example, to change the speed of both:
css::view-transition-old(root),
::view-transition-new(root) {
  animation-duration: 0.5s;
}

It is recommended that you target the ::view-transition-group() with such styles in cases where you want to apply them to ::view-transition-old() and ::view-transition-new(). Because of the pseudo-element hierarchy and default user-agent styling, the styles will be inherited by both. For example:
css::view-transition-group(root) {
  animation-duration: 0.5s;
}


Note:
This is also a good option for safeguarding your code — ::view-transition-group() also animates and you could end up with different durations for the group/image-pair pseudo-elements versus the old and new pseudo-elements.

In the case of cross-document (MPA) transitions, the pseudo-elements need to be included in the destination document only for the view transition to work. If you want to use the view transition in both directions, you'll need to include it in both, of course.
Our View Transitions MPA demo includes the above CSS, but takes the customization a step further, defining custom animations and applying them to the ::view-transition-old(root) and ::view-transition-new(root) pseudo-elements. The result is that the default cross-fade transition is swapped out for a "swipe up" transition when navigation occurs:
css/* Create a custom animation */

@keyframes move-out {
  from {
    transform: translateY(0%);
  }

  to {
    transform: translateY(-100%);
  }
}

@keyframes move-in {
  from {
    transform: translateY(100%);
  }

  to {
    transform: translateY(0%);
  }
}

/* Apply the custom animation to the old and new page states */

::view-transition-old(root) {
  animation: 0.4s ease-in both move-out;
}

::view-transition-new(root) {
  animation: 0.4s ease-in both move-in;
}
Different animations for different elementsBy default, all of the different elements that change during the view update are transitioned using the same animation. If you want some elements to animate differently from the default root animation, you can separate them out using the view-transition-name property. For example, in our View Transitions SPA demo the <figcaption> elements are given a view-transition-name of figure-caption to separate them from the rest of the page in terms of view transitions:
cssfigcaption {
  view-transition-name: figure-caption;
}

With this CSS applied, the generated pseudo-element tree will now look like this:
::view-transition
├─ ::view-transition-group(root)
│ └─ ::view-transition-image-pair(root)
│     ├─ ::view-transition-old(root)
│     └─ ::view-transition-new(root)
└─ ::view-transition-group(figure-caption)
  └─ ::view-transition-image-pair(figure-caption)
      ├─ ::view-transition-old(figure-caption)
      └─ ::view-transition-new(figure-caption)

The existence of the second set of pseudo-elements allows separate view transition styling to be applied just to the <figcaption>. The different old and new view captures are handled separately from one another.

Note:
The value of view-transition-name can be anything you want except for none — the none value specifically means that the element will not participate in a view transition.
view-transition-name values must also be unique. If two rendered elements have the same view-transition-name at the same time, ViewTransition.ready will reject and the transition will be skipped.

The following code applies a custom animation just to the <figcaption>:
css@keyframes grow-x {
  from {
    transform: scaleX(0);
  }
  to {
    transform: scaleX(1);
  }
}

@keyframes shrink-x {
  from {
    transform: scaleX(1);
  }
  to {
    transform: scaleX(0);
  }
}

::view-transition-group(figure-caption) {
  height: auto;
  right: 0;
  left: auto;
  transform-origin: right center;
}

::view-transition-old(figure-caption) {
  animation: 0.25s linear both shrink-x;
}

::view-transition-new(figure-caption) {
  animation: 0.25s 0.25s linear both grow-x;
}

Here we've created a custom CSS animation and applied it to the ::view-transition-old(figure-caption) and ::view-transition-new(figure-caption) pseudo-elements. We've also added a number of other styles to both to keep them in the same place and stop the default styling from interfering with our custom animations.

Note:
You can use * as the identifier in a pseudo-element to target all snapshot pseudo-elements, regardless of what name they have. For example:
css::view-transition-group(*) {
  animation-duration: 2s;
}

Taking advantage of the default animation stylesNote that we also discovered another transition option that is simpler and produced a nicer result than the above. Our final <figcaption> view transition ended up looking like this:
cssfigcaption {
  view-transition-name: figure-caption;
}

::view-transition-group(figure-caption) {
  height: 100%;
}

This works because, by default, ::view-transition-group transitions width and height between the old and new views with a smooth scale. We just needed to set a fixed height on both states to make it work.

Note: Smooth transitions with the View Transition API contains several other customization examples.
Controlling view transitions with JavaScriptA view transition has an associated ViewTransition object instance, which contains several promise members allowing you to run JavaScript in response to different states of the transition being reached. For example, ViewTransition.ready fulfills once the pseudo-element tree is created and the animation is about to start, whereas ViewTransition.finished fulfills once the animation is finished, and the new page view is visible and interactive to the user.
The ViewTransition can be accessed like so:


In the case of same-document (SPA) transitions, the document.startViewTransition() method returns the ViewTransition associated with the transition.


In the case of cross-document (MPA) transitions:

A pageswap event is fired when a document is about to be unloaded due to a navigation. Its event object (PageSwapEvent) provides access to the ViewTransition via the PageSwapEvent.viewTransition property, as well as a NavigationActivation via PageSwapEvent.activation containing the navigation type and current and destination document history entries.

Note:
If the navigation has a cross-origin URL anywhere in the redirect chain, the activation property returns null.


A pagereveal event is fired when a document is first rendered, either when loading a fresh document from the network or activating a document (either from back/forward cache (bfcache) or prerender). Its event object (PageRevealEvent) provides access to the ViewTransition via the PageRevealEvent.viewTransition property.



Let's have a look at some example code to show how these features could be used.A JavaScript-powered custom same-document (SPA) transitionThe following JavaScript could be used to create a circular reveal view transition emanating from the position of the user's cursor on click, with animation provided by the Web Animations API.
js// Store the last click event
let lastClick;
addEventListener("click", (event) => (lastClick = event));

function spaNavigate(data) {
  // Fallback for browsers that don't support this API:
  if (!document.startViewTransition) {
    updateTheDOMSomehow(data);
    return;
  }

  // Get the click position, or fallback to the middle of the screen
  const x = lastClick?.clientX ?? innerWidth / 2;
  const y = lastClick?.clientY ?? innerHeight / 2;
  // Get the distance to the furthest corner
  const endRadius = Math.hypot(
    Math.max(x, innerWidth - x),
    Math.max(y, innerHeight - y),
  );

  // Create a transition:
  const transition = document.startViewTransition(() => {
    updateTheDOMSomehow(data);
  });

  // Wait for the pseudo-elements to be created:
  transition.ready.then(() => {
    // Animate the root's new view
    document.documentElement.animate(
      {
        clipPath: [
          `circle(0 at ${x}px ${y}px)`,
          `circle(${endRadius}px at ${x}px ${y}px)`,
        ],
      },
      {
        duration: 500,
        easing: "ease-in",
        // Specify which pseudo-element to animate
        pseudoElement: "::view-transition-new(root)",
      },
    );
  });
}

This animation also requires the following CSS, to turn off the default CSS animation and stop the old and new view states from blending in any way (the new state "wipes" right over the top of the old state, rather than transitioning in):
css::view-transition-image-pair(root) {
  isolation: auto;
}

::view-transition-old(root),
::view-transition-new(root) {
  animation: none;
  mix-blend-mode: normal;
  display: block;
}
A JavaScript-powered custom cross-document (MPA) transitionThe List of Chrome DevRel team members demo provides a basic set of team profile pages, and demonstrates how to use the pageswap and pagereveal events to customize the outgoing and inbound animations of a cross-document view transition based on the "from" and "to" URLs.
The pageswap event listener looks as follows. This sets view transition names on the elements on the outbound page that link to the profile pages. When navigating from the home page to a profile page, custom animations are provided only for the linked element that is clicked in each case.
jswindow.addEventListener("pageswap", async (e) => {
  // Only run this if an active view transition exists
  if (e.viewTransition) {
    const currentUrl = e.activation.from?.url
      ? new URL(e.activation.from.url)
      : null;
    const targetUrl = new URL(e.activation.entry.url);

    // Going from profile page to homepage
    // ~> The big img and title are the ones!
    if (isProfilePage(currentUrl) && isHomePage(targetUrl)) {
      // Set view-transition-name values on the elements to animate
      document.querySelector(`#detail main h1`).style.viewTransitionName =
        "name";
      document.querySelector(`#detail main img`).style.viewTransitionName =
        "avatar";

      // Remove view-transition-names after snapshots have been taken
      // Stops naming conflicts resulting from the page state persisting in BFCache
      await e.viewTransition.finished;
      document.querySelector(`#detail main h1`).style.viewTransitionName =
        "none";
      document.querySelector(`#detail main img`).style.viewTransitionName =
        "none";
    }

    // Going to profile page
    // ~> The clicked items are the ones!
    if (isProfilePage(targetUrl)) {
      const profile = extractProfileNameFromUrl(targetUrl);

      // Set view-transition-name values on the elements to animate
      document.querySelector(`#${profile} span`).style.viewTransitionName =
        "name";
      document.querySelector(`#${profile} img`).style.viewTransitionName =
        "avatar";

      // Remove view-transition-names after snapshots have been taken
      // Stops naming conflicts resulting from the page state persisting in BFCache
      await e.viewTransition.finished;
      document.querySelector(`#${profile} span`).style.viewTransitionName =
        "none";
      document.querySelector(`#${profile} img`).style.viewTransitionName =
        "none";
    }
  }
});


Note:
We remove the view-transition-name values after snapshots have been taken in each case. If we left them set, they would persist in the page state saved in the bfcache upon navigation. If the back button was then pressed, the pagereveal event handler of the page being navigated back to would then attempt to set the same view-transition-name values on different elements. If multiple elements have the same view-transition-name set, the view transition is skipped.

The pagereveal event listener looks as follows. This works in a similar way to the pageswap event listener, although bear in mind that here we are customizing the "to" animation, for page elements on the new page.
jswindow.addEventListener("pagereveal", async (e) => {
  // If the "from" history entry does not exist, return
  if (!navigation.activation.from) return;

  // Only run this if an active view transition exists
  if (e.viewTransition) {
    const fromUrl = new URL(navigation.activation.from.url);
    const currentUrl = new URL(navigation.activation.entry.url);

    // Went from profile page to homepage
    // ~> Set VT names on the relevant list item
    if (isProfilePage(fromUrl) && isHomePage(currentUrl)) {
      const profile = extractProfileNameFromUrl(fromUrl);

      // Set view-transition-name values on the elements to animate
      document.querySelector(`#${profile} span`).style.viewTransitionName =
        "name";
      document.querySelector(`#${profile} img`).style.viewTransitionName =
        "avatar";

      // Remove names after snapshots have been taken
      // so that we're ready for the next navigation
      await e.viewTransition.ready;
      document.querySelector(`#${profile} span`).style.viewTransitionName =
        "none";
      document.querySelector(`#${profile} img`).style.viewTransitionName =
        "none";
    }

    // Went to profile page
    // ~> Set VT names on the main title and image
    if (isProfilePage(currentUrl)) {
      // Set view-transition-name values on the elements to animate
      document.querySelector(`#detail main h1`).style.viewTransitionName =
        "name";
      document.querySelector(`#detail main img`).style.viewTransitionName =
        "avatar";

      // Remove names after snapshots have been taken
      // so that we're ready for the next navigation
      await e.viewTransition.ready;
      document.querySelector(`#detail main h1`).style.viewTransitionName =
        "none";
      document.querySelector(`#detail main img`).style.viewTransitionName =
        "none";
    }
  }
});
Stabilizing page state to make cross-document transitions consistentBefore running a cross-document transition, you ideally want to wait until the state of the page stabilizes, relying on render blocking to ensure that:

Critical styles are loaded and applied.
Critical scripts are loaded and run.
The HTML visible for the user's initial view of the page has been parsed, so it renders consistently.

Styles are render blocked by default, and scripts can be render blocked using the blocking="render" attribute.
To ensure that your initial HTML has been parsed and will always render consistently before the transition animation runs, you can use <link rel="expect">. In this element, you include the following attributes:

rel="expect" to indicate that you want to use this <link> element to render block some HTML on the page.
href="#element-id" to indicate the ID of the element you want to render block.
blocking="render" to render block the specified HTML.

Let's explore what this looks like with an example HTML document:
html<!doctype html>
<html lang="en">
  <head>
    <!-- This will be render-blocking by default -->
    <link rel="stylesheet" href="style.css" />

    <!-- Marking critical scripts as render blocking will
         ensure they're run before the view transition is activated -->
    <script async href="layout.js" blocking="render"></script>

    <!-- Use rel="expect" and blocking="render" to ensure the
         #lead-content element is visible and fully parsed before
         activating the transition -->
    <link rel="expect" href="#lead-content" blocking="render" />
  </head>
  <body>
    <h1>Page title</h1>
    <nav>...</nav>
    <div id="lead-content">
      <section id="first-section">The first section</section>
      <section>The second section</section>
    </div>
  </body>
</html>

The result is that document rendering is blocked until the lead content <div> has been parsed, ensuring a consistent view transition.
You can also specify a media attribute on <link rel="expect"> elements. For example, you might want to block rendering on a smaller amount of content when loading the page on a narrow-screen device, than on a wide-screen device. This makes sense — on a mobile, less content will be visible when the page first loads than in the case of a desktop.
This could be achieved with the following HTML:
html<link
  rel="expect"
  href="#lead-content"
  blocking="render"
  media="screen and (min-width: 641px)" />
<link
  rel="expect"
  href="#first-section"
  blocking="render"
  media="screen and (max-width: 640px)" />
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nUsing the View Transition APIThis article explains the theory behind how the View Transition API works, how to create view transitions and customize the transition animations, and how to manipulate active view transitions. This covers view transitions for both DOM state updates in a single-page app (SPA), and navigating between documents in a multi-page app (MPA).The view transition processLet's walk through the process by which a view transition works:


A view transition is triggered. How this is done depends on the type of view transition:

In the case of same-document transitions (SPAs), a view transition is triggered by passing the function that would trigger the view change DOM update as a callback to the document.startViewTransition() method.
In the case of cross-document transitions (MPAs), a view transition is triggered by initiating navigation to a new document. Both the current and destination documents of the navigation need to be on the same origin, and opt-in to the view transition by including a @view-transition at rule in their CSS with a navigation descriptor of auto.

Note:
An active view transition has an associated ViewTransition instance (for example, returned by startViewTransition() in the case of same-document (SPA) transitions). The ViewTransition object includes several promises, allowing you to run code in response to different parts of the view transition process being reached. See Controlling view transitions with JavaScript for more information.





On the current (old page) view, the API captures snapshots of elements that have a view-transition-name declared on them.


The view change occurs:


In the case of same-document transitions (SPAs), the callback passed to startViewTransition() is invoked, which causes the DOM to change.
When the callback has run successfully, the ViewTransition.updateCallbackDone promise fulfills, allowing you to respond to the DOM updating.


In the case of cross-document transitions (MPAs), the navigation occurs between the current and destination documents.




The API captures snapshots from the new view as a live representation.
At this point, the view transition is about to run, and the ViewTransition.ready promise fulfills, allowing you to respond by running a custom JavaScript animation instead of the default, for example.


The old page snapshots animate "out", while the new view snapshots animate "in". By default, the old view snapshots animate from opacity 1 to 0, and the new view snapshots animate from opacity 0 to 1, which creates a cross-fade.


When the transition animations have reached their end states, the ViewTransition.finished promise fulfills, allowing you to respond.



Note:
If the document's page visibility state is hidden (for example if the document is obscured by a window, the browser is minimized, or another browser tab is active) during a document.startViewTransition() call, the view transition is skipped entirely.
The view transition pseudo-element treeTo handle creating the outbound and inbound transition animations, the API constructs a pseudo-element tree with the following structure:
::view-transition
└─ ::view-transition-group(root)
  └─ ::view-transition-image-pair(root)
      ├─ ::view-transition-old(root)
      └─ ::view-transition-new(root)


Note:
A ::view-transition-group subtree is created for every captured view-transition-name.

In the case of same-document transitions (SPAs), the pseudo-element tree is made available in the document. In the case of cross-document transitions (MPAs), the pseudo-element tree is made available in the destination document only.
The most interesting parts of the tree structure are as follows:


::view-transition is the root of view transitions overlay, which contains all view transition snapshot groups and sits over the top of all other page content.


A ::view-transition-group acts as a container for each view transition snapshot group. The root argument specifies the default snapshot group — the view transition animation will apply to the snapshot whose view-transition-name is root. By default, this is the :root element, because the default browser styles define this:
css:root {
  view-transition-name: root;
}

Be aware however that page authors can change this by unsetting the above, and setting view-transition-name: root on a different element.


::view-transition-old targets the static snapshot of the old page element, and ::view-transition-new targets the live snapshot of the new page element. Both of these render as replaced content, in the same manner as an <img> or <video>, meaning that they can be styled with handy properties like object-fit and object-position.



Note:
It is possible to target different DOM elements with different custom view transition animations by setting a different view-transition-name on each one. In such cases, a ::view-transition-group is created for each one. See Different animations for different elements for an example.


Note:
As you'll see later, to customize the outbound and inbound animations you need to target the ::view-transition-old and ::view-transition-new pseudo-elements with your animations, respectively.
Creating a basic view transitionThis section illustrates how to create a basic view transition, in both the SPA and MPA case.Basic SPA view transitionAs an example, an SPA may include functionality to fetch new content and update the DOM in response to an event of some kind, such as a navigation link being clicked or an update being pushed from the server. In our View Transitions SPA demo we've simplified this to a displayNewImage() function that shows a new full-size image based on the thumbnail that was clicked. We've encapsulated this inside an updateView() function that only calls the View Transition API if the browser supports it:
jsfunction updateView(event) {
  // Handle the difference in whether the event is fired on the <a> or the <img>
  const targetIdentifier = event.target.firstChild || event.target;

  const displayNewImage = () => {
    const mainSrc = `${targetIdentifier.src.split("_th.jpg")[0]}.jpg`;
    galleryImg.src = mainSrc;
    galleryCaption.textContent = targetIdentifier.alt;
  };

  // Fallback for browsers that don't support View Transitions:
  if (!document.startViewTransition) {
    displayNewImage();
    return;
  }

  // With View Transitions:
  const transition = document.startViewTransition(() => displayNewImage());
}

This code is enough to handle the transition between displayed images. Supporting browsers will show the change from old to new images and captions as a smooth cross-fade (the default view transition). It will still work in non-supporting browsers but without the nice animation.Basic MPA view transitionWhen creating a cross-document (MPA) view transition, the process is even simpler than for SPAs. No JavaScript is required, as the view update is triggered by a cross-document, same-origin navigation rather than a JavaScript-initiated DOM change. To enable a basic MPA view transition, you need to specify a @view-transition at-rule in the CSS for both the current and destination documents to opt them in, like so:
css@view-transition {
  navigation: auto;
}

Our View Transitions MPA demo shows this at-rule in action, and additionally demonstrates how to customize the outbound and inbound animations of the view transition.

Note:
Currently MPA view transitions can only be created between same-origin documents, but this restriction may be relaxed in future implementations.
Customizing your animationsThe View Transitions pseudo-elements have default CSS Animations applied (which are detailed in their reference pages).
Most appearance transitions are given a default smooth cross-fade animation, as mentioned above. There are some exceptions:

height and width transitions have a smooth scaling animation applied.
position and transform transitions have a smooth movement animation applied.

You can modify the default animations in any way you want using regular CSS — target the "from" animation with ::view-transition-old, and the "to" animation with ::view-transition-new.
For example, to change the speed of both:
css::view-transition-old(root),
::view-transition-new(root) {
  animation-duration: 0.5s;
}

It is recommended that you target the ::view-transition-group() with such styles in cases where you want to apply them to ::view-transition-old() and ::view-transition-new(). Because of the pseudo-element hierarchy and default user-agent styling, the styles will be inherited by both. For example:
css::view-transition-group(root) {
  animation-duration: 0.5s;
}


Note:
This is also a good option for safeguarding your code — ::view-transition-group() also animates and you could end up with different durations for the group/image-pair pseudo-elements versus the old and new pseudo-elements.

In the case of cross-document (MPA) transitions, the pseudo-elements need to be included in the destination document only for the view transition to work. If you want to use the view transition in both directions, you'll need to include it in both, of course.
Our View Transitions MPA demo includes the above CSS, but takes the customization a step further, defining custom animations and applying them to the ::view-transition-old(root) and ::view-transition-new(root) pseudo-elements. The result is that the default cross-fade transition is swapped out for a "swipe up" transition when navigation occurs:
css/* Create a custom animation */

@keyframes move-out {
  from {
    transform: translateY(0%);
  }

  to {
    transform: translateY(-100%);
  }
}

@keyframes move-in {
  from {
    transform: translateY(100%);
  }

  to {
    transform: translateY(0%);
  }
}

/* Apply the custom animation to the old and new page states */

::view-transition-old(root) {
  animation: 0.4s ease-in both move-out;
}

::view-transition-new(root) {
  animation: 0.4s ease-in both move-in;
}
Different animations for different elementsBy default, all of the different elements that change during the view update are transitioned using the same animation. If you want some elements to animate differently from the default root animation, you can separate them out using the view-transition-name property. For example, in our View Transitions SPA demo the <figcaption> elements are given a view-transition-name of figure-caption to separate them from the rest of the page in terms of view transitions:
cssfigcaption {
  view-transition-name: figure-caption;
}

With this CSS applied, the generated pseudo-element tree will now look like this:
::view-transition
├─ ::view-transition-group(root)
│ └─ ::view-transition-image-pair(root)
│     ├─ ::view-transition-old(root)
│     └─ ::view-transition-new(root)
└─ ::view-transition-group(figure-caption)
  └─ ::view-transition-image-pair(figure-caption)
      ├─ ::view-transition-old(figure-caption)
      └─ ::view-transition-new(figure-caption)

The existence of the second set of pseudo-elements allows separate view transition styling to be applied just to the <figcaption>. The different old and new view captures are handled separately from one another.

Note:
The value of view-transition-name can be anything you want except for none — the none value specifically means that the element will not participate in a view transition.
view-transition-name values must also be unique. If two rendered elements have the same view-transition-name at the same time, ViewTransition.ready will reject and the transition will be skipped.

The following code applies a custom animation just to the <figcaption>:
css@keyframes grow-x {
  from {
    transform: scaleX(0);
  }
  to {
    transform: scaleX(1);
  }
}

@keyframes shrink-x {
  from {
    transform: scaleX(1);
  }
  to {
    transform: scaleX(0);
  }
}

::view-transition-group(figure-caption) {
  height: auto;
  right: 0;
  left: auto;
  transform-origin: right center;
}

::view-transition-old(figure-caption) {
  animation: 0.25s linear both shrink-x;
}

::view-transition-new(figure-caption) {
  animation: 0.25s 0.25s linear both grow-x;
}

Here we've created a custom CSS animation and applied it to the ::view-transition-old(figure-caption) and ::view-transition-new(figure-caption) pseudo-elements. We've also added a number of other styles to both to keep them in the same place and stop the default styling from interfering with our custom animations.

Note:
You can use * as the identifier in a pseudo-element to target all snapshot pseudo-elements, regardless of what name they have. For example:
css::view-transition-group(*) {
  animation-duration: 2s;
}

Taking advantage of the default animation stylesNote that we also discovered another transition option that is simpler and produced a nicer result than the above. Our final <figcaption> view transition ended up looking like this:
cssfigcaption {
  view-transition-name: figure-caption;
}

::view-transition-group(figure-caption) {
  height: 100%;
}

This works because, by default, ::view-transition-group transitions width and height between the old and new views with a smooth scale. We just needed to set a fixed height on both states to make it work.

Note: Smooth transitions with the View Transition API contains several other customization examples.
Controlling view transitions with JavaScriptA view transition has an associated ViewTransition object instance, which contains several promise members allowing you to run JavaScript in response to different states of the transition being reached. For example, ViewTransition.ready fulfills once the pseudo-element tree is created and the animation is about to start, whereas ViewTransition.finished fulfills once the animation is finished, and the new page view is visible and interactive to the user.
The ViewTransition can be accessed like so:


In the case of same-document (SPA) transitions, the document.startViewTransition() method returns the ViewTransition associated with the transition.


In the case of cross-document (MPA) transitions:

A pageswap event is fired when a document is about to be unloaded due to a navigation. Its event object (PageSwapEvent) provides access to the ViewTransition via the PageSwapEvent.viewTransition property, as well as a NavigationActivation via PageSwapEvent.activation containing the navigation type and current and destination document history entries.

Note:
If the navigation has a cross-origin URL anywhere in the redirect chain, the activation property returns null.


A pagereveal event is fired when a document is first rendered, either when loading a fresh document from the network or activating a document (either from back/forward cache (bfcache) or prerender). Its event object (PageRevealEvent) provides access to the ViewTransition via the PageRevealEvent.viewTransition property.



Let's have a look at some example code to show how these features could be used.A JavaScript-powered custom same-document (SPA) transitionThe following JavaScript could be used to create a circular reveal view transition emanating from the position of the user's cursor on click, with animation provided by the Web Animations API.
js// Store the last click event
let lastClick;
addEventListener("click", (event) => (lastClick = event));

function spaNavigate(data) {
  // Fallback for browsers that don't support this API:
  if (!document.startViewTransition) {
    updateTheDOMSomehow(data);
    return;
  }

  // Get the click position, or fallback to the middle of the screen
  const x = lastClick?.clientX ?? innerWidth / 2;
  const y = lastClick?.clientY ?? innerHeight / 2;
  // Get the distance to the furthest corner
  const endRadius = Math.hypot(
    Math.max(x, innerWidth - x),
    Math.max(y, innerHeight - y),
  );

  // Create a transition:
  const transition = document.startViewTransition(() => {
    updateTheDOMSomehow(data);
  });

  // Wait for the pseudo-elements to be created:
  transition.ready.then(() => {
    // Animate the root's new view
    document.documentElement.animate(
      {
        clipPath: [
          `circle(0 at ${x}px ${y}px)`,
          `circle(${endRadius}px at ${x}px ${y}px)`,
        ],
      },
      {
        duration: 500,
        easing: "ease-in",
        // Specify which pseudo-element to animate
        pseudoElement: "::view-transition-new(root)",
      },
    );
  });
}

This animation also requires the following CSS, to turn off the default CSS animation and stop the old and new view states from blending in any way (the new state "wipes" right over the top of the old state, rather than transitioning in):
css::view-transition-image-pair(root) {
  isolation: auto;
}

::view-transition-old(root),
::view-transition-new(root) {
  animation: none;
  mix-blend-mode: normal;
  display: block;
}
A JavaScript-powered custom cross-document (MPA) transitionThe List of Chrome DevRel team members demo provides a basic set of team profile pages, and demonstrates how to use the pageswap and pagereveal events to customize the outgoing and inbound animations of a cross-document view transition based on the "from" and "to" URLs.
The pageswap event listener looks as follows. This sets view transition names on the elements on the outbound page that link to the profile pages. When navigating from the home page to a profile page, custom animations are provided only for the linked element that is clicked in each case.
jswindow.addEventListener("pageswap", async (e) => {
  // Only run this if an active view transition exists
  if (e.viewTransition) {
    const currentUrl = e.activation.from?.url
      ? new URL(e.activation.from.url)
      : null;
    const targetUrl = new URL(e.activation.entry.url);

    // Going from profile page to homepage
    // ~> The big img and title are the ones!
    if (isProfilePage(currentUrl) && isHomePage(targetUrl)) {
      // Set view-transition-name values on the elements to animate
      document.querySelector(`#detail main h1`).style.viewTransitionName =
        "name";
      document.querySelector(`#detail main img`).style.viewTransitionName =
        "avatar";

      // Remove view-transition-names after snapshots have been taken
      // Stops naming conflicts resulting from the page state persisting in BFCache
      await e.viewTransition.finished;
      document.querySelector(`#detail main h1`).style.viewTransitionName =
        "none";
      document.querySelector(`#detail main img`).style.viewTransitionName =
        "none";
    }

    // Going to profile page
    // ~> The clicked items are the ones!
    if (isProfilePage(targetUrl)) {
      const profile = extractProfileNameFromUrl(targetUrl);

      // Set view-transition-name values on the elements to animate
      document.querySelector(`#${profile} span`).style.viewTransitionName =
        "name";
      document.querySelector(`#${profile} img`).style.viewTransitionName =
        "avatar";

      // Remove view-transition-names after snapshots have been taken
      // Stops naming conflicts resulting from the page state persisting in BFCache
      await e.viewTransition.finished;
      document.querySelector(`#${profile} span`).style.viewTransitionName =
        "none";
      document.querySelector(`#${profile} img`).style.viewTransitionName =
        "none";
    }
  }
});


Note:
We remove the view-transition-name values after snapshots have been taken in each case. If we left them set, they would persist in the page state saved in the bfcache upon navigation. If the back button was then pressed, the pagereveal event handler of the page being navigated back to would then attempt to set the same view-transition-name values on different elements. If multiple elements have the same view-transition-name set, the view transition is skipped.

The pagereveal event listener looks as follows. This works in a similar way to the pageswap event listener, although bear in mind that here we are customizing the "to" animation, for page elements on the new page.
jswindow.addEventListener("pagereveal", async (e) => {
  // If the "from" history entry does not exist, return
  if (!navigation.activation.from) return;

  // Only run this if an active view transition exists
  if (e.viewTransition) {
    const fromUrl = new URL(navigation.activation.from.url);
    const currentUrl = new URL(navigation.activation.entry.url);

    // Went from profile page to homepage
    // ~> Set VT names on the relevant list item
    if (isProfilePage(fromUrl) && isHomePage(currentUrl)) {
      const profile = extractProfileNameFromUrl(fromUrl);

      // Set view-transition-name values on the elements to animate
      document.querySelector(`#${profile} span`).style.viewTransitionName =
        "name";
      document.querySelector(`#${profile} img`).style.viewTransitionName =
        "avatar";

      // Remove names after snapshots have been taken
      // so that we're ready for the next navigation
      await e.viewTransition.ready;
      document.querySelector(`#${profile} span`).style.viewTransitionName =
        "none";
      document.querySelector(`#${profile} img`).style.viewTransitionName =
        "none";
    }

    // Went to profile page
    // ~> Set VT names on the main title and image
    if (isProfilePage(currentUrl)) {
      // Set view-transition-name values on the elements to animate
      document.querySelector(`#detail main h1`).style.viewTransitionName =
        "name";
      document.querySelector(`#detail main img`).style.viewTransitionName =
        "avatar";

      // Remove names after snapshots have been taken
      // so that we're ready for the next navigation
      await e.viewTransition.ready;
      document.querySelector(`#detail main h1`).style.viewTransitionName =
        "none";
      document.querySelector(`#detail main img`).style.viewTransitionName =
        "none";
    }
  }
});
Stabilizing page state to make cross-document transitions consistentBefore running a cross-document transition, you ideally want to wait until the state of the page stabilizes, relying on render blocking to ensure that:

Critical styles are loaded and applied.
Critical scripts are loaded and run.
The HTML visible for the user's initial view of the page has been parsed, so it renders consistently.

Styles are render blocked by default, and scripts can be render blocked using the blocking="render" attribute.
To ensure that your initial HTML has been parsed and will always render consistently before the transition animation runs, you can use <link rel="expect">. In this element, you include the following attributes:

rel="expect" to indicate that you want to use this <link> element to render block some HTML on the page.
href="#element-id" to indicate the ID of the element you want to render block.
blocking="render" to render block the specified HTML.

Let's explore what this looks like with an example HTML document:
html<!doctype html>
<html lang="en">
  <head>
    <!-- This will be render-blocking by default -->
    <link rel="stylesheet" href="style.css" />

    <!-- Marking critical scripts as render blocking will
         ensure they're run before the view transition is activated -->
    <script async href="layout.js" blocking="render"></script>

    <!-- Use rel="expect" and blocking="render" to ensure the
         #lead-content element is visible and fully parsed before
         activating the transition -->
    <link rel="expect" href="#lead-content" blocking="render" />
  </head>
  <body>
    <h1>Page title</h1>
    <nav>...</nav>
    <div id="lead-content">
      <section id="first-section">The first section</section>
      <section>The second section</section>
    </div>
  </body>
</html>

The result is that document rendering is blocked until the lead content <div> has been parsed, ensuring a consistent view transition.
You can also specify a media attribute on <link rel="expect"> elements. For example, you might want to block rendering on a smaller amount of content when loading the page on a narrow-screen device, than on a wide-screen device. This makes sense — on a mobile, less content will be visible when the page first loads than in the case of a desktop.
This could be achieved with the following HTML:
html<link
  rel="expect"
  href="#lead-content"
  blocking="render"
  media="screen and (min-width: 641px)" />
<link
  rel="expect"
  href="#first-section"
  blocking="render"
  media="screen and (max-width: 640px)" />
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nMDN 2024 content projectsVadim MakeevJanuary 8, 20259 minute readMDN Web Docs provides accurate and accessible resources for people getting started building for the web right through to professional developers.
Our commitment includes maintenance of long-existing content and documenting features that are brand new to the web platform.
In 2024, the MDN content team chose some content areas to audit and update so they stay useful and relevant in an evolving web platform.
We looked at topics that were popular but contained some outdated or incomplete material, and invested time in improvements, additions, and removing obsolete content.
This post recaps what we achieved in our content projects in 2024, highlights some of our top picks and recommended reading, and looks forward to what's next on MDN for 2025.2024 MDN content areasFor 2024, we chose three technology categories that are popular, but had reader feedback that indicated they needed a refresh.
We focused on HTTP, MathML, and web Manifests.
From July to December 2024, the team worked through these areas to bring the quality up in a number of ways.
Let's have a look at what changed in each section below.MathMLMathML is an XML-based language for describing mathematical notation on the web. Similar to SVG, MathML can also be included in the HTML and rendered by the browser, no plugins or libraries are required.

  
    ∑
    
      n
      =
      1
    
    
      +
      ∞
    
  

html<math display="block">
  <munderover>
    <mo>∑</mo>
    <mrow>
      <mi>n</mi>
      <mo>=</mo>
      <mn>1</mn>
    </mrow>
    <mrow>
      <mo>+</mo>
      <mn>∞</mn>
    </mrow>
  </munderover>
</math>

Unlike the MathML Core specification, which often groups elements, MDN now features each MathML element on its page, with examples, usage notes, and BCD (browser-compat-data) now also updated. For example, you can read about <semantics>, <annotation> and <annotation-xml> elements and how they help to annotate MathML expressions.
Just like we're writing this blog post using Markdown instead of HTML, MathML is often generated by math processors using lightweight markup languages like LaTeX. To help content authors, all MathML examples now have annotations. For example, x2+yx^{2} + y can be written as x^{2} + y in LaTeX:
html<math>
  <semantics>
    <mrow>
      <msup>
        <mi>x</mi>
        <mn>2</mn>
      </msup>
      <mo>+</mo>
      <mi>y</mi>
    </mrow>
    <!-- Annotated with LaTeX, a lightweight markup language. -->
    <annotation encoding="application/x-tex">x^{2} + y</annotation>
  </semantics>
</math>

This will also allow us to start using LaTeX for MathML in the future, making it easier for content authors to write and maintain examples. To fully appreciate the difference, you can compare the full MathML source code of some bigger examples, such as Deriving the Quadratic Formula and Proving the Pythagorean theorem, with their LaTeX equivalents.
MathML documentation on MDN now features accessibility information for all elements. For example, using <math> element for representing math content allows screen readers to read the formula, which makes MathML better for such cases than using images or other formats.
Additionally, all MathML features now have live examples, so you can see how they're rendered in your browser. And just like with other live examples on MDN, you can always click "Play" in the top right corner to play around with the code in a new tab.
html,
body {
  height: 100%;
}

body {
  display: grid;
  place-items: center;
  font-size: 1.5rem;
}

<math display="block">
  <mrow>
    <mi>x</mi>
    <mo>=</mo>
    <mfrac>
      <mrow>
        <mrow>
          <mo>−</mo>
          <mi>b</mi>
        </mrow>
        <mo>±</mo>
        <msqrt>
          <mrow>
            <msup>
              <mi>b</mi>
              <mn>2</mn>
            </msup>
            <mo>−</mo>
            <mrow>
              <mn>4</mn>
              <mo>⁢</mo>
              <mi>a</mi>
              <mo>⁢</mo>
              <mi>c</mi>
            </mrow>
          </mrow>
        </msqrt>
      </mrow>
      <mrow>
        <mn>2</mn>
        <mo>⁢</mo>
        <mi>a</mi>
      </mrow>
    </mfrac>
  </mrow>
</math>


Not only is MathML documented on MDN, but it's also used to describe different parts of the web platform. For example, Set.difference() JavaScript method, CSS transformation functions, 3D collision detection in game development, WebXR Device API, and many more.
We made sure MathML is now rendered correctly throughout MDN: inside paragraphs and on the block level, on big and small screens, and in different browsers.Manifest (web app manifests)A web app manifest is a JSON text file that provides information about a web application.
The most common use for a manifest is to provide information that the browser needs to install a progressive web app (PWA) on a device, such as the app's name and icon.
json{
  "name": "HackerWeb",
  "short_name": "HackerWeb",
  "start_url": "/index.html",
  "display": "standalone",
  "background_color": "#ffffff",
  "description": "A readable Hacker News app",
  "icons": [
    {
      "src": "images/icons/homescreen192.png",
      "sizes": "192x192",
      "type": "image/png"
    }
  ]
}

For the manifest content updates, Dipika collaborated with Firefox engineer Jonathan Almeida to update browser compatibility data for manifest members in Firefox.
The manifest BCD additions now cover compat data for Firefox and Firefox for Android, ensuring accurate and up-to-date support information.
Readers on MDN, Can I use, and other sites, now have solid guidance on manifest support across browsers.
On the content side, several improvements landed across the section for prose, layout and templating fixes.
The page template is now improved for readability and consistency across the entire section.
For each member value (for example, "display": "standalone",), there is a proper prose description, with example scenarios where the value might be used.
Usage notes are collected into a dedicated "Description" section, and any caveats that the specification mentioned that were not in the MDN pages and now documented.
Some pages were missing "Syntax" sections completely, so now these gaps are filled so readers can better understand how to use the documented features and some possible member values:
json/* Boolean values */
"prefer_related_applications": true
"prefer_related_applications": false

This refresh made sure that the existing content was more comprehensive and readable but also included references to similar features, which allowed for more flexibility for developers. For example, using prefers-color-scheme in HTML to set different theme_color values for light and dark mode:
html<meta
  name="theme-color"
  content="#F4E6D8"
  media="(prefers-color-scheme: light)" />
<meta
  name="theme-color"
  content="#5D4037"
  media="(prefers-color-scheme: dark)" />
HTTP content updatesHTTP is a protocol that's foundational for data exchange on the web.
It allows communication between browsers and servers, but it can also be used for machine-to-machine communication, automating access to APIs, and more.
On MDN, the HTTP section has over 300 pages of reference material, and the majority of pages are about HTTP headers and response status codes.
Response status codes let the client know the outcome of a HTTP request (such as 200, 404), and give some additional context in certain cases.
There are 61 status codes documented on MDN and they include examples for common responses and clarifications for rarer types that web developers may not encounter often.
You can even make sure you're familiar with the 418 (I'm a teapot) status just in case.
There are 148 HTTP headers documented on MDN.
HTTP headers are the parts of the HTTP message that carry metadata, information about the client or server, instructions for the recipient, and so on.
Some headers have several sub-pages that describe mechanisms you can control via headers, such as Content Security Policy (CSP) directives that instruct a browser to restrict what the code comprising a site can run and Permissions Policy directives for requesting permission to use browser features such as location or microphone access.
The HTTP guides have overviews of how the protocol works, describing the evolution of the protocol from HTTP/0.9 right through to current versions.
We document different ways to control HTTP interactions such as caching and conditional requests, and we have guides about how to use and understand the protocol for beginners, right up to more involved topics.
A lot of the refresh of these guides meant making less specific references to HTTP/1.1 when talking about message formats seeing as HTTP/2 and HTTP/3 are increasingly common.
httpHEAD /en-US/docs/Web/HTTP HTTP/2
Host: developer.mozilla.org
User-Agent: curl/8.7.1
Accept: */*

* Request completely sent off
HTTP/2 200

To summarize, the changes we made across the entire HTTP section included adding examples where they were missing or too short to be useful, removing outdated or obsolete information, and making the formatting and presentation consistent over all pages.
HTTP highlights on MDN
Part of the refresh involved updating and adding sequence diagrams that explain client-server exchanges.
We've been finding mermaid syntax useful for a lot of these types of diagrams as it makes it easier to store sources for images that we may need to update later.
These images are stored in the shared-assets repository, which allows us to reuse images instead of duplicate them in the source, and these are easier to write, read, maintain, and they look nice, too:

One interesting pick from the HTTP section is the Server-Timing response header that you can use to surface server metrics to a client:
httpHTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Content-Length: 123
Date: Fri, 03 Jan 2025 10:41:21 GMT
Server-Timing: custom-metric;dur=123.45;desc="My custom metric"

--- response body ---

Depending on the type of request, you can decide if you want to send server timings to the client, and these are visible in the Network request details panel in most browser's developer tools.
For example, the BBC iPlayer is using the Server-Timing header to send performance metrics about the service, visible in the Network > Timings panel below.
If you find this interesting, be sure to check the Performance API and the Web performance documentation.

For the HTTP section, most of the BCD updates involved improving the accuracy of existing entries and adding missing compat data for headers.
Additions included the Service-Worker request header for logging service worker script requests and the Sec-Websocket-* headers used in the WebSocket handshake.
Most of the HTTP updates are for older features, but the accuracy of the support information is crucial for developers making decisions about what to build.
One example is the Trailer compatibility details which now reflects browser implementations.
It's important to avoid misleading information in compatibility tables because they may encourage people to develop functionality in their applications for features that have poor browser support in reality.Other 2024 content highlights on MDNHere's a few interesting picks of documentation that landed in 2024:

New! CSS anchor positioning documentation
New! Using the View Transition API guide

Aside from reference docs, we've written about these topics on the MDN blog:

Locale-sensitive text segmentation in JavaScript with Intl.Segmenter
Exclusive accordions using the HTML <details> element
New JavaScript Set methods
Using the Page Visibility API
Interop 2023: MDN updates
Creating effective technical documentation

We also blogged about these changes and launches:

A new learning experience on MDN merging the MDN Curriculum into Learn Web Development.
Introducing the MDN HTTP Observatory for testing server HTTP header configuration.
And, of course, we have a new Community page which we are delighted to share!
Firefox release notes for developersFirefox release notes describe what's changed for everyday browser users.
The MDN team document each Firefox release with release notes specifically for developers.
That means in 2024, Firefox versions 122 up to 133 have pages describing the changes in each Firefox release that developers can target.
You can find everything in the Firefox release notes for developers pages.
Something you may not be aware of is that we also document Experimental features in Firefox.
This page describes features implemented in Firefox that are only available behind a preference (though configuration).
You can test out upcoming features before they are released, which is ideal if you're planning to use an experimental technology or if you're curious and would like to provide feedback on Bugzilla.Kicking off 2025The content projects that the team worked on were a superb learning experience, and we hope our readers benefit greatly from it.
If you want to make our docs better, let us know if there are other sections that need attention, and even lend your expertise.
If you want to learn about a topic, why not try to improve the documentation!
By contributing to MDN, you can improve your skills in a technology category, and millions of readers will benefit from it.
We're happy to share that we saw the following contributions in mdn/content GitHub repository in 2024:

915 different authors contributed.
~4300 pull requests opened.
~1500 issues opened.

We want to send out a big thanks to everyone who contributed in 2024 and we hope to see you continue in 2025.
One of the first larger changes we're excited to see is that JavaScript Temporal is coming with support scheduled to land in Firefox 135.
There is a huge pull request for Temporal authored by Josh-Cena, which means you can expect to be able to read Temporal documentation on MDN very soon.
We hope you enjoyed this post!
Feel free to get in touch with us and let us know what you think.Previous Post A new learning experience on MDNNext Post Fix your website's Largest Contentful Paint by optimizing image loadingPrevious Post A new learning experience on MDNNext Post Fix your website's Largest Contentful Paint by optimizing image loading\n\nIn this article2024 MDN content areasMathMLManifest (web app manifests)Other 2024 content highlights on MDNKicking off 2025MDN 2024 content projectsVadim MakeevJanuary 8, 20259 minute readMDN Web Docs provides accurate and accessible resources for people getting started building for the web right through to professional developers.
Our commitment includes maintenance of long-existing content and documenting features that are brand new to the web platform.
In 2024, the MDN content team chose some content areas to audit and update so they stay useful and relevant in an evolving web platform.
We looked at topics that were popular but contained some outdated or incomplete material, and invested time in improvements, additions, and removing obsolete content.
This post recaps what we achieved in our content projects in 2024, highlights some of our top picks and recommended reading, and looks forward to what's next on MDN for 2025.2024 MDN content areasFor 2024, we chose three technology categories that are popular, but had reader feedback that indicated they needed a refresh.
We focused on HTTP, MathML, and web Manifests.
From July to December 2024, the team worked through these areas to bring the quality up in a number of ways.
Let's have a look at what changed in each section below.MathMLMathML is an XML-based language for describing mathematical notation on the web. Similar to SVG, MathML can also be included in the HTML and rendered by the browser, no plugins or libraries are required.

  
    ∑
    
      n
      =
      1
    
    
      +
      ∞
    
  

html<math display="block">
  <munderover>
    <mo>∑</mo>
    <mrow>
      <mi>n</mi>
      <mo>=</mo>
      <mn>1</mn>
    </mrow>
    <mrow>
      <mo>+</mo>
      <mn>∞</mn>
    </mrow>
  </munderover>
</math>

Unlike the MathML Core specification, which often groups elements, MDN now features each MathML element on its page, with examples, usage notes, and BCD (browser-compat-data) now also updated. For example, you can read about <semantics>, <annotation> and <annotation-xml> elements and how they help to annotate MathML expressions.
Just like we're writing this blog post using Markdown instead of HTML, MathML is often generated by math processors using lightweight markup languages like LaTeX. To help content authors, all MathML examples now have annotations. For example, x2+yx^{2} + y can be written as x^{2} + y in LaTeX:
html<math>
  <semantics>
    <mrow>
      <msup>
        <mi>x</mi>
        <mn>2</mn>
      </msup>
      <mo>+</mo>
      <mi>y</mi>
    </mrow>
    <!-- Annotated with LaTeX, a lightweight markup language. -->
    <annotation encoding="application/x-tex">x^{2} + y</annotation>
  </semantics>
</math>

This will also allow us to start using LaTeX for MathML in the future, making it easier for content authors to write and maintain examples. To fully appreciate the difference, you can compare the full MathML source code of some bigger examples, such as Deriving the Quadratic Formula and Proving the Pythagorean theorem, with their LaTeX equivalents.
MathML documentation on MDN now features accessibility information for all elements. For example, using <math> element for representing math content allows screen readers to read the formula, which makes MathML better for such cases than using images or other formats.
Additionally, all MathML features now have live examples, so you can see how they're rendered in your browser. And just like with other live examples on MDN, you can always click "Play" in the top right corner to play around with the code in a new tab.
html,
body {
  height: 100%;
}

body {
  display: grid;
  place-items: center;
  font-size: 1.5rem;
}

<math display="block">
  <mrow>
    <mi>x</mi>
    <mo>=</mo>
    <mfrac>
      <mrow>
        <mrow>
          <mo>−</mo>
          <mi>b</mi>
        </mrow>
        <mo>±</mo>
        <msqrt>
          <mrow>
            <msup>
              <mi>b</mi>
              <mn>2</mn>
            </msup>
            <mo>−</mo>
            <mrow>
              <mn>4</mn>
              <mo>⁢</mo>
              <mi>a</mi>
              <mo>⁢</mo>
              <mi>c</mi>
            </mrow>
          </mrow>
        </msqrt>
      </mrow>
      <mrow>
        <mn>2</mn>
        <mo>⁢</mo>
        <mi>a</mi>
      </mrow>
    </mfrac>
  </mrow>
</math>


Not only is MathML documented on MDN, but it's also used to describe different parts of the web platform. For example, Set.difference() JavaScript method, CSS transformation functions, 3D collision detection in game development, WebXR Device API, and many more.
We made sure MathML is now rendered correctly throughout MDN: inside paragraphs and on the block level, on big and small screens, and in different browsers.Manifest (web app manifests)A web app manifest is a JSON text file that provides information about a web application.
The most common use for a manifest is to provide information that the browser needs to install a progressive web app (PWA) on a device, such as the app's name and icon.
json{
  "name": "HackerWeb",
  "short_name": "HackerWeb",
  "start_url": "/index.html",
  "display": "standalone",
  "background_color": "#ffffff",
  "description": "A readable Hacker News app",
  "icons": [
    {
      "src": "images/icons/homescreen192.png",
      "sizes": "192x192",
      "type": "image/png"
    }
  ]
}

For the manifest content updates, Dipika collaborated with Firefox engineer Jonathan Almeida to update browser compatibility data for manifest members in Firefox.
The manifest BCD additions now cover compat data for Firefox and Firefox for Android, ensuring accurate and up-to-date support information.
Readers on MDN, Can I use, and other sites, now have solid guidance on manifest support across browsers.
On the content side, several improvements landed across the section for prose, layout and templating fixes.
The page template is now improved for readability and consistency across the entire section.
For each member value (for example, "display": "standalone",), there is a proper prose description, with example scenarios where the value might be used.
Usage notes are collected into a dedicated "Description" section, and any caveats that the specification mentioned that were not in the MDN pages and now documented.
Some pages were missing "Syntax" sections completely, so now these gaps are filled so readers can better understand how to use the documented features and some possible member values:
json/* Boolean values */
"prefer_related_applications": true
"prefer_related_applications": false

This refresh made sure that the existing content was more comprehensive and readable but also included references to similar features, which allowed for more flexibility for developers. For example, using prefers-color-scheme in HTML to set different theme_color values for light and dark mode:
html<meta
  name="theme-color"
  content="#F4E6D8"
  media="(prefers-color-scheme: light)" />
<meta
  name="theme-color"
  content="#5D4037"
  media="(prefers-color-scheme: dark)" />
HTTP content updatesHTTP is a protocol that's foundational for data exchange on the web.
It allows communication between browsers and servers, but it can also be used for machine-to-machine communication, automating access to APIs, and more.
On MDN, the HTTP section has over 300 pages of reference material, and the majority of pages are about HTTP headers and response status codes.
Response status codes let the client know the outcome of a HTTP request (such as 200, 404), and give some additional context in certain cases.
There are 61 status codes documented on MDN and they include examples for common responses and clarifications for rarer types that web developers may not encounter often.
You can even make sure you're familiar with the 418 (I'm a teapot) status just in case.
There are 148 HTTP headers documented on MDN.
HTTP headers are the parts of the HTTP message that carry metadata, information about the client or server, instructions for the recipient, and so on.
Some headers have several sub-pages that describe mechanisms you can control via headers, such as Content Security Policy (CSP) directives that instruct a browser to restrict what the code comprising a site can run and Permissions Policy directives for requesting permission to use browser features such as location or microphone access.
The HTTP guides have overviews of how the protocol works, describing the evolution of the protocol from HTTP/0.9 right through to current versions.
We document different ways to control HTTP interactions such as caching and conditional requests, and we have guides about how to use and understand the protocol for beginners, right up to more involved topics.
A lot of the refresh of these guides meant making less specific references to HTTP/1.1 when talking about message formats seeing as HTTP/2 and HTTP/3 are increasingly common.
httpHEAD /en-US/docs/Web/HTTP HTTP/2
Host: developer.mozilla.org
User-Agent: curl/8.7.1
Accept: */*

* Request completely sent off
HTTP/2 200

To summarize, the changes we made across the entire HTTP section included adding examples where they were missing or too short to be useful, removing outdated or obsolete information, and making the formatting and presentation consistent over all pages.
HTTP highlights on MDN
Part of the refresh involved updating and adding sequence diagrams that explain client-server exchanges.
We've been finding mermaid syntax useful for a lot of these types of diagrams as it makes it easier to store sources for images that we may need to update later.
These images are stored in the shared-assets repository, which allows us to reuse images instead of duplicate them in the source, and these are easier to write, read, maintain, and they look nice, too:

One interesting pick from the HTTP section is the Server-Timing response header that you can use to surface server metrics to a client:
httpHTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Content-Length: 123
Date: Fri, 03 Jan 2025 10:41:21 GMT
Server-Timing: custom-metric;dur=123.45;desc="My custom metric"

--- response body ---

Depending on the type of request, you can decide if you want to send server timings to the client, and these are visible in the Network request details panel in most browser's developer tools.
For example, the BBC iPlayer is using the Server-Timing header to send performance metrics about the service, visible in the Network > Timings panel below.
If you find this interesting, be sure to check the Performance API and the Web performance documentation.

For the HTTP section, most of the BCD updates involved improving the accuracy of existing entries and adding missing compat data for headers.
Additions included the Service-Worker request header for logging service worker script requests and the Sec-Websocket-* headers used in the WebSocket handshake.
Most of the HTTP updates are for older features, but the accuracy of the support information is crucial for developers making decisions about what to build.
One example is the Trailer compatibility details which now reflects browser implementations.
It's important to avoid misleading information in compatibility tables because they may encourage people to develop functionality in their applications for features that have poor browser support in reality.Other 2024 content highlights on MDNHere's a few interesting picks of documentation that landed in 2024:

New! CSS anchor positioning documentation
New! Using the View Transition API guide

Aside from reference docs, we've written about these topics on the MDN blog:

Locale-sensitive text segmentation in JavaScript with Intl.Segmenter
Exclusive accordions using the HTML <details> element
New JavaScript Set methods
Using the Page Visibility API
Interop 2023: MDN updates
Creating effective technical documentation

We also blogged about these changes and launches:

A new learning experience on MDN merging the MDN Curriculum into Learn Web Development.
Introducing the MDN HTTP Observatory for testing server HTTP header configuration.
And, of course, we have a new Community page which we are delighted to share!
Firefox release notes for developersFirefox release notes describe what's changed for everyday browser users.
The MDN team document each Firefox release with release notes specifically for developers.
That means in 2024, Firefox versions 122 up to 133 have pages describing the changes in each Firefox release that developers can target.
You can find everything in the Firefox release notes for developers pages.
Something you may not be aware of is that we also document Experimental features in Firefox.
This page describes features implemented in Firefox that are only available behind a preference (though configuration).
You can test out upcoming features before they are released, which is ideal if you're planning to use an experimental technology or if you're curious and would like to provide feedback on Bugzilla.Kicking off 2025The content projects that the team worked on were a superb learning experience, and we hope our readers benefit greatly from it.
If you want to make our docs better, let us know if there are other sections that need attention, and even lend your expertise.
If you want to learn about a topic, why not try to improve the documentation!
By contributing to MDN, you can improve your skills in a technology category, and millions of readers will benefit from it.
We're happy to share that we saw the following contributions in mdn/content GitHub repository in 2024:

915 different authors contributed.
~4300 pull requests opened.
~1500 issues opened.

We want to send out a big thanks to everyone who contributed in 2024 and we hope to see you continue in 2025.
One of the first larger changes we're excited to see is that JavaScript Temporal is coming with support scheduled to land in Firefox 135.
There is a huge pull request for Temporal authored by Josh-Cena, which means you can expect to be able to read Temporal documentation on MDN very soon.
We hope you enjoyed this post!
Feel free to get in touch with us and let us know what you think.Previous Post A new learning experience on MDNNext Post Fix your website's Largest Contentful Paint by optimizing image loading\n\nMDN 2024 content projectsVadim MakeevJanuary 8, 20259 minute readMDN Web Docs provides accurate and accessible resources for people getting started building for the web right through to professional developers.
Our commitment includes maintenance of long-existing content and documenting features that are brand new to the web platform.
In 2024, the MDN content team chose some content areas to audit and update so they stay useful and relevant in an evolving web platform.
We looked at topics that were popular but contained some outdated or incomplete material, and invested time in improvements, additions, and removing obsolete content.
This post recaps what we achieved in our content projects in 2024, highlights some of our top picks and recommended reading, and looks forward to what's next on MDN for 2025.2024 MDN content areasFor 2024, we chose three technology categories that are popular, but had reader feedback that indicated they needed a refresh.
We focused on HTTP, MathML, and web Manifests.
From July to December 2024, the team worked through these areas to bring the quality up in a number of ways.
Let's have a look at what changed in each section below.MathMLMathML is an XML-based language for describing mathematical notation on the web. Similar to SVG, MathML can also be included in the HTML and rendered by the browser, no plugins or libraries are required.

  
    ∑
    
      n
      =
      1
    
    
      +
      ∞
    
  

html<math display="block">
  <munderover>
    <mo>∑</mo>
    <mrow>
      <mi>n</mi>
      <mo>=</mo>
      <mn>1</mn>
    </mrow>
    <mrow>
      <mo>+</mo>
      <mn>∞</mn>
    </mrow>
  </munderover>
</math>

Unlike the MathML Core specification, which often groups elements, MDN now features each MathML element on its page, with examples, usage notes, and BCD (browser-compat-data) now also updated. For example, you can read about <semantics>, <annotation> and <annotation-xml> elements and how they help to annotate MathML expressions.
Just like we're writing this blog post using Markdown instead of HTML, MathML is often generated by math processors using lightweight markup languages like LaTeX. To help content authors, all MathML examples now have annotations. For example, x2+yx^{2} + y can be written as x^{2} + y in LaTeX:
html<math>
  <semantics>
    <mrow>
      <msup>
        <mi>x</mi>
        <mn>2</mn>
      </msup>
      <mo>+</mo>
      <mi>y</mi>
    </mrow>
    <!-- Annotated with LaTeX, a lightweight markup language. -->
    <annotation encoding="application/x-tex">x^{2} + y</annotation>
  </semantics>
</math>

This will also allow us to start using LaTeX for MathML in the future, making it easier for content authors to write and maintain examples. To fully appreciate the difference, you can compare the full MathML source code of some bigger examples, such as Deriving the Quadratic Formula and Proving the Pythagorean theorem, with their LaTeX equivalents.
MathML documentation on MDN now features accessibility information for all elements. For example, using <math> element for representing math content allows screen readers to read the formula, which makes MathML better for such cases than using images or other formats.
Additionally, all MathML features now have live examples, so you can see how they're rendered in your browser. And just like with other live examples on MDN, you can always click "Play" in the top right corner to play around with the code in a new tab.
html,
body {
  height: 100%;
}

body {
  display: grid;
  place-items: center;
  font-size: 1.5rem;
}

<math display="block">
  <mrow>
    <mi>x</mi>
    <mo>=</mo>
    <mfrac>
      <mrow>
        <mrow>
          <mo>−</mo>
          <mi>b</mi>
        </mrow>
        <mo>±</mo>
        <msqrt>
          <mrow>
            <msup>
              <mi>b</mi>
              <mn>2</mn>
            </msup>
            <mo>−</mo>
            <mrow>
              <mn>4</mn>
              <mo>⁢</mo>
              <mi>a</mi>
              <mo>⁢</mo>
              <mi>c</mi>
            </mrow>
          </mrow>
        </msqrt>
      </mrow>
      <mrow>
        <mn>2</mn>
        <mo>⁢</mo>
        <mi>a</mi>
      </mrow>
    </mfrac>
  </mrow>
</math>


Not only is MathML documented on MDN, but it's also used to describe different parts of the web platform. For example, Set.difference() JavaScript method, CSS transformation functions, 3D collision detection in game development, WebXR Device API, and many more.
We made sure MathML is now rendered correctly throughout MDN: inside paragraphs and on the block level, on big and small screens, and in different browsers.Manifest (web app manifests)A web app manifest is a JSON text file that provides information about a web application.
The most common use for a manifest is to provide information that the browser needs to install a progressive web app (PWA) on a device, such as the app's name and icon.
json{
  "name": "HackerWeb",
  "short_name": "HackerWeb",
  "start_url": "/index.html",
  "display": "standalone",
  "background_color": "#ffffff",
  "description": "A readable Hacker News app",
  "icons": [
    {
      "src": "images/icons/homescreen192.png",
      "sizes": "192x192",
      "type": "image/png"
    }
  ]
}

For the manifest content updates, Dipika collaborated with Firefox engineer Jonathan Almeida to update browser compatibility data for manifest members in Firefox.
The manifest BCD additions now cover compat data for Firefox and Firefox for Android, ensuring accurate and up-to-date support information.
Readers on MDN, Can I use, and other sites, now have solid guidance on manifest support across browsers.
On the content side, several improvements landed across the section for prose, layout and templating fixes.
The page template is now improved for readability and consistency across the entire section.
For each member value (for example, "display": "standalone",), there is a proper prose description, with example scenarios where the value might be used.
Usage notes are collected into a dedicated "Description" section, and any caveats that the specification mentioned that were not in the MDN pages and now documented.
Some pages were missing "Syntax" sections completely, so now these gaps are filled so readers can better understand how to use the documented features and some possible member values:
json/* Boolean values */
"prefer_related_applications": true
"prefer_related_applications": false

This refresh made sure that the existing content was more comprehensive and readable but also included references to similar features, which allowed for more flexibility for developers. For example, using prefers-color-scheme in HTML to set different theme_color values for light and dark mode:
html<meta
  name="theme-color"
  content="#F4E6D8"
  media="(prefers-color-scheme: light)" />
<meta
  name="theme-color"
  content="#5D4037"
  media="(prefers-color-scheme: dark)" />
HTTP content updatesHTTP is a protocol that's foundational for data exchange on the web.
It allows communication between browsers and servers, but it can also be used for machine-to-machine communication, automating access to APIs, and more.
On MDN, the HTTP section has over 300 pages of reference material, and the majority of pages are about HTTP headers and response status codes.
Response status codes let the client know the outcome of a HTTP request (such as 200, 404), and give some additional context in certain cases.
There are 61 status codes documented on MDN and they include examples for common responses and clarifications for rarer types that web developers may not encounter often.
You can even make sure you're familiar with the 418 (I'm a teapot) status just in case.
There are 148 HTTP headers documented on MDN.
HTTP headers are the parts of the HTTP message that carry metadata, information about the client or server, instructions for the recipient, and so on.
Some headers have several sub-pages that describe mechanisms you can control via headers, such as Content Security Policy (CSP) directives that instruct a browser to restrict what the code comprising a site can run and Permissions Policy directives for requesting permission to use browser features such as location or microphone access.
The HTTP guides have overviews of how the protocol works, describing the evolution of the protocol from HTTP/0.9 right through to current versions.
We document different ways to control HTTP interactions such as caching and conditional requests, and we have guides about how to use and understand the protocol for beginners, right up to more involved topics.
A lot of the refresh of these guides meant making less specific references to HTTP/1.1 when talking about message formats seeing as HTTP/2 and HTTP/3 are increasingly common.
httpHEAD /en-US/docs/Web/HTTP HTTP/2
Host: developer.mozilla.org
User-Agent: curl/8.7.1
Accept: */*

* Request completely sent off
HTTP/2 200

To summarize, the changes we made across the entire HTTP section included adding examples where they were missing or too short to be useful, removing outdated or obsolete information, and making the formatting and presentation consistent over all pages.
HTTP highlights on MDN
Part of the refresh involved updating and adding sequence diagrams that explain client-server exchanges.
We've been finding mermaid syntax useful for a lot of these types of diagrams as it makes it easier to store sources for images that we may need to update later.
These images are stored in the shared-assets repository, which allows us to reuse images instead of duplicate them in the source, and these are easier to write, read, maintain, and they look nice, too:

One interesting pick from the HTTP section is the Server-Timing response header that you can use to surface server metrics to a client:
httpHTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Content-Length: 123
Date: Fri, 03 Jan 2025 10:41:21 GMT
Server-Timing: custom-metric;dur=123.45;desc="My custom metric"

--- response body ---

Depending on the type of request, you can decide if you want to send server timings to the client, and these are visible in the Network request details panel in most browser's developer tools.
For example, the BBC iPlayer is using the Server-Timing header to send performance metrics about the service, visible in the Network > Timings panel below.
If you find this interesting, be sure to check the Performance API and the Web performance documentation.

For the HTTP section, most of the BCD updates involved improving the accuracy of existing entries and adding missing compat data for headers.
Additions included the Service-Worker request header for logging service worker script requests and the Sec-Websocket-* headers used in the WebSocket handshake.
Most of the HTTP updates are for older features, but the accuracy of the support information is crucial for developers making decisions about what to build.
One example is the Trailer compatibility details which now reflects browser implementations.
It's important to avoid misleading information in compatibility tables because they may encourage people to develop functionality in their applications for features that have poor browser support in reality.Other 2024 content highlights on MDNHere's a few interesting picks of documentation that landed in 2024:

New! CSS anchor positioning documentation
New! Using the View Transition API guide

Aside from reference docs, we've written about these topics on the MDN blog:

Locale-sensitive text segmentation in JavaScript with Intl.Segmenter
Exclusive accordions using the HTML <details> element
New JavaScript Set methods
Using the Page Visibility API
Interop 2023: MDN updates
Creating effective technical documentation

We also blogged about these changes and launches:

A new learning experience on MDN merging the MDN Curriculum into Learn Web Development.
Introducing the MDN HTTP Observatory for testing server HTTP header configuration.
And, of course, we have a new Community page which we are delighted to share!
Firefox release notes for developersFirefox release notes describe what's changed for everyday browser users.
The MDN team document each Firefox release with release notes specifically for developers.
That means in 2024, Firefox versions 122 up to 133 have pages describing the changes in each Firefox release that developers can target.
You can find everything in the Firefox release notes for developers pages.
Something you may not be aware of is that we also document Experimental features in Firefox.
This page describes features implemented in Firefox that are only available behind a preference (though configuration).
You can test out upcoming features before they are released, which is ideal if you're planning to use an experimental technology or if you're curious and would like to provide feedback on Bugzilla.Kicking off 2025The content projects that the team worked on were a superb learning experience, and we hope our readers benefit greatly from it.
If you want to make our docs better, let us know if there are other sections that need attention, and even lend your expertise.
If you want to learn about a topic, why not try to improve the documentation!
By contributing to MDN, you can improve your skills in a technology category, and millions of readers will benefit from it.
We're happy to share that we saw the following contributions in mdn/content GitHub repository in 2024:

915 different authors contributed.
~4300 pull requests opened.
~1500 issues opened.

We want to send out a big thanks to everyone who contributed in 2024 and we hope to see you continue in 2025.
One of the first larger changes we're excited to see is that JavaScript Temporal is coming with support scheduled to land in Firefox 135.
There is a huge pull request for Temporal authored by Josh-Cena, which means you can expect to be able to read Temporal documentation on MDN very soon.
We hope you enjoyed this post!
Feel free to get in touch with us and let us know what you think.Previous Post A new learning experience on MDNNext Post Fix your website's Largest Contentful Paint by optimizing image loading\n\n\n\nA new learning experience on MDNRuth JohnDecember 20, 20244 minute readA major update to the MDN Learn Web Development section started in November 2024 and was finally published in December 2024.
To summarize, the MDN Curriculum has been merged into Learn Web Development.
This post looks at the background leading up to this decision being made, what the changes mean specifically, and what updates you can expect to see in the future.Overview of learning material on MDNWe originally launched the MDN Learn Web Development section in 2016 with the aim of making MDN more accessible to non-experts and helping to take new web developers from "beginner to comfortable".
The content was pretty successful — by 2019 it was being used by over a million people per month to learn web development topics.
However, it was noted that the structure was sub-par:

The content had become bloated with topics that weren't really suitable for beginner web developers — either they were too advanced, or they were out of scope altogether.
Beginners tend to want a robust pathway they can follow to get the knowledge they need, rather than being expected to figure out what to learn and when.
Learners these days tend to want interactive multimedia content, not just text.
Developing the MDN curriculumTo solve the second issue highlighted above, we created a resource to help guide people towards learning a better skillset, making them more employable, and enabling them to build a better, more accessible, more responsible web of tomorrow.
As part of this project, we did substantial research to find out exactly what skills are seen as essential in new hires, and what the most common knowledge gaps are.
The resulting curriculum was intended to be useful as a study guide for self-learners, and a syllabus for educators to base courses on.
We also used it as a place to experiment with including interactive multimedia content via our learning partner, Scrimba.
We launched the MDN Curriculum in early 2024.Why the update?The curriculum was well-received by educators, but we quickly received feedback that users found it confusing having two learning resources on MDN, with the curriculum/learning pathway in one place and the learning content in another place.
In addition, the pathway was just a curriculum; learners still had to figure out what content to look at to achieve the learning objectives. And it did nothing to solve the first issue listed above — the content was still bloated.The new state of learning material on MDN
To provide a less confusing, more streamlined learning experience, we decided to merge the curriculum pathway into the MDN Learn Web Development section, restructuring it in the process. The results can be seen at the following new URL — developer.mozilla.org/docs/Learn_web_development.

The most significant changes are as follows:

The articles now follow the same structure as the curriculum, with useful background and environment setup information in Getting started, the web fundamentals everyone should know in Core, and optional extra topics in Extensions. There is a clear pathway to follow between each article in the first two major sections, so readers know what to learn next at each stage.
In some cases, content was deemed not suitable for a beginner audience and has been repurposed as extensions/additional articles or migrated to other parts of MDN.
The specific learning outcomes detailed in the curriculum have been added to the top of the Getting started, Core, and some of the Extension articles, to match the learning outcomes detailed in the Curriculum.
Other features from the Curriculum have been migrated across to the Learn Web Development section, such as the About page and Resources for educators.

Initially, the Curriculum section will stay, however it will be merged into the Learn area over the next few iterations of this work and will be removed when it is felt the time is right.
We will keep a downloadable version as a resource for educators.What's next for learners on MDNMoving forward, we will continue to update the content and design to make Learn Web Development even more useful to learners and educators.
We are intending to give the article content a significant overhaul as we move into 2025. A lot of the content is timeless and does a good job of teaching the fundamentals, but the pacing is uneven, some of the articles are pretty long (which can be intimidating for beginners), and some of the challenges and examples have been around for a long time. Inspired by resources such as the content produced by our learning partner, Scrimba, we intend to shake our content up a bit to make it more fun, bite-size, and digestible.
We are also looking at improving the design of our learning pages, to echo the bright bold design we used on the curriculum and improve the experience further.
You can expect to see regular iterative improvements going forward, so watch this space.SummaryWe hope you find the new Learn Web Development content structure useful — have a look around and let us know what you think.
If you still have unanswered questions or wish to report issues, please get in touch via the usual communication channels.
If your issue concerns a specific piece of content, you might want to file a GitHub issue.Previous Post Countdown to the holidays with daily coding challengesNext Post MDN 2024 content projectsPrevious Post Countdown to the holidays with daily coding challengesNext Post MDN 2024 content projects\n\nIn this articleOverview of learning material on MDNDeveloping the MDN curriculumWhy the update?The new state of learning material on MDNWhat's next for learners on MDNSummaryA new learning experience on MDNRuth JohnDecember 20, 20244 minute readA major update to the MDN Learn Web Development section started in November 2024 and was finally published in December 2024.
To summarize, the MDN Curriculum has been merged into Learn Web Development.
This post looks at the background leading up to this decision being made, what the changes mean specifically, and what updates you can expect to see in the future.Overview of learning material on MDNWe originally launched the MDN Learn Web Development section in 2016 with the aim of making MDN more accessible to non-experts and helping to take new web developers from "beginner to comfortable".
The content was pretty successful — by 2019 it was being used by over a million people per month to learn web development topics.
However, it was noted that the structure was sub-par:

The content had become bloated with topics that weren't really suitable for beginner web developers — either they were too advanced, or they were out of scope altogether.
Beginners tend to want a robust pathway they can follow to get the knowledge they need, rather than being expected to figure out what to learn and when.
Learners these days tend to want interactive multimedia content, not just text.
Developing the MDN curriculumTo solve the second issue highlighted above, we created a resource to help guide people towards learning a better skillset, making them more employable, and enabling them to build a better, more accessible, more responsible web of tomorrow.
As part of this project, we did substantial research to find out exactly what skills are seen as essential in new hires, and what the most common knowledge gaps are.
The resulting curriculum was intended to be useful as a study guide for self-learners, and a syllabus for educators to base courses on.
We also used it as a place to experiment with including interactive multimedia content via our learning partner, Scrimba.
We launched the MDN Curriculum in early 2024.Why the update?The curriculum was well-received by educators, but we quickly received feedback that users found it confusing having two learning resources on MDN, with the curriculum/learning pathway in one place and the learning content in another place.
In addition, the pathway was just a curriculum; learners still had to figure out what content to look at to achieve the learning objectives. And it did nothing to solve the first issue listed above — the content was still bloated.The new state of learning material on MDN
To provide a less confusing, more streamlined learning experience, we decided to merge the curriculum pathway into the MDN Learn Web Development section, restructuring it in the process. The results can be seen at the following new URL — developer.mozilla.org/docs/Learn_web_development.

The most significant changes are as follows:

The articles now follow the same structure as the curriculum, with useful background and environment setup information in Getting started, the web fundamentals everyone should know in Core, and optional extra topics in Extensions. There is a clear pathway to follow between each article in the first two major sections, so readers know what to learn next at each stage.
In some cases, content was deemed not suitable for a beginner audience and has been repurposed as extensions/additional articles or migrated to other parts of MDN.
The specific learning outcomes detailed in the curriculum have been added to the top of the Getting started, Core, and some of the Extension articles, to match the learning outcomes detailed in the Curriculum.
Other features from the Curriculum have been migrated across to the Learn Web Development section, such as the About page and Resources for educators.

Initially, the Curriculum section will stay, however it will be merged into the Learn area over the next few iterations of this work and will be removed when it is felt the time is right.
We will keep a downloadable version as a resource for educators.What's next for learners on MDNMoving forward, we will continue to update the content and design to make Learn Web Development even more useful to learners and educators.
We are intending to give the article content a significant overhaul as we move into 2025. A lot of the content is timeless and does a good job of teaching the fundamentals, but the pacing is uneven, some of the articles are pretty long (which can be intimidating for beginners), and some of the challenges and examples have been around for a long time. Inspired by resources such as the content produced by our learning partner, Scrimba, we intend to shake our content up a bit to make it more fun, bite-size, and digestible.
We are also looking at improving the design of our learning pages, to echo the bright bold design we used on the curriculum and improve the experience further.
You can expect to see regular iterative improvements going forward, so watch this space.SummaryWe hope you find the new Learn Web Development content structure useful — have a look around and let us know what you think.
If you still have unanswered questions or wish to report issues, please get in touch via the usual communication channels.
If your issue concerns a specific piece of content, you might want to file a GitHub issue.Previous Post Countdown to the holidays with daily coding challengesNext Post MDN 2024 content projects\n\nA new learning experience on MDNRuth JohnDecember 20, 20244 minute readA major update to the MDN Learn Web Development section started in November 2024 and was finally published in December 2024.
To summarize, the MDN Curriculum has been merged into Learn Web Development.
This post looks at the background leading up to this decision being made, what the changes mean specifically, and what updates you can expect to see in the future.Overview of learning material on MDNWe originally launched the MDN Learn Web Development section in 2016 with the aim of making MDN more accessible to non-experts and helping to take new web developers from "beginner to comfortable".
The content was pretty successful — by 2019 it was being used by over a million people per month to learn web development topics.
However, it was noted that the structure was sub-par:

The content had become bloated with topics that weren't really suitable for beginner web developers — either they were too advanced, or they were out of scope altogether.
Beginners tend to want a robust pathway they can follow to get the knowledge they need, rather than being expected to figure out what to learn and when.
Learners these days tend to want interactive multimedia content, not just text.
Developing the MDN curriculumTo solve the second issue highlighted above, we created a resource to help guide people towards learning a better skillset, making them more employable, and enabling them to build a better, more accessible, more responsible web of tomorrow.
As part of this project, we did substantial research to find out exactly what skills are seen as essential in new hires, and what the most common knowledge gaps are.
The resulting curriculum was intended to be useful as a study guide for self-learners, and a syllabus for educators to base courses on.
We also used it as a place to experiment with including interactive multimedia content via our learning partner, Scrimba.
We launched the MDN Curriculum in early 2024.Why the update?The curriculum was well-received by educators, but we quickly received feedback that users found it confusing having two learning resources on MDN, with the curriculum/learning pathway in one place and the learning content in another place.
In addition, the pathway was just a curriculum; learners still had to figure out what content to look at to achieve the learning objectives. And it did nothing to solve the first issue listed above — the content was still bloated.The new state of learning material on MDN
To provide a less confusing, more streamlined learning experience, we decided to merge the curriculum pathway into the MDN Learn Web Development section, restructuring it in the process. The results can be seen at the following new URL — developer.mozilla.org/docs/Learn_web_development.

The most significant changes are as follows:

The articles now follow the same structure as the curriculum, with useful background and environment setup information in Getting started, the web fundamentals everyone should know in Core, and optional extra topics in Extensions. There is a clear pathway to follow between each article in the first two major sections, so readers know what to learn next at each stage.
In some cases, content was deemed not suitable for a beginner audience and has been repurposed as extensions/additional articles or migrated to other parts of MDN.
The specific learning outcomes detailed in the curriculum have been added to the top of the Getting started, Core, and some of the Extension articles, to match the learning outcomes detailed in the Curriculum.
Other features from the Curriculum have been migrated across to the Learn Web Development section, such as the About page and Resources for educators.

Initially, the Curriculum section will stay, however it will be merged into the Learn area over the next few iterations of this work and will be removed when it is felt the time is right.
We will keep a downloadable version as a resource for educators.What's next for learners on MDNMoving forward, we will continue to update the content and design to make Learn Web Development even more useful to learners and educators.
We are intending to give the article content a significant overhaul as we move into 2025. A lot of the content is timeless and does a good job of teaching the fundamentals, but the pacing is uneven, some of the articles are pretty long (which can be intimidating for beginners), and some of the challenges and examples have been around for a long time. Inspired by resources such as the content produced by our learning partner, Scrimba, we intend to shake our content up a bit to make it more fun, bite-size, and digestible.
We are also looking at improving the design of our learning pages, to echo the bright bold design we used on the curriculum and improve the experience further.
You can expect to see regular iterative improvements going forward, so watch this space.SummaryWe hope you find the new Learn Web Development content structure useful — have a look around and let us know what you think.
If you still have unanswered questions or wish to report issues, please get in touch via the usual communication channels.
If your issue concerns a specific piece of content, you might want to file a GitHub issue.Previous Post Countdown to the holidays with daily coding challengesNext Post MDN 2024 content projects\n\n\n\nIntroducing the new MDN Community pagePranshu KhannaOctober 15, 20245 minute readMDN has always been a place for people to connect, collaborate, and grow. As we look to the future, we want to celebrate our achievements and bring people together on the exciting path ahead. Today, I'm thrilled to introduce our brand-new community page.
Launching during Hacktoberfest, a month-long celebration of open source, is excellent timing for MDN, the go-to place for open-source web documentation. We're thrilled to welcome even more contributors and acknowledge the achievements of the MDN community.What's new for the MDN Community?We aim to make your community experience welcoming and engaging. You'll quickly find the resources you need, and we'll showcase more of the community's contributions. I'm excited to guide you through the new updates that make this space more interactive and valuable for everyone!A place for collaboration and growthOur new Community page highlights contributions from developers, writers, and learners who work together to improve MDN. Many community members contribute to MDN to grow their technical, writing, and language skills while building connections with collaborators. We invite you to connect with other members, share your knowledge, learn from others, and grow professionally alongside peers as passionate about the web as you are.
Recognizing our contributorsMeet Our Contributors highlights people who have contributed to the platform. We celebrate the diverse skills and backgrounds that help MDN's mission to provide a blueprint for a better internet and empower a new generation of developers and content creators to build it.
The Contributor Spotlight program is a series of personal stories about what motivates people to work on MDN. People like Joshua appreciate MDN's infrastructure, which is unique in how it helps everyone work efficiently, or Hochan, who enjoys the community's diversity and how it broadens his perspective. We're proud to amplify and share the voices of our community and the reasons why they are driven to improve MDN.Get recognition for your contributionsWe want this to be a community where everyone's contributions are visible and valued. If you're passionate about making the web better, there are so many ways to get involved. You can squash bugs, improve content, help with localization, or even answer questions on Discord. Every contribution, no matter the size, helps shape the future of MDN, and we want to ensure those efforts don't go unnoticed.
By contributing, your name could also appear on this page as one of the dedicated individuals shaping the web. Whether through our GitHub repository, working on translation efforts, or simply helping out other developers, there are plenty of opportunities to be a part of this community and leave your mark. The new page makes it easier than ever to get started, with guides and resources available to help you find the best way to contribute.
Contributing to open sourceIf you're new to contributing to MDN, we've made it easier than ever to get started. We've added a video that offers simple, clear instructions on how you can begin making an impact. We collaborate on GitHub, and you'll find step-by-step guidance to help you with writing, fixing bugs, or even improving documentation. Plus, you can check out our helpful video on how to get started with contributing to MDN Web Docs, so you're fully prepared to make your first contribution.
MDN is driven by a global community dedicated to documenting the web for the future. Whatever your skill set, there's a place for you to make a difference. You can now easily get involved, and start playing your part in building a better, more inclusive web.
Want to start contributing to MDN?We understand if you're new to MDN or open-source projects, and would like to start right away. That is exactly why we have our first issues front and center, it is the perfect place to start. We've highlighted beginner-friendly issues to help you improve MDN. This section lists specific tasks that are great for first-time contributors, whether it's fixing a bug, addressing an issue with documentation, or enhancing translated content. You'll find clear guidance on how to contribute, along with links to relevant repositories, so you can jump right in and start making an impact.
Join the conversationMDN is an open-source project that you can help us shape in many ways. We'd love it if you dropped by our Discord so you can get to know other community members, ask questions, and get help from fellow developers. It's a space for lively discussion where you can share ideas and seek advice. Also, we invite you to Join our Community Call, where you'll receive updates from the MDN team, hear about new initiatives, and share your questions and thoughts on how we can continue improving the platform and content. Whether through Discord or our calls, we want you to have the space to connect and make an impact in this community.
Licensing and reuseMDN Resources are openly accessible and free to reuse under a variety of open-source licenses. We encourage developers, educators, and content creators to use and share MDN's materials, as long as proper attribution is given. Our goal is to ensure that the knowledge we build together is freely available to anyone who needs it, while still protecting the contributions of our community members.
We're incredibly excited about the future of our community and what we can build together. We want our platform to be even more collaborative, accessible, and vibrant, where every contribution supports and shapes the web, and there's a place for everyone to make an impact.
We'd love to hear your feedback on the new community page or any ideas you have for improving MDN. Let us know on Discord or start a discussion on GitHub. I look forward to seeing you there!Previous Post Fixing your website's JavaScript performanceNext Post How to land your first developer jobPrevious Post Fixing your website's JavaScript performanceNext Post How to land your first developer job\n\nIn this articleWhat's new for the MDN Community?Want to start contributing to MDN?Join the conversationLicensing and reuseIntroducing the new MDN Community pagePranshu KhannaOctober 15, 20245 minute readMDN has always been a place for people to connect, collaborate, and grow. As we look to the future, we want to celebrate our achievements and bring people together on the exciting path ahead. Today, I'm thrilled to introduce our brand-new community page.
Launching during Hacktoberfest, a month-long celebration of open source, is excellent timing for MDN, the go-to place for open-source web documentation. We're thrilled to welcome even more contributors and acknowledge the achievements of the MDN community.What's new for the MDN Community?We aim to make your community experience welcoming and engaging. You'll quickly find the resources you need, and we'll showcase more of the community's contributions. I'm excited to guide you through the new updates that make this space more interactive and valuable for everyone!A place for collaboration and growthOur new Community page highlights contributions from developers, writers, and learners who work together to improve MDN. Many community members contribute to MDN to grow their technical, writing, and language skills while building connections with collaborators. We invite you to connect with other members, share your knowledge, learn from others, and grow professionally alongside peers as passionate about the web as you are.
Recognizing our contributorsMeet Our Contributors highlights people who have contributed to the platform. We celebrate the diverse skills and backgrounds that help MDN's mission to provide a blueprint for a better internet and empower a new generation of developers and content creators to build it.
The Contributor Spotlight program is a series of personal stories about what motivates people to work on MDN. People like Joshua appreciate MDN's infrastructure, which is unique in how it helps everyone work efficiently, or Hochan, who enjoys the community's diversity and how it broadens his perspective. We're proud to amplify and share the voices of our community and the reasons why they are driven to improve MDN.Get recognition for your contributionsWe want this to be a community where everyone's contributions are visible and valued. If you're passionate about making the web better, there are so many ways to get involved. You can squash bugs, improve content, help with localization, or even answer questions on Discord. Every contribution, no matter the size, helps shape the future of MDN, and we want to ensure those efforts don't go unnoticed.
By contributing, your name could also appear on this page as one of the dedicated individuals shaping the web. Whether through our GitHub repository, working on translation efforts, or simply helping out other developers, there are plenty of opportunities to be a part of this community and leave your mark. The new page makes it easier than ever to get started, with guides and resources available to help you find the best way to contribute.
Contributing to open sourceIf you're new to contributing to MDN, we've made it easier than ever to get started. We've added a video that offers simple, clear instructions on how you can begin making an impact. We collaborate on GitHub, and you'll find step-by-step guidance to help you with writing, fixing bugs, or even improving documentation. Plus, you can check out our helpful video on how to get started with contributing to MDN Web Docs, so you're fully prepared to make your first contribution.
MDN is driven by a global community dedicated to documenting the web for the future. Whatever your skill set, there's a place for you to make a difference. You can now easily get involved, and start playing your part in building a better, more inclusive web.
Want to start contributing to MDN?We understand if you're new to MDN or open-source projects, and would like to start right away. That is exactly why we have our first issues front and center, it is the perfect place to start. We've highlighted beginner-friendly issues to help you improve MDN. This section lists specific tasks that are great for first-time contributors, whether it's fixing a bug, addressing an issue with documentation, or enhancing translated content. You'll find clear guidance on how to contribute, along with links to relevant repositories, so you can jump right in and start making an impact.
Join the conversationMDN is an open-source project that you can help us shape in many ways. We'd love it if you dropped by our Discord so you can get to know other community members, ask questions, and get help from fellow developers. It's a space for lively discussion where you can share ideas and seek advice. Also, we invite you to Join our Community Call, where you'll receive updates from the MDN team, hear about new initiatives, and share your questions and thoughts on how we can continue improving the platform and content. Whether through Discord or our calls, we want you to have the space to connect and make an impact in this community.
Licensing and reuseMDN Resources are openly accessible and free to reuse under a variety of open-source licenses. We encourage developers, educators, and content creators to use and share MDN's materials, as long as proper attribution is given. Our goal is to ensure that the knowledge we build together is freely available to anyone who needs it, while still protecting the contributions of our community members.
We're incredibly excited about the future of our community and what we can build together. We want our platform to be even more collaborative, accessible, and vibrant, where every contribution supports and shapes the web, and there's a place for everyone to make an impact.
We'd love to hear your feedback on the new community page or any ideas you have for improving MDN. Let us know on Discord or start a discussion on GitHub. I look forward to seeing you there!Previous Post Fixing your website's JavaScript performanceNext Post How to land your first developer job\n\nIntroducing the new MDN Community pagePranshu KhannaOctober 15, 20245 minute readMDN has always been a place for people to connect, collaborate, and grow. As we look to the future, we want to celebrate our achievements and bring people together on the exciting path ahead. Today, I'm thrilled to introduce our brand-new community page.
Launching during Hacktoberfest, a month-long celebration of open source, is excellent timing for MDN, the go-to place for open-source web documentation. We're thrilled to welcome even more contributors and acknowledge the achievements of the MDN community.What's new for the MDN Community?We aim to make your community experience welcoming and engaging. You'll quickly find the resources you need, and we'll showcase more of the community's contributions. I'm excited to guide you through the new updates that make this space more interactive and valuable for everyone!A place for collaboration and growthOur new Community page highlights contributions from developers, writers, and learners who work together to improve MDN. Many community members contribute to MDN to grow their technical, writing, and language skills while building connections with collaborators. We invite you to connect with other members, share your knowledge, learn from others, and grow professionally alongside peers as passionate about the web as you are.
Recognizing our contributorsMeet Our Contributors highlights people who have contributed to the platform. We celebrate the diverse skills and backgrounds that help MDN's mission to provide a blueprint for a better internet and empower a new generation of developers and content creators to build it.
The Contributor Spotlight program is a series of personal stories about what motivates people to work on MDN. People like Joshua appreciate MDN's infrastructure, which is unique in how it helps everyone work efficiently, or Hochan, who enjoys the community's diversity and how it broadens his perspective. We're proud to amplify and share the voices of our community and the reasons why they are driven to improve MDN.Get recognition for your contributionsWe want this to be a community where everyone's contributions are visible and valued. If you're passionate about making the web better, there are so many ways to get involved. You can squash bugs, improve content, help with localization, or even answer questions on Discord. Every contribution, no matter the size, helps shape the future of MDN, and we want to ensure those efforts don't go unnoticed.
By contributing, your name could also appear on this page as one of the dedicated individuals shaping the web. Whether through our GitHub repository, working on translation efforts, or simply helping out other developers, there are plenty of opportunities to be a part of this community and leave your mark. The new page makes it easier than ever to get started, with guides and resources available to help you find the best way to contribute.
Contributing to open sourceIf you're new to contributing to MDN, we've made it easier than ever to get started. We've added a video that offers simple, clear instructions on how you can begin making an impact. We collaborate on GitHub, and you'll find step-by-step guidance to help you with writing, fixing bugs, or even improving documentation. Plus, you can check out our helpful video on how to get started with contributing to MDN Web Docs, so you're fully prepared to make your first contribution.
MDN is driven by a global community dedicated to documenting the web for the future. Whatever your skill set, there's a place for you to make a difference. You can now easily get involved, and start playing your part in building a better, more inclusive web.
Want to start contributing to MDN?We understand if you're new to MDN or open-source projects, and would like to start right away. That is exactly why we have our first issues front and center, it is the perfect place to start. We've highlighted beginner-friendly issues to help you improve MDN. This section lists specific tasks that are great for first-time contributors, whether it's fixing a bug, addressing an issue with documentation, or enhancing translated content. You'll find clear guidance on how to contribute, along with links to relevant repositories, so you can jump right in and start making an impact.
Join the conversationMDN is an open-source project that you can help us shape in many ways. We'd love it if you dropped by our Discord so you can get to know other community members, ask questions, and get help from fellow developers. It's a space for lively discussion where you can share ideas and seek advice. Also, we invite you to Join our Community Call, where you'll receive updates from the MDN team, hear about new initiatives, and share your questions and thoughts on how we can continue improving the platform and content. Whether through Discord or our calls, we want you to have the space to connect and make an impact in this community.
Licensing and reuseMDN Resources are openly accessible and free to reuse under a variety of open-source licenses. We encourage developers, educators, and content creators to use and share MDN's materials, as long as proper attribution is given. Our goal is to ensure that the knowledge we build together is freely available to anyone who needs it, while still protecting the contributions of our community members.
We're incredibly excited about the future of our community and what we can build together. We want our platform to be even more collaborative, accessible, and vibrant, where every contribution supports and shapes the web, and there's a place for everyone to make an impact.
We'd love to hear your feedback on the new community page or any ideas you have for improving MDN. Let us know on Discord or start a discussion on GitHub. I look forward to seeing you there!Previous Post Fixing your website's JavaScript performanceNext Post How to land your first developer job\n\n\n\nContributor profile@yashrajbhartiHi! I'm Yash, a UXE and a Senior Mentor of the Liquid Galaxy, where I work on GIS applications, making immersive data viz projects on Google Maps, Street View, and Earth. Liquid Galaxy is a Google-founded open-source project and was my primary reason for falling in love with open-source. I work on the web with HTML, CSS, and JS, and I believe that honing strong basics can make even the most complex tasks easy.
I still remember my first contribution to MDN. I was so proud of myself. Even though the fix was small, the cheer from Will Bamberg at the time meant a lot. It was for PWA docs, where I corrected that the iTunes value associated with the App Store for platform members of related apps has been dropped since it's currently not supported by Safari.
Since then, I have been lurking to find a way to contribute to MDN. I also contributed to web.dev to learn more. I am not new to MDN, W3C, or web.dev (HTML5Rocks), and have been learning like a nerd for the last 9 years, but a couple of years back, I started finally contributing. I felt like helping the community, making explainers, and I worked alongside people like Adam Argyle on a CSS motion blur proposal and Thomas Steiner (Project Fugu). I discovered, that when I put my passion and heart into something, I can achieve it. The grit to solve challenges isn't new to me.
My work at Liquid Galaxy, documentation, and creating an innovative UX to control Google Earth using Google Maps led me to get invited as a Speaker to Google, CA, USA, which was my first time outside India. I got to speak at Talks at Google, and most importantly, to network! I met Kristi Progri who was previously a Mozilla Representative, and I thought "that's so cool, I read MDN every day" and I was confident that I could get involved, too.
After an incredible journey to Google, knowing the roots of the Liquid Galaxy from 2008, I was mesmerized and was full of energy to do something, so I went to MDN and saw some small bugs like buttontext details, where I met Estelle Weyl (and I'm so thankful I did, as I had all the passion and pure knowledge waiting to test the waters). They helped me with the contributions by stating how buttontext for accessibility reasons will be fixed by filing a bug in WebKit. After some PRs like this, I mailed them asking to create an issue about the <model> tag. They told me it's still a WIP but there are some Baseline 'Widely Available' PRs I can contribute to. They trusted me, created a Google Sheet, and gave me edit access. And I delivered. The rest is history, I found my chance and took it, I knew Estelle because I had read her book on CSS, and was amazed to work alongside her on this. This sheet holds value to me and is the most up-to-date record of the work we are doing.
I love it because just think about how many future developers can be helped with it, those who truly learn like me and do not rely on crash courses to just get it "done". I thank Estelle for my journey and I want to stay in this community and help make MDN the library, a well-organized library I know it as, where you just know where each book is.Yash Raj BhartiMDN resonates with my passion to build a consistent and open web, where developers can learn and grow.How did you start using MDN?I started just like others, but using it as a source of learning, from those little tooltips that say "MDN reference" in VS Code, all the way to contributing and making the docs correct, wherever I can find a way to contribute, to hopefully be a part of it.What do you like about MDN?I like that it has all the implementation knowledge needed. When documenting, what I truly got to know from Will was, we are not just paraphrasing W3C specs, we are building it with an abstraction keeping in mind developers (and UXEs like me too) are our end users.Why do you contribute to Open Source or MDN?Anything open source is where we can ask "why should we not contribute"? There's all the reasons in the world to help and let everyone prosper, and that's what I love, whether it's for Google or Mozilla.What do you enjoy about contributing to MDN?I loved making DOMQuad as I was learning first hand and I believe I will become an encyclopedia as a by-product of helping others! That's rad.\n\n\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\n\n\nWebtechnologie für EntwicklerDas offene Web bietet unglaubliche Möglichkeiten für Entwickler. Um diese Technologien voll auszuschöpfen, müssen Sie wissen, wie man sie nutzt. Nachfolgend finden Sie Links zu unserer Webtechnologie-Dokumentation.Dokumentation für Webentwickler
Webentwickler-Leitfäden

Die Webentwickler-Leitfäden bieten praktische Anleitungen, um Ihnen zu helfen, Webtechnologien für Ihre Ziele oder Bedürfnisse zu nutzen.

Tutorials für Webentwickler

Tutorials, die Sie Schritt für Schritt durch das Lernen von HTML, CSS, JavaScript und Web-APIs führen.

Barrierefreiheit

Ermöglichen, dass so viele Menschen wie möglich Websites nutzen können, selbst wenn die Fähigkeiten dieser Menschen in irgendeiner Weise eingeschränkt sind.

Performance

Inhalte so schnell wie möglich verfügbar und interaktiv machen.

Datenschutz

Schutz der persönlichen Daten der Nutzer.

Sicherheit

Schutz der Benutzer vor Datenlecks und Datendiebstahl, Seitenkanalangriffen und Angriffen wie Cross-Site-Scripting, Inhaltseinschleusung und Clickjacking.

Glossar

Definitionen von Web-bezogenen Begriffen.

Webtechnologie-Referenzen
Web-APIs

JavaScript-Programmier-APIs, die Sie verwenden können, um Apps im Web zu entwickeln.

HTML

HTML bietet die grundlegenden Bausteine zur Strukturierung von Webdokumenten und Apps.

CSS

Cascading Style Sheets werden verwendet, um das Erscheinungsbild von Webdokumenten und Apps zu beschreiben.

JavaScript

JavaScript ist die native Programmiersprache des Webs.

WebAssembly

WebAssembly ermöglicht es, Programme, die in C, C++, Rust, Swift, C#, Go und mehr geschrieben sind, im Web auszuführen.

Events

Ereignisse sind das, worauf Sie Web-Apps reagieren lassen; zum Beispiel, wenn eine Webseite fertig geladen wurde, oder ein Benutzer etwas auswählt, eine Taste drückt, ein Fenster vergrößert, ein Formular absendet oder ein Video pausiert.

HTTP

HTTP ist das grundlegende Internetprotokoll zum Abrufen von Dokumenten, Stylesheets, Skripten, Bildern, Videos, Fonts und anderen Ressourcen über das Web – und zum Zurücksenden von Daten an Webserver.

Medien

Formate, Codecs, Protokolle, APIs und Techniken zum Einbetten und Streamen von Video-, Audio- und Bildinhalten in Webdokumenten und Apps.

SVG

Scalable Vector Graphics ermöglicht es Ihnen, Bilder zu erstellen, die sich reibungslos auf jede Größe skalieren lassen.

MathML

MathML ermöglicht die Darstellung komplexer mathematischer Notationen im Web.

URI

Uniform Resource Identifiers werden von verschiedenen Technologien verwendet, einschließlich des Browsers selbst über die Adressleiste, um Ressourcen auf unterschiedliche Weise zu identifizieren.

WebDriver

WebDriver ist ein Browser-Automatisierungsmechanismus zum Fernsteuern eines Browsers, indem Aktionen einer echten Person imitiert werden, die den Browser benutzt. Es wird häufig für Cross-Browser-Tests von Web-Apps verwendet.

Web-Erweiterungen

Web-Erweiterungen sind eine Möglichkeit, Benutzern erweiterte Funktionen in ihren Browsern bereitzustellen, indem z.B. Werbung und andere Inhalte blockiert, das Erscheinungsbild von Seiten angepasst und mehr getan wird.

Web App Manifeste

Web App Manifeste ermöglichen es Benutzern, Web-Apps auf ihren Gerätestartbildschirmen zu installieren, mit Aspekten wie Hoch-/Querformat-Bildschirmorientierung und Anzeigemodus (z.B. Vollbild) vorkonfiguriert.

Progressive Web Apps (PWAs)

Progressive Web Apps bieten ein Benutzererlebnis, das dem nativer mobiler Apps ähnelt.

OpenSearch

OpenSearch ermöglicht es einer Website, eine Suchmaschine für sich selbst zu beschreiben, so dass ein Browser oder eine andere Client-Anwendung diese Suchmaschine nutzen kann.

XML

Die Extensible Markup Language ist eine strikte Serialisierung des Document Object Model.

XSLT

Extensible Stylesheet Language Transformations ist eine auf XML basierende Sprache, die zusammen mit spezialisierten Verarbeitungsprogrammen zur Transformation von XML-Dokumenten verwendet wird.

XPath

XPath verwendet eine nicht-XML-Syntax, um eine flexible Möglichkeit zu bieten, verschiedene Teile eines XML-Dokuments anzusprechen (hinzuweisen). Es kann auch verwendet werden, um adressierte Knoten innerhalb eines Dokuments zu testen, um festzustellen, ob sie einem Muster entsprechen oder nicht.

EXSLT

EXSLT ist eine Menge von Erweiterungen zu XSLT.

Dokumentation der Entwicklerwerkzeuge
Firefox Developer Tools

Dokumentation für die Menge an Webentwickler-Werkzeugen, die in Firefox eingebaut sind.

Chrome DevTools

Dokumentation für die Menge an Webentwickler-Werkzeugen, die in Chrome eingebaut sind.

Safari Web Inspector

Dokumentation für die Menge an Webentwickler-Werkzeugen, die in Safari eingebaut sind.

Edge DevTools

Dokumentation für die Menge an Webentwickler-Werkzeugen, die in Edge eingebaut sind.\n\nWebtechnologie für EntwicklerDas offene Web bietet unglaubliche Möglichkeiten für Entwickler. Um diese Technologien voll auszuschöpfen, müssen Sie wissen, wie man sie nutzt. Nachfolgend finden Sie Links zu unserer Webtechnologie-Dokumentation.Dokumentation für Webentwickler
Webentwickler-Leitfäden

Die Webentwickler-Leitfäden bieten praktische Anleitungen, um Ihnen zu helfen, Webtechnologien für Ihre Ziele oder Bedürfnisse zu nutzen.

Tutorials für Webentwickler

Tutorials, die Sie Schritt für Schritt durch das Lernen von HTML, CSS, JavaScript und Web-APIs führen.

Barrierefreiheit

Ermöglichen, dass so viele Menschen wie möglich Websites nutzen können, selbst wenn die Fähigkeiten dieser Menschen in irgendeiner Weise eingeschränkt sind.

Performance

Inhalte so schnell wie möglich verfügbar und interaktiv machen.

Datenschutz

Schutz der persönlichen Daten der Nutzer.

Sicherheit

Schutz der Benutzer vor Datenlecks und Datendiebstahl, Seitenkanalangriffen und Angriffen wie Cross-Site-Scripting, Inhaltseinschleusung und Clickjacking.

Glossar

Definitionen von Web-bezogenen Begriffen.

Webtechnologie-Referenzen
Web-APIs

JavaScript-Programmier-APIs, die Sie verwenden können, um Apps im Web zu entwickeln.

HTML

HTML bietet die grundlegenden Bausteine zur Strukturierung von Webdokumenten und Apps.

CSS

Cascading Style Sheets werden verwendet, um das Erscheinungsbild von Webdokumenten und Apps zu beschreiben.

JavaScript

JavaScript ist die native Programmiersprache des Webs.

WebAssembly

WebAssembly ermöglicht es, Programme, die in C, C++, Rust, Swift, C#, Go und mehr geschrieben sind, im Web auszuführen.

Events

Ereignisse sind das, worauf Sie Web-Apps reagieren lassen; zum Beispiel, wenn eine Webseite fertig geladen wurde, oder ein Benutzer etwas auswählt, eine Taste drückt, ein Fenster vergrößert, ein Formular absendet oder ein Video pausiert.

HTTP

HTTP ist das grundlegende Internetprotokoll zum Abrufen von Dokumenten, Stylesheets, Skripten, Bildern, Videos, Fonts und anderen Ressourcen über das Web – und zum Zurücksenden von Daten an Webserver.

Medien

Formate, Codecs, Protokolle, APIs und Techniken zum Einbetten und Streamen von Video-, Audio- und Bildinhalten in Webdokumenten und Apps.

SVG

Scalable Vector Graphics ermöglicht es Ihnen, Bilder zu erstellen, die sich reibungslos auf jede Größe skalieren lassen.

MathML

MathML ermöglicht die Darstellung komplexer mathematischer Notationen im Web.

URI

Uniform Resource Identifiers werden von verschiedenen Technologien verwendet, einschließlich des Browsers selbst über die Adressleiste, um Ressourcen auf unterschiedliche Weise zu identifizieren.

WebDriver

WebDriver ist ein Browser-Automatisierungsmechanismus zum Fernsteuern eines Browsers, indem Aktionen einer echten Person imitiert werden, die den Browser benutzt. Es wird häufig für Cross-Browser-Tests von Web-Apps verwendet.

Web-Erweiterungen

Web-Erweiterungen sind eine Möglichkeit, Benutzern erweiterte Funktionen in ihren Browsern bereitzustellen, indem z.B. Werbung und andere Inhalte blockiert, das Erscheinungsbild von Seiten angepasst und mehr getan wird.

Web App Manifeste

Web App Manifeste ermöglichen es Benutzern, Web-Apps auf ihren Gerätestartbildschirmen zu installieren, mit Aspekten wie Hoch-/Querformat-Bildschirmorientierung und Anzeigemodus (z.B. Vollbild) vorkonfiguriert.

Progressive Web Apps (PWAs)

Progressive Web Apps bieten ein Benutzererlebnis, das dem nativer mobiler Apps ähnelt.

OpenSearch

OpenSearch ermöglicht es einer Website, eine Suchmaschine für sich selbst zu beschreiben, so dass ein Browser oder eine andere Client-Anwendung diese Suchmaschine nutzen kann.

XML

Die Extensible Markup Language ist eine strikte Serialisierung des Document Object Model.

XSLT

Extensible Stylesheet Language Transformations ist eine auf XML basierende Sprache, die zusammen mit spezialisierten Verarbeitungsprogrammen zur Transformation von XML-Dokumenten verwendet wird.

XPath

XPath verwendet eine nicht-XML-Syntax, um eine flexible Möglichkeit zu bieten, verschiedene Teile eines XML-Dokuments anzusprechen (hinzuweisen). Es kann auch verwendet werden, um adressierte Knoten innerhalb eines Dokuments zu testen, um festzustellen, ob sie einem Muster entsprechen oder nicht.

EXSLT

EXSLT ist eine Menge von Erweiterungen zu XSLT.

Dokumentation der Entwicklerwerkzeuge
Firefox Developer Tools

Dokumentation für die Menge an Webentwickler-Werkzeugen, die in Firefox eingebaut sind.

Chrome DevTools

Dokumentation für die Menge an Webentwickler-Werkzeugen, die in Chrome eingebaut sind.

Safari Web Inspector

Dokumentation für die Menge an Webentwickler-Werkzeugen, die in Safari eingebaut sind.

Edge DevTools

Dokumentation für die Menge an Webentwickler-Werkzeugen, die in Edge eingebaut sind.

MDN-Feedback-BoxWar diese Übersetzung hilfreich?JaNeinDiese Seite wurde automatisch aus dem Englischen übersetzt.Übersetzung auf GitHub anzeigen • Fehler mit dieser Übersetzung melden\n\nWebtechnologie für EntwicklerDas offene Web bietet unglaubliche Möglichkeiten für Entwickler. Um diese Technologien voll auszuschöpfen, müssen Sie wissen, wie man sie nutzt. Nachfolgend finden Sie Links zu unserer Webtechnologie-Dokumentation.Dokumentation für Webentwickler
Webentwickler-Leitfäden

Die Webentwickler-Leitfäden bieten praktische Anleitungen, um Ihnen zu helfen, Webtechnologien für Ihre Ziele oder Bedürfnisse zu nutzen.

Tutorials für Webentwickler

Tutorials, die Sie Schritt für Schritt durch das Lernen von HTML, CSS, JavaScript und Web-APIs führen.

Barrierefreiheit

Ermöglichen, dass so viele Menschen wie möglich Websites nutzen können, selbst wenn die Fähigkeiten dieser Menschen in irgendeiner Weise eingeschränkt sind.

Performance

Inhalte so schnell wie möglich verfügbar und interaktiv machen.

Datenschutz

Schutz der persönlichen Daten der Nutzer.

Sicherheit

Schutz der Benutzer vor Datenlecks und Datendiebstahl, Seitenkanalangriffen und Angriffen wie Cross-Site-Scripting, Inhaltseinschleusung und Clickjacking.

Glossar

Definitionen von Web-bezogenen Begriffen.

Webtechnologie-Referenzen
Web-APIs

JavaScript-Programmier-APIs, die Sie verwenden können, um Apps im Web zu entwickeln.

HTML

HTML bietet die grundlegenden Bausteine zur Strukturierung von Webdokumenten und Apps.

CSS

Cascading Style Sheets werden verwendet, um das Erscheinungsbild von Webdokumenten und Apps zu beschreiben.

JavaScript

JavaScript ist die native Programmiersprache des Webs.

WebAssembly

WebAssembly ermöglicht es, Programme, die in C, C++, Rust, Swift, C#, Go und mehr geschrieben sind, im Web auszuführen.

Events

Ereignisse sind das, worauf Sie Web-Apps reagieren lassen; zum Beispiel, wenn eine Webseite fertig geladen wurde, oder ein Benutzer etwas auswählt, eine Taste drückt, ein Fenster vergrößert, ein Formular absendet oder ein Video pausiert.

HTTP

HTTP ist das grundlegende Internetprotokoll zum Abrufen von Dokumenten, Stylesheets, Skripten, Bildern, Videos, Fonts und anderen Ressourcen über das Web – und zum Zurücksenden von Daten an Webserver.

Medien

Formate, Codecs, Protokolle, APIs und Techniken zum Einbetten und Streamen von Video-, Audio- und Bildinhalten in Webdokumenten und Apps.

SVG

Scalable Vector Graphics ermöglicht es Ihnen, Bilder zu erstellen, die sich reibungslos auf jede Größe skalieren lassen.

MathML

MathML ermöglicht die Darstellung komplexer mathematischer Notationen im Web.

URI

Uniform Resource Identifiers werden von verschiedenen Technologien verwendet, einschließlich des Browsers selbst über die Adressleiste, um Ressourcen auf unterschiedliche Weise zu identifizieren.

WebDriver

WebDriver ist ein Browser-Automatisierungsmechanismus zum Fernsteuern eines Browsers, indem Aktionen einer echten Person imitiert werden, die den Browser benutzt. Es wird häufig für Cross-Browser-Tests von Web-Apps verwendet.

Web-Erweiterungen

Web-Erweiterungen sind eine Möglichkeit, Benutzern erweiterte Funktionen in ihren Browsern bereitzustellen, indem z.B. Werbung und andere Inhalte blockiert, das Erscheinungsbild von Seiten angepasst und mehr getan wird.

Web App Manifeste

Web App Manifeste ermöglichen es Benutzern, Web-Apps auf ihren Gerätestartbildschirmen zu installieren, mit Aspekten wie Hoch-/Querformat-Bildschirmorientierung und Anzeigemodus (z.B. Vollbild) vorkonfiguriert.

Progressive Web Apps (PWAs)

Progressive Web Apps bieten ein Benutzererlebnis, das dem nativer mobiler Apps ähnelt.

OpenSearch

OpenSearch ermöglicht es einer Website, eine Suchmaschine für sich selbst zu beschreiben, so dass ein Browser oder eine andere Client-Anwendung diese Suchmaschine nutzen kann.

XML

Die Extensible Markup Language ist eine strikte Serialisierung des Document Object Model.

XSLT

Extensible Stylesheet Language Transformations ist eine auf XML basierende Sprache, die zusammen mit spezialisierten Verarbeitungsprogrammen zur Transformation von XML-Dokumenten verwendet wird.

XPath

XPath verwendet eine nicht-XML-Syntax, um eine flexible Möglichkeit zu bieten, verschiedene Teile eines XML-Dokuments anzusprechen (hinzuweisen). Es kann auch verwendet werden, um adressierte Knoten innerhalb eines Dokuments zu testen, um festzustellen, ob sie einem Muster entsprechen oder nicht.

EXSLT

EXSLT ist eine Menge von Erweiterungen zu XSLT.

Dokumentation der Entwicklerwerkzeuge
Firefox Developer Tools

Dokumentation für die Menge an Webentwickler-Werkzeugen, die in Firefox eingebaut sind.

Chrome DevTools

Dokumentation für die Menge an Webentwickler-Werkzeugen, die in Chrome eingebaut sind.

Safari Web Inspector

Dokumentation für die Menge an Webentwickler-Werkzeugen, die in Safari eingebaut sind.

Edge DevTools

Dokumentation für die Menge an Webentwickler-Werkzeugen, die in Edge eingebaut sind.

MDN-Feedback-BoxWar diese Übersetzung hilfreich?JaNeinDiese Seite wurde automatisch aus dem Englischen übersetzt.Übersetzung auf GitHub anzeigen • Fehler mit dieser Übersetzung melden\n\n\n\nTecnología para desarrolladores webLa Web abierta presenta increíbles oportunidades para los desarrolladores. Para aprovechar al máximo estas tecnologías, debes saber cómo utilizarlas. A continuación, encontrarás enlaces a nuestra documentación de tecnología web.Documentación para desarrolladores web
Referencia para desarrolladores web

Una lista de todas las referencias para tecnologías web, incluidas las de HTML, CSS, etc.

Guía para desarrolladores web

La Guía para desarrolladores web ofrece contenido práctico útil que te ayudará a utilizar las tecnologías web para hacer lo que quieres o necesitas hacer.

Tutoriales para desarrolladores web

Una lista de tutoriales que te guiarán paso a paso a través del aprendizaje de las APIs, tecnologías o amplias áreas temáticas.

Desarrollar aplicaciones web

Documentación para desarrolladores de aplicaciones web; Las aplicaciones web son verdaderas aplicaciones de una sola escritura y se implementan en cualquier lugar para dispositivos móviles, de escritorio y Firefox OS.

Fragmentos de código

Esta es una lista rápida de fragmentos de código útiles (pequeñas muestras de código) disponibles para los desarrolladores de extensiones para las diversas aplicaciones de Mozilla. Muchos de estos ejemplos también se pueden utilizar en aplicaciones XULRunner, así como en el propio código de Mozilla.

Referencias de tecnología web
APIs web

Material de referencia para cada una de las APIs individuales que comprenden la poderosa capacidad de secuencia de comandos de la Web, incluido el DOM y todas las APIs e interfaces relacionadas que puedes utilizar para crear contenido y aplicaciones Web.

HTML

El lenguaje de marcado de hipertexto es el lenguaje utilizado para describir y definir el contenido de una página web.

CSS

Las hojas de estilo en cascada (Cascading Style Sheets) se utilizan para describir la apariencia del contenido web.

SVG

Los gráficos vectoriales escalables (Scalable Vector Graphics) te permiten describir imágenes como conjuntos de vectores y formas para permitirles escalar sin problemas, independientemente del tamaño en el que se dibujen.

MathML

El lenguaje de marcado matemático permite mostrar sintaxis y ecuaciones matemáticas complejas.


Temporal
Lo siguiente aquí es temporal para ayudarte a realizar un seguimiento de las cosas mientras el trabajo de la organización está en curso. No le hagas caso.
AccesibilidadAplicaciones Web ProgresivasCSSHTML: Lenguaje de etiquetas de hipertextoHTTPJavaScriptMathMLReferencia de EventosReferencia de la API WebRendimiento WebSVGSeguridad WebTecnologías multimedia de la webXML: Lenguaje de marcado extensible\n\nTecnología para desarrolladores webLa Web abierta presenta increíbles oportunidades para los desarrolladores. Para aprovechar al máximo estas tecnologías, debes saber cómo utilizarlas. A continuación, encontrarás enlaces a nuestra documentación de tecnología web.Documentación para desarrolladores web
Referencia para desarrolladores web

Una lista de todas las referencias para tecnologías web, incluidas las de HTML, CSS, etc.

Guía para desarrolladores web

La Guía para desarrolladores web ofrece contenido práctico útil que te ayudará a utilizar las tecnologías web para hacer lo que quieres o necesitas hacer.

Tutoriales para desarrolladores web

Una lista de tutoriales que te guiarán paso a paso a través del aprendizaje de las APIs, tecnologías o amplias áreas temáticas.

Desarrollar aplicaciones web

Documentación para desarrolladores de aplicaciones web; Las aplicaciones web son verdaderas aplicaciones de una sola escritura y se implementan en cualquier lugar para dispositivos móviles, de escritorio y Firefox OS.

Fragmentos de código

Esta es una lista rápida de fragmentos de código útiles (pequeñas muestras de código) disponibles para los desarrolladores de extensiones para las diversas aplicaciones de Mozilla. Muchos de estos ejemplos también se pueden utilizar en aplicaciones XULRunner, así como en el propio código de Mozilla.

Referencias de tecnología web
APIs web

Material de referencia para cada una de las APIs individuales que comprenden la poderosa capacidad de secuencia de comandos de la Web, incluido el DOM y todas las APIs e interfaces relacionadas que puedes utilizar para crear contenido y aplicaciones Web.

HTML

El lenguaje de marcado de hipertexto es el lenguaje utilizado para describir y definir el contenido de una página web.

CSS

Las hojas de estilo en cascada (Cascading Style Sheets) se utilizan para describir la apariencia del contenido web.

SVG

Los gráficos vectoriales escalables (Scalable Vector Graphics) te permiten describir imágenes como conjuntos de vectores y formas para permitirles escalar sin problemas, independientemente del tamaño en el que se dibujen.

MathML

El lenguaje de marcado matemático permite mostrar sintaxis y ecuaciones matemáticas complejas.


Temporal
Lo siguiente aquí es temporal para ayudarte a realizar un seguimiento de las cosas mientras el trabajo de la organización está en curso. No le hagas caso.
AccesibilidadAplicaciones Web ProgresivasCSSHTML: Lenguaje de etiquetas de hipertextoHTTPJavaScriptMathMLReferencia de EventosReferencia de la API WebRendimiento WebSVGSeguridad WebTecnologías multimedia de la webXML: Lenguaje de marcado extensibleHelp improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 27 mar 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nTecnología para desarrolladores webLa Web abierta presenta increíbles oportunidades para los desarrolladores. Para aprovechar al máximo estas tecnologías, debes saber cómo utilizarlas. A continuación, encontrarás enlaces a nuestra documentación de tecnología web.Documentación para desarrolladores web
Referencia para desarrolladores web

Una lista de todas las referencias para tecnologías web, incluidas las de HTML, CSS, etc.

Guía para desarrolladores web

La Guía para desarrolladores web ofrece contenido práctico útil que te ayudará a utilizar las tecnologías web para hacer lo que quieres o necesitas hacer.

Tutoriales para desarrolladores web

Una lista de tutoriales que te guiarán paso a paso a través del aprendizaje de las APIs, tecnologías o amplias áreas temáticas.

Desarrollar aplicaciones web

Documentación para desarrolladores de aplicaciones web; Las aplicaciones web son verdaderas aplicaciones de una sola escritura y se implementan en cualquier lugar para dispositivos móviles, de escritorio y Firefox OS.

Fragmentos de código

Esta es una lista rápida de fragmentos de código útiles (pequeñas muestras de código) disponibles para los desarrolladores de extensiones para las diversas aplicaciones de Mozilla. Muchos de estos ejemplos también se pueden utilizar en aplicaciones XULRunner, así como en el propio código de Mozilla.

Referencias de tecnología web
APIs web

Material de referencia para cada una de las APIs individuales que comprenden la poderosa capacidad de secuencia de comandos de la Web, incluido el DOM y todas las APIs e interfaces relacionadas que puedes utilizar para crear contenido y aplicaciones Web.

HTML

El lenguaje de marcado de hipertexto es el lenguaje utilizado para describir y definir el contenido de una página web.

CSS

Las hojas de estilo en cascada (Cascading Style Sheets) se utilizan para describir la apariencia del contenido web.

SVG

Los gráficos vectoriales escalables (Scalable Vector Graphics) te permiten describir imágenes como conjuntos de vectores y formas para permitirles escalar sin problemas, independientemente del tamaño en el que se dibujen.

MathML

El lenguaje de marcado matemático permite mostrar sintaxis y ecuaciones matemáticas complejas.


Temporal
Lo siguiente aquí es temporal para ayudarte a realizar un seguimiento de las cosas mientras el trabajo de la organización está en curso. No le hagas caso.
AccesibilidadAplicaciones Web ProgresivasCSSHTML: Lenguaje de etiquetas de hipertextoHTTPJavaScriptMathMLReferencia de EventosReferencia de la API WebRendimiento WebSVGSeguridad WebTecnologías multimedia de la webXML: Lenguaje de marcado extensibleHelp improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 27 mar 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nTechnologies web pour développeursLe Web fournit d'incroyables opportunités aux développeuses et développeurs. Pour tirer le meilleur parti de ces technologies, il est nécessaire de savoir comment les utiliser. Voici différents liens qui vous permettront de naviguer dans la documentation de ces technologies web.Documentation pour le développement web
Références

Une liste de l'ensemble des références sur les technologies web dont celles sur HTML, CSS, etc.

Guides

Cette page fournit différents tutoriels pour vous aider à manipuler les technologies web afin de réaliser ce que vous souhaitez.

Tutoriels

Une liste de tutoriels qui progressent étape par étape pour apprendre les API, langages et autres sujets.

Les applications web progressives (Progressive Web Applications ou PWA en anglais)

Les applications web progressives sont des applications web qui utilisent les API et les fonctionnalités du navigateur ainsi que des stratégies d'amélioration progressive afin d'apporter une expérience utilisateur semblable aux applications natives et qui puissent fonctionner sur les différentes plateformes web.

Références des technologies web
API Web

Les références pour l'ensemble des API qui permettent de rendre le Web interactif et scriptable. On y trouve notamment le DOM, les diverses interfaces et API utilisées pour construire du contenu et des applications web.

HTML

HyperText Markup Language est le langage utilisé pour décrire et définir le contenu d'une page web.

CSS

Cascading Style Sheets est le langage utilisé pour décrire l'apparence du contenu web.

JavaScript

JavaScript est le langage de programmation utilisé pour ajouter de l'interactivité à un site web.

HTTP

HyperText Transfer Protocol est le protocole utilisé entre le navigateur et les serveurs web.

SVG

Scalable Vector Graphics est un format qui permet de décrire des images comme ensembles de vecteurs et de formes afin de pouvoir les mettre à l'échelle quelles que soient les dimensions selon lesquelles elles sont dessinées.

MathML

Mathematical Markup Language est un langage qui permet d'afficher des expressions mathématiques complexes.\n\nTechnologies web pour développeursLe Web fournit d'incroyables opportunités aux développeuses et développeurs. Pour tirer le meilleur parti de ces technologies, il est nécessaire de savoir comment les utiliser. Voici différents liens qui vous permettront de naviguer dans la documentation de ces technologies web.Documentation pour le développement web
Références

Une liste de l'ensemble des références sur les technologies web dont celles sur HTML, CSS, etc.

Guides

Cette page fournit différents tutoriels pour vous aider à manipuler les technologies web afin de réaliser ce que vous souhaitez.

Tutoriels

Une liste de tutoriels qui progressent étape par étape pour apprendre les API, langages et autres sujets.

Les applications web progressives (Progressive Web Applications ou PWA en anglais)

Les applications web progressives sont des applications web qui utilisent les API et les fonctionnalités du navigateur ainsi que des stratégies d'amélioration progressive afin d'apporter une expérience utilisateur semblable aux applications natives et qui puissent fonctionner sur les différentes plateformes web.

Références des technologies web
API Web

Les références pour l'ensemble des API qui permettent de rendre le Web interactif et scriptable. On y trouve notamment le DOM, les diverses interfaces et API utilisées pour construire du contenu et des applications web.

HTML

HyperText Markup Language est le langage utilisé pour décrire et définir le contenu d'une page web.

CSS

Cascading Style Sheets est le langage utilisé pour décrire l'apparence du contenu web.

JavaScript

JavaScript est le langage de programmation utilisé pour ajouter de l'interactivité à un site web.

HTTP

HyperText Transfer Protocol est le protocole utilisé entre le navigateur et les serveurs web.

SVG

Scalable Vector Graphics est un format qui permet de décrire des images comme ensembles de vecteurs et de formes afin de pouvoir les mettre à l'échelle quelles que soient les dimensions selon lesquelles elles sont dessinées.

MathML

Mathematical Markup Language est un langage qui permet d'afficher des expressions mathématiques complexes.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 17 déc. 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nTechnologies web pour développeursLe Web fournit d'incroyables opportunités aux développeuses et développeurs. Pour tirer le meilleur parti de ces technologies, il est nécessaire de savoir comment les utiliser. Voici différents liens qui vous permettront de naviguer dans la documentation de ces technologies web.Documentation pour le développement web
Références

Une liste de l'ensemble des références sur les technologies web dont celles sur HTML, CSS, etc.

Guides

Cette page fournit différents tutoriels pour vous aider à manipuler les technologies web afin de réaliser ce que vous souhaitez.

Tutoriels

Une liste de tutoriels qui progressent étape par étape pour apprendre les API, langages et autres sujets.

Les applications web progressives (Progressive Web Applications ou PWA en anglais)

Les applications web progressives sont des applications web qui utilisent les API et les fonctionnalités du navigateur ainsi que des stratégies d'amélioration progressive afin d'apporter une expérience utilisateur semblable aux applications natives et qui puissent fonctionner sur les différentes plateformes web.

Références des technologies web
API Web

Les références pour l'ensemble des API qui permettent de rendre le Web interactif et scriptable. On y trouve notamment le DOM, les diverses interfaces et API utilisées pour construire du contenu et des applications web.

HTML

HyperText Markup Language est le langage utilisé pour décrire et définir le contenu d'une page web.

CSS

Cascading Style Sheets est le langage utilisé pour décrire l'apparence du contenu web.

JavaScript

JavaScript est le langage de programmation utilisé pour ajouter de l'interactivité à un site web.

HTTP

HyperText Transfer Protocol est le protocole utilisé entre le navigateur et les serveurs web.

SVG

Scalable Vector Graphics est un format qui permet de décrire des images comme ensembles de vecteurs et de formes afin de pouvoir les mettre à l'échelle quelles que soient les dimensions selon lesquelles elles sont dessinées.

MathML

Mathematical Markup Language est un langage qui permet d'afficher des expressions mathématiques complexes.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 17 déc. 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\n開発者向けのウェブ技術オープンなウェブは、開発者に素晴らしい機会をもたらします。これらの技術を最大限に活用するには、それらの使い方を知る必要があります。以下に、ウェブ技術のドキュメントへのリンクがあります。ウェブ開発者のためのドキュメント
ウェブ開発者ガイド

ウェブ開発者ガイドは、ウェブ技術を実際に使用して、やりたいことや必要なことを実現するために役立つハウツーコンテンツを提供しています。

ウェブ開発者向けチュートリアル

HTML、CSS、JavaScript、Web API の学習を段階的に進めるためのチュートリアルです。

アクセシビリティ

ウェブサイトを使用する人に何らかの制約があっても、できるだけ多くの人が使用できるようにすることです。

パフォーマンス

コンテンツをできるだけ早く利用できるように、操作できるようにすることです。

セキュリティ

データ漏洩やデータ盗難、サイドチャンネル攻撃、クロスサイトスクリプティング、コンテンツインジェクション、クリックジャッキングなどの攻撃からユーザーを保護することです。

ウェブ技術のリファレンス
Web API

ウェブでアプリを構築するために利用できる JavaScript のプログラミング API 群です。

HTML

HTML は、ウェブの文書やアプリを構成する基礎的な構成要素を提供します。

CSS

CSS は、ウェブの文書やアプリの外観を記述するために使用されます。

JavaScript

JavaScript は、ウェブのネイティブプログラミング言語です。

WebAssembly

WebAssembly により、 C、C++、Rust、Swift、C#、Go などで書かれたプログラムをウェブで実行できます。

イベント

イベントとは、ウェブアプリで応答するために構築するものです。例えば、ウェブページの読み込みが完了したとき、ユーザーが何かを選択したとき、キーを押したとき、ウィンドウのサイズを変更したとき、フォームを送信したとき、動画を一時停止したとき、などです。

HTTP

HTTP は、文書、スタイルシート、スクリプト、画像、動画、フォント、その他のリソースをウェブ上で取得し、ウェブサーバーにデータを送り返すための基本的なインターネットプロトコルです。

メディア

ウェブ文書やアプリに動画、音声、画像コンテンツを埋め込んだりストリーミングしたりするための形式、コーデック、プロトコル、API、技術です。

SVG

SVG を使用すると、画像を一連のベクトルと形状として記述して、描画されるサイズに関係なくスムーズに拡大縮小できます。

MathML

MathML により、複雑な数式や構文を表示することができます。

ウェブコンポーネント

ウェブコンポーネントは、アプリで定義したり再利用したりすることができるカスタム要素です。

WebDriver

WebDriverは、実際にブラウザーを使用している人の動作をエミュレートして、ブラウザーを遠隔制御するためのブラウザーオートメーションメカニズムです。

ウェブ拡張機能

ウェブ拡張機能は、ユーザーがブラウザーで広告や他のコンテンツをブロックしたり、ページの外観をカスタマイズしたりするなどの機能を強化するための方法です。

ウェブアプリマニフェスト

ウェブアプリマニフェストにより、縦画面/横画面の方向や表示モード（全画面など）をあらかじめ設定し、ユーザーの機器のホーム画面へウェブアプリケーションをインストールすることができます。

プログレッシブウェブアプリ (PWA)

プログレッシブウェブアプリは、ネイティブアプリのような使い勝手をもたらします。

用語集

ウェブ関連用語の定義。

開発者ツールの文書
Firefox Developer Tools

Firefox に組み込まれた一連のウェブ開発者ツールのためのドキュメントです。

Chrome DevTools

Chrome に組み込まれた一連のウェブ開発者ツールのためのドキュメントです。

Safari Web Inspector

Safari に組み込まれた一連のウェブ開発者ツールのためのドキュメントです。

Edge DevTools

Edge に組み込まれた一連のウェブ開発者ツールのためのドキュメントです。\n\n開発者向けのウェブ技術オープンなウェブは、開発者に素晴らしい機会をもたらします。これらの技術を最大限に活用するには、それらの使い方を知る必要があります。以下に、ウェブ技術のドキュメントへのリンクがあります。ウェブ開発者のためのドキュメント
ウェブ開発者ガイド

ウェブ開発者ガイドは、ウェブ技術を実際に使用して、やりたいことや必要なことを実現するために役立つハウツーコンテンツを提供しています。

ウェブ開発者向けチュートリアル

HTML、CSS、JavaScript、Web API の学習を段階的に進めるためのチュートリアルです。

アクセシビリティ

ウェブサイトを使用する人に何らかの制約があっても、できるだけ多くの人が使用できるようにすることです。

パフォーマンス

コンテンツをできるだけ早く利用できるように、操作できるようにすることです。

セキュリティ

データ漏洩やデータ盗難、サイドチャンネル攻撃、クロスサイトスクリプティング、コンテンツインジェクション、クリックジャッキングなどの攻撃からユーザーを保護することです。

ウェブ技術のリファレンス
Web API

ウェブでアプリを構築するために利用できる JavaScript のプログラミング API 群です。

HTML

HTML は、ウェブの文書やアプリを構成する基礎的な構成要素を提供します。

CSS

CSS は、ウェブの文書やアプリの外観を記述するために使用されます。

JavaScript

JavaScript は、ウェブのネイティブプログラミング言語です。

WebAssembly

WebAssembly により、 C、C++、Rust、Swift、C#、Go などで書かれたプログラムをウェブで実行できます。

イベント

イベントとは、ウェブアプリで応答するために構築するものです。例えば、ウェブページの読み込みが完了したとき、ユーザーが何かを選択したとき、キーを押したとき、ウィンドウのサイズを変更したとき、フォームを送信したとき、動画を一時停止したとき、などです。

HTTP

HTTP は、文書、スタイルシート、スクリプト、画像、動画、フォント、その他のリソースをウェブ上で取得し、ウェブサーバーにデータを送り返すための基本的なインターネットプロトコルです。

メディア

ウェブ文書やアプリに動画、音声、画像コンテンツを埋め込んだりストリーミングしたりするための形式、コーデック、プロトコル、API、技術です。

SVG

SVG を使用すると、画像を一連のベクトルと形状として記述して、描画されるサイズに関係なくスムーズに拡大縮小できます。

MathML

MathML により、複雑な数式や構文を表示することができます。

ウェブコンポーネント

ウェブコンポーネントは、アプリで定義したり再利用したりすることができるカスタム要素です。

WebDriver

WebDriverは、実際にブラウザーを使用している人の動作をエミュレートして、ブラウザーを遠隔制御するためのブラウザーオートメーションメカニズムです。

ウェブ拡張機能

ウェブ拡張機能は、ユーザーがブラウザーで広告や他のコンテンツをブロックしたり、ページの外観をカスタマイズしたりするなどの機能を強化するための方法です。

ウェブアプリマニフェスト

ウェブアプリマニフェストにより、縦画面/横画面の方向や表示モード（全画面など）をあらかじめ設定し、ユーザーの機器のホーム画面へウェブアプリケーションをインストールすることができます。

プログレッシブウェブアプリ (PWA)

プログレッシブウェブアプリは、ネイティブアプリのような使い勝手をもたらします。

用語集

ウェブ関連用語の定義。

開発者ツールの文書
Firefox Developer Tools

Firefox に組み込まれた一連のウェブ開発者ツールのためのドキュメントです。

Chrome DevTools

Chrome に組み込まれた一連のウェブ開発者ツールのためのドキュメントです。

Safari Web Inspector

Safari に組み込まれた一連のウェブ開発者ツールのためのドキュメントです。

Edge DevTools

Edge に組み込まれた一連のウェブ開発者ツールのためのドキュメントです。

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025年3月21日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n開発者向けのウェブ技術オープンなウェブは、開発者に素晴らしい機会をもたらします。これらの技術を最大限に活用するには、それらの使い方を知る必要があります。以下に、ウェブ技術のドキュメントへのリンクがあります。ウェブ開発者のためのドキュメント
ウェブ開発者ガイド

ウェブ開発者ガイドは、ウェブ技術を実際に使用して、やりたいことや必要なことを実現するために役立つハウツーコンテンツを提供しています。

ウェブ開発者向けチュートリアル

HTML、CSS、JavaScript、Web API の学習を段階的に進めるためのチュートリアルです。

アクセシビリティ

ウェブサイトを使用する人に何らかの制約があっても、できるだけ多くの人が使用できるようにすることです。

パフォーマンス

コンテンツをできるだけ早く利用できるように、操作できるようにすることです。

セキュリティ

データ漏洩やデータ盗難、サイドチャンネル攻撃、クロスサイトスクリプティング、コンテンツインジェクション、クリックジャッキングなどの攻撃からユーザーを保護することです。

ウェブ技術のリファレンス
Web API

ウェブでアプリを構築するために利用できる JavaScript のプログラミング API 群です。

HTML

HTML は、ウェブの文書やアプリを構成する基礎的な構成要素を提供します。

CSS

CSS は、ウェブの文書やアプリの外観を記述するために使用されます。

JavaScript

JavaScript は、ウェブのネイティブプログラミング言語です。

WebAssembly

WebAssembly により、 C、C++、Rust、Swift、C#、Go などで書かれたプログラムをウェブで実行できます。

イベント

イベントとは、ウェブアプリで応答するために構築するものです。例えば、ウェブページの読み込みが完了したとき、ユーザーが何かを選択したとき、キーを押したとき、ウィンドウのサイズを変更したとき、フォームを送信したとき、動画を一時停止したとき、などです。

HTTP

HTTP は、文書、スタイルシート、スクリプト、画像、動画、フォント、その他のリソースをウェブ上で取得し、ウェブサーバーにデータを送り返すための基本的なインターネットプロトコルです。

メディア

ウェブ文書やアプリに動画、音声、画像コンテンツを埋め込んだりストリーミングしたりするための形式、コーデック、プロトコル、API、技術です。

SVG

SVG を使用すると、画像を一連のベクトルと形状として記述して、描画されるサイズに関係なくスムーズに拡大縮小できます。

MathML

MathML により、複雑な数式や構文を表示することができます。

ウェブコンポーネント

ウェブコンポーネントは、アプリで定義したり再利用したりすることができるカスタム要素です。

WebDriver

WebDriverは、実際にブラウザーを使用している人の動作をエミュレートして、ブラウザーを遠隔制御するためのブラウザーオートメーションメカニズムです。

ウェブ拡張機能

ウェブ拡張機能は、ユーザーがブラウザーで広告や他のコンテンツをブロックしたり、ページの外観をカスタマイズしたりするなどの機能を強化するための方法です。

ウェブアプリマニフェスト

ウェブアプリマニフェストにより、縦画面/横画面の方向や表示モード（全画面など）をあらかじめ設定し、ユーザーの機器のホーム画面へウェブアプリケーションをインストールすることができます。

プログレッシブウェブアプリ (PWA)

プログレッシブウェブアプリは、ネイティブアプリのような使い勝手をもたらします。

用語集

ウェブ関連用語の定義。

開発者ツールの文書
Firefox Developer Tools

Firefox に組み込まれた一連のウェブ開発者ツールのためのドキュメントです。

Chrome DevTools

Chrome に組み込まれた一連のウェブ開発者ツールのためのドキュメントです。

Safari Web Inspector

Safari に組み込まれた一連のウェブ開発者ツールのためのドキュメントです。

Edge DevTools

Edge に組み込まれた一連のウェブ開発者ツールのためのドキュメントです。

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025年3月21日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\n개발자를 위한 웹 기술웹의 개방성은 개발자들에게 많은 기회를 제공합니다. 하지만 웹 기술을 잘 활용하려면 우선 그 사용 방법을 잘 알아야 합니다. 아래의 링크들을 확인하여 다양한 웹 기술을 배워보세요.웹 개발자를 위한 문서
웹 개발자 안내서

웹 개발자 안내서는 원하는 것과 필요한 것을 웹으로 만들 때 유용한 도움말을 제공합니다.

웹 개발자를 위한 자습서

HTML, CSS, JavaScript, Web API에 대한 단계별 학습을 제공하는 문서 목록입니다.

접근성

가능한 한 많은 사람들이 웹사이트를 사용할 수 있게 합니다. 비록 이러한 사람들의 능력이 어떤 식으로든 제한되어 있는 경우에도 말이죠.

성능

가능한 한 빠르게 콘텐츠를 사용 가능하게 하고 가능하면 상호작용이 기능하게 만듭니다.

개인정보

사용자의 개인 데이터를 보호합니다.

보안

데이터 유출 및 도난, 부채널 공격(side-channel attacks) 및 크로스 사이트 스크립팅, 콘텐츠 주입 및 클릭 재킹과 같은 공격으로부터 사용자를 보호합니다.

웹 기술 참고서
웹 API

웹에서 앱을 만들기 위해 사용하는 JavaScript 프로그래밍 API입니다.

HTML

HTML은 웹 문서와 앱을 구조화하는데 필요한 기본적인 구성 요소를 제공합니다.

CSS

Cascading Style Sheets는 웹 문서와 앱의 외형을 만드는데 사용됩니다.

JavaScript

JavaScript는 웹의 기본 프로그래밍 언어입니다.

WebAssembly

WebAssembly는 C, C++, Rust, Swift, C#, Go 등으로 작성한 프로그램을 웹에서 구동할 수 있도록 합니다.

Events

이벤트는 웹 페이지 로드가 완료되거나 사용자가 무언가를 선택하거나 키를 누르거나 창 크기를 조정하거나 양식을 제출하거나 비디오를 일시 중지할 때 여러분이 만든 웹 앱이 반응해야하는 것 입니다.

HTTP

HTTP는 웹을 통해 문서, 스타일시트, 스크립트, 이미지, 비디오, 글꼴 및 기타 리소스를 가져오고 웹 서버로 다시 보내기 위한 기본적인 인터넷 프로토콜입니다.

Media

웹 문서 및 앱에 비디오, 오디오 및 이미지 콘텐츠를 내장하고 스트리밍하기 위한 형식, 코덱, 프로토콜, API 및 기술.

SVG

Scalable Vector Graphics(SVG)는 어떠한 크기로 확대해도 부드러운 이미지를 만들수 있습니다.

MathML

MathML은 복잡한 수학 표기법을 웹에 표시할 수 있습니다.

웹 컴포넌트

웹 컴포넌트는 개발자가 직접 정의하고 재사용할 수 있는 사용자 정의 요소입니다.

WebDriver

웹드라이버(WebDriver)는 브라우저를 사용하는 실제 사람의 행위를 모방하여 원격으로 브라우저를 제어하는 브라우저-자동화 메커니즘입니다. 웹 앱의 브라우저간 테스트를 위해 폭넓게 사용합니다.

Web Extensions

웹 확장 기능(Web Extensions)은 브라우저에서 사용자에게 향상된 기능을 제공합니다. 광고 및 기타 컨텐츠 차단, 페이지 모양 사용자 지정 등을 수행할 수 있습니다.

Web App Manifests

웹 앱 매니페스트(Web App Manifest)를 사용하면 사용자가 세로/가로 화면 방향과 디스플레이 모드(예: 전체 화면)를 미리 설정하여 장치의 홈 스크린에 웹 앱을 설치할 수 있습니다.

프로그레시브 웹 앱(PWAs)

프로그레시브 웹 앱(Progressive Web App)은 네이티브 모바일 앱과 유사한 사용자 경험을 제공합니다.

개발자 도구 문서
Firefox Developer Tools

Firefox에 내장된 웹 개발자 도구 집합에 대한 설명서입니다.

Chrome DevTools

Chrome에 내장된 웹 개발자 도구 집합에 대한 설명서입니다.

Safari Web Inspector

Safari에 내장된 웹 개발자 도구 집합에 대한 설명서입니다.

Edge DevTools

Edge에 내장된 웹 개발자 도구 집합에 대한 설명서입니다.\n\n개발자를 위한 웹 기술웹의 개방성은 개발자들에게 많은 기회를 제공합니다. 하지만 웹 기술을 잘 활용하려면 우선 그 사용 방법을 잘 알아야 합니다. 아래의 링크들을 확인하여 다양한 웹 기술을 배워보세요.웹 개발자를 위한 문서
웹 개발자 안내서

웹 개발자 안내서는 원하는 것과 필요한 것을 웹으로 만들 때 유용한 도움말을 제공합니다.

웹 개발자를 위한 자습서

HTML, CSS, JavaScript, Web API에 대한 단계별 학습을 제공하는 문서 목록입니다.

접근성

가능한 한 많은 사람들이 웹사이트를 사용할 수 있게 합니다. 비록 이러한 사람들의 능력이 어떤 식으로든 제한되어 있는 경우에도 말이죠.

성능

가능한 한 빠르게 콘텐츠를 사용 가능하게 하고 가능하면 상호작용이 기능하게 만듭니다.

개인정보

사용자의 개인 데이터를 보호합니다.

보안

데이터 유출 및 도난, 부채널 공격(side-channel attacks) 및 크로스 사이트 스크립팅, 콘텐츠 주입 및 클릭 재킹과 같은 공격으로부터 사용자를 보호합니다.

웹 기술 참고서
웹 API

웹에서 앱을 만들기 위해 사용하는 JavaScript 프로그래밍 API입니다.

HTML

HTML은 웹 문서와 앱을 구조화하는데 필요한 기본적인 구성 요소를 제공합니다.

CSS

Cascading Style Sheets는 웹 문서와 앱의 외형을 만드는데 사용됩니다.

JavaScript

JavaScript는 웹의 기본 프로그래밍 언어입니다.

WebAssembly

WebAssembly는 C, C++, Rust, Swift, C#, Go 등으로 작성한 프로그램을 웹에서 구동할 수 있도록 합니다.

Events

이벤트는 웹 페이지 로드가 완료되거나 사용자가 무언가를 선택하거나 키를 누르거나 창 크기를 조정하거나 양식을 제출하거나 비디오를 일시 중지할 때 여러분이 만든 웹 앱이 반응해야하는 것 입니다.

HTTP

HTTP는 웹을 통해 문서, 스타일시트, 스크립트, 이미지, 비디오, 글꼴 및 기타 리소스를 가져오고 웹 서버로 다시 보내기 위한 기본적인 인터넷 프로토콜입니다.

Media

웹 문서 및 앱에 비디오, 오디오 및 이미지 콘텐츠를 내장하고 스트리밍하기 위한 형식, 코덱, 프로토콜, API 및 기술.

SVG

Scalable Vector Graphics(SVG)는 어떠한 크기로 확대해도 부드러운 이미지를 만들수 있습니다.

MathML

MathML은 복잡한 수학 표기법을 웹에 표시할 수 있습니다.

웹 컴포넌트

웹 컴포넌트는 개발자가 직접 정의하고 재사용할 수 있는 사용자 정의 요소입니다.

WebDriver

웹드라이버(WebDriver)는 브라우저를 사용하는 실제 사람의 행위를 모방하여 원격으로 브라우저를 제어하는 브라우저-자동화 메커니즘입니다. 웹 앱의 브라우저간 테스트를 위해 폭넓게 사용합니다.

Web Extensions

웹 확장 기능(Web Extensions)은 브라우저에서 사용자에게 향상된 기능을 제공합니다. 광고 및 기타 컨텐츠 차단, 페이지 모양 사용자 지정 등을 수행할 수 있습니다.

Web App Manifests

웹 앱 매니페스트(Web App Manifest)를 사용하면 사용자가 세로/가로 화면 방향과 디스플레이 모드(예: 전체 화면)를 미리 설정하여 장치의 홈 스크린에 웹 앱을 설치할 수 있습니다.

프로그레시브 웹 앱(PWAs)

프로그레시브 웹 앱(Progressive Web App)은 네이티브 모바일 앱과 유사한 사용자 경험을 제공합니다.

개발자 도구 문서
Firefox Developer Tools

Firefox에 내장된 웹 개발자 도구 집합에 대한 설명서입니다.

Chrome DevTools

Chrome에 내장된 웹 개발자 도구 집합에 대한 설명서입니다.

Safari Web Inspector

Safari에 내장된 웹 개발자 도구 집합에 대한 설명서입니다.

Edge DevTools

Edge에 내장된 웹 개발자 도구 집합에 대한 설명서입니다.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025년 1월 19일 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n개발자를 위한 웹 기술웹의 개방성은 개발자들에게 많은 기회를 제공합니다. 하지만 웹 기술을 잘 활용하려면 우선 그 사용 방법을 잘 알아야 합니다. 아래의 링크들을 확인하여 다양한 웹 기술을 배워보세요.웹 개발자를 위한 문서
웹 개발자 안내서

웹 개발자 안내서는 원하는 것과 필요한 것을 웹으로 만들 때 유용한 도움말을 제공합니다.

웹 개발자를 위한 자습서

HTML, CSS, JavaScript, Web API에 대한 단계별 학습을 제공하는 문서 목록입니다.

접근성

가능한 한 많은 사람들이 웹사이트를 사용할 수 있게 합니다. 비록 이러한 사람들의 능력이 어떤 식으로든 제한되어 있는 경우에도 말이죠.

성능

가능한 한 빠르게 콘텐츠를 사용 가능하게 하고 가능하면 상호작용이 기능하게 만듭니다.

개인정보

사용자의 개인 데이터를 보호합니다.

보안

데이터 유출 및 도난, 부채널 공격(side-channel attacks) 및 크로스 사이트 스크립팅, 콘텐츠 주입 및 클릭 재킹과 같은 공격으로부터 사용자를 보호합니다.

웹 기술 참고서
웹 API

웹에서 앱을 만들기 위해 사용하는 JavaScript 프로그래밍 API입니다.

HTML

HTML은 웹 문서와 앱을 구조화하는데 필요한 기본적인 구성 요소를 제공합니다.

CSS

Cascading Style Sheets는 웹 문서와 앱의 외형을 만드는데 사용됩니다.

JavaScript

JavaScript는 웹의 기본 프로그래밍 언어입니다.

WebAssembly

WebAssembly는 C, C++, Rust, Swift, C#, Go 등으로 작성한 프로그램을 웹에서 구동할 수 있도록 합니다.

Events

이벤트는 웹 페이지 로드가 완료되거나 사용자가 무언가를 선택하거나 키를 누르거나 창 크기를 조정하거나 양식을 제출하거나 비디오를 일시 중지할 때 여러분이 만든 웹 앱이 반응해야하는 것 입니다.

HTTP

HTTP는 웹을 통해 문서, 스타일시트, 스크립트, 이미지, 비디오, 글꼴 및 기타 리소스를 가져오고 웹 서버로 다시 보내기 위한 기본적인 인터넷 프로토콜입니다.

Media

웹 문서 및 앱에 비디오, 오디오 및 이미지 콘텐츠를 내장하고 스트리밍하기 위한 형식, 코덱, 프로토콜, API 및 기술.

SVG

Scalable Vector Graphics(SVG)는 어떠한 크기로 확대해도 부드러운 이미지를 만들수 있습니다.

MathML

MathML은 복잡한 수학 표기법을 웹에 표시할 수 있습니다.

웹 컴포넌트

웹 컴포넌트는 개발자가 직접 정의하고 재사용할 수 있는 사용자 정의 요소입니다.

WebDriver

웹드라이버(WebDriver)는 브라우저를 사용하는 실제 사람의 행위를 모방하여 원격으로 브라우저를 제어하는 브라우저-자동화 메커니즘입니다. 웹 앱의 브라우저간 테스트를 위해 폭넓게 사용합니다.

Web Extensions

웹 확장 기능(Web Extensions)은 브라우저에서 사용자에게 향상된 기능을 제공합니다. 광고 및 기타 컨텐츠 차단, 페이지 모양 사용자 지정 등을 수행할 수 있습니다.

Web App Manifests

웹 앱 매니페스트(Web App Manifest)를 사용하면 사용자가 세로/가로 화면 방향과 디스플레이 모드(예: 전체 화면)를 미리 설정하여 장치의 홈 스크린에 웹 앱을 설치할 수 있습니다.

프로그레시브 웹 앱(PWAs)

프로그레시브 웹 앱(Progressive Web App)은 네이티브 모바일 앱과 유사한 사용자 경험을 제공합니다.

개발자 도구 문서
Firefox Developer Tools

Firefox에 내장된 웹 개발자 도구 집합에 대한 설명서입니다.

Chrome DevTools

Chrome에 내장된 웹 개발자 도구 집합에 대한 설명서입니다.

Safari Web Inspector

Safari에 내장된 웹 개발자 도구 집합에 대한 설명서입니다.

Edge DevTools

Edge에 내장된 웹 개발자 도구 집합에 대한 설명서입니다.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025년 1월 19일 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nTecnologia Web para desenvolvedoresA Web aberta apresenta oportunidades incríveis para os desenvolvedores. Para tirar o máximo proveito dessas tecnologias, você precisa saber como usá-las. Abaixo, você encontrará links para nossa documentação de tecnologias Web.Documentação para desenvolvedores Web
Guia para Desenvolvedores Web

O Guia para Desenvolvedores Web provê um conteúdo útil de informações, para realmente ajudá-lo a usar as tecnologias Web para fazer o que deseja ou precisa.

Tutoriais para Desenvolvedores Web

Uma lista de tutoriais para orientá-lo passo a passo no aprendizado de APIs, tecnologias ou áreas abrangentes dos tópicos.

Acessibilidade

Permitir que o maior número possível de pessoas use sites, mesmo quando as habilidades dessas pessoas são limitadas de alguma forma.

Performance

Tornar o conteúdo o mais disponível e interativo possível, o mais rápido possível.

Security

Protegendo os usuários contra vazamentos de dados e roubo de dados, ataques de canal lateral e ataques como scripts entre sites, injeção de conteúdo e click-jacking.

Referências para Tecnologias Web
APIs da Web

APIs de programação JavaScript que você pode usar para criar aplicativos na Web.

HTML

HTML fornece os blocos de construção fundamentais para estruturar documentos e aplicativos da Web.

CSS

Folhas de estilo em cascata são usadas para descrever a aparência de documentos e aplicativos da Web.

JavaScript

JavaScript é a linguagem de programação nativa da Web.

WebAssembly

O WebAssembly permite que programas escritos em C, C++, Rust, Swift, C#, Go e muito mais sejam executados na Web.

Eventos

Eventos são o que você cria aplicativos da Web para reagir; por exemplo, quando uma página da Web termina de carregar ou um usuário seleciona algo, pressiona uma tecla, redimensiona uma janela, envia um formulário ou pausa um vídeo.

HTTP

HTTP é o protocolo fundamental da Internet para buscar documentos, folhas de estilo, scripts, imagens, vídeos, fontes e outros recursos pela Web — e para enviar dados de volta aos servidores Web.

Mídia

Formatos, codecs, protocolos, APIs e técnicas para incorporar e transmitir conteúdo de vídeo, áudio e imagem em documentos e aplicativos da Web.

SVG

Gráficos vetoriais escaláveis permitem que você crie imagens que podem ser dimensionadas suavemente para qualquer tamanho.

MathML

MathML permite exibir notações matemáticas complexas na Web.

Componentes da Web

Componentes Web são elementos personalizados que você pode definir e reutilizar em seus aplicativos Web.

WebDriver

WebDriver é um mecanismo de automação de navegador para controlar remotamente um navegador emulando as ações de uma pessoa real usando o navegador. É amplamente usado para testes entre navegadores de aplicativos da Web.

Extensões da Web

Extensões da Web são uma maneira de você fornecer aos usuários recursos aprimorados em seus navegadores — para fazer coisas como bloquear anúncios e outros conteúdos, personalizar a aparência das páginas e muito mais.

Manifestos de aplicativos da Web

Manifestos de aplicativos da Web permitem que os usuários instalem aplicativos da Web nas telas iniciais de seus dispositivos, com aspectos como orientação de tela retrato/paisagem e modo de exibição (por exemplo, tela cheia) predefinidos.

Progressive Web Apps (PWAs)

Progressive Web Apps fornecem uma experiência de usuário semelhante a aplicativos móveis nativos.

Documentação das ferramentas do desenvolvedor
Ferramentas do desenvolvedor do Firefox

Documentação para o conjunto de ferramentas de desenvolvimento web incorporadas ao Firefox.

Chrome DevTools

Documentação para o conjunto de ferramentas de desenvolvedor da Web incorporadas ao Chrome.

Safari Web Inspector

Documentação para o conjunto de ferramentas de desenvolvedor da Web incorporadas ao Safari.

Edge DevTools

Documentação para o conjunto de ferramentas de desenvolvedor da Web incorporadas ao Edge.\n\nTecnologia Web para desenvolvedoresA Web aberta apresenta oportunidades incríveis para os desenvolvedores. Para tirar o máximo proveito dessas tecnologias, você precisa saber como usá-las. Abaixo, você encontrará links para nossa documentação de tecnologias Web.Documentação para desenvolvedores Web
Guia para Desenvolvedores Web

O Guia para Desenvolvedores Web provê um conteúdo útil de informações, para realmente ajudá-lo a usar as tecnologias Web para fazer o que deseja ou precisa.

Tutoriais para Desenvolvedores Web

Uma lista de tutoriais para orientá-lo passo a passo no aprendizado de APIs, tecnologias ou áreas abrangentes dos tópicos.

Acessibilidade

Permitir que o maior número possível de pessoas use sites, mesmo quando as habilidades dessas pessoas são limitadas de alguma forma.

Performance

Tornar o conteúdo o mais disponível e interativo possível, o mais rápido possível.

Security

Protegendo os usuários contra vazamentos de dados e roubo de dados, ataques de canal lateral e ataques como scripts entre sites, injeção de conteúdo e click-jacking.

Referências para Tecnologias Web
APIs da Web

APIs de programação JavaScript que você pode usar para criar aplicativos na Web.

HTML

HTML fornece os blocos de construção fundamentais para estruturar documentos e aplicativos da Web.

CSS

Folhas de estilo em cascata são usadas para descrever a aparência de documentos e aplicativos da Web.

JavaScript

JavaScript é a linguagem de programação nativa da Web.

WebAssembly

O WebAssembly permite que programas escritos em C, C++, Rust, Swift, C#, Go e muito mais sejam executados na Web.

Eventos

Eventos são o que você cria aplicativos da Web para reagir; por exemplo, quando uma página da Web termina de carregar ou um usuário seleciona algo, pressiona uma tecla, redimensiona uma janela, envia um formulário ou pausa um vídeo.

HTTP

HTTP é o protocolo fundamental da Internet para buscar documentos, folhas de estilo, scripts, imagens, vídeos, fontes e outros recursos pela Web — e para enviar dados de volta aos servidores Web.

Mídia

Formatos, codecs, protocolos, APIs e técnicas para incorporar e transmitir conteúdo de vídeo, áudio e imagem em documentos e aplicativos da Web.

SVG

Gráficos vetoriais escaláveis permitem que você crie imagens que podem ser dimensionadas suavemente para qualquer tamanho.

MathML

MathML permite exibir notações matemáticas complexas na Web.

Componentes da Web

Componentes Web são elementos personalizados que você pode definir e reutilizar em seus aplicativos Web.

WebDriver

WebDriver é um mecanismo de automação de navegador para controlar remotamente um navegador emulando as ações de uma pessoa real usando o navegador. É amplamente usado para testes entre navegadores de aplicativos da Web.

Extensões da Web

Extensões da Web são uma maneira de você fornecer aos usuários recursos aprimorados em seus navegadores — para fazer coisas como bloquear anúncios e outros conteúdos, personalizar a aparência das páginas e muito mais.

Manifestos de aplicativos da Web

Manifestos de aplicativos da Web permitem que os usuários instalem aplicativos da Web nas telas iniciais de seus dispositivos, com aspectos como orientação de tela retrato/paisagem e modo de exibição (por exemplo, tela cheia) predefinidos.

Progressive Web Apps (PWAs)

Progressive Web Apps fornecem uma experiência de usuário semelhante a aplicativos móveis nativos.

Documentação das ferramentas do desenvolvedor
Ferramentas do desenvolvedor do Firefox

Documentação para o conjunto de ferramentas de desenvolvimento web incorporadas ao Firefox.

Chrome DevTools

Documentação para o conjunto de ferramentas de desenvolvedor da Web incorporadas ao Chrome.

Safari Web Inspector

Documentação para o conjunto de ferramentas de desenvolvedor da Web incorporadas ao Safari.

Edge DevTools

Documentação para o conjunto de ferramentas de desenvolvedor da Web incorporadas ao Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 17 de dez. de 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nTecnologia Web para desenvolvedoresA Web aberta apresenta oportunidades incríveis para os desenvolvedores. Para tirar o máximo proveito dessas tecnologias, você precisa saber como usá-las. Abaixo, você encontrará links para nossa documentação de tecnologias Web.Documentação para desenvolvedores Web
Guia para Desenvolvedores Web

O Guia para Desenvolvedores Web provê um conteúdo útil de informações, para realmente ajudá-lo a usar as tecnologias Web para fazer o que deseja ou precisa.

Tutoriais para Desenvolvedores Web

Uma lista de tutoriais para orientá-lo passo a passo no aprendizado de APIs, tecnologias ou áreas abrangentes dos tópicos.

Acessibilidade

Permitir que o maior número possível de pessoas use sites, mesmo quando as habilidades dessas pessoas são limitadas de alguma forma.

Performance

Tornar o conteúdo o mais disponível e interativo possível, o mais rápido possível.

Security

Protegendo os usuários contra vazamentos de dados e roubo de dados, ataques de canal lateral e ataques como scripts entre sites, injeção de conteúdo e click-jacking.

Referências para Tecnologias Web
APIs da Web

APIs de programação JavaScript que você pode usar para criar aplicativos na Web.

HTML

HTML fornece os blocos de construção fundamentais para estruturar documentos e aplicativos da Web.

CSS

Folhas de estilo em cascata são usadas para descrever a aparência de documentos e aplicativos da Web.

JavaScript

JavaScript é a linguagem de programação nativa da Web.

WebAssembly

O WebAssembly permite que programas escritos em C, C++, Rust, Swift, C#, Go e muito mais sejam executados na Web.

Eventos

Eventos são o que você cria aplicativos da Web para reagir; por exemplo, quando uma página da Web termina de carregar ou um usuário seleciona algo, pressiona uma tecla, redimensiona uma janela, envia um formulário ou pausa um vídeo.

HTTP

HTTP é o protocolo fundamental da Internet para buscar documentos, folhas de estilo, scripts, imagens, vídeos, fontes e outros recursos pela Web — e para enviar dados de volta aos servidores Web.

Mídia

Formatos, codecs, protocolos, APIs e técnicas para incorporar e transmitir conteúdo de vídeo, áudio e imagem em documentos e aplicativos da Web.

SVG

Gráficos vetoriais escaláveis permitem que você crie imagens que podem ser dimensionadas suavemente para qualquer tamanho.

MathML

MathML permite exibir notações matemáticas complexas na Web.

Componentes da Web

Componentes Web são elementos personalizados que você pode definir e reutilizar em seus aplicativos Web.

WebDriver

WebDriver é um mecanismo de automação de navegador para controlar remotamente um navegador emulando as ações de uma pessoa real usando o navegador. É amplamente usado para testes entre navegadores de aplicativos da Web.

Extensões da Web

Extensões da Web são uma maneira de você fornecer aos usuários recursos aprimorados em seus navegadores — para fazer coisas como bloquear anúncios e outros conteúdos, personalizar a aparência das páginas e muito mais.

Manifestos de aplicativos da Web

Manifestos de aplicativos da Web permitem que os usuários instalem aplicativos da Web nas telas iniciais de seus dispositivos, com aspectos como orientação de tela retrato/paisagem e modo de exibição (por exemplo, tela cheia) predefinidos.

Progressive Web Apps (PWAs)

Progressive Web Apps fornecem uma experiência de usuário semelhante a aplicativos móveis nativos.

Documentação das ferramentas do desenvolvedor
Ferramentas do desenvolvedor do Firefox

Documentação para o conjunto de ferramentas de desenvolvimento web incorporadas ao Firefox.

Chrome DevTools

Documentação para o conjunto de ferramentas de desenvolvedor da Web incorporadas ao Chrome.

Safari Web Inspector

Documentação para o conjunto de ferramentas de desenvolvedor da Web incorporadas ao Safari.

Edge DevTools

Documentação para o conjunto de ferramentas de desenvolvedor da Web incorporadas ao Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 17 de dez. de 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nВеб-технологии для разработчиковСовременные веб-технологии предоставляют разработчикам неограниченные возможности для реализации своих идей. Для того, чтобы вы могли использовать весь их потенциал, необходимо знать как правильно их использовать. На этой странице мы постарались собрать ссылки на документацию по различным технологиям, которые могут быть вам полезны.Веб-технологииОсновы веб разработки
HTML

Язык гипертекстовой разметки — это язык, используемый для определения структуры и описания содержания веб-страницы в структурированной форме.

CSS

Каскадные таблицы стилей используются для описания внешнего вида веб-контента.

HTTP

HyperText Transfer Protocol (HTTP) — это протокол, по которому доставляются HTML и прочие медиа-документы.

Написание сценариев
JavaScript

JavaScript — язык программирования, широко используемый для реализации взаимодействия пользователя с веб-сайтами и приложениями.

Веб API

Данный раздел включает справочные материалы по каждому из отдельно взятых API, содержащих огромные возможности для создания веб-сценариев, включая DOM и все связанные с ним API, которые вы можете использовать для построения веб-контента и приложений.

Справочник по веб API содержит все интерфейсы в алфавитном порядке.
WebAPI — данная страница содержит перечень API для взаимодействия с устройствами и другие API не менее полезные для приложений.
Справка по событиям содержит список событий, которые возникают на веб-странице или в веб-приложении.


Веб Компоненты

Веб Компоненты - это набор различных технологий, позволяющих создавать собственные переиспользуемые элементы - со своей функциональностью, инкапсулированной от остального кода - и использовать их в ваших веб-приложениях.

Графика
Canvas

<canvas> элемент предоставляет API для рисования 2D-графики, с использованием JavaScript.

SVG

SVG (Scalable Vector Graphics - масштабируемая векторная графика) - позволяет вам описать изображение в виде линий, кривых и других геометрических фигур. Благодаря этому можно масштабировать рисунок без потери качества.

WebGL

WebGL - это JavaScript API, позволяющее рисовать 3D или 2D изображения используя HTML-элемент <canvas>. Эта технология позволяет использовать стандарт OpenGL ES в Web-содержимом.

Аудио, видео и мультимедиа
Web медиа-технологии

Список связанного с медиа API, со ссылками на документацию для каждого из них.

Media capture and streams API

Справочник для API, используемого для потоковой передачи, записи и управления данным как локально, так и по сети. Также включает в себя инструменты для использования локальных камер и микрофонов для захвата видео, аудио и статичных изображений.

Использование HTML аудио и видео

Включение видео и\или аудио в веб-страницу и управление их воспроизведением.

WebRTC

RTC в WebRTC означает Real-Time Communications (связь в реальном времени) - технологию, обеспечивающую поток аудио или видео и обмен данным между одноранговыми клиентами браузера.

Прочее
MathML

Математический язык разметки предоставляет возможность показа комплексных математических уравнений и синтаксиса.

XSLT

Extensible Stylesheet Language Transformations (XSLT) позволяет преобразовать XML-документ в человекочитаемый HTML.

EXSLT

Функциональное расширение, которое предоставляет дополнительные возможности для XSLT.

XPath

XPath позволяет вам выбрать DOM-узел в документе, используя более мощный синтаксис, чем предоставляется обычными CSS selectors.

Документация по типам
Руководство веб-разработчика

Руководство веб-разработчика предоставляет полезные пошаговые материалы, которые помогут вам в полной мере использовать веб-технологии для выполнения ваших задач и реализации ваших идей.

Учебные материалы для веб-разработчиков

Перечень учебных материалов позволит вам пошагово изучить API, технологии и расширить свой кругозор в области веб-технологий.

Справочные материалы

На данной странице будут представлены ссылки на всю справочную информацию, имеющуюся в MDN; а пока можно использовать ссылки на веб-технологии из левой части данной страницы.

Прочие разделы
Центр приложений

Содержит документацию для разработчиков веб-приложений. При помощи данных материалов можно научиться создавать приложения для мобильных устройств, персональных компьютеров и Firefox OS.

Общедоступность

Общедоступность (доступность, accessibility) в веб-разработке означает предоставление возможности использования веб-сайтов максимально возможному числу людей, даже если эти люди имеют некоторые физиологические ограничения. Этот раздел содержит информацию о разработке наиболее доступного веб-контента для таких людей.

Безопасность

Этот раздел уделяет внимание вопросам безопасности веб-сайтов и веб-приложений.\n\nВеб-технологии для разработчиковСовременные веб-технологии предоставляют разработчикам неограниченные возможности для реализации своих идей. Для того, чтобы вы могли использовать весь их потенциал, необходимо знать как правильно их использовать. На этой странице мы постарались собрать ссылки на документацию по различным технологиям, которые могут быть вам полезны.Веб-технологииОсновы веб разработки
HTML

Язык гипертекстовой разметки — это язык, используемый для определения структуры и описания содержания веб-страницы в структурированной форме.

CSS

Каскадные таблицы стилей используются для описания внешнего вида веб-контента.

HTTP

HyperText Transfer Protocol (HTTP) — это протокол, по которому доставляются HTML и прочие медиа-документы.

Написание сценариев
JavaScript

JavaScript — язык программирования, широко используемый для реализации взаимодействия пользователя с веб-сайтами и приложениями.

Веб API

Данный раздел включает справочные материалы по каждому из отдельно взятых API, содержащих огромные возможности для создания веб-сценариев, включая DOM и все связанные с ним API, которые вы можете использовать для построения веб-контента и приложений.

Справочник по веб API содержит все интерфейсы в алфавитном порядке.
WebAPI — данная страница содержит перечень API для взаимодействия с устройствами и другие API не менее полезные для приложений.
Справка по событиям содержит список событий, которые возникают на веб-странице или в веб-приложении.


Веб Компоненты

Веб Компоненты - это набор различных технологий, позволяющих создавать собственные переиспользуемые элементы - со своей функциональностью, инкапсулированной от остального кода - и использовать их в ваших веб-приложениях.

Графика
Canvas

<canvas> элемент предоставляет API для рисования 2D-графики, с использованием JavaScript.

SVG

SVG (Scalable Vector Graphics - масштабируемая векторная графика) - позволяет вам описать изображение в виде линий, кривых и других геометрических фигур. Благодаря этому можно масштабировать рисунок без потери качества.

WebGL

WebGL - это JavaScript API, позволяющее рисовать 3D или 2D изображения используя HTML-элемент <canvas>. Эта технология позволяет использовать стандарт OpenGL ES в Web-содержимом.

Аудио, видео и мультимедиа
Web медиа-технологии

Список связанного с медиа API, со ссылками на документацию для каждого из них.

Media capture and streams API

Справочник для API, используемого для потоковой передачи, записи и управления данным как локально, так и по сети. Также включает в себя инструменты для использования локальных камер и микрофонов для захвата видео, аудио и статичных изображений.

Использование HTML аудио и видео

Включение видео и\или аудио в веб-страницу и управление их воспроизведением.

WebRTC

RTC в WebRTC означает Real-Time Communications (связь в реальном времени) - технологию, обеспечивающую поток аудио или видео и обмен данным между одноранговыми клиентами браузера.

Прочее
MathML

Математический язык разметки предоставляет возможность показа комплексных математических уравнений и синтаксиса.

XSLT

Extensible Stylesheet Language Transformations (XSLT) позволяет преобразовать XML-документ в человекочитаемый HTML.

EXSLT

Функциональное расширение, которое предоставляет дополнительные возможности для XSLT.

XPath

XPath позволяет вам выбрать DOM-узел в документе, используя более мощный синтаксис, чем предоставляется обычными CSS selectors.

Документация по типам
Руководство веб-разработчика

Руководство веб-разработчика предоставляет полезные пошаговые материалы, которые помогут вам в полной мере использовать веб-технологии для выполнения ваших задач и реализации ваших идей.

Учебные материалы для веб-разработчиков

Перечень учебных материалов позволит вам пошагово изучить API, технологии и расширить свой кругозор в области веб-технологий.

Справочные материалы

На данной странице будут представлены ссылки на всю справочную информацию, имеющуюся в MDN; а пока можно использовать ссылки на веб-технологии из левой части данной страницы.

Прочие разделы
Центр приложений

Содержит документацию для разработчиков веб-приложений. При помощи данных материалов можно научиться создавать приложения для мобильных устройств, персональных компьютеров и Firefox OS.

Общедоступность

Общедоступность (доступность, accessibility) в веб-разработке означает предоставление возможности использования веб-сайтов максимально возможному числу людей, даже если эти люди имеют некоторые физиологические ограничения. Этот раздел содержит информацию о разработке наиболее доступного веб-контента для таких людей.

Безопасность

Этот раздел уделяет внимание вопросам безопасности веб-сайтов и веб-приложений.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 24 мар. 2025 г. by MDN contributors.View this page on GitHub • Report a problem with this content\n\nВеб-технологии для разработчиковСовременные веб-технологии предоставляют разработчикам неограниченные возможности для реализации своих идей. Для того, чтобы вы могли использовать весь их потенциал, необходимо знать как правильно их использовать. На этой странице мы постарались собрать ссылки на документацию по различным технологиям, которые могут быть вам полезны.Веб-технологииОсновы веб разработки
HTML

Язык гипертекстовой разметки — это язык, используемый для определения структуры и описания содержания веб-страницы в структурированной форме.

CSS

Каскадные таблицы стилей используются для описания внешнего вида веб-контента.

HTTP

HyperText Transfer Protocol (HTTP) — это протокол, по которому доставляются HTML и прочие медиа-документы.

Написание сценариев
JavaScript

JavaScript — язык программирования, широко используемый для реализации взаимодействия пользователя с веб-сайтами и приложениями.

Веб API

Данный раздел включает справочные материалы по каждому из отдельно взятых API, содержащих огромные возможности для создания веб-сценариев, включая DOM и все связанные с ним API, которые вы можете использовать для построения веб-контента и приложений.

Справочник по веб API содержит все интерфейсы в алфавитном порядке.
WebAPI — данная страница содержит перечень API для взаимодействия с устройствами и другие API не менее полезные для приложений.
Справка по событиям содержит список событий, которые возникают на веб-странице или в веб-приложении.


Веб Компоненты

Веб Компоненты - это набор различных технологий, позволяющих создавать собственные переиспользуемые элементы - со своей функциональностью, инкапсулированной от остального кода - и использовать их в ваших веб-приложениях.

Графика
Canvas

<canvas> элемент предоставляет API для рисования 2D-графики, с использованием JavaScript.

SVG

SVG (Scalable Vector Graphics - масштабируемая векторная графика) - позволяет вам описать изображение в виде линий, кривых и других геометрических фигур. Благодаря этому можно масштабировать рисунок без потери качества.

WebGL

WebGL - это JavaScript API, позволяющее рисовать 3D или 2D изображения используя HTML-элемент <canvas>. Эта технология позволяет использовать стандарт OpenGL ES в Web-содержимом.

Аудио, видео и мультимедиа
Web медиа-технологии

Список связанного с медиа API, со ссылками на документацию для каждого из них.

Media capture and streams API

Справочник для API, используемого для потоковой передачи, записи и управления данным как локально, так и по сети. Также включает в себя инструменты для использования локальных камер и микрофонов для захвата видео, аудио и статичных изображений.

Использование HTML аудио и видео

Включение видео и\или аудио в веб-страницу и управление их воспроизведением.

WebRTC

RTC в WebRTC означает Real-Time Communications (связь в реальном времени) - технологию, обеспечивающую поток аудио или видео и обмен данным между одноранговыми клиентами браузера.

Прочее
MathML

Математический язык разметки предоставляет возможность показа комплексных математических уравнений и синтаксиса.

XSLT

Extensible Stylesheet Language Transformations (XSLT) позволяет преобразовать XML-документ в человекочитаемый HTML.

EXSLT

Функциональное расширение, которое предоставляет дополнительные возможности для XSLT.

XPath

XPath позволяет вам выбрать DOM-узел в документе, используя более мощный синтаксис, чем предоставляется обычными CSS selectors.

Документация по типам
Руководство веб-разработчика

Руководство веб-разработчика предоставляет полезные пошаговые материалы, которые помогут вам в полной мере использовать веб-технологии для выполнения ваших задач и реализации ваших идей.

Учебные материалы для веб-разработчиков

Перечень учебных материалов позволит вам пошагово изучить API, технологии и расширить свой кругозор в области веб-технологий.

Справочные материалы

На данной странице будут представлены ссылки на всю справочную информацию, имеющуюся в MDN; а пока можно использовать ссылки на веб-технологии из левой части данной страницы.

Прочие разделы
Центр приложений

Содержит документацию для разработчиков веб-приложений. При помощи данных материалов можно научиться создавать приложения для мобильных устройств, персональных компьютеров и Firefox OS.

Общедоступность

Общедоступность (доступность, accessibility) в веб-разработке означает предоставление возможности использования веб-сайтов максимально возможному числу людей, даже если эти люди имеют некоторые физиологические ограничения. Этот раздел содержит информацию о разработке наиболее доступного веб-контента для таких людей.

Безопасность

Этот раздел уделяет внимание вопросам безопасности веб-сайтов и веб-приложений.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 24 мар. 2025 г. by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\n面向开发者的 Web 技术开放的 Web 为开发者提供了巨大的机遇，为了充分利用这些技术，你需要知道如何使用它们。在下方你可以找到这些 Web 技术文档的链接。面向 Web 开发者的文档
Web 开发者指南

Web 开发者指南提供了实用的操作方法内容，帮助你使用 Web 技术实现你的目标或需求。

面向 Web 开发者的教程

这些教程会带着你一步一步地学习 HTML、CSS、JavaScript 和 Web API。

无障碍

让更多人能够使用你的网站，即使他们的某些能力受限。

性能

让网站上的内容尽可能快地变得可用和可交互。

隐私

保护用户的个人数据。

安全

保护用户免受数据泄露和数据盗窃、侧信道攻击，以及跨站脚本、内容注入和点击劫持等攻击。

术语表

Web 相关术语的定义。

Web 技术参考
Web API

用 JavaScript 编程 API 构建 Web 应用。

HTML

用 HTML 的基本构建块创建 Web 文档和应用。

CSS

用层叠样式表描述 Web 文档和应用的外观。

JavaScript

JavaScript 是 Web 的原生编程语言。

WebAssembly

用 WebAssembly 在 Web 上运行使用 C、C++、Rust、Swift、C#、Go 等语言编写的程序。

事件

Web 应用中，可响应的内容称作事件；例如，当一个网页完成加载，或者用户选择什么、按下一个键、调整一个窗口的大小、提交一个表单或暂停一个视频。

HTTP

HTTP 是通过 Web 来获取文档、样式表、脚本、图像、视频、字体和其他资源——并将数据发送回 Web 服务器的基础互联网协议。

媒体

用于在 Web 文档和应用中嵌入和流式传输视频、音频和图像内容的格式、编解码器、协议、API 和技术。

SVG

可缩放矢量图形用于创建可平滑地缩放至任意尺寸的图像。

MathML

通过 MathML 能在 Web 上显示复杂的数学符号。

URI

统一资源标识符被各种技术使用，包括浏览器自身通过地址栏，以各种方式标识资源。

WebDriver

WebDriver 是一种浏览器自动化机制，可通过模拟真人使用浏览器的操作远程控制浏览器。被广泛应用于 Web 应用的跨浏览器测试。

Web 扩展

Web 扩展是一种在浏览器中为用户提供增强功能的方式——用于阻止广告和其他内容、定制页面的外观以及更多行为。

Web 应用清单

Web 应用清单能让用户将 Web 应用安装到其设备主屏幕上，并预先设置好屏幕方向（纵向或横向）和显示模式（如全屏）等内容。

渐进式 Web 应用（PWA）

渐进式 Web 应用能提供类似原生移动应用的用户体验。

OpenSearch

OpenSearch 允许网站描述自身的搜索引擎，以便浏览器或客户端应用程序能使用该搜索引擎。

XML

可扩展标记语言是可由文档对象模型严格序列化的一种语言。

XSLT

可扩展样式表语言转换是一种基于 XML 的语言，和专门的处理软件一起使用，用于 XML 文档转换。

XPath

XPath 使用非 XML 语法来提供一种灵活地定位（指向）XML 文档的不同部分的方法。它也可以用于检查文档中某个定位节点是否与某个模式匹配。

EXSLT

EXSLT 是一组 XSLT 的扩展。

开发者工具文档
Firefox 开发者工具

Firefox 内置的 Web 开发者工具的文档。

Chrome 开发者工具

Chrome 内置的 Web 开发者工具的文档。

Safari Web 监视器

Safari 内置的 Web 开发者工具的文档。

Edge 开发者工具

Edge 内置的 Web 开发者工具的文档。\n\n面向开发者的 Web 技术开放的 Web 为开发者提供了巨大的机遇，为了充分利用这些技术，你需要知道如何使用它们。在下方你可以找到这些 Web 技术文档的链接。面向 Web 开发者的文档
Web 开发者指南

Web 开发者指南提供了实用的操作方法内容，帮助你使用 Web 技术实现你的目标或需求。

面向 Web 开发者的教程

这些教程会带着你一步一步地学习 HTML、CSS、JavaScript 和 Web API。

无障碍

让更多人能够使用你的网站，即使他们的某些能力受限。

性能

让网站上的内容尽可能快地变得可用和可交互。

隐私

保护用户的个人数据。

安全

保护用户免受数据泄露和数据盗窃、侧信道攻击，以及跨站脚本、内容注入和点击劫持等攻击。

术语表

Web 相关术语的定义。

Web 技术参考
Web API

用 JavaScript 编程 API 构建 Web 应用。

HTML

用 HTML 的基本构建块创建 Web 文档和应用。

CSS

用层叠样式表描述 Web 文档和应用的外观。

JavaScript

JavaScript 是 Web 的原生编程语言。

WebAssembly

用 WebAssembly 在 Web 上运行使用 C、C++、Rust、Swift、C#、Go 等语言编写的程序。

事件

Web 应用中，可响应的内容称作事件；例如，当一个网页完成加载，或者用户选择什么、按下一个键、调整一个窗口的大小、提交一个表单或暂停一个视频。

HTTP

HTTP 是通过 Web 来获取文档、样式表、脚本、图像、视频、字体和其他资源——并将数据发送回 Web 服务器的基础互联网协议。

媒体

用于在 Web 文档和应用中嵌入和流式传输视频、音频和图像内容的格式、编解码器、协议、API 和技术。

SVG

可缩放矢量图形用于创建可平滑地缩放至任意尺寸的图像。

MathML

通过 MathML 能在 Web 上显示复杂的数学符号。

URI

统一资源标识符被各种技术使用，包括浏览器自身通过地址栏，以各种方式标识资源。

WebDriver

WebDriver 是一种浏览器自动化机制，可通过模拟真人使用浏览器的操作远程控制浏览器。被广泛应用于 Web 应用的跨浏览器测试。

Web 扩展

Web 扩展是一种在浏览器中为用户提供增强功能的方式——用于阻止广告和其他内容、定制页面的外观以及更多行为。

Web 应用清单

Web 应用清单能让用户将 Web 应用安装到其设备主屏幕上，并预先设置好屏幕方向（纵向或横向）和显示模式（如全屏）等内容。

渐进式 Web 应用（PWA）

渐进式 Web 应用能提供类似原生移动应用的用户体验。

OpenSearch

OpenSearch 允许网站描述自身的搜索引擎，以便浏览器或客户端应用程序能使用该搜索引擎。

XML

可扩展标记语言是可由文档对象模型严格序列化的一种语言。

XSLT

可扩展样式表语言转换是一种基于 XML 的语言，和专门的处理软件一起使用，用于 XML 文档转换。

XPath

XPath 使用非 XML 语法来提供一种灵活地定位（指向）XML 文档的不同部分的方法。它也可以用于检查文档中某个定位节点是否与某个模式匹配。

EXSLT

EXSLT 是一组 XSLT 的扩展。

开发者工具文档
Firefox 开发者工具

Firefox 内置的 Web 开发者工具的文档。

Chrome 开发者工具

Chrome 内置的 Web 开发者工具的文档。

Safari Web 监视器

Safari 内置的 Web 开发者工具的文档。

Edge 开发者工具

Edge 内置的 Web 开发者工具的文档。

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025年3月12日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n面向开发者的 Web 技术开放的 Web 为开发者提供了巨大的机遇，为了充分利用这些技术，你需要知道如何使用它们。在下方你可以找到这些 Web 技术文档的链接。面向 Web 开发者的文档
Web 开发者指南

Web 开发者指南提供了实用的操作方法内容，帮助你使用 Web 技术实现你的目标或需求。

面向 Web 开发者的教程

这些教程会带着你一步一步地学习 HTML、CSS、JavaScript 和 Web API。

无障碍

让更多人能够使用你的网站，即使他们的某些能力受限。

性能

让网站上的内容尽可能快地变得可用和可交互。

隐私

保护用户的个人数据。

安全

保护用户免受数据泄露和数据盗窃、侧信道攻击，以及跨站脚本、内容注入和点击劫持等攻击。

术语表

Web 相关术语的定义。

Web 技术参考
Web API

用 JavaScript 编程 API 构建 Web 应用。

HTML

用 HTML 的基本构建块创建 Web 文档和应用。

CSS

用层叠样式表描述 Web 文档和应用的外观。

JavaScript

JavaScript 是 Web 的原生编程语言。

WebAssembly

用 WebAssembly 在 Web 上运行使用 C、C++、Rust、Swift、C#、Go 等语言编写的程序。

事件

Web 应用中，可响应的内容称作事件；例如，当一个网页完成加载，或者用户选择什么、按下一个键、调整一个窗口的大小、提交一个表单或暂停一个视频。

HTTP

HTTP 是通过 Web 来获取文档、样式表、脚本、图像、视频、字体和其他资源——并将数据发送回 Web 服务器的基础互联网协议。

媒体

用于在 Web 文档和应用中嵌入和流式传输视频、音频和图像内容的格式、编解码器、协议、API 和技术。

SVG

可缩放矢量图形用于创建可平滑地缩放至任意尺寸的图像。

MathML

通过 MathML 能在 Web 上显示复杂的数学符号。

URI

统一资源标识符被各种技术使用，包括浏览器自身通过地址栏，以各种方式标识资源。

WebDriver

WebDriver 是一种浏览器自动化机制，可通过模拟真人使用浏览器的操作远程控制浏览器。被广泛应用于 Web 应用的跨浏览器测试。

Web 扩展

Web 扩展是一种在浏览器中为用户提供增强功能的方式——用于阻止广告和其他内容、定制页面的外观以及更多行为。

Web 应用清单

Web 应用清单能让用户将 Web 应用安装到其设备主屏幕上，并预先设置好屏幕方向（纵向或横向）和显示模式（如全屏）等内容。

渐进式 Web 应用（PWA）

渐进式 Web 应用能提供类似原生移动应用的用户体验。

OpenSearch

OpenSearch 允许网站描述自身的搜索引擎，以便浏览器或客户端应用程序能使用该搜索引擎。

XML

可扩展标记语言是可由文档对象模型严格序列化的一种语言。

XSLT

可扩展样式表语言转换是一种基于 XML 的语言，和专门的处理软件一起使用，用于 XML 文档转换。

XPath

XPath 使用非 XML 语法来提供一种灵活地定位（指向）XML 文档的不同部分的方法。它也可以用于检查文档中某个定位节点是否与某个模式匹配。

EXSLT

EXSLT 是一组 XSLT 的扩展。

开发者工具文档
Firefox 开发者工具

Firefox 内置的 Web 开发者工具的文档。

Chrome 开发者工具

Chrome 内置的 Web 开发者工具的文档。

Safari Web 监视器

Safari 内置的 Web 开发者工具的文档。

Edge 开发者工具

Edge 内置的 Web 开发者工具的文档。

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025年3月12日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\n給開發者的 Web 技術文件全球資訊網的開放性提供了開發人員非常棒的機會。要充分發揮 Web 潛能，你需要知道如何使用它們。你可以從以下連結找到各種 Web 技術說明。Web 開發者說明文件
Web 開發者指南

提供實用教學，幫助你實際使用 Web 技術來做你想做或需要做的事情。

Web 開發者入門

帶你逐步學習 HTML、CSS、JavaScript 和 Web API。

無障礙

盡可能地使所有人皆能使用你的網站，不論他們是否具有能力障礙。

效能

使內容完全發揮可用性和互動性，並且越快越好。

隱私

保護使用者的個人資料。

安全性

保護使用者免受資料外洩和盜取、旁路攻擊，以及跨網站指令碼、內容注入和點擊劫持等攻擊。

術語表

Web 相關術語的定義。

Web 技術參考
Web API

用於開發 Web 應用程式的 JavaScript API。

HTML

HTML 提供用於構建 Web 文件和應用程式的基本結構。

CSS

階層式樣式表用於描述　Web 文件和應用程式的外觀。

JavaScript

JavaScript 是 Web 的原生程式語言。

WebAssembly

WebAssembly 能夠讓以 C、C++、Rust、Swift、C#、Go 等語言開發的程式在 Web 上執行。

事件

你的 Web 應用程式能夠對事件做出反應；例如當 Web 完成載入，或使用者選擇某些內容、按下按鍵、調整視窗大小、提交表單、暫停影片等。

HTTP

超文字傳輸協定（Hypertext Transfer Protocol）是基本的網際網路協定，用於從網路上取得檔案、樣式表、程式碼、圖片、影片、字型，以及其他資源——以及將資料傳回伺服器。

媒體

用於在 Web 檔案和應用程式中嵌入和串流視訊、音訊和圖片內容的格式、轉碼器、協定、API 和技術。

SVG

可縮放向量圖形（Scalable Vector Graphic）使你能夠建立任何大小皆能平滑縮放的圖片。

MathML

數學標記語言（Mathematical Markup Language）使 Web 得以展示複雜的數學運算式及語法。

URI

統一資源識別碼（URI）被各種技術使用，包括瀏覽器本身透過地址欄來以各種方式識別資源。

WebDriver

WebDriver 是一種透過模擬真人使用瀏覽器的操作來遠端控制瀏覽器的自動化機制。被廣泛用於 Web 應用程式的跨瀏覽器測試。

Web 擴充功能

Web 擴充功能是一種讓你在瀏覽器中為使用者提供增強功能的方式，例如阻擋廣告和其他內容、自訂頁面外觀等。

Web 應用程式資訊清單

Web 應用程式資訊清單（Web App Manifest）讓使用者能夠將 Web 應用程式安裝到他們的裝置主畫面上，並預先設定畫面方向（直向或橫向）和顯示模式（如全螢幕）等。

漸進式 Web 應用程式

漸進式 Web 應用程式（Progressive Web App）提供使用者近似原生行動應用程式的體驗。

OpenSearch

OpenSearch 允許網站為自身描述一個搜尋引擎，以便瀏覽器或其他用戶端應用程式可以使用該搜尋引擎。

XML

可擴展標記語言是一種嚴格的文件物件模型序列化格式。

XSLT

可延伸樣式表轉換語言是一種基於 XML 的語言，與專門的處理軟體結合使用，用於轉換 XML 文件。

XPath

XPath 使用非 XML 語法提供一種靈活的方式來定位（指向）XML 文件的不同部分。它還可以用於測試文件中的定位節點是否符合某個模式。

EXSLT

EXSLT 是 XSLT 的一組擴展。

開發者工具說明文件
Firefox 開發者工具

Firefox 內建的 Web 開發者工具的說明文件。

Chrome 開發者工具

Chrome 內建的 Web 開發者工具的說明文件。

Safari Web 檢閱器

Safari 內建的 Web 開發者工具的說明文件。

Edge 開發者工具

Edge 內建的 Web 開發者工具的說明文件。\n\n給開發者的 Web 技術文件全球資訊網的開放性提供了開發人員非常棒的機會。要充分發揮 Web 潛能，你需要知道如何使用它們。你可以從以下連結找到各種 Web 技術說明。Web 開發者說明文件
Web 開發者指南

提供實用教學，幫助你實際使用 Web 技術來做你想做或需要做的事情。

Web 開發者入門

帶你逐步學習 HTML、CSS、JavaScript 和 Web API。

無障礙

盡可能地使所有人皆能使用你的網站，不論他們是否具有能力障礙。

效能

使內容完全發揮可用性和互動性，並且越快越好。

隱私

保護使用者的個人資料。

安全性

保護使用者免受資料外洩和盜取、旁路攻擊，以及跨網站指令碼、內容注入和點擊劫持等攻擊。

術語表

Web 相關術語的定義。

Web 技術參考
Web API

用於開發 Web 應用程式的 JavaScript API。

HTML

HTML 提供用於構建 Web 文件和應用程式的基本結構。

CSS

階層式樣式表用於描述　Web 文件和應用程式的外觀。

JavaScript

JavaScript 是 Web 的原生程式語言。

WebAssembly

WebAssembly 能夠讓以 C、C++、Rust、Swift、C#、Go 等語言開發的程式在 Web 上執行。

事件

你的 Web 應用程式能夠對事件做出反應；例如當 Web 完成載入，或使用者選擇某些內容、按下按鍵、調整視窗大小、提交表單、暫停影片等。

HTTP

超文字傳輸協定（Hypertext Transfer Protocol）是基本的網際網路協定，用於從網路上取得檔案、樣式表、程式碼、圖片、影片、字型，以及其他資源——以及將資料傳回伺服器。

媒體

用於在 Web 檔案和應用程式中嵌入和串流視訊、音訊和圖片內容的格式、轉碼器、協定、API 和技術。

SVG

可縮放向量圖形（Scalable Vector Graphic）使你能夠建立任何大小皆能平滑縮放的圖片。

MathML

數學標記語言（Mathematical Markup Language）使 Web 得以展示複雜的數學運算式及語法。

URI

統一資源識別碼（URI）被各種技術使用，包括瀏覽器本身透過地址欄來以各種方式識別資源。

WebDriver

WebDriver 是一種透過模擬真人使用瀏覽器的操作來遠端控制瀏覽器的自動化機制。被廣泛用於 Web 應用程式的跨瀏覽器測試。

Web 擴充功能

Web 擴充功能是一種讓你在瀏覽器中為使用者提供增強功能的方式，例如阻擋廣告和其他內容、自訂頁面外觀等。

Web 應用程式資訊清單

Web 應用程式資訊清單（Web App Manifest）讓使用者能夠將 Web 應用程式安裝到他們的裝置主畫面上，並預先設定畫面方向（直向或橫向）和顯示模式（如全螢幕）等。

漸進式 Web 應用程式

漸進式 Web 應用程式（Progressive Web App）提供使用者近似原生行動應用程式的體驗。

OpenSearch

OpenSearch 允許網站為自身描述一個搜尋引擎，以便瀏覽器或其他用戶端應用程式可以使用該搜尋引擎。

XML

可擴展標記語言是一種嚴格的文件物件模型序列化格式。

XSLT

可延伸樣式表轉換語言是一種基於 XML 的語言，與專門的處理軟體結合使用，用於轉換 XML 文件。

XPath

XPath 使用非 XML 語法提供一種靈活的方式來定位（指向）XML 文件的不同部分。它還可以用於測試文件中的定位節點是否符合某個模式。

EXSLT

EXSLT 是 XSLT 的一組擴展。

開發者工具說明文件
Firefox 開發者工具

Firefox 內建的 Web 開發者工具的說明文件。

Chrome 開發者工具

Chrome 內建的 Web 開發者工具的說明文件。

Safari Web 檢閱器

Safari 內建的 Web 開發者工具的說明文件。

Edge 開發者工具

Edge 內建的 Web 開發者工具的說明文件。

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025年3月21日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n給開發者的 Web 技術文件全球資訊網的開放性提供了開發人員非常棒的機會。要充分發揮 Web 潛能，你需要知道如何使用它們。你可以從以下連結找到各種 Web 技術說明。Web 開發者說明文件
Web 開發者指南

提供實用教學，幫助你實際使用 Web 技術來做你想做或需要做的事情。

Web 開發者入門

帶你逐步學習 HTML、CSS、JavaScript 和 Web API。

無障礙

盡可能地使所有人皆能使用你的網站，不論他們是否具有能力障礙。

效能

使內容完全發揮可用性和互動性，並且越快越好。

隱私

保護使用者的個人資料。

安全性

保護使用者免受資料外洩和盜取、旁路攻擊，以及跨網站指令碼、內容注入和點擊劫持等攻擊。

術語表

Web 相關術語的定義。

Web 技術參考
Web API

用於開發 Web 應用程式的 JavaScript API。

HTML

HTML 提供用於構建 Web 文件和應用程式的基本結構。

CSS

階層式樣式表用於描述　Web 文件和應用程式的外觀。

JavaScript

JavaScript 是 Web 的原生程式語言。

WebAssembly

WebAssembly 能夠讓以 C、C++、Rust、Swift、C#、Go 等語言開發的程式在 Web 上執行。

事件

你的 Web 應用程式能夠對事件做出反應；例如當 Web 完成載入，或使用者選擇某些內容、按下按鍵、調整視窗大小、提交表單、暫停影片等。

HTTP

超文字傳輸協定（Hypertext Transfer Protocol）是基本的網際網路協定，用於從網路上取得檔案、樣式表、程式碼、圖片、影片、字型，以及其他資源——以及將資料傳回伺服器。

媒體

用於在 Web 檔案和應用程式中嵌入和串流視訊、音訊和圖片內容的格式、轉碼器、協定、API 和技術。

SVG

可縮放向量圖形（Scalable Vector Graphic）使你能夠建立任何大小皆能平滑縮放的圖片。

MathML

數學標記語言（Mathematical Markup Language）使 Web 得以展示複雜的數學運算式及語法。

URI

統一資源識別碼（URI）被各種技術使用，包括瀏覽器本身透過地址欄來以各種方式識別資源。

WebDriver

WebDriver 是一種透過模擬真人使用瀏覽器的操作來遠端控制瀏覽器的自動化機制。被廣泛用於 Web 應用程式的跨瀏覽器測試。

Web 擴充功能

Web 擴充功能是一種讓你在瀏覽器中為使用者提供增強功能的方式，例如阻擋廣告和其他內容、自訂頁面外觀等。

Web 應用程式資訊清單

Web 應用程式資訊清單（Web App Manifest）讓使用者能夠將 Web 應用程式安裝到他們的裝置主畫面上，並預先設定畫面方向（直向或橫向）和顯示模式（如全螢幕）等。

漸進式 Web 應用程式

漸進式 Web 應用程式（Progressive Web App）提供使用者近似原生行動應用程式的體驗。

OpenSearch

OpenSearch 允許網站為自身描述一個搜尋引擎，以便瀏覽器或其他用戶端應用程式可以使用該搜尋引擎。

XML

可擴展標記語言是一種嚴格的文件物件模型序列化格式。

XSLT

可延伸樣式表轉換語言是一種基於 XML 的語言，與專門的處理軟體結合使用，用於轉換 XML 文件。

XPath

XPath 使用非 XML 語法提供一種靈活的方式來定位（指向）XML 文件的不同部分。它還可以用於測試文件中的定位節點是否符合某個模式。

EXSLT

EXSLT 是 XSLT 的一組擴展。

開發者工具說明文件
Firefox 開發者工具

Firefox 內建的 Web 開發者工具的說明文件。

Chrome 開發者工具

Chrome 內建的 Web 開發者工具的說明文件。

Safari Web 檢閱器

Safari 內建的 Web 開發者工具的說明文件。

Edge 開發者工具

Edge 內建的 Web 開發者工具的說明文件。

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025年3月21日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nEvent referenceEvents are fired to notify code of "interesting changes" that may affect code execution. These can arise from user interactions such as using a mouse or resizing a window, changes in the state of the underlying environment (e.g., low battery or media events from the operating system), and other causes.
Each event is represented by an object that is based on the Event interface, and may have additional custom fields and/or functions to provide information about what happened. The documentation for every event has a table (near the top) that includes a link to the associated event interface, and other relevant information. A full list of the different event types is given in Event > Interfaces based on Event.
This topic provides an index to the main sorts of events you might be interested in (animation, clipboard, workers etc.) along with the main classes that implement those sorts of events.Event index
  
    
      Event type
      Description
      Documentation
    
    
      Animation
      
        
          Events related to the
          Web Animation API.
        
        
          Used to respond to changes in animation status (e.g., when an animation
          starts or ends).
        
      
      
        Animation events fired on
        Document,
        Window,
        HTMLElement.
      
    
    
      Asynchronous data fetching
      Events related to the fetching data.
      
        Events fired on
        AbortSignal,
        XMLHttpRequest,
        FileReader.
      
    
    
      Clipboard
      
        
          Events related to the
          Clipboard API.
        
        Used to notify when content is cut, copied, or pasted.
      
      
        Events fired on
        Document,
        Element,
        Window.
      
    
    
      Composition
      
        
          Events related to composition; entering text "indirectly" (rather than
          using normal keyboard presses).
        
        
          For example, text entered via a speech to text engine, or using
          special key combinations that modify keyboard presses to represent new
          characters in another language.
        
      
      
        Events fired on
        Element.
      
    
    
      CSS transition
      
        
          Events related to
          CSS Transitions.
        
        
          Provides notification events when CSS transitions start, stop, are
          cancelled, etc.
        
      
      
        Events fired on
        Document,
        HTMLElement,
        Window.
      
    
    
      Database
      
        
          Events related to database operations: opening, closing, transactions,
          errors, etc.
        
      
      
        Events fired on
        IDBDatabase,
        IDBOpenDBRequest,
        IDBRequest,
        IDBTransaction.
      
    
    
      DOM mutation
      
        
          Events related to modifications to the Document Object Model (DOM)
          hierarchy and nodes.
        
      
      
        
          
            Warning:
            Mutation Events are
            deprecated.
            Mutation Observers
            should be used instead.
          
        
      
    
    
      Drag'n'drop, Wheel
      
        
          Events related to using the
          HTML Drag and Drop API
          and wheel events.
        
        
          Drag and Wheel events are derived from mouse events. While they are
          fired when using mouse wheel or drag/drop, they may also be used with
          other appropriate hardware.
        
      
      
        
          Drag events fired on
          Document
        
        
          Wheel events fired on
          Element
        
      
    
    
      Focus
      Events related to elements gaining and losing focus.
      
        Events fired on
        Element,
        Window.
      
    
    
      Form
      
        Events related to forms being constructed, reset and submitted.
      
      
        Events fired on
        HTMLFormElement.
      
    
    
      Fullscreen
      
        
          Events related to the
          Fullscreen API.
        
        
          Used to notify when the transitioning between full screen and windowed
          modes, and also of errors occurring during this transition.
        
      
      
        Events fired on
        Document,
        Element.
      
    
    
      Gamepad
      
        
          Events related to the
          Gamepad API.
        
      
      
        Events fired on
        Window.
      
    
    
      Gestures
      
        
          Touch events are
          recommended for implementing gestures.
        
      
      
        
          Events fired on
          Document,
          Element.
        
        In addition there are a number of non-standard gesture events:
        
          
            Non-standard WebKit specific events on
            Element:
            gesturestart event,
            gesturechange event,
            gestureend event.
          
        
      
    
    
      History
      
        
          Events related to the
          History API.
        
      
      
        Events fired on
        Window.
      
    
    
      HTML element content display management
      
        
          Events related to changing the state of a display or textual element.
        
      
      
        Events fired on
        HTMLDetailsElement,
        HTMLDialogElement,
        HTMLSlotElement.
      
    
    
      Inputs
      
        
          Events related to HTML input elements e.g.
          <input>, <select>, or
          <textarea>.
        
      
      
        Events fired on
        HTMLElement,
        HTMLInputElement.
      
    
    
      Keyboard
      
        
          Events related to using a
          keyboard.
        
        Used to notify when keys are moved up, down, or just pressed.
      
      
        Events fired on
        Document,
        Element.
      
    
    
      Loading/unloading documents
      Events related to loading and unloading documents.
      
        
          Events fired on
          Document
          and
          Window.
        
      
    
    
      Manifests
      
        
          Events related to installation of
          progressive web app manifests.
        
      
      
        Events fired on
        Window.
      
    
    
      Media
      
        
          Events related to media usage (including the
          Media Capture and Streams API,
          Web Audio API,
          Picture-in-Picture API, etc.).
        
      
      
        Events fired on
        ScriptProcessorNode,
        HTMLMediaElement,
        AudioTrackList,
        AudioScheduledSourceNode,
        MediaRecorder,
        MediaStream,
        MediaStreamTrack,
        VideoTrackList,
        HTMLTrackElement,
        OfflineAudioContext,
        TextTrack,
        TextTrackList,
        Element/audio,
        Element/video.
      
    
    
      Messaging
      
        
          Events related to a window receiving a message from another browsing
          context.
        
      
      
        Events fired on
        Window.
      
    
    
      Mouse
      
        
          Events related to using a
          computer mouse.
        
        
          Used to notify when the mouse is clicked, double-clicked, up and down
          events, right-click, movement in and out of an element, text
          selection, etc.
        
        
          Pointer events provide a hardware-agnostic alternative to mouse
          events. Drag and Wheel events are derived from mouse events.
        
      
      
        Mouse events fired on
        Element
      
    
    
      Network/Connection
      Events related to gaining and losing network connection.
      
        
          Events fired on
          Window.
        
        
          Events fired on
          NetworkInformation
          (Network Information API).
        
      
    
    
      Payments
      
        
          Events related to the
          Payment Request API.
        
      
      
        
          Events fired on
          PaymentRequest,
          PaymentResponse.
        
      
    
    
      Performance
      
        
          Events related to any performance-related spec grouped into
          Performance APIs.
        
      
      
        
          Events fired on
          Performance.
        
      
    
    
      Pointer
      
        
          Events related to the
          Pointer Events API.
        
        
          Provides hardware-agnostic notification from pointing devices
          including Mouse, Touch, pen/stylus.
        
      
      
        Events fired on
        Document,
        HTMLElement.
      
    
    
      Print
      Events related to printing.
      
        Events fired on
        Window.
      
    
    
      Promise rejection
      
        
          Events sent to the global script context when any JavaScript promise
          is rejected.
        
      
      
        Events fired on
        Window.
      
    
    
      Sockets
      
        
          Events related to the
          WebSockets API.
        
      
      
        Events fired on
        WebSocket.
      
    
    
      SVG
      Events related to SVG images.
      
        
          Events fired on
          SVGElement,
          SVGAnimationElement,
          SVGGraphicsElement.
        
      
    
    
      Text selection
      
        
          Selection API events
          related to selecting text.
        
      
      
        
          Event (selectionchange) fired on
          HTMLTextAreaElement,
          HTMLInputElement.
        
      
    
    
      Touch
      
        
          Events related to the
          Touch Events API.
        
        
          Provides notification events from interacting with a touch sensitive
          screen (i.e., using a finger or stylus). Not related to the
          Force Touch API.
        
      
      
        Events fired on
        Document,
        Element.
      
    
    
      Virtual reality
      
        
          Events related to the
          WebXR Device API.
        
        
          
            Warning: The
            WebVR API (and
            associated
            Window events) are deprecated.
          
        
      
      
        Events fired on
        XRSystem,
        XRSession,
        XRReferenceSpace.
      
    
    
      RTC (real time communication)
      
        
          Events related to the
          WebRTC API.
        
      
      
        Events fired on
        RTCDataChannel,
        RTCDTMFSender,
        RTCIceTransport,
        RTCPeerConnection.
      
    
    
      Server-sent events
      
        
          Events related to the
          server sent events API.
        
      
      
        Events fired on
        EventSource.
      
    
    
      Speech
      
        
          Events related to the
          Web Speech API.
        
      
      
        Events fired on
        SpeechSynthesisUtterance.
      
    
    
      Workers
      
        
          Events related to the
          Web Workers API,
          Service Worker API,
          Broadcast Channel API, and
          Channel Messaging API.
        
        
          Used to respond to new messages and message sending errors. Service
          workers can also be notified of other events, including push
          notifications, users clicking on displayed notifications, that push
          subscription has been invalidated, deletion of items from the content
          index, etc.
        
      
      
        Events fired on
        ServiceWorkerGlobalScope,
        DedicatedWorkerGlobalScope,
        SharedWorkerGlobalScope,
        WorkerGlobalScope,
        Worker,
        BroadcastChannel,
        MessagePort.
      
    
  
SpecificationsSpecificationHTML # events-2\n\nEvent referenceEvents are fired to notify code of "interesting changes" that may affect code execution. These can arise from user interactions such as using a mouse or resizing a window, changes in the state of the underlying environment (e.g., low battery or media events from the operating system), and other causes.
Each event is represented by an object that is based on the Event interface, and may have additional custom fields and/or functions to provide information about what happened. The documentation for every event has a table (near the top) that includes a link to the associated event interface, and other relevant information. A full list of the different event types is given in Event > Interfaces based on Event.
This topic provides an index to the main sorts of events you might be interested in (animation, clipboard, workers etc.) along with the main classes that implement those sorts of events.Event index
  
    
      Event type
      Description
      Documentation
    
    
      Animation
      
        
          Events related to the
          Web Animation API.
        
        
          Used to respond to changes in animation status (e.g., when an animation
          starts or ends).
        
      
      
        Animation events fired on
        Document,
        Window,
        HTMLElement.
      
    
    
      Asynchronous data fetching
      Events related to the fetching data.
      
        Events fired on
        AbortSignal,
        XMLHttpRequest,
        FileReader.
      
    
    
      Clipboard
      
        
          Events related to the
          Clipboard API.
        
        Used to notify when content is cut, copied, or pasted.
      
      
        Events fired on
        Document,
        Element,
        Window.
      
    
    
      Composition
      
        
          Events related to composition; entering text "indirectly" (rather than
          using normal keyboard presses).
        
        
          For example, text entered via a speech to text engine, or using
          special key combinations that modify keyboard presses to represent new
          characters in another language.
        
      
      
        Events fired on
        Element.
      
    
    
      CSS transition
      
        
          Events related to
          CSS Transitions.
        
        
          Provides notification events when CSS transitions start, stop, are
          cancelled, etc.
        
      
      
        Events fired on
        Document,
        HTMLElement,
        Window.
      
    
    
      Database
      
        
          Events related to database operations: opening, closing, transactions,
          errors, etc.
        
      
      
        Events fired on
        IDBDatabase,
        IDBOpenDBRequest,
        IDBRequest,
        IDBTransaction.
      
    
    
      DOM mutation
      
        
          Events related to modifications to the Document Object Model (DOM)
          hierarchy and nodes.
        
      
      
        
          
            Warning:
            Mutation Events are
            deprecated.
            Mutation Observers
            should be used instead.
          
        
      
    
    
      Drag'n'drop, Wheel
      
        
          Events related to using the
          HTML Drag and Drop API
          and wheel events.
        
        
          Drag and Wheel events are derived from mouse events. While they are
          fired when using mouse wheel or drag/drop, they may also be used with
          other appropriate hardware.
        
      
      
        
          Drag events fired on
          Document
        
        
          Wheel events fired on
          Element
        
      
    
    
      Focus
      Events related to elements gaining and losing focus.
      
        Events fired on
        Element,
        Window.
      
    
    
      Form
      
        Events related to forms being constructed, reset and submitted.
      
      
        Events fired on
        HTMLFormElement.
      
    
    
      Fullscreen
      
        
          Events related to the
          Fullscreen API.
        
        
          Used to notify when the transitioning between full screen and windowed
          modes, and also of errors occurring during this transition.
        
      
      
        Events fired on
        Document,
        Element.
      
    
    
      Gamepad
      
        
          Events related to the
          Gamepad API.
        
      
      
        Events fired on
        Window.
      
    
    
      Gestures
      
        
          Touch events are
          recommended for implementing gestures.
        
      
      
        
          Events fired on
          Document,
          Element.
        
        In addition there are a number of non-standard gesture events:
        
          
            Non-standard WebKit specific events on
            Element:
            gesturestart event,
            gesturechange event,
            gestureend event.
          
        
      
    
    
      History
      
        
          Events related to the
          History API.
        
      
      
        Events fired on
        Window.
      
    
    
      HTML element content display management
      
        
          Events related to changing the state of a display or textual element.
        
      
      
        Events fired on
        HTMLDetailsElement,
        HTMLDialogElement,
        HTMLSlotElement.
      
    
    
      Inputs
      
        
          Events related to HTML input elements e.g.
          <input>, <select>, or
          <textarea>.
        
      
      
        Events fired on
        HTMLElement,
        HTMLInputElement.
      
    
    
      Keyboard
      
        
          Events related to using a
          keyboard.
        
        Used to notify when keys are moved up, down, or just pressed.
      
      
        Events fired on
        Document,
        Element.
      
    
    
      Loading/unloading documents
      Events related to loading and unloading documents.
      
        
          Events fired on
          Document
          and
          Window.
        
      
    
    
      Manifests
      
        
          Events related to installation of
          progressive web app manifests.
        
      
      
        Events fired on
        Window.
      
    
    
      Media
      
        
          Events related to media usage (including the
          Media Capture and Streams API,
          Web Audio API,
          Picture-in-Picture API, etc.).
        
      
      
        Events fired on
        ScriptProcessorNode,
        HTMLMediaElement,
        AudioTrackList,
        AudioScheduledSourceNode,
        MediaRecorder,
        MediaStream,
        MediaStreamTrack,
        VideoTrackList,
        HTMLTrackElement,
        OfflineAudioContext,
        TextTrack,
        TextTrackList,
        Element/audio,
        Element/video.
      
    
    
      Messaging
      
        
          Events related to a window receiving a message from another browsing
          context.
        
      
      
        Events fired on
        Window.
      
    
    
      Mouse
      
        
          Events related to using a
          computer mouse.
        
        
          Used to notify when the mouse is clicked, double-clicked, up and down
          events, right-click, movement in and out of an element, text
          selection, etc.
        
        
          Pointer events provide a hardware-agnostic alternative to mouse
          events. Drag and Wheel events are derived from mouse events.
        
      
      
        Mouse events fired on
        Element
      
    
    
      Network/Connection
      Events related to gaining and losing network connection.
      
        
          Events fired on
          Window.
        
        
          Events fired on
          NetworkInformation
          (Network Information API).
        
      
    
    
      Payments
      
        
          Events related to the
          Payment Request API.
        
      
      
        
          Events fired on
          PaymentRequest,
          PaymentResponse.
        
      
    
    
      Performance
      
        
          Events related to any performance-related spec grouped into
          Performance APIs.
        
      
      
        
          Events fired on
          Performance.
        
      
    
    
      Pointer
      
        
          Events related to the
          Pointer Events API.
        
        
          Provides hardware-agnostic notification from pointing devices
          including Mouse, Touch, pen/stylus.
        
      
      
        Events fired on
        Document,
        HTMLElement.
      
    
    
      Print
      Events related to printing.
      
        Events fired on
        Window.
      
    
    
      Promise rejection
      
        
          Events sent to the global script context when any JavaScript promise
          is rejected.
        
      
      
        Events fired on
        Window.
      
    
    
      Sockets
      
        
          Events related to the
          WebSockets API.
        
      
      
        Events fired on
        WebSocket.
      
    
    
      SVG
      Events related to SVG images.
      
        
          Events fired on
          SVGElement,
          SVGAnimationElement,
          SVGGraphicsElement.
        
      
    
    
      Text selection
      
        
          Selection API events
          related to selecting text.
        
      
      
        
          Event (selectionchange) fired on
          HTMLTextAreaElement,
          HTMLInputElement.
        
      
    
    
      Touch
      
        
          Events related to the
          Touch Events API.
        
        
          Provides notification events from interacting with a touch sensitive
          screen (i.e., using a finger or stylus). Not related to the
          Force Touch API.
        
      
      
        Events fired on
        Document,
        Element.
      
    
    
      Virtual reality
      
        
          Events related to the
          WebXR Device API.
        
        
          
            Warning: The
            WebVR API (and
            associated
            Window events) are deprecated.
          
        
      
      
        Events fired on
        XRSystem,
        XRSession,
        XRReferenceSpace.
      
    
    
      RTC (real time communication)
      
        
          Events related to the
          WebRTC API.
        
      
      
        Events fired on
        RTCDataChannel,
        RTCDTMFSender,
        RTCIceTransport,
        RTCPeerConnection.
      
    
    
      Server-sent events
      
        
          Events related to the
          server sent events API.
        
      
      
        Events fired on
        EventSource.
      
    
    
      Speech
      
        
          Events related to the
          Web Speech API.
        
      
      
        Events fired on
        SpeechSynthesisUtterance.
      
    
    
      Workers
      
        
          Events related to the
          Web Workers API,
          Service Worker API,
          Broadcast Channel API, and
          Channel Messaging API.
        
        
          Used to respond to new messages and message sending errors. Service
          workers can also be notified of other events, including push
          notifications, users clicking on displayed notifications, that push
          subscription has been invalidated, deletion of items from the content
          index, etc.
        
      
      
        Events fired on
        ServiceWorkerGlobalScope,
        DedicatedWorkerGlobalScope,
        SharedWorkerGlobalScope,
        WorkerGlobalScope,
        Worker,
        BroadcastChannel,
        MessagePort.
      
    
  
SpecificationsSpecificationHTML # events-2Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nEvent referenceEvents are fired to notify code of "interesting changes" that may affect code execution. These can arise from user interactions such as using a mouse or resizing a window, changes in the state of the underlying environment (e.g., low battery or media events from the operating system), and other causes.
Each event is represented by an object that is based on the Event interface, and may have additional custom fields and/or functions to provide information about what happened. The documentation for every event has a table (near the top) that includes a link to the associated event interface, and other relevant information. A full list of the different event types is given in Event > Interfaces based on Event.
This topic provides an index to the main sorts of events you might be interested in (animation, clipboard, workers etc.) along with the main classes that implement those sorts of events.Event index
  
    
      Event type
      Description
      Documentation
    
    
      Animation
      
        
          Events related to the
          Web Animation API.
        
        
          Used to respond to changes in animation status (e.g., when an animation
          starts or ends).
        
      
      
        Animation events fired on
        Document,
        Window,
        HTMLElement.
      
    
    
      Asynchronous data fetching
      Events related to the fetching data.
      
        Events fired on
        AbortSignal,
        XMLHttpRequest,
        FileReader.
      
    
    
      Clipboard
      
        
          Events related to the
          Clipboard API.
        
        Used to notify when content is cut, copied, or pasted.
      
      
        Events fired on
        Document,
        Element,
        Window.
      
    
    
      Composition
      
        
          Events related to composition; entering text "indirectly" (rather than
          using normal keyboard presses).
        
        
          For example, text entered via a speech to text engine, or using
          special key combinations that modify keyboard presses to represent new
          characters in another language.
        
      
      
        Events fired on
        Element.
      
    
    
      CSS transition
      
        
          Events related to
          CSS Transitions.
        
        
          Provides notification events when CSS transitions start, stop, are
          cancelled, etc.
        
      
      
        Events fired on
        Document,
        HTMLElement,
        Window.
      
    
    
      Database
      
        
          Events related to database operations: opening, closing, transactions,
          errors, etc.
        
      
      
        Events fired on
        IDBDatabase,
        IDBOpenDBRequest,
        IDBRequest,
        IDBTransaction.
      
    
    
      DOM mutation
      
        
          Events related to modifications to the Document Object Model (DOM)
          hierarchy and nodes.
        
      
      
        
          
            Warning:
            Mutation Events are
            deprecated.
            Mutation Observers
            should be used instead.
          
        
      
    
    
      Drag'n'drop, Wheel
      
        
          Events related to using the
          HTML Drag and Drop API
          and wheel events.
        
        
          Drag and Wheel events are derived from mouse events. While they are
          fired when using mouse wheel or drag/drop, they may also be used with
          other appropriate hardware.
        
      
      
        
          Drag events fired on
          Document
        
        
          Wheel events fired on
          Element
        
      
    
    
      Focus
      Events related to elements gaining and losing focus.
      
        Events fired on
        Element,
        Window.
      
    
    
      Form
      
        Events related to forms being constructed, reset and submitted.
      
      
        Events fired on
        HTMLFormElement.
      
    
    
      Fullscreen
      
        
          Events related to the
          Fullscreen API.
        
        
          Used to notify when the transitioning between full screen and windowed
          modes, and also of errors occurring during this transition.
        
      
      
        Events fired on
        Document,
        Element.
      
    
    
      Gamepad
      
        
          Events related to the
          Gamepad API.
        
      
      
        Events fired on
        Window.
      
    
    
      Gestures
      
        
          Touch events are
          recommended for implementing gestures.
        
      
      
        
          Events fired on
          Document,
          Element.
        
        In addition there are a number of non-standard gesture events:
        
          
            Non-standard WebKit specific events on
            Element:
            gesturestart event,
            gesturechange event,
            gestureend event.
          
        
      
    
    
      History
      
        
          Events related to the
          History API.
        
      
      
        Events fired on
        Window.
      
    
    
      HTML element content display management
      
        
          Events related to changing the state of a display or textual element.
        
      
      
        Events fired on
        HTMLDetailsElement,
        HTMLDialogElement,
        HTMLSlotElement.
      
    
    
      Inputs
      
        
          Events related to HTML input elements e.g.
          <input>, <select>, or
          <textarea>.
        
      
      
        Events fired on
        HTMLElement,
        HTMLInputElement.
      
    
    
      Keyboard
      
        
          Events related to using a
          keyboard.
        
        Used to notify when keys are moved up, down, or just pressed.
      
      
        Events fired on
        Document,
        Element.
      
    
    
      Loading/unloading documents
      Events related to loading and unloading documents.
      
        
          Events fired on
          Document
          and
          Window.
        
      
    
    
      Manifests
      
        
          Events related to installation of
          progressive web app manifests.
        
      
      
        Events fired on
        Window.
      
    
    
      Media
      
        
          Events related to media usage (including the
          Media Capture and Streams API,
          Web Audio API,
          Picture-in-Picture API, etc.).
        
      
      
        Events fired on
        ScriptProcessorNode,
        HTMLMediaElement,
        AudioTrackList,
        AudioScheduledSourceNode,
        MediaRecorder,
        MediaStream,
        MediaStreamTrack,
        VideoTrackList,
        HTMLTrackElement,
        OfflineAudioContext,
        TextTrack,
        TextTrackList,
        Element/audio,
        Element/video.
      
    
    
      Messaging
      
        
          Events related to a window receiving a message from another browsing
          context.
        
      
      
        Events fired on
        Window.
      
    
    
      Mouse
      
        
          Events related to using a
          computer mouse.
        
        
          Used to notify when the mouse is clicked, double-clicked, up and down
          events, right-click, movement in and out of an element, text
          selection, etc.
        
        
          Pointer events provide a hardware-agnostic alternative to mouse
          events. Drag and Wheel events are derived from mouse events.
        
      
      
        Mouse events fired on
        Element
      
    
    
      Network/Connection
      Events related to gaining and losing network connection.
      
        
          Events fired on
          Window.
        
        
          Events fired on
          NetworkInformation
          (Network Information API).
        
      
    
    
      Payments
      
        
          Events related to the
          Payment Request API.
        
      
      
        
          Events fired on
          PaymentRequest,
          PaymentResponse.
        
      
    
    
      Performance
      
        
          Events related to any performance-related spec grouped into
          Performance APIs.
        
      
      
        
          Events fired on
          Performance.
        
      
    
    
      Pointer
      
        
          Events related to the
          Pointer Events API.
        
        
          Provides hardware-agnostic notification from pointing devices
          including Mouse, Touch, pen/stylus.
        
      
      
        Events fired on
        Document,
        HTMLElement.
      
    
    
      Print
      Events related to printing.
      
        Events fired on
        Window.
      
    
    
      Promise rejection
      
        
          Events sent to the global script context when any JavaScript promise
          is rejected.
        
      
      
        Events fired on
        Window.
      
    
    
      Sockets
      
        
          Events related to the
          WebSockets API.
        
      
      
        Events fired on
        WebSocket.
      
    
    
      SVG
      Events related to SVG images.
      
        
          Events fired on
          SVGElement,
          SVGAnimationElement,
          SVGGraphicsElement.
        
      
    
    
      Text selection
      
        
          Selection API events
          related to selecting text.
        
      
      
        
          Event (selectionchange) fired on
          HTMLTextAreaElement,
          HTMLInputElement.
        
      
    
    
      Touch
      
        
          Events related to the
          Touch Events API.
        
        
          Provides notification events from interacting with a touch sensitive
          screen (i.e., using a finger or stylus). Not related to the
          Force Touch API.
        
      
      
        Events fired on
        Document,
        Element.
      
    
    
      Virtual reality
      
        
          Events related to the
          WebXR Device API.
        
        
          
            Warning: The
            WebVR API (and
            associated
            Window events) are deprecated.
          
        
      
      
        Events fired on
        XRSystem,
        XRSession,
        XRReferenceSpace.
      
    
    
      RTC (real time communication)
      
        
          Events related to the
          WebRTC API.
        
      
      
        Events fired on
        RTCDataChannel,
        RTCDTMFSender,
        RTCIceTransport,
        RTCPeerConnection.
      
    
    
      Server-sent events
      
        
          Events related to the
          server sent events API.
        
      
      
        Events fired on
        EventSource.
      
    
    
      Speech
      
        
          Events related to the
          Web Speech API.
        
      
      
        Events fired on
        SpeechSynthesisUtterance.
      
    
    
      Workers
      
        
          Events related to the
          Web Workers API,
          Service Worker API,
          Broadcast Channel API, and
          Channel Messaging API.
        
        
          Used to respond to new messages and message sending errors. Service
          workers can also be notified of other events, including push
          notifications, users clicking on displayed notifications, that push
          subscription has been invalidated, deletion of items from the content
          index, etc.
        
      
      
        Events fired on
        ServiceWorkerGlobalScope,
        DedicatedWorkerGlobalScope,
        SharedWorkerGlobalScope,
        WorkerGlobalScope,
        Worker,
        BroadcastChannel,
        MessagePort.
      
    
  
SpecificationsSpecificationHTML # events-2Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nMathMLBaseline 2023Newly availableSince January 2023, this feature works across the latest devices and browser versions. This feature might not work in older devices or browsers.Learn moreSee full compatibilityReport feedbackMathematical Markup Language (MathML) is an XML-based language for describing mathematical notation.
MathML was originally designed as a general-purpose specification for browsers, office suites, computer algebra systems, EPUB readers, LaTeX-based generators. However, this approach was not very adapted to the Web: the subset focusing on semantics has never been implemented in browsers while the subset focusing on math layout led to incomplete and inconsistent browser implementations.
MathML Core is a subset with increased implementation details based on rules from LaTeX and the Open Font Format. It is tailored for browsers and designed specifically to work well with other web standards including HTML, CSS, DOM, JavaScript.
Below you will find links to documentation, examples, and tools to work with MathML. MDN uses MathML Core as a reference specification but, due to an erratic standardization history, legacy MathML features may still show up in existing implementations and web content.

Note:
It is highly recommended that developers and authors switch to MathML Core, perhaps relying on other web technologies to cover missing use cases. The Math WG is maintaining a set of MathML polyfills to facilitate that transition.
Tutorials
MathML for beginners

This tutorial will guide you through creating math formulas using structured markup. It starts with an introduction to adding MathML to an HTML document, followed by a deep dive into key components: fractions and roots, scripted elements, and text containers. The tutorial then covers tabular layouts for matrices and advanced math formatting. Finally, a challenge tests your understanding by having you recreate three famous mathematical formulas using the learned concepts.

Guides
Authoring MathML

Suggestions and tips for writing MathML, including suggested MathML editors and how to integrate their output into Web content.

Fonts for MathML

How users can install such math fonts to properly display MathML in browsers.

Reference
MathML element reference

Details about each MathML element and compatibility information for desktop and mobile browsers.

MathML global attribute reference

Information about global MathML attributes applicable to all elements.

MathML attribute reference

Information about MathML attributes that modify the appearance or behavior of elements.

MathML attribute values

Further information about MathML attribute values.

ExamplesBelow you'll find some examples you can look at to help you to understand how to use MathML.MathML formulasThe following demos display increasingly complex mathematical concepts in Web content.

Proving the Pythagorean theorem

Small example showing a proof of the Pythagorean Theorem.

Deriving the quadratic formula

Outlines the derivation of the Quadratic Formula.

Mozilla MathML test

Original test from the Mozilla MathML project. It contains examples from the TeXbook with image references generated by TeX.

MathML browser test

A similar test with concrete formulas taken from Wikipedia.

Other Web technologiesThe following demos mix MathML with other Web technologies to produce advanced content.

<la-tex> custom element

A custom element that accepts LaTeX content.

Magnetic field demo

A 3D representation of a magnetic field, using SVG and WebGL.

Συνάρτηση ζήτα Ρήμαν (el)

A greek article about the Riemann zeta function, with Web fonts from the Greek Font Society.

Pell's equation

A JavaScript program to solve Pell's equation using BigInt.

Lovelace's program for Bernoulli numbers

An emulator for Ada Lovelace's program to calculate Bernoulli numbers, using Private properties.

Getting help from the community
W3C Math Home
Raise issues on GitHub w3c/mathml repository
www-math w3.org mail archive
Tools
W3C Validator
W3C's wiki page
Related topics
CSS
HTML
SVG
SpecificationsSpecificationMathematical Markup Language (MathML) Version 4.0 Browser compatibility\n\nMathMLBaseline 2023Newly availableSince January 2023, this feature works across the latest devices and browser versions. This feature might not work in older devices or browsers.Learn moreSee full compatibilityReport feedbackMathematical Markup Language (MathML) is an XML-based language for describing mathematical notation.
MathML was originally designed as a general-purpose specification for browsers, office suites, computer algebra systems, EPUB readers, LaTeX-based generators. However, this approach was not very adapted to the Web: the subset focusing on semantics has never been implemented in browsers while the subset focusing on math layout led to incomplete and inconsistent browser implementations.
MathML Core is a subset with increased implementation details based on rules from LaTeX and the Open Font Format. It is tailored for browsers and designed specifically to work well with other web standards including HTML, CSS, DOM, JavaScript.
Below you will find links to documentation, examples, and tools to work with MathML. MDN uses MathML Core as a reference specification but, due to an erratic standardization history, legacy MathML features may still show up in existing implementations and web content.

Note:
It is highly recommended that developers and authors switch to MathML Core, perhaps relying on other web technologies to cover missing use cases. The Math WG is maintaining a set of MathML polyfills to facilitate that transition.
Tutorials
MathML for beginners

This tutorial will guide you through creating math formulas using structured markup. It starts with an introduction to adding MathML to an HTML document, followed by a deep dive into key components: fractions and roots, scripted elements, and text containers. The tutorial then covers tabular layouts for matrices and advanced math formatting. Finally, a challenge tests your understanding by having you recreate three famous mathematical formulas using the learned concepts.

Guides
Authoring MathML

Suggestions and tips for writing MathML, including suggested MathML editors and how to integrate their output into Web content.

Fonts for MathML

How users can install such math fonts to properly display MathML in browsers.

Reference
MathML element reference

Details about each MathML element and compatibility information for desktop and mobile browsers.

MathML global attribute reference

Information about global MathML attributes applicable to all elements.

MathML attribute reference

Information about MathML attributes that modify the appearance or behavior of elements.

MathML attribute values

Further information about MathML attribute values.

ExamplesBelow you'll find some examples you can look at to help you to understand how to use MathML.MathML formulasThe following demos display increasingly complex mathematical concepts in Web content.

Proving the Pythagorean theorem

Small example showing a proof of the Pythagorean Theorem.

Deriving the quadratic formula

Outlines the derivation of the Quadratic Formula.

Mozilla MathML test

Original test from the Mozilla MathML project. It contains examples from the TeXbook with image references generated by TeX.

MathML browser test

A similar test with concrete formulas taken from Wikipedia.

Other Web technologiesThe following demos mix MathML with other Web technologies to produce advanced content.

<la-tex> custom element

A custom element that accepts LaTeX content.

Magnetic field demo

A 3D representation of a magnetic field, using SVG and WebGL.

Συνάρτηση ζήτα Ρήμαν (el)

A greek article about the Riemann zeta function, with Web fonts from the Greek Font Society.

Pell's equation

A JavaScript program to solve Pell's equation using BigInt.

Lovelace's program for Bernoulli numbers

An emulator for Ada Lovelace's program to calculate Bernoulli numbers, using Private properties.

Getting help from the community
W3C Math Home
Raise issues on GitHub w3c/mathml repository
www-math w3.org mail archive
Tools
W3C Validator
W3C's wiki page
Related topics
CSS
HTML
SVG
SpecificationsSpecificationMathematical Markup Language (MathML) Version 4.0 Browser compatibilityHelp improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 4, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nMathMLBaseline 2023Newly availableSince January 2023, this feature works across the latest devices and browser versions. This feature might not work in older devices or browsers.Learn moreSee full compatibilityReport feedbackMathematical Markup Language (MathML) is an XML-based language for describing mathematical notation.
MathML was originally designed as a general-purpose specification for browsers, office suites, computer algebra systems, EPUB readers, LaTeX-based generators. However, this approach was not very adapted to the Web: the subset focusing on semantics has never been implemented in browsers while the subset focusing on math layout led to incomplete and inconsistent browser implementations.
MathML Core is a subset with increased implementation details based on rules from LaTeX and the Open Font Format. It is tailored for browsers and designed specifically to work well with other web standards including HTML, CSS, DOM, JavaScript.
Below you will find links to documentation, examples, and tools to work with MathML. MDN uses MathML Core as a reference specification but, due to an erratic standardization history, legacy MathML features may still show up in existing implementations and web content.

Note:
It is highly recommended that developers and authors switch to MathML Core, perhaps relying on other web technologies to cover missing use cases. The Math WG is maintaining a set of MathML polyfills to facilitate that transition.
Tutorials
MathML for beginners

This tutorial will guide you through creating math formulas using structured markup. It starts with an introduction to adding MathML to an HTML document, followed by a deep dive into key components: fractions and roots, scripted elements, and text containers. The tutorial then covers tabular layouts for matrices and advanced math formatting. Finally, a challenge tests your understanding by having you recreate three famous mathematical formulas using the learned concepts.

Guides
Authoring MathML

Suggestions and tips for writing MathML, including suggested MathML editors and how to integrate their output into Web content.

Fonts for MathML

How users can install such math fonts to properly display MathML in browsers.

Reference
MathML element reference

Details about each MathML element and compatibility information for desktop and mobile browsers.

MathML global attribute reference

Information about global MathML attributes applicable to all elements.

MathML attribute reference

Information about MathML attributes that modify the appearance or behavior of elements.

MathML attribute values

Further information about MathML attribute values.

ExamplesBelow you'll find some examples you can look at to help you to understand how to use MathML.MathML formulasThe following demos display increasingly complex mathematical concepts in Web content.

Proving the Pythagorean theorem

Small example showing a proof of the Pythagorean Theorem.

Deriving the quadratic formula

Outlines the derivation of the Quadratic Formula.

Mozilla MathML test

Original test from the Mozilla MathML project. It contains examples from the TeXbook with image references generated by TeX.

MathML browser test

A similar test with concrete formulas taken from Wikipedia.

Other Web technologiesThe following demos mix MathML with other Web technologies to produce advanced content.

<la-tex> custom element

A custom element that accepts LaTeX content.

Magnetic field demo

A 3D representation of a magnetic field, using SVG and WebGL.

Συνάρτηση ζήτα Ρήμαν (el)

A greek article about the Riemann zeta function, with Web fonts from the Greek Font Society.

Pell's equation

A JavaScript program to solve Pell's equation using BigInt.

Lovelace's program for Bernoulli numbers

An emulator for Ada Lovelace's program to calculate Bernoulli numbers, using Private properties.

Getting help from the community
W3C Math Home
Raise issues on GitHub w3c/mathml repository
www-math w3.org mail archive
Tools
W3C Validator
W3C's wiki page
Related topics
CSS
HTML
SVG
SpecificationsSpecificationMathematical Markup Language (MathML) Version 4.0 Browser compatibilityHelp improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 4, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nMedia technologies on the webOver the years, the web's ability to present, create, and manage audio, video, and other media has matured.
There are now a large number of APIs, as well as HTML elements, DOM interfaces, and other features that make it possible to work with media in exciting and immersive ways.
This article lists guides and references for various features you may use when incorporating media into your projects.Guides
Audio and Video Delivery

We can deliver audio and video on the web in a number of ways, ranging from 'static' media files to adaptive live streams. This article is intended as a starting point for exploring the various delivery mechanisms of web-based media and compatibility with popular browsers.

Audio and Video manipulation

Having native audio and video in the browser means we can use these data streams with technologies such as <canvas>, WebGL or Web Audio API to modify audio and video directly, for example adding reverb/compression effects to audio, or grayscale/sepia filters to video.

Autoplay guide for media and Web Audio APIs

Unexpected automatic playback of media or audio can be an unwelcome surprise to users. While autoplay serves a purpose, it should be used carefully. To give users control over this, many browsers now provide forms of autoplay blocking. This article is a guide to autoplay, with tips on when and how to use it and how to work with browsers to handle autoplay blocking gracefully.

DASH Adaptive Streaming for HTML 5 Video

Dynamic Adaptive Streaming over HTTP (DASH) is an adaptive streaming protocol. This means that it allows for a video stream to switch between bit rates on the basis of network performance, in order to keep a video playing.

Streaming audio and video

A guide which covers how to stream audio and video, as well as techniques and technologies you can take advantage of to ensure the best possible quality and/or performance of your streams.

Media types and formats on the web

A guide to the file types and codecs available for images, audio, and video media on the web. This includes recommendations for what formats to use for what kinds of content, best practices including how to provide fallbacks and how to prioritize media types, and also includes general browser support information for each media container and codec.

Using images in HTML

A guide to adding images to websites that are responsive, accessible, and performant.

ReferencesHTMLThese articles describe the HTML elements used for including media:

<audio>

The <audio> element is used to play audio. These can be used invisibly as a destination for more complex media, or with visible controls for user-controlled playback of audio files. Accessible from JavaScript as HTMLAudioElement objects.

<video>

The <video> element is used to play video content. It can be used to present video files, or as a destination for streamed video content. <video> can also be used as a way to link media APIs with other HTML and DOM technologies, including <canvas> (for frame grabbing and manipulation), for example. It is accessible from JavaScript as HTMLVideoElement objects.

<track>

The HTML <track> element can be placed within an <audio> or <video> element to provide a reference to a WebVTT format subtitle or caption track to be used when playing the media. Accessible from JavaScript as HTMLTrackElement objects.

<source>

The HTML <source> element is used within an <audio> or <video> element to specify source media to present. Multiple sources can be used to provide the media in different formats, sizes, or resolutions. Accessible from JavaScript as HTMLSourceElement objects.

APIs
Media Capabilities API

The Media Capabilities API lets you determine the encoding and decoding capabilities of the device your app or site is running on. This lets you make real-time decisions about what formats to use and when.

Media Capture and Streams API

A reference for the API which makes it possible to stream, record, and manipulate media both locally and across a network. This includes using local cameras and microphones to capture video, audio, and still images.

Media Session API

The Media Session API provides a way to customize media notifications. It does this by providing metadata for display by the user agent for the media your web app is playing. It also provides action handlers that the browser can use to access platform media keys such as hardware keys found on keyboards, headsets, remote controls, and software keys found in notification areas and on lock screens of mobile devices.

MediaStream Recording API

The MediaStream Recording API lets you capture media streams to process or filter the data or record it to disk.

Web Audio API

The Web Audio API lets you generate, filter, and manipulate sound data both in real-time and on pre-recorded material, then send that audio to a destination such as an <audio> element, a media stream, or to disk.

WebRTC

WebRTC (Web Real-Time Communication) makes it possible to stream live audio and video, as well as transfer arbitrary data, between two peers over the Internet, without requiring an intermediary.

Related topicsRelated topics which may be of interest, since they can be used in tandem with media APIs in interesting ways.

Accessible multimedia

In this guide, we cover ways web designers and developers can create content that is accessible to people with different capabilities. This ranges from using the alt attribute on <img> elements to captions to tagging media for screen readers.

Canvas API

The Canvas API lets you draw into an <canvas>, manipulating and changing the contents of an image. This can be used with media in many ways, including by setting a <canvas> element as the destination for video playback or camera capture so that you can capture and manipulate video frames.

WebGL

WebGL provides an OpenGL ES compatible API on top of the existing Canvas API, making it possible to do powerful 3D graphics on the Web. Through a canvas, this can be used to add 3D imagery to media content.

WebXR

WebXR, which has replaced the now-obsolete WebVR API, is a technology that provides support for creating virtual reality (VR) and augmented reality (AR) content. The mixed reality content can then be displayed on the device's screen or using goggles or a headset.

WebVR 
Deprecated


The Web Virtual Reality API supports virtual reality (VR) devices such as the Oculus Rift or the HTC Vive, making it possible for developers to translate position and movement of the user into movement within a 3D scene which is then presented on the device. WebVR has been replaced by WebXR, and is due to be removed from browsers soon.

Web Audio spatialization basics

In 3D environments, which may either be 3D scenes rendered to the screen or a mixed reality experience experienced using a headset, it's important for audio to be performed so that it sounds like it's coming from the direction of its source. This guide covers how to accomplish this.\n\nMedia technologies on the webOver the years, the web's ability to present, create, and manage audio, video, and other media has matured.
There are now a large number of APIs, as well as HTML elements, DOM interfaces, and other features that make it possible to work with media in exciting and immersive ways.
This article lists guides and references for various features you may use when incorporating media into your projects.Guides
Audio and Video Delivery

We can deliver audio and video on the web in a number of ways, ranging from 'static' media files to adaptive live streams. This article is intended as a starting point for exploring the various delivery mechanisms of web-based media and compatibility with popular browsers.

Audio and Video manipulation

Having native audio and video in the browser means we can use these data streams with technologies such as <canvas>, WebGL or Web Audio API to modify audio and video directly, for example adding reverb/compression effects to audio, or grayscale/sepia filters to video.

Autoplay guide for media and Web Audio APIs

Unexpected automatic playback of media or audio can be an unwelcome surprise to users. While autoplay serves a purpose, it should be used carefully. To give users control over this, many browsers now provide forms of autoplay blocking. This article is a guide to autoplay, with tips on when and how to use it and how to work with browsers to handle autoplay blocking gracefully.

DASH Adaptive Streaming for HTML 5 Video

Dynamic Adaptive Streaming over HTTP (DASH) is an adaptive streaming protocol. This means that it allows for a video stream to switch between bit rates on the basis of network performance, in order to keep a video playing.

Streaming audio and video

A guide which covers how to stream audio and video, as well as techniques and technologies you can take advantage of to ensure the best possible quality and/or performance of your streams.

Media types and formats on the web

A guide to the file types and codecs available for images, audio, and video media on the web. This includes recommendations for what formats to use for what kinds of content, best practices including how to provide fallbacks and how to prioritize media types, and also includes general browser support information for each media container and codec.

Using images in HTML

A guide to adding images to websites that are responsive, accessible, and performant.

ReferencesHTMLThese articles describe the HTML elements used for including media:

<audio>

The <audio> element is used to play audio. These can be used invisibly as a destination for more complex media, or with visible controls for user-controlled playback of audio files. Accessible from JavaScript as HTMLAudioElement objects.

<video>

The <video> element is used to play video content. It can be used to present video files, or as a destination for streamed video content. <video> can also be used as a way to link media APIs with other HTML and DOM technologies, including <canvas> (for frame grabbing and manipulation), for example. It is accessible from JavaScript as HTMLVideoElement objects.

<track>

The HTML <track> element can be placed within an <audio> or <video> element to provide a reference to a WebVTT format subtitle or caption track to be used when playing the media. Accessible from JavaScript as HTMLTrackElement objects.

<source>

The HTML <source> element is used within an <audio> or <video> element to specify source media to present. Multiple sources can be used to provide the media in different formats, sizes, or resolutions. Accessible from JavaScript as HTMLSourceElement objects.

APIs
Media Capabilities API

The Media Capabilities API lets you determine the encoding and decoding capabilities of the device your app or site is running on. This lets you make real-time decisions about what formats to use and when.

Media Capture and Streams API

A reference for the API which makes it possible to stream, record, and manipulate media both locally and across a network. This includes using local cameras and microphones to capture video, audio, and still images.

Media Session API

The Media Session API provides a way to customize media notifications. It does this by providing metadata for display by the user agent for the media your web app is playing. It also provides action handlers that the browser can use to access platform media keys such as hardware keys found on keyboards, headsets, remote controls, and software keys found in notification areas and on lock screens of mobile devices.

MediaStream Recording API

The MediaStream Recording API lets you capture media streams to process or filter the data or record it to disk.

Web Audio API

The Web Audio API lets you generate, filter, and manipulate sound data both in real-time and on pre-recorded material, then send that audio to a destination such as an <audio> element, a media stream, or to disk.

WebRTC

WebRTC (Web Real-Time Communication) makes it possible to stream live audio and video, as well as transfer arbitrary data, between two peers over the Internet, without requiring an intermediary.

Related topicsRelated topics which may be of interest, since they can be used in tandem with media APIs in interesting ways.

Accessible multimedia

In this guide, we cover ways web designers and developers can create content that is accessible to people with different capabilities. This ranges from using the alt attribute on <img> elements to captions to tagging media for screen readers.

Canvas API

The Canvas API lets you draw into an <canvas>, manipulating and changing the contents of an image. This can be used with media in many ways, including by setting a <canvas> element as the destination for video playback or camera capture so that you can capture and manipulate video frames.

WebGL

WebGL provides an OpenGL ES compatible API on top of the existing Canvas API, making it possible to do powerful 3D graphics on the Web. Through a canvas, this can be used to add 3D imagery to media content.

WebXR

WebXR, which has replaced the now-obsolete WebVR API, is a technology that provides support for creating virtual reality (VR) and augmented reality (AR) content. The mixed reality content can then be displayed on the device's screen or using goggles or a headset.

WebVR 
Deprecated


The Web Virtual Reality API supports virtual reality (VR) devices such as the Oculus Rift or the HTC Vive, making it possible for developers to translate position and movement of the user into movement within a 3D scene which is then presented on the device. WebVR has been replaced by WebXR, and is due to be removed from browsers soon.

Web Audio spatialization basics

In 3D environments, which may either be 3D scenes rendered to the screen or a mixed reality experience experienced using a headset, it's important for audio to be performed so that it sounds like it's coming from the direction of its source. This guide covers how to accomplish this.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nMedia technologies on the webOver the years, the web's ability to present, create, and manage audio, video, and other media has matured.
There are now a large number of APIs, as well as HTML elements, DOM interfaces, and other features that make it possible to work with media in exciting and immersive ways.
This article lists guides and references for various features you may use when incorporating media into your projects.Guides
Audio and Video Delivery

We can deliver audio and video on the web in a number of ways, ranging from 'static' media files to adaptive live streams. This article is intended as a starting point for exploring the various delivery mechanisms of web-based media and compatibility with popular browsers.

Audio and Video manipulation

Having native audio and video in the browser means we can use these data streams with technologies such as <canvas>, WebGL or Web Audio API to modify audio and video directly, for example adding reverb/compression effects to audio, or grayscale/sepia filters to video.

Autoplay guide for media and Web Audio APIs

Unexpected automatic playback of media or audio can be an unwelcome surprise to users. While autoplay serves a purpose, it should be used carefully. To give users control over this, many browsers now provide forms of autoplay blocking. This article is a guide to autoplay, with tips on when and how to use it and how to work with browsers to handle autoplay blocking gracefully.

DASH Adaptive Streaming for HTML 5 Video

Dynamic Adaptive Streaming over HTTP (DASH) is an adaptive streaming protocol. This means that it allows for a video stream to switch between bit rates on the basis of network performance, in order to keep a video playing.

Streaming audio and video

A guide which covers how to stream audio and video, as well as techniques and technologies you can take advantage of to ensure the best possible quality and/or performance of your streams.

Media types and formats on the web

A guide to the file types and codecs available for images, audio, and video media on the web. This includes recommendations for what formats to use for what kinds of content, best practices including how to provide fallbacks and how to prioritize media types, and also includes general browser support information for each media container and codec.

Using images in HTML

A guide to adding images to websites that are responsive, accessible, and performant.

ReferencesHTMLThese articles describe the HTML elements used for including media:

<audio>

The <audio> element is used to play audio. These can be used invisibly as a destination for more complex media, or with visible controls for user-controlled playback of audio files. Accessible from JavaScript as HTMLAudioElement objects.

<video>

The <video> element is used to play video content. It can be used to present video files, or as a destination for streamed video content. <video> can also be used as a way to link media APIs with other HTML and DOM technologies, including <canvas> (for frame grabbing and manipulation), for example. It is accessible from JavaScript as HTMLVideoElement objects.

<track>

The HTML <track> element can be placed within an <audio> or <video> element to provide a reference to a WebVTT format subtitle or caption track to be used when playing the media. Accessible from JavaScript as HTMLTrackElement objects.

<source>

The HTML <source> element is used within an <audio> or <video> element to specify source media to present. Multiple sources can be used to provide the media in different formats, sizes, or resolutions. Accessible from JavaScript as HTMLSourceElement objects.

APIs
Media Capabilities API

The Media Capabilities API lets you determine the encoding and decoding capabilities of the device your app or site is running on. This lets you make real-time decisions about what formats to use and when.

Media Capture and Streams API

A reference for the API which makes it possible to stream, record, and manipulate media both locally and across a network. This includes using local cameras and microphones to capture video, audio, and still images.

Media Session API

The Media Session API provides a way to customize media notifications. It does this by providing metadata for display by the user agent for the media your web app is playing. It also provides action handlers that the browser can use to access platform media keys such as hardware keys found on keyboards, headsets, remote controls, and software keys found in notification areas and on lock screens of mobile devices.

MediaStream Recording API

The MediaStream Recording API lets you capture media streams to process or filter the data or record it to disk.

Web Audio API

The Web Audio API lets you generate, filter, and manipulate sound data both in real-time and on pre-recorded material, then send that audio to a destination such as an <audio> element, a media stream, or to disk.

WebRTC

WebRTC (Web Real-Time Communication) makes it possible to stream live audio and video, as well as transfer arbitrary data, between two peers over the Internet, without requiring an intermediary.

Related topicsRelated topics which may be of interest, since they can be used in tandem with media APIs in interesting ways.

Accessible multimedia

In this guide, we cover ways web designers and developers can create content that is accessible to people with different capabilities. This ranges from using the alt attribute on <img> elements to captions to tagging media for screen readers.

Canvas API

The Canvas API lets you draw into an <canvas>, manipulating and changing the contents of an image. This can be used with media in many ways, including by setting a <canvas> element as the destination for video playback or camera capture so that you can capture and manipulate video frames.

WebGL

WebGL provides an OpenGL ES compatible API on top of the existing Canvas API, making it possible to do powerful 3D graphics on the Web. Through a canvas, this can be used to add 3D imagery to media content.

WebXR

WebXR, which has replaced the now-obsolete WebVR API, is a technology that provides support for creating virtual reality (VR) and augmented reality (AR) content. The mixed reality content can then be displayed on the device's screen or using goggles or a headset.

WebVR 
Deprecated


The Web Virtual Reality API supports virtual reality (VR) devices such as the Oculus Rift or the HTC Vive, making it possible for developers to translate position and movement of the user into movement within a 3D scene which is then presented on the device. WebVR has been replaced by WebXR, and is due to be removed from browsers soon.

Web Audio spatialization basics

In 3D environments, which may either be 3D scenes rendered to the screen or a mixed reality experience experienced using a headset, it's important for audio to be performed so that it sounds like it's coming from the direction of its source. This guide covers how to accomplish this.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nPrivacy on the webPeople use websites for several important tasks such as banking, shopping, entertainment, and paying their taxes. In doing so, they are required to share personal information with those sites. Users place a certain level of trust in the sites they share their data with. If that information fell into the wrong hands, it could be used to exploit users, for example by profiling them, targeting them with unwanted ads, or even stealing their identity or money.
Modern browsers already have a wealth of features to protect users' privacy on the web, but that's not enough. To create a trustworthy and privacy-respecting experience, developers need to educate their site users in good practices (and enforce them). Developers should also create sites that collect as little data from users as possible, use the data responsibly, and transport and store it securely.
In this article, we:

Define privacy and important related terms.
Examine browser features that automatically protect user privacy.
Look at what developers can do to create privacy-respecting web content that minimizes the risk of users' personal information/data being obtained unexpectedly by third parties.
Defining privacy terms and conceptsBefore we look at the various privacy and security features available to use on the web, let's define some important terms.Privacy and its relationship with securityIt is hard to talk about privacy without also talking about security — they are closely related, and you can't really create privacy-respecting websites without good security. Therefore, we shall define both.


Privacy refers to the act of giving users the right to control how their data is collected, stored, and used, and not using it irresponsibly. For example, you should clearly communicate to your users what data you are collecting, who it will be shared with, and how it will be used. Users must be given a chance to consent to your terms of data usage, have access to all of their data that you are storing, and delete it if they no longer wish you to have it. You must also comply with your own terms: nothing erodes user trust like having their data used and shared in ways they never consented to. And this isn't just ethically wrong; it could be against the law. Many parts of the world now have legislation that protects consumer privacy rights (for example the EU's GDPR).


Security is the act of keeping private data and systems protected against unauthorized access. This includes both company (internal) data, and user and partner (external) data. It is no use having a robust privacy policy that makes your users trust you if your security is weak and malicious parties can steal their data anyway.

Personal and private informationPersonal information is any information that describes a user. Examples include:

Postal address, email address, phone number, or other contact information
Passport number, bank account, credit card, social security number, or other official identifiers
Physical attributes such as height, gender expression, weight, hair color, or age
Health information such as medical history, allergies, or ongoing conditions
Usernames, when they can be linked to an individual
Hobbies, interests, or other personal preferences
Biometric data such as fingerprints or facial recognition data

Private information is any information that users do not want shared publicly and must be kept private (i.e., information that is accessible only by a certain group of authorized users). Some private data is private by law (for example medical data), and some is private more by personal preference.Personally identifiable informationFollowing on from the above section, personally identifiable information (PII) is information that can be used, in whole or in part, to track down and/or identify a specific person. For example, if a site leaks a list of users' names and zip codes online, a bad actor could almost certainly use this information to find their full addresses. Even if a full-scale leak does not happen, it is still possible to identify users through less obvious means, such as the browsers they are using, the devices they are using, specific fonts they have installed, and so on.TrackingTracking refers to the process of recording a user's activity across many different websites. This can be done in various ways, for example:

Looking at multiple third-party cookies set across different sites where third-party content is embedded to find out various information points about the user.
Looking at the Referer header to see where a user has navigated from.
Including parameters on the URLs of inbound links (for example in embedded ads linking to product pages, or marketing emails) that can reveal to the linked site where the link originated from, what marketing campaign it is part of, the email address or other identifier of the user that clicked on it, etc. This process is referred to as link decorating, and results in link URLs that look like this: https://example.com/article/?id=62yhgt1a&campaign=902.
Redirect tracking, which involves trackers momentarily (and imperceptibly) redirecting a user to their website to use first-party storage to track that user across websites. This allows trackers to get around third-party cookies being blocked. For example, if you have read a product review and want to click through to buy it, you might unwittingly navigate to the redirect tracker first, then to the retailer. This means the tracker is loaded as a first party, and can associate tracking data with the identifiers they have stored in their first-party cookies before forwarding you to the retailer.

Tracking data can be used to build a profile of a user and their interests and preferences, which is usually bad and can be annoying to various degrees. For example:

Targeted ads: Everyone has had the unnerving experience of researching some items to buy on one device and then suddenly being bombarded by adverts for the same products on all their other devices.
Selling or sharing data: Some third parties have been known to compile tracking data and then sell it to/share it with others to use for various purposes, like targeted ads. This is obviously highly unethical and may also be illegal, depending on where in the world it happens.
Prejudice via data: In the worst cases, sharing data could result in the user being unfairly disadvantaged. For example, imagine an insurance company finding out data points about a potential customer that they didn't consent to share, and using them as a justification for increasing insurance premiums.
FingerprintingA process very closely related to tracking is fingerprinting: this specifically refers to identifying users by building up a store of data points about them that differentiate them from other users. This could be anything from cookie contents to what browser they are using and what fonts they have installed locally.
Modern browsers take steps to help prevent fingerprinting-based attacks by either not allowing information to be accessed or, where the information must be made available, by introducing variations or "noise" that prevent it from being used for identification purposes.
For example, if a website queries a user's browser for the elapsed time, a comparison of that time to the time reported by the server might be useful as a factor in fingerprinting. Because of this, browsers typically introduce a small amount of variability to timers to make them less useful for identifying the user's system.

Note:
See Fingerprinting on web.dev for additional useful information.
Privacy features provided by browsersBrowser vendors are aware of the need to protect user privacy and the negative effects of tracking, fingerprinting, etc., on user experience. To this end, they have implemented various features that enhance privacy protection and/or mitigate threats. In this section, we look at different categories of privacy protection that browsers apply automatically.HTTPS by defaultTransport Layer Security (TLS) provides security and privacy by encrypting data during transport over the network and is the technology behind the HTTPS protocol. TLS is good for privacy because it stops third parties from being able to intercept transmitted data and use it maliciously, for example for tracking.
All browsers are moving towards requiring HTTPS by default; this is practically the case already because you can't do much on the web without this protocol.
Related topics are as follows:

Certificate Transparency

An open standard for monitoring and auditing certificates, creating a database of public logs that can be used to help identify incorrect or malicious certificates.

HTTP Strict Transport Security (HSTS)

HSTS is used by servers to let them protect themselves from protocol downgrade and cookie hijack attacks by letting sites tell clients that they can only use HTTPS to communicate with the server.

HTTP/2

While HTTP/2 technically does not have to use encryption, most browser developers support it only when used with HTTPS; so in that regard, it can be thought of as a feature to enhance security/privacy.

Opt-in for "powerful features"So-called "powerful" web API features that provide access to potentially sensitive data and operations are available only in secure contexts, which basically means HTTPS-only. Not only that, but these web features are gated behind a system of user permissions. Users have to explicitly opt in to features like allowing notifications, accessing geolocation data, making the browser go into fullscreen mode, accessing media streams from webcams, using web payments, etc.Anti-tracking technologyBrowsers have implemented several anti-tracking features that automatically enhance their users' privacy protection. Many of these block or limit the ability of third-party sites embedded in <iframe>s to access cookies set on the top-level domain, run tracking scripts, etc.

The Set-Cookie header SameSite attribute's default value has been updated to Lax, to provide better protection against tracking and CSRF attacks. See Controlling third-party cookies with SameSite for more information.
Browsers have all started to block third-party cookies by default. See How do browsers handle third-party cookies? for more details.
Browsers are implementing technologies to allow third-party cookies only in certain circumstances that do not damage privacy, or to implement common use cases that currently require third-party cookies in alternative ways. See Transitioning from third-party cookies and Replacing third-party cookies.
Several browsers strip out known tracking parameters from URLs — this includes Firefox, Safari, and Brave. Browser extensions also help to do this, for example ClearURLs.
Browsers have implemented redirect tracking protection.
Privacy considerations for client-side developersThere are several actions web developers can and should take to improve privacy for their users. The below sections discuss the most important ones. Some of the categories are not purely technical tasks as such and will involve collaboration with other team members.Collect data ethicallyCompanies collect lots of different data from their users for a variety of different reasons:

Usernames, passwords, emails, etc. for authentication purposes.
Emails, postal addresses, and phone numbers for communication.
Age, gender, geographical location, favorite pastimes, and a host of other PII for anything from site personalization to customer satisfaction surveys.
Browsing habits on their sites and other sites, to measure page and feature success metrics.
And so much more.

When collecting data from your customers, you have an opportunity to behave with integrity, show them that you are trustworthy, and build a great relationship with them, in turn, improving your brand and your chance of success.
The ethics of data collection can be broken down into three simple principles:

Don't collect more data than you need
Communicate clearly how you are going to use the data you collect
Delete the data once you have finished with it


Note:
The tips provided below make for a better, more privacy-aware user experience, but many of them are required by law to comply with regulations, for example the GDPR in the EU. You should make sure to find out what regulations apply to you in your locale, and what you need to do to comply with them.
Don't collect more data than you needIt is tempting to ask for a lot of data from your users because you think it might be useful in the future. However, every bit of extra data you collect adds risk to your users' privacy and increases the chance that they will abandon the step they are performing (whether it is filling out a survey or signing up for a service).
It is good to anonymize data. You should also consider whether you can get what you need by making your data request less granular. As an example, instead of asking a user their favorite products, you could ask them to select between more general categories.
The best way to protect user privacy though, is to minimize the data you collect. Referring to the previous example, you could infer the same data by looking at user purchase history. As another example, users appreciate being able to buy products anonymously. You shouldn't force them to sign up for an account; if it's not necessary for the service to operate, it should be their choice.Communicate clearly how you are going to use the data you collectOnce you have decided what data you are going to collect, you should publish a privacy policy on your site that clearly states:

Data that you collect
Ways in which you use the data
Parties with whom you tend to share the data, if at all, and a declaration that you will ask for user consent before sharing
The duration for which you keep the data before it is deleted
Ways in which users can view the data you have collected from them and delete it if they want to

When providing you with data, your users should be given an opportunity to read your privacy policy, and consent to it. They should be able to control if they are happy with this and agree to your terms. And as indicated above, they should also get to see what data of theirs you have collected, and delete it if they want to.
When you've published your privacy policy, you need to make sure that you comply with it — doing what you say you are going to do is very important in building user trust. You should only collect the data you say you'll collect, and only use it for the purpose you say you'll use it for. If someone from your company comes up with a clever new way to use existing data, that still isn't OK under the terms of your policy if it doesn't specify that you'll use it for that purpose. If users consented to the use of their data for a specific purpose and that purpose expands, you may have to consider obtaining new consent.Delete the data once you have finished with itEarlier on, we mentioned giving users a way to see what data of theirs you have collected, and delete it if they want to. You could possibly do this as part of the same experience they can use to delete their account (their data goes with it), or make them two separate options. Either way, the options should be easy to find.
Allowing the user to choose when significant portions of data get deleted is very empowering, and builds trust, but there may be some bits of data that you will want to handle deletion of yourself. For example, some data might only be used for a few hours or minutes and then deleted, like data that is used during the administration of a user's session while they are logged in.

Note:
The Clear-Site-Data HTTP response header is very useful for clearing short-lived user data — it instructs the browser to clear out its cache and/or cookies and/or storage (e.g., Web Storage or IndexedDB data). For example, you might get your server to send it along with a "logged out confirmation" page so that once the user is logged out, their data is safely removed.
Cut down on trackingEarlier on we discussed tracking, and some of the unethical purposes it is used for. We shouldn't have to spell out how such uses can erode user trust; wherever possible, you should only use potential tracking mechanisms like third-party cookies for ethical uses, such as transferring sign-in or other personalization status across sites.
Also recall from earlier that browsers are all starting to block third-party cookies by default, while implementing alternative technologies to achieve common use case. It is a good idea to prepare for this, by limiting the amount of tracking activities you rely on, and/or implementing desired information persistence in other ways. See Transitioning from third-party cookies for more information.Carefully manage third-party resourcesOf course, it would be easy to manage privacy if you were only worried about resources you have created (code, cookies, sites, etc.). The real challenge comes from the fact that your site will likely use third-party resources. This can include third-party content embedded in <iframe>s, libraries, frameworks, APIs, externally-hosted resources such as images and videos, etc.
Third-party resources are an essential part of modern web development, they provide a lot of power. However, any third-party resource you allow onto your site potentially has the same permissions as your own resources; it all depends on how it is included on your site:

JavaScript running inside third-party content embedded in your site via an <iframe> is separated by same-origin policy, meaning that it wouldn't have access to other scripts and data included in the top-level browsing context.
However, a third-party script included directly in your page via a <script> element would have access to your other scripts and data, whether it was hosted on your site or another site. It would effectively be first-party code. A malicious script included in this way could secretly steal your users' data, for example sending it off to a third-party server.

It is important to audit all of the third-party resources you use on your site. Make sure you know what data they collect, what requests they make and to whom, and what their privacy policies are. Your carefully designed privacy policy is useless if you use a third-party script that violates it.

Note:
There are various tools out there that can help you build up a picture of what requests a site is making, for example the Request Map Generator.

Once you have audited your third-party resources and understand what they are doing, you should then consider their negatives as a trade-off for the value they bring. If a third-party script is free and really useful but collects quite a lot of user data, you could:

Accept that trade-off, update your privacy policy to include details of it, and hope that it doesn't impact your users' trust too much.
Look for an alternative, less data-hungry third-party tool.
Build your own tool.

The following list provides some tips on how to mitigate privacy risks inherent with using third-party resources:


When embedding third-party resources, consider if there is a way to achieve the same or a similar effect with less privacy impact. For example, it might be fun to have a social media post viewer embedded on your site, but is it really necessary? Wouldn't a link to your social media page be sufficient? Also, some third-party services have privacy-enhancing options. See, for example, YouTube's Embed videos & playlists > Turn on privacy-enhanced mode.


Where possible, you should block third parties from receiving a Referer header when you make requests to them. This can be done in a pretty granular way, for example by including rel="noreferrer" on external links. Or, you could set this more globally for the page or site, for example by using the Referrer-Policy header.

Note:
See also Referer header: privacy and security concerns.



Use the Permissions-Policy HTTP header to control access to API "powerful features" (such as notifications, geolocation data, accessing media streams from webcams, etc.). This can be useful for privacy because it stops third-party sites from doing unexpected things with these features, and users don't want to be unnecessarily bombarded by permission prompts that they may not understand. You can also control usage of "powerful features" inside third-party sites embedded inside <iframe> elements by specifying permissions policies inside an allow attribute on the <iframe> itself.

Note:
See also our Permissions-Policy guide for more information and examples, and permissionspolicy.com for useful tools including a policy generator.



Use the <iframe> sandbox attribute to allow or disallow usage of certain features inside the content embedded in the <iframe> — this includes things like downloads, form submissions, modals, and scripting.



Note:
See Third parties over on web.dev for additional useful information on auditing and more.
Protect user dataYou need to make sure that user data is transmitted and stored securely once you've collected it. This is more of a security topic, but it is worth mentioning here — a good privacy policy is useless if your security is lax and attackers can steal the data from you.
The below tips offer some guidance on protecting your user's data:

Security is hard to get right. When implementing a secure solution that involves data collection — particularly if it is sensitive data such as sign-in credentials — it makes sense to use a reputable solution from a well-respected provider. For example, any respectable server-side framework will have built-in features to protect against common vulnerabilities. You could also consider using a specialized product for your purpose — for example an identity provider solution, or a secure online survey provider.
If you want to roll out your own solution for collecting user data, make sure you understand what you are doing. Hire an experienced server-side developer and/or security engineer to implement the system, and ensure it is tested thoroughly. Use multifactor authentication (MFA) to provide better protection. Consider using a dedicated API such as Web Authentication or Federated Credential Management to streamline the client-side of the app.
When collecting user sign-up information, enforce strong passwords so your user's account details cannot be easily guessed. Weak passwords are one of the main causes of security breaches. Encourage your users to use a password manager to generate and store complex passwords; this way they won't worry about remembering them, or create a security risk by writing them down.
Don't include sensitive data in URLs — if a third party intercepts the URL (for example via the Referer header), they could steal that information. Use POST requests rather than GET requests to avoid this.
Consider using tools like Content Security Policy and Permissions Policy to enforce a set of feature usage on your site that makes it harder to introduce vulnerabilities. Be careful when doing this — if you block usage of a feature that a third-party script relies on to work, you may end up breaking your site's functionality. This is something you can look into when auditing your third-party resources (see Carefully manage third-party resources).
See also
Web security
Learn Privacy on web.dev
The Privacy Sandbox on privacysandbox.google.com
Lean Data Practices on mozilla.org\n\nPrivacy on the webPeople use websites for several important tasks such as banking, shopping, entertainment, and paying their taxes. In doing so, they are required to share personal information with those sites. Users place a certain level of trust in the sites they share their data with. If that information fell into the wrong hands, it could be used to exploit users, for example by profiling them, targeting them with unwanted ads, or even stealing their identity or money.
Modern browsers already have a wealth of features to protect users' privacy on the web, but that's not enough. To create a trustworthy and privacy-respecting experience, developers need to educate their site users in good practices (and enforce them). Developers should also create sites that collect as little data from users as possible, use the data responsibly, and transport and store it securely.
In this article, we:

Define privacy and important related terms.
Examine browser features that automatically protect user privacy.
Look at what developers can do to create privacy-respecting web content that minimizes the risk of users' personal information/data being obtained unexpectedly by third parties.
Defining privacy terms and conceptsBefore we look at the various privacy and security features available to use on the web, let's define some important terms.Privacy and its relationship with securityIt is hard to talk about privacy without also talking about security — they are closely related, and you can't really create privacy-respecting websites without good security. Therefore, we shall define both.


Privacy refers to the act of giving users the right to control how their data is collected, stored, and used, and not using it irresponsibly. For example, you should clearly communicate to your users what data you are collecting, who it will be shared with, and how it will be used. Users must be given a chance to consent to your terms of data usage, have access to all of their data that you are storing, and delete it if they no longer wish you to have it. You must also comply with your own terms: nothing erodes user trust like having their data used and shared in ways they never consented to. And this isn't just ethically wrong; it could be against the law. Many parts of the world now have legislation that protects consumer privacy rights (for example the EU's GDPR).


Security is the act of keeping private data and systems protected against unauthorized access. This includes both company (internal) data, and user and partner (external) data. It is no use having a robust privacy policy that makes your users trust you if your security is weak and malicious parties can steal their data anyway.

Personal and private informationPersonal information is any information that describes a user. Examples include:

Postal address, email address, phone number, or other contact information
Passport number, bank account, credit card, social security number, or other official identifiers
Physical attributes such as height, gender expression, weight, hair color, or age
Health information such as medical history, allergies, or ongoing conditions
Usernames, when they can be linked to an individual
Hobbies, interests, or other personal preferences
Biometric data such as fingerprints or facial recognition data

Private information is any information that users do not want shared publicly and must be kept private (i.e., information that is accessible only by a certain group of authorized users). Some private data is private by law (for example medical data), and some is private more by personal preference.Personally identifiable informationFollowing on from the above section, personally identifiable information (PII) is information that can be used, in whole or in part, to track down and/or identify a specific person. For example, if a site leaks a list of users' names and zip codes online, a bad actor could almost certainly use this information to find their full addresses. Even if a full-scale leak does not happen, it is still possible to identify users through less obvious means, such as the browsers they are using, the devices they are using, specific fonts they have installed, and so on.TrackingTracking refers to the process of recording a user's activity across many different websites. This can be done in various ways, for example:

Looking at multiple third-party cookies set across different sites where third-party content is embedded to find out various information points about the user.
Looking at the Referer header to see where a user has navigated from.
Including parameters on the URLs of inbound links (for example in embedded ads linking to product pages, or marketing emails) that can reveal to the linked site where the link originated from, what marketing campaign it is part of, the email address or other identifier of the user that clicked on it, etc. This process is referred to as link decorating, and results in link URLs that look like this: https://example.com/article/?id=62yhgt1a&campaign=902.
Redirect tracking, which involves trackers momentarily (and imperceptibly) redirecting a user to their website to use first-party storage to track that user across websites. This allows trackers to get around third-party cookies being blocked. For example, if you have read a product review and want to click through to buy it, you might unwittingly navigate to the redirect tracker first, then to the retailer. This means the tracker is loaded as a first party, and can associate tracking data with the identifiers they have stored in their first-party cookies before forwarding you to the retailer.

Tracking data can be used to build a profile of a user and their interests and preferences, which is usually bad and can be annoying to various degrees. For example:

Targeted ads: Everyone has had the unnerving experience of researching some items to buy on one device and then suddenly being bombarded by adverts for the same products on all their other devices.
Selling or sharing data: Some third parties have been known to compile tracking data and then sell it to/share it with others to use for various purposes, like targeted ads. This is obviously highly unethical and may also be illegal, depending on where in the world it happens.
Prejudice via data: In the worst cases, sharing data could result in the user being unfairly disadvantaged. For example, imagine an insurance company finding out data points about a potential customer that they didn't consent to share, and using them as a justification for increasing insurance premiums.
FingerprintingA process very closely related to tracking is fingerprinting: this specifically refers to identifying users by building up a store of data points about them that differentiate them from other users. This could be anything from cookie contents to what browser they are using and what fonts they have installed locally.
Modern browsers take steps to help prevent fingerprinting-based attacks by either not allowing information to be accessed or, where the information must be made available, by introducing variations or "noise" that prevent it from being used for identification purposes.
For example, if a website queries a user's browser for the elapsed time, a comparison of that time to the time reported by the server might be useful as a factor in fingerprinting. Because of this, browsers typically introduce a small amount of variability to timers to make them less useful for identifying the user's system.

Note:
See Fingerprinting on web.dev for additional useful information.
Privacy features provided by browsersBrowser vendors are aware of the need to protect user privacy and the negative effects of tracking, fingerprinting, etc., on user experience. To this end, they have implemented various features that enhance privacy protection and/or mitigate threats. In this section, we look at different categories of privacy protection that browsers apply automatically.HTTPS by defaultTransport Layer Security (TLS) provides security and privacy by encrypting data during transport over the network and is the technology behind the HTTPS protocol. TLS is good for privacy because it stops third parties from being able to intercept transmitted data and use it maliciously, for example for tracking.
All browsers are moving towards requiring HTTPS by default; this is practically the case already because you can't do much on the web without this protocol.
Related topics are as follows:

Certificate Transparency

An open standard for monitoring and auditing certificates, creating a database of public logs that can be used to help identify incorrect or malicious certificates.

HTTP Strict Transport Security (HSTS)

HSTS is used by servers to let them protect themselves from protocol downgrade and cookie hijack attacks by letting sites tell clients that they can only use HTTPS to communicate with the server.

HTTP/2

While HTTP/2 technically does not have to use encryption, most browser developers support it only when used with HTTPS; so in that regard, it can be thought of as a feature to enhance security/privacy.

Opt-in for "powerful features"So-called "powerful" web API features that provide access to potentially sensitive data and operations are available only in secure contexts, which basically means HTTPS-only. Not only that, but these web features are gated behind a system of user permissions. Users have to explicitly opt in to features like allowing notifications, accessing geolocation data, making the browser go into fullscreen mode, accessing media streams from webcams, using web payments, etc.Anti-tracking technologyBrowsers have implemented several anti-tracking features that automatically enhance their users' privacy protection. Many of these block or limit the ability of third-party sites embedded in <iframe>s to access cookies set on the top-level domain, run tracking scripts, etc.

The Set-Cookie header SameSite attribute's default value has been updated to Lax, to provide better protection against tracking and CSRF attacks. See Controlling third-party cookies with SameSite for more information.
Browsers have all started to block third-party cookies by default. See How do browsers handle third-party cookies? for more details.
Browsers are implementing technologies to allow third-party cookies only in certain circumstances that do not damage privacy, or to implement common use cases that currently require third-party cookies in alternative ways. See Transitioning from third-party cookies and Replacing third-party cookies.
Several browsers strip out known tracking parameters from URLs — this includes Firefox, Safari, and Brave. Browser extensions also help to do this, for example ClearURLs.
Browsers have implemented redirect tracking protection.
Privacy considerations for client-side developersThere are several actions web developers can and should take to improve privacy for their users. The below sections discuss the most important ones. Some of the categories are not purely technical tasks as such and will involve collaboration with other team members.Collect data ethicallyCompanies collect lots of different data from their users for a variety of different reasons:

Usernames, passwords, emails, etc. for authentication purposes.
Emails, postal addresses, and phone numbers for communication.
Age, gender, geographical location, favorite pastimes, and a host of other PII for anything from site personalization to customer satisfaction surveys.
Browsing habits on their sites and other sites, to measure page and feature success metrics.
And so much more.

When collecting data from your customers, you have an opportunity to behave with integrity, show them that you are trustworthy, and build a great relationship with them, in turn, improving your brand and your chance of success.
The ethics of data collection can be broken down into three simple principles:

Don't collect more data than you need
Communicate clearly how you are going to use the data you collect
Delete the data once you have finished with it


Note:
The tips provided below make for a better, more privacy-aware user experience, but many of them are required by law to comply with regulations, for example the GDPR in the EU. You should make sure to find out what regulations apply to you in your locale, and what you need to do to comply with them.
Don't collect more data than you needIt is tempting to ask for a lot of data from your users because you think it might be useful in the future. However, every bit of extra data you collect adds risk to your users' privacy and increases the chance that they will abandon the step they are performing (whether it is filling out a survey or signing up for a service).
It is good to anonymize data. You should also consider whether you can get what you need by making your data request less granular. As an example, instead of asking a user their favorite products, you could ask them to select between more general categories.
The best way to protect user privacy though, is to minimize the data you collect. Referring to the previous example, you could infer the same data by looking at user purchase history. As another example, users appreciate being able to buy products anonymously. You shouldn't force them to sign up for an account; if it's not necessary for the service to operate, it should be their choice.Communicate clearly how you are going to use the data you collectOnce you have decided what data you are going to collect, you should publish a privacy policy on your site that clearly states:

Data that you collect
Ways in which you use the data
Parties with whom you tend to share the data, if at all, and a declaration that you will ask for user consent before sharing
The duration for which you keep the data before it is deleted
Ways in which users can view the data you have collected from them and delete it if they want to

When providing you with data, your users should be given an opportunity to read your privacy policy, and consent to it. They should be able to control if they are happy with this and agree to your terms. And as indicated above, they should also get to see what data of theirs you have collected, and delete it if they want to.
When you've published your privacy policy, you need to make sure that you comply with it — doing what you say you are going to do is very important in building user trust. You should only collect the data you say you'll collect, and only use it for the purpose you say you'll use it for. If someone from your company comes up with a clever new way to use existing data, that still isn't OK under the terms of your policy if it doesn't specify that you'll use it for that purpose. If users consented to the use of their data for a specific purpose and that purpose expands, you may have to consider obtaining new consent.Delete the data once you have finished with itEarlier on, we mentioned giving users a way to see what data of theirs you have collected, and delete it if they want to. You could possibly do this as part of the same experience they can use to delete their account (their data goes with it), or make them two separate options. Either way, the options should be easy to find.
Allowing the user to choose when significant portions of data get deleted is very empowering, and builds trust, but there may be some bits of data that you will want to handle deletion of yourself. For example, some data might only be used for a few hours or minutes and then deleted, like data that is used during the administration of a user's session while they are logged in.

Note:
The Clear-Site-Data HTTP response header is very useful for clearing short-lived user data — it instructs the browser to clear out its cache and/or cookies and/or storage (e.g., Web Storage or IndexedDB data). For example, you might get your server to send it along with a "logged out confirmation" page so that once the user is logged out, their data is safely removed.
Cut down on trackingEarlier on we discussed tracking, and some of the unethical purposes it is used for. We shouldn't have to spell out how such uses can erode user trust; wherever possible, you should only use potential tracking mechanisms like third-party cookies for ethical uses, such as transferring sign-in or other personalization status across sites.
Also recall from earlier that browsers are all starting to block third-party cookies by default, while implementing alternative technologies to achieve common use case. It is a good idea to prepare for this, by limiting the amount of tracking activities you rely on, and/or implementing desired information persistence in other ways. See Transitioning from third-party cookies for more information.Carefully manage third-party resourcesOf course, it would be easy to manage privacy if you were only worried about resources you have created (code, cookies, sites, etc.). The real challenge comes from the fact that your site will likely use third-party resources. This can include third-party content embedded in <iframe>s, libraries, frameworks, APIs, externally-hosted resources such as images and videos, etc.
Third-party resources are an essential part of modern web development, they provide a lot of power. However, any third-party resource you allow onto your site potentially has the same permissions as your own resources; it all depends on how it is included on your site:

JavaScript running inside third-party content embedded in your site via an <iframe> is separated by same-origin policy, meaning that it wouldn't have access to other scripts and data included in the top-level browsing context.
However, a third-party script included directly in your page via a <script> element would have access to your other scripts and data, whether it was hosted on your site or another site. It would effectively be first-party code. A malicious script included in this way could secretly steal your users' data, for example sending it off to a third-party server.

It is important to audit all of the third-party resources you use on your site. Make sure you know what data they collect, what requests they make and to whom, and what their privacy policies are. Your carefully designed privacy policy is useless if you use a third-party script that violates it.

Note:
There are various tools out there that can help you build up a picture of what requests a site is making, for example the Request Map Generator.

Once you have audited your third-party resources and understand what they are doing, you should then consider their negatives as a trade-off for the value they bring. If a third-party script is free and really useful but collects quite a lot of user data, you could:

Accept that trade-off, update your privacy policy to include details of it, and hope that it doesn't impact your users' trust too much.
Look for an alternative, less data-hungry third-party tool.
Build your own tool.

The following list provides some tips on how to mitigate privacy risks inherent with using third-party resources:


When embedding third-party resources, consider if there is a way to achieve the same or a similar effect with less privacy impact. For example, it might be fun to have a social media post viewer embedded on your site, but is it really necessary? Wouldn't a link to your social media page be sufficient? Also, some third-party services have privacy-enhancing options. See, for example, YouTube's Embed videos & playlists > Turn on privacy-enhanced mode.


Where possible, you should block third parties from receiving a Referer header when you make requests to them. This can be done in a pretty granular way, for example by including rel="noreferrer" on external links. Or, you could set this more globally for the page or site, for example by using the Referrer-Policy header.

Note:
See also Referer header: privacy and security concerns.



Use the Permissions-Policy HTTP header to control access to API "powerful features" (such as notifications, geolocation data, accessing media streams from webcams, etc.). This can be useful for privacy because it stops third-party sites from doing unexpected things with these features, and users don't want to be unnecessarily bombarded by permission prompts that they may not understand. You can also control usage of "powerful features" inside third-party sites embedded inside <iframe> elements by specifying permissions policies inside an allow attribute on the <iframe> itself.

Note:
See also our Permissions-Policy guide for more information and examples, and permissionspolicy.com for useful tools including a policy generator.



Use the <iframe> sandbox attribute to allow or disallow usage of certain features inside the content embedded in the <iframe> — this includes things like downloads, form submissions, modals, and scripting.



Note:
See Third parties over on web.dev for additional useful information on auditing and more.
Protect user dataYou need to make sure that user data is transmitted and stored securely once you've collected it. This is more of a security topic, but it is worth mentioning here — a good privacy policy is useless if your security is lax and attackers can steal the data from you.
The below tips offer some guidance on protecting your user's data:

Security is hard to get right. When implementing a secure solution that involves data collection — particularly if it is sensitive data such as sign-in credentials — it makes sense to use a reputable solution from a well-respected provider. For example, any respectable server-side framework will have built-in features to protect against common vulnerabilities. You could also consider using a specialized product for your purpose — for example an identity provider solution, or a secure online survey provider.
If you want to roll out your own solution for collecting user data, make sure you understand what you are doing. Hire an experienced server-side developer and/or security engineer to implement the system, and ensure it is tested thoroughly. Use multifactor authentication (MFA) to provide better protection. Consider using a dedicated API such as Web Authentication or Federated Credential Management to streamline the client-side of the app.
When collecting user sign-up information, enforce strong passwords so your user's account details cannot be easily guessed. Weak passwords are one of the main causes of security breaches. Encourage your users to use a password manager to generate and store complex passwords; this way they won't worry about remembering them, or create a security risk by writing them down.
Don't include sensitive data in URLs — if a third party intercepts the URL (for example via the Referer header), they could steal that information. Use POST requests rather than GET requests to avoid this.
Consider using tools like Content Security Policy and Permissions Policy to enforce a set of feature usage on your site that makes it harder to introduce vulnerabilities. Be careful when doing this — if you block usage of a feature that a third-party script relies on to work, you may end up breaking your site's functionality. This is something you can look into when auditing your third-party resources (see Carefully manage third-party resources).
See also
Web security
Learn Privacy on web.dev
The Privacy Sandbox on privacysandbox.google.com
Lean Data Practices on mozilla.org
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nPrivacy on the webPeople use websites for several important tasks such as banking, shopping, entertainment, and paying their taxes. In doing so, they are required to share personal information with those sites. Users place a certain level of trust in the sites they share their data with. If that information fell into the wrong hands, it could be used to exploit users, for example by profiling them, targeting them with unwanted ads, or even stealing their identity or money.
Modern browsers already have a wealth of features to protect users' privacy on the web, but that's not enough. To create a trustworthy and privacy-respecting experience, developers need to educate their site users in good practices (and enforce them). Developers should also create sites that collect as little data from users as possible, use the data responsibly, and transport and store it securely.
In this article, we:

Define privacy and important related terms.
Examine browser features that automatically protect user privacy.
Look at what developers can do to create privacy-respecting web content that minimizes the risk of users' personal information/data being obtained unexpectedly by third parties.
Defining privacy terms and conceptsBefore we look at the various privacy and security features available to use on the web, let's define some important terms.Privacy and its relationship with securityIt is hard to talk about privacy without also talking about security — they are closely related, and you can't really create privacy-respecting websites without good security. Therefore, we shall define both.


Privacy refers to the act of giving users the right to control how their data is collected, stored, and used, and not using it irresponsibly. For example, you should clearly communicate to your users what data you are collecting, who it will be shared with, and how it will be used. Users must be given a chance to consent to your terms of data usage, have access to all of their data that you are storing, and delete it if they no longer wish you to have it. You must also comply with your own terms: nothing erodes user trust like having their data used and shared in ways they never consented to. And this isn't just ethically wrong; it could be against the law. Many parts of the world now have legislation that protects consumer privacy rights (for example the EU's GDPR).


Security is the act of keeping private data and systems protected against unauthorized access. This includes both company (internal) data, and user and partner (external) data. It is no use having a robust privacy policy that makes your users trust you if your security is weak and malicious parties can steal their data anyway.

Personal and private informationPersonal information is any information that describes a user. Examples include:

Postal address, email address, phone number, or other contact information
Passport number, bank account, credit card, social security number, or other official identifiers
Physical attributes such as height, gender expression, weight, hair color, or age
Health information such as medical history, allergies, or ongoing conditions
Usernames, when they can be linked to an individual
Hobbies, interests, or other personal preferences
Biometric data such as fingerprints or facial recognition data

Private information is any information that users do not want shared publicly and must be kept private (i.e., information that is accessible only by a certain group of authorized users). Some private data is private by law (for example medical data), and some is private more by personal preference.Personally identifiable informationFollowing on from the above section, personally identifiable information (PII) is information that can be used, in whole or in part, to track down and/or identify a specific person. For example, if a site leaks a list of users' names and zip codes online, a bad actor could almost certainly use this information to find their full addresses. Even if a full-scale leak does not happen, it is still possible to identify users through less obvious means, such as the browsers they are using, the devices they are using, specific fonts they have installed, and so on.TrackingTracking refers to the process of recording a user's activity across many different websites. This can be done in various ways, for example:

Looking at multiple third-party cookies set across different sites where third-party content is embedded to find out various information points about the user.
Looking at the Referer header to see where a user has navigated from.
Including parameters on the URLs of inbound links (for example in embedded ads linking to product pages, or marketing emails) that can reveal to the linked site where the link originated from, what marketing campaign it is part of, the email address or other identifier of the user that clicked on it, etc. This process is referred to as link decorating, and results in link URLs that look like this: https://example.com/article/?id=62yhgt1a&campaign=902.
Redirect tracking, which involves trackers momentarily (and imperceptibly) redirecting a user to their website to use first-party storage to track that user across websites. This allows trackers to get around third-party cookies being blocked. For example, if you have read a product review and want to click through to buy it, you might unwittingly navigate to the redirect tracker first, then to the retailer. This means the tracker is loaded as a first party, and can associate tracking data with the identifiers they have stored in their first-party cookies before forwarding you to the retailer.

Tracking data can be used to build a profile of a user and their interests and preferences, which is usually bad and can be annoying to various degrees. For example:

Targeted ads: Everyone has had the unnerving experience of researching some items to buy on one device and then suddenly being bombarded by adverts for the same products on all their other devices.
Selling or sharing data: Some third parties have been known to compile tracking data and then sell it to/share it with others to use for various purposes, like targeted ads. This is obviously highly unethical and may also be illegal, depending on where in the world it happens.
Prejudice via data: In the worst cases, sharing data could result in the user being unfairly disadvantaged. For example, imagine an insurance company finding out data points about a potential customer that they didn't consent to share, and using them as a justification for increasing insurance premiums.
FingerprintingA process very closely related to tracking is fingerprinting: this specifically refers to identifying users by building up a store of data points about them that differentiate them from other users. This could be anything from cookie contents to what browser they are using and what fonts they have installed locally.
Modern browsers take steps to help prevent fingerprinting-based attacks by either not allowing information to be accessed or, where the information must be made available, by introducing variations or "noise" that prevent it from being used for identification purposes.
For example, if a website queries a user's browser for the elapsed time, a comparison of that time to the time reported by the server might be useful as a factor in fingerprinting. Because of this, browsers typically introduce a small amount of variability to timers to make them less useful for identifying the user's system.

Note:
See Fingerprinting on web.dev for additional useful information.
Privacy features provided by browsersBrowser vendors are aware of the need to protect user privacy and the negative effects of tracking, fingerprinting, etc., on user experience. To this end, they have implemented various features that enhance privacy protection and/or mitigate threats. In this section, we look at different categories of privacy protection that browsers apply automatically.HTTPS by defaultTransport Layer Security (TLS) provides security and privacy by encrypting data during transport over the network and is the technology behind the HTTPS protocol. TLS is good for privacy because it stops third parties from being able to intercept transmitted data and use it maliciously, for example for tracking.
All browsers are moving towards requiring HTTPS by default; this is practically the case already because you can't do much on the web without this protocol.
Related topics are as follows:

Certificate Transparency

An open standard for monitoring and auditing certificates, creating a database of public logs that can be used to help identify incorrect or malicious certificates.

HTTP Strict Transport Security (HSTS)

HSTS is used by servers to let them protect themselves from protocol downgrade and cookie hijack attacks by letting sites tell clients that they can only use HTTPS to communicate with the server.

HTTP/2

While HTTP/2 technically does not have to use encryption, most browser developers support it only when used with HTTPS; so in that regard, it can be thought of as a feature to enhance security/privacy.

Opt-in for "powerful features"So-called "powerful" web API features that provide access to potentially sensitive data and operations are available only in secure contexts, which basically means HTTPS-only. Not only that, but these web features are gated behind a system of user permissions. Users have to explicitly opt in to features like allowing notifications, accessing geolocation data, making the browser go into fullscreen mode, accessing media streams from webcams, using web payments, etc.Anti-tracking technologyBrowsers have implemented several anti-tracking features that automatically enhance their users' privacy protection. Many of these block or limit the ability of third-party sites embedded in <iframe>s to access cookies set on the top-level domain, run tracking scripts, etc.

The Set-Cookie header SameSite attribute's default value has been updated to Lax, to provide better protection against tracking and CSRF attacks. See Controlling third-party cookies with SameSite for more information.
Browsers have all started to block third-party cookies by default. See How do browsers handle third-party cookies? for more details.
Browsers are implementing technologies to allow third-party cookies only in certain circumstances that do not damage privacy, or to implement common use cases that currently require third-party cookies in alternative ways. See Transitioning from third-party cookies and Replacing third-party cookies.
Several browsers strip out known tracking parameters from URLs — this includes Firefox, Safari, and Brave. Browser extensions also help to do this, for example ClearURLs.
Browsers have implemented redirect tracking protection.
Privacy considerations for client-side developersThere are several actions web developers can and should take to improve privacy for their users. The below sections discuss the most important ones. Some of the categories are not purely technical tasks as such and will involve collaboration with other team members.Collect data ethicallyCompanies collect lots of different data from their users for a variety of different reasons:

Usernames, passwords, emails, etc. for authentication purposes.
Emails, postal addresses, and phone numbers for communication.
Age, gender, geographical location, favorite pastimes, and a host of other PII for anything from site personalization to customer satisfaction surveys.
Browsing habits on their sites and other sites, to measure page and feature success metrics.
And so much more.

When collecting data from your customers, you have an opportunity to behave with integrity, show them that you are trustworthy, and build a great relationship with them, in turn, improving your brand and your chance of success.
The ethics of data collection can be broken down into three simple principles:

Don't collect more data than you need
Communicate clearly how you are going to use the data you collect
Delete the data once you have finished with it


Note:
The tips provided below make for a better, more privacy-aware user experience, but many of them are required by law to comply with regulations, for example the GDPR in the EU. You should make sure to find out what regulations apply to you in your locale, and what you need to do to comply with them.
Don't collect more data than you needIt is tempting to ask for a lot of data from your users because you think it might be useful in the future. However, every bit of extra data you collect adds risk to your users' privacy and increases the chance that they will abandon the step they are performing (whether it is filling out a survey or signing up for a service).
It is good to anonymize data. You should also consider whether you can get what you need by making your data request less granular. As an example, instead of asking a user their favorite products, you could ask them to select between more general categories.
The best way to protect user privacy though, is to minimize the data you collect. Referring to the previous example, you could infer the same data by looking at user purchase history. As another example, users appreciate being able to buy products anonymously. You shouldn't force them to sign up for an account; if it's not necessary for the service to operate, it should be their choice.Communicate clearly how you are going to use the data you collectOnce you have decided what data you are going to collect, you should publish a privacy policy on your site that clearly states:

Data that you collect
Ways in which you use the data
Parties with whom you tend to share the data, if at all, and a declaration that you will ask for user consent before sharing
The duration for which you keep the data before it is deleted
Ways in which users can view the data you have collected from them and delete it if they want to

When providing you with data, your users should be given an opportunity to read your privacy policy, and consent to it. They should be able to control if they are happy with this and agree to your terms. And as indicated above, they should also get to see what data of theirs you have collected, and delete it if they want to.
When you've published your privacy policy, you need to make sure that you comply with it — doing what you say you are going to do is very important in building user trust. You should only collect the data you say you'll collect, and only use it for the purpose you say you'll use it for. If someone from your company comes up with a clever new way to use existing data, that still isn't OK under the terms of your policy if it doesn't specify that you'll use it for that purpose. If users consented to the use of their data for a specific purpose and that purpose expands, you may have to consider obtaining new consent.Delete the data once you have finished with itEarlier on, we mentioned giving users a way to see what data of theirs you have collected, and delete it if they want to. You could possibly do this as part of the same experience they can use to delete their account (their data goes with it), or make them two separate options. Either way, the options should be easy to find.
Allowing the user to choose when significant portions of data get deleted is very empowering, and builds trust, but there may be some bits of data that you will want to handle deletion of yourself. For example, some data might only be used for a few hours or minutes and then deleted, like data that is used during the administration of a user's session while they are logged in.

Note:
The Clear-Site-Data HTTP response header is very useful for clearing short-lived user data — it instructs the browser to clear out its cache and/or cookies and/or storage (e.g., Web Storage or IndexedDB data). For example, you might get your server to send it along with a "logged out confirmation" page so that once the user is logged out, their data is safely removed.
Cut down on trackingEarlier on we discussed tracking, and some of the unethical purposes it is used for. We shouldn't have to spell out how such uses can erode user trust; wherever possible, you should only use potential tracking mechanisms like third-party cookies for ethical uses, such as transferring sign-in or other personalization status across sites.
Also recall from earlier that browsers are all starting to block third-party cookies by default, while implementing alternative technologies to achieve common use case. It is a good idea to prepare for this, by limiting the amount of tracking activities you rely on, and/or implementing desired information persistence in other ways. See Transitioning from third-party cookies for more information.Carefully manage third-party resourcesOf course, it would be easy to manage privacy if you were only worried about resources you have created (code, cookies, sites, etc.). The real challenge comes from the fact that your site will likely use third-party resources. This can include third-party content embedded in <iframe>s, libraries, frameworks, APIs, externally-hosted resources such as images and videos, etc.
Third-party resources are an essential part of modern web development, they provide a lot of power. However, any third-party resource you allow onto your site potentially has the same permissions as your own resources; it all depends on how it is included on your site:

JavaScript running inside third-party content embedded in your site via an <iframe> is separated by same-origin policy, meaning that it wouldn't have access to other scripts and data included in the top-level browsing context.
However, a third-party script included directly in your page via a <script> element would have access to your other scripts and data, whether it was hosted on your site or another site. It would effectively be first-party code. A malicious script included in this way could secretly steal your users' data, for example sending it off to a third-party server.

It is important to audit all of the third-party resources you use on your site. Make sure you know what data they collect, what requests they make and to whom, and what their privacy policies are. Your carefully designed privacy policy is useless if you use a third-party script that violates it.

Note:
There are various tools out there that can help you build up a picture of what requests a site is making, for example the Request Map Generator.

Once you have audited your third-party resources and understand what they are doing, you should then consider their negatives as a trade-off for the value they bring. If a third-party script is free and really useful but collects quite a lot of user data, you could:

Accept that trade-off, update your privacy policy to include details of it, and hope that it doesn't impact your users' trust too much.
Look for an alternative, less data-hungry third-party tool.
Build your own tool.

The following list provides some tips on how to mitigate privacy risks inherent with using third-party resources:


When embedding third-party resources, consider if there is a way to achieve the same or a similar effect with less privacy impact. For example, it might be fun to have a social media post viewer embedded on your site, but is it really necessary? Wouldn't a link to your social media page be sufficient? Also, some third-party services have privacy-enhancing options. See, for example, YouTube's Embed videos & playlists > Turn on privacy-enhanced mode.


Where possible, you should block third parties from receiving a Referer header when you make requests to them. This can be done in a pretty granular way, for example by including rel="noreferrer" on external links. Or, you could set this more globally for the page or site, for example by using the Referrer-Policy header.

Note:
See also Referer header: privacy and security concerns.



Use the Permissions-Policy HTTP header to control access to API "powerful features" (such as notifications, geolocation data, accessing media streams from webcams, etc.). This can be useful for privacy because it stops third-party sites from doing unexpected things with these features, and users don't want to be unnecessarily bombarded by permission prompts that they may not understand. You can also control usage of "powerful features" inside third-party sites embedded inside <iframe> elements by specifying permissions policies inside an allow attribute on the <iframe> itself.

Note:
See also our Permissions-Policy guide for more information and examples, and permissionspolicy.com for useful tools including a policy generator.



Use the <iframe> sandbox attribute to allow or disallow usage of certain features inside the content embedded in the <iframe> — this includes things like downloads, form submissions, modals, and scripting.



Note:
See Third parties over on web.dev for additional useful information on auditing and more.
Protect user dataYou need to make sure that user data is transmitted and stored securely once you've collected it. This is more of a security topic, but it is worth mentioning here — a good privacy policy is useless if your security is lax and attackers can steal the data from you.
The below tips offer some guidance on protecting your user's data:

Security is hard to get right. When implementing a secure solution that involves data collection — particularly if it is sensitive data such as sign-in credentials — it makes sense to use a reputable solution from a well-respected provider. For example, any respectable server-side framework will have built-in features to protect against common vulnerabilities. You could also consider using a specialized product for your purpose — for example an identity provider solution, or a secure online survey provider.
If you want to roll out your own solution for collecting user data, make sure you understand what you are doing. Hire an experienced server-side developer and/or security engineer to implement the system, and ensure it is tested thoroughly. Use multifactor authentication (MFA) to provide better protection. Consider using a dedicated API such as Web Authentication or Federated Credential Management to streamline the client-side of the app.
When collecting user sign-up information, enforce strong passwords so your user's account details cannot be easily guessed. Weak passwords are one of the main causes of security breaches. Encourage your users to use a password manager to generate and store complex passwords; this way they won't worry about remembering them, or create a security risk by writing them down.
Don't include sensitive data in URLs — if a third party intercepts the URL (for example via the Referer header), they could steal that information. Use POST requests rather than GET requests to avoid this.
Consider using tools like Content Security Policy and Permissions Policy to enforce a set of feature usage on your site that makes it harder to introduce vulnerabilities. Be careful when doing this — if you block usage of a feature that a third-party script relies on to work, you may end up breaking your site's functionality. This is something you can look into when auditing your third-party resources (see Carefully manage third-party resources).
See also
Web security
Learn Privacy on web.dev
The Privacy Sandbox on privacysandbox.google.com
Lean Data Practices on mozilla.org
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nProgressive web appsA progressive web app (PWA) is an app that's built using web platform technologies, but that provides a user experience like that of a platform-specific app.
Like a website, a PWA can run on multiple platforms and devices from a single codebase. Like a platform-specific app, it can be installed on the device, can operate while offline and in the background, and can integrate with the device and with other installed apps.GuidesThese guides give conceptual explanations of different aspects of PWAs. They're intended to help you understand what kinds of things are possible with PWAs, and to provide enough pointers to help you understand how to achieve them.

What is a progressive web app?

An introduction to PWAs, comparing them with traditional websites and with platform-specific apps, and outlining their main features.

Making PWAs installable

One of the defining aspects of a PWA is that it can be installed on the device, and then appears to users as a platform-specific app, a permanent feature of their device which they can launch directly from the operating system like any other app. In this guide we'll explore what "installable" means, what a PWA needs to provide for it to be installable, and how you can customize the install experience.

Installing and uninstalling web apps

This guide covers how users can install and uninstall PWAs on their devices.

Offline and background operation

In this guide, we'll introduce a set of technologies that enable a PWA to provide a good user experience even when the device has intermittent network connectivity and to perform operations in the background, even when the main app is not running.

Caching

An overview of the APIs that enable a PWA to cache resources locally, and some common strategies used by PWAs to implement offline functionality.

Best practices for PWAs

PWAs should adapt to different browsers and devices, be accessible, have good performance, and integrate well with the operating system. This guide provides a list of best practices to help you make sure your PWA is as good as it can be.

How toThese guides give concrete detailed instructions for how to implement specific PWA features.

Create a standalone app

Describes how to specify that a PWA should be launched in its own dedicated window when it is launched, rather than a browser tab.

Define your app icons

Describes how to define your own set of icons to be used when the PWA is installed on a device.

Customize your app's colors

Describes how to set background and theme colors for a PWA.

Display badges

Describes how to display a badge on the PWA's icon: for example to let the user know that they have received new messages.

Expose common app actions as shortcuts

Describes how to expose common actions for a PWA that can be launched from the operating system's app shortcut menu.

Share data between apps

Describes how PWAs can share data with each other by using the operating system's app sharing mechanism.

Trigger installation from your PWA

Describes how developers can provide their own UI to invite users to install their PWA.

Associate files with your PWA

Describes how you can create an association between file types and your PWA, so that when the user clicks on the file, your PWA is launched to handle it.

TutorialsIn these tutorials, you'll build a PWA from scratch. Tutorials walk through the steps of creating an app, from start to finish, explaining how the different features of the app are implemented.

Creating your first PWA

This novice-level tutorial walks through the creation of a PWA to track menstrual cycles. Lessons include a walk through of the HTML, CSS, and JavaScript required to create a fully functional web app, setting up a testing environment, and complete explanations guiding the learner through upgrading the web app into a PWA; including developing and inspecting a manifest, adding a service worker, and using the service worker to delete stale caches.

Deep dive into PWA

This intermediate-level tutorial walks through the creation of a PWA that lists information about games submitted to the A-Frame category in the js13kGames 2017 competition. This tutorial includes all the basics for creating a PWA, with additional features, including notifications, push, and app performance.

ReferenceReference documentation for the web technologies you will use to build a PWA.Web app manifest
Web app manifest members

Developers can use web app manifest members to describe a PWA, customize its appearance, and more deeply integrate it into the operating system.

Service Worker APIsCommunication with the app
The following APIs can be used by a service worker to communicate with its associated client PWA:

Client.postMessage()

Allows a service worker to send a message to its client PWA.

Broadcast Channel API

Allows a service worker and its client PWA to establish a basic two-way communication channel.


Offline operation
The following APIs can be used by a service worker to make your app work offline:

Cache

A persistent storage mechanism for HTTP responses used to store assets that can be reused when the app is offline.

Clients

An interface used to provide access to the documents that are controlled by the service worker.

FetchEvent

An event, dispatched in the service worker with every HTTP request made by the client PWA. The event can be used to either send the request to the server as normal and save the response for future use, or intercept the request and immediately respond with a response cached previously.


Background operation
The following APIs can be used by a service worker to perform tasks in the background, even when your app is not running:

Background Synchronization API

A way to defer tasks to run in a service worker once there is a stable network connection.

Web Periodic Background Synchronization API

A way to register tasks to be run in a service worker at periodic intervals with network connectivity.

Background Fetch API

A method for a service worker to manage downloads that may take a significant amount of time, such as video or audio files.

Other web APIs
IndexedDB

A client-side storage API for significant amounts of structured data, including files.

Badging API

A method of setting a badge on the application icon, providing a low-distraction notification.

Notifications API

A way to send notifications that are displayed at the operating system level.

Web Share API

A mechanism for sharing text, links, files, and other content to other apps selected by the user on their device.

Window Controls Overlay API

An API for PWAs installed on desktop operating systems that enables hiding the default window title bar, enabling displaying the app over the full surface area of the app window.

See also
Progressive web apps on web.dev
Learn PWA on web.dev
Progressive web apps on learn.microsoft.com (2023)\n\nProgressive web appsA progressive web app (PWA) is an app that's built using web platform technologies, but that provides a user experience like that of a platform-specific app.
Like a website, a PWA can run on multiple platforms and devices from a single codebase. Like a platform-specific app, it can be installed on the device, can operate while offline and in the background, and can integrate with the device and with other installed apps.GuidesThese guides give conceptual explanations of different aspects of PWAs. They're intended to help you understand what kinds of things are possible with PWAs, and to provide enough pointers to help you understand how to achieve them.

What is a progressive web app?

An introduction to PWAs, comparing them with traditional websites and with platform-specific apps, and outlining their main features.

Making PWAs installable

One of the defining aspects of a PWA is that it can be installed on the device, and then appears to users as a platform-specific app, a permanent feature of their device which they can launch directly from the operating system like any other app. In this guide we'll explore what "installable" means, what a PWA needs to provide for it to be installable, and how you can customize the install experience.

Installing and uninstalling web apps

This guide covers how users can install and uninstall PWAs on their devices.

Offline and background operation

In this guide, we'll introduce a set of technologies that enable a PWA to provide a good user experience even when the device has intermittent network connectivity and to perform operations in the background, even when the main app is not running.

Caching

An overview of the APIs that enable a PWA to cache resources locally, and some common strategies used by PWAs to implement offline functionality.

Best practices for PWAs

PWAs should adapt to different browsers and devices, be accessible, have good performance, and integrate well with the operating system. This guide provides a list of best practices to help you make sure your PWA is as good as it can be.

How toThese guides give concrete detailed instructions for how to implement specific PWA features.

Create a standalone app

Describes how to specify that a PWA should be launched in its own dedicated window when it is launched, rather than a browser tab.

Define your app icons

Describes how to define your own set of icons to be used when the PWA is installed on a device.

Customize your app's colors

Describes how to set background and theme colors for a PWA.

Display badges

Describes how to display a badge on the PWA's icon: for example to let the user know that they have received new messages.

Expose common app actions as shortcuts

Describes how to expose common actions for a PWA that can be launched from the operating system's app shortcut menu.

Share data between apps

Describes how PWAs can share data with each other by using the operating system's app sharing mechanism.

Trigger installation from your PWA

Describes how developers can provide their own UI to invite users to install their PWA.

Associate files with your PWA

Describes how you can create an association between file types and your PWA, so that when the user clicks on the file, your PWA is launched to handle it.

TutorialsIn these tutorials, you'll build a PWA from scratch. Tutorials walk through the steps of creating an app, from start to finish, explaining how the different features of the app are implemented.

Creating your first PWA

This novice-level tutorial walks through the creation of a PWA to track menstrual cycles. Lessons include a walk through of the HTML, CSS, and JavaScript required to create a fully functional web app, setting up a testing environment, and complete explanations guiding the learner through upgrading the web app into a PWA; including developing and inspecting a manifest, adding a service worker, and using the service worker to delete stale caches.

Deep dive into PWA

This intermediate-level tutorial walks through the creation of a PWA that lists information about games submitted to the A-Frame category in the js13kGames 2017 competition. This tutorial includes all the basics for creating a PWA, with additional features, including notifications, push, and app performance.

ReferenceReference documentation for the web technologies you will use to build a PWA.Web app manifest
Web app manifest members

Developers can use web app manifest members to describe a PWA, customize its appearance, and more deeply integrate it into the operating system.

Service Worker APIsCommunication with the app
The following APIs can be used by a service worker to communicate with its associated client PWA:

Client.postMessage()

Allows a service worker to send a message to its client PWA.

Broadcast Channel API

Allows a service worker and its client PWA to establish a basic two-way communication channel.


Offline operation
The following APIs can be used by a service worker to make your app work offline:

Cache

A persistent storage mechanism for HTTP responses used to store assets that can be reused when the app is offline.

Clients

An interface used to provide access to the documents that are controlled by the service worker.

FetchEvent

An event, dispatched in the service worker with every HTTP request made by the client PWA. The event can be used to either send the request to the server as normal and save the response for future use, or intercept the request and immediately respond with a response cached previously.


Background operation
The following APIs can be used by a service worker to perform tasks in the background, even when your app is not running:

Background Synchronization API

A way to defer tasks to run in a service worker once there is a stable network connection.

Web Periodic Background Synchronization API

A way to register tasks to be run in a service worker at periodic intervals with network connectivity.

Background Fetch API

A method for a service worker to manage downloads that may take a significant amount of time, such as video or audio files.

Other web APIs
IndexedDB

A client-side storage API for significant amounts of structured data, including files.

Badging API

A method of setting a badge on the application icon, providing a low-distraction notification.

Notifications API

A way to send notifications that are displayed at the operating system level.

Web Share API

A mechanism for sharing text, links, files, and other content to other apps selected by the user on their device.

Window Controls Overlay API

An API for PWAs installed on desktop operating systems that enables hiding the default window title bar, enabling displaying the app over the full surface area of the app window.

See also
Progressive web apps on web.dev
Learn PWA on web.dev
Progressive web apps on learn.microsoft.com (2023)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nProgressive web appsA progressive web app (PWA) is an app that's built using web platform technologies, but that provides a user experience like that of a platform-specific app.
Like a website, a PWA can run on multiple platforms and devices from a single codebase. Like a platform-specific app, it can be installed on the device, can operate while offline and in the background, and can integrate with the device and with other installed apps.GuidesThese guides give conceptual explanations of different aspects of PWAs. They're intended to help you understand what kinds of things are possible with PWAs, and to provide enough pointers to help you understand how to achieve them.

What is a progressive web app?

An introduction to PWAs, comparing them with traditional websites and with platform-specific apps, and outlining their main features.

Making PWAs installable

One of the defining aspects of a PWA is that it can be installed on the device, and then appears to users as a platform-specific app, a permanent feature of their device which they can launch directly from the operating system like any other app. In this guide we'll explore what "installable" means, what a PWA needs to provide for it to be installable, and how you can customize the install experience.

Installing and uninstalling web apps

This guide covers how users can install and uninstall PWAs on their devices.

Offline and background operation

In this guide, we'll introduce a set of technologies that enable a PWA to provide a good user experience even when the device has intermittent network connectivity and to perform operations in the background, even when the main app is not running.

Caching

An overview of the APIs that enable a PWA to cache resources locally, and some common strategies used by PWAs to implement offline functionality.

Best practices for PWAs

PWAs should adapt to different browsers and devices, be accessible, have good performance, and integrate well with the operating system. This guide provides a list of best practices to help you make sure your PWA is as good as it can be.

How toThese guides give concrete detailed instructions for how to implement specific PWA features.

Create a standalone app

Describes how to specify that a PWA should be launched in its own dedicated window when it is launched, rather than a browser tab.

Define your app icons

Describes how to define your own set of icons to be used when the PWA is installed on a device.

Customize your app's colors

Describes how to set background and theme colors for a PWA.

Display badges

Describes how to display a badge on the PWA's icon: for example to let the user know that they have received new messages.

Expose common app actions as shortcuts

Describes how to expose common actions for a PWA that can be launched from the operating system's app shortcut menu.

Share data between apps

Describes how PWAs can share data with each other by using the operating system's app sharing mechanism.

Trigger installation from your PWA

Describes how developers can provide their own UI to invite users to install their PWA.

Associate files with your PWA

Describes how you can create an association between file types and your PWA, so that when the user clicks on the file, your PWA is launched to handle it.

TutorialsIn these tutorials, you'll build a PWA from scratch. Tutorials walk through the steps of creating an app, from start to finish, explaining how the different features of the app are implemented.

Creating your first PWA

This novice-level tutorial walks through the creation of a PWA to track menstrual cycles. Lessons include a walk through of the HTML, CSS, and JavaScript required to create a fully functional web app, setting up a testing environment, and complete explanations guiding the learner through upgrading the web app into a PWA; including developing and inspecting a manifest, adding a service worker, and using the service worker to delete stale caches.

Deep dive into PWA

This intermediate-level tutorial walks through the creation of a PWA that lists information about games submitted to the A-Frame category in the js13kGames 2017 competition. This tutorial includes all the basics for creating a PWA, with additional features, including notifications, push, and app performance.

ReferenceReference documentation for the web technologies you will use to build a PWA.Web app manifest
Web app manifest members

Developers can use web app manifest members to describe a PWA, customize its appearance, and more deeply integrate it into the operating system.

Service Worker APIsCommunication with the app
The following APIs can be used by a service worker to communicate with its associated client PWA:

Client.postMessage()

Allows a service worker to send a message to its client PWA.

Broadcast Channel API

Allows a service worker and its client PWA to establish a basic two-way communication channel.


Offline operation
The following APIs can be used by a service worker to make your app work offline:

Cache

A persistent storage mechanism for HTTP responses used to store assets that can be reused when the app is offline.

Clients

An interface used to provide access to the documents that are controlled by the service worker.

FetchEvent

An event, dispatched in the service worker with every HTTP request made by the client PWA. The event can be used to either send the request to the server as normal and save the response for future use, or intercept the request and immediately respond with a response cached previously.


Background operation
The following APIs can be used by a service worker to perform tasks in the background, even when your app is not running:

Background Synchronization API

A way to defer tasks to run in a service worker once there is a stable network connection.

Web Periodic Background Synchronization API

A way to register tasks to be run in a service worker at periodic intervals with network connectivity.

Background Fetch API

A method for a service worker to manage downloads that may take a significant amount of time, such as video or audio files.

Other web APIs
IndexedDB

A client-side storage API for significant amounts of structured data, including files.

Badging API

A method of setting a badge on the application icon, providing a low-distraction notification.

Notifications API

A way to send notifications that are displayed at the operating system level.

Web Share API

A mechanism for sharing text, links, files, and other content to other apps selected by the user on their device.

Window Controls Overlay API

An API for PWAs installed on desktop operating systems that enables hiding the default window title bar, enabling displaying the app over the full surface area of the app window.

See also
Progressive web apps on web.dev
Learn PWA on web.dev
Progressive web apps on learn.microsoft.com (2023)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nSVG: Scalable Vector GraphicsScalable Vector Graphics (SVG) is an XML-based markup language for describing two-dimensional based vector graphics.
As such, it's a text-based, open Web standard for describing images that can be rendered cleanly at any size and are designed specifically to work well with other web standards including CSS, DOM, JavaScript, and SMIL. SVG is, essentially, to graphics what HTML is to text.
SVG images and their related behaviors are defined in XML text files, which means they can be searched, indexed, scripted, and compressed. Additionally, this means they can be created and edited with any text editor or with drawing software.
Compared to classic bitmapped image formats such as JPEG or PNG, SVG-format vector images can be rendered at any size without loss of quality and can be easily localized by updating the text within them, without the need of a graphical editor to do so. With proper libraries, SVG files can even be localized on-the-fly.
SVG has been developed by the World Wide Web Consortium (W3C) since 1999.Tutorials
Introducing SVG from scratch

This tutorial aims to explain the internals of SVG and is packed with technical details. If you just want to draw beautiful images, you might find more useful resources at Inkscape's documentation page. Another good introduction to SVG is provided by the W3C's SVG Primer. Also check out this advent calendar-themed SVG Tutorial that walks you through coding 25 festive SVGs.

Guides
Applying SVG effects to HTML content
Content type
Linking
Namespaces crash course
Scripting
SVG animation with SMIL
SVG as an image
SVG filters
SVG in HTML introduction
Reference
SVG element reference

Details about each SVG element.

SVG attribute reference

Details about each SVG attribute.

SVG DOM interface reference

Details about the SVG DOM API, for interaction with JavaScript.

Applying SVG effects to HTML content

SVG works together with HTML, CSS and JavaScript.

Resources
SVG test suite
Markup validator
SVG authoring guidelines
SVG tutorial
D3 data visualization library\n\nSVG: Scalable Vector GraphicsScalable Vector Graphics (SVG) is an XML-based markup language for describing two-dimensional based vector graphics.
As such, it's a text-based, open Web standard for describing images that can be rendered cleanly at any size and are designed specifically to work well with other web standards including CSS, DOM, JavaScript, and SMIL. SVG is, essentially, to graphics what HTML is to text.
SVG images and their related behaviors are defined in XML text files, which means they can be searched, indexed, scripted, and compressed. Additionally, this means they can be created and edited with any text editor or with drawing software.
Compared to classic bitmapped image formats such as JPEG or PNG, SVG-format vector images can be rendered at any size without loss of quality and can be easily localized by updating the text within them, without the need of a graphical editor to do so. With proper libraries, SVG files can even be localized on-the-fly.
SVG has been developed by the World Wide Web Consortium (W3C) since 1999.Tutorials
Introducing SVG from scratch

This tutorial aims to explain the internals of SVG and is packed with technical details. If you just want to draw beautiful images, you might find more useful resources at Inkscape's documentation page. Another good introduction to SVG is provided by the W3C's SVG Primer. Also check out this advent calendar-themed SVG Tutorial that walks you through coding 25 festive SVGs.

Guides
Applying SVG effects to HTML content
Content type
Linking
Namespaces crash course
Scripting
SVG animation with SMIL
SVG as an image
SVG filters
SVG in HTML introduction
Reference
SVG element reference

Details about each SVG element.

SVG attribute reference

Details about each SVG attribute.

SVG DOM interface reference

Details about the SVG DOM API, for interaction with JavaScript.

Applying SVG effects to HTML content

SVG works together with HTML, CSS and JavaScript.

Resources
SVG test suite
Markup validator
SVG authoring guidelines
SVG tutorial
D3 data visualization library
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 18, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nSVG: Scalable Vector GraphicsScalable Vector Graphics (SVG) is an XML-based markup language for describing two-dimensional based vector graphics.
As such, it's a text-based, open Web standard for describing images that can be rendered cleanly at any size and are designed specifically to work well with other web standards including CSS, DOM, JavaScript, and SMIL. SVG is, essentially, to graphics what HTML is to text.
SVG images and their related behaviors are defined in XML text files, which means they can be searched, indexed, scripted, and compressed. Additionally, this means they can be created and edited with any text editor or with drawing software.
Compared to classic bitmapped image formats such as JPEG or PNG, SVG-format vector images can be rendered at any size without loss of quality and can be easily localized by updating the text within them, without the need of a graphical editor to do so. With proper libraries, SVG files can even be localized on-the-fly.
SVG has been developed by the World Wide Web Consortium (W3C) since 1999.Tutorials
Introducing SVG from scratch

This tutorial aims to explain the internals of SVG and is packed with technical details. If you just want to draw beautiful images, you might find more useful resources at Inkscape's documentation page. Another good introduction to SVG is provided by the W3C's SVG Primer. Also check out this advent calendar-themed SVG Tutorial that walks you through coding 25 festive SVGs.

Guides
Applying SVG effects to HTML content
Content type
Linking
Namespaces crash course
Scripting
SVG animation with SMIL
SVG as an image
SVG filters
SVG in HTML introduction
Reference
SVG element reference

Details about each SVG element.

SVG attribute reference

Details about each SVG attribute.

SVG DOM interface reference

Details about the SVG DOM API, for interaction with JavaScript.

Applying SVG effects to HTML content

SVG works together with HTML, CSS and JavaScript.

Resources
SVG test suite
Markup validator
SVG authoring guidelines
SVG tutorial
D3 data visualization library
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 18, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nSecurity on the webWebsites contain several different types of information. Some of it is non-sensitive, for example the copy shown on the public pages. Some of it is sensitive, for example customer usernames, passwords, and banking information, or internal algorithms and private product information.
Sensitive information needs to be protected, and that is the focus of web security. If that information fell into the wrong hands, it could be used to:

Put companies at a competitive disadvantage by sharing their information with competitors.
Disable or hijack their services, again causing serious problems with their operation.
Put their customer's privacy at risk, making them vulnerable to profiling, targeting, loss of data, identity theft, or even financial loss.

Modern browsers already have several features to protect users' security on the web, but developers also need to use best practices and code carefully to ensure that their websites are secure. Even simple bugs in your code can result in vulnerabilities that bad actors can exploit to steal data and gain unauthorized control over services.
This article provides an introduction to web security, including conceptual information to help you understand website vulnerabilities and practical guides on how to secure them.Relationship between security and privacySecurity and privacy are distinct yet closely related topics. It is worth knowing the differences between the two and how they relate.


Security is the act of keeping private data and systems protected against unauthorized access. This includes both company (internal) data and user and partner (external) data.


Privacy refers to the act of giving users control over how their data is collected, stored, and used, while also ensuring that it is not used irresponsibly. For example, you should let your users know what data you are collecting from them, the parties with whom it will be shared, and how it will be used. Users must be given a chance to consent to your privacy policy, have access to their data you store, and delete it if they choose to.


Good security is essential for good privacy. You could follow all the advice listed in our Privacy on the web guide, but acting with integrity and having a robust privacy policy are futile if your site is not secure and attackers can just steal data anyway.Security features provided by browsersWeb browsers follow a strict security model that enforces strong security for content, connections between the browser and the server, and data transportation. This section looks at the features that underpin this model.Same-origin policy and CORSSame-origin policy is a fundamental security mechanism of the web that restricts how a document or a script loaded from one origin can interact with a resource from another origin. It helps isolate potentially malicious documents, reducing possible attack vectors.
In general, documents from one origin cannot make requests to other origins. This makes sense because you don't want sites to be able to interfere with one another and access unauthorized data.
However, you might want to relax this restriction in some circumstances; for example, if you have multiple websites that interact with each other, you may allow them to request resources from one another using fetch(). This can be permitted using Cross-Origin Resource Sharing (CORS), an HTTP-header-based mechanism that allows a server to indicate any origins (domain, scheme, or port) other than its own from which a browser should permit loading resources.HTTP model for communicationThe HTTP protocol is used by web browsers and servers to communicate with one another, request resources, provide responses (for example, providing a requested resource or detailing why a request failed), and provide security features for that communication.
Transport Layer Security (TLS) provides security and privacy by encrypting data during transport over the network and is the technology behind the HTTPS protocol. TLS is good for privacy because it stops third parties from being able to intercept transmitted data and use it maliciously.
All browsers are moving towards requiring HTTPS by default; this is practically the case already because you can't do much on the web without this protocol.
Related topics:

Transport layer security (TLS)

The TLS protocol is the standard for enabling two networked applications or devices to exchange information privately and robustly. Applications that use TLS can choose their security parameters, which can have a substantial impact on the security and reliability of data.

HTTP Strict-Transport-Security

The Strict-Transport-Security HTTP header lets a website specify that it may only be accessed using HTTPS.

Certificate Transparency

Certificate Transparency (CT) is an open framework designed to protect against and monitor for certificate misissuance. Newly issued certificates are 'logged' to publicly run, often independent CT logs. These provide append-only, cryptographically assured records of issued TLS certificates.

Mixed content

An HTTPS page that includes content fetched using cleartext HTTP is called a mixed content page. Pages like this are only partially encrypted, leaving the unencrypted content accessible to sniffers and man-in-the-middle attackers.

Weak signature algorithms

The strength of the hash algorithm used in signing a digital certificate is a critical element of the security of the certificate. Some signature algorithms are known to be weak, and should be avoided when appropriate.

Secure contexts and feature permissionsBrowsers control the usage of "powerful features" in different ways. These "powerful features" include generating system notifications on a website, using a user's webcam to get access to a media stream, manipulating the system GPU, and using web payments. If a site could just use the APIs that control such features without restriction, malicious developers could attempt to do the following:

Annoy users with unneeded notifications and other UI features.
Turn their webcam on without warning to spy on them.
Clog up their browser/system to create Denial of Service (DoS) attacks.
Steal data or money.

These "powerful features" are controlled in the following ways:


Usage of such features is permitted only in secure contexts. A secure context is a window or a worker for which there is reasonable confidence that the content has been delivered securely (via HTTPS/TLS). In a secure context, the potential for communication with contexts that are not secure is limited. Secure contexts also help to prevent man-in-the-middle attackers from accessing powerful features.
To see a list of web platform features available only in secure contexts, see Features restricted to secure contexts.


The usage of these features is gated behind a system of user permissions: users have to explicitly opt-in to providing access to such features, meaning that they can't be used automatically. User permission requests happen automatically, and you can query the state of an API permission by using the Permissions API.


Several other browser features can be used only in response to a user action such as clicking a button, meaning that they need to be invoked from inside an appropriate event handler. This is called transient activation. See Features gated by user activation for more information.

High-level security considerationsThere are many aspects of web security that need to be thought about on the server- and client-side. This section focuses mainly on client-side security considerations. You can find a useful summary of security from a server-side perspective, which also includes descriptions of common attacks to watch out for, at Website security (part of our Server-side website programming learning module).Store client-side data responsiblyHandling data responsibly is largely concerned with cutting down on third-party cookie usage and being careful about the data you store and share with them. Traditionally, web developers have used cookies to store all kinds of data, and it has been easy for attackers to exploit this tendency. As a result, browsers have started to limit what you can do with cross-site cookies, with the aim of removing access to them altogether in the future.
You should prepare for the removal of cross-site cookies by limiting the amount of tracking activities you rely on and/or by implementing the persistence of the desired information in other ways. See Transitioning from third-party cookies and Replacing third-party cookies for more information.Protect user identity and manage loginsWhen implementing a secure solution that involves data collection, particularly if the data is sensitive such as log-in credentials, it makes sense to use a reputable solution. For example, any respectable server-side framework will have built-in features to protect against common vulnerabilities. You could also consider using a specialized product for your purpose, for example an identity provider solution or a secure online survey provider.
If you want to roll your own solution for collecting user data, make sure you understand all aspects and requirements. Hire an experienced server-side developer and/or security engineer to implement the system, and ensure it is tested thoroughly. Use multi-factor authentication (MFA) to provide better protection. Consider using a dedicated API such as Web Authentication or Federated Credential Management to streamline the client-side of the app.
Here are some other tips for providing secure logins:


When collecting user login information, enforce strong passwords so that your user's account details cannot be easily guessed. Weak passwords are one of the main causes of security breaches. In addition, encourage your users to use a password manager so that they can use more complex passwords, don't need to worry about remembering them, and won't create a security risk by writing them down. See also our article on Insecure passwords.


You should also educate your users about phishing. Phishing is the act of sending a message to a user (for example, an email or an SMS) containing a link to a site that looks like a site they use every day but isn't. The link is accompanied by a message designed to trick users into entering their username and password on the site so it can be stolen and then used by an attacker for malicious purposes.

Note:
Some phishing sites can be very sophisticated and hard to distinguish from a real website. You should therefore educate your users to not trust random links in emails and SMS messages. If they receive a message along the lines of "Urgent, you need to log in now to resolve an issue", they should go to the site directly in a new tab and try logging in directly rather than clicking the link in the message. Or they could phone or email you to discuss the message they received.



Protect against brute force attacks on login pages with rate limiting, account lockouts after a certain number of unsuccessful attempts, and CAPTCHA challenges.


Manage user login sessions with unique session IDs, and automatically log out users after periods of inactivity.

Don't include sensitive data in URL query stringsAs a general rule, you shouldn't include sensitive data in URL query strings because if a third party intercepts the URL (for example, via the Referer HTTP header), they could steal that information. Even more serious is the fact that these URLs can be indexed by public web crawlers, HTTP proxies, and archiving tools such as the internet archive, meaning that your sensitive data could persist on publicly accessible resources.
Use POST requests rather than GET requests to avoid these issues. Our article Referer header policy: Privacy and security concerns describes in more detail the privacy and security risks associated with the Referer header, and offers advice on mitigating those risks.

Note:
Steering away from transmitting sensitive data in URLs via GET requests can also help protect against cross-site request forgery and replay attacks.
Enforce usage policiesConsider using web platform features like Content Security Policy (CSP) and Permissions Policy to enforce a set of feature and resource usage rules on your website that make it harder to introduce vulnerabilities.
CSP allows you to add a layer of security by, for example, allowing images or scripts to be loaded only from specific trusted origins. This helps to detect and mitigate certain types of attacks, including Cross-Site Scripting (XSS) and data injection attacks. These attacks involve a range of malicious activities, including data theft, site defacement, and distribution of malware.
Permissions policy works in a similar way, except that it is more concerned with allowing or blocking access to specific "powerful features" (as mentioned earlier).

Note:
Such policies are very useful to help keep sites secure, especially when you are using a lot of third-party code on your site. However, keep in mind that if you block usage of a feature that a third-party script relies on to work, you may end up breaking your site's functionality.
Maintain data integrityFollowing on from the previous section, when you allow feature and resource usage on your site, you should try to ensure that resources have not been tampered with.
Related topics:

Subresource integrity

Subresource Integrity (SRI) is a security feature that enables browsers to verify that resources they fetch (for example, from a CDN) are delivered without unexpected manipulation. It works by allowing you to provide a cryptographic hash that a fetched resource must match.

HTTP Access-Control-Allow-Origin

The Access-Control-Allow-Origin response header indicates whether the response can be shared with requesting code from the given origin.

HTTP X-Content-Type-Options

The X-Content-Type-Options response header is a marker used by the server to indicate that the MIME types advertised in the Content-Type headers should not be changed and must be followed. This header is a way to opt out of MIME type sniffing, or, in other words, to specify that the MIME types are deliberately configured.

Sanitize form inputAs a general rule, don't trust anything that users enter into forms. Filling out forms online is complicated and tedious, and it is easy for users to enter incorrect data or data in the wrong format. In addition, malicious folks are skilled in the art of entering specific strings of executable code into form fields (for example, SQL or JavaScript). If you're not careful about handling such inputs, they could either execute harmful code on your site or delete your databases. See SQL injection for a good example of how this could happen.
To protect against this, you should thoroughly sanitize data entered into your forms:

You should implement client-side validation to inform users when they have entered data in the wrong format. You can do this using built-in HTML form validation features, or you can write your own validation code. See Client-side form validation for more information.
You should use output encoding when displaying user input in an application UI to safely display data exactly as a user typed it in and avoid it being executed as code. See Output encoding for more information.

You can't rely on client-side validation alone for security — it should be combined with server-side validation. Client-side validation enhances the user experience by providing instant validation feedback without having to wait for a round trip to the server. However, client-side validation is easy for a malicious party to bypass (for example, by turning off JavaScript in the browser to bypass JavaScript-based validation).
Any reputable server-side framework will provide functionality for validating form submissions. In addition, a common best practice is to escape any special characters that form part of executable syntax, thereby making any entered code no longer executable and treated as plain text.Protect against clickjackingIn a clickjacking attack, a user is fooled into clicking a UI element that performs an action different from what the user expects, often resulting in the user's confidential information being passed to a malicious third party. This risk is inherent in embedded third-party content, so make sure you trust what is being embedded into your site. Additionally, be aware that clickjacking can be combined with phishing techniques. You can read about phishing in the previous section Protect user identity and manage logins.
The following features can help guard against clickjacking:

HTTP X-Frame-Options

The X-Frame-Options HTTP response header can be used to indicate whether a browser should be allowed to render a page in a <frame>, <iframe>, <embed> or <object>. Sites can use this to avoid clickjacking attacks, by ensuring that their content is not embedded into other sites.

CSP: frame-ancestors

The HTTP Content-Security-Policy (CSP) frame-ancestors directive specifies valid parents that may embed a page using <frame>, <iframe>, <object>, or <embed>.

Practical security implementation guidesTo get comprehensive instructions for implementing security features effectively on websites and to ensure you're following best practices, see our set of Practical security implementation guides.
Some of these guides are directly related to the HTTP Observatory tool. Observatory performs security audits on a website and provides a grade and score along with recommendations for fixing the security issues it finds. These guides explain how to resolve issues surfaced by the MDN Observatory tests: the tool links to the relevant guide for each issue, helping guide you towards an effective resolution. Interestingly, Mozilla's internal developer teams use this guidance when implementing websites to ensure that security best practices are applied.See also
Privacy on the web
Learn: Website security
Mozilla Security Blog
OWASP Cheat Sheet series\n\nSecurity on the webWebsites contain several different types of information. Some of it is non-sensitive, for example the copy shown on the public pages. Some of it is sensitive, for example customer usernames, passwords, and banking information, or internal algorithms and private product information.
Sensitive information needs to be protected, and that is the focus of web security. If that information fell into the wrong hands, it could be used to:

Put companies at a competitive disadvantage by sharing their information with competitors.
Disable or hijack their services, again causing serious problems with their operation.
Put their customer's privacy at risk, making them vulnerable to profiling, targeting, loss of data, identity theft, or even financial loss.

Modern browsers already have several features to protect users' security on the web, but developers also need to use best practices and code carefully to ensure that their websites are secure. Even simple bugs in your code can result in vulnerabilities that bad actors can exploit to steal data and gain unauthorized control over services.
This article provides an introduction to web security, including conceptual information to help you understand website vulnerabilities and practical guides on how to secure them.Relationship between security and privacySecurity and privacy are distinct yet closely related topics. It is worth knowing the differences between the two and how they relate.


Security is the act of keeping private data and systems protected against unauthorized access. This includes both company (internal) data and user and partner (external) data.


Privacy refers to the act of giving users control over how their data is collected, stored, and used, while also ensuring that it is not used irresponsibly. For example, you should let your users know what data you are collecting from them, the parties with whom it will be shared, and how it will be used. Users must be given a chance to consent to your privacy policy, have access to their data you store, and delete it if they choose to.


Good security is essential for good privacy. You could follow all the advice listed in our Privacy on the web guide, but acting with integrity and having a robust privacy policy are futile if your site is not secure and attackers can just steal data anyway.Security features provided by browsersWeb browsers follow a strict security model that enforces strong security for content, connections between the browser and the server, and data transportation. This section looks at the features that underpin this model.Same-origin policy and CORSSame-origin policy is a fundamental security mechanism of the web that restricts how a document or a script loaded from one origin can interact with a resource from another origin. It helps isolate potentially malicious documents, reducing possible attack vectors.
In general, documents from one origin cannot make requests to other origins. This makes sense because you don't want sites to be able to interfere with one another and access unauthorized data.
However, you might want to relax this restriction in some circumstances; for example, if you have multiple websites that interact with each other, you may allow them to request resources from one another using fetch(). This can be permitted using Cross-Origin Resource Sharing (CORS), an HTTP-header-based mechanism that allows a server to indicate any origins (domain, scheme, or port) other than its own from which a browser should permit loading resources.HTTP model for communicationThe HTTP protocol is used by web browsers and servers to communicate with one another, request resources, provide responses (for example, providing a requested resource or detailing why a request failed), and provide security features for that communication.
Transport Layer Security (TLS) provides security and privacy by encrypting data during transport over the network and is the technology behind the HTTPS protocol. TLS is good for privacy because it stops third parties from being able to intercept transmitted data and use it maliciously.
All browsers are moving towards requiring HTTPS by default; this is practically the case already because you can't do much on the web without this protocol.
Related topics:

Transport layer security (TLS)

The TLS protocol is the standard for enabling two networked applications or devices to exchange information privately and robustly. Applications that use TLS can choose their security parameters, which can have a substantial impact on the security and reliability of data.

HTTP Strict-Transport-Security

The Strict-Transport-Security HTTP header lets a website specify that it may only be accessed using HTTPS.

Certificate Transparency

Certificate Transparency (CT) is an open framework designed to protect against and monitor for certificate misissuance. Newly issued certificates are 'logged' to publicly run, often independent CT logs. These provide append-only, cryptographically assured records of issued TLS certificates.

Mixed content

An HTTPS page that includes content fetched using cleartext HTTP is called a mixed content page. Pages like this are only partially encrypted, leaving the unencrypted content accessible to sniffers and man-in-the-middle attackers.

Weak signature algorithms

The strength of the hash algorithm used in signing a digital certificate is a critical element of the security of the certificate. Some signature algorithms are known to be weak, and should be avoided when appropriate.

Secure contexts and feature permissionsBrowsers control the usage of "powerful features" in different ways. These "powerful features" include generating system notifications on a website, using a user's webcam to get access to a media stream, manipulating the system GPU, and using web payments. If a site could just use the APIs that control such features without restriction, malicious developers could attempt to do the following:

Annoy users with unneeded notifications and other UI features.
Turn their webcam on without warning to spy on them.
Clog up their browser/system to create Denial of Service (DoS) attacks.
Steal data or money.

These "powerful features" are controlled in the following ways:


Usage of such features is permitted only in secure contexts. A secure context is a window or a worker for which there is reasonable confidence that the content has been delivered securely (via HTTPS/TLS). In a secure context, the potential for communication with contexts that are not secure is limited. Secure contexts also help to prevent man-in-the-middle attackers from accessing powerful features.
To see a list of web platform features available only in secure contexts, see Features restricted to secure contexts.


The usage of these features is gated behind a system of user permissions: users have to explicitly opt-in to providing access to such features, meaning that they can't be used automatically. User permission requests happen automatically, and you can query the state of an API permission by using the Permissions API.


Several other browser features can be used only in response to a user action such as clicking a button, meaning that they need to be invoked from inside an appropriate event handler. This is called transient activation. See Features gated by user activation for more information.

High-level security considerationsThere are many aspects of web security that need to be thought about on the server- and client-side. This section focuses mainly on client-side security considerations. You can find a useful summary of security from a server-side perspective, which also includes descriptions of common attacks to watch out for, at Website security (part of our Server-side website programming learning module).Store client-side data responsiblyHandling data responsibly is largely concerned with cutting down on third-party cookie usage and being careful about the data you store and share with them. Traditionally, web developers have used cookies to store all kinds of data, and it has been easy for attackers to exploit this tendency. As a result, browsers have started to limit what you can do with cross-site cookies, with the aim of removing access to them altogether in the future.
You should prepare for the removal of cross-site cookies by limiting the amount of tracking activities you rely on and/or by implementing the persistence of the desired information in other ways. See Transitioning from third-party cookies and Replacing third-party cookies for more information.Protect user identity and manage loginsWhen implementing a secure solution that involves data collection, particularly if the data is sensitive such as log-in credentials, it makes sense to use a reputable solution. For example, any respectable server-side framework will have built-in features to protect against common vulnerabilities. You could also consider using a specialized product for your purpose, for example an identity provider solution or a secure online survey provider.
If you want to roll your own solution for collecting user data, make sure you understand all aspects and requirements. Hire an experienced server-side developer and/or security engineer to implement the system, and ensure it is tested thoroughly. Use multi-factor authentication (MFA) to provide better protection. Consider using a dedicated API such as Web Authentication or Federated Credential Management to streamline the client-side of the app.
Here are some other tips for providing secure logins:


When collecting user login information, enforce strong passwords so that your user's account details cannot be easily guessed. Weak passwords are one of the main causes of security breaches. In addition, encourage your users to use a password manager so that they can use more complex passwords, don't need to worry about remembering them, and won't create a security risk by writing them down. See also our article on Insecure passwords.


You should also educate your users about phishing. Phishing is the act of sending a message to a user (for example, an email or an SMS) containing a link to a site that looks like a site they use every day but isn't. The link is accompanied by a message designed to trick users into entering their username and password on the site so it can be stolen and then used by an attacker for malicious purposes.

Note:
Some phishing sites can be very sophisticated and hard to distinguish from a real website. You should therefore educate your users to not trust random links in emails and SMS messages. If they receive a message along the lines of "Urgent, you need to log in now to resolve an issue", they should go to the site directly in a new tab and try logging in directly rather than clicking the link in the message. Or they could phone or email you to discuss the message they received.



Protect against brute force attacks on login pages with rate limiting, account lockouts after a certain number of unsuccessful attempts, and CAPTCHA challenges.


Manage user login sessions with unique session IDs, and automatically log out users after periods of inactivity.

Don't include sensitive data in URL query stringsAs a general rule, you shouldn't include sensitive data in URL query strings because if a third party intercepts the URL (for example, via the Referer HTTP header), they could steal that information. Even more serious is the fact that these URLs can be indexed by public web crawlers, HTTP proxies, and archiving tools such as the internet archive, meaning that your sensitive data could persist on publicly accessible resources.
Use POST requests rather than GET requests to avoid these issues. Our article Referer header policy: Privacy and security concerns describes in more detail the privacy and security risks associated with the Referer header, and offers advice on mitigating those risks.

Note:
Steering away from transmitting sensitive data in URLs via GET requests can also help protect against cross-site request forgery and replay attacks.
Enforce usage policiesConsider using web platform features like Content Security Policy (CSP) and Permissions Policy to enforce a set of feature and resource usage rules on your website that make it harder to introduce vulnerabilities.
CSP allows you to add a layer of security by, for example, allowing images or scripts to be loaded only from specific trusted origins. This helps to detect and mitigate certain types of attacks, including Cross-Site Scripting (XSS) and data injection attacks. These attacks involve a range of malicious activities, including data theft, site defacement, and distribution of malware.
Permissions policy works in a similar way, except that it is more concerned with allowing or blocking access to specific "powerful features" (as mentioned earlier).

Note:
Such policies are very useful to help keep sites secure, especially when you are using a lot of third-party code on your site. However, keep in mind that if you block usage of a feature that a third-party script relies on to work, you may end up breaking your site's functionality.
Maintain data integrityFollowing on from the previous section, when you allow feature and resource usage on your site, you should try to ensure that resources have not been tampered with.
Related topics:

Subresource integrity

Subresource Integrity (SRI) is a security feature that enables browsers to verify that resources they fetch (for example, from a CDN) are delivered without unexpected manipulation. It works by allowing you to provide a cryptographic hash that a fetched resource must match.

HTTP Access-Control-Allow-Origin

The Access-Control-Allow-Origin response header indicates whether the response can be shared with requesting code from the given origin.

HTTP X-Content-Type-Options

The X-Content-Type-Options response header is a marker used by the server to indicate that the MIME types advertised in the Content-Type headers should not be changed and must be followed. This header is a way to opt out of MIME type sniffing, or, in other words, to specify that the MIME types are deliberately configured.

Sanitize form inputAs a general rule, don't trust anything that users enter into forms. Filling out forms online is complicated and tedious, and it is easy for users to enter incorrect data or data in the wrong format. In addition, malicious folks are skilled in the art of entering specific strings of executable code into form fields (for example, SQL or JavaScript). If you're not careful about handling such inputs, they could either execute harmful code on your site or delete your databases. See SQL injection for a good example of how this could happen.
To protect against this, you should thoroughly sanitize data entered into your forms:

You should implement client-side validation to inform users when they have entered data in the wrong format. You can do this using built-in HTML form validation features, or you can write your own validation code. See Client-side form validation for more information.
You should use output encoding when displaying user input in an application UI to safely display data exactly as a user typed it in and avoid it being executed as code. See Output encoding for more information.

You can't rely on client-side validation alone for security — it should be combined with server-side validation. Client-side validation enhances the user experience by providing instant validation feedback without having to wait for a round trip to the server. However, client-side validation is easy for a malicious party to bypass (for example, by turning off JavaScript in the browser to bypass JavaScript-based validation).
Any reputable server-side framework will provide functionality for validating form submissions. In addition, a common best practice is to escape any special characters that form part of executable syntax, thereby making any entered code no longer executable and treated as plain text.Protect against clickjackingIn a clickjacking attack, a user is fooled into clicking a UI element that performs an action different from what the user expects, often resulting in the user's confidential information being passed to a malicious third party. This risk is inherent in embedded third-party content, so make sure you trust what is being embedded into your site. Additionally, be aware that clickjacking can be combined with phishing techniques. You can read about phishing in the previous section Protect user identity and manage logins.
The following features can help guard against clickjacking:

HTTP X-Frame-Options

The X-Frame-Options HTTP response header can be used to indicate whether a browser should be allowed to render a page in a <frame>, <iframe>, <embed> or <object>. Sites can use this to avoid clickjacking attacks, by ensuring that their content is not embedded into other sites.

CSP: frame-ancestors

The HTTP Content-Security-Policy (CSP) frame-ancestors directive specifies valid parents that may embed a page using <frame>, <iframe>, <object>, or <embed>.

Practical security implementation guidesTo get comprehensive instructions for implementing security features effectively on websites and to ensure you're following best practices, see our set of Practical security implementation guides.
Some of these guides are directly related to the HTTP Observatory tool. Observatory performs security audits on a website and provides a grade and score along with recommendations for fixing the security issues it finds. These guides explain how to resolve issues surfaced by the MDN Observatory tests: the tool links to the relevant guide for each issue, helping guide you towards an effective resolution. Interestingly, Mozilla's internal developer teams use this guidance when implementing websites to ensure that security best practices are applied.See also
Privacy on the web
Learn: Website security
Mozilla Security Blog
OWASP Cheat Sheet series
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nSecurity on the webWebsites contain several different types of information. Some of it is non-sensitive, for example the copy shown on the public pages. Some of it is sensitive, for example customer usernames, passwords, and banking information, or internal algorithms and private product information.
Sensitive information needs to be protected, and that is the focus of web security. If that information fell into the wrong hands, it could be used to:

Put companies at a competitive disadvantage by sharing their information with competitors.
Disable or hijack their services, again causing serious problems with their operation.
Put their customer's privacy at risk, making them vulnerable to profiling, targeting, loss of data, identity theft, or even financial loss.

Modern browsers already have several features to protect users' security on the web, but developers also need to use best practices and code carefully to ensure that their websites are secure. Even simple bugs in your code can result in vulnerabilities that bad actors can exploit to steal data and gain unauthorized control over services.
This article provides an introduction to web security, including conceptual information to help you understand website vulnerabilities and practical guides on how to secure them.Relationship between security and privacySecurity and privacy are distinct yet closely related topics. It is worth knowing the differences between the two and how they relate.


Security is the act of keeping private data and systems protected against unauthorized access. This includes both company (internal) data and user and partner (external) data.


Privacy refers to the act of giving users control over how their data is collected, stored, and used, while also ensuring that it is not used irresponsibly. For example, you should let your users know what data you are collecting from them, the parties with whom it will be shared, and how it will be used. Users must be given a chance to consent to your privacy policy, have access to their data you store, and delete it if they choose to.


Good security is essential for good privacy. You could follow all the advice listed in our Privacy on the web guide, but acting with integrity and having a robust privacy policy are futile if your site is not secure and attackers can just steal data anyway.Security features provided by browsersWeb browsers follow a strict security model that enforces strong security for content, connections between the browser and the server, and data transportation. This section looks at the features that underpin this model.Same-origin policy and CORSSame-origin policy is a fundamental security mechanism of the web that restricts how a document or a script loaded from one origin can interact with a resource from another origin. It helps isolate potentially malicious documents, reducing possible attack vectors.
In general, documents from one origin cannot make requests to other origins. This makes sense because you don't want sites to be able to interfere with one another and access unauthorized data.
However, you might want to relax this restriction in some circumstances; for example, if you have multiple websites that interact with each other, you may allow them to request resources from one another using fetch(). This can be permitted using Cross-Origin Resource Sharing (CORS), an HTTP-header-based mechanism that allows a server to indicate any origins (domain, scheme, or port) other than its own from which a browser should permit loading resources.HTTP model for communicationThe HTTP protocol is used by web browsers and servers to communicate with one another, request resources, provide responses (for example, providing a requested resource or detailing why a request failed), and provide security features for that communication.
Transport Layer Security (TLS) provides security and privacy by encrypting data during transport over the network and is the technology behind the HTTPS protocol. TLS is good for privacy because it stops third parties from being able to intercept transmitted data and use it maliciously.
All browsers are moving towards requiring HTTPS by default; this is practically the case already because you can't do much on the web without this protocol.
Related topics:

Transport layer security (TLS)

The TLS protocol is the standard for enabling two networked applications or devices to exchange information privately and robustly. Applications that use TLS can choose their security parameters, which can have a substantial impact on the security and reliability of data.

HTTP Strict-Transport-Security

The Strict-Transport-Security HTTP header lets a website specify that it may only be accessed using HTTPS.

Certificate Transparency

Certificate Transparency (CT) is an open framework designed to protect against and monitor for certificate misissuance. Newly issued certificates are 'logged' to publicly run, often independent CT logs. These provide append-only, cryptographically assured records of issued TLS certificates.

Mixed content

An HTTPS page that includes content fetched using cleartext HTTP is called a mixed content page. Pages like this are only partially encrypted, leaving the unencrypted content accessible to sniffers and man-in-the-middle attackers.

Weak signature algorithms

The strength of the hash algorithm used in signing a digital certificate is a critical element of the security of the certificate. Some signature algorithms are known to be weak, and should be avoided when appropriate.

Secure contexts and feature permissionsBrowsers control the usage of "powerful features" in different ways. These "powerful features" include generating system notifications on a website, using a user's webcam to get access to a media stream, manipulating the system GPU, and using web payments. If a site could just use the APIs that control such features without restriction, malicious developers could attempt to do the following:

Annoy users with unneeded notifications and other UI features.
Turn their webcam on without warning to spy on them.
Clog up their browser/system to create Denial of Service (DoS) attacks.
Steal data or money.

These "powerful features" are controlled in the following ways:


Usage of such features is permitted only in secure contexts. A secure context is a window or a worker for which there is reasonable confidence that the content has been delivered securely (via HTTPS/TLS). In a secure context, the potential for communication with contexts that are not secure is limited. Secure contexts also help to prevent man-in-the-middle attackers from accessing powerful features.
To see a list of web platform features available only in secure contexts, see Features restricted to secure contexts.


The usage of these features is gated behind a system of user permissions: users have to explicitly opt-in to providing access to such features, meaning that they can't be used automatically. User permission requests happen automatically, and you can query the state of an API permission by using the Permissions API.


Several other browser features can be used only in response to a user action such as clicking a button, meaning that they need to be invoked from inside an appropriate event handler. This is called transient activation. See Features gated by user activation for more information.

High-level security considerationsThere are many aspects of web security that need to be thought about on the server- and client-side. This section focuses mainly on client-side security considerations. You can find a useful summary of security from a server-side perspective, which also includes descriptions of common attacks to watch out for, at Website security (part of our Server-side website programming learning module).Store client-side data responsiblyHandling data responsibly is largely concerned with cutting down on third-party cookie usage and being careful about the data you store and share with them. Traditionally, web developers have used cookies to store all kinds of data, and it has been easy for attackers to exploit this tendency. As a result, browsers have started to limit what you can do with cross-site cookies, with the aim of removing access to them altogether in the future.
You should prepare for the removal of cross-site cookies by limiting the amount of tracking activities you rely on and/or by implementing the persistence of the desired information in other ways. See Transitioning from third-party cookies and Replacing third-party cookies for more information.Protect user identity and manage loginsWhen implementing a secure solution that involves data collection, particularly if the data is sensitive such as log-in credentials, it makes sense to use a reputable solution. For example, any respectable server-side framework will have built-in features to protect against common vulnerabilities. You could also consider using a specialized product for your purpose, for example an identity provider solution or a secure online survey provider.
If you want to roll your own solution for collecting user data, make sure you understand all aspects and requirements. Hire an experienced server-side developer and/or security engineer to implement the system, and ensure it is tested thoroughly. Use multi-factor authentication (MFA) to provide better protection. Consider using a dedicated API such as Web Authentication or Federated Credential Management to streamline the client-side of the app.
Here are some other tips for providing secure logins:


When collecting user login information, enforce strong passwords so that your user's account details cannot be easily guessed. Weak passwords are one of the main causes of security breaches. In addition, encourage your users to use a password manager so that they can use more complex passwords, don't need to worry about remembering them, and won't create a security risk by writing them down. See also our article on Insecure passwords.


You should also educate your users about phishing. Phishing is the act of sending a message to a user (for example, an email or an SMS) containing a link to a site that looks like a site they use every day but isn't. The link is accompanied by a message designed to trick users into entering their username and password on the site so it can be stolen and then used by an attacker for malicious purposes.

Note:
Some phishing sites can be very sophisticated and hard to distinguish from a real website. You should therefore educate your users to not trust random links in emails and SMS messages. If they receive a message along the lines of "Urgent, you need to log in now to resolve an issue", they should go to the site directly in a new tab and try logging in directly rather than clicking the link in the message. Or they could phone or email you to discuss the message they received.



Protect against brute force attacks on login pages with rate limiting, account lockouts after a certain number of unsuccessful attempts, and CAPTCHA challenges.


Manage user login sessions with unique session IDs, and automatically log out users after periods of inactivity.

Don't include sensitive data in URL query stringsAs a general rule, you shouldn't include sensitive data in URL query strings because if a third party intercepts the URL (for example, via the Referer HTTP header), they could steal that information. Even more serious is the fact that these URLs can be indexed by public web crawlers, HTTP proxies, and archiving tools such as the internet archive, meaning that your sensitive data could persist on publicly accessible resources.
Use POST requests rather than GET requests to avoid these issues. Our article Referer header policy: Privacy and security concerns describes in more detail the privacy and security risks associated with the Referer header, and offers advice on mitigating those risks.

Note:
Steering away from transmitting sensitive data in URLs via GET requests can also help protect against cross-site request forgery and replay attacks.
Enforce usage policiesConsider using web platform features like Content Security Policy (CSP) and Permissions Policy to enforce a set of feature and resource usage rules on your website that make it harder to introduce vulnerabilities.
CSP allows you to add a layer of security by, for example, allowing images or scripts to be loaded only from specific trusted origins. This helps to detect and mitigate certain types of attacks, including Cross-Site Scripting (XSS) and data injection attacks. These attacks involve a range of malicious activities, including data theft, site defacement, and distribution of malware.
Permissions policy works in a similar way, except that it is more concerned with allowing or blocking access to specific "powerful features" (as mentioned earlier).

Note:
Such policies are very useful to help keep sites secure, especially when you are using a lot of third-party code on your site. However, keep in mind that if you block usage of a feature that a third-party script relies on to work, you may end up breaking your site's functionality.
Maintain data integrityFollowing on from the previous section, when you allow feature and resource usage on your site, you should try to ensure that resources have not been tampered with.
Related topics:

Subresource integrity

Subresource Integrity (SRI) is a security feature that enables browsers to verify that resources they fetch (for example, from a CDN) are delivered without unexpected manipulation. It works by allowing you to provide a cryptographic hash that a fetched resource must match.

HTTP Access-Control-Allow-Origin

The Access-Control-Allow-Origin response header indicates whether the response can be shared with requesting code from the given origin.

HTTP X-Content-Type-Options

The X-Content-Type-Options response header is a marker used by the server to indicate that the MIME types advertised in the Content-Type headers should not be changed and must be followed. This header is a way to opt out of MIME type sniffing, or, in other words, to specify that the MIME types are deliberately configured.

Sanitize form inputAs a general rule, don't trust anything that users enter into forms. Filling out forms online is complicated and tedious, and it is easy for users to enter incorrect data or data in the wrong format. In addition, malicious folks are skilled in the art of entering specific strings of executable code into form fields (for example, SQL or JavaScript). If you're not careful about handling such inputs, they could either execute harmful code on your site or delete your databases. See SQL injection for a good example of how this could happen.
To protect against this, you should thoroughly sanitize data entered into your forms:

You should implement client-side validation to inform users when they have entered data in the wrong format. You can do this using built-in HTML form validation features, or you can write your own validation code. See Client-side form validation for more information.
You should use output encoding when displaying user input in an application UI to safely display data exactly as a user typed it in and avoid it being executed as code. See Output encoding for more information.

You can't rely on client-side validation alone for security — it should be combined with server-side validation. Client-side validation enhances the user experience by providing instant validation feedback without having to wait for a round trip to the server. However, client-side validation is easy for a malicious party to bypass (for example, by turning off JavaScript in the browser to bypass JavaScript-based validation).
Any reputable server-side framework will provide functionality for validating form submissions. In addition, a common best practice is to escape any special characters that form part of executable syntax, thereby making any entered code no longer executable and treated as plain text.Protect against clickjackingIn a clickjacking attack, a user is fooled into clicking a UI element that performs an action different from what the user expects, often resulting in the user's confidential information being passed to a malicious third party. This risk is inherent in embedded third-party content, so make sure you trust what is being embedded into your site. Additionally, be aware that clickjacking can be combined with phishing techniques. You can read about phishing in the previous section Protect user identity and manage logins.
The following features can help guard against clickjacking:

HTTP X-Frame-Options

The X-Frame-Options HTTP response header can be used to indicate whether a browser should be allowed to render a page in a <frame>, <iframe>, <embed> or <object>. Sites can use this to avoid clickjacking attacks, by ensuring that their content is not embedded into other sites.

CSP: frame-ancestors

The HTTP Content-Security-Policy (CSP) frame-ancestors directive specifies valid parents that may embed a page using <frame>, <iframe>, <object>, or <embed>.

Practical security implementation guidesTo get comprehensive instructions for implementing security features effectively on websites and to ensure you're following best practices, see our set of Practical security implementation guides.
Some of these guides are directly related to the HTTP Observatory tool. Observatory performs security audits on a website and provides a grade and score along with recommendations for fixing the security issues it finds. These guides explain how to resolve issues surfaced by the MDN Observatory tests: the tool links to the relevant guide for each issue, helping guide you towards an effective resolution. Interestingly, Mozilla's internal developer teams use this guidance when implementing websites to ensure that security best practices are applied.See also
Privacy on the web
Learn: Website security
Mozilla Security Blog
OWASP Cheat Sheet series
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURIsUniform Resource Identifiers (URI) are used to identify "resources" on the web.
URIs are commonly used as targets of HTTP requests, in which case the URI represents a location for a physical resource, such as a document, a photo, binary data.
The most common type of URI is a Uniform Resource Locator (URL), which is known as the web address.
URIs can be used to trigger behaviors other than fetching a resource, including opening an email client, sending text messages, or executing JavaScript, when used in other places such as the href of an HTML <a> link.URLs and URNsURLsAny of the following URLs can be typed into your browser's address bar to tell it to load the associated document (resource):
urlhttps://developer.mozilla.org
https://developer.mozilla.org/en-US/docs/Learn_web_development/
https://developer.mozilla.org/en-US/search?q=URL

A URL is composed of different parts, some mandatory and others optional. A more complex example might look like this:
urlhttp://www.example.com:80/path/to/myfile.html?key1=value1&key2=value2#SomewhereInTheDocument
URNsA Uniform Resource Name (URN) is a URI that identifies a resource by name in a particular namespace.
urlurn:isbn:9780141036144
urn:ietf:rfc:7230

The two URNs correspond to

the book Nineteen Eighty-Four by George Orwell,
the IETF specification 7230, Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing.
Syntax of Uniform Resource Identifiers (URIs)We will break down the following URL into its components:
urlhttp://www.example.com:80/path/to/myfile.html?key1=value1&key2=value2#SomewhereInTheDocument
Scheme
http:// is the scheme of the URL, indicating which protocol the browser must use. Usually it is the HTTP protocol or its secured version, HTTPS. The Web requires one of these two, but browsers also know how to handle other protocols such as mailto: (to open a mail client) or ftp: to handle a file transfer, so don't be surprised if you see such protocols. The schemes reference provides a list of the most common schemes, and documentation for some of them.
When using URLs in HTML content, you should generally only use a few of these URL schemes. When referring to subresources — that is, files that are being loaded as part of a larger document — you should only use the HTTP and HTTPS schemes. Increasingly, browsers are removing support for using FTP to load subresources, for security reasons.
FTP is still acceptable at the top level (such as typed directly into the browser's URL bar, or the target of a link), although some browsers may delegate loading FTP content to another application.AuthorityThe URI authority is comprised of user info (optional and usually unspecified), the host name, and the port.

www.example.com is the host name of the URI, indicating which Web server is being requested. Here, we use a domain name. It is also possible to directly use an IP address, but because it is less convenient, it is rare to do so, unless the server doesn't have a registered domain name.

:80 is the port of the URL, indicating the technical "gate" used to access the resources on the web server. It is usually omitted if the web server uses the standard ports of the HTTP protocol (80 for HTTP and 443 for HTTPS) to grant access to its resources. Otherwise, it is mandatory.Path
/path/to/myfile.html is the path of the URL, indicating the location of the resource on the web server. In the early days of the Web, this was an actual directory path to a physical location on the web server. Nowadays, web servers usually abstract this to an arbitrary location.Query
?key1=value1&key2=value2 is the query of the URL, which are extra parameters provided to the web server. The parameters are a list of key/value pairs prefixed by the ? symbol, and separated with the & symbol. These can be used to provide additional context about the resource being requested. Each resource location can have its own rules regarding parameters, and the only reliable way to know how specific parameters are handled is by asking the owner of the server, such as reading its documentation.Fragment
#SomewhereInTheDocument is the fragment of the URL, which is an anchor to another part of the resource itself. An anchor represents a sort of "bookmark" inside the resource, giving the browser the directions to show the content located at that "bookmarked" spot. On an HTML document, for example, the browser will scroll to the point where the anchor is defined; on a video or audio document, the browser will try to go to the time the anchor represents. It is worth noting that the part after the #, also known as the fragment identifier, is never sent to the server with the request.
There's a special text fragment feature that allows you to link to a specific part of a web page identified by its text content.Examplesurlhttps://developer.mozilla.org/en-US/docs/Learn
tel:+1-816-555-1212
git@github.com:mdn/browser-compat-data.git
ftp://example.org/resource.txt
urn:isbn:9780141036144
mailto:help@supercyberhelpdesk.info
SpecificationsSpecificationUnknown specification See also
What is a URL?\n\nURIsUniform Resource Identifiers (URI) are used to identify "resources" on the web.
URIs are commonly used as targets of HTTP requests, in which case the URI represents a location for a physical resource, such as a document, a photo, binary data.
The most common type of URI is a Uniform Resource Locator (URL), which is known as the web address.
URIs can be used to trigger behaviors other than fetching a resource, including opening an email client, sending text messages, or executing JavaScript, when used in other places such as the href of an HTML <a> link.URLs and URNsURLsAny of the following URLs can be typed into your browser's address bar to tell it to load the associated document (resource):
urlhttps://developer.mozilla.org
https://developer.mozilla.org/en-US/docs/Learn_web_development/
https://developer.mozilla.org/en-US/search?q=URL

A URL is composed of different parts, some mandatory and others optional. A more complex example might look like this:
urlhttp://www.example.com:80/path/to/myfile.html?key1=value1&key2=value2#SomewhereInTheDocument
URNsA Uniform Resource Name (URN) is a URI that identifies a resource by name in a particular namespace.
urlurn:isbn:9780141036144
urn:ietf:rfc:7230

The two URNs correspond to

the book Nineteen Eighty-Four by George Orwell,
the IETF specification 7230, Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing.
Syntax of Uniform Resource Identifiers (URIs)We will break down the following URL into its components:
urlhttp://www.example.com:80/path/to/myfile.html?key1=value1&key2=value2#SomewhereInTheDocument
Scheme
http:// is the scheme of the URL, indicating which protocol the browser must use. Usually it is the HTTP protocol or its secured version, HTTPS. The Web requires one of these two, but browsers also know how to handle other protocols such as mailto: (to open a mail client) or ftp: to handle a file transfer, so don't be surprised if you see such protocols. The schemes reference provides a list of the most common schemes, and documentation for some of them.
When using URLs in HTML content, you should generally only use a few of these URL schemes. When referring to subresources — that is, files that are being loaded as part of a larger document — you should only use the HTTP and HTTPS schemes. Increasingly, browsers are removing support for using FTP to load subresources, for security reasons.
FTP is still acceptable at the top level (such as typed directly into the browser's URL bar, or the target of a link), although some browsers may delegate loading FTP content to another application.AuthorityThe URI authority is comprised of user info (optional and usually unspecified), the host name, and the port.

www.example.com is the host name of the URI, indicating which Web server is being requested. Here, we use a domain name. It is also possible to directly use an IP address, but because it is less convenient, it is rare to do so, unless the server doesn't have a registered domain name.

:80 is the port of the URL, indicating the technical "gate" used to access the resources on the web server. It is usually omitted if the web server uses the standard ports of the HTTP protocol (80 for HTTP and 443 for HTTPS) to grant access to its resources. Otherwise, it is mandatory.Path
/path/to/myfile.html is the path of the URL, indicating the location of the resource on the web server. In the early days of the Web, this was an actual directory path to a physical location on the web server. Nowadays, web servers usually abstract this to an arbitrary location.Query
?key1=value1&key2=value2 is the query of the URL, which are extra parameters provided to the web server. The parameters are a list of key/value pairs prefixed by the ? symbol, and separated with the & symbol. These can be used to provide additional context about the resource being requested. Each resource location can have its own rules regarding parameters, and the only reliable way to know how specific parameters are handled is by asking the owner of the server, such as reading its documentation.Fragment
#SomewhereInTheDocument is the fragment of the URL, which is an anchor to another part of the resource itself. An anchor represents a sort of "bookmark" inside the resource, giving the browser the directions to show the content located at that "bookmarked" spot. On an HTML document, for example, the browser will scroll to the point where the anchor is defined; on a video or audio document, the browser will try to go to the time the anchor represents. It is worth noting that the part after the #, also known as the fragment identifier, is never sent to the server with the request.
There's a special text fragment feature that allows you to link to a specific part of a web page identified by its text content.Examplesurlhttps://developer.mozilla.org/en-US/docs/Learn
tel:+1-816-555-1212
git@github.com:mdn/browser-compat-data.git
ftp://example.org/resource.txt
urn:isbn:9780141036144
mailto:help@supercyberhelpdesk.info
SpecificationsSpecificationUnknown specification See also
What is a URL?
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURIsUniform Resource Identifiers (URI) are used to identify "resources" on the web.
URIs are commonly used as targets of HTTP requests, in which case the URI represents a location for a physical resource, such as a document, a photo, binary data.
The most common type of URI is a Uniform Resource Locator (URL), which is known as the web address.
URIs can be used to trigger behaviors other than fetching a resource, including opening an email client, sending text messages, or executing JavaScript, when used in other places such as the href of an HTML <a> link.URLs and URNsURLsAny of the following URLs can be typed into your browser's address bar to tell it to load the associated document (resource):
urlhttps://developer.mozilla.org
https://developer.mozilla.org/en-US/docs/Learn_web_development/
https://developer.mozilla.org/en-US/search?q=URL

A URL is composed of different parts, some mandatory and others optional. A more complex example might look like this:
urlhttp://www.example.com:80/path/to/myfile.html?key1=value1&key2=value2#SomewhereInTheDocument
URNsA Uniform Resource Name (URN) is a URI that identifies a resource by name in a particular namespace.
urlurn:isbn:9780141036144
urn:ietf:rfc:7230

The two URNs correspond to

the book Nineteen Eighty-Four by George Orwell,
the IETF specification 7230, Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing.
Syntax of Uniform Resource Identifiers (URIs)We will break down the following URL into its components:
urlhttp://www.example.com:80/path/to/myfile.html?key1=value1&key2=value2#SomewhereInTheDocument
Scheme
http:// is the scheme of the URL, indicating which protocol the browser must use. Usually it is the HTTP protocol or its secured version, HTTPS. The Web requires one of these two, but browsers also know how to handle other protocols such as mailto: (to open a mail client) or ftp: to handle a file transfer, so don't be surprised if you see such protocols. The schemes reference provides a list of the most common schemes, and documentation for some of them.
When using URLs in HTML content, you should generally only use a few of these URL schemes. When referring to subresources — that is, files that are being loaded as part of a larger document — you should only use the HTTP and HTTPS schemes. Increasingly, browsers are removing support for using FTP to load subresources, for security reasons.
FTP is still acceptable at the top level (such as typed directly into the browser's URL bar, or the target of a link), although some browsers may delegate loading FTP content to another application.AuthorityThe URI authority is comprised of user info (optional and usually unspecified), the host name, and the port.

www.example.com is the host name of the URI, indicating which Web server is being requested. Here, we use a domain name. It is also possible to directly use an IP address, but because it is less convenient, it is rare to do so, unless the server doesn't have a registered domain name.

:80 is the port of the URL, indicating the technical "gate" used to access the resources on the web server. It is usually omitted if the web server uses the standard ports of the HTTP protocol (80 for HTTP and 443 for HTTPS) to grant access to its resources. Otherwise, it is mandatory.Path
/path/to/myfile.html is the path of the URL, indicating the location of the resource on the web server. In the early days of the Web, this was an actual directory path to a physical location on the web server. Nowadays, web servers usually abstract this to an arbitrary location.Query
?key1=value1&key2=value2 is the query of the URL, which are extra parameters provided to the web server. The parameters are a list of key/value pairs prefixed by the ? symbol, and separated with the & symbol. These can be used to provide additional context about the resource being requested. Each resource location can have its own rules regarding parameters, and the only reliable way to know how specific parameters are handled is by asking the owner of the server, such as reading its documentation.Fragment
#SomewhereInTheDocument is the fragment of the URL, which is an anchor to another part of the resource itself. An anchor represents a sort of "bookmark" inside the resource, giving the browser the directions to show the content located at that "bookmarked" spot. On an HTML document, for example, the browser will scroll to the point where the anchor is defined; on a video or audio document, the browser will try to go to the time the anchor represents. It is worth noting that the part after the #, also known as the fragment identifier, is never sent to the server with the request.
There's a special text fragment feature that allows you to link to a specific part of a web page identified by its text content.Examplesurlhttps://developer.mozilla.org/en-US/docs/Learn
tel:+1-816-555-1212
git@github.com:mdn/browser-compat-data.git
ftp://example.org/resource.txt
urn:isbn:9780141036144
mailto:help@supercyberhelpdesk.info
SpecificationsSpecificationUnknown specification See also
What is a URL?
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nWeb performanceWeb performance is the objective measurements and the perceived user experience of load time and runtime.
Web performance is how long a site takes to load, become interactive and responsive, and how smooth the content is during user interactions.
Performance concerns questions like: Is scrolling smooth? Are buttons responsive? Do pop-ups load quickly and animate fluidly?
The objective measurements include time to load, frames per second, and time to become interactive, and subjective experience means how long it feels like it takes for content to load.
The longer it takes for a site to respond, the more users will abandon the site. It is important to minimize the loading and response times and add additional features to conceal latency by making the experience as available and interactive as possible, as soon as possible, while asynchronously loading in the longer tail parts of the experience.
There are tools, APIs, and best practices that help us measure and improve web performance. We cover them in the following pages.Web performance guides
Performance fundamentals

Performance means efficiency. In the context of Open Web Apps, this document explains in general what performance is, how the browser platform helps improve it, and what tools and processes you can use to test and improve it.

Populating the page: how browsers work

Users want web experiences with content that is fast to load and smooth to interact with. Therefore, a developer should strive to achieve these two goals.
To understand how to improve performance and perceived performance, it helps to understand how the browser works.

Understanding latency

Latency is the time it takes for a packet of data to travel from source to a destination. In terms of performance optimization, it's important to optimize to reduce causes of latency and to test site performance emulating high latency to optimize for users with slow or unreliable connections.

Recommended Web Performance Timings: How long is too long?

There are no clear set rules as to what constitutes a slow pace when loading pages, but there are specific guidelines for indicating content will load (1 second), idling (50ms), animating (16.7ms) and responding to user input (50 to 200ms).

Using dns-prefetch

DNS-prefetch is an attempt to resolve domain names before resources get requested. This could be a file loaded later or link target a user tries to follow.

Navigation and resource timings

Navigation timings are metrics measuring a browser's document navigation events. Resource timings are detailed network timing measurements regarding the loading of an application's resources. Both provide the same read-only properties, but navigation timing measures the main document's timings whereas the resource timing provides the times for all the assets or resources called in by that main document and the resources' requested resources.

Optimizing startup performance

Improving your startup performance is often one of the highest value performance optimizations that can be made.
Good user experience includes ensuring your app loads quickly. This article provides performance tips and suggestions for both writing new applications and porting applications to the web from other platforms.

Critical rendering path

The Critical Rendering Path is the sequence of steps the browser goes through to convert the HTML, CSS, and JavaScript into pixels on the screen. Optimizing the critical render path improves render performance.
The critical rendering path includes the Document Object Model (DOM), CSS Object Model (CSSOM), render tree and layout.

Lazy loading

Lazy loading is a strategy to identify resources as non-blocking (non-critical) and load these only when needed. It's a way to shorten the length of the critical rendering path, which translates into reduced page load times.

Speculative loading

Speculative loading refers to the practice of performing navigation actions (such as DNS fetching, fetching resources, or rendering documents) before the associated pages are actually visited, based on predictions as to what pages the user is most likely to visit next.

Performance budgets

A performance budget is a limit to prevent regressions. It can apply to a file, a file type, all files loaded on a page, a specific metric (e.g., Time to Interactive), a custom metric (e.g., Time to Hero Element), or a threshold over a period of time.

Performance Monitoring: RUM vs. synthetic monitoring

Synthetic monitoring and real user monitoring (RUM) are two approaches for monitoring and providing insight into web performance. RUM and synthetic monitoring provide for different views of performance and have benefits, good use cases and shortfalls. RUM is generally best suited for understanding long-term trends whereas synthetic monitoring is very well suited to regression testing and mitigating shorter-term performance issues during development. In this article we define and compare these two performance monitoring approaches.

CSS and JavaScript animation performance

Animations are critical for a pleasurable user experience on many applications. There are many ways to implement web animations, such as CSS transitions/animations or JavaScript-based animations (using requestAnimationFrame()). In this article, we analyze the performance differences between CSS-based and JavaScript-based animation.

Animation performance and frame rate

Animation on the web can be done via SVG, JavaScript, including <canvas> and WebGL, CSS animation, <video>, animated GIFs and even animated PNGs and other image types.
The performance cost of animating a CSS property can vary from one property to another, and animating expensive CSS properties can result in Jank as the browser struggles to hit a smooth frame rate.

Tutorials for beginnersThe MDN Web Performance Learning Area contains modern, up-to-date tutorials covering Performance essentials. Start here if you are a newcomer to performance:

Web performance: brief overview

Overview of the web performance learning path. Start your journey here.

What is web performance?

This article starts the module off with a good look at what performance actually is — this includes the tools, metrics, APIs, networks, and groups of people we need to consider when thinking about performance, and how we can make performance part of our web development workflow.

How do users perceive performance?

More important than how fast your website is in milliseconds, is how fast your users perceive your site to be. These perceptions are impacted by actual page load time, idling, responsiveness to user interaction, and the smoothness of scrolling and other animations. In this article, we discuss the various loading metrics, animation, and responsiveness metrics, along with best practices to improve user perception, if not the actual timings.

Web performance basics

In addition to the front end components of HTML, CSS, JavaScript, and media files, there are features that can make applications slower and features that can make applications subjectively and objectively faster. There are many APIs, developer tools, best practices, and bad practices relating to web performance. Here we'll introduce many of these features ad the basic level and provide links to deeper dives to improve performance for each topic.

HTML performance features

Some attributes and the source order of your markup can impact the performance of your website. By minimizing the number of DOM nodes, making sure the best order and attributes are used for including content such as styles, scripts, media, and third-party scripts, you can drastically improve the user experience. This article looks in detail at how HTML can be used to ensure maximum performance.

Multimedia: images and video

The lowest hanging fruit of web performance is often media optimization. Serving different media files based on each user agent's capability, size, and pixel density is possible. Additional tips like removing audio tracks from background videos can improve performance even further. In this article we discuss the impact video, audio, and image content has on performance, and the methods to ensure that impact is as minimal as possible.

CSS performance features

CSS may be a less important optimization focus for improved performance, but there are some CSS features that impact performance more than others. In this article we look at some CSS properties that impact performance and suggested ways of handling styles to ensure performance is not negatively impacted.

JavaScript performance best practices

JavaScript, when used properly, can allow for interactive and immersive web experiences — or it can significantly harm download time, render time, in-app performance, battery life, and user experience. This article outlines some JavaScript best practices that should be considered to ensure even complex content is as performant as possible.

Performance APIsThe Performance API is a group of standards used to measure the performance of web applications.
The following pages provide overviews of the Performance APIs including information on how to use them:

High precision timing

The Performance API allows high precision measurements that are based on time in potential sub-millisecond resolution and a stable monotonic clock that is not subject to system clock skew or adjustments.
The high resolution timers are needed for accurate benchmarking instead of the less precise and non-monotonic Date timestamps.

Long animation frame timing

Long animation frames (LoAFs) can impact the user experience of a website.
They can cause slow user interface (UI) updates, resulting in seemingly unresponsive controls and janky (or non-smooth) animated effects and scrolling, leading to user frustration.
The Long Animation Frames API allows developers to get information about the long animation frames and better understand their root causes. This article shows how to use the Long Animation Frames API.

Monitoring bfcache blocking reasons

The PerformanceNavigationTiming.notRestoredReasons property reports information on why the current document was blocked from using the bfcache on navigation.
Developers can use this information to identify pages that need updates to make them bfcache-compatible, thereby improving site performance.

Navigation timing

Navigation Timing provides metrics associated with navigating from one page to another via the PerformanceNavigationTiming API.
For example, you can determine how much time it takes to load or unload a document, or log the time it took until DOM construction has finished and interaction with the DOM is possible.

Performance data

The Performance API doesn't provide performance data analysis, or visualizations.
However, the Performance API is integrated well with developer tools and its data is often sent to analytics end points and libraries to record performance metrics which help you to evaluate the data to find performance bottlenecks affecting your users.
This page provides an overview about what sorts of Performance API data exists, how it is collected, and how it can be accessed.

Resource Timing API

Resource Timing enables retrieving and analyzing detailed network timing data for the loading of an application's resources.
An application can use the timing metrics to determine, for example, the length of time it takes to load a specific resource (such as an image or a script) either implicitly as part of page load or explicitly from JavaScript, for example using the fetch() API.

Server timing

Server-Timing allows servers to communicate metrics about the request-response cycle to the user agent.
You can collect this information and act on server-side metrics in the same way as all the other metrics processed with the Performance API.

User Timing API

Create application specific timestamps using the user timing API's "mark" and "measure" entry types using high-precision timestamps that are part of the browser's performance timeline.

Related APIsThe following APIs are also useful for measuring and influencing page performance:

Page Visibility API

Provides events you can watch for to know when a document becomes visible or hidden, as well as features to look at the current visibility state of the page.

Background Tasks API

The Cooperative Scheduling of Background Tasks API (also referred to as the Background Tasks API or the requestIdleCallback() API) provides the ability to queue tasks to be executed automatically by the user agent when it determines that there is free time to do so.

Beacon API

The Beacon interface schedules an asynchronous and non-blocking request to a web server.

Intersection Observer API

The Intersection Observer API provides a way to asynchronously observe changes in the intersection of a target element with an ancestor element or with a top-level document's Viewport.
This enabled use cases such as Timing element visibility to get asynchronously notified when elements of interest become visible.

Media Capabilities API

Exposes decoding and encoding abilities of a client device, such as whether media is supported and whether playback should be smooth and power efficient, with real time feedback about playback to better enable adaptive streaming, and access to display property information.

Network Information API

Information about the system's connection in terms of general connection type (e.g., 'wifi, 'cellular', etc.).
This can be used to select high definition content or low definition content based on the user's connection.

Battery Status API

The Battery API, provides information about the system's battery charge level and lets you be notified by events that are sent when the battery level or charging status change.
This can be used to adjust your app's resource usage to reduce battery drain when the battery is low, or to save changes before the battery runs out in order to prevent data loss.

Navigator.deviceMemory

The deviceMemory read-only property of the Navigator interface returns the approximate amount of device memory in gigabytes.

FetchEvent.preloadResponse

The preloadResponse read-only property of the FetchEvent interface returns a Promise that resolves to the navigation preload Response if navigation preload was triggered, or undefined otherwise.

Profiling and tooling
Firefox Profiler Performance Features

This website provides information on how to use and understand the performance features in your developer tools, including Call Tree, Flame Graph, Stack Chart, Marker Chart and Network Chart.

Profiling with the built-in profiler

Learn how to profile app performance with Firefox's built-in profiler.

ReferencesHTML
<picture> element
<video> element
<source> element
<img> attributes (like srcset) for responsive images
rel="preload" attribute for preloading content via HTML
CSS
will-change
JavaScript
DOMContentLoaded
Garbage collection
requestAnimationFrame
HTTP
Content-encoding
Resource hints via dns-prefetch, preconnect, prefetch, and prerender
HTTP/2
Client Hints
See also
Responsive images HTML guide
Web Workers API, including Using Service Workers and Using Web Workers
Offline and background operation
Caching
Client hints
Glossary terms:

Beacon
Brotli compression
Content Delivery Networks (CDN)
Cumulative Layout Shifts (CLS)
Code splitting
CSSOM
Domain sharding
Effective connection type
First contentful paint (FCP)
First CPU idle
First paint
gzip_compression
HTTP/2
HTTP
Interaction to next paint (INP)
Jank
Largest Contentful Paint (LCP)
Latency
Lazy load
Long task
Lossless compression
Lossy compression
Main thread
Minification
Network throttling
Packet
Page load time
Page prediction
Parse
Perceived performance
Prefetch
Prerender
QUIC
RAIL
Real User Monitoring (RUM)
Resource Timing
Round Trip Time (RTT)
Server Timing
Speculative parsing
Speed index (and Perceptual Speed Index)
SSL
Synthetic monitoring
TCP handshake
TCP slow start
Transmission Control Protocol (TCP)
Time to first byte (TTFB)
Time to interactive (TTI)
TLS
Tree shaking
Web performance


Performance in Firefox Developer Tools\n\nWeb performanceWeb performance is the objective measurements and the perceived user experience of load time and runtime.
Web performance is how long a site takes to load, become interactive and responsive, and how smooth the content is during user interactions.
Performance concerns questions like: Is scrolling smooth? Are buttons responsive? Do pop-ups load quickly and animate fluidly?
The objective measurements include time to load, frames per second, and time to become interactive, and subjective experience means how long it feels like it takes for content to load.
The longer it takes for a site to respond, the more users will abandon the site. It is important to minimize the loading and response times and add additional features to conceal latency by making the experience as available and interactive as possible, as soon as possible, while asynchronously loading in the longer tail parts of the experience.
There are tools, APIs, and best practices that help us measure and improve web performance. We cover them in the following pages.Web performance guides
Performance fundamentals

Performance means efficiency. In the context of Open Web Apps, this document explains in general what performance is, how the browser platform helps improve it, and what tools and processes you can use to test and improve it.

Populating the page: how browsers work

Users want web experiences with content that is fast to load and smooth to interact with. Therefore, a developer should strive to achieve these two goals.
To understand how to improve performance and perceived performance, it helps to understand how the browser works.

Understanding latency

Latency is the time it takes for a packet of data to travel from source to a destination. In terms of performance optimization, it's important to optimize to reduce causes of latency and to test site performance emulating high latency to optimize for users with slow or unreliable connections.

Recommended Web Performance Timings: How long is too long?

There are no clear set rules as to what constitutes a slow pace when loading pages, but there are specific guidelines for indicating content will load (1 second), idling (50ms), animating (16.7ms) and responding to user input (50 to 200ms).

Using dns-prefetch

DNS-prefetch is an attempt to resolve domain names before resources get requested. This could be a file loaded later or link target a user tries to follow.

Navigation and resource timings

Navigation timings are metrics measuring a browser's document navigation events. Resource timings are detailed network timing measurements regarding the loading of an application's resources. Both provide the same read-only properties, but navigation timing measures the main document's timings whereas the resource timing provides the times for all the assets or resources called in by that main document and the resources' requested resources.

Optimizing startup performance

Improving your startup performance is often one of the highest value performance optimizations that can be made.
Good user experience includes ensuring your app loads quickly. This article provides performance tips and suggestions for both writing new applications and porting applications to the web from other platforms.

Critical rendering path

The Critical Rendering Path is the sequence of steps the browser goes through to convert the HTML, CSS, and JavaScript into pixels on the screen. Optimizing the critical render path improves render performance.
The critical rendering path includes the Document Object Model (DOM), CSS Object Model (CSSOM), render tree and layout.

Lazy loading

Lazy loading is a strategy to identify resources as non-blocking (non-critical) and load these only when needed. It's a way to shorten the length of the critical rendering path, which translates into reduced page load times.

Speculative loading

Speculative loading refers to the practice of performing navigation actions (such as DNS fetching, fetching resources, or rendering documents) before the associated pages are actually visited, based on predictions as to what pages the user is most likely to visit next.

Performance budgets

A performance budget is a limit to prevent regressions. It can apply to a file, a file type, all files loaded on a page, a specific metric (e.g., Time to Interactive), a custom metric (e.g., Time to Hero Element), or a threshold over a period of time.

Performance Monitoring: RUM vs. synthetic monitoring

Synthetic monitoring and real user monitoring (RUM) are two approaches for monitoring and providing insight into web performance. RUM and synthetic monitoring provide for different views of performance and have benefits, good use cases and shortfalls. RUM is generally best suited for understanding long-term trends whereas synthetic monitoring is very well suited to regression testing and mitigating shorter-term performance issues during development. In this article we define and compare these two performance monitoring approaches.

CSS and JavaScript animation performance

Animations are critical for a pleasurable user experience on many applications. There are many ways to implement web animations, such as CSS transitions/animations or JavaScript-based animations (using requestAnimationFrame()). In this article, we analyze the performance differences between CSS-based and JavaScript-based animation.

Animation performance and frame rate

Animation on the web can be done via SVG, JavaScript, including <canvas> and WebGL, CSS animation, <video>, animated GIFs and even animated PNGs and other image types.
The performance cost of animating a CSS property can vary from one property to another, and animating expensive CSS properties can result in Jank as the browser struggles to hit a smooth frame rate.

Tutorials for beginnersThe MDN Web Performance Learning Area contains modern, up-to-date tutorials covering Performance essentials. Start here if you are a newcomer to performance:

Web performance: brief overview

Overview of the web performance learning path. Start your journey here.

What is web performance?

This article starts the module off with a good look at what performance actually is — this includes the tools, metrics, APIs, networks, and groups of people we need to consider when thinking about performance, and how we can make performance part of our web development workflow.

How do users perceive performance?

More important than how fast your website is in milliseconds, is how fast your users perceive your site to be. These perceptions are impacted by actual page load time, idling, responsiveness to user interaction, and the smoothness of scrolling and other animations. In this article, we discuss the various loading metrics, animation, and responsiveness metrics, along with best practices to improve user perception, if not the actual timings.

Web performance basics

In addition to the front end components of HTML, CSS, JavaScript, and media files, there are features that can make applications slower and features that can make applications subjectively and objectively faster. There are many APIs, developer tools, best practices, and bad practices relating to web performance. Here we'll introduce many of these features ad the basic level and provide links to deeper dives to improve performance for each topic.

HTML performance features

Some attributes and the source order of your markup can impact the performance of your website. By minimizing the number of DOM nodes, making sure the best order and attributes are used for including content such as styles, scripts, media, and third-party scripts, you can drastically improve the user experience. This article looks in detail at how HTML can be used to ensure maximum performance.

Multimedia: images and video

The lowest hanging fruit of web performance is often media optimization. Serving different media files based on each user agent's capability, size, and pixel density is possible. Additional tips like removing audio tracks from background videos can improve performance even further. In this article we discuss the impact video, audio, and image content has on performance, and the methods to ensure that impact is as minimal as possible.

CSS performance features

CSS may be a less important optimization focus for improved performance, but there are some CSS features that impact performance more than others. In this article we look at some CSS properties that impact performance and suggested ways of handling styles to ensure performance is not negatively impacted.

JavaScript performance best practices

JavaScript, when used properly, can allow for interactive and immersive web experiences — or it can significantly harm download time, render time, in-app performance, battery life, and user experience. This article outlines some JavaScript best practices that should be considered to ensure even complex content is as performant as possible.

Performance APIsThe Performance API is a group of standards used to measure the performance of web applications.
The following pages provide overviews of the Performance APIs including information on how to use them:

High precision timing

The Performance API allows high precision measurements that are based on time in potential sub-millisecond resolution and a stable monotonic clock that is not subject to system clock skew or adjustments.
The high resolution timers are needed for accurate benchmarking instead of the less precise and non-monotonic Date timestamps.

Long animation frame timing

Long animation frames (LoAFs) can impact the user experience of a website.
They can cause slow user interface (UI) updates, resulting in seemingly unresponsive controls and janky (or non-smooth) animated effects and scrolling, leading to user frustration.
The Long Animation Frames API allows developers to get information about the long animation frames and better understand their root causes. This article shows how to use the Long Animation Frames API.

Monitoring bfcache blocking reasons

The PerformanceNavigationTiming.notRestoredReasons property reports information on why the current document was blocked from using the bfcache on navigation.
Developers can use this information to identify pages that need updates to make them bfcache-compatible, thereby improving site performance.

Navigation timing

Navigation Timing provides metrics associated with navigating from one page to another via the PerformanceNavigationTiming API.
For example, you can determine how much time it takes to load or unload a document, or log the time it took until DOM construction has finished and interaction with the DOM is possible.

Performance data

The Performance API doesn't provide performance data analysis, or visualizations.
However, the Performance API is integrated well with developer tools and its data is often sent to analytics end points and libraries to record performance metrics which help you to evaluate the data to find performance bottlenecks affecting your users.
This page provides an overview about what sorts of Performance API data exists, how it is collected, and how it can be accessed.

Resource Timing API

Resource Timing enables retrieving and analyzing detailed network timing data for the loading of an application's resources.
An application can use the timing metrics to determine, for example, the length of time it takes to load a specific resource (such as an image or a script) either implicitly as part of page load or explicitly from JavaScript, for example using the fetch() API.

Server timing

Server-Timing allows servers to communicate metrics about the request-response cycle to the user agent.
You can collect this information and act on server-side metrics in the same way as all the other metrics processed with the Performance API.

User Timing API

Create application specific timestamps using the user timing API's "mark" and "measure" entry types using high-precision timestamps that are part of the browser's performance timeline.

Related APIsThe following APIs are also useful for measuring and influencing page performance:

Page Visibility API

Provides events you can watch for to know when a document becomes visible or hidden, as well as features to look at the current visibility state of the page.

Background Tasks API

The Cooperative Scheduling of Background Tasks API (also referred to as the Background Tasks API or the requestIdleCallback() API) provides the ability to queue tasks to be executed automatically by the user agent when it determines that there is free time to do so.

Beacon API

The Beacon interface schedules an asynchronous and non-blocking request to a web server.

Intersection Observer API

The Intersection Observer API provides a way to asynchronously observe changes in the intersection of a target element with an ancestor element or with a top-level document's Viewport.
This enabled use cases such as Timing element visibility to get asynchronously notified when elements of interest become visible.

Media Capabilities API

Exposes decoding and encoding abilities of a client device, such as whether media is supported and whether playback should be smooth and power efficient, with real time feedback about playback to better enable adaptive streaming, and access to display property information.

Network Information API

Information about the system's connection in terms of general connection type (e.g., 'wifi, 'cellular', etc.).
This can be used to select high definition content or low definition content based on the user's connection.

Battery Status API

The Battery API, provides information about the system's battery charge level and lets you be notified by events that are sent when the battery level or charging status change.
This can be used to adjust your app's resource usage to reduce battery drain when the battery is low, or to save changes before the battery runs out in order to prevent data loss.

Navigator.deviceMemory

The deviceMemory read-only property of the Navigator interface returns the approximate amount of device memory in gigabytes.

FetchEvent.preloadResponse

The preloadResponse read-only property of the FetchEvent interface returns a Promise that resolves to the navigation preload Response if navigation preload was triggered, or undefined otherwise.

Profiling and tooling
Firefox Profiler Performance Features

This website provides information on how to use and understand the performance features in your developer tools, including Call Tree, Flame Graph, Stack Chart, Marker Chart and Network Chart.

Profiling with the built-in profiler

Learn how to profile app performance with Firefox's built-in profiler.

ReferencesHTML
<picture> element
<video> element
<source> element
<img> attributes (like srcset) for responsive images
rel="preload" attribute for preloading content via HTML
CSS
will-change
JavaScript
DOMContentLoaded
Garbage collection
requestAnimationFrame
HTTP
Content-encoding
Resource hints via dns-prefetch, preconnect, prefetch, and prerender
HTTP/2
Client Hints
See also
Responsive images HTML guide
Web Workers API, including Using Service Workers and Using Web Workers
Offline and background operation
Caching
Client hints
Glossary terms:

Beacon
Brotli compression
Content Delivery Networks (CDN)
Cumulative Layout Shifts (CLS)
Code splitting
CSSOM
Domain sharding
Effective connection type
First contentful paint (FCP)
First CPU idle
First paint
gzip_compression
HTTP/2
HTTP
Interaction to next paint (INP)
Jank
Largest Contentful Paint (LCP)
Latency
Lazy load
Long task
Lossless compression
Lossy compression
Main thread
Minification
Network throttling
Packet
Page load time
Page prediction
Parse
Perceived performance
Prefetch
Prerender
QUIC
RAIL
Real User Monitoring (RUM)
Resource Timing
Round Trip Time (RTT)
Server Timing
Speculative parsing
Speed index (and Perceptual Speed Index)
SSL
Synthetic monitoring
TCP handshake
TCP slow start
Transmission Control Protocol (TCP)
Time to first byte (TTFB)
Time to interactive (TTI)
TLS
Tree shaking
Web performance


Performance in Firefox Developer Tools
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWeb performanceWeb performance is the objective measurements and the perceived user experience of load time and runtime.
Web performance is how long a site takes to load, become interactive and responsive, and how smooth the content is during user interactions.
Performance concerns questions like: Is scrolling smooth? Are buttons responsive? Do pop-ups load quickly and animate fluidly?
The objective measurements include time to load, frames per second, and time to become interactive, and subjective experience means how long it feels like it takes for content to load.
The longer it takes for a site to respond, the more users will abandon the site. It is important to minimize the loading and response times and add additional features to conceal latency by making the experience as available and interactive as possible, as soon as possible, while asynchronously loading in the longer tail parts of the experience.
There are tools, APIs, and best practices that help us measure and improve web performance. We cover them in the following pages.Web performance guides
Performance fundamentals

Performance means efficiency. In the context of Open Web Apps, this document explains in general what performance is, how the browser platform helps improve it, and what tools and processes you can use to test and improve it.

Populating the page: how browsers work

Users want web experiences with content that is fast to load and smooth to interact with. Therefore, a developer should strive to achieve these two goals.
To understand how to improve performance and perceived performance, it helps to understand how the browser works.

Understanding latency

Latency is the time it takes for a packet of data to travel from source to a destination. In terms of performance optimization, it's important to optimize to reduce causes of latency and to test site performance emulating high latency to optimize for users with slow or unreliable connections.

Recommended Web Performance Timings: How long is too long?

There are no clear set rules as to what constitutes a slow pace when loading pages, but there are specific guidelines for indicating content will load (1 second), idling (50ms), animating (16.7ms) and responding to user input (50 to 200ms).

Using dns-prefetch

DNS-prefetch is an attempt to resolve domain names before resources get requested. This could be a file loaded later or link target a user tries to follow.

Navigation and resource timings

Navigation timings are metrics measuring a browser's document navigation events. Resource timings are detailed network timing measurements regarding the loading of an application's resources. Both provide the same read-only properties, but navigation timing measures the main document's timings whereas the resource timing provides the times for all the assets or resources called in by that main document and the resources' requested resources.

Optimizing startup performance

Improving your startup performance is often one of the highest value performance optimizations that can be made.
Good user experience includes ensuring your app loads quickly. This article provides performance tips and suggestions for both writing new applications and porting applications to the web from other platforms.

Critical rendering path

The Critical Rendering Path is the sequence of steps the browser goes through to convert the HTML, CSS, and JavaScript into pixels on the screen. Optimizing the critical render path improves render performance.
The critical rendering path includes the Document Object Model (DOM), CSS Object Model (CSSOM), render tree and layout.

Lazy loading

Lazy loading is a strategy to identify resources as non-blocking (non-critical) and load these only when needed. It's a way to shorten the length of the critical rendering path, which translates into reduced page load times.

Speculative loading

Speculative loading refers to the practice of performing navigation actions (such as DNS fetching, fetching resources, or rendering documents) before the associated pages are actually visited, based on predictions as to what pages the user is most likely to visit next.

Performance budgets

A performance budget is a limit to prevent regressions. It can apply to a file, a file type, all files loaded on a page, a specific metric (e.g., Time to Interactive), a custom metric (e.g., Time to Hero Element), or a threshold over a period of time.

Performance Monitoring: RUM vs. synthetic monitoring

Synthetic monitoring and real user monitoring (RUM) are two approaches for monitoring and providing insight into web performance. RUM and synthetic monitoring provide for different views of performance and have benefits, good use cases and shortfalls. RUM is generally best suited for understanding long-term trends whereas synthetic monitoring is very well suited to regression testing and mitigating shorter-term performance issues during development. In this article we define and compare these two performance monitoring approaches.

CSS and JavaScript animation performance

Animations are critical for a pleasurable user experience on many applications. There are many ways to implement web animations, such as CSS transitions/animations or JavaScript-based animations (using requestAnimationFrame()). In this article, we analyze the performance differences between CSS-based and JavaScript-based animation.

Animation performance and frame rate

Animation on the web can be done via SVG, JavaScript, including <canvas> and WebGL, CSS animation, <video>, animated GIFs and even animated PNGs and other image types.
The performance cost of animating a CSS property can vary from one property to another, and animating expensive CSS properties can result in Jank as the browser struggles to hit a smooth frame rate.

Tutorials for beginnersThe MDN Web Performance Learning Area contains modern, up-to-date tutorials covering Performance essentials. Start here if you are a newcomer to performance:

Web performance: brief overview

Overview of the web performance learning path. Start your journey here.

What is web performance?

This article starts the module off with a good look at what performance actually is — this includes the tools, metrics, APIs, networks, and groups of people we need to consider when thinking about performance, and how we can make performance part of our web development workflow.

How do users perceive performance?

More important than how fast your website is in milliseconds, is how fast your users perceive your site to be. These perceptions are impacted by actual page load time, idling, responsiveness to user interaction, and the smoothness of scrolling and other animations. In this article, we discuss the various loading metrics, animation, and responsiveness metrics, along with best practices to improve user perception, if not the actual timings.

Web performance basics

In addition to the front end components of HTML, CSS, JavaScript, and media files, there are features that can make applications slower and features that can make applications subjectively and objectively faster. There are many APIs, developer tools, best practices, and bad practices relating to web performance. Here we'll introduce many of these features ad the basic level and provide links to deeper dives to improve performance for each topic.

HTML performance features

Some attributes and the source order of your markup can impact the performance of your website. By minimizing the number of DOM nodes, making sure the best order and attributes are used for including content such as styles, scripts, media, and third-party scripts, you can drastically improve the user experience. This article looks in detail at how HTML can be used to ensure maximum performance.

Multimedia: images and video

The lowest hanging fruit of web performance is often media optimization. Serving different media files based on each user agent's capability, size, and pixel density is possible. Additional tips like removing audio tracks from background videos can improve performance even further. In this article we discuss the impact video, audio, and image content has on performance, and the methods to ensure that impact is as minimal as possible.

CSS performance features

CSS may be a less important optimization focus for improved performance, but there are some CSS features that impact performance more than others. In this article we look at some CSS properties that impact performance and suggested ways of handling styles to ensure performance is not negatively impacted.

JavaScript performance best practices

JavaScript, when used properly, can allow for interactive and immersive web experiences — or it can significantly harm download time, render time, in-app performance, battery life, and user experience. This article outlines some JavaScript best practices that should be considered to ensure even complex content is as performant as possible.

Performance APIsThe Performance API is a group of standards used to measure the performance of web applications.
The following pages provide overviews of the Performance APIs including information on how to use them:

High precision timing

The Performance API allows high precision measurements that are based on time in potential sub-millisecond resolution and a stable monotonic clock that is not subject to system clock skew or adjustments.
The high resolution timers are needed for accurate benchmarking instead of the less precise and non-monotonic Date timestamps.

Long animation frame timing

Long animation frames (LoAFs) can impact the user experience of a website.
They can cause slow user interface (UI) updates, resulting in seemingly unresponsive controls and janky (or non-smooth) animated effects and scrolling, leading to user frustration.
The Long Animation Frames API allows developers to get information about the long animation frames and better understand their root causes. This article shows how to use the Long Animation Frames API.

Monitoring bfcache blocking reasons

The PerformanceNavigationTiming.notRestoredReasons property reports information on why the current document was blocked from using the bfcache on navigation.
Developers can use this information to identify pages that need updates to make them bfcache-compatible, thereby improving site performance.

Navigation timing

Navigation Timing provides metrics associated with navigating from one page to another via the PerformanceNavigationTiming API.
For example, you can determine how much time it takes to load or unload a document, or log the time it took until DOM construction has finished and interaction with the DOM is possible.

Performance data

The Performance API doesn't provide performance data analysis, or visualizations.
However, the Performance API is integrated well with developer tools and its data is often sent to analytics end points and libraries to record performance metrics which help you to evaluate the data to find performance bottlenecks affecting your users.
This page provides an overview about what sorts of Performance API data exists, how it is collected, and how it can be accessed.

Resource Timing API

Resource Timing enables retrieving and analyzing detailed network timing data for the loading of an application's resources.
An application can use the timing metrics to determine, for example, the length of time it takes to load a specific resource (such as an image or a script) either implicitly as part of page load or explicitly from JavaScript, for example using the fetch() API.

Server timing

Server-Timing allows servers to communicate metrics about the request-response cycle to the user agent.
You can collect this information and act on server-side metrics in the same way as all the other metrics processed with the Performance API.

User Timing API

Create application specific timestamps using the user timing API's "mark" and "measure" entry types using high-precision timestamps that are part of the browser's performance timeline.

Related APIsThe following APIs are also useful for measuring and influencing page performance:

Page Visibility API

Provides events you can watch for to know when a document becomes visible or hidden, as well as features to look at the current visibility state of the page.

Background Tasks API

The Cooperative Scheduling of Background Tasks API (also referred to as the Background Tasks API or the requestIdleCallback() API) provides the ability to queue tasks to be executed automatically by the user agent when it determines that there is free time to do so.

Beacon API

The Beacon interface schedules an asynchronous and non-blocking request to a web server.

Intersection Observer API

The Intersection Observer API provides a way to asynchronously observe changes in the intersection of a target element with an ancestor element or with a top-level document's Viewport.
This enabled use cases such as Timing element visibility to get asynchronously notified when elements of interest become visible.

Media Capabilities API

Exposes decoding and encoding abilities of a client device, such as whether media is supported and whether playback should be smooth and power efficient, with real time feedback about playback to better enable adaptive streaming, and access to display property information.

Network Information API

Information about the system's connection in terms of general connection type (e.g., 'wifi, 'cellular', etc.).
This can be used to select high definition content or low definition content based on the user's connection.

Battery Status API

The Battery API, provides information about the system's battery charge level and lets you be notified by events that are sent when the battery level or charging status change.
This can be used to adjust your app's resource usage to reduce battery drain when the battery is low, or to save changes before the battery runs out in order to prevent data loss.

Navigator.deviceMemory

The deviceMemory read-only property of the Navigator interface returns the approximate amount of device memory in gigabytes.

FetchEvent.preloadResponse

The preloadResponse read-only property of the FetchEvent interface returns a Promise that resolves to the navigation preload Response if navigation preload was triggered, or undefined otherwise.

Profiling and tooling
Firefox Profiler Performance Features

This website provides information on how to use and understand the performance features in your developer tools, including Call Tree, Flame Graph, Stack Chart, Marker Chart and Network Chart.

Profiling with the built-in profiler

Learn how to profile app performance with Firefox's built-in profiler.

ReferencesHTML
<picture> element
<video> element
<source> element
<img> attributes (like srcset) for responsive images
rel="preload" attribute for preloading content via HTML
CSS
will-change
JavaScript
DOMContentLoaded
Garbage collection
requestAnimationFrame
HTTP
Content-encoding
Resource hints via dns-prefetch, preconnect, prefetch, and prerender
HTTP/2
Client Hints
See also
Responsive images HTML guide
Web Workers API, including Using Service Workers and Using Web Workers
Offline and background operation
Caching
Client hints
Glossary terms:

Beacon
Brotli compression
Content Delivery Networks (CDN)
Cumulative Layout Shifts (CLS)
Code splitting
CSSOM
Domain sharding
Effective connection type
First contentful paint (FCP)
First CPU idle
First paint
gzip_compression
HTTP/2
HTTP
Interaction to next paint (INP)
Jank
Largest Contentful Paint (LCP)
Latency
Lazy load
Long task
Lossless compression
Lossy compression
Main thread
Minification
Network throttling
Packet
Page load time
Page prediction
Parse
Perceived performance
Prefetch
Prerender
QUIC
RAIL
Real User Monitoring (RUM)
Resource Timing
Round Trip Time (RTT)
Server Timing
Speculative parsing
Speed index (and Perceptual Speed Index)
SSL
Synthetic monitoring
TCP handshake
TCP slow start
Transmission Control Protocol (TCP)
Time to first byte (TTFB)
Time to interactive (TTI)
TLS
Tree shaking
Web performance


Performance in Firefox Developer Tools
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nWebDriverWebDriver is a remote control interface that enables introspection and control of user agents. It provides a platform- and language-neutral wire protocol as a way for out-of-process programs to remotely instruct the behavior of web browsers.
To have the ability to write instruction sets that can be run interchangeably in many browsers on different platforms is critical to deliver a consistent experience to users. With the new wave of developments on the web platform, the increase diversity in devices and demands for real interoperability between the technologies, WebDriver provides tooling for cross-browser testing.
Provided is a set of interfaces to discover and manipulate DOM elements in web documents and to control the behavior of a user agent. It is primarily intended to allow web authors to write tests that automate a user agent from a separate controlling process, but may also be used in such a way as to allow in-browser scripts to control a — possibly separate — browser.UsageSo what does WebDriver let you do and what does it look like? Since WebDriver is programming language neutral, the answer to this question depends on which WebDriver client you're using and the choice of language.
But using a popular client written in Python, your interaction with WebDriver might look like this:
pythonfrom selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support.expected_conditions import presence_of_element_located

with webdriver.Firefox() as driver:

    driver.get("https://google.com/ncr")
    wait = WebDriverWait(driver, 10)
    driver.find_element(By.NAME, "q").send_keys("cheese" + Keys.RETURN)
    wait.until(presence_of_element_located((By.XPATH, '//*[@id="rcnt"]')))
    results = driver.find_elements(By.XPATH, "//a[@href]")

    for i, elem in enumerate(results):
        print(f'#{i} {elem.text} ({elem.get_attribute("href")})')

This might produce output akin to this:
#1 Cheese - Wikipedia (https://en.wikipedia.org/wiki/Cheese)
Reference
Timeouts
CommandsClose WindowGet Element AttributeGet Element PropertyGet Element Tag NameGet TimeoutsGet Window HandlesGet Window RectNew WindowSet TimeoutsSet Window RectCapabilitiesacceptInsecureCertsfirefoxOptionswebSocketUrlErrorsInsecure certificateInvalid argumentInvalid cookie domainInvalid selectorInvalid session IDJavaScript errorScript timeoutStale element referenceUnknown commandUnknown errorUnknown methodSpecifications
WebDriver
See also
Testing
Selenium documentation\n\nWebDriverWebDriver is a remote control interface that enables introspection and control of user agents. It provides a platform- and language-neutral wire protocol as a way for out-of-process programs to remotely instruct the behavior of web browsers.
To have the ability to write instruction sets that can be run interchangeably in many browsers on different platforms is critical to deliver a consistent experience to users. With the new wave of developments on the web platform, the increase diversity in devices and demands for real interoperability between the technologies, WebDriver provides tooling for cross-browser testing.
Provided is a set of interfaces to discover and manipulate DOM elements in web documents and to control the behavior of a user agent. It is primarily intended to allow web authors to write tests that automate a user agent from a separate controlling process, but may also be used in such a way as to allow in-browser scripts to control a — possibly separate — browser.UsageSo what does WebDriver let you do and what does it look like? Since WebDriver is programming language neutral, the answer to this question depends on which WebDriver client you're using and the choice of language.
But using a popular client written in Python, your interaction with WebDriver might look like this:
pythonfrom selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support.expected_conditions import presence_of_element_located

with webdriver.Firefox() as driver:

    driver.get("https://google.com/ncr")
    wait = WebDriverWait(driver, 10)
    driver.find_element(By.NAME, "q").send_keys("cheese" + Keys.RETURN)
    wait.until(presence_of_element_located((By.XPATH, '//*[@id="rcnt"]')))
    results = driver.find_elements(By.XPATH, "//a[@href]")

    for i, elem in enumerate(results):
        print(f'#{i} {elem.text} ({elem.get_attribute("href")})')

This might produce output akin to this:
#1 Cheese - Wikipedia (https://en.wikipedia.org/wiki/Cheese)
Reference
Timeouts
CommandsClose WindowGet Element AttributeGet Element PropertyGet Element Tag NameGet TimeoutsGet Window HandlesGet Window RectNew WindowSet TimeoutsSet Window RectCapabilitiesacceptInsecureCertsfirefoxOptionswebSocketUrlErrorsInsecure certificateInvalid argumentInvalid cookie domainInvalid selectorInvalid session IDJavaScript errorScript timeoutStale element referenceUnknown commandUnknown errorUnknown methodSpecifications
WebDriver
See also
Testing
Selenium documentation
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 28, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWebDriverWebDriver is a remote control interface that enables introspection and control of user agents. It provides a platform- and language-neutral wire protocol as a way for out-of-process programs to remotely instruct the behavior of web browsers.
To have the ability to write instruction sets that can be run interchangeably in many browsers on different platforms is critical to deliver a consistent experience to users. With the new wave of developments on the web platform, the increase diversity in devices and demands for real interoperability between the technologies, WebDriver provides tooling for cross-browser testing.
Provided is a set of interfaces to discover and manipulate DOM elements in web documents and to control the behavior of a user agent. It is primarily intended to allow web authors to write tests that automate a user agent from a separate controlling process, but may also be used in such a way as to allow in-browser scripts to control a — possibly separate — browser.UsageSo what does WebDriver let you do and what does it look like? Since WebDriver is programming language neutral, the answer to this question depends on which WebDriver client you're using and the choice of language.
But using a popular client written in Python, your interaction with WebDriver might look like this:
pythonfrom selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support.expected_conditions import presence_of_element_located

with webdriver.Firefox() as driver:

    driver.get("https://google.com/ncr")
    wait = WebDriverWait(driver, 10)
    driver.find_element(By.NAME, "q").send_keys("cheese" + Keys.RETURN)
    wait.until(presence_of_element_located((By.XPATH, '//*[@id="rcnt"]')))
    results = driver.find_elements(By.XPATH, "//a[@href]")

    for i, elem in enumerate(results):
        print(f'#{i} {elem.text} ({elem.get_attribute("href")})')

This might produce output akin to this:
#1 Cheese - Wikipedia (https://en.wikipedia.org/wiki/Cheese)
Reference
Timeouts
CommandsClose WindowGet Element AttributeGet Element PropertyGet Element Tag NameGet TimeoutsGet Window HandlesGet Window RectNew WindowSet TimeoutsSet Window RectCapabilitiesacceptInsecureCertsfirefoxOptionswebSocketUrlErrorsInsecure certificateInvalid argumentInvalid cookie domainInvalid selectorInvalid session IDJavaScript errorScript timeoutStale element referenceUnknown commandUnknown errorUnknown methodSpecifications
WebDriver
See also
Testing
Selenium documentation
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 28, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nXML: Extensible Markup LanguageThe Extensible Markup Language is a strict serialization of the Document Object Model.
EXSLTEXSLT is a set of extensions to XSLT. There are a number of modules; those that are supported by Firefox are listed below:XML GuidesThis page lists guides for XML.XPathXPath stands for XML Path Language. It uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.XSLT: Extensible Stylesheet Language TransformationsExtensible Stylesheet Language Transformations (XSLT) is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.\n\nXML: Extensible Markup LanguageThe Extensible Markup Language is a strict serialization of the Document Object Model.
EXSLTEXSLT is a set of extensions to XSLT. There are a number of modules; those that are supported by Firefox are listed below:XML GuidesThis page lists guides for XML.XPathXPath stands for XML Path Language. It uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.XSLT: Extensible Stylesheet Language TransformationsExtensible Stylesheet Language Transformations (XSLT) is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 5, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nXML: Extensible Markup LanguageThe Extensible Markup Language is a strict serialization of the Document Object Model.
EXSLTEXSLT is a set of extensions to XSLT. There are a number of modules; those that are supported by Firefox are listed below:XML GuidesThis page lists guides for XML.XPathXPath stands for XML Path Language. It uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.XSLT: Extensible Stylesheet Language TransformationsExtensible Stylesheet Language Transformations (XSLT) is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 5, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nWeb developer guidesThere are many guides on MDN Web Docs that teach you how to use features or APIs through practical examples.
This page is a curated list of some of the most popular goal-oriented learning material.HTML
Structuring the web with HTML

The HTML learning area offers tutorials to help you learn HTML from the ground up.

HTML basics

This article will give you a basic understanding of HTML. After following this guide, you can further explore the material in the HTML Learning Area.

CSS
Learn to style HTML using CSS

Our complete CSS tutorial, taking you from first steps through styling text, creating layouts, and more.

CSS Layout Guides

There are a large number of guides to CSS Layout across MDN, this page collects them all together.

Using CSS animations

CSS animations make it possible to animate transitions from one CSS style configuration to another. This guide will help you get started with the animation properties.

JavaScript
JavaScript learning area

Whether you are a complete beginner, or hoping to refresh your skills, this is the place to start.

Media
Audio and video delivery

We can deliver audio and video on the web in several ways, ranging from 'static' media files to adaptive live streams. This article is intended as a starting point for exploring the various delivery mechanisms of web-based media and compatibility with popular browsers.

Audio and video manipulation

The beauty of the web is that you can combine technologies to create new forms. Having native audio and video in the browser means we can use these data streams with technologies such as <canvas>, WebGL or Web Audio API to modify audio and video directly, for example adding reverb/compression effects to audio, or grayscale/sepia filters to video. This article provides a reference to explain what you need to do.

APIs
Using FormData objects

The FormData object lets you compile a set of key/value pairs to send using fetch(). It's primarily intended for sending form data, but can be used independently of forms to transmit keyed data. The transmission is in the same format that the form's submit() method would use to send the data if the form's encoding type were set to "multipart/form-data".

Progressive web apps

Progressive web apps (PWAs) use modern web APIs along with traditional progressive enhancement strategy to create cross-platform web applications. These apps work everywhere and provide several features that give them the same user experience advantages as native apps. This set of guides tells you all you need to know about PWAs.

Parsing and serializing XML

The web platform provides different methods of parsing and serializing XML, each with its pros and cons.

Performance
Optimization and performance

When building modern web apps and sites, it's important to make your content work quickly and efficiently. This lets it perform effectively for both powerful desktop systems and weaker handheld devices.

Mobile web development
Learn: Responsive design

This article provides an overview of some main techniques needed to design websites that work well on mobile devices.

Fonts
Variable fonts guide

Find out how to use variable fonts in your designs.

The Web Open Font Format (WOFF)

WOFF (Web Open Font Format) is a font file format that is free for anyone to use on the web.

User interface development
User input methods and controls

User input goes beyond just a mouse and keyboard: think of touchscreens for example. This article provides recommendations for managing user input and implementing controls in open web apps, along with FAQs, real-world examples, and links to further information for anyone needing more detailed information on the underlying technologies.\n\nWeb developer guidesThere are many guides on MDN Web Docs that teach you how to use features or APIs through practical examples.
This page is a curated list of some of the most popular goal-oriented learning material.HTML
Structuring the web with HTML

The HTML learning area offers tutorials to help you learn HTML from the ground up.

HTML basics

This article will give you a basic understanding of HTML. After following this guide, you can further explore the material in the HTML Learning Area.

CSS
Learn to style HTML using CSS

Our complete CSS tutorial, taking you from first steps through styling text, creating layouts, and more.

CSS Layout Guides

There are a large number of guides to CSS Layout across MDN, this page collects them all together.

Using CSS animations

CSS animations make it possible to animate transitions from one CSS style configuration to another. This guide will help you get started with the animation properties.

JavaScript
JavaScript learning area

Whether you are a complete beginner, or hoping to refresh your skills, this is the place to start.

Media
Audio and video delivery

We can deliver audio and video on the web in several ways, ranging from 'static' media files to adaptive live streams. This article is intended as a starting point for exploring the various delivery mechanisms of web-based media and compatibility with popular browsers.

Audio and video manipulation

The beauty of the web is that you can combine technologies to create new forms. Having native audio and video in the browser means we can use these data streams with technologies such as <canvas>, WebGL or Web Audio API to modify audio and video directly, for example adding reverb/compression effects to audio, or grayscale/sepia filters to video. This article provides a reference to explain what you need to do.

APIs
Using FormData objects

The FormData object lets you compile a set of key/value pairs to send using fetch(). It's primarily intended for sending form data, but can be used independently of forms to transmit keyed data. The transmission is in the same format that the form's submit() method would use to send the data if the form's encoding type were set to "multipart/form-data".

Progressive web apps

Progressive web apps (PWAs) use modern web APIs along with traditional progressive enhancement strategy to create cross-platform web applications. These apps work everywhere and provide several features that give them the same user experience advantages as native apps. This set of guides tells you all you need to know about PWAs.

Parsing and serializing XML

The web platform provides different methods of parsing and serializing XML, each with its pros and cons.

Performance
Optimization and performance

When building modern web apps and sites, it's important to make your content work quickly and efficiently. This lets it perform effectively for both powerful desktop systems and weaker handheld devices.

Mobile web development
Learn: Responsive design

This article provides an overview of some main techniques needed to design websites that work well on mobile devices.

Fonts
Variable fonts guide

Find out how to use variable fonts in your designs.

The Web Open Font Format (WOFF)

WOFF (Web Open Font Format) is a font file format that is free for anyone to use on the web.

User interface development
User input methods and controls

User input goes beyond just a mouse and keyboard: think of touchscreens for example. This article provides recommendations for managing user input and implementing controls in open web apps, along with FAQs, real-world examples, and links to further information for anyone needing more detailed information on the underlying technologies.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 25, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWeb developer guidesThere are many guides on MDN Web Docs that teach you how to use features or APIs through practical examples.
This page is a curated list of some of the most popular goal-oriented learning material.HTML
Structuring the web with HTML

The HTML learning area offers tutorials to help you learn HTML from the ground up.

HTML basics

This article will give you a basic understanding of HTML. After following this guide, you can further explore the material in the HTML Learning Area.

CSS
Learn to style HTML using CSS

Our complete CSS tutorial, taking you from first steps through styling text, creating layouts, and more.

CSS Layout Guides

There are a large number of guides to CSS Layout across MDN, this page collects them all together.

Using CSS animations

CSS animations make it possible to animate transitions from one CSS style configuration to another. This guide will help you get started with the animation properties.

JavaScript
JavaScript learning area

Whether you are a complete beginner, or hoping to refresh your skills, this is the place to start.

Media
Audio and video delivery

We can deliver audio and video on the web in several ways, ranging from 'static' media files to adaptive live streams. This article is intended as a starting point for exploring the various delivery mechanisms of web-based media and compatibility with popular browsers.

Audio and video manipulation

The beauty of the web is that you can combine technologies to create new forms. Having native audio and video in the browser means we can use these data streams with technologies such as <canvas>, WebGL or Web Audio API to modify audio and video directly, for example adding reverb/compression effects to audio, or grayscale/sepia filters to video. This article provides a reference to explain what you need to do.

APIs
Using FormData objects

The FormData object lets you compile a set of key/value pairs to send using fetch(). It's primarily intended for sending form data, but can be used independently of forms to transmit keyed data. The transmission is in the same format that the form's submit() method would use to send the data if the form's encoding type were set to "multipart/form-data".

Progressive web apps

Progressive web apps (PWAs) use modern web APIs along with traditional progressive enhancement strategy to create cross-platform web applications. These apps work everywhere and provide several features that give them the same user experience advantages as native apps. This set of guides tells you all you need to know about PWAs.

Parsing and serializing XML

The web platform provides different methods of parsing and serializing XML, each with its pros and cons.

Performance
Optimization and performance

When building modern web apps and sites, it's important to make your content work quickly and efficiently. This lets it perform effectively for both powerful desktop systems and weaker handheld devices.

Mobile web development
Learn: Responsive design

This article provides an overview of some main techniques needed to design websites that work well on mobile devices.

Fonts
Variable fonts guide

Find out how to use variable fonts in your designs.

The Web Open Font Format (WOFF)

WOFF (Web Open Font Format) is a font file format that is free for anyone to use on the web.

User interface development
User input methods and controls

User input goes beyond just a mouse and keyboard: think of touchscreens for example. This article provides recommendations for managing user input and implementing controls in open web apps, along with FAQs, real-world examples, and links to further information for anyone needing more detailed information on the underlying technologies.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 25, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nWeb development tutorialsThe links on this page lead to a variety of tutorials and learning materials.
Whether you are a beginner, intermediate, or expert at web development, you will find something helpful here.
These tutorials are created by forward-thinking companies and web developers who have embraced open standards and good practices, and allow or provide translations through an open content license such as Creative Commons.For complete beginners
Getting started with the Web

Getting started with the Web is a concise series introducing you to the practicalities of web development.
You'll set up the tools you need to construct a basic webpage and publish your own code.

HTML tutorialsIntroduction to HTML
Structuring content with HTML

Our introductory HTML learning module teaches HTML from the ground up — no previous knowledge required.
It sets the stage, getting you used to important concepts and syntax, looking at applying HTML to text, how to create hyperlinks, and how to use HTML to structure a webpage.

HTML for Beginners

An HTML guide for beginners that includes explanations of common tags, including HTML tags.
Also includes a step-by-step guide to creating a basic web page with code examples.

HTML Challenges

Use these challenges to hone your HTML skills (for example, "Should I use an <h2> element or a <strong> element?"), focusing on meaningful markup.

Advanced HTML topics
Web forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, such as registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side parts of forms.

Tips for authoring fast-loading HTML pages

Optimize web pages to provide a more responsive site for visitors and reduce the load on your web server and Internet connection.

CSS tutorialsIntroduction to CSS
CSS basics

CSS (Cascading Style Sheets) is the code you use to style your webpage. CSS Basics takes you through what you need to get started. We'll answer questions like: How do I make my text black or red? How do I make my content show up in such-and-such a place on the screen? How do I decorate my webpage with background images and colors?

CSS Styling basics

CSS (Cascading Style Sheets) is used to style and lay out web pages — for example, to alter the font, color, size, and spacing of your content, split it into multiple columns, or add animations and other decorative features. This module provides a gentle beginning to your path toward CSS mastery with the basics of how it works, what the syntax looks like, and how you can start using it to add styling to HTML.

Selectors

Target HTML elements, including based on element state, with CSS.

Specificity

Understanding the browser algorithm to determine which CSS declarations get applied to an element when there are competing declarations, with a specificity quiz.

Handling conflicts

The cascade, specificity, and inheritance control how CSS is applied to HTML and how conflicts between style declarations are resolved.

CSS text Styling

Here we look at text styling fundamentals, including setting font, boldness, and italics, line and letter spacing, and drop shadows and other text features. We round off the module by looking at applying custom fonts to your page, and styling lists and links.

Solve common CSS problems

Common questions and answers for beginners.

Intermediate CSS topics
CSS layout

At this point we've already looked at CSS fundamentals, how to style text, and how to style and manipulate the boxes that your content sits inside. Now it's time to look at how to place your boxes in the right place in relation to the viewport, and one another. We have covered the necessary prerequisites so can now dive deep into CSS layout, looking at different display settings, traditional layout methods involving float and positioning, and new fangled layout tools like flexbox.

CSS reference

Complete reference to CSS, with details on support by Firefox and other browsers.

Fluid Grids

Design layouts that fluidly resize with the browser window, while still using a typographic grid.

CSS Challenges

Flex your CSS skills, and see where you need more practice.

Advanced CSS topics
Using CSS transforms

Apply rotation, skewing, scaling, and translation using CSS.

CSS transitions

CSS transitions provide a way to animate changes to CSS properties, instead of having the changes take effect instantly.

Canvas tutorial

Learn how to draw graphics using scripting using the canvas element.

JavaScript tutorialsIntroduction to JavaScript
Dynamic scripting with JavaScript

In this module, we continue our coverage of all JavaScript's key fundamental features, turning our attention to commonly-encountered types of code blocks such as conditional statements, loops, functions, and events. You've seen this stuff already in the course, but only in passing — here we'll discuss it all explicitly.

Getting started with JavaScript

What is JavaScript and how can it help you?

Codecademy

Codecademy is an easy way to learn how to code JavaScript. It's interactive and you can do it with your friends.

freeCodeCamp

freeCodeCamp teaches a variety of languages and frameworks for web development. It also has a forum, an internet radio station, and a blog.

Intermediate JavaScript topics
Introducing JavaScript objects

In JavaScript, most things are objects, from core JavaScript features like strings and arrays to the browser APIs built on top of JavaScript. You can even create your own objects to encapsulate related functions and variables into efficient packages. The object-oriented nature of JavaScript is important to understand if you want to go further with your knowledge of the language and write more efficient code, therefore we've provided this module to help you. Here we teach object theory and syntax in detail, look at how to create your own objects, and explain what JSON data is and how to work with it.

Client-side web APIs

When writing client-side JavaScript for websites or applications, you won't go very far before you start to use APIs — interfaces for manipulating different aspects of the browser and operating system the site is running on, or even data from other websites or services. In this module, we will explore what APIs are, and how to use some of the most common APIs you'll come across often in your development work.

Eloquent JavaScript

A comprehensive guide to intermediate and advanced JavaScript methodologies.

Speaking JavaScript

For programmers who want to learn JavaScript quickly and properly, and for JavaScript programmers who want to deepen their skills and/or look up specific topics.

Essential JavaScript Design Patterns

An introduction to essential JavaScript design patterns.

JavaScript.info - The Modern JavaScript Tutorial

Part 1: The Language. Part 2: Working with Browsers.

Advanced JavaScript topics
JavaScript Guide

A comprehensive, regularly updated guide to JavaScript for all levels of learning from beginner to advanced.

You Don't Know JS

A series of books diving deep into the core mechanisms of the JavaScript language.

JavaScript Garden

Documentation of the most quirky parts of JavaScript.

Exploring ES6

Reliable and in-depth information on ECMAScript 2015.

JavaScript Patterns

A JavaScript pattern and anti-pattern collection that covers function patterns, jQuery patterns, jQuery plugin patterns, design patterns, general patterns, literals and constructor patterns, object creation patterns, code reuse patterns, DOM.

How browsers work

A detailed research article describing different modern browsers, their engines, page rendering etc.

JavaScript Videos

A collection of JavaScript videos to watch.

Extension Development
WebExtensions

WebExtensions is a cross-browser system for developing browser add-ons. To a large extent, the system is compatible with the extension API supported by Google Chrome and Opera. Extensions written for these browsers will in most cases run in Firefox or Microsoft Edge with just a few changes. The API is also fully compatible with multiprocess Firefox.\n\nWeb development tutorialsThe links on this page lead to a variety of tutorials and learning materials.
Whether you are a beginner, intermediate, or expert at web development, you will find something helpful here.
These tutorials are created by forward-thinking companies and web developers who have embraced open standards and good practices, and allow or provide translations through an open content license such as Creative Commons.For complete beginners
Getting started with the Web

Getting started with the Web is a concise series introducing you to the practicalities of web development.
You'll set up the tools you need to construct a basic webpage and publish your own code.

HTML tutorialsIntroduction to HTML
Structuring content with HTML

Our introductory HTML learning module teaches HTML from the ground up — no previous knowledge required.
It sets the stage, getting you used to important concepts and syntax, looking at applying HTML to text, how to create hyperlinks, and how to use HTML to structure a webpage.

HTML for Beginners

An HTML guide for beginners that includes explanations of common tags, including HTML tags.
Also includes a step-by-step guide to creating a basic web page with code examples.

HTML Challenges

Use these challenges to hone your HTML skills (for example, "Should I use an <h2> element or a <strong> element?"), focusing on meaningful markup.

Advanced HTML topics
Web forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, such as registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side parts of forms.

Tips for authoring fast-loading HTML pages

Optimize web pages to provide a more responsive site for visitors and reduce the load on your web server and Internet connection.

CSS tutorialsIntroduction to CSS
CSS basics

CSS (Cascading Style Sheets) is the code you use to style your webpage. CSS Basics takes you through what you need to get started. We'll answer questions like: How do I make my text black or red? How do I make my content show up in such-and-such a place on the screen? How do I decorate my webpage with background images and colors?

CSS Styling basics

CSS (Cascading Style Sheets) is used to style and lay out web pages — for example, to alter the font, color, size, and spacing of your content, split it into multiple columns, or add animations and other decorative features. This module provides a gentle beginning to your path toward CSS mastery with the basics of how it works, what the syntax looks like, and how you can start using it to add styling to HTML.

Selectors

Target HTML elements, including based on element state, with CSS.

Specificity

Understanding the browser algorithm to determine which CSS declarations get applied to an element when there are competing declarations, with a specificity quiz.

Handling conflicts

The cascade, specificity, and inheritance control how CSS is applied to HTML and how conflicts between style declarations are resolved.

CSS text Styling

Here we look at text styling fundamentals, including setting font, boldness, and italics, line and letter spacing, and drop shadows and other text features. We round off the module by looking at applying custom fonts to your page, and styling lists and links.

Solve common CSS problems

Common questions and answers for beginners.

Intermediate CSS topics
CSS layout

At this point we've already looked at CSS fundamentals, how to style text, and how to style and manipulate the boxes that your content sits inside. Now it's time to look at how to place your boxes in the right place in relation to the viewport, and one another. We have covered the necessary prerequisites so can now dive deep into CSS layout, looking at different display settings, traditional layout methods involving float and positioning, and new fangled layout tools like flexbox.

CSS reference

Complete reference to CSS, with details on support by Firefox and other browsers.

Fluid Grids

Design layouts that fluidly resize with the browser window, while still using a typographic grid.

CSS Challenges

Flex your CSS skills, and see where you need more practice.

Advanced CSS topics
Using CSS transforms

Apply rotation, skewing, scaling, and translation using CSS.

CSS transitions

CSS transitions provide a way to animate changes to CSS properties, instead of having the changes take effect instantly.

Canvas tutorial

Learn how to draw graphics using scripting using the canvas element.

JavaScript tutorialsIntroduction to JavaScript
Dynamic scripting with JavaScript

In this module, we continue our coverage of all JavaScript's key fundamental features, turning our attention to commonly-encountered types of code blocks such as conditional statements, loops, functions, and events. You've seen this stuff already in the course, but only in passing — here we'll discuss it all explicitly.

Getting started with JavaScript

What is JavaScript and how can it help you?

Codecademy

Codecademy is an easy way to learn how to code JavaScript. It's interactive and you can do it with your friends.

freeCodeCamp

freeCodeCamp teaches a variety of languages and frameworks for web development. It also has a forum, an internet radio station, and a blog.

Intermediate JavaScript topics
Introducing JavaScript objects

In JavaScript, most things are objects, from core JavaScript features like strings and arrays to the browser APIs built on top of JavaScript. You can even create your own objects to encapsulate related functions and variables into efficient packages. The object-oriented nature of JavaScript is important to understand if you want to go further with your knowledge of the language and write more efficient code, therefore we've provided this module to help you. Here we teach object theory and syntax in detail, look at how to create your own objects, and explain what JSON data is and how to work with it.

Client-side web APIs

When writing client-side JavaScript for websites or applications, you won't go very far before you start to use APIs — interfaces for manipulating different aspects of the browser and operating system the site is running on, or even data from other websites or services. In this module, we will explore what APIs are, and how to use some of the most common APIs you'll come across often in your development work.

Eloquent JavaScript

A comprehensive guide to intermediate and advanced JavaScript methodologies.

Speaking JavaScript

For programmers who want to learn JavaScript quickly and properly, and for JavaScript programmers who want to deepen their skills and/or look up specific topics.

Essential JavaScript Design Patterns

An introduction to essential JavaScript design patterns.

JavaScript.info - The Modern JavaScript Tutorial

Part 1: The Language. Part 2: Working with Browsers.

Advanced JavaScript topics
JavaScript Guide

A comprehensive, regularly updated guide to JavaScript for all levels of learning from beginner to advanced.

You Don't Know JS

A series of books diving deep into the core mechanisms of the JavaScript language.

JavaScript Garden

Documentation of the most quirky parts of JavaScript.

Exploring ES6

Reliable and in-depth information on ECMAScript 2015.

JavaScript Patterns

A JavaScript pattern and anti-pattern collection that covers function patterns, jQuery patterns, jQuery plugin patterns, design patterns, general patterns, literals and constructor patterns, object creation patterns, code reuse patterns, DOM.

How browsers work

A detailed research article describing different modern browsers, their engines, page rendering etc.

JavaScript Videos

A collection of JavaScript videos to watch.

Extension Development
WebExtensions

WebExtensions is a cross-browser system for developing browser add-ons. To a large extent, the system is compatible with the extension API supported by Google Chrome and Opera. Extensions written for these browsers will in most cases run in Firefox or Microsoft Edge with just a few changes. The API is also fully compatible with multiprocess Firefox.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 30, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWeb development tutorialsThe links on this page lead to a variety of tutorials and learning materials.
Whether you are a beginner, intermediate, or expert at web development, you will find something helpful here.
These tutorials are created by forward-thinking companies and web developers who have embraced open standards and good practices, and allow or provide translations through an open content license such as Creative Commons.For complete beginners
Getting started with the Web

Getting started with the Web is a concise series introducing you to the practicalities of web development.
You'll set up the tools you need to construct a basic webpage and publish your own code.

HTML tutorialsIntroduction to HTML
Structuring content with HTML

Our introductory HTML learning module teaches HTML from the ground up — no previous knowledge required.
It sets the stage, getting you used to important concepts and syntax, looking at applying HTML to text, how to create hyperlinks, and how to use HTML to structure a webpage.

HTML for Beginners

An HTML guide for beginners that includes explanations of common tags, including HTML tags.
Also includes a step-by-step guide to creating a basic web page with code examples.

HTML Challenges

Use these challenges to hone your HTML skills (for example, "Should I use an <h2> element or a <strong> element?"), focusing on meaningful markup.

Advanced HTML topics
Web forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, such as registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side parts of forms.

Tips for authoring fast-loading HTML pages

Optimize web pages to provide a more responsive site for visitors and reduce the load on your web server and Internet connection.

CSS tutorialsIntroduction to CSS
CSS basics

CSS (Cascading Style Sheets) is the code you use to style your webpage. CSS Basics takes you through what you need to get started. We'll answer questions like: How do I make my text black or red? How do I make my content show up in such-and-such a place on the screen? How do I decorate my webpage with background images and colors?

CSS Styling basics

CSS (Cascading Style Sheets) is used to style and lay out web pages — for example, to alter the font, color, size, and spacing of your content, split it into multiple columns, or add animations and other decorative features. This module provides a gentle beginning to your path toward CSS mastery with the basics of how it works, what the syntax looks like, and how you can start using it to add styling to HTML.

Selectors

Target HTML elements, including based on element state, with CSS.

Specificity

Understanding the browser algorithm to determine which CSS declarations get applied to an element when there are competing declarations, with a specificity quiz.

Handling conflicts

The cascade, specificity, and inheritance control how CSS is applied to HTML and how conflicts between style declarations are resolved.

CSS text Styling

Here we look at text styling fundamentals, including setting font, boldness, and italics, line and letter spacing, and drop shadows and other text features. We round off the module by looking at applying custom fonts to your page, and styling lists and links.

Solve common CSS problems

Common questions and answers for beginners.

Intermediate CSS topics
CSS layout

At this point we've already looked at CSS fundamentals, how to style text, and how to style and manipulate the boxes that your content sits inside. Now it's time to look at how to place your boxes in the right place in relation to the viewport, and one another. We have covered the necessary prerequisites so can now dive deep into CSS layout, looking at different display settings, traditional layout methods involving float and positioning, and new fangled layout tools like flexbox.

CSS reference

Complete reference to CSS, with details on support by Firefox and other browsers.

Fluid Grids

Design layouts that fluidly resize with the browser window, while still using a typographic grid.

CSS Challenges

Flex your CSS skills, and see where you need more practice.

Advanced CSS topics
Using CSS transforms

Apply rotation, skewing, scaling, and translation using CSS.

CSS transitions

CSS transitions provide a way to animate changes to CSS properties, instead of having the changes take effect instantly.

Canvas tutorial

Learn how to draw graphics using scripting using the canvas element.

JavaScript tutorialsIntroduction to JavaScript
Dynamic scripting with JavaScript

In this module, we continue our coverage of all JavaScript's key fundamental features, turning our attention to commonly-encountered types of code blocks such as conditional statements, loops, functions, and events. You've seen this stuff already in the course, but only in passing — here we'll discuss it all explicitly.

Getting started with JavaScript

What is JavaScript and how can it help you?

Codecademy

Codecademy is an easy way to learn how to code JavaScript. It's interactive and you can do it with your friends.

freeCodeCamp

freeCodeCamp teaches a variety of languages and frameworks for web development. It also has a forum, an internet radio station, and a blog.

Intermediate JavaScript topics
Introducing JavaScript objects

In JavaScript, most things are objects, from core JavaScript features like strings and arrays to the browser APIs built on top of JavaScript. You can even create your own objects to encapsulate related functions and variables into efficient packages. The object-oriented nature of JavaScript is important to understand if you want to go further with your knowledge of the language and write more efficient code, therefore we've provided this module to help you. Here we teach object theory and syntax in detail, look at how to create your own objects, and explain what JSON data is and how to work with it.

Client-side web APIs

When writing client-side JavaScript for websites or applications, you won't go very far before you start to use APIs — interfaces for manipulating different aspects of the browser and operating system the site is running on, or even data from other websites or services. In this module, we will explore what APIs are, and how to use some of the most common APIs you'll come across often in your development work.

Eloquent JavaScript

A comprehensive guide to intermediate and advanced JavaScript methodologies.

Speaking JavaScript

For programmers who want to learn JavaScript quickly and properly, and for JavaScript programmers who want to deepen their skills and/or look up specific topics.

Essential JavaScript Design Patterns

An introduction to essential JavaScript design patterns.

JavaScript.info - The Modern JavaScript Tutorial

Part 1: The Language. Part 2: Working with Browsers.

Advanced JavaScript topics
JavaScript Guide

A comprehensive, regularly updated guide to JavaScript for all levels of learning from beginner to advanced.

You Don't Know JS

A series of books diving deep into the core mechanisms of the JavaScript language.

JavaScript Garden

Documentation of the most quirky parts of JavaScript.

Exploring ES6

Reliable and in-depth information on ECMAScript 2015.

JavaScript Patterns

A JavaScript pattern and anti-pattern collection that covers function patterns, jQuery patterns, jQuery plugin patterns, design patterns, general patterns, literals and constructor patterns, object creation patterns, code reuse patterns, DOM.

How browsers work

A detailed research article describing different modern browsers, their engines, page rendering etc.

JavaScript Videos

A collection of JavaScript videos to watch.

Extension Development
WebExtensions

WebExtensions is a cross-browser system for developing browser add-ons. To a large extent, the system is compatible with the extension API supported by Google Chrome and Opera. Extensions written for these browsers will in most cases run in Firefox or Microsoft Edge with just a few changes. The API is also fully compatible with multiprocess Firefox.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 30, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nMDN Web Docs Glossary: Definitions of Web-related termsWeb technologies contain long lists of jargon and abbreviations that are used in documentation and coding. This glossary provides definitions of words and abbreviations you need to know to successfully understand and build for the web.
Glossary terms can be selected from the sidebar.

Note:
This glossary is a never-ending work in progress. You can help improve it by writing new entries or by making the existing ones better.\n\nMDN Web Docs Glossary: Definitions of Web-related termsWeb technologies contain long lists of jargon and abbreviations that are used in documentation and coding. This glossary provides definitions of words and abbreviations you need to know to successfully understand and build for the web.
Glossary terms can be selected from the sidebar.

Note:
This glossary is a never-ending work in progress. You can help improve it by writing new entries or by making the existing ones better.
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jul 25, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nMDN Web Docs Glossary: Definitions of Web-related termsWeb technologies contain long lists of jargon and abbreviations that are used in documentation and coding. This glossary provides definitions of words and abbreviations you need to know to successfully understand and build for the web.
Glossary terms can be selected from the sidebar.

Note:
This glossary is a never-ending work in progress. You can help improve it by writing new entries or by making the existing ones better.
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jul 25, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nWebAssemblyWebAssembly is a type of code that can be run in modern web browsers — it is a low-level assembly-like language with a compact binary format that runs with near-native performance and provides languages such as C/C++, C# and Rust with a compilation target so that they can run on the web. It is also designed to run alongside JavaScript, allowing both to work together.In a NutshellWebAssembly has huge implications for the web platform — it provides a way to run code written in multiple languages on the web at near-native speed, with client apps running on the web that previously couldn't have done so.
WebAssembly is designed to complement and run alongside JavaScript — using the WebAssembly JavaScript APIs, you can load WebAssembly modules into a JavaScript app and share functionality between the two. This allows you to take advantage of WebAssembly's performance and power and JavaScript's expressiveness and flexibility in the same app, even if you don't know how to write WebAssembly code.
And what's even better is that it is being developed as a web standard via the W3C WebAssembly Working Group and Community Group with active participation from all major browser vendors.Guides
WebAssembly concepts

Get started by reading the high-level concepts behind WebAssembly — what it is, why it is so useful, how it fits into the web platform (and beyond), and how to use it.

Compiling a New C/C++ Module to WebAssembly

When you've written code in C/C++, you can then compile it into Wasm using a tool like Emscripten. Let's look at how it works.

Compiling an Existing C Module to WebAssembly

A core use-case for WebAssembly is to take the existing ecosystem of C libraries and allow developers to use them on the web.

Compiling from Rust to WebAssembly

If you've written some Rust code, you can compile it into WebAssembly! This tutorial takes you through all you need to know to compile a Rust project to Wasm and use it in an existing web app.

Loading and running WebAssembly code

After you have a Wasm module, this article covers how to fetch, compile and instantiate it, combining the WebAssembly JavaScript API with the Fetch or XHR APIs.

Using the WebAssembly JavaScript API

Once you've loaded a Wasm module, you'll want to use it. In this article, we show you how to use WebAssembly via the WebAssembly JavaScript API.

Exported WebAssembly functions

Exported WebAssembly functions are the JavaScript reflections of WebAssembly functions, which allow calling WebAssembly code from JavaScript. This article describes what they are.

Understanding WebAssembly text format

This article explains the Wasm text format. This is the low-level textual representation of a Wasm module shown in browser developer tools when debugging.

Converting WebAssembly text format to Wasm

This article provides a guide on how to convert a WebAssembly module written in text format into a Wasm binary.

API reference
WebAssembly instruction reference

Reference documentation with interactive samples for the set of WebAssembly operators.

WebAssembly JavaScript interface

This object acts as the namespace for all WebAssembly-related functionality.

WebAssembly.Global()

A WebAssembly.Global object represents a global variable instance, accessible from both JavaScript and importable/exportable across one or more WebAssembly.Module instances. This allows dynamic linking of multiple modules.

WebAssembly.Module()

A WebAssembly.Module object contains stateless WebAssembly code that has already been compiled by the browser and can be efficiently shared with Workers, and instantiated multiple times.

WebAssembly.Instance()

A WebAssembly.Instance object is a stateful, executable instance of a Module. Instance objects contain all the Exported WebAssembly functions that allow calling into WebAssembly code from JavaScript.

WebAssembly.compile()

The WebAssembly.compile() function compiles WebAssembly binary code into a WebAssembly.Module object.

WebAssembly.compileStreaming()

The WebAssembly.compileStreaming() function compiles a WebAssembly.Module directly from a streamed underlying source.

WebAssembly.instantiate()

The WebAssembly.instantiate() function allows you to compile and instantiate WebAssembly code.

WebAssembly.instantiateStreaming()

The WebAssembly.instantiateStreaming() function is the primary API for compiling and instantiating WebAssembly code, returning both a Module and its first Instance.

WebAssembly.validate()

The WebAssembly.validate() function validates a given typed array of WebAssembly binary code.

WebAssembly.Memory()

A WebAssembly.Memory object is a resizable ArrayBuffer that holds the raw bytes of memory accessed by an Instance.

WebAssembly.Table()

A WebAssembly.Table object is a resizable typed array of opaque values, like function references, that are accessed by an Instance.

WebAssembly.Tag()

The WebAssembly.Tag object defines a type of WebAssembly exception that can be thrown to/from WebAssembly code.

WebAssembly.Exception()

The WebAssembly.Exception object represents a runtime exception thrown from WebAssembly to JavaScript, or thrown from JavaScript to a WebAssembly exception handler.

WebAssembly.CompileError()

Creates a new WebAssembly CompileError object.

WebAssembly.LinkError()

Creates a new WebAssembly LinkError object.

WebAssembly.RuntimeError()

Creates a new WebAssembly RuntimeError object.

Examples
WASMSobel
See our webassembly-examples repo for a number of other examples.
SpecificationsSpecificationWebAssembly JavaScript Interface # webassembly-namespaceWebAssembly JavaScript Interface # ref-for-syntax-numtype①⓪Unknown specification Unknown specification Unknown specification Unknown specification WebAssembly Core: Garbage Collection # garbage-collection①Unknown specification Unknown specification WebAssembly JavaScript Interface # dom-globaldescriptor-mutableUnknown specification Unknown specification Unknown specification Unknown specification Unknown specification Browser compatibilitySee also
WebAssembly on Mozilla Research
webassembly.org
WebAssembly articles on Mozilla Hacks blog
W3C WebAssembly Community Group
Emscripting a C Library to Wasm\n\nWebAssemblyWebAssembly is a type of code that can be run in modern web browsers — it is a low-level assembly-like language with a compact binary format that runs with near-native performance and provides languages such as C/C++, C# and Rust with a compilation target so that they can run on the web. It is also designed to run alongside JavaScript, allowing both to work together.In a NutshellWebAssembly has huge implications for the web platform — it provides a way to run code written in multiple languages on the web at near-native speed, with client apps running on the web that previously couldn't have done so.
WebAssembly is designed to complement and run alongside JavaScript — using the WebAssembly JavaScript APIs, you can load WebAssembly modules into a JavaScript app and share functionality between the two. This allows you to take advantage of WebAssembly's performance and power and JavaScript's expressiveness and flexibility in the same app, even if you don't know how to write WebAssembly code.
And what's even better is that it is being developed as a web standard via the W3C WebAssembly Working Group and Community Group with active participation from all major browser vendors.Guides
WebAssembly concepts

Get started by reading the high-level concepts behind WebAssembly — what it is, why it is so useful, how it fits into the web platform (and beyond), and how to use it.

Compiling a New C/C++ Module to WebAssembly

When you've written code in C/C++, you can then compile it into Wasm using a tool like Emscripten. Let's look at how it works.

Compiling an Existing C Module to WebAssembly

A core use-case for WebAssembly is to take the existing ecosystem of C libraries and allow developers to use them on the web.

Compiling from Rust to WebAssembly

If you've written some Rust code, you can compile it into WebAssembly! This tutorial takes you through all you need to know to compile a Rust project to Wasm and use it in an existing web app.

Loading and running WebAssembly code

After you have a Wasm module, this article covers how to fetch, compile and instantiate it, combining the WebAssembly JavaScript API with the Fetch or XHR APIs.

Using the WebAssembly JavaScript API

Once you've loaded a Wasm module, you'll want to use it. In this article, we show you how to use WebAssembly via the WebAssembly JavaScript API.

Exported WebAssembly functions

Exported WebAssembly functions are the JavaScript reflections of WebAssembly functions, which allow calling WebAssembly code from JavaScript. This article describes what they are.

Understanding WebAssembly text format

This article explains the Wasm text format. This is the low-level textual representation of a Wasm module shown in browser developer tools when debugging.

Converting WebAssembly text format to Wasm

This article provides a guide on how to convert a WebAssembly module written in text format into a Wasm binary.

API reference
WebAssembly instruction reference

Reference documentation with interactive samples for the set of WebAssembly operators.

WebAssembly JavaScript interface

This object acts as the namespace for all WebAssembly-related functionality.

WebAssembly.Global()

A WebAssembly.Global object represents a global variable instance, accessible from both JavaScript and importable/exportable across one or more WebAssembly.Module instances. This allows dynamic linking of multiple modules.

WebAssembly.Module()

A WebAssembly.Module object contains stateless WebAssembly code that has already been compiled by the browser and can be efficiently shared with Workers, and instantiated multiple times.

WebAssembly.Instance()

A WebAssembly.Instance object is a stateful, executable instance of a Module. Instance objects contain all the Exported WebAssembly functions that allow calling into WebAssembly code from JavaScript.

WebAssembly.compile()

The WebAssembly.compile() function compiles WebAssembly binary code into a WebAssembly.Module object.

WebAssembly.compileStreaming()

The WebAssembly.compileStreaming() function compiles a WebAssembly.Module directly from a streamed underlying source.

WebAssembly.instantiate()

The WebAssembly.instantiate() function allows you to compile and instantiate WebAssembly code.

WebAssembly.instantiateStreaming()

The WebAssembly.instantiateStreaming() function is the primary API for compiling and instantiating WebAssembly code, returning both a Module and its first Instance.

WebAssembly.validate()

The WebAssembly.validate() function validates a given typed array of WebAssembly binary code.

WebAssembly.Memory()

A WebAssembly.Memory object is a resizable ArrayBuffer that holds the raw bytes of memory accessed by an Instance.

WebAssembly.Table()

A WebAssembly.Table object is a resizable typed array of opaque values, like function references, that are accessed by an Instance.

WebAssembly.Tag()

The WebAssembly.Tag object defines a type of WebAssembly exception that can be thrown to/from WebAssembly code.

WebAssembly.Exception()

The WebAssembly.Exception object represents a runtime exception thrown from WebAssembly to JavaScript, or thrown from JavaScript to a WebAssembly exception handler.

WebAssembly.CompileError()

Creates a new WebAssembly CompileError object.

WebAssembly.LinkError()

Creates a new WebAssembly LinkError object.

WebAssembly.RuntimeError()

Creates a new WebAssembly RuntimeError object.

Examples
WASMSobel
See our webassembly-examples repo for a number of other examples.
SpecificationsSpecificationWebAssembly JavaScript Interface # webassembly-namespaceWebAssembly JavaScript Interface # ref-for-syntax-numtype①⓪Unknown specification Unknown specification Unknown specification Unknown specification WebAssembly Core: Garbage Collection # garbage-collection①Unknown specification Unknown specification WebAssembly JavaScript Interface # dom-globaldescriptor-mutableUnknown specification Unknown specification Unknown specification Unknown specification Unknown specification Browser compatibilitySee also
WebAssembly on Mozilla Research
webassembly.org
WebAssembly articles on Mozilla Hacks blog
W3C WebAssembly Community Group
Emscripting a C Library to Wasm
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jan 31, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWebAssemblyWebAssembly is a type of code that can be run in modern web browsers — it is a low-level assembly-like language with a compact binary format that runs with near-native performance and provides languages such as C/C++, C# and Rust with a compilation target so that they can run on the web. It is also designed to run alongside JavaScript, allowing both to work together.In a NutshellWebAssembly has huge implications for the web platform — it provides a way to run code written in multiple languages on the web at near-native speed, with client apps running on the web that previously couldn't have done so.
WebAssembly is designed to complement and run alongside JavaScript — using the WebAssembly JavaScript APIs, you can load WebAssembly modules into a JavaScript app and share functionality between the two. This allows you to take advantage of WebAssembly's performance and power and JavaScript's expressiveness and flexibility in the same app, even if you don't know how to write WebAssembly code.
And what's even better is that it is being developed as a web standard via the W3C WebAssembly Working Group and Community Group with active participation from all major browser vendors.Guides
WebAssembly concepts

Get started by reading the high-level concepts behind WebAssembly — what it is, why it is so useful, how it fits into the web platform (and beyond), and how to use it.

Compiling a New C/C++ Module to WebAssembly

When you've written code in C/C++, you can then compile it into Wasm using a tool like Emscripten. Let's look at how it works.

Compiling an Existing C Module to WebAssembly

A core use-case for WebAssembly is to take the existing ecosystem of C libraries and allow developers to use them on the web.

Compiling from Rust to WebAssembly

If you've written some Rust code, you can compile it into WebAssembly! This tutorial takes you through all you need to know to compile a Rust project to Wasm and use it in an existing web app.

Loading and running WebAssembly code

After you have a Wasm module, this article covers how to fetch, compile and instantiate it, combining the WebAssembly JavaScript API with the Fetch or XHR APIs.

Using the WebAssembly JavaScript API

Once you've loaded a Wasm module, you'll want to use it. In this article, we show you how to use WebAssembly via the WebAssembly JavaScript API.

Exported WebAssembly functions

Exported WebAssembly functions are the JavaScript reflections of WebAssembly functions, which allow calling WebAssembly code from JavaScript. This article describes what they are.

Understanding WebAssembly text format

This article explains the Wasm text format. This is the low-level textual representation of a Wasm module shown in browser developer tools when debugging.

Converting WebAssembly text format to Wasm

This article provides a guide on how to convert a WebAssembly module written in text format into a Wasm binary.

API reference
WebAssembly instruction reference

Reference documentation with interactive samples for the set of WebAssembly operators.

WebAssembly JavaScript interface

This object acts as the namespace for all WebAssembly-related functionality.

WebAssembly.Global()

A WebAssembly.Global object represents a global variable instance, accessible from both JavaScript and importable/exportable across one or more WebAssembly.Module instances. This allows dynamic linking of multiple modules.

WebAssembly.Module()

A WebAssembly.Module object contains stateless WebAssembly code that has already been compiled by the browser and can be efficiently shared with Workers, and instantiated multiple times.

WebAssembly.Instance()

A WebAssembly.Instance object is a stateful, executable instance of a Module. Instance objects contain all the Exported WebAssembly functions that allow calling into WebAssembly code from JavaScript.

WebAssembly.compile()

The WebAssembly.compile() function compiles WebAssembly binary code into a WebAssembly.Module object.

WebAssembly.compileStreaming()

The WebAssembly.compileStreaming() function compiles a WebAssembly.Module directly from a streamed underlying source.

WebAssembly.instantiate()

The WebAssembly.instantiate() function allows you to compile and instantiate WebAssembly code.

WebAssembly.instantiateStreaming()

The WebAssembly.instantiateStreaming() function is the primary API for compiling and instantiating WebAssembly code, returning both a Module and its first Instance.

WebAssembly.validate()

The WebAssembly.validate() function validates a given typed array of WebAssembly binary code.

WebAssembly.Memory()

A WebAssembly.Memory object is a resizable ArrayBuffer that holds the raw bytes of memory accessed by an Instance.

WebAssembly.Table()

A WebAssembly.Table object is a resizable typed array of opaque values, like function references, that are accessed by an Instance.

WebAssembly.Tag()

The WebAssembly.Tag object defines a type of WebAssembly exception that can be thrown to/from WebAssembly code.

WebAssembly.Exception()

The WebAssembly.Exception object represents a runtime exception thrown from WebAssembly to JavaScript, or thrown from JavaScript to a WebAssembly exception handler.

WebAssembly.CompileError()

Creates a new WebAssembly CompileError object.

WebAssembly.LinkError()

Creates a new WebAssembly LinkError object.

WebAssembly.RuntimeError()

Creates a new WebAssembly RuntimeError object.

Examples
WASMSobel
See our webassembly-examples repo for a number of other examples.
SpecificationsSpecificationWebAssembly JavaScript Interface # webassembly-namespaceWebAssembly JavaScript Interface # ref-for-syntax-numtype①⓪Unknown specification Unknown specification Unknown specification Unknown specification WebAssembly Core: Garbage Collection # garbage-collection①Unknown specification Unknown specification WebAssembly JavaScript Interface # dom-globaldescriptor-mutableUnknown specification Unknown specification Unknown specification Unknown specification Unknown specification Browser compatibilitySee also
WebAssembly on Mozilla Research
webassembly.org
WebAssembly articles on Mozilla Hacks blog
W3C WebAssembly Community Group
Emscripting a C Library to Wasm
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jan 31, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nWeb app manifestsA web application manifest, defined in the Web Application Manifest specification, is a JSON text file that provides information about a web application.
The most common use for a web application manifest is to provide information that the browser needs to install a progressive web app (PWA) on a device, such as the app's name and icon.
A web application manifest contains a single JSON object where the top-level keys are called members.MembersThis section lists the members that may appear in the manifest.
All members are optional in the specification, but some applications require some members to be present. For example, PWAs must provide certain manifest members.
background_colorcategoriesdescriptiondisplaydisplay_override
Experimental
file_handlers
Experimental
iconsidlaunch_handler
Experimental
namenote_taking
Experimental
orientationprefer_related_applications
Experimental
protocol_handlers
Experimental
related_applications
Experimental
scopescreenshotsserviceworker
Experimental

Non-standard
share_target
Experimental
short_nameshortcutsstart_urltheme_color

Note:
The dir, lang, and iarc_rating_id members are not implemented.
Example manifestjson{
  "short_name": "MDN",
  "name": "MDN Web Docs",
  "icons": [
    {
      "src": "/favicon-192x192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "/favicon-512x512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}
Deploying a manifestWeb app manifests are deployed in your HTML pages using a <link> element in the <head> of a document:
html<link rel="manifest" href="manifest.json" />

The .webmanifest extension is specified in the Media type registration section of the specification (the response of the manifest file should return Content-Type: application/manifest+json). Browsers generally support manifests with other appropriate extensions like .json (Content-Type: application/json).
If the manifest requires credentials to fetch, the crossorigin attribute must be set to use-credentials, even if the manifest file is in the same origin as the current page.
html<link rel="manifest" href="/app.webmanifest" crossorigin="use-credentials" />
Splash screensIn some browsers and operating systems, a splash screen is displayed when an installed PWA is launched. This splash screen is automatically generated and its appearance is defined by members in the web app manifest, specifically:

name
background_color
icons
Browser compatibilitySee also
Progressive Web Apps (PWAs)\n\nWeb app manifestsA web application manifest, defined in the Web Application Manifest specification, is a JSON text file that provides information about a web application.
The most common use for a web application manifest is to provide information that the browser needs to install a progressive web app (PWA) on a device, such as the app's name and icon.
A web application manifest contains a single JSON object where the top-level keys are called members.MembersThis section lists the members that may appear in the manifest.
All members are optional in the specification, but some applications require some members to be present. For example, PWAs must provide certain manifest members.
background_colorcategoriesdescriptiondisplaydisplay_override
Experimental
file_handlers
Experimental
iconsidlaunch_handler
Experimental
namenote_taking
Experimental
orientationprefer_related_applications
Experimental
protocol_handlers
Experimental
related_applications
Experimental
scopescreenshotsserviceworker
Experimental

Non-standard
share_target
Experimental
short_nameshortcutsstart_urltheme_color

Note:
The dir, lang, and iarc_rating_id members are not implemented.
Example manifestjson{
  "short_name": "MDN",
  "name": "MDN Web Docs",
  "icons": [
    {
      "src": "/favicon-192x192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "/favicon-512x512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}
Deploying a manifestWeb app manifests are deployed in your HTML pages using a <link> element in the <head> of a document:
html<link rel="manifest" href="manifest.json" />

The .webmanifest extension is specified in the Media type registration section of the specification (the response of the manifest file should return Content-Type: application/manifest+json). Browsers generally support manifests with other appropriate extensions like .json (Content-Type: application/json).
If the manifest requires credentials to fetch, the crossorigin attribute must be set to use-credentials, even if the manifest file is in the same origin as the current page.
html<link rel="manifest" href="/app.webmanifest" crossorigin="use-credentials" />
Splash screensIn some browsers and operating systems, a splash screen is displayed when an installed PWA is launched. This splash screen is automatically generated and its appearance is defined by members in the web app manifest, specifically:

name
background_color
icons
Browser compatibilitySee also
Progressive Web Apps (PWAs)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWeb app manifestsA web application manifest, defined in the Web Application Manifest specification, is a JSON text file that provides information about a web application.
The most common use for a web application manifest is to provide information that the browser needs to install a progressive web app (PWA) on a device, such as the app's name and icon.
A web application manifest contains a single JSON object where the top-level keys are called members.MembersThis section lists the members that may appear in the manifest.
All members are optional in the specification, but some applications require some members to be present. For example, PWAs must provide certain manifest members.
background_colorcategoriesdescriptiondisplaydisplay_override
Experimental
file_handlers
Experimental
iconsidlaunch_handler
Experimental
namenote_taking
Experimental
orientationprefer_related_applications
Experimental
protocol_handlers
Experimental
related_applications
Experimental
scopescreenshotsserviceworker
Experimental

Non-standard
share_target
Experimental
short_nameshortcutsstart_urltheme_color

Note:
The dir, lang, and iarc_rating_id members are not implemented.
Example manifestjson{
  "short_name": "MDN",
  "name": "MDN Web Docs",
  "icons": [
    {
      "src": "/favicon-192x192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "/favicon-512x512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}
Deploying a manifestWeb app manifests are deployed in your HTML pages using a <link> element in the <head> of a document:
html<link rel="manifest" href="manifest.json" />

The .webmanifest extension is specified in the Media type registration section of the specification (the response of the manifest file should return Content-Type: application/manifest+json). Browsers generally support manifests with other appropriate extensions like .json (Content-Type: application/json).
If the manifest requires credentials to fetch, the crossorigin attribute must be set to use-credentials, even if the manifest file is in the same origin as the current page.
html<link rel="manifest" href="/app.webmanifest" crossorigin="use-credentials" />
Splash screensIn some browsers and operating systems, a splash screen is displayed when an installed PWA is launched. This splash screen is automatically generated and its appearance is defined by members in the web app manifest, specifically:

name
background_color
icons
Browser compatibilitySee also
Progressive Web Apps (PWAs)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nOpenSearch description formatThe OpenSearch description format can be used to describe the web interface of a search engine. This allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine. OpenSearch is supported by (at least) Firefox, Edge, Safari, and Chrome. (See Reference Material for links to other browsers' documentation.)
Firefox also supports additional features not in the OpenSearch standard, such as search suggestions. This article focuses on creating OpenSearch-compatible search engines that support these additional Firefox features.OverviewThe address bar in browsers has a dual purpose: you can type a URL to directly go to a site, or you can type a search term to query a search engine. The search engine returns a list of results that you can browse directly, or you can open the search engine's full results page.
By default, browsers can connect to a few popular search engines, such as Google, Bing, or Yandex. The OpenSearch protocol allows websites to define their own search engines, enabling users to search those websites directly from the browser's address bar. For example, the MDN website has a site-wide search engine. If MDN registers itself as a search engine, users can search MDN directly from the address bar.
Browsers query a search engine by requesting a URL. The site defines a template for the URL to be requested, and the browser fills in the user's search terms in the specified placeholders. For example, if the search engine URL is https://example.com/search?q={searchTerms}, then the browser will request https://example.com/search?q=foo when the user types "foo" into the address bar. The search engine then generates a response—either a list of search results or a full search results page.
A site defines its search engine by linking to an XML description file in its HTML. When the user first visits the site, the browser detects this description file and registers the search engine. The browser then uses the registered search engine to handle searches from the address bar.

Note:
Chrome registers site search engines as "inactive" by default. Users must manually activate each site in the search engine settings.
OpenSearch description fileThe XML file that describes a search engine follows the basic template below. Sections in [square brackets] should be customized for your specific engine.
xml<OpenSearchDescription
  xmlns="http://a9.com/-/spec/opensearch/1.1/"
  xmlns:moz="http://www.mozilla.org/2006/browser/search/">
  <ShortName>[SNK]</ShortName>
  <Description>[Search engine full name and summary]</Description>
  <InputEncoding>[UTF-8]</InputEncoding>
  <Image width="16" height="16" type="image/x-icon">[https://example.com/favicon.ico]</Image>
  <Url type="text/html" template="[searchURL]"/>
  <Url type="application/x-suggestions+json" template="[suggestionURL]"/>
</OpenSearchDescription>


ShortName

A short name for the search engine. It must be 16 or fewer characters of plain text, with no HTML or other markup.

Description

A brief description of the search engine. It must be 1024 or fewer characters of plain text, with no HTML or other markup.

InputEncoding

The character encoding to use when submitting input to the search engine.

Image

URL of an icon for the search engine. When possible, include a 16×16 image of type image/x-icon (such as /favicon.ico) and a 64×64 image of type image/jpeg or image/png.
The URL may also use the data: URL scheme. (You can generate a data: URL from an icon file at The data: URL kitchen.)
xml<Image height="16" width="16" type="image/x-icon">https://example.com/favicon.ico</Image>
  <!-- or -->
<Image height="16" width="16">data:image/x-icon;base64,AAABAAEAEBAAA…DAAA=</Image>

Firefox caches the icon as a base64 data: URL (search plug-ins are stored in the profile's searchplugins/ folder). http: and https: URLs are converted to data: URLs when this is done.

Note:
For icons loaded remotely (that is, from https:// URLs as opposed to data: URLs), Firefox will reject icons larger than 10 kilobytes.



Url

Describes the URL or URLs to use for the search. The template attribute indicates the base URL for the search query.
Firefox supports three URL types:

type="text/html" specifies the URL for the actual search query.
type="application/x-suggestions+json" specifies the URL for fetching search suggestions. In Firefox 63 onwards, type="application/json" is accepted as an alias of this.
type="application/x-moz-keywordsearch" specifies the URL used when a keyword search is entered in the location bar. This is supported only in Firefox.

For these URL types, you can use {searchTerms} to substitute the search terms entered by the user in the search bar or location bar. Other supported dynamic search parameters are described in OpenSearch 1.1 parameters.
For search suggestions, the application/x-suggestions+json URL template is used to fetch a suggestion list in JSON format.

Linking to the OpenSearch description fileTo support autodiscovery, add a <link> element for each search engine to the <head> of your web page:
html<link
  rel="search"
  type="application/opensearchdescription+xml"
  title="[searchTitle]"
  href="[descriptionURL]" />

Replace the items in [square brackets] as explained below:

searchTitle

The name of the search to perform, such as "Search MDC" or "Yahoo! Search". This must match your plugin file's <ShortName>.

descriptionURL

The URL to the XML description file, so the browser can download it.


If your site offers multiple search engines, you can support autodiscovery for them all. For example:
html<link
  rel="search"
  type="application/opensearchdescription+xml"
  title="MySite: By Author"
  href="http://example.com/mysiteauthor.xml" />

<link
  rel="search"
  type="application/opensearchdescription+xml"
  title="MySite: By Title"
  href="http://example.com/mysitetitle.xml" />

This way, your site can offer two engines to search: one by author and another by title.

Note:
In Firefox, an icon change in the search box indicates there's a provided search plugin. (See image, the green plus sign.) Thus if a search box is not shown in the user's UI, they will receive no indication. In general, behavior varies among browsers.
Supporting automatic updates for OpenSearch descriptionThe OpenSearch description file can update automatically. To support this, include an extra Url element with type="application/opensearchdescription+xml" and rel="self". The template attribute should be the URL of the OpenSearch document to automatically update to.
For example:
xml<Url
  type="application/opensearchdescription+xml"
  rel="self"
  template="https://example.com/mysearchdescription.xml" />
Troubleshooting tipsIf there is a mistake in your XML description file, you could run into errors when adding the search engine. If the error message isn't helpful, use the following tips to troubleshoot the problem:

Check that your server serves OpenSearch descriptions with Content-Type: application/opensearchdescription+xml.
Make sure that your XML description file is well-formed. You can check by loading the file directly into a browser. Ampersands (&) in the template URL must be escaped as &amp;, and tags must be closed with a trailing slash or a matching end tag.
Make sure to include the xmlns attribute—without it, you could get the error message like "Firefox could not download the search plugin".
You must include a text/html URL — search engines including only Atom or RSS URL types (which is valid, but Firefox doesn't support) will also generate the "could not download the search plugin" error.
Remotely fetched favicons must not be larger than 10KB (see Firefox bug 361923).
As mentioned earlier, browsers may not activate site search shortcuts by default. Check the browser's settings and make sure the search engine is activated.

In addition, the search plugin service provides a logging mechanism that may be useful to plugin developers. Use about:config to set the pref browser.search.log to true. Then, logging information will appear in Firefox's Browser Console (Tools ➤ Browser Tools ➤ Browser Console) when search plugins are added.Reference Material
OpenSearch Documentation
Safari 8.0 Release Notes: Quick Website Search
Microsoft Edge Dev Guide: Search provider discovery
The Chromium Projects: Tab to Search
imdb.com has a working osd.xml
Ready2Search - create OpenSearch plugins. Customized Search through Ready2Search\n\nOpenSearch description formatThe OpenSearch description format can be used to describe the web interface of a search engine. This allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine. OpenSearch is supported by (at least) Firefox, Edge, Safari, and Chrome. (See Reference Material for links to other browsers' documentation.)
Firefox also supports additional features not in the OpenSearch standard, such as search suggestions. This article focuses on creating OpenSearch-compatible search engines that support these additional Firefox features.OverviewThe address bar in browsers has a dual purpose: you can type a URL to directly go to a site, or you can type a search term to query a search engine. The search engine returns a list of results that you can browse directly, or you can open the search engine's full results page.
By default, browsers can connect to a few popular search engines, such as Google, Bing, or Yandex. The OpenSearch protocol allows websites to define their own search engines, enabling users to search those websites directly from the browser's address bar. For example, the MDN website has a site-wide search engine. If MDN registers itself as a search engine, users can search MDN directly from the address bar.
Browsers query a search engine by requesting a URL. The site defines a template for the URL to be requested, and the browser fills in the user's search terms in the specified placeholders. For example, if the search engine URL is https://example.com/search?q={searchTerms}, then the browser will request https://example.com/search?q=foo when the user types "foo" into the address bar. The search engine then generates a response—either a list of search results or a full search results page.
A site defines its search engine by linking to an XML description file in its HTML. When the user first visits the site, the browser detects this description file and registers the search engine. The browser then uses the registered search engine to handle searches from the address bar.

Note:
Chrome registers site search engines as "inactive" by default. Users must manually activate each site in the search engine settings.
OpenSearch description fileThe XML file that describes a search engine follows the basic template below. Sections in [square brackets] should be customized for your specific engine.
xml<OpenSearchDescription
  xmlns="http://a9.com/-/spec/opensearch/1.1/"
  xmlns:moz="http://www.mozilla.org/2006/browser/search/">
  <ShortName>[SNK]</ShortName>
  <Description>[Search engine full name and summary]</Description>
  <InputEncoding>[UTF-8]</InputEncoding>
  <Image width="16" height="16" type="image/x-icon">[https://example.com/favicon.ico]</Image>
  <Url type="text/html" template="[searchURL]"/>
  <Url type="application/x-suggestions+json" template="[suggestionURL]"/>
</OpenSearchDescription>


ShortName

A short name for the search engine. It must be 16 or fewer characters of plain text, with no HTML or other markup.

Description

A brief description of the search engine. It must be 1024 or fewer characters of plain text, with no HTML or other markup.

InputEncoding

The character encoding to use when submitting input to the search engine.

Image

URL of an icon for the search engine. When possible, include a 16×16 image of type image/x-icon (such as /favicon.ico) and a 64×64 image of type image/jpeg or image/png.
The URL may also use the data: URL scheme. (You can generate a data: URL from an icon file at The data: URL kitchen.)
xml<Image height="16" width="16" type="image/x-icon">https://example.com/favicon.ico</Image>
  <!-- or -->
<Image height="16" width="16">data:image/x-icon;base64,AAABAAEAEBAAA…DAAA=</Image>

Firefox caches the icon as a base64 data: URL (search plug-ins are stored in the profile's searchplugins/ folder). http: and https: URLs are converted to data: URLs when this is done.

Note:
For icons loaded remotely (that is, from https:// URLs as opposed to data: URLs), Firefox will reject icons larger than 10 kilobytes.



Url

Describes the URL or URLs to use for the search. The template attribute indicates the base URL for the search query.
Firefox supports three URL types:

type="text/html" specifies the URL for the actual search query.
type="application/x-suggestions+json" specifies the URL for fetching search suggestions. In Firefox 63 onwards, type="application/json" is accepted as an alias of this.
type="application/x-moz-keywordsearch" specifies the URL used when a keyword search is entered in the location bar. This is supported only in Firefox.

For these URL types, you can use {searchTerms} to substitute the search terms entered by the user in the search bar or location bar. Other supported dynamic search parameters are described in OpenSearch 1.1 parameters.
For search suggestions, the application/x-suggestions+json URL template is used to fetch a suggestion list in JSON format.

Linking to the OpenSearch description fileTo support autodiscovery, add a <link> element for each search engine to the <head> of your web page:
html<link
  rel="search"
  type="application/opensearchdescription+xml"
  title="[searchTitle]"
  href="[descriptionURL]" />

Replace the items in [square brackets] as explained below:

searchTitle

The name of the search to perform, such as "Search MDC" or "Yahoo! Search". This must match your plugin file's <ShortName>.

descriptionURL

The URL to the XML description file, so the browser can download it.


If your site offers multiple search engines, you can support autodiscovery for them all. For example:
html<link
  rel="search"
  type="application/opensearchdescription+xml"
  title="MySite: By Author"
  href="http://example.com/mysiteauthor.xml" />

<link
  rel="search"
  type="application/opensearchdescription+xml"
  title="MySite: By Title"
  href="http://example.com/mysitetitle.xml" />

This way, your site can offer two engines to search: one by author and another by title.

Note:
In Firefox, an icon change in the search box indicates there's a provided search plugin. (See image, the green plus sign.) Thus if a search box is not shown in the user's UI, they will receive no indication. In general, behavior varies among browsers.
Supporting automatic updates for OpenSearch descriptionThe OpenSearch description file can update automatically. To support this, include an extra Url element with type="application/opensearchdescription+xml" and rel="self". The template attribute should be the URL of the OpenSearch document to automatically update to.
For example:
xml<Url
  type="application/opensearchdescription+xml"
  rel="self"
  template="https://example.com/mysearchdescription.xml" />
Troubleshooting tipsIf there is a mistake in your XML description file, you could run into errors when adding the search engine. If the error message isn't helpful, use the following tips to troubleshoot the problem:

Check that your server serves OpenSearch descriptions with Content-Type: application/opensearchdescription+xml.
Make sure that your XML description file is well-formed. You can check by loading the file directly into a browser. Ampersands (&) in the template URL must be escaped as &amp;, and tags must be closed with a trailing slash or a matching end tag.
Make sure to include the xmlns attribute—without it, you could get the error message like "Firefox could not download the search plugin".
You must include a text/html URL — search engines including only Atom or RSS URL types (which is valid, but Firefox doesn't support) will also generate the "could not download the search plugin" error.
Remotely fetched favicons must not be larger than 10KB (see Firefox bug 361923).
As mentioned earlier, browsers may not activate site search shortcuts by default. Check the browser's settings and make sure the search engine is activated.

In addition, the search plugin service provides a logging mechanism that may be useful to plugin developers. Use about:config to set the pref browser.search.log to true. Then, logging information will appear in Firefox's Browser Console (Tools ➤ Browser Tools ➤ Browser Console) when search plugins are added.Reference Material
OpenSearch Documentation
Safari 8.0 Release Notes: Quick Website Search
Microsoft Edge Dev Guide: Search provider discovery
The Chromium Projects: Tab to Search
imdb.com has a working osd.xml
Ready2Search - create OpenSearch plugins. Customized Search through Ready2Search
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nOpenSearch description formatThe OpenSearch description format can be used to describe the web interface of a search engine. This allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine. OpenSearch is supported by (at least) Firefox, Edge, Safari, and Chrome. (See Reference Material for links to other browsers' documentation.)
Firefox also supports additional features not in the OpenSearch standard, such as search suggestions. This article focuses on creating OpenSearch-compatible search engines that support these additional Firefox features.OverviewThe address bar in browsers has a dual purpose: you can type a URL to directly go to a site, or you can type a search term to query a search engine. The search engine returns a list of results that you can browse directly, or you can open the search engine's full results page.
By default, browsers can connect to a few popular search engines, such as Google, Bing, or Yandex. The OpenSearch protocol allows websites to define their own search engines, enabling users to search those websites directly from the browser's address bar. For example, the MDN website has a site-wide search engine. If MDN registers itself as a search engine, users can search MDN directly from the address bar.
Browsers query a search engine by requesting a URL. The site defines a template for the URL to be requested, and the browser fills in the user's search terms in the specified placeholders. For example, if the search engine URL is https://example.com/search?q={searchTerms}, then the browser will request https://example.com/search?q=foo when the user types "foo" into the address bar. The search engine then generates a response—either a list of search results or a full search results page.
A site defines its search engine by linking to an XML description file in its HTML. When the user first visits the site, the browser detects this description file and registers the search engine. The browser then uses the registered search engine to handle searches from the address bar.

Note:
Chrome registers site search engines as "inactive" by default. Users must manually activate each site in the search engine settings.
OpenSearch description fileThe XML file that describes a search engine follows the basic template below. Sections in [square brackets] should be customized for your specific engine.
xml<OpenSearchDescription
  xmlns="http://a9.com/-/spec/opensearch/1.1/"
  xmlns:moz="http://www.mozilla.org/2006/browser/search/">
  <ShortName>[SNK]</ShortName>
  <Description>[Search engine full name and summary]</Description>
  <InputEncoding>[UTF-8]</InputEncoding>
  <Image width="16" height="16" type="image/x-icon">[https://example.com/favicon.ico]</Image>
  <Url type="text/html" template="[searchURL]"/>
  <Url type="application/x-suggestions+json" template="[suggestionURL]"/>
</OpenSearchDescription>


ShortName

A short name for the search engine. It must be 16 or fewer characters of plain text, with no HTML or other markup.

Description

A brief description of the search engine. It must be 1024 or fewer characters of plain text, with no HTML or other markup.

InputEncoding

The character encoding to use when submitting input to the search engine.

Image

URL of an icon for the search engine. When possible, include a 16×16 image of type image/x-icon (such as /favicon.ico) and a 64×64 image of type image/jpeg or image/png.
The URL may also use the data: URL scheme. (You can generate a data: URL from an icon file at The data: URL kitchen.)
xml<Image height="16" width="16" type="image/x-icon">https://example.com/favicon.ico</Image>
  <!-- or -->
<Image height="16" width="16">data:image/x-icon;base64,AAABAAEAEBAAA…DAAA=</Image>

Firefox caches the icon as a base64 data: URL (search plug-ins are stored in the profile's searchplugins/ folder). http: and https: URLs are converted to data: URLs when this is done.

Note:
For icons loaded remotely (that is, from https:// URLs as opposed to data: URLs), Firefox will reject icons larger than 10 kilobytes.



Url

Describes the URL or URLs to use for the search. The template attribute indicates the base URL for the search query.
Firefox supports three URL types:

type="text/html" specifies the URL for the actual search query.
type="application/x-suggestions+json" specifies the URL for fetching search suggestions. In Firefox 63 onwards, type="application/json" is accepted as an alias of this.
type="application/x-moz-keywordsearch" specifies the URL used when a keyword search is entered in the location bar. This is supported only in Firefox.

For these URL types, you can use {searchTerms} to substitute the search terms entered by the user in the search bar or location bar. Other supported dynamic search parameters are described in OpenSearch 1.1 parameters.
For search suggestions, the application/x-suggestions+json URL template is used to fetch a suggestion list in JSON format.

Linking to the OpenSearch description fileTo support autodiscovery, add a <link> element for each search engine to the <head> of your web page:
html<link
  rel="search"
  type="application/opensearchdescription+xml"
  title="[searchTitle]"
  href="[descriptionURL]" />

Replace the items in [square brackets] as explained below:

searchTitle

The name of the search to perform, such as "Search MDC" or "Yahoo! Search". This must match your plugin file's <ShortName>.

descriptionURL

The URL to the XML description file, so the browser can download it.


If your site offers multiple search engines, you can support autodiscovery for them all. For example:
html<link
  rel="search"
  type="application/opensearchdescription+xml"
  title="MySite: By Author"
  href="http://example.com/mysiteauthor.xml" />

<link
  rel="search"
  type="application/opensearchdescription+xml"
  title="MySite: By Title"
  href="http://example.com/mysitetitle.xml" />

This way, your site can offer two engines to search: one by author and another by title.

Note:
In Firefox, an icon change in the search box indicates there's a provided search plugin. (See image, the green plus sign.) Thus if a search box is not shown in the user's UI, they will receive no indication. In general, behavior varies among browsers.
Supporting automatic updates for OpenSearch descriptionThe OpenSearch description file can update automatically. To support this, include an extra Url element with type="application/opensearchdescription+xml" and rel="self". The template attribute should be the URL of the OpenSearch document to automatically update to.
For example:
xml<Url
  type="application/opensearchdescription+xml"
  rel="self"
  template="https://example.com/mysearchdescription.xml" />
Troubleshooting tipsIf there is a mistake in your XML description file, you could run into errors when adding the search engine. If the error message isn't helpful, use the following tips to troubleshoot the problem:

Check that your server serves OpenSearch descriptions with Content-Type: application/opensearchdescription+xml.
Make sure that your XML description file is well-formed. You can check by loading the file directly into a browser. Ampersands (&) in the template URL must be escaped as &amp;, and tags must be closed with a trailing slash or a matching end tag.
Make sure to include the xmlns attribute—without it, you could get the error message like "Firefox could not download the search plugin".
You must include a text/html URL — search engines including only Atom or RSS URL types (which is valid, but Firefox doesn't support) will also generate the "could not download the search plugin" error.
Remotely fetched favicons must not be larger than 10KB (see Firefox bug 361923).
As mentioned earlier, browsers may not activate site search shortcuts by default. Check the browser's settings and make sure the search engine is activated.

In addition, the search plugin service provides a logging mechanism that may be useful to plugin developers. Use about:config to set the pref browser.search.log to true. Then, logging information will appear in Firefox's Browser Console (Tools ➤ Browser Tools ➤ Browser Console) when search plugins are added.Reference Material
OpenSearch Documentation
Safari 8.0 Release Notes: Quick Website Search
Microsoft Edge Dev Guide: Search provider discovery
The Chromium Projects: Tab to Search
imdb.com has a working osd.xml
Ready2Search - create OpenSearch plugins. Customized Search through Ready2Search
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nDocument Object Model (DOM)The Document Object Model (DOM) connects web pages to scripts or programming languages by representing the structure of a document—such as the HTML representing a web page—in memory. Usually it refers to JavaScript, even though modeling HTML, SVG, or XML documents as objects are not part of the core JavaScript language.
The DOM represents a document with a logical tree. Each branch of the tree ends in a node, and each node contains objects. DOM methods allow programmatic access to the tree. With them, you can change the document's structure, style, or content.
Nodes can also have event handlers attached to them. Once an event is triggered, the event handlers get executed.
To learn more about what the DOM is and how it represents documents, see our article Introduction to the DOM.DOM interfaces
AbortController
AbortSignal
AbstractRange
Attr
CDATASection
CharacterData
Comment
CustomEvent
Document
DocumentFragment
DocumentType
DOMError 
Deprecated

DOMException
DOMImplementation
DOMParser
DOMPoint
DOMPointReadOnly
DOMRect
DOMTokenList
Element
Event
EventTarget
HTMLCollection
MutationObserver
MutationRecord
NamedNodeMap
Node
NodeIterator
NodeList
ProcessingInstruction
Range
StaticRange
Text
TextDecoder
TextEncoder
TimeRanges
TreeWalker
XMLDocument
Obsolete DOM interfacesThe Document Object Model has been highly simplified. To achieve this, the following interfaces in the different DOM level 3 or earlier specifications have been removed. They are no longer available to web developers.

DOMConfiguration
DOMErrorHandler
DOMImplementationList
DOMImplementationRegistry
DOMImplementationSource
DOMLocator
DOMObject
DOMSettableTokenList
DOMUserData
ElementTraversal
Entity
EntityReference
NameList
Notation
TypeInfo
UserDataHandler
HTML DOMA document containing HTML is described using the Document interface, which is extended by the HTML specification to include various HTML-specific features. In particular, the Element interface is enhanced to become HTMLElement and various subclasses, each representing one of (or a family of closely related) elements.
The HTML DOM API provides access to various browser features such as tabs and windows, CSS styles and stylesheets, browser history, etc. These interfaces are discussed further in the HTML DOM API documentation.SVG DOMSimilarly, a document containing SVG is also described using the Document interface, which is extended by the SVG specification to include various SVG-specific features. In particular, the Element interface is enhanced to become SVGElement and various subclasses, each representing an element or a family of closely related elements. These interfaces are discussed further in the SVG API documentation.SpecificationsSpecificationDOM See also
DOM Examples
CSS Object Model (CSSOM)\n\nDocument Object Model (DOM)The Document Object Model (DOM) connects web pages to scripts or programming languages by representing the structure of a document—such as the HTML representing a web page—in memory. Usually it refers to JavaScript, even though modeling HTML, SVG, or XML documents as objects are not part of the core JavaScript language.
The DOM represents a document with a logical tree. Each branch of the tree ends in a node, and each node contains objects. DOM methods allow programmatic access to the tree. With them, you can change the document's structure, style, or content.
Nodes can also have event handlers attached to them. Once an event is triggered, the event handlers get executed.
To learn more about what the DOM is and how it represents documents, see our article Introduction to the DOM.DOM interfaces
AbortController
AbortSignal
AbstractRange
Attr
CDATASection
CharacterData
Comment
CustomEvent
Document
DocumentFragment
DocumentType
DOMError 
Deprecated

DOMException
DOMImplementation
DOMParser
DOMPoint
DOMPointReadOnly
DOMRect
DOMTokenList
Element
Event
EventTarget
HTMLCollection
MutationObserver
MutationRecord
NamedNodeMap
Node
NodeIterator
NodeList
ProcessingInstruction
Range
StaticRange
Text
TextDecoder
TextEncoder
TimeRanges
TreeWalker
XMLDocument
Obsolete DOM interfacesThe Document Object Model has been highly simplified. To achieve this, the following interfaces in the different DOM level 3 or earlier specifications have been removed. They are no longer available to web developers.

DOMConfiguration
DOMErrorHandler
DOMImplementationList
DOMImplementationRegistry
DOMImplementationSource
DOMLocator
DOMObject
DOMSettableTokenList
DOMUserData
ElementTraversal
Entity
EntityReference
NameList
Notation
TypeInfo
UserDataHandler
HTML DOMA document containing HTML is described using the Document interface, which is extended by the HTML specification to include various HTML-specific features. In particular, the Element interface is enhanced to become HTMLElement and various subclasses, each representing one of (or a family of closely related) elements.
The HTML DOM API provides access to various browser features such as tabs and windows, CSS styles and stylesheets, browser history, etc. These interfaces are discussed further in the HTML DOM API documentation.SVG DOMSimilarly, a document containing SVG is also described using the Document interface, which is extended by the SVG specification to include various SVG-specific features. In particular, the Element interface is enhanced to become SVGElement and various subclasses, each representing an element or a family of closely related elements. These interfaces are discussed further in the SVG API documentation.SpecificationsSpecificationDOM See also
DOM Examples
CSS Object Model (CSSOM)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Dec 17, 2023 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nDocument Object Model (DOM)The Document Object Model (DOM) connects web pages to scripts or programming languages by representing the structure of a document—such as the HTML representing a web page—in memory. Usually it refers to JavaScript, even though modeling HTML, SVG, or XML documents as objects are not part of the core JavaScript language.
The DOM represents a document with a logical tree. Each branch of the tree ends in a node, and each node contains objects. DOM methods allow programmatic access to the tree. With them, you can change the document's structure, style, or content.
Nodes can also have event handlers attached to them. Once an event is triggered, the event handlers get executed.
To learn more about what the DOM is and how it represents documents, see our article Introduction to the DOM.DOM interfaces
AbortController
AbortSignal
AbstractRange
Attr
CDATASection
CharacterData
Comment
CustomEvent
Document
DocumentFragment
DocumentType
DOMError 
Deprecated

DOMException
DOMImplementation
DOMParser
DOMPoint
DOMPointReadOnly
DOMRect
DOMTokenList
Element
Event
EventTarget
HTMLCollection
MutationObserver
MutationRecord
NamedNodeMap
Node
NodeIterator
NodeList
ProcessingInstruction
Range
StaticRange
Text
TextDecoder
TextEncoder
TimeRanges
TreeWalker
XMLDocument
Obsolete DOM interfacesThe Document Object Model has been highly simplified. To achieve this, the following interfaces in the different DOM level 3 or earlier specifications have been removed. They are no longer available to web developers.

DOMConfiguration
DOMErrorHandler
DOMImplementationList
DOMImplementationRegistry
DOMImplementationSource
DOMLocator
DOMObject
DOMSettableTokenList
DOMUserData
ElementTraversal
Entity
EntityReference
NameList
Notation
TypeInfo
UserDataHandler
HTML DOMA document containing HTML is described using the Document interface, which is extended by the HTML specification to include various HTML-specific features. In particular, the Element interface is enhanced to become HTMLElement and various subclasses, each representing one of (or a family of closely related) elements.
The HTML DOM API provides access to various browser features such as tabs and windows, CSS styles and stylesheets, browser history, etc. These interfaces are discussed further in the HTML DOM API documentation.SVG DOMSimilarly, a document containing SVG is also described using the Document interface, which is extended by the SVG specification to include various SVG-specific features. In particular, the Element interface is enhanced to become SVGElement and various subclasses, each representing an element or a family of closely related elements. These interfaces are discussed further in the SVG API documentation.SpecificationsSpecificationDOM See also
DOM Examples
CSS Object Model (CSSOM)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Dec 17, 2023 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nXSLT: Extensible Stylesheet Language TransformationsExtensible Stylesheet Language Transformations (XSLT) is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.
Although the process is referred to as "transformation," the original document is not changed; rather, a new XML document is created based on the content of an existing document. Then, the new document may be serialized (output) by the processor in standard XML syntax or in another format, such as HTML or plain text.
XSLT is most often used to convert data between different XML schemas or to convert XML data into web pages or PDF documents.DocumentationReference
XSLT elements reference

This page describes XSLT elements, focusing on top-level elements used in <xsl:stylesheet> or <xsl:transform> and instructions for templates.
It also briefly covers literal result elements (LREs), which copy non-instruction elements like <hr> directly to the output, and attribute value templates that use XPath expressions to set attribute values.

Guides
Transforming XML with XSLT

XSLT allows a stylesheet author to transform a primary XML document in two significant ways: manipulating and sorting the content, including a wholesale reordering of it if so desired, and transforming the content into a different format.

Specifying parameters using processing instructions

Firefox allows stylesheet parameters to be specified when using the <?xml-stylesheet?> processing instruction. This is done using the <?xslt-param?> PI described in this document.

Common XSLT Errors

This article lists some common problems using XSLT in Firefox.

Related topics
XML
XPath
See also
W3Schools XSLT Introduction

This tutorial teaches the reader how to use XSLT to transform XML documents into other formats, like XHTML.

What is XSLT?

This extensive introduction to XSLT and XPath assumes no prior knowledge of the technologies and guides the reader through background, context, structure, concepts and introductory terminology.\n\nXSLT: Extensible Stylesheet Language TransformationsExtensible Stylesheet Language Transformations (XSLT) is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.
Although the process is referred to as "transformation," the original document is not changed; rather, a new XML document is created based on the content of an existing document. Then, the new document may be serialized (output) by the processor in standard XML syntax or in another format, such as HTML or plain text.
XSLT is most often used to convert data between different XML schemas or to convert XML data into web pages or PDF documents.DocumentationReference
XSLT elements reference

This page describes XSLT elements, focusing on top-level elements used in <xsl:stylesheet> or <xsl:transform> and instructions for templates.
It also briefly covers literal result elements (LREs), which copy non-instruction elements like <hr> directly to the output, and attribute value templates that use XPath expressions to set attribute values.

Guides
Transforming XML with XSLT

XSLT allows a stylesheet author to transform a primary XML document in two significant ways: manipulating and sorting the content, including a wholesale reordering of it if so desired, and transforming the content into a different format.

Specifying parameters using processing instructions

Firefox allows stylesheet parameters to be specified when using the <?xml-stylesheet?> processing instruction. This is done using the <?xslt-param?> PI described in this document.

Common XSLT Errors

This article lists some common problems using XSLT in Firefox.

Related topics
XML
XPath
See also
W3Schools XSLT Introduction

This tutorial teaches the reader how to use XSLT to transform XML documents into other formats, like XHTML.

What is XSLT?

This extensive introduction to XSLT and XPath assumes no prior knowledge of the technologies and guides the reader through background, context, structure, concepts and introductory terminology.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 5, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nXSLT: Extensible Stylesheet Language TransformationsExtensible Stylesheet Language Transformations (XSLT) is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.
Although the process is referred to as "transformation," the original document is not changed; rather, a new XML document is created based on the content of an existing document. Then, the new document may be serialized (output) by the processor in standard XML syntax or in another format, such as HTML or plain text.
XSLT is most often used to convert data between different XML schemas or to convert XML data into web pages or PDF documents.DocumentationReference
XSLT elements reference

This page describes XSLT elements, focusing on top-level elements used in <xsl:stylesheet> or <xsl:transform> and instructions for templates.
It also briefly covers literal result elements (LREs), which copy non-instruction elements like <hr> directly to the output, and attribute value templates that use XPath expressions to set attribute values.

Guides
Transforming XML with XSLT

XSLT allows a stylesheet author to transform a primary XML document in two significant ways: manipulating and sorting the content, including a wholesale reordering of it if so desired, and transforming the content into a different format.

Specifying parameters using processing instructions

Firefox allows stylesheet parameters to be specified when using the <?xml-stylesheet?> processing instruction. This is done using the <?xslt-param?> PI described in this document.

Common XSLT Errors

This article lists some common problems using XSLT in Firefox.

Related topics
XML
XPath
See also
W3Schools XSLT Introduction

This tutorial teaches the reader how to use XSLT to transform XML documents into other formats, like XHTML.

What is XSLT?

This extensive introduction to XSLT and XPath assumes no prior knowledge of the technologies and guides the reader through background, context, structure, concepts and introductory terminology.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 5, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nXML introductionXML (Extensible Markup Language) is a markup language similar to HTML, but without predefined tags to use. Instead, you define your own tags designed specifically for your needs. This is a powerful way to store data in a format that can be stored, searched, and shared. Most importantly, since the fundamental format of XML is standardized, if you share or transmit XML across systems or platforms, either locally or over the internet, the recipient can still parse the data due to the standardized XML syntax.
There are many languages based on XML, including XHTML, MathML, SVG, RSS, and RDF. You can also define your own.Structure of an XML documentThe whole structure of XML and XML-based languages is built on tags.XML declarationXML - declaration is not a tag. It is used for the transmission of the meta-data of a document.
html<?xml version="1.0" encoding="UTF-8"?>

Attributes

version

Used version XML in this document.

encoding

Used encoding in this document.

Commentshtml<!-- Comment -->
"Correct" XML (valid and well-formed)Correct design rulesFor an XML document to be correct, the following conditions must be fulfilled:

Document must be well-formed.
Document must conform to all XML syntax rules.
Document must conform to semantic rules, which are usually set in an XML schema or a DTD (Document Type Definition).
Examplexml<?xml version="1.0" encoding="UTF-8"?>
<message>
    <warning>
        Hello World
    <!--missing </warning> -->
</message>

Now let's look at a corrected version of that same document:
xml<?xml version="1.0" encoding="UTF-8"?>
<message>
    <warning>
         Hello World
    </warning>
</message>

A document that contains an undefined tag is invalid. For example, if we never defined the <warning> tag, the document above wouldn't be valid.
Most browsers offer a debugger that can identify poorly-formed XML documents.Character referencesLike HTML, XML offers character references for referring to some special reserved characters (such as a greater than sign which is used for tags). There are five of these characters that you should know:



Entity
Character
Description




&lt;
<
Less than sign


&gt;
>
Greater than sign


&amp;
&
Ampersand


&quot;
"
One double-quotation mark


&apos;
'
One apostrophe (or single-quotation mark)



Even though there are only 5 declared character references, or entities, more can be added using the document's Document Type Definition. For example, to create a new &warning; entity, you can do this:
xml<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE body [
  <!ENTITY warning "Warning: Something bad happened... please refresh and try again.">
]>
<body>
  <message> &warning; </message>
</body>

You can also use numeric character references to specify special characters; for example, &#xA9; is the "©" symbol.Displaying XMLXML is usually used for descriptive purposes, but there are ways to display XML data. If you don't define a specific way for the XML to be rendered, the raw XML is displayed in the browser.
One way to style XML output is to specify CSS to apply to the document using the xml-stylesheet processing instruction.
xml<?xml-stylesheet type="text/css" href="stylesheet.css"?>

There is also another more powerful way to display XML: the Extensible Stylesheet Language Transformations (XSLT) which can be used to transform XML into other languages such as HTML. This makes XML incredibly versatile.
xml<?xml-stylesheet type="text/xsl" href="transform.xsl"?>
RecommendationsThis article is obviously only a very brief introduction to what XML is, with a few small examples and references to get you started. For more details about XML, you should look around on the Web for more in-depth articles.
Learning the HyperText Markup Language (HTML) will help you better understand XML.See also
XML.com
Extensible Markup Language (XML) @ W3.org
Using XML: A List Apart\n\nXML introductionXML (Extensible Markup Language) is a markup language similar to HTML, but without predefined tags to use. Instead, you define your own tags designed specifically for your needs. This is a powerful way to store data in a format that can be stored, searched, and shared. Most importantly, since the fundamental format of XML is standardized, if you share or transmit XML across systems or platforms, either locally or over the internet, the recipient can still parse the data due to the standardized XML syntax.
There are many languages based on XML, including XHTML, MathML, SVG, RSS, and RDF. You can also define your own.Structure of an XML documentThe whole structure of XML and XML-based languages is built on tags.XML declarationXML - declaration is not a tag. It is used for the transmission of the meta-data of a document.
html<?xml version="1.0" encoding="UTF-8"?>

Attributes

version

Used version XML in this document.

encoding

Used encoding in this document.

Commentshtml<!-- Comment -->
"Correct" XML (valid and well-formed)Correct design rulesFor an XML document to be correct, the following conditions must be fulfilled:

Document must be well-formed.
Document must conform to all XML syntax rules.
Document must conform to semantic rules, which are usually set in an XML schema or a DTD (Document Type Definition).
Examplexml<?xml version="1.0" encoding="UTF-8"?>
<message>
    <warning>
        Hello World
    <!--missing </warning> -->
</message>

Now let's look at a corrected version of that same document:
xml<?xml version="1.0" encoding="UTF-8"?>
<message>
    <warning>
         Hello World
    </warning>
</message>

A document that contains an undefined tag is invalid. For example, if we never defined the <warning> tag, the document above wouldn't be valid.
Most browsers offer a debugger that can identify poorly-formed XML documents.Character referencesLike HTML, XML offers character references for referring to some special reserved characters (such as a greater than sign which is used for tags). There are five of these characters that you should know:



Entity
Character
Description




&lt;
<
Less than sign


&gt;
>
Greater than sign


&amp;
&
Ampersand


&quot;
"
One double-quotation mark


&apos;
'
One apostrophe (or single-quotation mark)



Even though there are only 5 declared character references, or entities, more can be added using the document's Document Type Definition. For example, to create a new &warning; entity, you can do this:
xml<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE body [
  <!ENTITY warning "Warning: Something bad happened... please refresh and try again.">
]>
<body>
  <message> &warning; </message>
</body>

You can also use numeric character references to specify special characters; for example, &#xA9; is the "©" symbol.Displaying XMLXML is usually used for descriptive purposes, but there are ways to display XML data. If you don't define a specific way for the XML to be rendered, the raw XML is displayed in the browser.
One way to style XML output is to specify CSS to apply to the document using the xml-stylesheet processing instruction.
xml<?xml-stylesheet type="text/css" href="stylesheet.css"?>

There is also another more powerful way to display XML: the Extensible Stylesheet Language Transformations (XSLT) which can be used to transform XML into other languages such as HTML. This makes XML incredibly versatile.
xml<?xml-stylesheet type="text/xsl" href="transform.xsl"?>
RecommendationsThis article is obviously only a very brief introduction to what XML is, with a few small examples and references to get you started. For more details about XML, you should look around on the Web for more in-depth articles.
Learning the HyperText Markup Language (HTML) will help you better understand XML.See also
XML.com
Extensible Markup Language (XML) @ W3.org
Using XML: A List Apart
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 5, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nXML introductionXML (Extensible Markup Language) is a markup language similar to HTML, but without predefined tags to use. Instead, you define your own tags designed specifically for your needs. This is a powerful way to store data in a format that can be stored, searched, and shared. Most importantly, since the fundamental format of XML is standardized, if you share or transmit XML across systems or platforms, either locally or over the internet, the recipient can still parse the data due to the standardized XML syntax.
There are many languages based on XML, including XHTML, MathML, SVG, RSS, and RDF. You can also define your own.Structure of an XML documentThe whole structure of XML and XML-based languages is built on tags.XML declarationXML - declaration is not a tag. It is used for the transmission of the meta-data of a document.
html<?xml version="1.0" encoding="UTF-8"?>

Attributes

version

Used version XML in this document.

encoding

Used encoding in this document.

Commentshtml<!-- Comment -->
"Correct" XML (valid and well-formed)Correct design rulesFor an XML document to be correct, the following conditions must be fulfilled:

Document must be well-formed.
Document must conform to all XML syntax rules.
Document must conform to semantic rules, which are usually set in an XML schema or a DTD (Document Type Definition).
Examplexml<?xml version="1.0" encoding="UTF-8"?>
<message>
    <warning>
        Hello World
    <!--missing </warning> -->
</message>

Now let's look at a corrected version of that same document:
xml<?xml version="1.0" encoding="UTF-8"?>
<message>
    <warning>
         Hello World
    </warning>
</message>

A document that contains an undefined tag is invalid. For example, if we never defined the <warning> tag, the document above wouldn't be valid.
Most browsers offer a debugger that can identify poorly-formed XML documents.Character referencesLike HTML, XML offers character references for referring to some special reserved characters (such as a greater than sign which is used for tags). There are five of these characters that you should know:



Entity
Character
Description




&lt;
<
Less than sign


&gt;
>
Greater than sign


&amp;
&
Ampersand


&quot;
"
One double-quotation mark


&apos;
'
One apostrophe (or single-quotation mark)



Even though there are only 5 declared character references, or entities, more can be added using the document's Document Type Definition. For example, to create a new &warning; entity, you can do this:
xml<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE body [
  <!ENTITY warning "Warning: Something bad happened... please refresh and try again.">
]>
<body>
  <message> &warning; </message>
</body>

You can also use numeric character references to specify special characters; for example, &#xA9; is the "©" symbol.Displaying XMLXML is usually used for descriptive purposes, but there are ways to display XML data. If you don't define a specific way for the XML to be rendered, the raw XML is displayed in the browser.
One way to style XML output is to specify CSS to apply to the document using the xml-stylesheet processing instruction.
xml<?xml-stylesheet type="text/css" href="stylesheet.css"?>

There is also another more powerful way to display XML: the Extensible Stylesheet Language Transformations (XSLT) which can be used to transform XML into other languages such as HTML. This makes XML incredibly versatile.
xml<?xml-stylesheet type="text/xsl" href="transform.xsl"?>
RecommendationsThis article is obviously only a very brief introduction to what XML is, with a few small examples and references to get you started. For more details about XML, you should look around on the Web for more in-depth articles.
Learning the HyperText Markup Language (HTML) will help you better understand XML.See also
XML.com
Extensible Markup Language (XML) @ W3.org
Using XML: A List Apart
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 5, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nXPathXPath stands for XML Path Language. It uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.
XPath is mainly used in XSLT, but can also be used as a much more powerful way of navigating through the DOM of any XML-like language document using XPathExpression, such as HTML and SVG, instead of relying on the Document.getElementById() or Document.querySelectorAll() methods, the Node.childNodes properties, and other DOM Core features.
XPath uses a path notation (as in URLs) for navigating through the hierarchical structure of an XML document. It uses a non-XML syntax so that it can be used in URIs and XML attribute values.Guides
Introduction to using XPath in JavaScript

Describes a non-XSLT use of XPath.

XPath snippets

These are JavaScript utility functions, that can be used in your own code, based on DOM Level 3 XPath APIs.

Reference
XPath:Axes

List and definition of the axes defined in the XPath specification. Axes are used to describe the relationships between nodes.

XPath:Functions

List and description of the core XPath functions and XSLT-specific additions to XPath.

See also
XSLT, XML, DOM
Transforming XML with XSLT
Comparison of CSS Selectors and XPath
What is XSLT? introduces XSLT and XPath, including background, context, structure, concepts, and terminology - xml.com (2000)
XPath tester online XPath Builder/Debugger\n\nXPathXPath stands for XML Path Language. It uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.
XPath is mainly used in XSLT, but can also be used as a much more powerful way of navigating through the DOM of any XML-like language document using XPathExpression, such as HTML and SVG, instead of relying on the Document.getElementById() or Document.querySelectorAll() methods, the Node.childNodes properties, and other DOM Core features.
XPath uses a path notation (as in URLs) for navigating through the hierarchical structure of an XML document. It uses a non-XML syntax so that it can be used in URIs and XML attribute values.Guides
Introduction to using XPath in JavaScript

Describes a non-XSLT use of XPath.

XPath snippets

These are JavaScript utility functions, that can be used in your own code, based on DOM Level 3 XPath APIs.

Reference
XPath:Axes

List and definition of the axes defined in the XPath specification. Axes are used to describe the relationships between nodes.

XPath:Functions

List and description of the core XPath functions and XSLT-specific additions to XPath.

See also
XSLT, XML, DOM
Transforming XML with XSLT
Comparison of CSS Selectors and XPath
What is XSLT? introduces XSLT and XPath, including background, context, structure, concepts, and terminology - xml.com (2000)
XPath tester online XPath Builder/Debugger
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 5, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nXPathXPath stands for XML Path Language. It uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.
XPath is mainly used in XSLT, but can also be used as a much more powerful way of navigating through the DOM of any XML-like language document using XPathExpression, such as HTML and SVG, instead of relying on the Document.getElementById() or Document.querySelectorAll() methods, the Node.childNodes properties, and other DOM Core features.
XPath uses a path notation (as in URLs) for navigating through the hierarchical structure of an XML document. It uses a non-XML syntax so that it can be used in URIs and XML attribute values.Guides
Introduction to using XPath in JavaScript

Describes a non-XSLT use of XPath.

XPath snippets

These are JavaScript utility functions, that can be used in your own code, based on DOM Level 3 XPath APIs.

Reference
XPath:Axes

List and definition of the axes defined in the XPath specification. Axes are used to describe the relationships between nodes.

XPath:Functions

List and description of the core XPath functions and XSLT-specific additions to XPath.

See also
XSLT, XML, DOM
Transforming XML with XSLT
Comparison of CSS Selectors and XPath
What is XSLT? introduces XSLT and XPath, including background, context, structure, concepts, and terminology - xml.com (2000)
XPath tester online XPath Builder/Debugger
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 5, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nEXSLTEXSLT is a set of extensions to XSLT. There are a number of modules; those that are supported by Firefox are listed below:EXSLT modulesTo use an EXSLT function, you need to declare the namespace the function is in, and then use the appropriate prefix when calling the function. For example, to use the regular expressions package:
xml<xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:regexp="http://exslt.org/regular-expressions">
  <xsl:template match="/">
    …
    <xsl:value-of select="regexp:replace(/root/@value, 'before', 'gi', 'AFTER')"/>
    …
  </xsl:template>

</xsl:stylesheet>
CommonThe EXSLT Common package provides basic functions that expand upon the capabilities of XSLT. The namespace for the Common package is http://exslt.org/common.
Functions

exsl:node-set()
exsl:object-type()
MathThe EXSLT Math package provides functions for working with numeric values and comparing nodes. The namespace for the Math package is http://exslt.org/math.
Functions

math:highest()
math:lowest()
math:max()
math:min()
Regular expressionsThe EXSLT Regular Expressions package provides functions that allow testing, matching, and replacing text using JavaScript style regular expressions.
The EXSLT Regular Expressions namespace is http://exslt.org/regular-expressions.
Functions

regexp:match()
regexp:replace()
regexp:test()
SetsThe EXSLT Sets package offers functions that let you perform set manipulation. The namespace for these functions is http://exslt.org/sets.
Functions

set:difference()
set:distinct()
set:intersection()
set:has-same-node()
set:leading()
set:trailing()
StringsThe EXSLT Strings package provides functions that allow the manipulation of strings. The namespace for the Strings package is http://exslt.org/strings.
Functions

str:concat()
str:split()
str:tokenize()
See also
EXSLT website\n\nEXSLTEXSLT is a set of extensions to XSLT. There are a number of modules; those that are supported by Firefox are listed below:EXSLT modulesTo use an EXSLT function, you need to declare the namespace the function is in, and then use the appropriate prefix when calling the function. For example, to use the regular expressions package:
xml<xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:regexp="http://exslt.org/regular-expressions">
  <xsl:template match="/">
    …
    <xsl:value-of select="regexp:replace(/root/@value, 'before', 'gi', 'AFTER')"/>
    …
  </xsl:template>

</xsl:stylesheet>
CommonThe EXSLT Common package provides basic functions that expand upon the capabilities of XSLT. The namespace for the Common package is http://exslt.org/common.
Functions

exsl:node-set()
exsl:object-type()
MathThe EXSLT Math package provides functions for working with numeric values and comparing nodes. The namespace for the Math package is http://exslt.org/math.
Functions

math:highest()
math:lowest()
math:max()
math:min()
Regular expressionsThe EXSLT Regular Expressions package provides functions that allow testing, matching, and replacing text using JavaScript style regular expressions.
The EXSLT Regular Expressions namespace is http://exslt.org/regular-expressions.
Functions

regexp:match()
regexp:replace()
regexp:test()
SetsThe EXSLT Sets package offers functions that let you perform set manipulation. The namespace for these functions is http://exslt.org/sets.
Functions

set:difference()
set:distinct()
set:intersection()
set:has-same-node()
set:leading()
set:trailing()
StringsThe EXSLT Strings package provides functions that allow the manipulation of strings. The namespace for the Strings package is http://exslt.org/strings.
Functions

str:concat()
str:split()
str:tokenize()
See also
EXSLT website
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 8, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nEXSLTEXSLT is a set of extensions to XSLT. There are a number of modules; those that are supported by Firefox are listed below:EXSLT modulesTo use an EXSLT function, you need to declare the namespace the function is in, and then use the appropriate prefix when calling the function. For example, to use the regular expressions package:
xml<xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:regexp="http://exslt.org/regular-expressions">
  <xsl:template match="/">
    …
    <xsl:value-of select="regexp:replace(/root/@value, 'before', 'gi', 'AFTER')"/>
    …
  </xsl:template>

</xsl:stylesheet>
CommonThe EXSLT Common package provides basic functions that expand upon the capabilities of XSLT. The namespace for the Common package is http://exslt.org/common.
Functions

exsl:node-set()
exsl:object-type()
MathThe EXSLT Math package provides functions for working with numeric values and comparing nodes. The namespace for the Math package is http://exslt.org/math.
Functions

math:highest()
math:lowest()
math:max()
math:min()
Regular expressionsThe EXSLT Regular Expressions package provides functions that allow testing, matching, and replacing text using JavaScript style regular expressions.
The EXSLT Regular Expressions namespace is http://exslt.org/regular-expressions.
Functions

regexp:match()
regexp:replace()
regexp:test()
SetsThe EXSLT Sets package offers functions that let you perform set manipulation. The namespace for these functions is http://exslt.org/sets.
Functions

set:difference()
set:distinct()
set:intersection()
set:has-same-node()
set:leading()
set:trailing()
StringsThe EXSLT Strings package provides functions that allow the manipulation of strings. The namespace for the Strings package is http://exslt.org/strings.
Functions

str:concat()
str:split()
str:tokenize()
See also
EXSLT website
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 8, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

Guides
HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

Guides
HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

Guides
HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

Guides
HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

Guides
HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

Guides
HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

Guides
HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

Guides
HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

Guides
HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\n\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) ist der grundlegendste Baustein des Webs. Es definiert die Bedeutung und Struktur von Webinhalten. Neben HTML werden in der Regel andere Technologien verwendet, um das Erscheinungsbild/Präsentation einer Webseite zu beschreiben (CSS) oder die Funktionalität/Verhalten (JavaScript).
"Hypertext" bezieht sich auf Links, die Webseiten miteinander verbinden, entweder innerhalb einer einzigen Website oder zwischen Websites. Links sind ein grundlegender Aspekt des Webs. Indem Sie Inhalte ins Internet hochladen und mit von anderen erstellten Seiten verlinken, werden Sie ein aktiver Teilnehmer des World Wide Web.
HTML verwendet "Markup", um Text, Bilder und andere Inhalte für die Anzeige in einem Webbrowser zu annotieren. HTML-Markup umfasst spezielle "Elemente" wie <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> und viele andere.
Ein HTML-Element wird durch "Tags" von anderem Text in einem Dokument abgegrenzt, die aus dem Elementnamen bestehen, umgeben von < und >. Der Name eines Elements innerhalb eines Tags ist nicht case-sensitiv. Das bedeutet, er kann in Großbuchstaben, Kleinbuchstaben oder einer Mischung geschrieben werden. Zum Beispiel kann das <title>-Tag als <Title>, <TITLE> oder in irgendeiner anderen Weise geschrieben werden. Die Konvention und empfohlene Praxis ist jedoch, Tags in Kleinbuchstaben zu schreiben.
Die unten stehenden Artikel können Ihnen helfen, mehr über HTML zu lernen.Tutorials für Anfänger
Ihre erste Website: Erstellen der Inhalte

Dieser Artikel bietet eine kurze Einführung in das, was HTML ist und wie man es verwendet, und richtet sich an Personen, die völlig neu in der Webentwicklung sind.

Inhalte mit HTML strukturieren

Unser Leitfaden zur Webentwicklung im HTML-Modul vermittelt alle HTML-Grundlagen von Grund auf.

Leitfäden
HTML-Formulare

Formulare sind ein sehr wichtiger Bestandteil des Webs - sie bieten viel der Funktionalität, die Sie für die Interaktion mit Websites benötigen, z. B. Registrierung und Anmeldung, Feedback senden, Produkte kaufen und mehr. Dieses Modul gibt Ihnen eine Einführung in die Erstellung der clientseitigen/front-end Teile von Formularen.

CORS-fähiges Bild

Das Attribut crossorigin ermöglicht es zusammen mit einem geeigneten CORS-Header, dass Bilder, die durch das <img>-Element definiert sind, von fremden Ursprüngen geladen und in einem <canvas>-Element verwendet werden können, als ob sie vom aktuellen Ursprung geladen würden.

CORS-Einstellungen für Attribute

Einige HTML-Elemente, die Unterstützung für CORS bieten, wie <img> oder <video>, haben ein crossorigin-Attribut (crossOrigin-Eigenschaft), das Ihnen erlaubt, die CORS-Anfragen für die abgerufenen Daten des Elements zu konfigurieren.

Inhalte mit rel="preload" vorladen

Der preload-Wert des rel-Attributs des <link>-Elements ermöglicht es Ihnen, deklarative Abrufanforderungen in Ihr HTML-<head> zu schreiben. Dabei geben Sie Ressourcen an, die Ihre Seiten sehr bald nach dem Laden benötigen und die Sie daher frühzeitig im Lebenszyklus eines Seitenladevorgangs vorladen möchten, bevor der Hauptbrowser-Rendering-Mechanismus einsetzt. Dies stellt sicher, dass sie früher verfügbar gemacht und die erste Darstellung der Seite weniger wahrscheinlich blockiert wird, was zu Leistungsverbesserungen führt. Dieser Artikel bietet einen grundlegenden Leitfaden dazu, wie preload funktioniert.

Responsive Bilder

In diesem Artikel werden wir das Konzept der responsiven Bilder erlernen - Bilder, die gut auf Geräten mit stark unterschiedlichen Bildschirmgrößen, Auflösungen und anderen ähnlichen Merkmalen funktionieren - und sehen, welche Werkzeuge HTML bietet, um sie zu implementieren. Dies hilft, die Leistung auf verschiedenen Geräten zu verbessern.

Referenz
HTML-Referenz

HTML besteht aus Elementen, von denen jedes durch eine Anzahl von Attributen modifiziert werden kann. HTML-Dokumente sind durch Links miteinander verbunden.

HTML-Element-Referenz

Durchsuchen Sie eine Liste aller HTML-Elemente.

HTML-Attribut-Referenz

Elemente in HTML haben Attribute. Diese sind zusätzliche Werte, die die Elemente konfigurieren oder deren Verhalten auf verschiedene Arten anpassen.

Globale Attribute

Globale Attribute können auf alle HTML-Elemente angewendet werden, selbst auf die, die nicht im Standard spezifiziert sind. Dies bedeutet, dass alle nicht standardisierten Elemente trotzdem diese Attribute erlauben müssen, auch wenn diese Elemente das Dokument HTML5-nichtkonform machen.

Inline-Level-Elemente und Block-Level-Elemente

HTML-Elemente sind in der Regel "Inline-Level"- oder "Block-Level"-Elemente. Ein Inline-Level-Element nimmt nur den Platz ein, der durch die Tags definiert wird, die es umgeben. Ein Block-Level-Element nimmt den gesamten Platz seines übergeordneten Elements (Containers) ein und bildet so eine "Blockbox".

HTML-Kommentare

HTML-Kommentare werden verwendet, um erklärende Anmerkungen zum Markup hinzuzufügen oder zu verhindern, dass der Browser bestimmte Teile des Dokuments interpretiert.

Leitfaden zu Medientypen und -formaten im Web

Die <audio>- und <video>-Elemente ermöglichen es Ihnen, Audio- und Videomedien nativ innerhalb Ihrer Inhalte abzuspielen, ohne dass eine externe Softwareunterstützung erforderlich ist.

HTML-Inhaltskategorien

HTML besteht aus verschiedenen Arten von Inhalten, die jeweils in bestimmten Kontexten verwendet werden dürfen und in anderen nicht. Ebenso hat jeder Kontext eine Reihe von anderen Inhaltskategorien, die er enthalten kann, und Elemente, die darin verwendet werden dürfen oder nicht. Dies ist ein Leitfaden zu diesen Kategorien.

Quirks-Modus und Standardsmodus

Historische Informationen über den Quirks-Modus und den Standardsmodus.

Verwandte Themen
Farbe auf HTML-Elemente mit CSS anwenden

Dieser Artikel behandelt die meisten Methoden, mit denen Sie CSS verwenden, um Farbe zu HTML-Inhalten hinzuzufügen, und listet auf, welche Teile von HTML-Dokumenten farbig gestaltet werden können und welche CSS-Eigenschaften dabei verwendet werden.\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) ist der grundlegendste Baustein des Webs. Es definiert die Bedeutung und Struktur von Webinhalten. Neben HTML werden in der Regel andere Technologien verwendet, um das Erscheinungsbild/Präsentation einer Webseite zu beschreiben (CSS) oder die Funktionalität/Verhalten (JavaScript).
"Hypertext" bezieht sich auf Links, die Webseiten miteinander verbinden, entweder innerhalb einer einzigen Website oder zwischen Websites. Links sind ein grundlegender Aspekt des Webs. Indem Sie Inhalte ins Internet hochladen und mit von anderen erstellten Seiten verlinken, werden Sie ein aktiver Teilnehmer des World Wide Web.
HTML verwendet "Markup", um Text, Bilder und andere Inhalte für die Anzeige in einem Webbrowser zu annotieren. HTML-Markup umfasst spezielle "Elemente" wie <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> und viele andere.
Ein HTML-Element wird durch "Tags" von anderem Text in einem Dokument abgegrenzt, die aus dem Elementnamen bestehen, umgeben von < und >. Der Name eines Elements innerhalb eines Tags ist nicht case-sensitiv. Das bedeutet, er kann in Großbuchstaben, Kleinbuchstaben oder einer Mischung geschrieben werden. Zum Beispiel kann das <title>-Tag als <Title>, <TITLE> oder in irgendeiner anderen Weise geschrieben werden. Die Konvention und empfohlene Praxis ist jedoch, Tags in Kleinbuchstaben zu schreiben.
Die unten stehenden Artikel können Ihnen helfen, mehr über HTML zu lernen.Tutorials für Anfänger
Ihre erste Website: Erstellen der Inhalte

Dieser Artikel bietet eine kurze Einführung in das, was HTML ist und wie man es verwendet, und richtet sich an Personen, die völlig neu in der Webentwicklung sind.

Inhalte mit HTML strukturieren

Unser Leitfaden zur Webentwicklung im HTML-Modul vermittelt alle HTML-Grundlagen von Grund auf.

Leitfäden
HTML-Formulare

Formulare sind ein sehr wichtiger Bestandteil des Webs - sie bieten viel der Funktionalität, die Sie für die Interaktion mit Websites benötigen, z. B. Registrierung und Anmeldung, Feedback senden, Produkte kaufen und mehr. Dieses Modul gibt Ihnen eine Einführung in die Erstellung der clientseitigen/front-end Teile von Formularen.

CORS-fähiges Bild

Das Attribut crossorigin ermöglicht es zusammen mit einem geeigneten CORS-Header, dass Bilder, die durch das <img>-Element definiert sind, von fremden Ursprüngen geladen und in einem <canvas>-Element verwendet werden können, als ob sie vom aktuellen Ursprung geladen würden.

CORS-Einstellungen für Attribute

Einige HTML-Elemente, die Unterstützung für CORS bieten, wie <img> oder <video>, haben ein crossorigin-Attribut (crossOrigin-Eigenschaft), das Ihnen erlaubt, die CORS-Anfragen für die abgerufenen Daten des Elements zu konfigurieren.

Inhalte mit rel="preload" vorladen

Der preload-Wert des rel-Attributs des <link>-Elements ermöglicht es Ihnen, deklarative Abrufanforderungen in Ihr HTML-<head> zu schreiben. Dabei geben Sie Ressourcen an, die Ihre Seiten sehr bald nach dem Laden benötigen und die Sie daher frühzeitig im Lebenszyklus eines Seitenladevorgangs vorladen möchten, bevor der Hauptbrowser-Rendering-Mechanismus einsetzt. Dies stellt sicher, dass sie früher verfügbar gemacht und die erste Darstellung der Seite weniger wahrscheinlich blockiert wird, was zu Leistungsverbesserungen führt. Dieser Artikel bietet einen grundlegenden Leitfaden dazu, wie preload funktioniert.

Responsive Bilder

In diesem Artikel werden wir das Konzept der responsiven Bilder erlernen - Bilder, die gut auf Geräten mit stark unterschiedlichen Bildschirmgrößen, Auflösungen und anderen ähnlichen Merkmalen funktionieren - und sehen, welche Werkzeuge HTML bietet, um sie zu implementieren. Dies hilft, die Leistung auf verschiedenen Geräten zu verbessern.

Referenz
HTML-Referenz

HTML besteht aus Elementen, von denen jedes durch eine Anzahl von Attributen modifiziert werden kann. HTML-Dokumente sind durch Links miteinander verbunden.

HTML-Element-Referenz

Durchsuchen Sie eine Liste aller HTML-Elemente.

HTML-Attribut-Referenz

Elemente in HTML haben Attribute. Diese sind zusätzliche Werte, die die Elemente konfigurieren oder deren Verhalten auf verschiedene Arten anpassen.

Globale Attribute

Globale Attribute können auf alle HTML-Elemente angewendet werden, selbst auf die, die nicht im Standard spezifiziert sind. Dies bedeutet, dass alle nicht standardisierten Elemente trotzdem diese Attribute erlauben müssen, auch wenn diese Elemente das Dokument HTML5-nichtkonform machen.

Inline-Level-Elemente und Block-Level-Elemente

HTML-Elemente sind in der Regel "Inline-Level"- oder "Block-Level"-Elemente. Ein Inline-Level-Element nimmt nur den Platz ein, der durch die Tags definiert wird, die es umgeben. Ein Block-Level-Element nimmt den gesamten Platz seines übergeordneten Elements (Containers) ein und bildet so eine "Blockbox".

HTML-Kommentare

HTML-Kommentare werden verwendet, um erklärende Anmerkungen zum Markup hinzuzufügen oder zu verhindern, dass der Browser bestimmte Teile des Dokuments interpretiert.

Leitfaden zu Medientypen und -formaten im Web

Die <audio>- und <video>-Elemente ermöglichen es Ihnen, Audio- und Videomedien nativ innerhalb Ihrer Inhalte abzuspielen, ohne dass eine externe Softwareunterstützung erforderlich ist.

HTML-Inhaltskategorien

HTML besteht aus verschiedenen Arten von Inhalten, die jeweils in bestimmten Kontexten verwendet werden dürfen und in anderen nicht. Ebenso hat jeder Kontext eine Reihe von anderen Inhaltskategorien, die er enthalten kann, und Elemente, die darin verwendet werden dürfen oder nicht. Dies ist ein Leitfaden zu diesen Kategorien.

Quirks-Modus und Standardsmodus

Historische Informationen über den Quirks-Modus und den Standardsmodus.

Verwandte Themen
Farbe auf HTML-Elemente mit CSS anwenden

Dieser Artikel behandelt die meisten Methoden, mit denen Sie CSS verwenden, um Farbe zu HTML-Inhalten hinzuzufügen, und listet auf, welche Teile von HTML-Dokumenten farbig gestaltet werden können und welche CSS-Eigenschaften dabei verwendet werden.

MDN-Feedback-BoxWar diese Übersetzung hilfreich?JaNeinDiese Seite wurde automatisch aus dem Englischen übersetzt.Übersetzung auf GitHub anzeigen • Fehler mit dieser Übersetzung melden\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) ist der grundlegendste Baustein des Webs. Es definiert die Bedeutung und Struktur von Webinhalten. Neben HTML werden in der Regel andere Technologien verwendet, um das Erscheinungsbild/Präsentation einer Webseite zu beschreiben (CSS) oder die Funktionalität/Verhalten (JavaScript).
"Hypertext" bezieht sich auf Links, die Webseiten miteinander verbinden, entweder innerhalb einer einzigen Website oder zwischen Websites. Links sind ein grundlegender Aspekt des Webs. Indem Sie Inhalte ins Internet hochladen und mit von anderen erstellten Seiten verlinken, werden Sie ein aktiver Teilnehmer des World Wide Web.
HTML verwendet "Markup", um Text, Bilder und andere Inhalte für die Anzeige in einem Webbrowser zu annotieren. HTML-Markup umfasst spezielle "Elemente" wie <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> und viele andere.
Ein HTML-Element wird durch "Tags" von anderem Text in einem Dokument abgegrenzt, die aus dem Elementnamen bestehen, umgeben von < und >. Der Name eines Elements innerhalb eines Tags ist nicht case-sensitiv. Das bedeutet, er kann in Großbuchstaben, Kleinbuchstaben oder einer Mischung geschrieben werden. Zum Beispiel kann das <title>-Tag als <Title>, <TITLE> oder in irgendeiner anderen Weise geschrieben werden. Die Konvention und empfohlene Praxis ist jedoch, Tags in Kleinbuchstaben zu schreiben.
Die unten stehenden Artikel können Ihnen helfen, mehr über HTML zu lernen.Tutorials für Anfänger
Ihre erste Website: Erstellen der Inhalte

Dieser Artikel bietet eine kurze Einführung in das, was HTML ist und wie man es verwendet, und richtet sich an Personen, die völlig neu in der Webentwicklung sind.

Inhalte mit HTML strukturieren

Unser Leitfaden zur Webentwicklung im HTML-Modul vermittelt alle HTML-Grundlagen von Grund auf.

Leitfäden
HTML-Formulare

Formulare sind ein sehr wichtiger Bestandteil des Webs - sie bieten viel der Funktionalität, die Sie für die Interaktion mit Websites benötigen, z. B. Registrierung und Anmeldung, Feedback senden, Produkte kaufen und mehr. Dieses Modul gibt Ihnen eine Einführung in die Erstellung der clientseitigen/front-end Teile von Formularen.

CORS-fähiges Bild

Das Attribut crossorigin ermöglicht es zusammen mit einem geeigneten CORS-Header, dass Bilder, die durch das <img>-Element definiert sind, von fremden Ursprüngen geladen und in einem <canvas>-Element verwendet werden können, als ob sie vom aktuellen Ursprung geladen würden.

CORS-Einstellungen für Attribute

Einige HTML-Elemente, die Unterstützung für CORS bieten, wie <img> oder <video>, haben ein crossorigin-Attribut (crossOrigin-Eigenschaft), das Ihnen erlaubt, die CORS-Anfragen für die abgerufenen Daten des Elements zu konfigurieren.

Inhalte mit rel="preload" vorladen

Der preload-Wert des rel-Attributs des <link>-Elements ermöglicht es Ihnen, deklarative Abrufanforderungen in Ihr HTML-<head> zu schreiben. Dabei geben Sie Ressourcen an, die Ihre Seiten sehr bald nach dem Laden benötigen und die Sie daher frühzeitig im Lebenszyklus eines Seitenladevorgangs vorladen möchten, bevor der Hauptbrowser-Rendering-Mechanismus einsetzt. Dies stellt sicher, dass sie früher verfügbar gemacht und die erste Darstellung der Seite weniger wahrscheinlich blockiert wird, was zu Leistungsverbesserungen führt. Dieser Artikel bietet einen grundlegenden Leitfaden dazu, wie preload funktioniert.

Responsive Bilder

In diesem Artikel werden wir das Konzept der responsiven Bilder erlernen - Bilder, die gut auf Geräten mit stark unterschiedlichen Bildschirmgrößen, Auflösungen und anderen ähnlichen Merkmalen funktionieren - und sehen, welche Werkzeuge HTML bietet, um sie zu implementieren. Dies hilft, die Leistung auf verschiedenen Geräten zu verbessern.

Referenz
HTML-Referenz

HTML besteht aus Elementen, von denen jedes durch eine Anzahl von Attributen modifiziert werden kann. HTML-Dokumente sind durch Links miteinander verbunden.

HTML-Element-Referenz

Durchsuchen Sie eine Liste aller HTML-Elemente.

HTML-Attribut-Referenz

Elemente in HTML haben Attribute. Diese sind zusätzliche Werte, die die Elemente konfigurieren oder deren Verhalten auf verschiedene Arten anpassen.

Globale Attribute

Globale Attribute können auf alle HTML-Elemente angewendet werden, selbst auf die, die nicht im Standard spezifiziert sind. Dies bedeutet, dass alle nicht standardisierten Elemente trotzdem diese Attribute erlauben müssen, auch wenn diese Elemente das Dokument HTML5-nichtkonform machen.

Inline-Level-Elemente und Block-Level-Elemente

HTML-Elemente sind in der Regel "Inline-Level"- oder "Block-Level"-Elemente. Ein Inline-Level-Element nimmt nur den Platz ein, der durch die Tags definiert wird, die es umgeben. Ein Block-Level-Element nimmt den gesamten Platz seines übergeordneten Elements (Containers) ein und bildet so eine "Blockbox".

HTML-Kommentare

HTML-Kommentare werden verwendet, um erklärende Anmerkungen zum Markup hinzuzufügen oder zu verhindern, dass der Browser bestimmte Teile des Dokuments interpretiert.

Leitfaden zu Medientypen und -formaten im Web

Die <audio>- und <video>-Elemente ermöglichen es Ihnen, Audio- und Videomedien nativ innerhalb Ihrer Inhalte abzuspielen, ohne dass eine externe Softwareunterstützung erforderlich ist.

HTML-Inhaltskategorien

HTML besteht aus verschiedenen Arten von Inhalten, die jeweils in bestimmten Kontexten verwendet werden dürfen und in anderen nicht. Ebenso hat jeder Kontext eine Reihe von anderen Inhaltskategorien, die er enthalten kann, und Elemente, die darin verwendet werden dürfen oder nicht. Dies ist ein Leitfaden zu diesen Kategorien.

Quirks-Modus und Standardsmodus

Historische Informationen über den Quirks-Modus und den Standardsmodus.

Verwandte Themen
Farbe auf HTML-Elemente mit CSS anwenden

Dieser Artikel behandelt die meisten Methoden, mit denen Sie CSS verwenden, um Farbe zu HTML-Inhalten hinzuzufügen, und listet auf, welche Teile von HTML-Dokumenten farbig gestaltet werden können und welche CSS-Eigenschaften dabei verwendet werden.

MDN-Feedback-BoxWar diese Übersetzung hilfreich?JaNeinDiese Seite wurde automatisch aus dem Englischen übersetzt.Übersetzung auf GitHub anzeigen • Fehler mit dieser Übersetzung melden\n\n\n\nHTML: Lenguaje de etiquetas de hipertextoHTML (Lenguaje de Marcas de Hipertexto, del inglés HyperText Markup Language) es el componente más básico de la Web. Define el significado y la estructura del contenido web. Además de HTML, generalmente se utilizan otras tecnologías para describir la apariencia/presentación de una página web (CSS) o la funcionalidad/comportamiento (JavaScript).
"Hipertexto" hace referencia a los enlaces que conectan páginas web entre sí, ya sea dentro de un único sitio web o entre sitios web. Los enlaces son un aspecto fundamental de la Web. Al subir contenido a Internet y vincularlo a las páginas creadas por otras personas, te conviertes en un participante activo en la «World Wide Web» (Red Informática Mundial).
HTML utiliza "marcas" para etiquetar texto, imágenes y otro contenido para mostrarlo en un navegador Web. Las marcas HTML incluyen "elementos" especiales como <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <output>, <progress>, <video>, <ul>, <ol>, <li> y muchos otros.
Un elemento HTML se distingue de otro texto en un documento mediante "etiquetas", que consisten en el nombre del elemento rodeado por "<" y ">". El nombre de un elemento dentro de una etiqueta no distingue entre mayúsculas y minúsculas. Es decir, se puede escribir en mayúsculas, minúsculas o una mezcla. Por ejemplo, la etiqueta <title> se puede escribir como <Title>, <TITLE> o de cualquier otra forma.
Los siguientes artículos pueden ayudarte a obtener más información sobre HTML.Recursos clave
Introducción a HTML

Si eres nuevo en el desarrollo Web, asegúrate de leer el artículo Conceptos básicos de HTML para aprender qué es HTML y cómo usarlo.

Tutoriales HTML

Para ver artículos sobre cómo usar HTML, así como tutoriales y ejemplos completos, consulte el Área de aprendizaje de HTML.

Referencia HTML

En nuestra extensa sección referencia HTML encontrarás los detalles sobre cada elemento y atributo en HTML.




¿Quieres transformarte en un desarrollador de la interfaz de usuario web?
Hemos elaborado un curso que incluye toda la información esencial que necesitas para trabajar hacia tu objetivo.
Empieza aquí
Tutoriales para principiantesEl Área de aprendizaje de HTML incluye varios módulos que enseñan HTML desde cero, sin necesidad de conocimientos previos.

Introducción a HTML

Este módulo prepara el escenario para que te acostumbres a conceptos y sintaxis importantes, tal como la aplicación de HTML al texto, cómo crear hipervínculos y cómo utilizar HTML para estructurar una página web.

Multimedia e inserción

Este módulo explora cómo usar HTML para incluir multimedia en tus páginas web, incluidas las diferentes formas en que se pueden incluir imágenes y cómo insertar video, audio e incluso otras páginas web completas.

tablas HTML

Representar datos tabulares en una página web de una manera comprensible y accesible puede ser un desafío. Este módulo cubre el marcado básico de tablas, junto con características más complejas como la implementación de subtítulos y resúmenes.

Formularios HTML

Los formularios son una parte muy importante de la Web — proporcionan gran parte de la funcionalidad que necesitas para interactuar con sitios web, p. ej. registrarte e iniciar sesión, enviar comentarios, comprar productos y más. Este módulo te ayuda a comenzar a crear las partes de formularios del lado del cliente/Interfaz de usuario.

Utilizar HTML para resolver problemas comunes

Proporciona enlaces a secciones de contenido que explican cómo usar HTML para resolver muchos problemas comunes al crear una página web: tratar con títulos, agregar imágenes o videos, enfatizar el contenido, crear un formulario básico, etc.

Temas avanzados
Imagen compatible con CORS

El atributo crossorigin, en combinación con un encabezado CORS apropiado, permite imágenes definidas por el elemento <img> que se cargarán desde orígenes externos y se utilizarán en un elemento <canvas> como si se estuvieran cargando desde el origen actual.

Atributos de configuración de CORS

Algunos elementos HTML que brindan soporte para CORS, como <img> o <video>, tienen un atributo crossorigin (propiedad crossOrigin), que te permite configurar las solicitudes CORS para los datos extraídos del elemento.

Precarga de contenido con rel='preload'

El valor de preload del atributo <link> del elemento rel te permite escribir solicitudes de recuperación declarativas en tu HTML <head>, que especifican los recursos que tus páginas necesitarán muy pronto después de la carga, que por lo tanto deseas comenzar a precargar al principio del ciclo de vida de la carga de una página, antes de la representación principal del navegador la maquinaria entra en acción. Esto asegura que estén disponibles antes y es menos probable que bloqueen el primer procesamiento de la página, lo que lleva a mejoras de rendimiento. Este artículo proporciona una guía básica sobre cómo funciona preload.

Referencias
Referencia HTML

HTML consta de elementos, cada uno de los cuales se puede modificar por medio de algunos atributos. Los documentos HTML están conectados entre sí mediante enlaces.

Referencia del elemento HTML

Examina una lista de todos los elementos HTML.

Referencia de atributos HTML

Los elementos en HTML tienen atributos. Se trata de valores adicionales que configuran los elementos o ajustan su comportamiento de diversas formas.

Atributos globales

Los atributos globales se pueden especificar en todos los elementos HTML, incluso aquellos no especificados en el estándar. Esto significa que cualquier elemento no estándar debe permitir esos atributos, aunque esos elementos hagan que el documento no sea compatible con HTML5.

Elementos en línea y Elementos a nivel de bloque

Los elementos HTML suelen ser elementos "en línea" o "a nivel de bloque". Un elemento en línea ocupa solo el espacio delimitado por las etiquetas que lo definen. Un elemento a nivel de bloque ocupa todo el espacio de su elemento padre (contenedor), creando así un "bloque".

Tipos de enlaces

En HTML, se pueden usar varios tipos de enlaces para establecer y definir la relación entre dos documentos. Los elementos de enlace en los que se pueden configurar tipos incluyen <a>, <area> y <link>.

Guía de tipos y formatos de medios en la web

Los elementos <audio> y <video> te permiten reproducir audio y video de forma nativa dentro de tu contenido sin la necesidad de soporte de software externo.

Categorías de contenido HTML

HTML se compone de varios tipos de contenido, cada uno de los cuales se puede usar en ciertos contextos y no está permitido en otros. De manera similar, cada uno tiene un conjunto de otras categorías de contenido que pueden recibir y elementos que pueden o no se pueden usar en ellos. Esta es una guía para estas categorías.

Modo Quirks y modo estándar

Información histórica sobre el modo peculiar («Quirks» en inglés) y el modo estándar.

Temas relacionados
Aplicando color a elementos HTML mediante CSS

Este artículo cubre la mayoría de las formas en que usas CSS para agregar color al contenido HTML, enumerando qué partes de los documentos HTML se pueden colorear y qué propiedades CSS usar al hacerlo. Incluye ejemplos, enlaces a herramientas de creación de paletas de colores y más.\n\nHTML: Lenguaje de etiquetas de hipertextoHTML (Lenguaje de Marcas de Hipertexto, del inglés HyperText Markup Language) es el componente más básico de la Web. Define el significado y la estructura del contenido web. Además de HTML, generalmente se utilizan otras tecnologías para describir la apariencia/presentación de una página web (CSS) o la funcionalidad/comportamiento (JavaScript).
"Hipertexto" hace referencia a los enlaces que conectan páginas web entre sí, ya sea dentro de un único sitio web o entre sitios web. Los enlaces son un aspecto fundamental de la Web. Al subir contenido a Internet y vincularlo a las páginas creadas por otras personas, te conviertes en un participante activo en la «World Wide Web» (Red Informática Mundial).
HTML utiliza "marcas" para etiquetar texto, imágenes y otro contenido para mostrarlo en un navegador Web. Las marcas HTML incluyen "elementos" especiales como <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <output>, <progress>, <video>, <ul>, <ol>, <li> y muchos otros.
Un elemento HTML se distingue de otro texto en un documento mediante "etiquetas", que consisten en el nombre del elemento rodeado por "<" y ">". El nombre de un elemento dentro de una etiqueta no distingue entre mayúsculas y minúsculas. Es decir, se puede escribir en mayúsculas, minúsculas o una mezcla. Por ejemplo, la etiqueta <title> se puede escribir como <Title>, <TITLE> o de cualquier otra forma.
Los siguientes artículos pueden ayudarte a obtener más información sobre HTML.Recursos clave
Introducción a HTML

Si eres nuevo en el desarrollo Web, asegúrate de leer el artículo Conceptos básicos de HTML para aprender qué es HTML y cómo usarlo.

Tutoriales HTML

Para ver artículos sobre cómo usar HTML, así como tutoriales y ejemplos completos, consulte el Área de aprendizaje de HTML.

Referencia HTML

En nuestra extensa sección referencia HTML encontrarás los detalles sobre cada elemento y atributo en HTML.




¿Quieres transformarte en un desarrollador de la interfaz de usuario web?
Hemos elaborado un curso que incluye toda la información esencial que necesitas para trabajar hacia tu objetivo.
Empieza aquí
Tutoriales para principiantesEl Área de aprendizaje de HTML incluye varios módulos que enseñan HTML desde cero, sin necesidad de conocimientos previos.

Introducción a HTML

Este módulo prepara el escenario para que te acostumbres a conceptos y sintaxis importantes, tal como la aplicación de HTML al texto, cómo crear hipervínculos y cómo utilizar HTML para estructurar una página web.

Multimedia e inserción

Este módulo explora cómo usar HTML para incluir multimedia en tus páginas web, incluidas las diferentes formas en que se pueden incluir imágenes y cómo insertar video, audio e incluso otras páginas web completas.

tablas HTML

Representar datos tabulares en una página web de una manera comprensible y accesible puede ser un desafío. Este módulo cubre el marcado básico de tablas, junto con características más complejas como la implementación de subtítulos y resúmenes.

Formularios HTML

Los formularios son una parte muy importante de la Web — proporcionan gran parte de la funcionalidad que necesitas para interactuar con sitios web, p. ej. registrarte e iniciar sesión, enviar comentarios, comprar productos y más. Este módulo te ayuda a comenzar a crear las partes de formularios del lado del cliente/Interfaz de usuario.

Utilizar HTML para resolver problemas comunes

Proporciona enlaces a secciones de contenido que explican cómo usar HTML para resolver muchos problemas comunes al crear una página web: tratar con títulos, agregar imágenes o videos, enfatizar el contenido, crear un formulario básico, etc.

Temas avanzados
Imagen compatible con CORS

El atributo crossorigin, en combinación con un encabezado CORS apropiado, permite imágenes definidas por el elemento <img> que se cargarán desde orígenes externos y se utilizarán en un elemento <canvas> como si se estuvieran cargando desde el origen actual.

Atributos de configuración de CORS

Algunos elementos HTML que brindan soporte para CORS, como <img> o <video>, tienen un atributo crossorigin (propiedad crossOrigin), que te permite configurar las solicitudes CORS para los datos extraídos del elemento.

Precarga de contenido con rel='preload'

El valor de preload del atributo <link> del elemento rel te permite escribir solicitudes de recuperación declarativas en tu HTML <head>, que especifican los recursos que tus páginas necesitarán muy pronto después de la carga, que por lo tanto deseas comenzar a precargar al principio del ciclo de vida de la carga de una página, antes de la representación principal del navegador la maquinaria entra en acción. Esto asegura que estén disponibles antes y es menos probable que bloqueen el primer procesamiento de la página, lo que lleva a mejoras de rendimiento. Este artículo proporciona una guía básica sobre cómo funciona preload.

Referencias
Referencia HTML

HTML consta de elementos, cada uno de los cuales se puede modificar por medio de algunos atributos. Los documentos HTML están conectados entre sí mediante enlaces.

Referencia del elemento HTML

Examina una lista de todos los elementos HTML.

Referencia de atributos HTML

Los elementos en HTML tienen atributos. Se trata de valores adicionales que configuran los elementos o ajustan su comportamiento de diversas formas.

Atributos globales

Los atributos globales se pueden especificar en todos los elementos HTML, incluso aquellos no especificados en el estándar. Esto significa que cualquier elemento no estándar debe permitir esos atributos, aunque esos elementos hagan que el documento no sea compatible con HTML5.

Elementos en línea y Elementos a nivel de bloque

Los elementos HTML suelen ser elementos "en línea" o "a nivel de bloque". Un elemento en línea ocupa solo el espacio delimitado por las etiquetas que lo definen. Un elemento a nivel de bloque ocupa todo el espacio de su elemento padre (contenedor), creando así un "bloque".

Tipos de enlaces

En HTML, se pueden usar varios tipos de enlaces para establecer y definir la relación entre dos documentos. Los elementos de enlace en los que se pueden configurar tipos incluyen <a>, <area> y <link>.

Guía de tipos y formatos de medios en la web

Los elementos <audio> y <video> te permiten reproducir audio y video de forma nativa dentro de tu contenido sin la necesidad de soporte de software externo.

Categorías de contenido HTML

HTML se compone de varios tipos de contenido, cada uno de los cuales se puede usar en ciertos contextos y no está permitido en otros. De manera similar, cada uno tiene un conjunto de otras categorías de contenido que pueden recibir y elementos que pueden o no se pueden usar en ellos. Esta es una guía para estas categorías.

Modo Quirks y modo estándar

Información histórica sobre el modo peculiar («Quirks» en inglés) y el modo estándar.

Temas relacionados
Aplicando color a elementos HTML mediante CSS

Este artículo cubre la mayoría de las formas en que usas CSS para agregar color al contenido HTML, enumerando qué partes de los documentos HTML se pueden colorear y qué propiedades CSS usar al hacerlo. Incluye ejemplos, enlaces a herramientas de creación de paletas de colores y más.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 11 abr 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nHTML: Lenguaje de etiquetas de hipertextoHTML (Lenguaje de Marcas de Hipertexto, del inglés HyperText Markup Language) es el componente más básico de la Web. Define el significado y la estructura del contenido web. Además de HTML, generalmente se utilizan otras tecnologías para describir la apariencia/presentación de una página web (CSS) o la funcionalidad/comportamiento (JavaScript).
"Hipertexto" hace referencia a los enlaces que conectan páginas web entre sí, ya sea dentro de un único sitio web o entre sitios web. Los enlaces son un aspecto fundamental de la Web. Al subir contenido a Internet y vincularlo a las páginas creadas por otras personas, te conviertes en un participante activo en la «World Wide Web» (Red Informática Mundial).
HTML utiliza "marcas" para etiquetar texto, imágenes y otro contenido para mostrarlo en un navegador Web. Las marcas HTML incluyen "elementos" especiales como <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <output>, <progress>, <video>, <ul>, <ol>, <li> y muchos otros.
Un elemento HTML se distingue de otro texto en un documento mediante "etiquetas", que consisten en el nombre del elemento rodeado por "<" y ">". El nombre de un elemento dentro de una etiqueta no distingue entre mayúsculas y minúsculas. Es decir, se puede escribir en mayúsculas, minúsculas o una mezcla. Por ejemplo, la etiqueta <title> se puede escribir como <Title>, <TITLE> o de cualquier otra forma.
Los siguientes artículos pueden ayudarte a obtener más información sobre HTML.Recursos clave
Introducción a HTML

Si eres nuevo en el desarrollo Web, asegúrate de leer el artículo Conceptos básicos de HTML para aprender qué es HTML y cómo usarlo.

Tutoriales HTML

Para ver artículos sobre cómo usar HTML, así como tutoriales y ejemplos completos, consulte el Área de aprendizaje de HTML.

Referencia HTML

En nuestra extensa sección referencia HTML encontrarás los detalles sobre cada elemento y atributo en HTML.




¿Quieres transformarte en un desarrollador de la interfaz de usuario web?
Hemos elaborado un curso que incluye toda la información esencial que necesitas para trabajar hacia tu objetivo.
Empieza aquí
Tutoriales para principiantesEl Área de aprendizaje de HTML incluye varios módulos que enseñan HTML desde cero, sin necesidad de conocimientos previos.

Introducción a HTML

Este módulo prepara el escenario para que te acostumbres a conceptos y sintaxis importantes, tal como la aplicación de HTML al texto, cómo crear hipervínculos y cómo utilizar HTML para estructurar una página web.

Multimedia e inserción

Este módulo explora cómo usar HTML para incluir multimedia en tus páginas web, incluidas las diferentes formas en que se pueden incluir imágenes y cómo insertar video, audio e incluso otras páginas web completas.

tablas HTML

Representar datos tabulares en una página web de una manera comprensible y accesible puede ser un desafío. Este módulo cubre el marcado básico de tablas, junto con características más complejas como la implementación de subtítulos y resúmenes.

Formularios HTML

Los formularios son una parte muy importante de la Web — proporcionan gran parte de la funcionalidad que necesitas para interactuar con sitios web, p. ej. registrarte e iniciar sesión, enviar comentarios, comprar productos y más. Este módulo te ayuda a comenzar a crear las partes de formularios del lado del cliente/Interfaz de usuario.

Utilizar HTML para resolver problemas comunes

Proporciona enlaces a secciones de contenido que explican cómo usar HTML para resolver muchos problemas comunes al crear una página web: tratar con títulos, agregar imágenes o videos, enfatizar el contenido, crear un formulario básico, etc.

Temas avanzados
Imagen compatible con CORS

El atributo crossorigin, en combinación con un encabezado CORS apropiado, permite imágenes definidas por el elemento <img> que se cargarán desde orígenes externos y se utilizarán en un elemento <canvas> como si se estuvieran cargando desde el origen actual.

Atributos de configuración de CORS

Algunos elementos HTML que brindan soporte para CORS, como <img> o <video>, tienen un atributo crossorigin (propiedad crossOrigin), que te permite configurar las solicitudes CORS para los datos extraídos del elemento.

Precarga de contenido con rel='preload'

El valor de preload del atributo <link> del elemento rel te permite escribir solicitudes de recuperación declarativas en tu HTML <head>, que especifican los recursos que tus páginas necesitarán muy pronto después de la carga, que por lo tanto deseas comenzar a precargar al principio del ciclo de vida de la carga de una página, antes de la representación principal del navegador la maquinaria entra en acción. Esto asegura que estén disponibles antes y es menos probable que bloqueen el primer procesamiento de la página, lo que lleva a mejoras de rendimiento. Este artículo proporciona una guía básica sobre cómo funciona preload.

Referencias
Referencia HTML

HTML consta de elementos, cada uno de los cuales se puede modificar por medio de algunos atributos. Los documentos HTML están conectados entre sí mediante enlaces.

Referencia del elemento HTML

Examina una lista de todos los elementos HTML.

Referencia de atributos HTML

Los elementos en HTML tienen atributos. Se trata de valores adicionales que configuran los elementos o ajustan su comportamiento de diversas formas.

Atributos globales

Los atributos globales se pueden especificar en todos los elementos HTML, incluso aquellos no especificados en el estándar. Esto significa que cualquier elemento no estándar debe permitir esos atributos, aunque esos elementos hagan que el documento no sea compatible con HTML5.

Elementos en línea y Elementos a nivel de bloque

Los elementos HTML suelen ser elementos "en línea" o "a nivel de bloque". Un elemento en línea ocupa solo el espacio delimitado por las etiquetas que lo definen. Un elemento a nivel de bloque ocupa todo el espacio de su elemento padre (contenedor), creando así un "bloque".

Tipos de enlaces

En HTML, se pueden usar varios tipos de enlaces para establecer y definir la relación entre dos documentos. Los elementos de enlace en los que se pueden configurar tipos incluyen <a>, <area> y <link>.

Guía de tipos y formatos de medios en la web

Los elementos <audio> y <video> te permiten reproducir audio y video de forma nativa dentro de tu contenido sin la necesidad de soporte de software externo.

Categorías de contenido HTML

HTML se compone de varios tipos de contenido, cada uno de los cuales se puede usar en ciertos contextos y no está permitido en otros. De manera similar, cada uno tiene un conjunto de otras categorías de contenido que pueden recibir y elementos que pueden o no se pueden usar en ellos. Esta es una guía para estas categorías.

Modo Quirks y modo estándar

Información histórica sobre el modo peculiar («Quirks» en inglés) y el modo estándar.

Temas relacionados
Aplicando color a elementos HTML mediante CSS

Este artículo cubre la mayoría de las formas en que usas CSS para agregar color al contenido HTML, enumerando qué partes de los documentos HTML se pueden colorear y qué propiedades CSS usar al hacerlo. Incluye ejemplos, enlaces a herramientas de creación de paletas de colores y más.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 11 abr 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nHTML (HyperText Markup Language)HTML signifie « HyperText Markup Language » qu'on peut traduire par « langage de balises pour l'hypertexte ». Il est utilisé afin de créer et de représenter le contenu d'une page web et sa structure. D'autres technologies sont utilisées avec HTML pour décrire la présentation d'une page (CSS) et/ou ses fonctionnalités interactives (JavaScript).
L'« hypertexte » désigne les liens qui relient les pages web entre elles, que ce soit au sein d'un même site web ou entre différents sites web. Les liens sont un aspect fondamental du Web. Ce sont eux qui forment cette « toile » (ce mot est traduit par web en anglais). En téléchargeant du contenu sur l'Internet et en le reliant à des pages créées par d'autres personnes, vous devenez un participant actif du World Wide Web.
Le langage HTML utilise des « balises » pour annoter du texte, des images et d'autres contenus afin de les afficher dans un navigateur web. Le balisage HTML comprend des « éléments » spéciaux tels que <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <output>, <progress>, <video>, <ul>, <ol>, <li> et bien d'autres.
En HTML, les balises sont insensibles à la casse et peuvent aussi bien être écrites en minuscules, en majuscules voire avec un mélange des deux. Autrement dit, la balise <title> pourrait très bien être écrite comme <Title>, <TiTle> ou d'une autre façon.
Les articles suivants fournissent des éléments de référence utiles au développement web.Ressources clés
Introduction au HTML

Vous faites vos premiers pas dans le développement web ? Nos articles sur les bases de HTML expliquent ce qu'est HTML et comment l'utiliser.

Tutoriels HTML

Pour plus d'informations sur l'utilisation du HTML, des tutoriels et des exemples complets, vous pouvez consulter notre section Apprendre HTML.

Référence HTML

Dans notre référence exhaustive, vous trouverez le détail de chaque élément et attribut constituant HTML.




Vous cherchez à devenir un développeur web front-end ?
Nous avons élaboré un cours qui comprend toutes les informations essentielles dont vous avez besoin pour atteindre votre objectif.
Commencer
Tutoriels pour les débutantsLa section Apprendre HTML contient plusieurs modules pour vous apprendre à utiliser HTML — sans autre connaissance particulière.

Une introduction à HTML

Dans ce module, on brosse un premier portrait de HTML pour présenter les concepts importants, la syntaxe. On voit comment appliquer HTML sur du texte, comment créer des hyperliens et comment structurer une page web grâce à HTML.

Le multimédia et l'intégration

Dans ce module, on explore comment utiliser HTML pour intégrer des fichiers multimédias dans une page web. Cela couvre les différentes façons d'inclure une image, comment ajouter une vidéo ou un fichier audio voire aussi comment intégrer d'autres pages web.

Les tableaux HTML

Il est parfois compliqué de représenter des données tabulaires de façon compréhensible et lisible sur une page web. Dans ce module, on voit les différentes balises utilisées pour construire des tableaux et certaines fonctionnalités plus complexes comme les légendes et résumés.

Les formulaires HTML

Les formulaires sont cruciaux sur le Web, ils permettent de créer un compte sur un site, de se connecter, d'acheter des produits, d'écrire des commentaires, etc. Dans ce module, on voit comment créer des formulaires pour le navigateur (« côté client »).

Utiliser HTML pour résoudre des problèmes courants

Ce module fournit un ensemble d'articles au sujet des problèmes qu'on rencontre fréquemment lorsqu'on crée une page web : gérer les titres, ajouter des images ou des vidéos, mettre en avant une partie du texte, créer un formulaire, etc.

Sujets avancés
Images avec le contrôle d'accès HTTP

L'attribut crossorigin, associé à un en-tête CORS approprié, permet de charger des images définies par l'élément <img> depuis des origines étrangères et de les utiliser dans un élément <canvas> comme si elles étaient chargées depuis l'origine actuelle.

Attributs de réglage du CORS

Certains éléments HTML qui fournissent un support pour CORS, tels que <img> ou <video>, ont un attribut crossorigin (propriété crossOrigin), qui vous permet de configurer les requêtes CORS pour les données extraites de l'élément.

Précharger du contenu avec rel="preload"

La valeur preload de l'attribut <link> de l'élément rel vous permet d'écrire des requêtes déclaratives de récupération dans votre <head> HTML, en spécifiant les ressources dont vos pages auront besoin très rapidement après le chargement, et que vous souhaitez donc commencer à précharger au début du cycle de vie d'une page, avant que le cycle de rendu du navigateur ne se mette en marche. Cela permet de s'assurer que ces éléments sont disponibles plus tôt et qu'ils risquent moins de bloquer le premier rendu de la page, améliorant ainsi les performances. Cet article fournit un guide de base sur le fonctionnement du preload.

Références
Référence HTML

HTML est un langage décrivant la structure et le contenu sémantique d'un document web. Il est constitué d'éléments, chacun pouvant être paramétré grâce à différents attributs. Les documents HTML sont connectés à d'autres via des liens

Référence des éléments HTML

Cette page liste les différents éléments HTML.

Liste des attributs HTML

Les éléments du langage HTML possèdent des attributs. Il s'agit de valeurs supplémentaires qui configurent les éléments ou ajustent leur comportement de diverses manières.

Attributs universels

Les attributs universels peuvent être spécifiés sur tous les éléments HTML, même ceux qui ne sont pas spécifiés dans la norme. Par exemple, les navigateurs qui prennent en charge HTML5 masquent les contenus marqués comme <toto hidden>…<toto> , bien que <toto> ne soit pas un élément valide HTML.

Éléments en ligne et éléments de bloc

Les éléments HTML sont habituellement des éléments « en ligne » ou des éléments de bloc. Un élément en ligne occupe seulement l'espace associé aux balises. Les éléments de bloc sont une catégorie d'éléments HTML opposés aux éléments en ligne. Leur caractéristique principale réside dans le fait qu'ils sont séparés par un saut de ligne avant et après l'élément. Ce faisant, ils prennent la largeur de leurs conteneurs (créant ainsi un bloc de contenu).

Types de lien

Les différents liens permettent de décrire les relations entre deux documents qui sont reliés entre eux par un élément <a>, <area> ou <link>.

Formats de média audio et vidéo pris en charge par HTML

Les éléments <audio> et <video> permettent d'ajouter des médias audio et vidéo directement dans le navigateur (sans avoir à utiliser des plugins ou programmes tiers).

Types de contenu HTML

HTML s'organise selon différents types de contenu dont chacun peut être autorisé ou non en fonction du contexte. Ces catégories indiquent quels éléments peuvent être contenus ou non dans d'autres éléments. Cet article explique le fonctionnement de ces catégories.

Sujets connexes
Appliquer des couleurs sur des éléments HTML grâce à CSS

Cet article couvre la plupart des façons d'utiliser CSS pour ajouter de la couleur au contenu HTML, en indiquant les parties des documents HTML qui peuvent être colorées et les propriétés CSS à utiliser pour ce faire. Il comprend des exemples, des liens vers des outils de création de palettes, etc.\n\nHTML (HyperText Markup Language)HTML signifie « HyperText Markup Language » qu'on peut traduire par « langage de balises pour l'hypertexte ». Il est utilisé afin de créer et de représenter le contenu d'une page web et sa structure. D'autres technologies sont utilisées avec HTML pour décrire la présentation d'une page (CSS) et/ou ses fonctionnalités interactives (JavaScript).
L'« hypertexte » désigne les liens qui relient les pages web entre elles, que ce soit au sein d'un même site web ou entre différents sites web. Les liens sont un aspect fondamental du Web. Ce sont eux qui forment cette « toile » (ce mot est traduit par web en anglais). En téléchargeant du contenu sur l'Internet et en le reliant à des pages créées par d'autres personnes, vous devenez un participant actif du World Wide Web.
Le langage HTML utilise des « balises » pour annoter du texte, des images et d'autres contenus afin de les afficher dans un navigateur web. Le balisage HTML comprend des « éléments » spéciaux tels que <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <output>, <progress>, <video>, <ul>, <ol>, <li> et bien d'autres.
En HTML, les balises sont insensibles à la casse et peuvent aussi bien être écrites en minuscules, en majuscules voire avec un mélange des deux. Autrement dit, la balise <title> pourrait très bien être écrite comme <Title>, <TiTle> ou d'une autre façon.
Les articles suivants fournissent des éléments de référence utiles au développement web.Ressources clés
Introduction au HTML

Vous faites vos premiers pas dans le développement web ? Nos articles sur les bases de HTML expliquent ce qu'est HTML et comment l'utiliser.

Tutoriels HTML

Pour plus d'informations sur l'utilisation du HTML, des tutoriels et des exemples complets, vous pouvez consulter notre section Apprendre HTML.

Référence HTML

Dans notre référence exhaustive, vous trouverez le détail de chaque élément et attribut constituant HTML.




Vous cherchez à devenir un développeur web front-end ?
Nous avons élaboré un cours qui comprend toutes les informations essentielles dont vous avez besoin pour atteindre votre objectif.
Commencer
Tutoriels pour les débutantsLa section Apprendre HTML contient plusieurs modules pour vous apprendre à utiliser HTML — sans autre connaissance particulière.

Une introduction à HTML

Dans ce module, on brosse un premier portrait de HTML pour présenter les concepts importants, la syntaxe. On voit comment appliquer HTML sur du texte, comment créer des hyperliens et comment structurer une page web grâce à HTML.

Le multimédia et l'intégration

Dans ce module, on explore comment utiliser HTML pour intégrer des fichiers multimédias dans une page web. Cela couvre les différentes façons d'inclure une image, comment ajouter une vidéo ou un fichier audio voire aussi comment intégrer d'autres pages web.

Les tableaux HTML

Il est parfois compliqué de représenter des données tabulaires de façon compréhensible et lisible sur une page web. Dans ce module, on voit les différentes balises utilisées pour construire des tableaux et certaines fonctionnalités plus complexes comme les légendes et résumés.

Les formulaires HTML

Les formulaires sont cruciaux sur le Web, ils permettent de créer un compte sur un site, de se connecter, d'acheter des produits, d'écrire des commentaires, etc. Dans ce module, on voit comment créer des formulaires pour le navigateur (« côté client »).

Utiliser HTML pour résoudre des problèmes courants

Ce module fournit un ensemble d'articles au sujet des problèmes qu'on rencontre fréquemment lorsqu'on crée une page web : gérer les titres, ajouter des images ou des vidéos, mettre en avant une partie du texte, créer un formulaire, etc.

Sujets avancés
Images avec le contrôle d'accès HTTP

L'attribut crossorigin, associé à un en-tête CORS approprié, permet de charger des images définies par l'élément <img> depuis des origines étrangères et de les utiliser dans un élément <canvas> comme si elles étaient chargées depuis l'origine actuelle.

Attributs de réglage du CORS

Certains éléments HTML qui fournissent un support pour CORS, tels que <img> ou <video>, ont un attribut crossorigin (propriété crossOrigin), qui vous permet de configurer les requêtes CORS pour les données extraites de l'élément.

Précharger du contenu avec rel="preload"

La valeur preload de l'attribut <link> de l'élément rel vous permet d'écrire des requêtes déclaratives de récupération dans votre <head> HTML, en spécifiant les ressources dont vos pages auront besoin très rapidement après le chargement, et que vous souhaitez donc commencer à précharger au début du cycle de vie d'une page, avant que le cycle de rendu du navigateur ne se mette en marche. Cela permet de s'assurer que ces éléments sont disponibles plus tôt et qu'ils risquent moins de bloquer le premier rendu de la page, améliorant ainsi les performances. Cet article fournit un guide de base sur le fonctionnement du preload.

Références
Référence HTML

HTML est un langage décrivant la structure et le contenu sémantique d'un document web. Il est constitué d'éléments, chacun pouvant être paramétré grâce à différents attributs. Les documents HTML sont connectés à d'autres via des liens

Référence des éléments HTML

Cette page liste les différents éléments HTML.

Liste des attributs HTML

Les éléments du langage HTML possèdent des attributs. Il s'agit de valeurs supplémentaires qui configurent les éléments ou ajustent leur comportement de diverses manières.

Attributs universels

Les attributs universels peuvent être spécifiés sur tous les éléments HTML, même ceux qui ne sont pas spécifiés dans la norme. Par exemple, les navigateurs qui prennent en charge HTML5 masquent les contenus marqués comme <toto hidden>…<toto> , bien que <toto> ne soit pas un élément valide HTML.

Éléments en ligne et éléments de bloc

Les éléments HTML sont habituellement des éléments « en ligne » ou des éléments de bloc. Un élément en ligne occupe seulement l'espace associé aux balises. Les éléments de bloc sont une catégorie d'éléments HTML opposés aux éléments en ligne. Leur caractéristique principale réside dans le fait qu'ils sont séparés par un saut de ligne avant et après l'élément. Ce faisant, ils prennent la largeur de leurs conteneurs (créant ainsi un bloc de contenu).

Types de lien

Les différents liens permettent de décrire les relations entre deux documents qui sont reliés entre eux par un élément <a>, <area> ou <link>.

Formats de média audio et vidéo pris en charge par HTML

Les éléments <audio> et <video> permettent d'ajouter des médias audio et vidéo directement dans le navigateur (sans avoir à utiliser des plugins ou programmes tiers).

Types de contenu HTML

HTML s'organise selon différents types de contenu dont chacun peut être autorisé ou non en fonction du contexte. Ces catégories indiquent quels éléments peuvent être contenus ou non dans d'autres éléments. Cet article explique le fonctionnement de ces catégories.

Sujets connexes
Appliquer des couleurs sur des éléments HTML grâce à CSS

Cet article couvre la plupart des façons d'utiliser CSS pour ajouter de la couleur au contenu HTML, en indiquant les parties des documents HTML qui peuvent être colorées et les propriétés CSS à utiliser pour ce faire. Il comprend des exemples, des liens vers des outils de création de palettes, etc.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 17 déc. 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nHTML (HyperText Markup Language)HTML signifie « HyperText Markup Language » qu'on peut traduire par « langage de balises pour l'hypertexte ». Il est utilisé afin de créer et de représenter le contenu d'une page web et sa structure. D'autres technologies sont utilisées avec HTML pour décrire la présentation d'une page (CSS) et/ou ses fonctionnalités interactives (JavaScript).
L'« hypertexte » désigne les liens qui relient les pages web entre elles, que ce soit au sein d'un même site web ou entre différents sites web. Les liens sont un aspect fondamental du Web. Ce sont eux qui forment cette « toile » (ce mot est traduit par web en anglais). En téléchargeant du contenu sur l'Internet et en le reliant à des pages créées par d'autres personnes, vous devenez un participant actif du World Wide Web.
Le langage HTML utilise des « balises » pour annoter du texte, des images et d'autres contenus afin de les afficher dans un navigateur web. Le balisage HTML comprend des « éléments » spéciaux tels que <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <output>, <progress>, <video>, <ul>, <ol>, <li> et bien d'autres.
En HTML, les balises sont insensibles à la casse et peuvent aussi bien être écrites en minuscules, en majuscules voire avec un mélange des deux. Autrement dit, la balise <title> pourrait très bien être écrite comme <Title>, <TiTle> ou d'une autre façon.
Les articles suivants fournissent des éléments de référence utiles au développement web.Ressources clés
Introduction au HTML

Vous faites vos premiers pas dans le développement web ? Nos articles sur les bases de HTML expliquent ce qu'est HTML et comment l'utiliser.

Tutoriels HTML

Pour plus d'informations sur l'utilisation du HTML, des tutoriels et des exemples complets, vous pouvez consulter notre section Apprendre HTML.

Référence HTML

Dans notre référence exhaustive, vous trouverez le détail de chaque élément et attribut constituant HTML.




Vous cherchez à devenir un développeur web front-end ?
Nous avons élaboré un cours qui comprend toutes les informations essentielles dont vous avez besoin pour atteindre votre objectif.
Commencer
Tutoriels pour les débutantsLa section Apprendre HTML contient plusieurs modules pour vous apprendre à utiliser HTML — sans autre connaissance particulière.

Une introduction à HTML

Dans ce module, on brosse un premier portrait de HTML pour présenter les concepts importants, la syntaxe. On voit comment appliquer HTML sur du texte, comment créer des hyperliens et comment structurer une page web grâce à HTML.

Le multimédia et l'intégration

Dans ce module, on explore comment utiliser HTML pour intégrer des fichiers multimédias dans une page web. Cela couvre les différentes façons d'inclure une image, comment ajouter une vidéo ou un fichier audio voire aussi comment intégrer d'autres pages web.

Les tableaux HTML

Il est parfois compliqué de représenter des données tabulaires de façon compréhensible et lisible sur une page web. Dans ce module, on voit les différentes balises utilisées pour construire des tableaux et certaines fonctionnalités plus complexes comme les légendes et résumés.

Les formulaires HTML

Les formulaires sont cruciaux sur le Web, ils permettent de créer un compte sur un site, de se connecter, d'acheter des produits, d'écrire des commentaires, etc. Dans ce module, on voit comment créer des formulaires pour le navigateur (« côté client »).

Utiliser HTML pour résoudre des problèmes courants

Ce module fournit un ensemble d'articles au sujet des problèmes qu'on rencontre fréquemment lorsqu'on crée une page web : gérer les titres, ajouter des images ou des vidéos, mettre en avant une partie du texte, créer un formulaire, etc.

Sujets avancés
Images avec le contrôle d'accès HTTP

L'attribut crossorigin, associé à un en-tête CORS approprié, permet de charger des images définies par l'élément <img> depuis des origines étrangères et de les utiliser dans un élément <canvas> comme si elles étaient chargées depuis l'origine actuelle.

Attributs de réglage du CORS

Certains éléments HTML qui fournissent un support pour CORS, tels que <img> ou <video>, ont un attribut crossorigin (propriété crossOrigin), qui vous permet de configurer les requêtes CORS pour les données extraites de l'élément.

Précharger du contenu avec rel="preload"

La valeur preload de l'attribut <link> de l'élément rel vous permet d'écrire des requêtes déclaratives de récupération dans votre <head> HTML, en spécifiant les ressources dont vos pages auront besoin très rapidement après le chargement, et que vous souhaitez donc commencer à précharger au début du cycle de vie d'une page, avant que le cycle de rendu du navigateur ne se mette en marche. Cela permet de s'assurer que ces éléments sont disponibles plus tôt et qu'ils risquent moins de bloquer le premier rendu de la page, améliorant ainsi les performances. Cet article fournit un guide de base sur le fonctionnement du preload.

Références
Référence HTML

HTML est un langage décrivant la structure et le contenu sémantique d'un document web. Il est constitué d'éléments, chacun pouvant être paramétré grâce à différents attributs. Les documents HTML sont connectés à d'autres via des liens

Référence des éléments HTML

Cette page liste les différents éléments HTML.

Liste des attributs HTML

Les éléments du langage HTML possèdent des attributs. Il s'agit de valeurs supplémentaires qui configurent les éléments ou ajustent leur comportement de diverses manières.

Attributs universels

Les attributs universels peuvent être spécifiés sur tous les éléments HTML, même ceux qui ne sont pas spécifiés dans la norme. Par exemple, les navigateurs qui prennent en charge HTML5 masquent les contenus marqués comme <toto hidden>…<toto> , bien que <toto> ne soit pas un élément valide HTML.

Éléments en ligne et éléments de bloc

Les éléments HTML sont habituellement des éléments « en ligne » ou des éléments de bloc. Un élément en ligne occupe seulement l'espace associé aux balises. Les éléments de bloc sont une catégorie d'éléments HTML opposés aux éléments en ligne. Leur caractéristique principale réside dans le fait qu'ils sont séparés par un saut de ligne avant et après l'élément. Ce faisant, ils prennent la largeur de leurs conteneurs (créant ainsi un bloc de contenu).

Types de lien

Les différents liens permettent de décrire les relations entre deux documents qui sont reliés entre eux par un élément <a>, <area> ou <link>.

Formats de média audio et vidéo pris en charge par HTML

Les éléments <audio> et <video> permettent d'ajouter des médias audio et vidéo directement dans le navigateur (sans avoir à utiliser des plugins ou programmes tiers).

Types de contenu HTML

HTML s'organise selon différents types de contenu dont chacun peut être autorisé ou non en fonction du contexte. Ces catégories indiquent quels éléments peuvent être contenus ou non dans d'autres éléments. Cet article explique le fonctionnement de ces catégories.

Sujets connexes
Appliquer des couleurs sur des éléments HTML grâce à CSS

Cet article couvre la plupart des façons d'utiliser CSS pour ajouter de la couleur au contenu HTML, en indiquant les parties des documents HTML qui peuvent être colorées et les propriétés CSS à utiliser pour ce faire. Il comprend des exemples, des liens vers des outils de création de palettes, etc.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 17 déc. 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nHTML: ハイパーテキストマークアップ言語HTML (HyperText Markup Language) はウェブのもっとも基本的な構成要素です。 HTML はウェブページの基本レイアウトに従ってウェブページのコンテンツを記述し定義するものです。 HTML に隣接する他の技術としては、ウェブページの表示や表現を記述するもの (CSS) または機能や振る舞いを記述するもの (JavaScript) があります。
「ハイパーテキスト」はウェブページから別なページに、ウェブサイト内でもウェブサイト間でも、接続するリンクを示します。リンクはウェブの基礎的な特徴です。コンテンツをインターネットにアップロードして他の人々が作成したページにリンクすれば、 World Wide Web の活発な参加者になれます。
HTML ではウェブブラウザーのテキスト、画像、その他のコンテンツを記述するために「マークアップ」を使用します。 HTML のマークアップには、 <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> その他のたくさんの特殊な「要素」を用います。
HTML 要素は文書中で、< および > で囲まれた要素名で構成される「タグ」によって区別されます。タグ内の要素名は、大文字と小文字の区別がありません。つまり、大文字でも、小文字でも、混在して書いても構いません。例えば、 <title> タグは <Title> や <TITLE> やその他の方法で書くことができます。ただし、タグを小文字で書くのが慣習となっており、推奨されています。
以下の記事が HTML についてもっと学ぶのに役立ちます。初心者向けチュートリアル
初めてのウェブサイト: コンテンツの作成

この記事では、 HTML とは何か、また、どのように使用するのかについて、ウェブ開発に完全に新しい人々を対象に、簡単なツアーを提供します。

HTML によるコンテンツの構造化

ウェブ開発の学習の HTML モジュールの節では、 HTML の基礎をすべて一から学べます。

ガイド
HTML フォーム

フォームはウェブで非常に重要な部分です。――これはウェブサイトとのやり取り（登録やログイン、フィードバックの送信、商品の購入など）に必要な多くの機能を提供します。このモジュールでは、フォームのクライアント側／フロントエンド部分の作成から始めます。

CORS を利用した画像

crossorigin 属性と CORS ヘッダーを組み合わせることで、 <img> 要素で定義された画像を異なるドメインから読み出し、 それを <canvas> 要素の中で同じドメインから読み出したかのように扱うことができます。

CORS 設定属性

CORS をサポートするいくつかの HTML 要素（<img> や <video> など）は crossorigin 属性（crossOrigin プロパティ）を持っており、要素が取得したデータに関する CORS リクエストを設定することができます。

rel="preload" によるコンテンツの先読み

HTML の <head> 要素内において、 <link> 要素で rel 属性に preload を指定することで、読み込み後すぐにページに必要なリソース、つまりページ読み込みの過程の初期の、ブラウザーの主なレンダリング機構が起動する前に、先読みを始めたいものを指定する宣言的なフェッチリクエストを記述することができます。これにより、ページの最初のレンダリングがブロックされにくくなり、パフォーマンスが向上します。この記事では preload がどのように動作するのかについての基本的なガイドを提供します。

レスポンシブ画像

この記事では、レスポンシブ画像という概念について学びます。レスポンシブ画像とは、画面サイズや解像度、他にも様々な機能が異なる端末でも適切に表示される画像のことです。また、 HTML でレスポンシブ画像を実装するために役立つツールについても見ていきます。これにより、さまざまな端末でパフォーマンスを向上させることができます。

リファレンス
HTML リファレンス

HTML は要素の集まりで、それぞれの要素がいくつかの属性で修飾される場合があります。 HTML 文書は互いにリンクで接続されます。

HTML 要素リファレンス

すべての HTML 要素の一覧を閲覧します。

HTML 属性リファレンス

HTML の要素には属性があります。これは要素を調整したり、さまざまな方法で振る舞いを調整したりするための付加的な値です。

グローバル属性

グローバル属性は、標準仕様で規定されていないものを含むすべての HTML 要素に指定できるものです。つまり、あらゆる標準外の要素も、それを使用することで文書が HTML5 に準拠しなくなるとしても、グローバル属性を受け入れなければならないということです。

インラインレベル要素とブロックレベル要素

通常、 HTML の要素は「インラインレベル」要素または「ブロックレベル」要素のどちらかです。インラインレベル要素は、要素を定義するタグによって指定された範囲のみを占有します。ブロックレベル要素は親要素（コンテナー）の範囲全体を占有し、それによって「ブロックボックス」を作成します。

HTML コメント

HTML コメントは、マークアップに説明メモを追加したり、文書内の特定の部分をブラウザーが解釈しないようにしたりするために使用します。

ウェブにおけるメディア種別と形式のガイド

<audio> および <video> 要素では、外部のソフトウェアの支援を必要とせずにコンテンツの中でネイティブに音声や動画を再生できます。

HTML コンテンツカテゴリー

HTML は数種類のコンテンツで構成されています。それぞれのコンテンツは特定のコンテキストで使用することができ、それ以外のコンテキストでは使用できません。同様に、それぞれのコンテキストには、格納することができる他のコンテンツカテゴリーと、その中で使用できる要素、または使用できない要素の集合があります。これは、これらのカテゴリーへのガイドです

後方互換モードと標準準拠モード

後方互換モードと標準準拠モードの歴史的な情報です。

関連トピック
CSS を使って HTML の要素に色をつける

この記事では、 CSS を使用して HTML コンテンツに色をつける方法、 HTML 文書のどの部分に色付けできるかの一覧、使用する CSS プロパティについて説明します。\n\nHTML: ハイパーテキストマークアップ言語HTML (HyperText Markup Language) はウェブのもっとも基本的な構成要素です。 HTML はウェブページの基本レイアウトに従ってウェブページのコンテンツを記述し定義するものです。 HTML に隣接する他の技術としては、ウェブページの表示や表現を記述するもの (CSS) または機能や振る舞いを記述するもの (JavaScript) があります。
「ハイパーテキスト」はウェブページから別なページに、ウェブサイト内でもウェブサイト間でも、接続するリンクを示します。リンクはウェブの基礎的な特徴です。コンテンツをインターネットにアップロードして他の人々が作成したページにリンクすれば、 World Wide Web の活発な参加者になれます。
HTML ではウェブブラウザーのテキスト、画像、その他のコンテンツを記述するために「マークアップ」を使用します。 HTML のマークアップには、 <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> その他のたくさんの特殊な「要素」を用います。
HTML 要素は文書中で、< および > で囲まれた要素名で構成される「タグ」によって区別されます。タグ内の要素名は、大文字と小文字の区別がありません。つまり、大文字でも、小文字でも、混在して書いても構いません。例えば、 <title> タグは <Title> や <TITLE> やその他の方法で書くことができます。ただし、タグを小文字で書くのが慣習となっており、推奨されています。
以下の記事が HTML についてもっと学ぶのに役立ちます。初心者向けチュートリアル
初めてのウェブサイト: コンテンツの作成

この記事では、 HTML とは何か、また、どのように使用するのかについて、ウェブ開発に完全に新しい人々を対象に、簡単なツアーを提供します。

HTML によるコンテンツの構造化

ウェブ開発の学習の HTML モジュールの節では、 HTML の基礎をすべて一から学べます。

ガイド
HTML フォーム

フォームはウェブで非常に重要な部分です。――これはウェブサイトとのやり取り（登録やログイン、フィードバックの送信、商品の購入など）に必要な多くの機能を提供します。このモジュールでは、フォームのクライアント側／フロントエンド部分の作成から始めます。

CORS を利用した画像

crossorigin 属性と CORS ヘッダーを組み合わせることで、 <img> 要素で定義された画像を異なるドメインから読み出し、 それを <canvas> 要素の中で同じドメインから読み出したかのように扱うことができます。

CORS 設定属性

CORS をサポートするいくつかの HTML 要素（<img> や <video> など）は crossorigin 属性（crossOrigin プロパティ）を持っており、要素が取得したデータに関する CORS リクエストを設定することができます。

rel="preload" によるコンテンツの先読み

HTML の <head> 要素内において、 <link> 要素で rel 属性に preload を指定することで、読み込み後すぐにページに必要なリソース、つまりページ読み込みの過程の初期の、ブラウザーの主なレンダリング機構が起動する前に、先読みを始めたいものを指定する宣言的なフェッチリクエストを記述することができます。これにより、ページの最初のレンダリングがブロックされにくくなり、パフォーマンスが向上します。この記事では preload がどのように動作するのかについての基本的なガイドを提供します。

レスポンシブ画像

この記事では、レスポンシブ画像という概念について学びます。レスポンシブ画像とは、画面サイズや解像度、他にも様々な機能が異なる端末でも適切に表示される画像のことです。また、 HTML でレスポンシブ画像を実装するために役立つツールについても見ていきます。これにより、さまざまな端末でパフォーマンスを向上させることができます。

リファレンス
HTML リファレンス

HTML は要素の集まりで、それぞれの要素がいくつかの属性で修飾される場合があります。 HTML 文書は互いにリンクで接続されます。

HTML 要素リファレンス

すべての HTML 要素の一覧を閲覧します。

HTML 属性リファレンス

HTML の要素には属性があります。これは要素を調整したり、さまざまな方法で振る舞いを調整したりするための付加的な値です。

グローバル属性

グローバル属性は、標準仕様で規定されていないものを含むすべての HTML 要素に指定できるものです。つまり、あらゆる標準外の要素も、それを使用することで文書が HTML5 に準拠しなくなるとしても、グローバル属性を受け入れなければならないということです。

インラインレベル要素とブロックレベル要素

通常、 HTML の要素は「インラインレベル」要素または「ブロックレベル」要素のどちらかです。インラインレベル要素は、要素を定義するタグによって指定された範囲のみを占有します。ブロックレベル要素は親要素（コンテナー）の範囲全体を占有し、それによって「ブロックボックス」を作成します。

HTML コメント

HTML コメントは、マークアップに説明メモを追加したり、文書内の特定の部分をブラウザーが解釈しないようにしたりするために使用します。

ウェブにおけるメディア種別と形式のガイド

<audio> および <video> 要素では、外部のソフトウェアの支援を必要とせずにコンテンツの中でネイティブに音声や動画を再生できます。

HTML コンテンツカテゴリー

HTML は数種類のコンテンツで構成されています。それぞれのコンテンツは特定のコンテキストで使用することができ、それ以外のコンテキストでは使用できません。同様に、それぞれのコンテキストには、格納することができる他のコンテンツカテゴリーと、その中で使用できる要素、または使用できない要素の集合があります。これは、これらのカテゴリーへのガイドです

後方互換モードと標準準拠モード

後方互換モードと標準準拠モードの歴史的な情報です。

関連トピック
CSS を使って HTML の要素に色をつける

この記事では、 CSS を使用して HTML コンテンツに色をつける方法、 HTML 文書のどの部分に色付けできるかの一覧、使用する CSS プロパティについて説明します。

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025年4月15日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nHTML: ハイパーテキストマークアップ言語HTML (HyperText Markup Language) はウェブのもっとも基本的な構成要素です。 HTML はウェブページの基本レイアウトに従ってウェブページのコンテンツを記述し定義するものです。 HTML に隣接する他の技術としては、ウェブページの表示や表現を記述するもの (CSS) または機能や振る舞いを記述するもの (JavaScript) があります。
「ハイパーテキスト」はウェブページから別なページに、ウェブサイト内でもウェブサイト間でも、接続するリンクを示します。リンクはウェブの基礎的な特徴です。コンテンツをインターネットにアップロードして他の人々が作成したページにリンクすれば、 World Wide Web の活発な参加者になれます。
HTML ではウェブブラウザーのテキスト、画像、その他のコンテンツを記述するために「マークアップ」を使用します。 HTML のマークアップには、 <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> その他のたくさんの特殊な「要素」を用います。
HTML 要素は文書中で、< および > で囲まれた要素名で構成される「タグ」によって区別されます。タグ内の要素名は、大文字と小文字の区別がありません。つまり、大文字でも、小文字でも、混在して書いても構いません。例えば、 <title> タグは <Title> や <TITLE> やその他の方法で書くことができます。ただし、タグを小文字で書くのが慣習となっており、推奨されています。
以下の記事が HTML についてもっと学ぶのに役立ちます。初心者向けチュートリアル
初めてのウェブサイト: コンテンツの作成

この記事では、 HTML とは何か、また、どのように使用するのかについて、ウェブ開発に完全に新しい人々を対象に、簡単なツアーを提供します。

HTML によるコンテンツの構造化

ウェブ開発の学習の HTML モジュールの節では、 HTML の基礎をすべて一から学べます。

ガイド
HTML フォーム

フォームはウェブで非常に重要な部分です。――これはウェブサイトとのやり取り（登録やログイン、フィードバックの送信、商品の購入など）に必要な多くの機能を提供します。このモジュールでは、フォームのクライアント側／フロントエンド部分の作成から始めます。

CORS を利用した画像

crossorigin 属性と CORS ヘッダーを組み合わせることで、 <img> 要素で定義された画像を異なるドメインから読み出し、 それを <canvas> 要素の中で同じドメインから読み出したかのように扱うことができます。

CORS 設定属性

CORS をサポートするいくつかの HTML 要素（<img> や <video> など）は crossorigin 属性（crossOrigin プロパティ）を持っており、要素が取得したデータに関する CORS リクエストを設定することができます。

rel="preload" によるコンテンツの先読み

HTML の <head> 要素内において、 <link> 要素で rel 属性に preload を指定することで、読み込み後すぐにページに必要なリソース、つまりページ読み込みの過程の初期の、ブラウザーの主なレンダリング機構が起動する前に、先読みを始めたいものを指定する宣言的なフェッチリクエストを記述することができます。これにより、ページの最初のレンダリングがブロックされにくくなり、パフォーマンスが向上します。この記事では preload がどのように動作するのかについての基本的なガイドを提供します。

レスポンシブ画像

この記事では、レスポンシブ画像という概念について学びます。レスポンシブ画像とは、画面サイズや解像度、他にも様々な機能が異なる端末でも適切に表示される画像のことです。また、 HTML でレスポンシブ画像を実装するために役立つツールについても見ていきます。これにより、さまざまな端末でパフォーマンスを向上させることができます。

リファレンス
HTML リファレンス

HTML は要素の集まりで、それぞれの要素がいくつかの属性で修飾される場合があります。 HTML 文書は互いにリンクで接続されます。

HTML 要素リファレンス

すべての HTML 要素の一覧を閲覧します。

HTML 属性リファレンス

HTML の要素には属性があります。これは要素を調整したり、さまざまな方法で振る舞いを調整したりするための付加的な値です。

グローバル属性

グローバル属性は、標準仕様で規定されていないものを含むすべての HTML 要素に指定できるものです。つまり、あらゆる標準外の要素も、それを使用することで文書が HTML5 に準拠しなくなるとしても、グローバル属性を受け入れなければならないということです。

インラインレベル要素とブロックレベル要素

通常、 HTML の要素は「インラインレベル」要素または「ブロックレベル」要素のどちらかです。インラインレベル要素は、要素を定義するタグによって指定された範囲のみを占有します。ブロックレベル要素は親要素（コンテナー）の範囲全体を占有し、それによって「ブロックボックス」を作成します。

HTML コメント

HTML コメントは、マークアップに説明メモを追加したり、文書内の特定の部分をブラウザーが解釈しないようにしたりするために使用します。

ウェブにおけるメディア種別と形式のガイド

<audio> および <video> 要素では、外部のソフトウェアの支援を必要とせずにコンテンツの中でネイティブに音声や動画を再生できます。

HTML コンテンツカテゴリー

HTML は数種類のコンテンツで構成されています。それぞれのコンテンツは特定のコンテキストで使用することができ、それ以外のコンテキストでは使用できません。同様に、それぞれのコンテキストには、格納することができる他のコンテンツカテゴリーと、その中で使用できる要素、または使用できない要素の集合があります。これは、これらのカテゴリーへのガイドです

後方互換モードと標準準拠モード

後方互換モードと標準準拠モードの歴史的な情報です。

関連トピック
CSS を使って HTML の要素に色をつける

この記事では、 CSS を使用して HTML コンテンツに色をつける方法、 HTML 文書のどの部分に色付けできるかの一覧、使用する CSS プロパティについて説明します。

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025年4月15日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nHTML: Hypertext Markup LanguageHTML(HyperText Markup Language)은 웹을 이루는 가장 기초적인 구성 요소로, 웹 콘텐츠의 의미와 구조를
정의할 때 사용합니다. HTML 이외의 다른 기술은 일반적으로 웹 페이지의 모양/표현 (CSS), 또는 기능/동작 (JavaScript)을 설명하는 데 사용됩니다.
"Hypertext(하이퍼텍스트)"란 웹 페이지를 다른 페이지로 연결하는 링크를 말합니다. 링크는 웹의 근본적인 속성으로, 인터넷에 자료를 올리고 다른 사람이 만든 페이지로 연결함으로써 여러분도 월드 와이드 웹 세계의 능동적인 일원이 될 수 있습니다.
HTML은 웹 브라우저에 표시되는 글과 이미지 등의 다양한 콘텐츠를 표시하기 위해 "마크업"을 사용합니다. HTML 마크업은 다양한 "요소"를 사용하는데, 요소에는 <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <output>, <progress>, <video>, <ul>, <ol>, <li> 등 많은 종류가 존재합니다.
HTML 요소는 "태그"를 사용해서 문서의 다른 텍스트와 구분합니다. 태그는 "<", 태그 이름, ">"로 이루어집니다. 태그 안의 요소 이름은 대소문자를 구분하지 않습니다. 즉, 대문자, 소문자, 아니면 섞어서도 작성할 수 있습니다. 예를 들어 <title>요소는 <Title>, <TITLE>, 그 외 기타 가능한 모든 방법으로 작성할 수 있습니다.
아래 문서에서 HTML을 더 깊게 배워보세요.중요한 자료
HTML 소개

웹 개발이 처음이시라면 HTML 기본 문서에서 HTML이란 무엇인지, 그리고 HTML의 사용법을 배워보세요.

HTML 자습서

HTML 학습지를 방문하시면 HTML 사용법과 자습서, 완전한 예제를 찾아보실 수 있습니다.

HTML 참고서

방대한 HTML 참고서에서는 HTML을 구성하는 모든 요소와 특성의 자세한 설명을 볼 수 있습니다.




프런트엔드 웹 개발자가 되고자 하시나요?
목표를 달성하기 위한 모든 필수 정보가 들어있는 교육 과정을 준비했습니다.
시작하기
초보자 자습서MDN HTML 학습지는 HTML을 처음부터 알려주는 모듈로 구성되어 있습니다. 사전 지식도 필요하지 않습니다.

HTML 소개

이 모듈에서는 텍스트에 HTML을 추가하고, 하이퍼링크를 작성하고, HTML을 이용해 웹 페이지의 구조를 작성하는 등 중요한 개념과 구문에 익숙해지도록 기초를 다집니다.

멀티미디어와 임베딩

이 모듈에서는 HTML을 사용해 웹 페이지에 이미지를 추가하는 여러가지 방법과 오디오, 비디오, 혹은 다른 웹 페이지를 통째로 삽입하는 등 멀티미디어를 삽입하는 방법을 살펴봅니다.

HTML 표

표 형태의 데이터를 웹페이지에 이해하기도 쉽고 접근하기도 쉬운 방식으로 표현하는 것은 어려울 수 있습니다. 이 모듈은 기본적인 표 마크업 작성법과, 캡션과 요약 등 고급 기능 구현도 다룹니다.

HTML 양식

양식은 웹의 매우 중요한 부분으로, 회원가입과 로그인, 피드백 전송, 상품 구매 등 웹 사이트의 상호작용에 필요한 많은 기능을 제공합니다. 이 모듈은 양식의 클라이언트 사이트 개발 방법을 안내합니다.

일반적인 HTML 문제 해결하기

이 모듈은 HTML을 사용해서 웹 페이지 제목, 이미지와 비디오 추가, 콘텐츠 강조, 기본적인 양식 생성처럼 일반적인 문제를 해결하는 법을 설명합니다.

고급 주제
CORS 활성화 이미지

crossorigin 속성을 적절한 CORS 헤더와 조합하면 <img> 요소의 이미지를 외부 출처에서 가져올 수 있으며, 마치 현재 출처의 이미지인 것처럼 <canvas>에서도 사용할 수 있습니다.

CORS 설정 특성

<img>, <video> 등 CORS를 지원하는 일부 HTML 요소는 crossorigin 특성(crossOrigin 속성)을 보유하며, 해당 요소가 데이터를 가져올 때의 CORS 요청을 통제할 수 있습니다.

rel="preload"로 콘텐츠 미리 불러오기

<link> 요소, rel 특성의 preload 값을 사용하면 페이지를 불러온 직후 빠르게 사용해야 하는 리소스에 대해 선언적인 가져오기 요청을 <head> 안에 추가할 수 있습니다. 이렇게 지정한 리소스는 페이지 불러오기 라이프사이클의 초기, 브라우저의 주 렌더링이 시작하기도 전에 시작하고, 페이지의 첫 렌더링이 덜 막혀 성능이 개선됩니다. 이 글에서는 preload 작동 방식에 대한 기본적인 지침을 제공합니다.

참고서
HTML 참고서

HTML은 요소로 이루어져있으며, 각각의 요소는 몇 가지 특성을 사용해 수정할 수 있습니다. HTML 문서는 서로 링크로 연결되어 있습니다.

HTML 요소 참고서

모든 HTML 요소의 목록을 살펴보세요.

HTML 특성 참고서

HTML 요소는 특성을 가집니다. 특성은 요소나 그 동작 방식을 다양하게 설정하고 수정하는 일련의 추가 값입니다.

전역 특성

전역 특성은 모든 HTML 요소에 지정할 수 있으며, 심지어 표준에 명시되지 않은 요소에도 지정할 수 있습니다. 비록 비표준 요소를 사용하는 순간 문서는 HTML 표준을 준수하지 않는 것이지만, 그렇다고 해도 모든 비표준 요소는 전역 특성을 허용해야 합니다.

인라인 요소와 블록 레벨 요소

HTML의 요소는 역사적으로 "블록 레벨" 요소와 "인라인" 요소로 분류됐습니다. 인라인 요소는 콘텐츠의 흐름을 끊지 않고, 요소를 구성하는 태그에 할당된 공간만 차지합니다. 블록 레벨 요소는 부모 요소의 전체 공간을 차지하여 "블록"을 만듭니다.

HTML 미디어 유형과 형식 안내서

<audio>와 <video> 요소를 통해 외부 프로그램 없이 오디오와 비디오 미디어를 재생할 수 있습니다.

HTML 콘텐츠 카테고리

HTML 요소는 어떤 상황에서는 사용할 수 있고, 어떤 상황에서는 사용할 수 없는지 결정하는 여러가지 분류, 콘텐츠 카테고리에 속합니다. 마찬가지로, 요소는 자신의 콘텐츠로 허용할 콘텐츠 카테고리도 정의합니다.

호환성 모드와 표준 모드

호환성 모드와 표준 모드에 대한 역사적인 정보입니다.

관련 주제
CSS를 사용해 HTML 요소에 색 입히기

이 문서는 HTML 문서의 어떤 부분에 색을 적용할 수 있는지와, 이 때 사용할 수 있는 CSS 속성을 나열합니다. 예제와 함께 각종 도구로의 링크도 제공합니다.\n\nHTML: Hypertext Markup LanguageHTML(HyperText Markup Language)은 웹을 이루는 가장 기초적인 구성 요소로, 웹 콘텐츠의 의미와 구조를
정의할 때 사용합니다. HTML 이외의 다른 기술은 일반적으로 웹 페이지의 모양/표현 (CSS), 또는 기능/동작 (JavaScript)을 설명하는 데 사용됩니다.
"Hypertext(하이퍼텍스트)"란 웹 페이지를 다른 페이지로 연결하는 링크를 말합니다. 링크는 웹의 근본적인 속성으로, 인터넷에 자료를 올리고 다른 사람이 만든 페이지로 연결함으로써 여러분도 월드 와이드 웹 세계의 능동적인 일원이 될 수 있습니다.
HTML은 웹 브라우저에 표시되는 글과 이미지 등의 다양한 콘텐츠를 표시하기 위해 "마크업"을 사용합니다. HTML 마크업은 다양한 "요소"를 사용하는데, 요소에는 <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <output>, <progress>, <video>, <ul>, <ol>, <li> 등 많은 종류가 존재합니다.
HTML 요소는 "태그"를 사용해서 문서의 다른 텍스트와 구분합니다. 태그는 "<", 태그 이름, ">"로 이루어집니다. 태그 안의 요소 이름은 대소문자를 구분하지 않습니다. 즉, 대문자, 소문자, 아니면 섞어서도 작성할 수 있습니다. 예를 들어 <title>요소는 <Title>, <TITLE>, 그 외 기타 가능한 모든 방법으로 작성할 수 있습니다.
아래 문서에서 HTML을 더 깊게 배워보세요.중요한 자료
HTML 소개

웹 개발이 처음이시라면 HTML 기본 문서에서 HTML이란 무엇인지, 그리고 HTML의 사용법을 배워보세요.

HTML 자습서

HTML 학습지를 방문하시면 HTML 사용법과 자습서, 완전한 예제를 찾아보실 수 있습니다.

HTML 참고서

방대한 HTML 참고서에서는 HTML을 구성하는 모든 요소와 특성의 자세한 설명을 볼 수 있습니다.




프런트엔드 웹 개발자가 되고자 하시나요?
목표를 달성하기 위한 모든 필수 정보가 들어있는 교육 과정을 준비했습니다.
시작하기
초보자 자습서MDN HTML 학습지는 HTML을 처음부터 알려주는 모듈로 구성되어 있습니다. 사전 지식도 필요하지 않습니다.

HTML 소개

이 모듈에서는 텍스트에 HTML을 추가하고, 하이퍼링크를 작성하고, HTML을 이용해 웹 페이지의 구조를 작성하는 등 중요한 개념과 구문에 익숙해지도록 기초를 다집니다.

멀티미디어와 임베딩

이 모듈에서는 HTML을 사용해 웹 페이지에 이미지를 추가하는 여러가지 방법과 오디오, 비디오, 혹은 다른 웹 페이지를 통째로 삽입하는 등 멀티미디어를 삽입하는 방법을 살펴봅니다.

HTML 표

표 형태의 데이터를 웹페이지에 이해하기도 쉽고 접근하기도 쉬운 방식으로 표현하는 것은 어려울 수 있습니다. 이 모듈은 기본적인 표 마크업 작성법과, 캡션과 요약 등 고급 기능 구현도 다룹니다.

HTML 양식

양식은 웹의 매우 중요한 부분으로, 회원가입과 로그인, 피드백 전송, 상품 구매 등 웹 사이트의 상호작용에 필요한 많은 기능을 제공합니다. 이 모듈은 양식의 클라이언트 사이트 개발 방법을 안내합니다.

일반적인 HTML 문제 해결하기

이 모듈은 HTML을 사용해서 웹 페이지 제목, 이미지와 비디오 추가, 콘텐츠 강조, 기본적인 양식 생성처럼 일반적인 문제를 해결하는 법을 설명합니다.

고급 주제
CORS 활성화 이미지

crossorigin 속성을 적절한 CORS 헤더와 조합하면 <img> 요소의 이미지를 외부 출처에서 가져올 수 있으며, 마치 현재 출처의 이미지인 것처럼 <canvas>에서도 사용할 수 있습니다.

CORS 설정 특성

<img>, <video> 등 CORS를 지원하는 일부 HTML 요소는 crossorigin 특성(crossOrigin 속성)을 보유하며, 해당 요소가 데이터를 가져올 때의 CORS 요청을 통제할 수 있습니다.

rel="preload"로 콘텐츠 미리 불러오기

<link> 요소, rel 특성의 preload 값을 사용하면 페이지를 불러온 직후 빠르게 사용해야 하는 리소스에 대해 선언적인 가져오기 요청을 <head> 안에 추가할 수 있습니다. 이렇게 지정한 리소스는 페이지 불러오기 라이프사이클의 초기, 브라우저의 주 렌더링이 시작하기도 전에 시작하고, 페이지의 첫 렌더링이 덜 막혀 성능이 개선됩니다. 이 글에서는 preload 작동 방식에 대한 기본적인 지침을 제공합니다.

참고서
HTML 참고서

HTML은 요소로 이루어져있으며, 각각의 요소는 몇 가지 특성을 사용해 수정할 수 있습니다. HTML 문서는 서로 링크로 연결되어 있습니다.

HTML 요소 참고서

모든 HTML 요소의 목록을 살펴보세요.

HTML 특성 참고서

HTML 요소는 특성을 가집니다. 특성은 요소나 그 동작 방식을 다양하게 설정하고 수정하는 일련의 추가 값입니다.

전역 특성

전역 특성은 모든 HTML 요소에 지정할 수 있으며, 심지어 표준에 명시되지 않은 요소에도 지정할 수 있습니다. 비록 비표준 요소를 사용하는 순간 문서는 HTML 표준을 준수하지 않는 것이지만, 그렇다고 해도 모든 비표준 요소는 전역 특성을 허용해야 합니다.

인라인 요소와 블록 레벨 요소

HTML의 요소는 역사적으로 "블록 레벨" 요소와 "인라인" 요소로 분류됐습니다. 인라인 요소는 콘텐츠의 흐름을 끊지 않고, 요소를 구성하는 태그에 할당된 공간만 차지합니다. 블록 레벨 요소는 부모 요소의 전체 공간을 차지하여 "블록"을 만듭니다.

HTML 미디어 유형과 형식 안내서

<audio>와 <video> 요소를 통해 외부 프로그램 없이 오디오와 비디오 미디어를 재생할 수 있습니다.

HTML 콘텐츠 카테고리

HTML 요소는 어떤 상황에서는 사용할 수 있고, 어떤 상황에서는 사용할 수 없는지 결정하는 여러가지 분류, 콘텐츠 카테고리에 속합니다. 마찬가지로, 요소는 자신의 콘텐츠로 허용할 콘텐츠 카테고리도 정의합니다.

호환성 모드와 표준 모드

호환성 모드와 표준 모드에 대한 역사적인 정보입니다.

관련 주제
CSS를 사용해 HTML 요소에 색 입히기

이 문서는 HTML 문서의 어떤 부분에 색을 적용할 수 있는지와, 이 때 사용할 수 있는 CSS 속성을 나열합니다. 예제와 함께 각종 도구로의 링크도 제공합니다.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025년 3월 22일 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nHTML: Hypertext Markup LanguageHTML(HyperText Markup Language)은 웹을 이루는 가장 기초적인 구성 요소로, 웹 콘텐츠의 의미와 구조를
정의할 때 사용합니다. HTML 이외의 다른 기술은 일반적으로 웹 페이지의 모양/표현 (CSS), 또는 기능/동작 (JavaScript)을 설명하는 데 사용됩니다.
"Hypertext(하이퍼텍스트)"란 웹 페이지를 다른 페이지로 연결하는 링크를 말합니다. 링크는 웹의 근본적인 속성으로, 인터넷에 자료를 올리고 다른 사람이 만든 페이지로 연결함으로써 여러분도 월드 와이드 웹 세계의 능동적인 일원이 될 수 있습니다.
HTML은 웹 브라우저에 표시되는 글과 이미지 등의 다양한 콘텐츠를 표시하기 위해 "마크업"을 사용합니다. HTML 마크업은 다양한 "요소"를 사용하는데, 요소에는 <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <output>, <progress>, <video>, <ul>, <ol>, <li> 등 많은 종류가 존재합니다.
HTML 요소는 "태그"를 사용해서 문서의 다른 텍스트와 구분합니다. 태그는 "<", 태그 이름, ">"로 이루어집니다. 태그 안의 요소 이름은 대소문자를 구분하지 않습니다. 즉, 대문자, 소문자, 아니면 섞어서도 작성할 수 있습니다. 예를 들어 <title>요소는 <Title>, <TITLE>, 그 외 기타 가능한 모든 방법으로 작성할 수 있습니다.
아래 문서에서 HTML을 더 깊게 배워보세요.중요한 자료
HTML 소개

웹 개발이 처음이시라면 HTML 기본 문서에서 HTML이란 무엇인지, 그리고 HTML의 사용법을 배워보세요.

HTML 자습서

HTML 학습지를 방문하시면 HTML 사용법과 자습서, 완전한 예제를 찾아보실 수 있습니다.

HTML 참고서

방대한 HTML 참고서에서는 HTML을 구성하는 모든 요소와 특성의 자세한 설명을 볼 수 있습니다.




프런트엔드 웹 개발자가 되고자 하시나요?
목표를 달성하기 위한 모든 필수 정보가 들어있는 교육 과정을 준비했습니다.
시작하기
초보자 자습서MDN HTML 학습지는 HTML을 처음부터 알려주는 모듈로 구성되어 있습니다. 사전 지식도 필요하지 않습니다.

HTML 소개

이 모듈에서는 텍스트에 HTML을 추가하고, 하이퍼링크를 작성하고, HTML을 이용해 웹 페이지의 구조를 작성하는 등 중요한 개념과 구문에 익숙해지도록 기초를 다집니다.

멀티미디어와 임베딩

이 모듈에서는 HTML을 사용해 웹 페이지에 이미지를 추가하는 여러가지 방법과 오디오, 비디오, 혹은 다른 웹 페이지를 통째로 삽입하는 등 멀티미디어를 삽입하는 방법을 살펴봅니다.

HTML 표

표 형태의 데이터를 웹페이지에 이해하기도 쉽고 접근하기도 쉬운 방식으로 표현하는 것은 어려울 수 있습니다. 이 모듈은 기본적인 표 마크업 작성법과, 캡션과 요약 등 고급 기능 구현도 다룹니다.

HTML 양식

양식은 웹의 매우 중요한 부분으로, 회원가입과 로그인, 피드백 전송, 상품 구매 등 웹 사이트의 상호작용에 필요한 많은 기능을 제공합니다. 이 모듈은 양식의 클라이언트 사이트 개발 방법을 안내합니다.

일반적인 HTML 문제 해결하기

이 모듈은 HTML을 사용해서 웹 페이지 제목, 이미지와 비디오 추가, 콘텐츠 강조, 기본적인 양식 생성처럼 일반적인 문제를 해결하는 법을 설명합니다.

고급 주제
CORS 활성화 이미지

crossorigin 속성을 적절한 CORS 헤더와 조합하면 <img> 요소의 이미지를 외부 출처에서 가져올 수 있으며, 마치 현재 출처의 이미지인 것처럼 <canvas>에서도 사용할 수 있습니다.

CORS 설정 특성

<img>, <video> 등 CORS를 지원하는 일부 HTML 요소는 crossorigin 특성(crossOrigin 속성)을 보유하며, 해당 요소가 데이터를 가져올 때의 CORS 요청을 통제할 수 있습니다.

rel="preload"로 콘텐츠 미리 불러오기

<link> 요소, rel 특성의 preload 값을 사용하면 페이지를 불러온 직후 빠르게 사용해야 하는 리소스에 대해 선언적인 가져오기 요청을 <head> 안에 추가할 수 있습니다. 이렇게 지정한 리소스는 페이지 불러오기 라이프사이클의 초기, 브라우저의 주 렌더링이 시작하기도 전에 시작하고, 페이지의 첫 렌더링이 덜 막혀 성능이 개선됩니다. 이 글에서는 preload 작동 방식에 대한 기본적인 지침을 제공합니다.

참고서
HTML 참고서

HTML은 요소로 이루어져있으며, 각각의 요소는 몇 가지 특성을 사용해 수정할 수 있습니다. HTML 문서는 서로 링크로 연결되어 있습니다.

HTML 요소 참고서

모든 HTML 요소의 목록을 살펴보세요.

HTML 특성 참고서

HTML 요소는 특성을 가집니다. 특성은 요소나 그 동작 방식을 다양하게 설정하고 수정하는 일련의 추가 값입니다.

전역 특성

전역 특성은 모든 HTML 요소에 지정할 수 있으며, 심지어 표준에 명시되지 않은 요소에도 지정할 수 있습니다. 비록 비표준 요소를 사용하는 순간 문서는 HTML 표준을 준수하지 않는 것이지만, 그렇다고 해도 모든 비표준 요소는 전역 특성을 허용해야 합니다.

인라인 요소와 블록 레벨 요소

HTML의 요소는 역사적으로 "블록 레벨" 요소와 "인라인" 요소로 분류됐습니다. 인라인 요소는 콘텐츠의 흐름을 끊지 않고, 요소를 구성하는 태그에 할당된 공간만 차지합니다. 블록 레벨 요소는 부모 요소의 전체 공간을 차지하여 "블록"을 만듭니다.

HTML 미디어 유형과 형식 안내서

<audio>와 <video> 요소를 통해 외부 프로그램 없이 오디오와 비디오 미디어를 재생할 수 있습니다.

HTML 콘텐츠 카테고리

HTML 요소는 어떤 상황에서는 사용할 수 있고, 어떤 상황에서는 사용할 수 없는지 결정하는 여러가지 분류, 콘텐츠 카테고리에 속합니다. 마찬가지로, 요소는 자신의 콘텐츠로 허용할 콘텐츠 카테고리도 정의합니다.

호환성 모드와 표준 모드

호환성 모드와 표준 모드에 대한 역사적인 정보입니다.

관련 주제
CSS를 사용해 HTML 요소에 색 입히기

이 문서는 HTML 문서의 어떤 부분에 색을 적용할 수 있는지와, 이 때 사용할 수 있는 CSS 속성을 나열합니다. 예제와 함께 각종 도구로의 링크도 제공합니다.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025년 3월 22일 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nHTML: Linguagem de Marcação de HipertextoHTML (Linguagem de Marcação de HiperTexto) é o bloco de construção mais básico da web. Define o significado e a estrutura do conteúdo da web. Outras tecnologias além do HTML geralmente são usadas para descrever a aparência/apresentação (CSS) ou a funcionalidade/comportamento (JavaScript) de uma página da web.
"Hipertexto" refere-se aos links que conectam páginas da Web entre si, seja dentro de um único site ou entre sites. Links são um aspecto fundamental da web. Ao carregar conteúdo na Internet e vinculá-lo a páginas criadas por outras pessoas, você se torna um participante ativo na world wide web.
O HTML usa "Marcação" para anotar texto, imagem e outros conteúdos para exibição em um navegador da Web. A marcação HTML inclui "elementos" especiais, como <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <output>, <progress>, <video>, <ul>, <ol>, <li> e muitos outros.
Um elemento HTML é separado de outro texto em um documento por "tags", que consistem no nome do elemento entre "<" e ">". O nome de um elemento dentro de uma tag é insensível a maiúsculas e minúsculas. Isto é, pode ser escrito em maiúsculas, minúsculas ou um mistura. Por exemplo, a tag <title> pode ser escrita como <Title>, <TITLE> ou de qualquer outra forma.
Os artigos abaixo podem ajudá-lo a aprender mais sobre HTML.


Introdução ao HTML
Se você é novo no desenvolvimento web, não deixe de ler nosso artigo O Básico do HTML para aprender o que é HTML e como usá-lo.


Tutoriais HTML
Para artigos sobre como usar o HTML, assim como tutoriais e exemplos completos, confira nossa Área de Aprendizado de HTML.


Referência do HTML
Em nossa extensa seção de Referência do HTML, você encontrará os detalhes sobre cada elemento e atributo do HTML.

Tutoriais para iniciantesNossa Área de Aprendizado de HTML apresenta vários módulos que ensinam HTML desde o início — sem necessidade de conhecimento prévio.

Introdução ao HTML

Este módulo fornece uma base de conhecimento, permitindo que você acostume-se com os conceitos e sintaxes importantes, tais como aplicar HTML para texto, como criar hyperlinks e como usar HTML para estruturar uma página web.

Multimídia e como incorporá-la

Este módulo explora como usar HTML para incluir multimídia em sua página web, incluindo as diferentes maneiras para incluir imagens, e como incorporar vídeos, áudios e até como colocar uma página inteira em outras páginas web.

Tabelas HTML

Representar dados tabulares em uma página web de maneira entendível e acessível pode ser um desafio. Este módulo cobre marcação tabular básica, junto com outras funcionalidades mais complexas como legendas e sumários.

Formulários HTML

Formulários são partes muito importantes na Web — proporcionam muitas das funcionalidades que você precisa para interagir em páginas web. Exemplos disso são registrar-se e conectar-se, enviar comentários, comprar produtos e muito mais. Este módulo lhe permite começar a criar as partes visíveis dos formulários, ou seja, as partes que os usuários interagem.

Usando HTML para resolver problemas comuns

Apresenta links para seções com conteúdo explicando como usar HTML para resolver problemas muito comuns, quando se cria uma página web: como trabalhar com títulos, agregar imagens ou vídeos, colocar ênfase em conteúdo, criar um formulário básico, etc.

Tópicos avançados
Habilitando Imagem CORS

O atributo crossorigin, em combinação com um cabeçalho CORS adequado, permite definir imagens pelo elemento <img> para ser carregado de outras fontes em um elemento <canvas> como se estivessem sendo carregados da fonte atual.

Configuração de atributos CORS

Alguns elementos em HTML que suportam CORS, como por exemplo o <img> ou <video>, têm o atributo crossorigin (a propriedade crossOrigin), que permite configurar as requisições CORS para os dados recebidos pelo elemento.

Gerenciamento de foco em HTML

O atributo DOM activeElement e o método DOM hasFocus() lhe ajudam a melhorar a interação entre o usuário e os elementos da página.

Tipos de conexões

Em HTML, vários tipos de links podem ser utilizados para realizar conexões entre documentos, como por exemplo <a>, <area> e <link>.

Formatos de arquivos suportados pelos elementos de áudio e vídeo em HTML

Os elementos <audio> e <video> permitem que você reproduza áudios e vídeos no seu HTML. Estes elementos fornecem uma alternativa nativa de recursos do navegador, parecidos com a do Adobe Flash Player e outros plug-ins.

Usando o cachê de aplicação

O cachê de aplicação tem como o objetivo executar a aplicação offline. Você pode usar a interface Application Cache (AppCache) para escolher elementos que o browser possa guardar, deixando-os disponíveis para usuários desconectados. As aplicações que forem armazenadas em cache podem ser utilizadas sem nenhum problema, mesmo que o usuário clique no botão de atualizar a página enquanto estiver offline.

Pré-carregando conteúdo com rel="preload"

O valor preload do atributo rel do elemento <link> permite que você escreva solicitações de busca declarativas em seu elemento <head> do HTML, especificando recursos que suas páginas vão utilizar logo após o carregamento. Você também pode necessitar que estes recursos sejam pré-carregados ao início do ciclo de execução da página e depois que o mecanismo de renderização do navegador comece a agir. Isso garante que estarão disponíveis mais cedo e que seja menos provável que sua página seja bloqueada do processo de renderizar. Isso aumenta a performance da página. Este artigo oferece um guia básico de como preload funciona.

Referências
Referência do HTML

HTML é formado de elementos, onde cada um deles pode ser modificado por alguns atributos. Documentos HTML são interconectados através de links.

Referência dos Elementos HTML

Navegue em uma lista com todos os elementos HTML.

Referência de atributos em HTML

Elementos em HTML possuem atributos. Estes configuram ou ajustam o funcionamento e o comportamento dos seus elementos de muitas maneiras.

Atributos Globais

Os atributos globais podem ser utilizados em todos os elementos HTML, mesmo aqueles que não são especificados como padrão. Isso significa que qualquer elemento não padrão vai permitir estes atributos, mesmo que este retorne um documento HTML5 incompatível.

Elementos em linha e Elementos em nível de bloco

Elementos HTML são normalmente elementos inline (em linha) ou block-level (em nível de bloco). Um elemento em linha ocupa somente o espaço limitado pelas tags que o definem. Um elemento em nível de bloco ocupa o espaço inteiro do elemento pai (container), portanto criando um bloco.

Tipos de Links

No HTML, vários tipos de links podem ser utilizados para estabelecer e definir o relacionamento entre dois documentos. Os tipos de elementos de link que podem ser incluídos são <a>, <area> e <link>.

Formatos de mídia suportados pelos elementos vídeo e áudio do HTML

Os elementos <audio> e <video> permitem que você reproduza mídias de áudio e vídeo. Estes elementos fornecem uma alternativa nativa para o navegador reproduzir recursos similares aos encontrados no Adobe Flash e outros plug-ins.

Tipos de conteúdo HTML

O HTML é composto de uma grande diversidade de conteúdos, e cada um pode ser usado em certos contextos e não ser permitido em outros. Da mesma forma, cada um tem um conjunto de outras categorias de conteúdos que podem ou não serem usadas dentro deles. Este é um guia destas categorias.

Os Modos Quirks e o Modo Padrão

Informações sobre a história dos Modos Quirks e o Modo padrão.

Tópicos relacionados
Aplicando cores em elementos HTML usando CSS

Este artigo mostra as principais formas de se usar CSS para adicionar cores ao seu conteúdo HTML, mostrando que partes dos documentos HTML podem ser coloridas e quais propriedades utilizar. Inclui exemplos e links para ferramentas de palette-building, entre outros.\n\nHTML: Linguagem de Marcação de HipertextoHTML (Linguagem de Marcação de HiperTexto) é o bloco de construção mais básico da web. Define o significado e a estrutura do conteúdo da web. Outras tecnologias além do HTML geralmente são usadas para descrever a aparência/apresentação (CSS) ou a funcionalidade/comportamento (JavaScript) de uma página da web.
"Hipertexto" refere-se aos links que conectam páginas da Web entre si, seja dentro de um único site ou entre sites. Links são um aspecto fundamental da web. Ao carregar conteúdo na Internet e vinculá-lo a páginas criadas por outras pessoas, você se torna um participante ativo na world wide web.
O HTML usa "Marcação" para anotar texto, imagem e outros conteúdos para exibição em um navegador da Web. A marcação HTML inclui "elementos" especiais, como <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <output>, <progress>, <video>, <ul>, <ol>, <li> e muitos outros.
Um elemento HTML é separado de outro texto em um documento por "tags", que consistem no nome do elemento entre "<" e ">". O nome de um elemento dentro de uma tag é insensível a maiúsculas e minúsculas. Isto é, pode ser escrito em maiúsculas, minúsculas ou um mistura. Por exemplo, a tag <title> pode ser escrita como <Title>, <TITLE> ou de qualquer outra forma.
Os artigos abaixo podem ajudá-lo a aprender mais sobre HTML.


Introdução ao HTML
Se você é novo no desenvolvimento web, não deixe de ler nosso artigo O Básico do HTML para aprender o que é HTML e como usá-lo.


Tutoriais HTML
Para artigos sobre como usar o HTML, assim como tutoriais e exemplos completos, confira nossa Área de Aprendizado de HTML.


Referência do HTML
Em nossa extensa seção de Referência do HTML, você encontrará os detalhes sobre cada elemento e atributo do HTML.

Tutoriais para iniciantesNossa Área de Aprendizado de HTML apresenta vários módulos que ensinam HTML desde o início — sem necessidade de conhecimento prévio.

Introdução ao HTML

Este módulo fornece uma base de conhecimento, permitindo que você acostume-se com os conceitos e sintaxes importantes, tais como aplicar HTML para texto, como criar hyperlinks e como usar HTML para estruturar uma página web.

Multimídia e como incorporá-la

Este módulo explora como usar HTML para incluir multimídia em sua página web, incluindo as diferentes maneiras para incluir imagens, e como incorporar vídeos, áudios e até como colocar uma página inteira em outras páginas web.

Tabelas HTML

Representar dados tabulares em uma página web de maneira entendível e acessível pode ser um desafio. Este módulo cobre marcação tabular básica, junto com outras funcionalidades mais complexas como legendas e sumários.

Formulários HTML

Formulários são partes muito importantes na Web — proporcionam muitas das funcionalidades que você precisa para interagir em páginas web. Exemplos disso são registrar-se e conectar-se, enviar comentários, comprar produtos e muito mais. Este módulo lhe permite começar a criar as partes visíveis dos formulários, ou seja, as partes que os usuários interagem.

Usando HTML para resolver problemas comuns

Apresenta links para seções com conteúdo explicando como usar HTML para resolver problemas muito comuns, quando se cria uma página web: como trabalhar com títulos, agregar imagens ou vídeos, colocar ênfase em conteúdo, criar um formulário básico, etc.

Tópicos avançados
Habilitando Imagem CORS

O atributo crossorigin, em combinação com um cabeçalho CORS adequado, permite definir imagens pelo elemento <img> para ser carregado de outras fontes em um elemento <canvas> como se estivessem sendo carregados da fonte atual.

Configuração de atributos CORS

Alguns elementos em HTML que suportam CORS, como por exemplo o <img> ou <video>, têm o atributo crossorigin (a propriedade crossOrigin), que permite configurar as requisições CORS para os dados recebidos pelo elemento.

Gerenciamento de foco em HTML

O atributo DOM activeElement e o método DOM hasFocus() lhe ajudam a melhorar a interação entre o usuário e os elementos da página.

Tipos de conexões

Em HTML, vários tipos de links podem ser utilizados para realizar conexões entre documentos, como por exemplo <a>, <area> e <link>.

Formatos de arquivos suportados pelos elementos de áudio e vídeo em HTML

Os elementos <audio> e <video> permitem que você reproduza áudios e vídeos no seu HTML. Estes elementos fornecem uma alternativa nativa de recursos do navegador, parecidos com a do Adobe Flash Player e outros plug-ins.

Usando o cachê de aplicação

O cachê de aplicação tem como o objetivo executar a aplicação offline. Você pode usar a interface Application Cache (AppCache) para escolher elementos que o browser possa guardar, deixando-os disponíveis para usuários desconectados. As aplicações que forem armazenadas em cache podem ser utilizadas sem nenhum problema, mesmo que o usuário clique no botão de atualizar a página enquanto estiver offline.

Pré-carregando conteúdo com rel="preload"

O valor preload do atributo rel do elemento <link> permite que você escreva solicitações de busca declarativas em seu elemento <head> do HTML, especificando recursos que suas páginas vão utilizar logo após o carregamento. Você também pode necessitar que estes recursos sejam pré-carregados ao início do ciclo de execução da página e depois que o mecanismo de renderização do navegador comece a agir. Isso garante que estarão disponíveis mais cedo e que seja menos provável que sua página seja bloqueada do processo de renderizar. Isso aumenta a performance da página. Este artigo oferece um guia básico de como preload funciona.

Referências
Referência do HTML

HTML é formado de elementos, onde cada um deles pode ser modificado por alguns atributos. Documentos HTML são interconectados através de links.

Referência dos Elementos HTML

Navegue em uma lista com todos os elementos HTML.

Referência de atributos em HTML

Elementos em HTML possuem atributos. Estes configuram ou ajustam o funcionamento e o comportamento dos seus elementos de muitas maneiras.

Atributos Globais

Os atributos globais podem ser utilizados em todos os elementos HTML, mesmo aqueles que não são especificados como padrão. Isso significa que qualquer elemento não padrão vai permitir estes atributos, mesmo que este retorne um documento HTML5 incompatível.

Elementos em linha e Elementos em nível de bloco

Elementos HTML são normalmente elementos inline (em linha) ou block-level (em nível de bloco). Um elemento em linha ocupa somente o espaço limitado pelas tags que o definem. Um elemento em nível de bloco ocupa o espaço inteiro do elemento pai (container), portanto criando um bloco.

Tipos de Links

No HTML, vários tipos de links podem ser utilizados para estabelecer e definir o relacionamento entre dois documentos. Os tipos de elementos de link que podem ser incluídos são <a>, <area> e <link>.

Formatos de mídia suportados pelos elementos vídeo e áudio do HTML

Os elementos <audio> e <video> permitem que você reproduza mídias de áudio e vídeo. Estes elementos fornecem uma alternativa nativa para o navegador reproduzir recursos similares aos encontrados no Adobe Flash e outros plug-ins.

Tipos de conteúdo HTML

O HTML é composto de uma grande diversidade de conteúdos, e cada um pode ser usado em certos contextos e não ser permitido em outros. Da mesma forma, cada um tem um conjunto de outras categorias de conteúdos que podem ou não serem usadas dentro deles. Este é um guia destas categorias.

Os Modos Quirks e o Modo Padrão

Informações sobre a história dos Modos Quirks e o Modo padrão.

Tópicos relacionados
Aplicando cores em elementos HTML usando CSS

Este artigo mostra as principais formas de se usar CSS para adicionar cores ao seu conteúdo HTML, mostrando que partes dos documentos HTML podem ser coloridas e quais propriedades utilizar. Inclui exemplos e links para ferramentas de palette-building, entre outros.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 17 de dez. de 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nHTML: Linguagem de Marcação de HipertextoHTML (Linguagem de Marcação de HiperTexto) é o bloco de construção mais básico da web. Define o significado e a estrutura do conteúdo da web. Outras tecnologias além do HTML geralmente são usadas para descrever a aparência/apresentação (CSS) ou a funcionalidade/comportamento (JavaScript) de uma página da web.
"Hipertexto" refere-se aos links que conectam páginas da Web entre si, seja dentro de um único site ou entre sites. Links são um aspecto fundamental da web. Ao carregar conteúdo na Internet e vinculá-lo a páginas criadas por outras pessoas, você se torna um participante ativo na world wide web.
O HTML usa "Marcação" para anotar texto, imagem e outros conteúdos para exibição em um navegador da Web. A marcação HTML inclui "elementos" especiais, como <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <output>, <progress>, <video>, <ul>, <ol>, <li> e muitos outros.
Um elemento HTML é separado de outro texto em um documento por "tags", que consistem no nome do elemento entre "<" e ">". O nome de um elemento dentro de uma tag é insensível a maiúsculas e minúsculas. Isto é, pode ser escrito em maiúsculas, minúsculas ou um mistura. Por exemplo, a tag <title> pode ser escrita como <Title>, <TITLE> ou de qualquer outra forma.
Os artigos abaixo podem ajudá-lo a aprender mais sobre HTML.


Introdução ao HTML
Se você é novo no desenvolvimento web, não deixe de ler nosso artigo O Básico do HTML para aprender o que é HTML e como usá-lo.


Tutoriais HTML
Para artigos sobre como usar o HTML, assim como tutoriais e exemplos completos, confira nossa Área de Aprendizado de HTML.


Referência do HTML
Em nossa extensa seção de Referência do HTML, você encontrará os detalhes sobre cada elemento e atributo do HTML.

Tutoriais para iniciantesNossa Área de Aprendizado de HTML apresenta vários módulos que ensinam HTML desde o início — sem necessidade de conhecimento prévio.

Introdução ao HTML

Este módulo fornece uma base de conhecimento, permitindo que você acostume-se com os conceitos e sintaxes importantes, tais como aplicar HTML para texto, como criar hyperlinks e como usar HTML para estruturar uma página web.

Multimídia e como incorporá-la

Este módulo explora como usar HTML para incluir multimídia em sua página web, incluindo as diferentes maneiras para incluir imagens, e como incorporar vídeos, áudios e até como colocar uma página inteira em outras páginas web.

Tabelas HTML

Representar dados tabulares em uma página web de maneira entendível e acessível pode ser um desafio. Este módulo cobre marcação tabular básica, junto com outras funcionalidades mais complexas como legendas e sumários.

Formulários HTML

Formulários são partes muito importantes na Web — proporcionam muitas das funcionalidades que você precisa para interagir em páginas web. Exemplos disso são registrar-se e conectar-se, enviar comentários, comprar produtos e muito mais. Este módulo lhe permite começar a criar as partes visíveis dos formulários, ou seja, as partes que os usuários interagem.

Usando HTML para resolver problemas comuns

Apresenta links para seções com conteúdo explicando como usar HTML para resolver problemas muito comuns, quando se cria uma página web: como trabalhar com títulos, agregar imagens ou vídeos, colocar ênfase em conteúdo, criar um formulário básico, etc.

Tópicos avançados
Habilitando Imagem CORS

O atributo crossorigin, em combinação com um cabeçalho CORS adequado, permite definir imagens pelo elemento <img> para ser carregado de outras fontes em um elemento <canvas> como se estivessem sendo carregados da fonte atual.

Configuração de atributos CORS

Alguns elementos em HTML que suportam CORS, como por exemplo o <img> ou <video>, têm o atributo crossorigin (a propriedade crossOrigin), que permite configurar as requisições CORS para os dados recebidos pelo elemento.

Gerenciamento de foco em HTML

O atributo DOM activeElement e o método DOM hasFocus() lhe ajudam a melhorar a interação entre o usuário e os elementos da página.

Tipos de conexões

Em HTML, vários tipos de links podem ser utilizados para realizar conexões entre documentos, como por exemplo <a>, <area> e <link>.

Formatos de arquivos suportados pelos elementos de áudio e vídeo em HTML

Os elementos <audio> e <video> permitem que você reproduza áudios e vídeos no seu HTML. Estes elementos fornecem uma alternativa nativa de recursos do navegador, parecidos com a do Adobe Flash Player e outros plug-ins.

Usando o cachê de aplicação

O cachê de aplicação tem como o objetivo executar a aplicação offline. Você pode usar a interface Application Cache (AppCache) para escolher elementos que o browser possa guardar, deixando-os disponíveis para usuários desconectados. As aplicações que forem armazenadas em cache podem ser utilizadas sem nenhum problema, mesmo que o usuário clique no botão de atualizar a página enquanto estiver offline.

Pré-carregando conteúdo com rel="preload"

O valor preload do atributo rel do elemento <link> permite que você escreva solicitações de busca declarativas em seu elemento <head> do HTML, especificando recursos que suas páginas vão utilizar logo após o carregamento. Você também pode necessitar que estes recursos sejam pré-carregados ao início do ciclo de execução da página e depois que o mecanismo de renderização do navegador comece a agir. Isso garante que estarão disponíveis mais cedo e que seja menos provável que sua página seja bloqueada do processo de renderizar. Isso aumenta a performance da página. Este artigo oferece um guia básico de como preload funciona.

Referências
Referência do HTML

HTML é formado de elementos, onde cada um deles pode ser modificado por alguns atributos. Documentos HTML são interconectados através de links.

Referência dos Elementos HTML

Navegue em uma lista com todos os elementos HTML.

Referência de atributos em HTML

Elementos em HTML possuem atributos. Estes configuram ou ajustam o funcionamento e o comportamento dos seus elementos de muitas maneiras.

Atributos Globais

Os atributos globais podem ser utilizados em todos os elementos HTML, mesmo aqueles que não são especificados como padrão. Isso significa que qualquer elemento não padrão vai permitir estes atributos, mesmo que este retorne um documento HTML5 incompatível.

Elementos em linha e Elementos em nível de bloco

Elementos HTML são normalmente elementos inline (em linha) ou block-level (em nível de bloco). Um elemento em linha ocupa somente o espaço limitado pelas tags que o definem. Um elemento em nível de bloco ocupa o espaço inteiro do elemento pai (container), portanto criando um bloco.

Tipos de Links

No HTML, vários tipos de links podem ser utilizados para estabelecer e definir o relacionamento entre dois documentos. Os tipos de elementos de link que podem ser incluídos são <a>, <area> e <link>.

Formatos de mídia suportados pelos elementos vídeo e áudio do HTML

Os elementos <audio> e <video> permitem que você reproduza mídias de áudio e vídeo. Estes elementos fornecem uma alternativa nativa para o navegador reproduzir recursos similares aos encontrados no Adobe Flash e outros plug-ins.

Tipos de conteúdo HTML

O HTML é composto de uma grande diversidade de conteúdos, e cada um pode ser usado em certos contextos e não ser permitido em outros. Da mesma forma, cada um tem um conjunto de outras categorias de conteúdos que podem ou não serem usadas dentro deles. Este é um guia destas categorias.

Os Modos Quirks e o Modo Padrão

Informações sobre a história dos Modos Quirks e o Modo padrão.

Tópicos relacionados
Aplicando cores em elementos HTML usando CSS

Este artigo mostra as principais formas de se usar CSS para adicionar cores ao seu conteúdo HTML, mostrando que partes dos documentos HTML podem ser coloridas e quais propriedades utilizar. Inclui exemplos e links para ferramentas de palette-building, entre outros.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 17 de dez. de 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nHTMLHTML (HyperText Markup Language — «язык гипертекстовой разметки») — самый базовый строительный блок Веба. Он определяет содержание и структуру веб-контента. Другие технологии, помимо HTML, обычно используются для описания внешнего вида/представления (CSS) или функциональности/поведения (JavaScript) веб-страницы.
Под гипертекстом ("hypertext") понимаются ссылки, которые соединяют веб-страницы друг с другом либо в пределах одного веб-сайта, либо между веб-сайтами. Ссылки являются фундаментальным аспектом Веба. Загружая контент в Интернет и связывая его со страницами, созданными другими людьми, вы становитесь активным участником Всемирной паутины.
HTML использует разметку ("markup") для отображения текста, изображений и другого контента в веб-браузере. HTML-разметка включает в себя специальные "элементы", такие как <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <output>, <progress>, <video> и многие другие.
HTML-элемент выделяется из прочего текста в документе с помощью "тегов", которые состоят из имени элемента окружённого "<" и ">". Имя элемента внутри тега не чувствительно к регистру. То есть, оно может быть написано в верхнем или нижнем регистре, или смешано. Например, тег <title> может быть записан как <Title>, <TITLE>, или любым другим способом.
Статьи, представленные ниже, могут помочь вам больше узнать о HTML.


Введение в HTML
Если вы новичок в веб-разработке, обязательно прочитайте нашу статью "Основы HTML", чтобы узнать, что такое HTML и как его использовать.


Руководства по HTML
Статьи о том, как использовать HTML, а также обучающие материалы и исчерпывающие примеры можно найти в разделе "Пространство изучения HTML".


Справка по HTML
В нашем обширном разделе "Справка по HTML" вы найдёте подробности о каждом элементе и атрибуте в HTML.

Руководства для начинающихНаше Пространство изучения HTML содержит множество модулей, которые обучают HTML с нуля — начальные знания не требуются.

Введение в HTML

Этот модуль закладывает основу, знакомя вас с важными понятиями и синтаксисом, такими как применение HTML к тексту, создание гиперссылок и использование HTML для построения веб-страницы.

Мультимедиа и встраивание

В этом модуле рассматривается, как использовать HTML для добавления мультимедиа на ваши веб-страницы, включая различные способы вставки изображений, а также для встраивания видео, аудио, и даже других веб-страниц целиком.

HTML-таблицы

Представление табличных данных на веб-странице в понятной, доступной форме может быть проблемой. Этот модуль охватывает базовую разметку таблиц, а также более сложные особенности, такие как добавление заголовков и описаний.

HTML-формы

Формы являются очень важной частью Веба — они предоставляют большую часть функциональности, необходимого для взаимодействия с веб-сайтами, например регистрация и вход в систему, отправка отзывов, покупка товаров, и многое другое. Этот модуль познакомит вас с созданием клиентских (client-side/front-end) частей форм.

Используйте HTML для решения распространённых задач.

Содержит ссылки на разделы, объясняющие как использовать HTML для решения самых распространённых задач при создании веб-страницы: работа с заголовками, добавление изображений или видео, выделение контента, создание простой формы и т.д.

Продвинутые темы
CORS: включённые изображения

Атрибут crossorigin в сочетании с соответствующим заголовком CORS, позволяет загружать изображения, определённые элементом <img>, из внешних источников и использовать в элементе <canvas>, как если бы они были загружены из текущего источника.

CORS: Настройки атрибутов

Некоторые HTML-элементы, предоставляющие поддержку CORS, такие как <img> или <video>, имеют атрибут crossorigin (свойство crossOrigin), который позволяет вам настраивать CORS-запросы для получаемых элементом данных.

Управление фокусом в HTML

DOM-Атрибут activeElement и DOM-метод hasFocus() помогают отслеживать и контролировать взаимодействие пользователя с элементами на веб-странице.

Предварительная загрузка контента с помощью rel="preload"

Значение preload атрибута rel элемента <link> позволяет писать декларативные fetch-запросы в HTML <head>, указывая ресурсы, которые потребуются вашим страницам сразу после загрузки и, следовательно, которые вы хотите начать предварительно загружать на раннем этапе жизненного цикла страницы, прежде чем браузером запустится основной механизм рендеринга (отрисовки). Это гарантирует, что они станут доступными раньше и с меньшей вероятностью заблокируют первый рендеринг страницы, что приведёт к улучшению производительности. В этой статье приведено начальное руководство по работе с preload (предзагрузкой).

Справочники
Справка по HTML

HTML состоит из элементов, каждый из которых может быть изменён некоторым количеством атрибутов. HTML-документы связаны между собой ссылками.

Справка по HTML-элементам

Просмотр списка всех элементов HTML.

Справка по HTML-атрибутам

У элементов в HTML есть атрибуты. Это дополнительные величины, которые настраивают элементы или управляют их поведением различными способами.

Глобальные атрибуты

Глобальные атрибуты могут быть указаны для всех элементов HTML, даже тех, которые не указаны в стандарте. Это означает, что любые нестандартные элементы обязаны по-прежнему разрешать эти атрибуты, даже если эти элементы делают документ несовместимым с HTML5.

Строчные и блочные элементы

Элементы HTML являются обычно "строчными" или "блочными". Строчный элемент занимает только пространство, ограниченное тегами, которые его определяют. Блочный элемент занимает все пространство своего родительского элемента (контейнера), тем самым создавая "блок".

Типы ссылок

В HTML различные типы ссылок могут использоваться для установления и определения связи между двумя документами. Элементы-ссылки, типы которых могут быть заданы, включают в себя <a>, <area> и <link>.

Поддержка медиа-форматов с помощью HTML-элементов audio и video

Элементы <audio> и <video> позволяют вам воспроизводить аудио и видео. Эти элементы предоставляют браузерную альтернативу аналогичным возможностям, которые есть в Adobe Flash и других плагинах.

Виды HTML-контента

HTML состоит из нескольких видов контента, каждый из которых разрешено использовать в определённых контекстах и запрещено в других. Так же, у каждого есть набор других категорий контента, которые они могут содержать, и элементы, которые могут или не могут использоваться в них. Это руководство по таким категориям.

Режим совместимости и стандартный режим

Историческая справка по режиму совместимости и стандартному режиму.

Похожие темы
Применение цвета к HTML-элементам с помощью CSS

В этой статье описывается большинство способов использования CSS для добавления цвета к HTML-контенту, а также перечисляется, какие части документов HTML могут быть окрашены, и какие свойства CSS при этом используются. Включает примеры, ссылки на инструменты для создания палитры и многое другое.\n\nHTMLHTML (HyperText Markup Language — «язык гипертекстовой разметки») — самый базовый строительный блок Веба. Он определяет содержание и структуру веб-контента. Другие технологии, помимо HTML, обычно используются для описания внешнего вида/представления (CSS) или функциональности/поведения (JavaScript) веб-страницы.
Под гипертекстом ("hypertext") понимаются ссылки, которые соединяют веб-страницы друг с другом либо в пределах одного веб-сайта, либо между веб-сайтами. Ссылки являются фундаментальным аспектом Веба. Загружая контент в Интернет и связывая его со страницами, созданными другими людьми, вы становитесь активным участником Всемирной паутины.
HTML использует разметку ("markup") для отображения текста, изображений и другого контента в веб-браузере. HTML-разметка включает в себя специальные "элементы", такие как <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <output>, <progress>, <video> и многие другие.
HTML-элемент выделяется из прочего текста в документе с помощью "тегов", которые состоят из имени элемента окружённого "<" и ">". Имя элемента внутри тега не чувствительно к регистру. То есть, оно может быть написано в верхнем или нижнем регистре, или смешано. Например, тег <title> может быть записан как <Title>, <TITLE>, или любым другим способом.
Статьи, представленные ниже, могут помочь вам больше узнать о HTML.


Введение в HTML
Если вы новичок в веб-разработке, обязательно прочитайте нашу статью "Основы HTML", чтобы узнать, что такое HTML и как его использовать.


Руководства по HTML
Статьи о том, как использовать HTML, а также обучающие материалы и исчерпывающие примеры можно найти в разделе "Пространство изучения HTML".


Справка по HTML
В нашем обширном разделе "Справка по HTML" вы найдёте подробности о каждом элементе и атрибуте в HTML.

Руководства для начинающихНаше Пространство изучения HTML содержит множество модулей, которые обучают HTML с нуля — начальные знания не требуются.

Введение в HTML

Этот модуль закладывает основу, знакомя вас с важными понятиями и синтаксисом, такими как применение HTML к тексту, создание гиперссылок и использование HTML для построения веб-страницы.

Мультимедиа и встраивание

В этом модуле рассматривается, как использовать HTML для добавления мультимедиа на ваши веб-страницы, включая различные способы вставки изображений, а также для встраивания видео, аудио, и даже других веб-страниц целиком.

HTML-таблицы

Представление табличных данных на веб-странице в понятной, доступной форме может быть проблемой. Этот модуль охватывает базовую разметку таблиц, а также более сложные особенности, такие как добавление заголовков и описаний.

HTML-формы

Формы являются очень важной частью Веба — они предоставляют большую часть функциональности, необходимого для взаимодействия с веб-сайтами, например регистрация и вход в систему, отправка отзывов, покупка товаров, и многое другое. Этот модуль познакомит вас с созданием клиентских (client-side/front-end) частей форм.

Используйте HTML для решения распространённых задач.

Содержит ссылки на разделы, объясняющие как использовать HTML для решения самых распространённых задач при создании веб-страницы: работа с заголовками, добавление изображений или видео, выделение контента, создание простой формы и т.д.

Продвинутые темы
CORS: включённые изображения

Атрибут crossorigin в сочетании с соответствующим заголовком CORS, позволяет загружать изображения, определённые элементом <img>, из внешних источников и использовать в элементе <canvas>, как если бы они были загружены из текущего источника.

CORS: Настройки атрибутов

Некоторые HTML-элементы, предоставляющие поддержку CORS, такие как <img> или <video>, имеют атрибут crossorigin (свойство crossOrigin), который позволяет вам настраивать CORS-запросы для получаемых элементом данных.

Управление фокусом в HTML

DOM-Атрибут activeElement и DOM-метод hasFocus() помогают отслеживать и контролировать взаимодействие пользователя с элементами на веб-странице.

Предварительная загрузка контента с помощью rel="preload"

Значение preload атрибута rel элемента <link> позволяет писать декларативные fetch-запросы в HTML <head>, указывая ресурсы, которые потребуются вашим страницам сразу после загрузки и, следовательно, которые вы хотите начать предварительно загружать на раннем этапе жизненного цикла страницы, прежде чем браузером запустится основной механизм рендеринга (отрисовки). Это гарантирует, что они станут доступными раньше и с меньшей вероятностью заблокируют первый рендеринг страницы, что приведёт к улучшению производительности. В этой статье приведено начальное руководство по работе с preload (предзагрузкой).

Справочники
Справка по HTML

HTML состоит из элементов, каждый из которых может быть изменён некоторым количеством атрибутов. HTML-документы связаны между собой ссылками.

Справка по HTML-элементам

Просмотр списка всех элементов HTML.

Справка по HTML-атрибутам

У элементов в HTML есть атрибуты. Это дополнительные величины, которые настраивают элементы или управляют их поведением различными способами.

Глобальные атрибуты

Глобальные атрибуты могут быть указаны для всех элементов HTML, даже тех, которые не указаны в стандарте. Это означает, что любые нестандартные элементы обязаны по-прежнему разрешать эти атрибуты, даже если эти элементы делают документ несовместимым с HTML5.

Строчные и блочные элементы

Элементы HTML являются обычно "строчными" или "блочными". Строчный элемент занимает только пространство, ограниченное тегами, которые его определяют. Блочный элемент занимает все пространство своего родительского элемента (контейнера), тем самым создавая "блок".

Типы ссылок

В HTML различные типы ссылок могут использоваться для установления и определения связи между двумя документами. Элементы-ссылки, типы которых могут быть заданы, включают в себя <a>, <area> и <link>.

Поддержка медиа-форматов с помощью HTML-элементов audio и video

Элементы <audio> и <video> позволяют вам воспроизводить аудио и видео. Эти элементы предоставляют браузерную альтернативу аналогичным возможностям, которые есть в Adobe Flash и других плагинах.

Виды HTML-контента

HTML состоит из нескольких видов контента, каждый из которых разрешено использовать в определённых контекстах и запрещено в других. Так же, у каждого есть набор других категорий контента, которые они могут содержать, и элементы, которые могут или не могут использоваться в них. Это руководство по таким категориям.

Режим совместимости и стандартный режим

Историческая справка по режиму совместимости и стандартному режиму.

Похожие темы
Применение цвета к HTML-элементам с помощью CSS

В этой статье описывается большинство способов использования CSS для добавления цвета к HTML-контенту, а также перечисляется, какие части документов HTML могут быть окрашены, и какие свойства CSS при этом используются. Включает примеры, ссылки на инструменты для создания палитры и многое другое.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 15 апр. 2025 г. by MDN contributors.View this page on GitHub • Report a problem with this content\n\nHTMLHTML (HyperText Markup Language — «язык гипертекстовой разметки») — самый базовый строительный блок Веба. Он определяет содержание и структуру веб-контента. Другие технологии, помимо HTML, обычно используются для описания внешнего вида/представления (CSS) или функциональности/поведения (JavaScript) веб-страницы.
Под гипертекстом ("hypertext") понимаются ссылки, которые соединяют веб-страницы друг с другом либо в пределах одного веб-сайта, либо между веб-сайтами. Ссылки являются фундаментальным аспектом Веба. Загружая контент в Интернет и связывая его со страницами, созданными другими людьми, вы становитесь активным участником Всемирной паутины.
HTML использует разметку ("markup") для отображения текста, изображений и другого контента в веб-браузере. HTML-разметка включает в себя специальные "элементы", такие как <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <output>, <progress>, <video> и многие другие.
HTML-элемент выделяется из прочего текста в документе с помощью "тегов", которые состоят из имени элемента окружённого "<" и ">". Имя элемента внутри тега не чувствительно к регистру. То есть, оно может быть написано в верхнем или нижнем регистре, или смешано. Например, тег <title> может быть записан как <Title>, <TITLE>, или любым другим способом.
Статьи, представленные ниже, могут помочь вам больше узнать о HTML.


Введение в HTML
Если вы новичок в веб-разработке, обязательно прочитайте нашу статью "Основы HTML", чтобы узнать, что такое HTML и как его использовать.


Руководства по HTML
Статьи о том, как использовать HTML, а также обучающие материалы и исчерпывающие примеры можно найти в разделе "Пространство изучения HTML".


Справка по HTML
В нашем обширном разделе "Справка по HTML" вы найдёте подробности о каждом элементе и атрибуте в HTML.

Руководства для начинающихНаше Пространство изучения HTML содержит множество модулей, которые обучают HTML с нуля — начальные знания не требуются.

Введение в HTML

Этот модуль закладывает основу, знакомя вас с важными понятиями и синтаксисом, такими как применение HTML к тексту, создание гиперссылок и использование HTML для построения веб-страницы.

Мультимедиа и встраивание

В этом модуле рассматривается, как использовать HTML для добавления мультимедиа на ваши веб-страницы, включая различные способы вставки изображений, а также для встраивания видео, аудио, и даже других веб-страниц целиком.

HTML-таблицы

Представление табличных данных на веб-странице в понятной, доступной форме может быть проблемой. Этот модуль охватывает базовую разметку таблиц, а также более сложные особенности, такие как добавление заголовков и описаний.

HTML-формы

Формы являются очень важной частью Веба — они предоставляют большую часть функциональности, необходимого для взаимодействия с веб-сайтами, например регистрация и вход в систему, отправка отзывов, покупка товаров, и многое другое. Этот модуль познакомит вас с созданием клиентских (client-side/front-end) частей форм.

Используйте HTML для решения распространённых задач.

Содержит ссылки на разделы, объясняющие как использовать HTML для решения самых распространённых задач при создании веб-страницы: работа с заголовками, добавление изображений или видео, выделение контента, создание простой формы и т.д.

Продвинутые темы
CORS: включённые изображения

Атрибут crossorigin в сочетании с соответствующим заголовком CORS, позволяет загружать изображения, определённые элементом <img>, из внешних источников и использовать в элементе <canvas>, как если бы они были загружены из текущего источника.

CORS: Настройки атрибутов

Некоторые HTML-элементы, предоставляющие поддержку CORS, такие как <img> или <video>, имеют атрибут crossorigin (свойство crossOrigin), который позволяет вам настраивать CORS-запросы для получаемых элементом данных.

Управление фокусом в HTML

DOM-Атрибут activeElement и DOM-метод hasFocus() помогают отслеживать и контролировать взаимодействие пользователя с элементами на веб-странице.

Предварительная загрузка контента с помощью rel="preload"

Значение preload атрибута rel элемента <link> позволяет писать декларативные fetch-запросы в HTML <head>, указывая ресурсы, которые потребуются вашим страницам сразу после загрузки и, следовательно, которые вы хотите начать предварительно загружать на раннем этапе жизненного цикла страницы, прежде чем браузером запустится основной механизм рендеринга (отрисовки). Это гарантирует, что они станут доступными раньше и с меньшей вероятностью заблокируют первый рендеринг страницы, что приведёт к улучшению производительности. В этой статье приведено начальное руководство по работе с preload (предзагрузкой).

Справочники
Справка по HTML

HTML состоит из элементов, каждый из которых может быть изменён некоторым количеством атрибутов. HTML-документы связаны между собой ссылками.

Справка по HTML-элементам

Просмотр списка всех элементов HTML.

Справка по HTML-атрибутам

У элементов в HTML есть атрибуты. Это дополнительные величины, которые настраивают элементы или управляют их поведением различными способами.

Глобальные атрибуты

Глобальные атрибуты могут быть указаны для всех элементов HTML, даже тех, которые не указаны в стандарте. Это означает, что любые нестандартные элементы обязаны по-прежнему разрешать эти атрибуты, даже если эти элементы делают документ несовместимым с HTML5.

Строчные и блочные элементы

Элементы HTML являются обычно "строчными" или "блочными". Строчный элемент занимает только пространство, ограниченное тегами, которые его определяют. Блочный элемент занимает все пространство своего родительского элемента (контейнера), тем самым создавая "блок".

Типы ссылок

В HTML различные типы ссылок могут использоваться для установления и определения связи между двумя документами. Элементы-ссылки, типы которых могут быть заданы, включают в себя <a>, <area> и <link>.

Поддержка медиа-форматов с помощью HTML-элементов audio и video

Элементы <audio> и <video> позволяют вам воспроизводить аудио и видео. Эти элементы предоставляют браузерную альтернативу аналогичным возможностям, которые есть в Adobe Flash и других плагинах.

Виды HTML-контента

HTML состоит из нескольких видов контента, каждый из которых разрешено использовать в определённых контекстах и запрещено в других. Так же, у каждого есть набор других категорий контента, которые они могут содержать, и элементы, которые могут или не могут использоваться в них. Это руководство по таким категориям.

Режим совместимости и стандартный режим

Историческая справка по режиму совместимости и стандартному режиму.

Похожие темы
Применение цвета к HTML-элементам с помощью CSS

В этой статье описывается большинство способов использования CSS для добавления цвета к HTML-контенту, а также перечисляется, какие части документов HTML могут быть окрашены, и какие свойства CSS при этом используются. Включает примеры, ссылки на инструменты для создания палитры и многое другое.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 15 апр. 2025 г. by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\n