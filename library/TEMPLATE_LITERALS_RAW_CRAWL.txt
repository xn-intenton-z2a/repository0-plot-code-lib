Template literals (Template strings)Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackTemplate literals are literals delimited with backtick (`) characters, allowing for multi-line strings, string interpolation with embedded expressions, and special constructs called tagged templates.
Template literals are sometimes informally called template strings, because they are used most commonly for string interpolation (to create strings by doing substitution of placeholders). However, a tagged template literal may not result in a string; it can be used with a custom tag function to perform whatever operations you want on the different parts of the template literal.Syntaxjs`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tagFunction`string text ${expression} string text`
Parameters
string text

The string text that will become part of the template literal. Almost all characters are allowed literally, including line breaks and other whitespace characters. However, invalid escape sequences will cause a syntax error, unless a tag function is used.

expression

An expression to be inserted in the current position, whose value is converted to a string or passed to tagFunction.

tagFunction

If specified, it will be called with the template strings array and substitution expressions, and the return value becomes the value of the template literal. See tagged templates.

DescriptionTemplate literals are enclosed by backtick (`) characters instead of double or single quotes.
Along with having normal strings, template literals can also contain other parts called placeholders, which are embedded expressions delimited by a dollar sign and curly braces: ${expression}. The strings and placeholders get passed to a function — either a default function, or a function you supply. The default function (when you don't supply your own) just performs string interpolation to do substitution of the placeholders and then concatenate the parts into a single string.
To supply a function of your own, precede the template literal with a function name; the result is called a tagged template. In that case, the template literal is passed to your tag function, where you can then perform whatever operations you want on the different parts of the template literal.
To escape a backtick in a template literal, put a backslash (\) before the backtick.
js`\`` === "`"; // true

Dollar signs can be escaped as well to prevent interpolation.
js`\${1}` === "${1}"; // true
Multi-line stringsAny newline characters inserted in the source are part of the template literal.
Using normal strings, you would have to use the following syntax in order to get multi-line strings:
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
// string text line 2"

Using template literals, you can do the same with this:
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"

Like normal string literals, you can write a single-line string across multiple lines for source code readability, by escaping the newline with a backslash (\):
jsconsole.log(`string text line 1 \
string text line 2`);
// "string text line 1 string text line 2"
String interpolationWithout template literals, when you want to combine output from expressions with strings, you'd concatenate them using the addition operator +:
jsconst a = 5;
const b = 10;
console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");
// "Fifteen is 15 and
// not 20."

That can be hard to read – especially when you have multiple expressions.
With template literals, you can avoid the concatenation operator — and improve the readability of your code — by using placeholders of the form ${expression} to perform substitutions for embedded expressions:
jsconst a = 5;
const b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
// "Fifteen is 15 and
// not 20."

Note that there's a mild difference between the two syntaxes. Template literals coerce their expressions directly to strings, while addition coerces its operands to primitives first. For more information, see the reference page for the + operator.Nesting templatesIn certain cases, nesting a template is the easiest (and perhaps more readable) way to have configurable strings. Within a backtick-delimited template, it is simple to allow inner backticks by using them inside an ${expression} placeholder within the template.
For example, without template literals, if you wanted to return a certain value based on a particular condition, you could do something like the following:
jslet classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

With a template literal but without nesting, you could do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

With nesting of template literals, you can do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
Tagged templatesA more advanced form of template literals are tagged templates.
Tags allow you to parse template literals with a function. The first argument of a tag function contains an array of string values. The remaining arguments are related to the expressions.
The tag function can then perform whatever operations on these arguments you wish, and return the manipulated string. (Alternatively, it can return something completely different, as described in one of the following examples.)
The name of the function used for the tag can be whatever you want.
jsconst person = "Mike";
const age = 28;

function myTag(strings, personExp, ageExp) {
  const str0 = strings[0]; // "That "
  const str1 = strings[1]; // " is a "
  const str2 = strings[2]; // "."

  const ageStr = ageExp < 100 ? "youngster" : "centenarian";

  // We can even return a string built using a template literal
  return `${str0}${personExp}${str1}${ageStr}${str2}`;
}

const output = myTag`That ${person} is a ${age}.`;

console.log(output);
// That Mike is a youngster.

The tag does not have to be a plain identifier. You can use any expression with precedence greater than 16, which includes property access, function call, new expression, or even another tagged template literal.
jsconsole.log`Hello`; // [ 'Hello' ]
console.log.bind(1, 2)`Hello`; // 2 [ 'Hello' ]
new Function("console.log(arguments)")`Hello`; // [Arguments] { '0': [ 'Hello' ] }

function recursive(strings, ...values) {
  console.log(strings, values);
  return recursive;
}
recursive`Hello``World`;
// [ 'Hello' ] []
// [ 'World' ] []

While technically permitted by the syntax, untagged template literals are strings and will throw a TypeError when chained.
jsconsole.log(`Hello``World`); // TypeError: "Hello" is not a function

The only exception is optional chaining, which will throw a syntax error.
jsconsole.log?.`Hello`; // SyntaxError: Invalid tagged template on optional chain
console?.log`Hello`; // SyntaxError: Invalid tagged template on optional chain

Note that these two expressions are still parsable. This means they would not be subject to automatic semicolon insertion, which will only insert semicolons to fix code that's otherwise unparsable.
js// Still a syntax error
const a = console?.log
`Hello`

Tag functions don't even need to return a string!
jsfunction template(strings, ...keys) {
  return (...values) => {
    const dict = values[values.length - 1] || {};
    const result = [strings[0]];
    keys.forEach((key, i) => {
      const value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

const t1Closure = template`${0}${1}${0}!`;
// const t1Closure = template(["","","","!"],0,1,0);
t1Closure("Y", "A"); // "YAY!"

const t2Closure = template`${0} ${"foo"}!`;
// const t2Closure = template([""," ","!"],0,"foo");
t2Closure("Hello", { foo: "World" }); // "Hello World!"

const t3Closure = template`I'm ${"name"}. I'm almost ${"age"} years old.`;
// const t3Closure = template(["I'm ", ". I'm almost ", " years old."], "name", "age");
t3Closure("foo", { name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."
t3Closure({ name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."

The first argument received by the tag function is an array of strings. For any template literal, its length is equal to the number of substitutions (occurrences of ${…}) plus one, and is therefore always non-empty.
For any particular tagged template literal expression, the tag function will always be called with the exact same literal array, no matter how many times the literal is evaluated.
jsconst callHistory = [];

function tag(strings, ...values) {
  callHistory.push(strings);
  // Return a freshly made object
  return {};
}

function evaluateLiteral() {
  return tag`Hello, ${"world"}!`;
}

console.log(evaluateLiteral() === evaluateLiteral()); // false; each time `tag` is called, it returns a new object
console.log(callHistory[0] === callHistory[1]); // true; all evaluations of the same tagged literal would pass in the same strings array

This allows the tag to cache the result based on the identity of its first argument. To further ensure the array value's stability, the first argument and its raw property are both frozen, so you can't mutate them in any way.Raw stringsThe special raw property, available on the first argument to the tag function, allows you to access the raw strings as they were entered, without processing escape sequences.
jsfunction tag(strings) {
  console.log(strings.raw[0]);
}

tag`string text line 1 \n string text line 2`;
// Logs "string text line 1 \n string text line 2",
// including the two characters '\' and 'n'

In addition, the String.raw() method exists to create raw strings just like the default template function and string concatenation would create.
jsconst str = String.raw`Hi\n${2 + 3}!`;
// "Hi\\n5!"

str.length;
// 6

Array.from(str).join(",");
// "H,i,\\,n,5,!"

String.raw functions like an "identity" tag if the literal doesn't contain any escape sequences. In case you want an actual identity tag that always works as if the literal is untagged, you can make a custom function that passes the "cooked" (i.e., escape sequences are processed) literal array to String.raw, pretending they are raw strings.
jsconst identity = (strings, ...values) =>
  String.raw({ raw: strings }, ...values);
console.log(identity`Hi\n${2 + 3}!`);
// Hi
// 5!

This is useful for many tools which give special treatment to literals tagged by a particular name.
jsconst html = (strings, ...values) => String.raw({ raw: strings }, ...values);
// Some formatters will format this literal's content as HTML
const doc = html`<!doctype html>
  <html lang="en-US">
    <head>
      <title>Hello</title>
    </head>
    <body>
      <h1>Hello world!</h1>
    </body>
  </html>`;
Tagged templates and escape sequencesIn normal template literals, the escape sequences in string literals are all allowed. Any other non-well-formed escape sequence is a syntax error. This includes:

\ followed by any decimal digit other than 0, or \0 followed by a decimal digit; for example \9 and \07 (which is a deprecated syntax)
\x followed by fewer than two hex digits (including none); for example \xz
\u not followed by { and followed by fewer than four hex digits (including none); for example \uz
\u{} enclosing an invalid Unicode code point — it contains a non-hex digit, or its value is greater than 10FFFF; for example \u{110000} and \u{z}


Note: \ followed by other characters, while they may be useless since nothing is escaped, are not syntax errors.

However, this is problematic for tagged templates, which, in addition to the "cooked" literal, also have access to the raw literals (escape sequences are preserved as-is).
Tagged templates enable the embedding of arbitrary string content, where escape sequences may follow a different syntax. Consider for an example where we embed LaTeX source text in JavaScript via String.raw. We want to still be able to use LaTeX macros that start with u or x without following JavaScript syntax restrictions. Therefore, the syntax restriction of well-formed escape sequences is removed from tagged templates. The example below uses MathJax to render LaTeX in one element:
jsconst node = document.getElementById("formula");
MathJax.typesetClear([node]);
// Throws in older ECMAScript versions (ES2016 and earlier)
// SyntaxError: malformed Unicode character escape sequence
node.textContent = String.raw`$\underline{u}$`;
MathJax.typesetPromise([node]);

However, illegal escape sequences must still be represented in the "cooked" representation. They will show up as undefined element in the "cooked" array:
jsfunction log(str) {
  console.log("Cooked:", str[0]);
  console.log("Raw:", str.raw[0]);
}

log`\unicode`;
// Cooked: undefined
// Raw: \unicode

Note that the escape-sequence restriction is only dropped from tagged templates, but not from untagged template literals:
jsconst bad = `bad escape sequence: \unicode`;
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-template-literalsBrowser compatibilitySee also
Numbers and strings guide
String
String.raw()
Lexical grammar
ES6 in Depth: Template strings on hacks.mozilla.org (2015)\n\nTemplate literals (Template strings)Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackTemplate literals are literals delimited with backtick (`) characters, allowing for multi-line strings, string interpolation with embedded expressions, and special constructs called tagged templates.
Template literals are sometimes informally called template strings, because they are used most commonly for string interpolation (to create strings by doing substitution of placeholders). However, a tagged template literal may not result in a string; it can be used with a custom tag function to perform whatever operations you want on the different parts of the template literal.Syntaxjs`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tagFunction`string text ${expression} string text`
Parameters
string text

The string text that will become part of the template literal. Almost all characters are allowed literally, including line breaks and other whitespace characters. However, invalid escape sequences will cause a syntax error, unless a tag function is used.

expression

An expression to be inserted in the current position, whose value is converted to a string or passed to tagFunction.

tagFunction

If specified, it will be called with the template strings array and substitution expressions, and the return value becomes the value of the template literal. See tagged templates.

DescriptionTemplate literals are enclosed by backtick (`) characters instead of double or single quotes.
Along with having normal strings, template literals can also contain other parts called placeholders, which are embedded expressions delimited by a dollar sign and curly braces: ${expression}. The strings and placeholders get passed to a function — either a default function, or a function you supply. The default function (when you don't supply your own) just performs string interpolation to do substitution of the placeholders and then concatenate the parts into a single string.
To supply a function of your own, precede the template literal with a function name; the result is called a tagged template. In that case, the template literal is passed to your tag function, where you can then perform whatever operations you want on the different parts of the template literal.
To escape a backtick in a template literal, put a backslash (\) before the backtick.
js`\`` === "`"; // true

Dollar signs can be escaped as well to prevent interpolation.
js`\${1}` === "${1}"; // true
Multi-line stringsAny newline characters inserted in the source are part of the template literal.
Using normal strings, you would have to use the following syntax in order to get multi-line strings:
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
// string text line 2"

Using template literals, you can do the same with this:
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"

Like normal string literals, you can write a single-line string across multiple lines for source code readability, by escaping the newline with a backslash (\):
jsconsole.log(`string text line 1 \
string text line 2`);
// "string text line 1 string text line 2"
String interpolationWithout template literals, when you want to combine output from expressions with strings, you'd concatenate them using the addition operator +:
jsconst a = 5;
const b = 10;
console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");
// "Fifteen is 15 and
// not 20."

That can be hard to read – especially when you have multiple expressions.
With template literals, you can avoid the concatenation operator — and improve the readability of your code — by using placeholders of the form ${expression} to perform substitutions for embedded expressions:
jsconst a = 5;
const b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
// "Fifteen is 15 and
// not 20."

Note that there's a mild difference between the two syntaxes. Template literals coerce their expressions directly to strings, while addition coerces its operands to primitives first. For more information, see the reference page for the + operator.Nesting templatesIn certain cases, nesting a template is the easiest (and perhaps more readable) way to have configurable strings. Within a backtick-delimited template, it is simple to allow inner backticks by using them inside an ${expression} placeholder within the template.
For example, without template literals, if you wanted to return a certain value based on a particular condition, you could do something like the following:
jslet classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

With a template literal but without nesting, you could do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

With nesting of template literals, you can do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
Tagged templatesA more advanced form of template literals are tagged templates.
Tags allow you to parse template literals with a function. The first argument of a tag function contains an array of string values. The remaining arguments are related to the expressions.
The tag function can then perform whatever operations on these arguments you wish, and return the manipulated string. (Alternatively, it can return something completely different, as described in one of the following examples.)
The name of the function used for the tag can be whatever you want.
jsconst person = "Mike";
const age = 28;

function myTag(strings, personExp, ageExp) {
  const str0 = strings[0]; // "That "
  const str1 = strings[1]; // " is a "
  const str2 = strings[2]; // "."

  const ageStr = ageExp < 100 ? "youngster" : "centenarian";

  // We can even return a string built using a template literal
  return `${str0}${personExp}${str1}${ageStr}${str2}`;
}

const output = myTag`That ${person} is a ${age}.`;

console.log(output);
// That Mike is a youngster.

The tag does not have to be a plain identifier. You can use any expression with precedence greater than 16, which includes property access, function call, new expression, or even another tagged template literal.
jsconsole.log`Hello`; // [ 'Hello' ]
console.log.bind(1, 2)`Hello`; // 2 [ 'Hello' ]
new Function("console.log(arguments)")`Hello`; // [Arguments] { '0': [ 'Hello' ] }

function recursive(strings, ...values) {
  console.log(strings, values);
  return recursive;
}
recursive`Hello``World`;
// [ 'Hello' ] []
// [ 'World' ] []

While technically permitted by the syntax, untagged template literals are strings and will throw a TypeError when chained.
jsconsole.log(`Hello``World`); // TypeError: "Hello" is not a function

The only exception is optional chaining, which will throw a syntax error.
jsconsole.log?.`Hello`; // SyntaxError: Invalid tagged template on optional chain
console?.log`Hello`; // SyntaxError: Invalid tagged template on optional chain

Note that these two expressions are still parsable. This means they would not be subject to automatic semicolon insertion, which will only insert semicolons to fix code that's otherwise unparsable.
js// Still a syntax error
const a = console?.log
`Hello`

Tag functions don't even need to return a string!
jsfunction template(strings, ...keys) {
  return (...values) => {
    const dict = values[values.length - 1] || {};
    const result = [strings[0]];
    keys.forEach((key, i) => {
      const value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

const t1Closure = template`${0}${1}${0}!`;
// const t1Closure = template(["","","","!"],0,1,0);
t1Closure("Y", "A"); // "YAY!"

const t2Closure = template`${0} ${"foo"}!`;
// const t2Closure = template([""," ","!"],0,"foo");
t2Closure("Hello", { foo: "World" }); // "Hello World!"

const t3Closure = template`I'm ${"name"}. I'm almost ${"age"} years old.`;
// const t3Closure = template(["I'm ", ". I'm almost ", " years old."], "name", "age");
t3Closure("foo", { name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."
t3Closure({ name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."

The first argument received by the tag function is an array of strings. For any template literal, its length is equal to the number of substitutions (occurrences of ${…}) plus one, and is therefore always non-empty.
For any particular tagged template literal expression, the tag function will always be called with the exact same literal array, no matter how many times the literal is evaluated.
jsconst callHistory = [];

function tag(strings, ...values) {
  callHistory.push(strings);
  // Return a freshly made object
  return {};
}

function evaluateLiteral() {
  return tag`Hello, ${"world"}!`;
}

console.log(evaluateLiteral() === evaluateLiteral()); // false; each time `tag` is called, it returns a new object
console.log(callHistory[0] === callHistory[1]); // true; all evaluations of the same tagged literal would pass in the same strings array

This allows the tag to cache the result based on the identity of its first argument. To further ensure the array value's stability, the first argument and its raw property are both frozen, so you can't mutate them in any way.Raw stringsThe special raw property, available on the first argument to the tag function, allows you to access the raw strings as they were entered, without processing escape sequences.
jsfunction tag(strings) {
  console.log(strings.raw[0]);
}

tag`string text line 1 \n string text line 2`;
// Logs "string text line 1 \n string text line 2",
// including the two characters '\' and 'n'

In addition, the String.raw() method exists to create raw strings just like the default template function and string concatenation would create.
jsconst str = String.raw`Hi\n${2 + 3}!`;
// "Hi\\n5!"

str.length;
// 6

Array.from(str).join(",");
// "H,i,\\,n,5,!"

String.raw functions like an "identity" tag if the literal doesn't contain any escape sequences. In case you want an actual identity tag that always works as if the literal is untagged, you can make a custom function that passes the "cooked" (i.e., escape sequences are processed) literal array to String.raw, pretending they are raw strings.
jsconst identity = (strings, ...values) =>
  String.raw({ raw: strings }, ...values);
console.log(identity`Hi\n${2 + 3}!`);
// Hi
// 5!

This is useful for many tools which give special treatment to literals tagged by a particular name.
jsconst html = (strings, ...values) => String.raw({ raw: strings }, ...values);
// Some formatters will format this literal's content as HTML
const doc = html`<!doctype html>
  <html lang="en-US">
    <head>
      <title>Hello</title>
    </head>
    <body>
      <h1>Hello world!</h1>
    </body>
  </html>`;
Tagged templates and escape sequencesIn normal template literals, the escape sequences in string literals are all allowed. Any other non-well-formed escape sequence is a syntax error. This includes:

\ followed by any decimal digit other than 0, or \0 followed by a decimal digit; for example \9 and \07 (which is a deprecated syntax)
\x followed by fewer than two hex digits (including none); for example \xz
\u not followed by { and followed by fewer than four hex digits (including none); for example \uz
\u{} enclosing an invalid Unicode code point — it contains a non-hex digit, or its value is greater than 10FFFF; for example \u{110000} and \u{z}


Note: \ followed by other characters, while they may be useless since nothing is escaped, are not syntax errors.

However, this is problematic for tagged templates, which, in addition to the "cooked" literal, also have access to the raw literals (escape sequences are preserved as-is).
Tagged templates enable the embedding of arbitrary string content, where escape sequences may follow a different syntax. Consider for an example where we embed LaTeX source text in JavaScript via String.raw. We want to still be able to use LaTeX macros that start with u or x without following JavaScript syntax restrictions. Therefore, the syntax restriction of well-formed escape sequences is removed from tagged templates. The example below uses MathJax to render LaTeX in one element:
jsconst node = document.getElementById("formula");
MathJax.typesetClear([node]);
// Throws in older ECMAScript versions (ES2016 and earlier)
// SyntaxError: malformed Unicode character escape sequence
node.textContent = String.raw`$\underline{u}$`;
MathJax.typesetPromise([node]);

However, illegal escape sequences must still be represented in the "cooked" representation. They will show up as undefined element in the "cooked" array:
jsfunction log(str) {
  console.log("Cooked:", str[0]);
  console.log("Raw:", str.raw[0]);
}

log`\unicode`;
// Cooked: undefined
// Raw: \unicode

Note that the escape-sequence restriction is only dropped from tagged templates, but not from untagged template literals:
jsconst bad = `bad escape sequence: \unicode`;
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-template-literalsBrowser compatibilitySee also
Numbers and strings guide
String
String.raw()
Lexical grammar
ES6 in Depth: Template strings on hacks.mozilla.org (2015)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nTemplate literals (Template strings)Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackTemplate literals are literals delimited with backtick (`) characters, allowing for multi-line strings, string interpolation with embedded expressions, and special constructs called tagged templates.
Template literals are sometimes informally called template strings, because they are used most commonly for string interpolation (to create strings by doing substitution of placeholders). However, a tagged template literal may not result in a string; it can be used with a custom tag function to perform whatever operations you want on the different parts of the template literal.Syntaxjs`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tagFunction`string text ${expression} string text`
Parameters
string text

The string text that will become part of the template literal. Almost all characters are allowed literally, including line breaks and other whitespace characters. However, invalid escape sequences will cause a syntax error, unless a tag function is used.

expression

An expression to be inserted in the current position, whose value is converted to a string or passed to tagFunction.

tagFunction

If specified, it will be called with the template strings array and substitution expressions, and the return value becomes the value of the template literal. See tagged templates.

DescriptionTemplate literals are enclosed by backtick (`) characters instead of double or single quotes.
Along with having normal strings, template literals can also contain other parts called placeholders, which are embedded expressions delimited by a dollar sign and curly braces: ${expression}. The strings and placeholders get passed to a function — either a default function, or a function you supply. The default function (when you don't supply your own) just performs string interpolation to do substitution of the placeholders and then concatenate the parts into a single string.
To supply a function of your own, precede the template literal with a function name; the result is called a tagged template. In that case, the template literal is passed to your tag function, where you can then perform whatever operations you want on the different parts of the template literal.
To escape a backtick in a template literal, put a backslash (\) before the backtick.
js`\`` === "`"; // true

Dollar signs can be escaped as well to prevent interpolation.
js`\${1}` === "${1}"; // true
Multi-line stringsAny newline characters inserted in the source are part of the template literal.
Using normal strings, you would have to use the following syntax in order to get multi-line strings:
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
// string text line 2"

Using template literals, you can do the same with this:
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"

Like normal string literals, you can write a single-line string across multiple lines for source code readability, by escaping the newline with a backslash (\):
jsconsole.log(`string text line 1 \
string text line 2`);
// "string text line 1 string text line 2"
String interpolationWithout template literals, when you want to combine output from expressions with strings, you'd concatenate them using the addition operator +:
jsconst a = 5;
const b = 10;
console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");
// "Fifteen is 15 and
// not 20."

That can be hard to read – especially when you have multiple expressions.
With template literals, you can avoid the concatenation operator — and improve the readability of your code — by using placeholders of the form ${expression} to perform substitutions for embedded expressions:
jsconst a = 5;
const b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
// "Fifteen is 15 and
// not 20."

Note that there's a mild difference between the two syntaxes. Template literals coerce their expressions directly to strings, while addition coerces its operands to primitives first. For more information, see the reference page for the + operator.Nesting templatesIn certain cases, nesting a template is the easiest (and perhaps more readable) way to have configurable strings. Within a backtick-delimited template, it is simple to allow inner backticks by using them inside an ${expression} placeholder within the template.
For example, without template literals, if you wanted to return a certain value based on a particular condition, you could do something like the following:
jslet classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

With a template literal but without nesting, you could do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

With nesting of template literals, you can do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
Tagged templatesA more advanced form of template literals are tagged templates.
Tags allow you to parse template literals with a function. The first argument of a tag function contains an array of string values. The remaining arguments are related to the expressions.
The tag function can then perform whatever operations on these arguments you wish, and return the manipulated string. (Alternatively, it can return something completely different, as described in one of the following examples.)
The name of the function used for the tag can be whatever you want.
jsconst person = "Mike";
const age = 28;

function myTag(strings, personExp, ageExp) {
  const str0 = strings[0]; // "That "
  const str1 = strings[1]; // " is a "
  const str2 = strings[2]; // "."

  const ageStr = ageExp < 100 ? "youngster" : "centenarian";

  // We can even return a string built using a template literal
  return `${str0}${personExp}${str1}${ageStr}${str2}`;
}

const output = myTag`That ${person} is a ${age}.`;

console.log(output);
// That Mike is a youngster.

The tag does not have to be a plain identifier. You can use any expression with precedence greater than 16, which includes property access, function call, new expression, or even another tagged template literal.
jsconsole.log`Hello`; // [ 'Hello' ]
console.log.bind(1, 2)`Hello`; // 2 [ 'Hello' ]
new Function("console.log(arguments)")`Hello`; // [Arguments] { '0': [ 'Hello' ] }

function recursive(strings, ...values) {
  console.log(strings, values);
  return recursive;
}
recursive`Hello``World`;
// [ 'Hello' ] []
// [ 'World' ] []

While technically permitted by the syntax, untagged template literals are strings and will throw a TypeError when chained.
jsconsole.log(`Hello``World`); // TypeError: "Hello" is not a function

The only exception is optional chaining, which will throw a syntax error.
jsconsole.log?.`Hello`; // SyntaxError: Invalid tagged template on optional chain
console?.log`Hello`; // SyntaxError: Invalid tagged template on optional chain

Note that these two expressions are still parsable. This means they would not be subject to automatic semicolon insertion, which will only insert semicolons to fix code that's otherwise unparsable.
js// Still a syntax error
const a = console?.log
`Hello`

Tag functions don't even need to return a string!
jsfunction template(strings, ...keys) {
  return (...values) => {
    const dict = values[values.length - 1] || {};
    const result = [strings[0]];
    keys.forEach((key, i) => {
      const value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

const t1Closure = template`${0}${1}${0}!`;
// const t1Closure = template(["","","","!"],0,1,0);
t1Closure("Y", "A"); // "YAY!"

const t2Closure = template`${0} ${"foo"}!`;
// const t2Closure = template([""," ","!"],0,"foo");
t2Closure("Hello", { foo: "World" }); // "Hello World!"

const t3Closure = template`I'm ${"name"}. I'm almost ${"age"} years old.`;
// const t3Closure = template(["I'm ", ". I'm almost ", " years old."], "name", "age");
t3Closure("foo", { name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."
t3Closure({ name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."

The first argument received by the tag function is an array of strings. For any template literal, its length is equal to the number of substitutions (occurrences of ${…}) plus one, and is therefore always non-empty.
For any particular tagged template literal expression, the tag function will always be called with the exact same literal array, no matter how many times the literal is evaluated.
jsconst callHistory = [];

function tag(strings, ...values) {
  callHistory.push(strings);
  // Return a freshly made object
  return {};
}

function evaluateLiteral() {
  return tag`Hello, ${"world"}!`;
}

console.log(evaluateLiteral() === evaluateLiteral()); // false; each time `tag` is called, it returns a new object
console.log(callHistory[0] === callHistory[1]); // true; all evaluations of the same tagged literal would pass in the same strings array

This allows the tag to cache the result based on the identity of its first argument. To further ensure the array value's stability, the first argument and its raw property are both frozen, so you can't mutate them in any way.Raw stringsThe special raw property, available on the first argument to the tag function, allows you to access the raw strings as they were entered, without processing escape sequences.
jsfunction tag(strings) {
  console.log(strings.raw[0]);
}

tag`string text line 1 \n string text line 2`;
// Logs "string text line 1 \n string text line 2",
// including the two characters '\' and 'n'

In addition, the String.raw() method exists to create raw strings just like the default template function and string concatenation would create.
jsconst str = String.raw`Hi\n${2 + 3}!`;
// "Hi\\n5!"

str.length;
// 6

Array.from(str).join(",");
// "H,i,\\,n,5,!"

String.raw functions like an "identity" tag if the literal doesn't contain any escape sequences. In case you want an actual identity tag that always works as if the literal is untagged, you can make a custom function that passes the "cooked" (i.e., escape sequences are processed) literal array to String.raw, pretending they are raw strings.
jsconst identity = (strings, ...values) =>
  String.raw({ raw: strings }, ...values);
console.log(identity`Hi\n${2 + 3}!`);
// Hi
// 5!

This is useful for many tools which give special treatment to literals tagged by a particular name.
jsconst html = (strings, ...values) => String.raw({ raw: strings }, ...values);
// Some formatters will format this literal's content as HTML
const doc = html`<!doctype html>
  <html lang="en-US">
    <head>
      <title>Hello</title>
    </head>
    <body>
      <h1>Hello world!</h1>
    </body>
  </html>`;
Tagged templates and escape sequencesIn normal template literals, the escape sequences in string literals are all allowed. Any other non-well-formed escape sequence is a syntax error. This includes:

\ followed by any decimal digit other than 0, or \0 followed by a decimal digit; for example \9 and \07 (which is a deprecated syntax)
\x followed by fewer than two hex digits (including none); for example \xz
\u not followed by { and followed by fewer than four hex digits (including none); for example \uz
\u{} enclosing an invalid Unicode code point — it contains a non-hex digit, or its value is greater than 10FFFF; for example \u{110000} and \u{z}


Note: \ followed by other characters, while they may be useless since nothing is escaped, are not syntax errors.

However, this is problematic for tagged templates, which, in addition to the "cooked" literal, also have access to the raw literals (escape sequences are preserved as-is).
Tagged templates enable the embedding of arbitrary string content, where escape sequences may follow a different syntax. Consider for an example where we embed LaTeX source text in JavaScript via String.raw. We want to still be able to use LaTeX macros that start with u or x without following JavaScript syntax restrictions. Therefore, the syntax restriction of well-formed escape sequences is removed from tagged templates. The example below uses MathJax to render LaTeX in one element:
jsconst node = document.getElementById("formula");
MathJax.typesetClear([node]);
// Throws in older ECMAScript versions (ES2016 and earlier)
// SyntaxError: malformed Unicode character escape sequence
node.textContent = String.raw`$\underline{u}$`;
MathJax.typesetPromise([node]);

However, illegal escape sequences must still be represented in the "cooked" representation. They will show up as undefined element in the "cooked" array:
jsfunction log(str) {
  console.log("Cooked:", str[0]);
  console.log("Raw:", str.raw[0]);
}

log`\unicode`;
// Cooked: undefined
// Raw: \unicode

Note that the escape-sequence restriction is only dropped from tagged templates, but not from untagged template literals:
jsconst bad = `bad escape sequence: \unicode`;
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-template-literalsBrowser compatibilitySee also
Numbers and strings guide
String
String.raw()
Lexical grammar
ES6 in Depth: Template strings on hacks.mozilla.org (2015)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nTemplate literals (Template strings)Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackTemplate literals are literals delimited with backtick (`) characters, allowing for multi-line strings, string interpolation with embedded expressions, and special constructs called tagged templates.
Template literals are sometimes informally called template strings, because they are used most commonly for string interpolation (to create strings by doing substitution of placeholders). However, a tagged template literal may not result in a string; it can be used with a custom tag function to perform whatever operations you want on the different parts of the template literal.Syntaxjs`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tagFunction`string text ${expression} string text`
Parameters
string text

The string text that will become part of the template literal. Almost all characters are allowed literally, including line breaks and other whitespace characters. However, invalid escape sequences will cause a syntax error, unless a tag function is used.

expression

An expression to be inserted in the current position, whose value is converted to a string or passed to tagFunction.

tagFunction

If specified, it will be called with the template strings array and substitution expressions, and the return value becomes the value of the template literal. See tagged templates.

DescriptionTemplate literals are enclosed by backtick (`) characters instead of double or single quotes.
Along with having normal strings, template literals can also contain other parts called placeholders, which are embedded expressions delimited by a dollar sign and curly braces: ${expression}. The strings and placeholders get passed to a function — either a default function, or a function you supply. The default function (when you don't supply your own) just performs string interpolation to do substitution of the placeholders and then concatenate the parts into a single string.
To supply a function of your own, precede the template literal with a function name; the result is called a tagged template. In that case, the template literal is passed to your tag function, where you can then perform whatever operations you want on the different parts of the template literal.
To escape a backtick in a template literal, put a backslash (\) before the backtick.
js`\`` === "`"; // true

Dollar signs can be escaped as well to prevent interpolation.
js`\${1}` === "${1}"; // true
Multi-line stringsAny newline characters inserted in the source are part of the template literal.
Using normal strings, you would have to use the following syntax in order to get multi-line strings:
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
// string text line 2"

Using template literals, you can do the same with this:
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"

Like normal string literals, you can write a single-line string across multiple lines for source code readability, by escaping the newline with a backslash (\):
jsconsole.log(`string text line 1 \
string text line 2`);
// "string text line 1 string text line 2"
String interpolationWithout template literals, when you want to combine output from expressions with strings, you'd concatenate them using the addition operator +:
jsconst a = 5;
const b = 10;
console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");
// "Fifteen is 15 and
// not 20."

That can be hard to read – especially when you have multiple expressions.
With template literals, you can avoid the concatenation operator — and improve the readability of your code — by using placeholders of the form ${expression} to perform substitutions for embedded expressions:
jsconst a = 5;
const b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
// "Fifteen is 15 and
// not 20."

Note that there's a mild difference between the two syntaxes. Template literals coerce their expressions directly to strings, while addition coerces its operands to primitives first. For more information, see the reference page for the + operator.Nesting templatesIn certain cases, nesting a template is the easiest (and perhaps more readable) way to have configurable strings. Within a backtick-delimited template, it is simple to allow inner backticks by using them inside an ${expression} placeholder within the template.
For example, without template literals, if you wanted to return a certain value based on a particular condition, you could do something like the following:
jslet classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

With a template literal but without nesting, you could do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

With nesting of template literals, you can do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
Tagged templatesA more advanced form of template literals are tagged templates.
Tags allow you to parse template literals with a function. The first argument of a tag function contains an array of string values. The remaining arguments are related to the expressions.
The tag function can then perform whatever operations on these arguments you wish, and return the manipulated string. (Alternatively, it can return something completely different, as described in one of the following examples.)
The name of the function used for the tag can be whatever you want.
jsconst person = "Mike";
const age = 28;

function myTag(strings, personExp, ageExp) {
  const str0 = strings[0]; // "That "
  const str1 = strings[1]; // " is a "
  const str2 = strings[2]; // "."

  const ageStr = ageExp < 100 ? "youngster" : "centenarian";

  // We can even return a string built using a template literal
  return `${str0}${personExp}${str1}${ageStr}${str2}`;
}

const output = myTag`That ${person} is a ${age}.`;

console.log(output);
// That Mike is a youngster.

The tag does not have to be a plain identifier. You can use any expression with precedence greater than 16, which includes property access, function call, new expression, or even another tagged template literal.
jsconsole.log`Hello`; // [ 'Hello' ]
console.log.bind(1, 2)`Hello`; // 2 [ 'Hello' ]
new Function("console.log(arguments)")`Hello`; // [Arguments] { '0': [ 'Hello' ] }

function recursive(strings, ...values) {
  console.log(strings, values);
  return recursive;
}
recursive`Hello``World`;
// [ 'Hello' ] []
// [ 'World' ] []

While technically permitted by the syntax, untagged template literals are strings and will throw a TypeError when chained.
jsconsole.log(`Hello``World`); // TypeError: "Hello" is not a function

The only exception is optional chaining, which will throw a syntax error.
jsconsole.log?.`Hello`; // SyntaxError: Invalid tagged template on optional chain
console?.log`Hello`; // SyntaxError: Invalid tagged template on optional chain

Note that these two expressions are still parsable. This means they would not be subject to automatic semicolon insertion, which will only insert semicolons to fix code that's otherwise unparsable.
js// Still a syntax error
const a = console?.log
`Hello`

Tag functions don't even need to return a string!
jsfunction template(strings, ...keys) {
  return (...values) => {
    const dict = values[values.length - 1] || {};
    const result = [strings[0]];
    keys.forEach((key, i) => {
      const value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

const t1Closure = template`${0}${1}${0}!`;
// const t1Closure = template(["","","","!"],0,1,0);
t1Closure("Y", "A"); // "YAY!"

const t2Closure = template`${0} ${"foo"}!`;
// const t2Closure = template([""," ","!"],0,"foo");
t2Closure("Hello", { foo: "World" }); // "Hello World!"

const t3Closure = template`I'm ${"name"}. I'm almost ${"age"} years old.`;
// const t3Closure = template(["I'm ", ". I'm almost ", " years old."], "name", "age");
t3Closure("foo", { name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."
t3Closure({ name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."

The first argument received by the tag function is an array of strings. For any template literal, its length is equal to the number of substitutions (occurrences of ${…}) plus one, and is therefore always non-empty.
For any particular tagged template literal expression, the tag function will always be called with the exact same literal array, no matter how many times the literal is evaluated.
jsconst callHistory = [];

function tag(strings, ...values) {
  callHistory.push(strings);
  // Return a freshly made object
  return {};
}

function evaluateLiteral() {
  return tag`Hello, ${"world"}!`;
}

console.log(evaluateLiteral() === evaluateLiteral()); // false; each time `tag` is called, it returns a new object
console.log(callHistory[0] === callHistory[1]); // true; all evaluations of the same tagged literal would pass in the same strings array

This allows the tag to cache the result based on the identity of its first argument. To further ensure the array value's stability, the first argument and its raw property are both frozen, so you can't mutate them in any way.Raw stringsThe special raw property, available on the first argument to the tag function, allows you to access the raw strings as they were entered, without processing escape sequences.
jsfunction tag(strings) {
  console.log(strings.raw[0]);
}

tag`string text line 1 \n string text line 2`;
// Logs "string text line 1 \n string text line 2",
// including the two characters '\' and 'n'

In addition, the String.raw() method exists to create raw strings just like the default template function and string concatenation would create.
jsconst str = String.raw`Hi\n${2 + 3}!`;
// "Hi\\n5!"

str.length;
// 6

Array.from(str).join(",");
// "H,i,\\,n,5,!"

String.raw functions like an "identity" tag if the literal doesn't contain any escape sequences. In case you want an actual identity tag that always works as if the literal is untagged, you can make a custom function that passes the "cooked" (i.e., escape sequences are processed) literal array to String.raw, pretending they are raw strings.
jsconst identity = (strings, ...values) =>
  String.raw({ raw: strings }, ...values);
console.log(identity`Hi\n${2 + 3}!`);
// Hi
// 5!

This is useful for many tools which give special treatment to literals tagged by a particular name.
jsconst html = (strings, ...values) => String.raw({ raw: strings }, ...values);
// Some formatters will format this literal's content as HTML
const doc = html`<!doctype html>
  <html lang="en-US">
    <head>
      <title>Hello</title>
    </head>
    <body>
      <h1>Hello world!</h1>
    </body>
  </html>`;
Tagged templates and escape sequencesIn normal template literals, the escape sequences in string literals are all allowed. Any other non-well-formed escape sequence is a syntax error. This includes:

\ followed by any decimal digit other than 0, or \0 followed by a decimal digit; for example \9 and \07 (which is a deprecated syntax)
\x followed by fewer than two hex digits (including none); for example \xz
\u not followed by { and followed by fewer than four hex digits (including none); for example \uz
\u{} enclosing an invalid Unicode code point — it contains a non-hex digit, or its value is greater than 10FFFF; for example \u{110000} and \u{z}


Note: \ followed by other characters, while they may be useless since nothing is escaped, are not syntax errors.

However, this is problematic for tagged templates, which, in addition to the "cooked" literal, also have access to the raw literals (escape sequences are preserved as-is).
Tagged templates enable the embedding of arbitrary string content, where escape sequences may follow a different syntax. Consider for an example where we embed LaTeX source text in JavaScript via String.raw. We want to still be able to use LaTeX macros that start with u or x without following JavaScript syntax restrictions. Therefore, the syntax restriction of well-formed escape sequences is removed from tagged templates. The example below uses MathJax to render LaTeX in one element:
jsconst node = document.getElementById("formula");
MathJax.typesetClear([node]);
// Throws in older ECMAScript versions (ES2016 and earlier)
// SyntaxError: malformed Unicode character escape sequence
node.textContent = String.raw`$\underline{u}$`;
MathJax.typesetPromise([node]);

However, illegal escape sequences must still be represented in the "cooked" representation. They will show up as undefined element in the "cooked" array:
jsfunction log(str) {
  console.log("Cooked:", str[0]);
  console.log("Raw:", str.raw[0]);
}

log`\unicode`;
// Cooked: undefined
// Raw: \unicode

Note that the escape-sequence restriction is only dropped from tagged templates, but not from untagged template literals:
jsconst bad = `bad escape sequence: \unicode`;
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-template-literalsBrowser compatibilitySee also
Numbers and strings guide
String
String.raw()
Lexical grammar
ES6 in Depth: Template strings on hacks.mozilla.org (2015)\n\nTemplate literals (Template strings)Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackTemplate literals are literals delimited with backtick (`) characters, allowing for multi-line strings, string interpolation with embedded expressions, and special constructs called tagged templates.
Template literals are sometimes informally called template strings, because they are used most commonly for string interpolation (to create strings by doing substitution of placeholders). However, a tagged template literal may not result in a string; it can be used with a custom tag function to perform whatever operations you want on the different parts of the template literal.Syntaxjs`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tagFunction`string text ${expression} string text`
Parameters
string text

The string text that will become part of the template literal. Almost all characters are allowed literally, including line breaks and other whitespace characters. However, invalid escape sequences will cause a syntax error, unless a tag function is used.

expression

An expression to be inserted in the current position, whose value is converted to a string or passed to tagFunction.

tagFunction

If specified, it will be called with the template strings array and substitution expressions, and the return value becomes the value of the template literal. See tagged templates.

DescriptionTemplate literals are enclosed by backtick (`) characters instead of double or single quotes.
Along with having normal strings, template literals can also contain other parts called placeholders, which are embedded expressions delimited by a dollar sign and curly braces: ${expression}. The strings and placeholders get passed to a function — either a default function, or a function you supply. The default function (when you don't supply your own) just performs string interpolation to do substitution of the placeholders and then concatenate the parts into a single string.
To supply a function of your own, precede the template literal with a function name; the result is called a tagged template. In that case, the template literal is passed to your tag function, where you can then perform whatever operations you want on the different parts of the template literal.
To escape a backtick in a template literal, put a backslash (\) before the backtick.
js`\`` === "`"; // true

Dollar signs can be escaped as well to prevent interpolation.
js`\${1}` === "${1}"; // true
Multi-line stringsAny newline characters inserted in the source are part of the template literal.
Using normal strings, you would have to use the following syntax in order to get multi-line strings:
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
// string text line 2"

Using template literals, you can do the same with this:
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"

Like normal string literals, you can write a single-line string across multiple lines for source code readability, by escaping the newline with a backslash (\):
jsconsole.log(`string text line 1 \
string text line 2`);
// "string text line 1 string text line 2"
String interpolationWithout template literals, when you want to combine output from expressions with strings, you'd concatenate them using the addition operator +:
jsconst a = 5;
const b = 10;
console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");
// "Fifteen is 15 and
// not 20."

That can be hard to read – especially when you have multiple expressions.
With template literals, you can avoid the concatenation operator — and improve the readability of your code — by using placeholders of the form ${expression} to perform substitutions for embedded expressions:
jsconst a = 5;
const b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
// "Fifteen is 15 and
// not 20."

Note that there's a mild difference between the two syntaxes. Template literals coerce their expressions directly to strings, while addition coerces its operands to primitives first. For more information, see the reference page for the + operator.Nesting templatesIn certain cases, nesting a template is the easiest (and perhaps more readable) way to have configurable strings. Within a backtick-delimited template, it is simple to allow inner backticks by using them inside an ${expression} placeholder within the template.
For example, without template literals, if you wanted to return a certain value based on a particular condition, you could do something like the following:
jslet classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

With a template literal but without nesting, you could do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

With nesting of template literals, you can do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
Tagged templatesA more advanced form of template literals are tagged templates.
Tags allow you to parse template literals with a function. The first argument of a tag function contains an array of string values. The remaining arguments are related to the expressions.
The tag function can then perform whatever operations on these arguments you wish, and return the manipulated string. (Alternatively, it can return something completely different, as described in one of the following examples.)
The name of the function used for the tag can be whatever you want.
jsconst person = "Mike";
const age = 28;

function myTag(strings, personExp, ageExp) {
  const str0 = strings[0]; // "That "
  const str1 = strings[1]; // " is a "
  const str2 = strings[2]; // "."

  const ageStr = ageExp < 100 ? "youngster" : "centenarian";

  // We can even return a string built using a template literal
  return `${str0}${personExp}${str1}${ageStr}${str2}`;
}

const output = myTag`That ${person} is a ${age}.`;

console.log(output);
// That Mike is a youngster.

The tag does not have to be a plain identifier. You can use any expression with precedence greater than 16, which includes property access, function call, new expression, or even another tagged template literal.
jsconsole.log`Hello`; // [ 'Hello' ]
console.log.bind(1, 2)`Hello`; // 2 [ 'Hello' ]
new Function("console.log(arguments)")`Hello`; // [Arguments] { '0': [ 'Hello' ] }

function recursive(strings, ...values) {
  console.log(strings, values);
  return recursive;
}
recursive`Hello``World`;
// [ 'Hello' ] []
// [ 'World' ] []

While technically permitted by the syntax, untagged template literals are strings and will throw a TypeError when chained.
jsconsole.log(`Hello``World`); // TypeError: "Hello" is not a function

The only exception is optional chaining, which will throw a syntax error.
jsconsole.log?.`Hello`; // SyntaxError: Invalid tagged template on optional chain
console?.log`Hello`; // SyntaxError: Invalid tagged template on optional chain

Note that these two expressions are still parsable. This means they would not be subject to automatic semicolon insertion, which will only insert semicolons to fix code that's otherwise unparsable.
js// Still a syntax error
const a = console?.log
`Hello`

Tag functions don't even need to return a string!
jsfunction template(strings, ...keys) {
  return (...values) => {
    const dict = values[values.length - 1] || {};
    const result = [strings[0]];
    keys.forEach((key, i) => {
      const value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

const t1Closure = template`${0}${1}${0}!`;
// const t1Closure = template(["","","","!"],0,1,0);
t1Closure("Y", "A"); // "YAY!"

const t2Closure = template`${0} ${"foo"}!`;
// const t2Closure = template([""," ","!"],0,"foo");
t2Closure("Hello", { foo: "World" }); // "Hello World!"

const t3Closure = template`I'm ${"name"}. I'm almost ${"age"} years old.`;
// const t3Closure = template(["I'm ", ". I'm almost ", " years old."], "name", "age");
t3Closure("foo", { name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."
t3Closure({ name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."

The first argument received by the tag function is an array of strings. For any template literal, its length is equal to the number of substitutions (occurrences of ${…}) plus one, and is therefore always non-empty.
For any particular tagged template literal expression, the tag function will always be called with the exact same literal array, no matter how many times the literal is evaluated.
jsconst callHistory = [];

function tag(strings, ...values) {
  callHistory.push(strings);
  // Return a freshly made object
  return {};
}

function evaluateLiteral() {
  return tag`Hello, ${"world"}!`;
}

console.log(evaluateLiteral() === evaluateLiteral()); // false; each time `tag` is called, it returns a new object
console.log(callHistory[0] === callHistory[1]); // true; all evaluations of the same tagged literal would pass in the same strings array

This allows the tag to cache the result based on the identity of its first argument. To further ensure the array value's stability, the first argument and its raw property are both frozen, so you can't mutate them in any way.Raw stringsThe special raw property, available on the first argument to the tag function, allows you to access the raw strings as they were entered, without processing escape sequences.
jsfunction tag(strings) {
  console.log(strings.raw[0]);
}

tag`string text line 1 \n string text line 2`;
// Logs "string text line 1 \n string text line 2",
// including the two characters '\' and 'n'

In addition, the String.raw() method exists to create raw strings just like the default template function and string concatenation would create.
jsconst str = String.raw`Hi\n${2 + 3}!`;
// "Hi\\n5!"

str.length;
// 6

Array.from(str).join(",");
// "H,i,\\,n,5,!"

String.raw functions like an "identity" tag if the literal doesn't contain any escape sequences. In case you want an actual identity tag that always works as if the literal is untagged, you can make a custom function that passes the "cooked" (i.e., escape sequences are processed) literal array to String.raw, pretending they are raw strings.
jsconst identity = (strings, ...values) =>
  String.raw({ raw: strings }, ...values);
console.log(identity`Hi\n${2 + 3}!`);
// Hi
// 5!

This is useful for many tools which give special treatment to literals tagged by a particular name.
jsconst html = (strings, ...values) => String.raw({ raw: strings }, ...values);
// Some formatters will format this literal's content as HTML
const doc = html`<!doctype html>
  <html lang="en-US">
    <head>
      <title>Hello</title>
    </head>
    <body>
      <h1>Hello world!</h1>
    </body>
  </html>`;
Tagged templates and escape sequencesIn normal template literals, the escape sequences in string literals are all allowed. Any other non-well-formed escape sequence is a syntax error. This includes:

\ followed by any decimal digit other than 0, or \0 followed by a decimal digit; for example \9 and \07 (which is a deprecated syntax)
\x followed by fewer than two hex digits (including none); for example \xz
\u not followed by { and followed by fewer than four hex digits (including none); for example \uz
\u{} enclosing an invalid Unicode code point — it contains a non-hex digit, or its value is greater than 10FFFF; for example \u{110000} and \u{z}


Note: \ followed by other characters, while they may be useless since nothing is escaped, are not syntax errors.

However, this is problematic for tagged templates, which, in addition to the "cooked" literal, also have access to the raw literals (escape sequences are preserved as-is).
Tagged templates enable the embedding of arbitrary string content, where escape sequences may follow a different syntax. Consider for an example where we embed LaTeX source text in JavaScript via String.raw. We want to still be able to use LaTeX macros that start with u or x without following JavaScript syntax restrictions. Therefore, the syntax restriction of well-formed escape sequences is removed from tagged templates. The example below uses MathJax to render LaTeX in one element:
jsconst node = document.getElementById("formula");
MathJax.typesetClear([node]);
// Throws in older ECMAScript versions (ES2016 and earlier)
// SyntaxError: malformed Unicode character escape sequence
node.textContent = String.raw`$\underline{u}$`;
MathJax.typesetPromise([node]);

However, illegal escape sequences must still be represented in the "cooked" representation. They will show up as undefined element in the "cooked" array:
jsfunction log(str) {
  console.log("Cooked:", str[0]);
  console.log("Raw:", str.raw[0]);
}

log`\unicode`;
// Cooked: undefined
// Raw: \unicode

Note that the escape-sequence restriction is only dropped from tagged templates, but not from untagged template literals:
jsconst bad = `bad escape sequence: \unicode`;
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-template-literalsBrowser compatibilitySee also
Numbers and strings guide
String
String.raw()
Lexical grammar
ES6 in Depth: Template strings on hacks.mozilla.org (2015)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nTemplate literals (Template strings)Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackTemplate literals are literals delimited with backtick (`) characters, allowing for multi-line strings, string interpolation with embedded expressions, and special constructs called tagged templates.
Template literals are sometimes informally called template strings, because they are used most commonly for string interpolation (to create strings by doing substitution of placeholders). However, a tagged template literal may not result in a string; it can be used with a custom tag function to perform whatever operations you want on the different parts of the template literal.Syntaxjs`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tagFunction`string text ${expression} string text`
Parameters
string text

The string text that will become part of the template literal. Almost all characters are allowed literally, including line breaks and other whitespace characters. However, invalid escape sequences will cause a syntax error, unless a tag function is used.

expression

An expression to be inserted in the current position, whose value is converted to a string or passed to tagFunction.

tagFunction

If specified, it will be called with the template strings array and substitution expressions, and the return value becomes the value of the template literal. See tagged templates.

DescriptionTemplate literals are enclosed by backtick (`) characters instead of double or single quotes.
Along with having normal strings, template literals can also contain other parts called placeholders, which are embedded expressions delimited by a dollar sign and curly braces: ${expression}. The strings and placeholders get passed to a function — either a default function, or a function you supply. The default function (when you don't supply your own) just performs string interpolation to do substitution of the placeholders and then concatenate the parts into a single string.
To supply a function of your own, precede the template literal with a function name; the result is called a tagged template. In that case, the template literal is passed to your tag function, where you can then perform whatever operations you want on the different parts of the template literal.
To escape a backtick in a template literal, put a backslash (\) before the backtick.
js`\`` === "`"; // true

Dollar signs can be escaped as well to prevent interpolation.
js`\${1}` === "${1}"; // true
Multi-line stringsAny newline characters inserted in the source are part of the template literal.
Using normal strings, you would have to use the following syntax in order to get multi-line strings:
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
// string text line 2"

Using template literals, you can do the same with this:
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"

Like normal string literals, you can write a single-line string across multiple lines for source code readability, by escaping the newline with a backslash (\):
jsconsole.log(`string text line 1 \
string text line 2`);
// "string text line 1 string text line 2"
String interpolationWithout template literals, when you want to combine output from expressions with strings, you'd concatenate them using the addition operator +:
jsconst a = 5;
const b = 10;
console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");
// "Fifteen is 15 and
// not 20."

That can be hard to read – especially when you have multiple expressions.
With template literals, you can avoid the concatenation operator — and improve the readability of your code — by using placeholders of the form ${expression} to perform substitutions for embedded expressions:
jsconst a = 5;
const b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
// "Fifteen is 15 and
// not 20."

Note that there's a mild difference between the two syntaxes. Template literals coerce their expressions directly to strings, while addition coerces its operands to primitives first. For more information, see the reference page for the + operator.Nesting templatesIn certain cases, nesting a template is the easiest (and perhaps more readable) way to have configurable strings. Within a backtick-delimited template, it is simple to allow inner backticks by using them inside an ${expression} placeholder within the template.
For example, without template literals, if you wanted to return a certain value based on a particular condition, you could do something like the following:
jslet classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

With a template literal but without nesting, you could do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

With nesting of template literals, you can do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
Tagged templatesA more advanced form of template literals are tagged templates.
Tags allow you to parse template literals with a function. The first argument of a tag function contains an array of string values. The remaining arguments are related to the expressions.
The tag function can then perform whatever operations on these arguments you wish, and return the manipulated string. (Alternatively, it can return something completely different, as described in one of the following examples.)
The name of the function used for the tag can be whatever you want.
jsconst person = "Mike";
const age = 28;

function myTag(strings, personExp, ageExp) {
  const str0 = strings[0]; // "That "
  const str1 = strings[1]; // " is a "
  const str2 = strings[2]; // "."

  const ageStr = ageExp < 100 ? "youngster" : "centenarian";

  // We can even return a string built using a template literal
  return `${str0}${personExp}${str1}${ageStr}${str2}`;
}

const output = myTag`That ${person} is a ${age}.`;

console.log(output);
// That Mike is a youngster.

The tag does not have to be a plain identifier. You can use any expression with precedence greater than 16, which includes property access, function call, new expression, or even another tagged template literal.
jsconsole.log`Hello`; // [ 'Hello' ]
console.log.bind(1, 2)`Hello`; // 2 [ 'Hello' ]
new Function("console.log(arguments)")`Hello`; // [Arguments] { '0': [ 'Hello' ] }

function recursive(strings, ...values) {
  console.log(strings, values);
  return recursive;
}
recursive`Hello``World`;
// [ 'Hello' ] []
// [ 'World' ] []

While technically permitted by the syntax, untagged template literals are strings and will throw a TypeError when chained.
jsconsole.log(`Hello``World`); // TypeError: "Hello" is not a function

The only exception is optional chaining, which will throw a syntax error.
jsconsole.log?.`Hello`; // SyntaxError: Invalid tagged template on optional chain
console?.log`Hello`; // SyntaxError: Invalid tagged template on optional chain

Note that these two expressions are still parsable. This means they would not be subject to automatic semicolon insertion, which will only insert semicolons to fix code that's otherwise unparsable.
js// Still a syntax error
const a = console?.log
`Hello`

Tag functions don't even need to return a string!
jsfunction template(strings, ...keys) {
  return (...values) => {
    const dict = values[values.length - 1] || {};
    const result = [strings[0]];
    keys.forEach((key, i) => {
      const value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

const t1Closure = template`${0}${1}${0}!`;
// const t1Closure = template(["","","","!"],0,1,0);
t1Closure("Y", "A"); // "YAY!"

const t2Closure = template`${0} ${"foo"}!`;
// const t2Closure = template([""," ","!"],0,"foo");
t2Closure("Hello", { foo: "World" }); // "Hello World!"

const t3Closure = template`I'm ${"name"}. I'm almost ${"age"} years old.`;
// const t3Closure = template(["I'm ", ". I'm almost ", " years old."], "name", "age");
t3Closure("foo", { name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."
t3Closure({ name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."

The first argument received by the tag function is an array of strings. For any template literal, its length is equal to the number of substitutions (occurrences of ${…}) plus one, and is therefore always non-empty.
For any particular tagged template literal expression, the tag function will always be called with the exact same literal array, no matter how many times the literal is evaluated.
jsconst callHistory = [];

function tag(strings, ...values) {
  callHistory.push(strings);
  // Return a freshly made object
  return {};
}

function evaluateLiteral() {
  return tag`Hello, ${"world"}!`;
}

console.log(evaluateLiteral() === evaluateLiteral()); // false; each time `tag` is called, it returns a new object
console.log(callHistory[0] === callHistory[1]); // true; all evaluations of the same tagged literal would pass in the same strings array

This allows the tag to cache the result based on the identity of its first argument. To further ensure the array value's stability, the first argument and its raw property are both frozen, so you can't mutate them in any way.Raw stringsThe special raw property, available on the first argument to the tag function, allows you to access the raw strings as they were entered, without processing escape sequences.
jsfunction tag(strings) {
  console.log(strings.raw[0]);
}

tag`string text line 1 \n string text line 2`;
// Logs "string text line 1 \n string text line 2",
// including the two characters '\' and 'n'

In addition, the String.raw() method exists to create raw strings just like the default template function and string concatenation would create.
jsconst str = String.raw`Hi\n${2 + 3}!`;
// "Hi\\n5!"

str.length;
// 6

Array.from(str).join(",");
// "H,i,\\,n,5,!"

String.raw functions like an "identity" tag if the literal doesn't contain any escape sequences. In case you want an actual identity tag that always works as if the literal is untagged, you can make a custom function that passes the "cooked" (i.e., escape sequences are processed) literal array to String.raw, pretending they are raw strings.
jsconst identity = (strings, ...values) =>
  String.raw({ raw: strings }, ...values);
console.log(identity`Hi\n${2 + 3}!`);
// Hi
// 5!

This is useful for many tools which give special treatment to literals tagged by a particular name.
jsconst html = (strings, ...values) => String.raw({ raw: strings }, ...values);
// Some formatters will format this literal's content as HTML
const doc = html`<!doctype html>
  <html lang="en-US">
    <head>
      <title>Hello</title>
    </head>
    <body>
      <h1>Hello world!</h1>
    </body>
  </html>`;
Tagged templates and escape sequencesIn normal template literals, the escape sequences in string literals are all allowed. Any other non-well-formed escape sequence is a syntax error. This includes:

\ followed by any decimal digit other than 0, or \0 followed by a decimal digit; for example \9 and \07 (which is a deprecated syntax)
\x followed by fewer than two hex digits (including none); for example \xz
\u not followed by { and followed by fewer than four hex digits (including none); for example \uz
\u{} enclosing an invalid Unicode code point — it contains a non-hex digit, or its value is greater than 10FFFF; for example \u{110000} and \u{z}


Note: \ followed by other characters, while they may be useless since nothing is escaped, are not syntax errors.

However, this is problematic for tagged templates, which, in addition to the "cooked" literal, also have access to the raw literals (escape sequences are preserved as-is).
Tagged templates enable the embedding of arbitrary string content, where escape sequences may follow a different syntax. Consider for an example where we embed LaTeX source text in JavaScript via String.raw. We want to still be able to use LaTeX macros that start with u or x without following JavaScript syntax restrictions. Therefore, the syntax restriction of well-formed escape sequences is removed from tagged templates. The example below uses MathJax to render LaTeX in one element:
jsconst node = document.getElementById("formula");
MathJax.typesetClear([node]);
// Throws in older ECMAScript versions (ES2016 and earlier)
// SyntaxError: malformed Unicode character escape sequence
node.textContent = String.raw`$\underline{u}$`;
MathJax.typesetPromise([node]);

However, illegal escape sequences must still be represented in the "cooked" representation. They will show up as undefined element in the "cooked" array:
jsfunction log(str) {
  console.log("Cooked:", str[0]);
  console.log("Raw:", str.raw[0]);
}

log`\unicode`;
// Cooked: undefined
// Raw: \unicode

Note that the escape-sequence restriction is only dropped from tagged templates, but not from untagged template literals:
jsconst bad = `bad escape sequence: \unicode`;
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-template-literalsBrowser compatibilitySee also
Numbers and strings guide
String
String.raw()
Lexical grammar
ES6 in Depth: Template strings on hacks.mozilla.org (2015)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nTemplate literals (Template strings)Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackTemplate literals are literals delimited with backtick (`) characters, allowing for multi-line strings, string interpolation with embedded expressions, and special constructs called tagged templates.
Template literals are sometimes informally called template strings, because they are used most commonly for string interpolation (to create strings by doing substitution of placeholders). However, a tagged template literal may not result in a string; it can be used with a custom tag function to perform whatever operations you want on the different parts of the template literal.Syntaxjs`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tagFunction`string text ${expression} string text`
Parameters
string text

The string text that will become part of the template literal. Almost all characters are allowed literally, including line breaks and other whitespace characters. However, invalid escape sequences will cause a syntax error, unless a tag function is used.

expression

An expression to be inserted in the current position, whose value is converted to a string or passed to tagFunction.

tagFunction

If specified, it will be called with the template strings array and substitution expressions, and the return value becomes the value of the template literal. See tagged templates.

DescriptionTemplate literals are enclosed by backtick (`) characters instead of double or single quotes.
Along with having normal strings, template literals can also contain other parts called placeholders, which are embedded expressions delimited by a dollar sign and curly braces: ${expression}. The strings and placeholders get passed to a function — either a default function, or a function you supply. The default function (when you don't supply your own) just performs string interpolation to do substitution of the placeholders and then concatenate the parts into a single string.
To supply a function of your own, precede the template literal with a function name; the result is called a tagged template. In that case, the template literal is passed to your tag function, where you can then perform whatever operations you want on the different parts of the template literal.
To escape a backtick in a template literal, put a backslash (\) before the backtick.
js`\`` === "`"; // true

Dollar signs can be escaped as well to prevent interpolation.
js`\${1}` === "${1}"; // true
Multi-line stringsAny newline characters inserted in the source are part of the template literal.
Using normal strings, you would have to use the following syntax in order to get multi-line strings:
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
// string text line 2"

Using template literals, you can do the same with this:
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"

Like normal string literals, you can write a single-line string across multiple lines for source code readability, by escaping the newline with a backslash (\):
jsconsole.log(`string text line 1 \
string text line 2`);
// "string text line 1 string text line 2"
String interpolationWithout template literals, when you want to combine output from expressions with strings, you'd concatenate them using the addition operator +:
jsconst a = 5;
const b = 10;
console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");
// "Fifteen is 15 and
// not 20."

That can be hard to read – especially when you have multiple expressions.
With template literals, you can avoid the concatenation operator — and improve the readability of your code — by using placeholders of the form ${expression} to perform substitutions for embedded expressions:
jsconst a = 5;
const b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
// "Fifteen is 15 and
// not 20."

Note that there's a mild difference between the two syntaxes. Template literals coerce their expressions directly to strings, while addition coerces its operands to primitives first. For more information, see the reference page for the + operator.Nesting templatesIn certain cases, nesting a template is the easiest (and perhaps more readable) way to have configurable strings. Within a backtick-delimited template, it is simple to allow inner backticks by using them inside an ${expression} placeholder within the template.
For example, without template literals, if you wanted to return a certain value based on a particular condition, you could do something like the following:
jslet classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

With a template literal but without nesting, you could do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

With nesting of template literals, you can do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
Tagged templatesA more advanced form of template literals are tagged templates.
Tags allow you to parse template literals with a function. The first argument of a tag function contains an array of string values. The remaining arguments are related to the expressions.
The tag function can then perform whatever operations on these arguments you wish, and return the manipulated string. (Alternatively, it can return something completely different, as described in one of the following examples.)
The name of the function used for the tag can be whatever you want.
jsconst person = "Mike";
const age = 28;

function myTag(strings, personExp, ageExp) {
  const str0 = strings[0]; // "That "
  const str1 = strings[1]; // " is a "
  const str2 = strings[2]; // "."

  const ageStr = ageExp < 100 ? "youngster" : "centenarian";

  // We can even return a string built using a template literal
  return `${str0}${personExp}${str1}${ageStr}${str2}`;
}

const output = myTag`That ${person} is a ${age}.`;

console.log(output);
// That Mike is a youngster.

The tag does not have to be a plain identifier. You can use any expression with precedence greater than 16, which includes property access, function call, new expression, or even another tagged template literal.
jsconsole.log`Hello`; // [ 'Hello' ]
console.log.bind(1, 2)`Hello`; // 2 [ 'Hello' ]
new Function("console.log(arguments)")`Hello`; // [Arguments] { '0': [ 'Hello' ] }

function recursive(strings, ...values) {
  console.log(strings, values);
  return recursive;
}
recursive`Hello``World`;
// [ 'Hello' ] []
// [ 'World' ] []

While technically permitted by the syntax, untagged template literals are strings and will throw a TypeError when chained.
jsconsole.log(`Hello``World`); // TypeError: "Hello" is not a function

The only exception is optional chaining, which will throw a syntax error.
jsconsole.log?.`Hello`; // SyntaxError: Invalid tagged template on optional chain
console?.log`Hello`; // SyntaxError: Invalid tagged template on optional chain

Note that these two expressions are still parsable. This means they would not be subject to automatic semicolon insertion, which will only insert semicolons to fix code that's otherwise unparsable.
js// Still a syntax error
const a = console?.log
`Hello`

Tag functions don't even need to return a string!
jsfunction template(strings, ...keys) {
  return (...values) => {
    const dict = values[values.length - 1] || {};
    const result = [strings[0]];
    keys.forEach((key, i) => {
      const value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

const t1Closure = template`${0}${1}${0}!`;
// const t1Closure = template(["","","","!"],0,1,0);
t1Closure("Y", "A"); // "YAY!"

const t2Closure = template`${0} ${"foo"}!`;
// const t2Closure = template([""," ","!"],0,"foo");
t2Closure("Hello", { foo: "World" }); // "Hello World!"

const t3Closure = template`I'm ${"name"}. I'm almost ${"age"} years old.`;
// const t3Closure = template(["I'm ", ". I'm almost ", " years old."], "name", "age");
t3Closure("foo", { name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."
t3Closure({ name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."

The first argument received by the tag function is an array of strings. For any template literal, its length is equal to the number of substitutions (occurrences of ${…}) plus one, and is therefore always non-empty.
For any particular tagged template literal expression, the tag function will always be called with the exact same literal array, no matter how many times the literal is evaluated.
jsconst callHistory = [];

function tag(strings, ...values) {
  callHistory.push(strings);
  // Return a freshly made object
  return {};
}

function evaluateLiteral() {
  return tag`Hello, ${"world"}!`;
}

console.log(evaluateLiteral() === evaluateLiteral()); // false; each time `tag` is called, it returns a new object
console.log(callHistory[0] === callHistory[1]); // true; all evaluations of the same tagged literal would pass in the same strings array

This allows the tag to cache the result based on the identity of its first argument. To further ensure the array value's stability, the first argument and its raw property are both frozen, so you can't mutate them in any way.Raw stringsThe special raw property, available on the first argument to the tag function, allows you to access the raw strings as they were entered, without processing escape sequences.
jsfunction tag(strings) {
  console.log(strings.raw[0]);
}

tag`string text line 1 \n string text line 2`;
// Logs "string text line 1 \n string text line 2",
// including the two characters '\' and 'n'

In addition, the String.raw() method exists to create raw strings just like the default template function and string concatenation would create.
jsconst str = String.raw`Hi\n${2 + 3}!`;
// "Hi\\n5!"

str.length;
// 6

Array.from(str).join(",");
// "H,i,\\,n,5,!"

String.raw functions like an "identity" tag if the literal doesn't contain any escape sequences. In case you want an actual identity tag that always works as if the literal is untagged, you can make a custom function that passes the "cooked" (i.e., escape sequences are processed) literal array to String.raw, pretending they are raw strings.
jsconst identity = (strings, ...values) =>
  String.raw({ raw: strings }, ...values);
console.log(identity`Hi\n${2 + 3}!`);
// Hi
// 5!

This is useful for many tools which give special treatment to literals tagged by a particular name.
jsconst html = (strings, ...values) => String.raw({ raw: strings }, ...values);
// Some formatters will format this literal's content as HTML
const doc = html`<!doctype html>
  <html lang="en-US">
    <head>
      <title>Hello</title>
    </head>
    <body>
      <h1>Hello world!</h1>
    </body>
  </html>`;
Tagged templates and escape sequencesIn normal template literals, the escape sequences in string literals are all allowed. Any other non-well-formed escape sequence is a syntax error. This includes:

\ followed by any decimal digit other than 0, or \0 followed by a decimal digit; for example \9 and \07 (which is a deprecated syntax)
\x followed by fewer than two hex digits (including none); for example \xz
\u not followed by { and followed by fewer than four hex digits (including none); for example \uz
\u{} enclosing an invalid Unicode code point — it contains a non-hex digit, or its value is greater than 10FFFF; for example \u{110000} and \u{z}


Note: \ followed by other characters, while they may be useless since nothing is escaped, are not syntax errors.

However, this is problematic for tagged templates, which, in addition to the "cooked" literal, also have access to the raw literals (escape sequences are preserved as-is).
Tagged templates enable the embedding of arbitrary string content, where escape sequences may follow a different syntax. Consider for an example where we embed LaTeX source text in JavaScript via String.raw. We want to still be able to use LaTeX macros that start with u or x without following JavaScript syntax restrictions. Therefore, the syntax restriction of well-formed escape sequences is removed from tagged templates. The example below uses MathJax to render LaTeX in one element:
jsconst node = document.getElementById("formula");
MathJax.typesetClear([node]);
// Throws in older ECMAScript versions (ES2016 and earlier)
// SyntaxError: malformed Unicode character escape sequence
node.textContent = String.raw`$\underline{u}$`;
MathJax.typesetPromise([node]);

However, illegal escape sequences must still be represented in the "cooked" representation. They will show up as undefined element in the "cooked" array:
jsfunction log(str) {
  console.log("Cooked:", str[0]);
  console.log("Raw:", str.raw[0]);
}

log`\unicode`;
// Cooked: undefined
// Raw: \unicode

Note that the escape-sequence restriction is only dropped from tagged templates, but not from untagged template literals:
jsconst bad = `bad escape sequence: \unicode`;
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-template-literalsBrowser compatibilitySee also
Numbers and strings guide
String
String.raw()
Lexical grammar
ES6 in Depth: Template strings on hacks.mozilla.org (2015)\n\nTemplate literals (Template strings)Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackTemplate literals are literals delimited with backtick (`) characters, allowing for multi-line strings, string interpolation with embedded expressions, and special constructs called tagged templates.
Template literals are sometimes informally called template strings, because they are used most commonly for string interpolation (to create strings by doing substitution of placeholders). However, a tagged template literal may not result in a string; it can be used with a custom tag function to perform whatever operations you want on the different parts of the template literal.Syntaxjs`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tagFunction`string text ${expression} string text`
Parameters
string text

The string text that will become part of the template literal. Almost all characters are allowed literally, including line breaks and other whitespace characters. However, invalid escape sequences will cause a syntax error, unless a tag function is used.

expression

An expression to be inserted in the current position, whose value is converted to a string or passed to tagFunction.

tagFunction

If specified, it will be called with the template strings array and substitution expressions, and the return value becomes the value of the template literal. See tagged templates.

DescriptionTemplate literals are enclosed by backtick (`) characters instead of double or single quotes.
Along with having normal strings, template literals can also contain other parts called placeholders, which are embedded expressions delimited by a dollar sign and curly braces: ${expression}. The strings and placeholders get passed to a function — either a default function, or a function you supply. The default function (when you don't supply your own) just performs string interpolation to do substitution of the placeholders and then concatenate the parts into a single string.
To supply a function of your own, precede the template literal with a function name; the result is called a tagged template. In that case, the template literal is passed to your tag function, where you can then perform whatever operations you want on the different parts of the template literal.
To escape a backtick in a template literal, put a backslash (\) before the backtick.
js`\`` === "`"; // true

Dollar signs can be escaped as well to prevent interpolation.
js`\${1}` === "${1}"; // true
Multi-line stringsAny newline characters inserted in the source are part of the template literal.
Using normal strings, you would have to use the following syntax in order to get multi-line strings:
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
// string text line 2"

Using template literals, you can do the same with this:
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"

Like normal string literals, you can write a single-line string across multiple lines for source code readability, by escaping the newline with a backslash (\):
jsconsole.log(`string text line 1 \
string text line 2`);
// "string text line 1 string text line 2"
String interpolationWithout template literals, when you want to combine output from expressions with strings, you'd concatenate them using the addition operator +:
jsconst a = 5;
const b = 10;
console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");
// "Fifteen is 15 and
// not 20."

That can be hard to read – especially when you have multiple expressions.
With template literals, you can avoid the concatenation operator — and improve the readability of your code — by using placeholders of the form ${expression} to perform substitutions for embedded expressions:
jsconst a = 5;
const b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
// "Fifteen is 15 and
// not 20."

Note that there's a mild difference between the two syntaxes. Template literals coerce their expressions directly to strings, while addition coerces its operands to primitives first. For more information, see the reference page for the + operator.Nesting templatesIn certain cases, nesting a template is the easiest (and perhaps more readable) way to have configurable strings. Within a backtick-delimited template, it is simple to allow inner backticks by using them inside an ${expression} placeholder within the template.
For example, without template literals, if you wanted to return a certain value based on a particular condition, you could do something like the following:
jslet classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

With a template literal but without nesting, you could do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

With nesting of template literals, you can do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
Tagged templatesA more advanced form of template literals are tagged templates.
Tags allow you to parse template literals with a function. The first argument of a tag function contains an array of string values. The remaining arguments are related to the expressions.
The tag function can then perform whatever operations on these arguments you wish, and return the manipulated string. (Alternatively, it can return something completely different, as described in one of the following examples.)
The name of the function used for the tag can be whatever you want.
jsconst person = "Mike";
const age = 28;

function myTag(strings, personExp, ageExp) {
  const str0 = strings[0]; // "That "
  const str1 = strings[1]; // " is a "
  const str2 = strings[2]; // "."

  const ageStr = ageExp < 100 ? "youngster" : "centenarian";

  // We can even return a string built using a template literal
  return `${str0}${personExp}${str1}${ageStr}${str2}`;
}

const output = myTag`That ${person} is a ${age}.`;

console.log(output);
// That Mike is a youngster.

The tag does not have to be a plain identifier. You can use any expression with precedence greater than 16, which includes property access, function call, new expression, or even another tagged template literal.
jsconsole.log`Hello`; // [ 'Hello' ]
console.log.bind(1, 2)`Hello`; // 2 [ 'Hello' ]
new Function("console.log(arguments)")`Hello`; // [Arguments] { '0': [ 'Hello' ] }

function recursive(strings, ...values) {
  console.log(strings, values);
  return recursive;
}
recursive`Hello``World`;
// [ 'Hello' ] []
// [ 'World' ] []

While technically permitted by the syntax, untagged template literals are strings and will throw a TypeError when chained.
jsconsole.log(`Hello``World`); // TypeError: "Hello" is not a function

The only exception is optional chaining, which will throw a syntax error.
jsconsole.log?.`Hello`; // SyntaxError: Invalid tagged template on optional chain
console?.log`Hello`; // SyntaxError: Invalid tagged template on optional chain

Note that these two expressions are still parsable. This means they would not be subject to automatic semicolon insertion, which will only insert semicolons to fix code that's otherwise unparsable.
js// Still a syntax error
const a = console?.log
`Hello`

Tag functions don't even need to return a string!
jsfunction template(strings, ...keys) {
  return (...values) => {
    const dict = values[values.length - 1] || {};
    const result = [strings[0]];
    keys.forEach((key, i) => {
      const value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

const t1Closure = template`${0}${1}${0}!`;
// const t1Closure = template(["","","","!"],0,1,0);
t1Closure("Y", "A"); // "YAY!"

const t2Closure = template`${0} ${"foo"}!`;
// const t2Closure = template([""," ","!"],0,"foo");
t2Closure("Hello", { foo: "World" }); // "Hello World!"

const t3Closure = template`I'm ${"name"}. I'm almost ${"age"} years old.`;
// const t3Closure = template(["I'm ", ". I'm almost ", " years old."], "name", "age");
t3Closure("foo", { name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."
t3Closure({ name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."

The first argument received by the tag function is an array of strings. For any template literal, its length is equal to the number of substitutions (occurrences of ${…}) plus one, and is therefore always non-empty.
For any particular tagged template literal expression, the tag function will always be called with the exact same literal array, no matter how many times the literal is evaluated.
jsconst callHistory = [];

function tag(strings, ...values) {
  callHistory.push(strings);
  // Return a freshly made object
  return {};
}

function evaluateLiteral() {
  return tag`Hello, ${"world"}!`;
}

console.log(evaluateLiteral() === evaluateLiteral()); // false; each time `tag` is called, it returns a new object
console.log(callHistory[0] === callHistory[1]); // true; all evaluations of the same tagged literal would pass in the same strings array

This allows the tag to cache the result based on the identity of its first argument. To further ensure the array value's stability, the first argument and its raw property are both frozen, so you can't mutate them in any way.Raw stringsThe special raw property, available on the first argument to the tag function, allows you to access the raw strings as they were entered, without processing escape sequences.
jsfunction tag(strings) {
  console.log(strings.raw[0]);
}

tag`string text line 1 \n string text line 2`;
// Logs "string text line 1 \n string text line 2",
// including the two characters '\' and 'n'

In addition, the String.raw() method exists to create raw strings just like the default template function and string concatenation would create.
jsconst str = String.raw`Hi\n${2 + 3}!`;
// "Hi\\n5!"

str.length;
// 6

Array.from(str).join(",");
// "H,i,\\,n,5,!"

String.raw functions like an "identity" tag if the literal doesn't contain any escape sequences. In case you want an actual identity tag that always works as if the literal is untagged, you can make a custom function that passes the "cooked" (i.e., escape sequences are processed) literal array to String.raw, pretending they are raw strings.
jsconst identity = (strings, ...values) =>
  String.raw({ raw: strings }, ...values);
console.log(identity`Hi\n${2 + 3}!`);
// Hi
// 5!

This is useful for many tools which give special treatment to literals tagged by a particular name.
jsconst html = (strings, ...values) => String.raw({ raw: strings }, ...values);
// Some formatters will format this literal's content as HTML
const doc = html`<!doctype html>
  <html lang="en-US">
    <head>
      <title>Hello</title>
    </head>
    <body>
      <h1>Hello world!</h1>
    </body>
  </html>`;
Tagged templates and escape sequencesIn normal template literals, the escape sequences in string literals are all allowed. Any other non-well-formed escape sequence is a syntax error. This includes:

\ followed by any decimal digit other than 0, or \0 followed by a decimal digit; for example \9 and \07 (which is a deprecated syntax)
\x followed by fewer than two hex digits (including none); for example \xz
\u not followed by { and followed by fewer than four hex digits (including none); for example \uz
\u{} enclosing an invalid Unicode code point — it contains a non-hex digit, or its value is greater than 10FFFF; for example \u{110000} and \u{z}


Note: \ followed by other characters, while they may be useless since nothing is escaped, are not syntax errors.

However, this is problematic for tagged templates, which, in addition to the "cooked" literal, also have access to the raw literals (escape sequences are preserved as-is).
Tagged templates enable the embedding of arbitrary string content, where escape sequences may follow a different syntax. Consider for an example where we embed LaTeX source text in JavaScript via String.raw. We want to still be able to use LaTeX macros that start with u or x without following JavaScript syntax restrictions. Therefore, the syntax restriction of well-formed escape sequences is removed from tagged templates. The example below uses MathJax to render LaTeX in one element:
jsconst node = document.getElementById("formula");
MathJax.typesetClear([node]);
// Throws in older ECMAScript versions (ES2016 and earlier)
// SyntaxError: malformed Unicode character escape sequence
node.textContent = String.raw`$\underline{u}$`;
MathJax.typesetPromise([node]);

However, illegal escape sequences must still be represented in the "cooked" representation. They will show up as undefined element in the "cooked" array:
jsfunction log(str) {
  console.log("Cooked:", str[0]);
  console.log("Raw:", str.raw[0]);
}

log`\unicode`;
// Cooked: undefined
// Raw: \unicode

Note that the escape-sequence restriction is only dropped from tagged templates, but not from untagged template literals:
jsconst bad = `bad escape sequence: \unicode`;
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-template-literalsBrowser compatibilitySee also
Numbers and strings guide
String
String.raw()
Lexical grammar
ES6 in Depth: Template strings on hacks.mozilla.org (2015)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nTemplate literals (Template strings)Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackTemplate literals are literals delimited with backtick (`) characters, allowing for multi-line strings, string interpolation with embedded expressions, and special constructs called tagged templates.
Template literals are sometimes informally called template strings, because they are used most commonly for string interpolation (to create strings by doing substitution of placeholders). However, a tagged template literal may not result in a string; it can be used with a custom tag function to perform whatever operations you want on the different parts of the template literal.Syntaxjs`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tagFunction`string text ${expression} string text`
Parameters
string text

The string text that will become part of the template literal. Almost all characters are allowed literally, including line breaks and other whitespace characters. However, invalid escape sequences will cause a syntax error, unless a tag function is used.

expression

An expression to be inserted in the current position, whose value is converted to a string or passed to tagFunction.

tagFunction

If specified, it will be called with the template strings array and substitution expressions, and the return value becomes the value of the template literal. See tagged templates.

DescriptionTemplate literals are enclosed by backtick (`) characters instead of double or single quotes.
Along with having normal strings, template literals can also contain other parts called placeholders, which are embedded expressions delimited by a dollar sign and curly braces: ${expression}. The strings and placeholders get passed to a function — either a default function, or a function you supply. The default function (when you don't supply your own) just performs string interpolation to do substitution of the placeholders and then concatenate the parts into a single string.
To supply a function of your own, precede the template literal with a function name; the result is called a tagged template. In that case, the template literal is passed to your tag function, where you can then perform whatever operations you want on the different parts of the template literal.
To escape a backtick in a template literal, put a backslash (\) before the backtick.
js`\`` === "`"; // true

Dollar signs can be escaped as well to prevent interpolation.
js`\${1}` === "${1}"; // true
Multi-line stringsAny newline characters inserted in the source are part of the template literal.
Using normal strings, you would have to use the following syntax in order to get multi-line strings:
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
// string text line 2"

Using template literals, you can do the same with this:
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"

Like normal string literals, you can write a single-line string across multiple lines for source code readability, by escaping the newline with a backslash (\):
jsconsole.log(`string text line 1 \
string text line 2`);
// "string text line 1 string text line 2"
String interpolationWithout template literals, when you want to combine output from expressions with strings, you'd concatenate them using the addition operator +:
jsconst a = 5;
const b = 10;
console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");
// "Fifteen is 15 and
// not 20."

That can be hard to read – especially when you have multiple expressions.
With template literals, you can avoid the concatenation operator — and improve the readability of your code — by using placeholders of the form ${expression} to perform substitutions for embedded expressions:
jsconst a = 5;
const b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
// "Fifteen is 15 and
// not 20."

Note that there's a mild difference between the two syntaxes. Template literals coerce their expressions directly to strings, while addition coerces its operands to primitives first. For more information, see the reference page for the + operator.Nesting templatesIn certain cases, nesting a template is the easiest (and perhaps more readable) way to have configurable strings. Within a backtick-delimited template, it is simple to allow inner backticks by using them inside an ${expression} placeholder within the template.
For example, without template literals, if you wanted to return a certain value based on a particular condition, you could do something like the following:
jslet classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

With a template literal but without nesting, you could do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

With nesting of template literals, you can do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
Tagged templatesA more advanced form of template literals are tagged templates.
Tags allow you to parse template literals with a function. The first argument of a tag function contains an array of string values. The remaining arguments are related to the expressions.
The tag function can then perform whatever operations on these arguments you wish, and return the manipulated string. (Alternatively, it can return something completely different, as described in one of the following examples.)
The name of the function used for the tag can be whatever you want.
jsconst person = "Mike";
const age = 28;

function myTag(strings, personExp, ageExp) {
  const str0 = strings[0]; // "That "
  const str1 = strings[1]; // " is a "
  const str2 = strings[2]; // "."

  const ageStr = ageExp < 100 ? "youngster" : "centenarian";

  // We can even return a string built using a template literal
  return `${str0}${personExp}${str1}${ageStr}${str2}`;
}

const output = myTag`That ${person} is a ${age}.`;

console.log(output);
// That Mike is a youngster.

The tag does not have to be a plain identifier. You can use any expression with precedence greater than 16, which includes property access, function call, new expression, or even another tagged template literal.
jsconsole.log`Hello`; // [ 'Hello' ]
console.log.bind(1, 2)`Hello`; // 2 [ 'Hello' ]
new Function("console.log(arguments)")`Hello`; // [Arguments] { '0': [ 'Hello' ] }

function recursive(strings, ...values) {
  console.log(strings, values);
  return recursive;
}
recursive`Hello``World`;
// [ 'Hello' ] []
// [ 'World' ] []

While technically permitted by the syntax, untagged template literals are strings and will throw a TypeError when chained.
jsconsole.log(`Hello``World`); // TypeError: "Hello" is not a function

The only exception is optional chaining, which will throw a syntax error.
jsconsole.log?.`Hello`; // SyntaxError: Invalid tagged template on optional chain
console?.log`Hello`; // SyntaxError: Invalid tagged template on optional chain

Note that these two expressions are still parsable. This means they would not be subject to automatic semicolon insertion, which will only insert semicolons to fix code that's otherwise unparsable.
js// Still a syntax error
const a = console?.log
`Hello`

Tag functions don't even need to return a string!
jsfunction template(strings, ...keys) {
  return (...values) => {
    const dict = values[values.length - 1] || {};
    const result = [strings[0]];
    keys.forEach((key, i) => {
      const value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

const t1Closure = template`${0}${1}${0}!`;
// const t1Closure = template(["","","","!"],0,1,0);
t1Closure("Y", "A"); // "YAY!"

const t2Closure = template`${0} ${"foo"}!`;
// const t2Closure = template([""," ","!"],0,"foo");
t2Closure("Hello", { foo: "World" }); // "Hello World!"

const t3Closure = template`I'm ${"name"}. I'm almost ${"age"} years old.`;
// const t3Closure = template(["I'm ", ". I'm almost ", " years old."], "name", "age");
t3Closure("foo", { name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."
t3Closure({ name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."

The first argument received by the tag function is an array of strings. For any template literal, its length is equal to the number of substitutions (occurrences of ${…}) plus one, and is therefore always non-empty.
For any particular tagged template literal expression, the tag function will always be called with the exact same literal array, no matter how many times the literal is evaluated.
jsconst callHistory = [];

function tag(strings, ...values) {
  callHistory.push(strings);
  // Return a freshly made object
  return {};
}

function evaluateLiteral() {
  return tag`Hello, ${"world"}!`;
}

console.log(evaluateLiteral() === evaluateLiteral()); // false; each time `tag` is called, it returns a new object
console.log(callHistory[0] === callHistory[1]); // true; all evaluations of the same tagged literal would pass in the same strings array

This allows the tag to cache the result based on the identity of its first argument. To further ensure the array value's stability, the first argument and its raw property are both frozen, so you can't mutate them in any way.Raw stringsThe special raw property, available on the first argument to the tag function, allows you to access the raw strings as they were entered, without processing escape sequences.
jsfunction tag(strings) {
  console.log(strings.raw[0]);
}

tag`string text line 1 \n string text line 2`;
// Logs "string text line 1 \n string text line 2",
// including the two characters '\' and 'n'

In addition, the String.raw() method exists to create raw strings just like the default template function and string concatenation would create.
jsconst str = String.raw`Hi\n${2 + 3}!`;
// "Hi\\n5!"

str.length;
// 6

Array.from(str).join(",");
// "H,i,\\,n,5,!"

String.raw functions like an "identity" tag if the literal doesn't contain any escape sequences. In case you want an actual identity tag that always works as if the literal is untagged, you can make a custom function that passes the "cooked" (i.e., escape sequences are processed) literal array to String.raw, pretending they are raw strings.
jsconst identity = (strings, ...values) =>
  String.raw({ raw: strings }, ...values);
console.log(identity`Hi\n${2 + 3}!`);
// Hi
// 5!

This is useful for many tools which give special treatment to literals tagged by a particular name.
jsconst html = (strings, ...values) => String.raw({ raw: strings }, ...values);
// Some formatters will format this literal's content as HTML
const doc = html`<!doctype html>
  <html lang="en-US">
    <head>
      <title>Hello</title>
    </head>
    <body>
      <h1>Hello world!</h1>
    </body>
  </html>`;
Tagged templates and escape sequencesIn normal template literals, the escape sequences in string literals are all allowed. Any other non-well-formed escape sequence is a syntax error. This includes:

\ followed by any decimal digit other than 0, or \0 followed by a decimal digit; for example \9 and \07 (which is a deprecated syntax)
\x followed by fewer than two hex digits (including none); for example \xz
\u not followed by { and followed by fewer than four hex digits (including none); for example \uz
\u{} enclosing an invalid Unicode code point — it contains a non-hex digit, or its value is greater than 10FFFF; for example \u{110000} and \u{z}


Note: \ followed by other characters, while they may be useless since nothing is escaped, are not syntax errors.

However, this is problematic for tagged templates, which, in addition to the "cooked" literal, also have access to the raw literals (escape sequences are preserved as-is).
Tagged templates enable the embedding of arbitrary string content, where escape sequences may follow a different syntax. Consider for an example where we embed LaTeX source text in JavaScript via String.raw. We want to still be able to use LaTeX macros that start with u or x without following JavaScript syntax restrictions. Therefore, the syntax restriction of well-formed escape sequences is removed from tagged templates. The example below uses MathJax to render LaTeX in one element:
jsconst node = document.getElementById("formula");
MathJax.typesetClear([node]);
// Throws in older ECMAScript versions (ES2016 and earlier)
// SyntaxError: malformed Unicode character escape sequence
node.textContent = String.raw`$\underline{u}$`;
MathJax.typesetPromise([node]);

However, illegal escape sequences must still be represented in the "cooked" representation. They will show up as undefined element in the "cooked" array:
jsfunction log(str) {
  console.log("Cooked:", str[0]);
  console.log("Raw:", str.raw[0]);
}

log`\unicode`;
// Cooked: undefined
// Raw: \unicode

Note that the escape-sequence restriction is only dropped from tagged templates, but not from untagged template literals:
jsconst bad = `bad escape sequence: \unicode`;
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-template-literalsBrowser compatibilitySee also
Numbers and strings guide
String
String.raw()
Lexical grammar
ES6 in Depth: Template strings on hacks.mozilla.org (2015)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nTemplate literals (Template strings)Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackTemplate literals are literals delimited with backtick (`) characters, allowing for multi-line strings, string interpolation with embedded expressions, and special constructs called tagged templates.
Template literals are sometimes informally called template strings, because they are used most commonly for string interpolation (to create strings by doing substitution of placeholders). However, a tagged template literal may not result in a string; it can be used with a custom tag function to perform whatever operations you want on the different parts of the template literal.Syntaxjs`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tagFunction`string text ${expression} string text`
Parameters
string text

The string text that will become part of the template literal. Almost all characters are allowed literally, including line breaks and other whitespace characters. However, invalid escape sequences will cause a syntax error, unless a tag function is used.

expression

An expression to be inserted in the current position, whose value is converted to a string or passed to tagFunction.

tagFunction

If specified, it will be called with the template strings array and substitution expressions, and the return value becomes the value of the template literal. See tagged templates.

DescriptionTemplate literals are enclosed by backtick (`) characters instead of double or single quotes.
Along with having normal strings, template literals can also contain other parts called placeholders, which are embedded expressions delimited by a dollar sign and curly braces: ${expression}. The strings and placeholders get passed to a function — either a default function, or a function you supply. The default function (when you don't supply your own) just performs string interpolation to do substitution of the placeholders and then concatenate the parts into a single string.
To supply a function of your own, precede the template literal with a function name; the result is called a tagged template. In that case, the template literal is passed to your tag function, where you can then perform whatever operations you want on the different parts of the template literal.
To escape a backtick in a template literal, put a backslash (\) before the backtick.
js`\`` === "`"; // true

Dollar signs can be escaped as well to prevent interpolation.
js`\${1}` === "${1}"; // true
Multi-line stringsAny newline characters inserted in the source are part of the template literal.
Using normal strings, you would have to use the following syntax in order to get multi-line strings:
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
// string text line 2"

Using template literals, you can do the same with this:
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"

Like normal string literals, you can write a single-line string across multiple lines for source code readability, by escaping the newline with a backslash (\):
jsconsole.log(`string text line 1 \
string text line 2`);
// "string text line 1 string text line 2"
String interpolationWithout template literals, when you want to combine output from expressions with strings, you'd concatenate them using the addition operator +:
jsconst a = 5;
const b = 10;
console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");
// "Fifteen is 15 and
// not 20."

That can be hard to read – especially when you have multiple expressions.
With template literals, you can avoid the concatenation operator — and improve the readability of your code — by using placeholders of the form ${expression} to perform substitutions for embedded expressions:
jsconst a = 5;
const b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
// "Fifteen is 15 and
// not 20."

Note that there's a mild difference between the two syntaxes. Template literals coerce their expressions directly to strings, while addition coerces its operands to primitives first. For more information, see the reference page for the + operator.Nesting templatesIn certain cases, nesting a template is the easiest (and perhaps more readable) way to have configurable strings. Within a backtick-delimited template, it is simple to allow inner backticks by using them inside an ${expression} placeholder within the template.
For example, without template literals, if you wanted to return a certain value based on a particular condition, you could do something like the following:
jslet classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

With a template literal but without nesting, you could do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

With nesting of template literals, you can do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
Tagged templatesA more advanced form of template literals are tagged templates.
Tags allow you to parse template literals with a function. The first argument of a tag function contains an array of string values. The remaining arguments are related to the expressions.
The tag function can then perform whatever operations on these arguments you wish, and return the manipulated string. (Alternatively, it can return something completely different, as described in one of the following examples.)
The name of the function used for the tag can be whatever you want.
jsconst person = "Mike";
const age = 28;

function myTag(strings, personExp, ageExp) {
  const str0 = strings[0]; // "That "
  const str1 = strings[1]; // " is a "
  const str2 = strings[2]; // "."

  const ageStr = ageExp < 100 ? "youngster" : "centenarian";

  // We can even return a string built using a template literal
  return `${str0}${personExp}${str1}${ageStr}${str2}`;
}

const output = myTag`That ${person} is a ${age}.`;

console.log(output);
// That Mike is a youngster.

The tag does not have to be a plain identifier. You can use any expression with precedence greater than 16, which includes property access, function call, new expression, or even another tagged template literal.
jsconsole.log`Hello`; // [ 'Hello' ]
console.log.bind(1, 2)`Hello`; // 2 [ 'Hello' ]
new Function("console.log(arguments)")`Hello`; // [Arguments] { '0': [ 'Hello' ] }

function recursive(strings, ...values) {
  console.log(strings, values);
  return recursive;
}
recursive`Hello``World`;
// [ 'Hello' ] []
// [ 'World' ] []

While technically permitted by the syntax, untagged template literals are strings and will throw a TypeError when chained.
jsconsole.log(`Hello``World`); // TypeError: "Hello" is not a function

The only exception is optional chaining, which will throw a syntax error.
jsconsole.log?.`Hello`; // SyntaxError: Invalid tagged template on optional chain
console?.log`Hello`; // SyntaxError: Invalid tagged template on optional chain

Note that these two expressions are still parsable. This means they would not be subject to automatic semicolon insertion, which will only insert semicolons to fix code that's otherwise unparsable.
js// Still a syntax error
const a = console?.log
`Hello`

Tag functions don't even need to return a string!
jsfunction template(strings, ...keys) {
  return (...values) => {
    const dict = values[values.length - 1] || {};
    const result = [strings[0]];
    keys.forEach((key, i) => {
      const value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

const t1Closure = template`${0}${1}${0}!`;
// const t1Closure = template(["","","","!"],0,1,0);
t1Closure("Y", "A"); // "YAY!"

const t2Closure = template`${0} ${"foo"}!`;
// const t2Closure = template([""," ","!"],0,"foo");
t2Closure("Hello", { foo: "World" }); // "Hello World!"

const t3Closure = template`I'm ${"name"}. I'm almost ${"age"} years old.`;
// const t3Closure = template(["I'm ", ". I'm almost ", " years old."], "name", "age");
t3Closure("foo", { name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."
t3Closure({ name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."

The first argument received by the tag function is an array of strings. For any template literal, its length is equal to the number of substitutions (occurrences of ${…}) plus one, and is therefore always non-empty.
For any particular tagged template literal expression, the tag function will always be called with the exact same literal array, no matter how many times the literal is evaluated.
jsconst callHistory = [];

function tag(strings, ...values) {
  callHistory.push(strings);
  // Return a freshly made object
  return {};
}

function evaluateLiteral() {
  return tag`Hello, ${"world"}!`;
}

console.log(evaluateLiteral() === evaluateLiteral()); // false; each time `tag` is called, it returns a new object
console.log(callHistory[0] === callHistory[1]); // true; all evaluations of the same tagged literal would pass in the same strings array

This allows the tag to cache the result based on the identity of its first argument. To further ensure the array value's stability, the first argument and its raw property are both frozen, so you can't mutate them in any way.Raw stringsThe special raw property, available on the first argument to the tag function, allows you to access the raw strings as they were entered, without processing escape sequences.
jsfunction tag(strings) {
  console.log(strings.raw[0]);
}

tag`string text line 1 \n string text line 2`;
// Logs "string text line 1 \n string text line 2",
// including the two characters '\' and 'n'

In addition, the String.raw() method exists to create raw strings just like the default template function and string concatenation would create.
jsconst str = String.raw`Hi\n${2 + 3}!`;
// "Hi\\n5!"

str.length;
// 6

Array.from(str).join(",");
// "H,i,\\,n,5,!"

String.raw functions like an "identity" tag if the literal doesn't contain any escape sequences. In case you want an actual identity tag that always works as if the literal is untagged, you can make a custom function that passes the "cooked" (i.e., escape sequences are processed) literal array to String.raw, pretending they are raw strings.
jsconst identity = (strings, ...values) =>
  String.raw({ raw: strings }, ...values);
console.log(identity`Hi\n${2 + 3}!`);
// Hi
// 5!

This is useful for many tools which give special treatment to literals tagged by a particular name.
jsconst html = (strings, ...values) => String.raw({ raw: strings }, ...values);
// Some formatters will format this literal's content as HTML
const doc = html`<!doctype html>
  <html lang="en-US">
    <head>
      <title>Hello</title>
    </head>
    <body>
      <h1>Hello world!</h1>
    </body>
  </html>`;
Tagged templates and escape sequencesIn normal template literals, the escape sequences in string literals are all allowed. Any other non-well-formed escape sequence is a syntax error. This includes:

\ followed by any decimal digit other than 0, or \0 followed by a decimal digit; for example \9 and \07 (which is a deprecated syntax)
\x followed by fewer than two hex digits (including none); for example \xz
\u not followed by { and followed by fewer than four hex digits (including none); for example \uz
\u{} enclosing an invalid Unicode code point — it contains a non-hex digit, or its value is greater than 10FFFF; for example \u{110000} and \u{z}


Note: \ followed by other characters, while they may be useless since nothing is escaped, are not syntax errors.

However, this is problematic for tagged templates, which, in addition to the "cooked" literal, also have access to the raw literals (escape sequences are preserved as-is).
Tagged templates enable the embedding of arbitrary string content, where escape sequences may follow a different syntax. Consider for an example where we embed LaTeX source text in JavaScript via String.raw. We want to still be able to use LaTeX macros that start with u or x without following JavaScript syntax restrictions. Therefore, the syntax restriction of well-formed escape sequences is removed from tagged templates. The example below uses MathJax to render LaTeX in one element:
jsconst node = document.getElementById("formula");
MathJax.typesetClear([node]);
// Throws in older ECMAScript versions (ES2016 and earlier)
// SyntaxError: malformed Unicode character escape sequence
node.textContent = String.raw`$\underline{u}$`;
MathJax.typesetPromise([node]);

However, illegal escape sequences must still be represented in the "cooked" representation. They will show up as undefined element in the "cooked" array:
jsfunction log(str) {
  console.log("Cooked:", str[0]);
  console.log("Raw:", str.raw[0]);
}

log`\unicode`;
// Cooked: undefined
// Raw: \unicode

Note that the escape-sequence restriction is only dropped from tagged templates, but not from untagged template literals:
jsconst bad = `bad escape sequence: \unicode`;
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-template-literalsBrowser compatibilitySee also
Numbers and strings guide
String
String.raw()
Lexical grammar
ES6 in Depth: Template strings on hacks.mozilla.org (2015)\n\nTemplate literals (Template strings)Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackTemplate literals are literals delimited with backtick (`) characters, allowing for multi-line strings, string interpolation with embedded expressions, and special constructs called tagged templates.
Template literals are sometimes informally called template strings, because they are used most commonly for string interpolation (to create strings by doing substitution of placeholders). However, a tagged template literal may not result in a string; it can be used with a custom tag function to perform whatever operations you want on the different parts of the template literal.Syntaxjs`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tagFunction`string text ${expression} string text`
Parameters
string text

The string text that will become part of the template literal. Almost all characters are allowed literally, including line breaks and other whitespace characters. However, invalid escape sequences will cause a syntax error, unless a tag function is used.

expression

An expression to be inserted in the current position, whose value is converted to a string or passed to tagFunction.

tagFunction

If specified, it will be called with the template strings array and substitution expressions, and the return value becomes the value of the template literal. See tagged templates.

DescriptionTemplate literals are enclosed by backtick (`) characters instead of double or single quotes.
Along with having normal strings, template literals can also contain other parts called placeholders, which are embedded expressions delimited by a dollar sign and curly braces: ${expression}. The strings and placeholders get passed to a function — either a default function, or a function you supply. The default function (when you don't supply your own) just performs string interpolation to do substitution of the placeholders and then concatenate the parts into a single string.
To supply a function of your own, precede the template literal with a function name; the result is called a tagged template. In that case, the template literal is passed to your tag function, where you can then perform whatever operations you want on the different parts of the template literal.
To escape a backtick in a template literal, put a backslash (\) before the backtick.
js`\`` === "`"; // true

Dollar signs can be escaped as well to prevent interpolation.
js`\${1}` === "${1}"; // true
Multi-line stringsAny newline characters inserted in the source are part of the template literal.
Using normal strings, you would have to use the following syntax in order to get multi-line strings:
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
// string text line 2"

Using template literals, you can do the same with this:
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"

Like normal string literals, you can write a single-line string across multiple lines for source code readability, by escaping the newline with a backslash (\):
jsconsole.log(`string text line 1 \
string text line 2`);
// "string text line 1 string text line 2"
String interpolationWithout template literals, when you want to combine output from expressions with strings, you'd concatenate them using the addition operator +:
jsconst a = 5;
const b = 10;
console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");
// "Fifteen is 15 and
// not 20."

That can be hard to read – especially when you have multiple expressions.
With template literals, you can avoid the concatenation operator — and improve the readability of your code — by using placeholders of the form ${expression} to perform substitutions for embedded expressions:
jsconst a = 5;
const b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
// "Fifteen is 15 and
// not 20."

Note that there's a mild difference between the two syntaxes. Template literals coerce their expressions directly to strings, while addition coerces its operands to primitives first. For more information, see the reference page for the + operator.Nesting templatesIn certain cases, nesting a template is the easiest (and perhaps more readable) way to have configurable strings. Within a backtick-delimited template, it is simple to allow inner backticks by using them inside an ${expression} placeholder within the template.
For example, without template literals, if you wanted to return a certain value based on a particular condition, you could do something like the following:
jslet classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

With a template literal but without nesting, you could do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

With nesting of template literals, you can do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
Tagged templatesA more advanced form of template literals are tagged templates.
Tags allow you to parse template literals with a function. The first argument of a tag function contains an array of string values. The remaining arguments are related to the expressions.
The tag function can then perform whatever operations on these arguments you wish, and return the manipulated string. (Alternatively, it can return something completely different, as described in one of the following examples.)
The name of the function used for the tag can be whatever you want.
jsconst person = "Mike";
const age = 28;

function myTag(strings, personExp, ageExp) {
  const str0 = strings[0]; // "That "
  const str1 = strings[1]; // " is a "
  const str2 = strings[2]; // "."

  const ageStr = ageExp < 100 ? "youngster" : "centenarian";

  // We can even return a string built using a template literal
  return `${str0}${personExp}${str1}${ageStr}${str2}`;
}

const output = myTag`That ${person} is a ${age}.`;

console.log(output);
// That Mike is a youngster.

The tag does not have to be a plain identifier. You can use any expression with precedence greater than 16, which includes property access, function call, new expression, or even another tagged template literal.
jsconsole.log`Hello`; // [ 'Hello' ]
console.log.bind(1, 2)`Hello`; // 2 [ 'Hello' ]
new Function("console.log(arguments)")`Hello`; // [Arguments] { '0': [ 'Hello' ] }

function recursive(strings, ...values) {
  console.log(strings, values);
  return recursive;
}
recursive`Hello``World`;
// [ 'Hello' ] []
// [ 'World' ] []

While technically permitted by the syntax, untagged template literals are strings and will throw a TypeError when chained.
jsconsole.log(`Hello``World`); // TypeError: "Hello" is not a function

The only exception is optional chaining, which will throw a syntax error.
jsconsole.log?.`Hello`; // SyntaxError: Invalid tagged template on optional chain
console?.log`Hello`; // SyntaxError: Invalid tagged template on optional chain

Note that these two expressions are still parsable. This means they would not be subject to automatic semicolon insertion, which will only insert semicolons to fix code that's otherwise unparsable.
js// Still a syntax error
const a = console?.log
`Hello`

Tag functions don't even need to return a string!
jsfunction template(strings, ...keys) {
  return (...values) => {
    const dict = values[values.length - 1] || {};
    const result = [strings[0]];
    keys.forEach((key, i) => {
      const value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

const t1Closure = template`${0}${1}${0}!`;
// const t1Closure = template(["","","","!"],0,1,0);
t1Closure("Y", "A"); // "YAY!"

const t2Closure = template`${0} ${"foo"}!`;
// const t2Closure = template([""," ","!"],0,"foo");
t2Closure("Hello", { foo: "World" }); // "Hello World!"

const t3Closure = template`I'm ${"name"}. I'm almost ${"age"} years old.`;
// const t3Closure = template(["I'm ", ". I'm almost ", " years old."], "name", "age");
t3Closure("foo", { name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."
t3Closure({ name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."

The first argument received by the tag function is an array of strings. For any template literal, its length is equal to the number of substitutions (occurrences of ${…}) plus one, and is therefore always non-empty.
For any particular tagged template literal expression, the tag function will always be called with the exact same literal array, no matter how many times the literal is evaluated.
jsconst callHistory = [];

function tag(strings, ...values) {
  callHistory.push(strings);
  // Return a freshly made object
  return {};
}

function evaluateLiteral() {
  return tag`Hello, ${"world"}!`;
}

console.log(evaluateLiteral() === evaluateLiteral()); // false; each time `tag` is called, it returns a new object
console.log(callHistory[0] === callHistory[1]); // true; all evaluations of the same tagged literal would pass in the same strings array

This allows the tag to cache the result based on the identity of its first argument. To further ensure the array value's stability, the first argument and its raw property are both frozen, so you can't mutate them in any way.Raw stringsThe special raw property, available on the first argument to the tag function, allows you to access the raw strings as they were entered, without processing escape sequences.
jsfunction tag(strings) {
  console.log(strings.raw[0]);
}

tag`string text line 1 \n string text line 2`;
// Logs "string text line 1 \n string text line 2",
// including the two characters '\' and 'n'

In addition, the String.raw() method exists to create raw strings just like the default template function and string concatenation would create.
jsconst str = String.raw`Hi\n${2 + 3}!`;
// "Hi\\n5!"

str.length;
// 6

Array.from(str).join(",");
// "H,i,\\,n,5,!"

String.raw functions like an "identity" tag if the literal doesn't contain any escape sequences. In case you want an actual identity tag that always works as if the literal is untagged, you can make a custom function that passes the "cooked" (i.e., escape sequences are processed) literal array to String.raw, pretending they are raw strings.
jsconst identity = (strings, ...values) =>
  String.raw({ raw: strings }, ...values);
console.log(identity`Hi\n${2 + 3}!`);
// Hi
// 5!

This is useful for many tools which give special treatment to literals tagged by a particular name.
jsconst html = (strings, ...values) => String.raw({ raw: strings }, ...values);
// Some formatters will format this literal's content as HTML
const doc = html`<!doctype html>
  <html lang="en-US">
    <head>
      <title>Hello</title>
    </head>
    <body>
      <h1>Hello world!</h1>
    </body>
  </html>`;
Tagged templates and escape sequencesIn normal template literals, the escape sequences in string literals are all allowed. Any other non-well-formed escape sequence is a syntax error. This includes:

\ followed by any decimal digit other than 0, or \0 followed by a decimal digit; for example \9 and \07 (which is a deprecated syntax)
\x followed by fewer than two hex digits (including none); for example \xz
\u not followed by { and followed by fewer than four hex digits (including none); for example \uz
\u{} enclosing an invalid Unicode code point — it contains a non-hex digit, or its value is greater than 10FFFF; for example \u{110000} and \u{z}


Note: \ followed by other characters, while they may be useless since nothing is escaped, are not syntax errors.

However, this is problematic for tagged templates, which, in addition to the "cooked" literal, also have access to the raw literals (escape sequences are preserved as-is).
Tagged templates enable the embedding of arbitrary string content, where escape sequences may follow a different syntax. Consider for an example where we embed LaTeX source text in JavaScript via String.raw. We want to still be able to use LaTeX macros that start with u or x without following JavaScript syntax restrictions. Therefore, the syntax restriction of well-formed escape sequences is removed from tagged templates. The example below uses MathJax to render LaTeX in one element:
jsconst node = document.getElementById("formula");
MathJax.typesetClear([node]);
// Throws in older ECMAScript versions (ES2016 and earlier)
// SyntaxError: malformed Unicode character escape sequence
node.textContent = String.raw`$\underline{u}$`;
MathJax.typesetPromise([node]);

However, illegal escape sequences must still be represented in the "cooked" representation. They will show up as undefined element in the "cooked" array:
jsfunction log(str) {
  console.log("Cooked:", str[0]);
  console.log("Raw:", str.raw[0]);
}

log`\unicode`;
// Cooked: undefined
// Raw: \unicode

Note that the escape-sequence restriction is only dropped from tagged templates, but not from untagged template literals:
jsconst bad = `bad escape sequence: \unicode`;
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-template-literalsBrowser compatibilitySee also
Numbers and strings guide
String
String.raw()
Lexical grammar
ES6 in Depth: Template strings on hacks.mozilla.org (2015)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nTemplate literals (Template strings)Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackTemplate literals are literals delimited with backtick (`) characters, allowing for multi-line strings, string interpolation with embedded expressions, and special constructs called tagged templates.
Template literals are sometimes informally called template strings, because they are used most commonly for string interpolation (to create strings by doing substitution of placeholders). However, a tagged template literal may not result in a string; it can be used with a custom tag function to perform whatever operations you want on the different parts of the template literal.Syntaxjs`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tagFunction`string text ${expression} string text`
Parameters
string text

The string text that will become part of the template literal. Almost all characters are allowed literally, including line breaks and other whitespace characters. However, invalid escape sequences will cause a syntax error, unless a tag function is used.

expression

An expression to be inserted in the current position, whose value is converted to a string or passed to tagFunction.

tagFunction

If specified, it will be called with the template strings array and substitution expressions, and the return value becomes the value of the template literal. See tagged templates.

DescriptionTemplate literals are enclosed by backtick (`) characters instead of double or single quotes.
Along with having normal strings, template literals can also contain other parts called placeholders, which are embedded expressions delimited by a dollar sign and curly braces: ${expression}. The strings and placeholders get passed to a function — either a default function, or a function you supply. The default function (when you don't supply your own) just performs string interpolation to do substitution of the placeholders and then concatenate the parts into a single string.
To supply a function of your own, precede the template literal with a function name; the result is called a tagged template. In that case, the template literal is passed to your tag function, where you can then perform whatever operations you want on the different parts of the template literal.
To escape a backtick in a template literal, put a backslash (\) before the backtick.
js`\`` === "`"; // true

Dollar signs can be escaped as well to prevent interpolation.
js`\${1}` === "${1}"; // true
Multi-line stringsAny newline characters inserted in the source are part of the template literal.
Using normal strings, you would have to use the following syntax in order to get multi-line strings:
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
// string text line 2"

Using template literals, you can do the same with this:
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"

Like normal string literals, you can write a single-line string across multiple lines for source code readability, by escaping the newline with a backslash (\):
jsconsole.log(`string text line 1 \
string text line 2`);
// "string text line 1 string text line 2"
String interpolationWithout template literals, when you want to combine output from expressions with strings, you'd concatenate them using the addition operator +:
jsconst a = 5;
const b = 10;
console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");
// "Fifteen is 15 and
// not 20."

That can be hard to read – especially when you have multiple expressions.
With template literals, you can avoid the concatenation operator — and improve the readability of your code — by using placeholders of the form ${expression} to perform substitutions for embedded expressions:
jsconst a = 5;
const b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
// "Fifteen is 15 and
// not 20."

Note that there's a mild difference between the two syntaxes. Template literals coerce their expressions directly to strings, while addition coerces its operands to primitives first. For more information, see the reference page for the + operator.Nesting templatesIn certain cases, nesting a template is the easiest (and perhaps more readable) way to have configurable strings. Within a backtick-delimited template, it is simple to allow inner backticks by using them inside an ${expression} placeholder within the template.
For example, without template literals, if you wanted to return a certain value based on a particular condition, you could do something like the following:
jslet classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

With a template literal but without nesting, you could do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

With nesting of template literals, you can do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
Tagged templatesA more advanced form of template literals are tagged templates.
Tags allow you to parse template literals with a function. The first argument of a tag function contains an array of string values. The remaining arguments are related to the expressions.
The tag function can then perform whatever operations on these arguments you wish, and return the manipulated string. (Alternatively, it can return something completely different, as described in one of the following examples.)
The name of the function used for the tag can be whatever you want.
jsconst person = "Mike";
const age = 28;

function myTag(strings, personExp, ageExp) {
  const str0 = strings[0]; // "That "
  const str1 = strings[1]; // " is a "
  const str2 = strings[2]; // "."

  const ageStr = ageExp < 100 ? "youngster" : "centenarian";

  // We can even return a string built using a template literal
  return `${str0}${personExp}${str1}${ageStr}${str2}`;
}

const output = myTag`That ${person} is a ${age}.`;

console.log(output);
// That Mike is a youngster.

The tag does not have to be a plain identifier. You can use any expression with precedence greater than 16, which includes property access, function call, new expression, or even another tagged template literal.
jsconsole.log`Hello`; // [ 'Hello' ]
console.log.bind(1, 2)`Hello`; // 2 [ 'Hello' ]
new Function("console.log(arguments)")`Hello`; // [Arguments] { '0': [ 'Hello' ] }

function recursive(strings, ...values) {
  console.log(strings, values);
  return recursive;
}
recursive`Hello``World`;
// [ 'Hello' ] []
// [ 'World' ] []

While technically permitted by the syntax, untagged template literals are strings and will throw a TypeError when chained.
jsconsole.log(`Hello``World`); // TypeError: "Hello" is not a function

The only exception is optional chaining, which will throw a syntax error.
jsconsole.log?.`Hello`; // SyntaxError: Invalid tagged template on optional chain
console?.log`Hello`; // SyntaxError: Invalid tagged template on optional chain

Note that these two expressions are still parsable. This means they would not be subject to automatic semicolon insertion, which will only insert semicolons to fix code that's otherwise unparsable.
js// Still a syntax error
const a = console?.log
`Hello`

Tag functions don't even need to return a string!
jsfunction template(strings, ...keys) {
  return (...values) => {
    const dict = values[values.length - 1] || {};
    const result = [strings[0]];
    keys.forEach((key, i) => {
      const value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

const t1Closure = template`${0}${1}${0}!`;
// const t1Closure = template(["","","","!"],0,1,0);
t1Closure("Y", "A"); // "YAY!"

const t2Closure = template`${0} ${"foo"}!`;
// const t2Closure = template([""," ","!"],0,"foo");
t2Closure("Hello", { foo: "World" }); // "Hello World!"

const t3Closure = template`I'm ${"name"}. I'm almost ${"age"} years old.`;
// const t3Closure = template(["I'm ", ". I'm almost ", " years old."], "name", "age");
t3Closure("foo", { name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."
t3Closure({ name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."

The first argument received by the tag function is an array of strings. For any template literal, its length is equal to the number of substitutions (occurrences of ${…}) plus one, and is therefore always non-empty.
For any particular tagged template literal expression, the tag function will always be called with the exact same literal array, no matter how many times the literal is evaluated.
jsconst callHistory = [];

function tag(strings, ...values) {
  callHistory.push(strings);
  // Return a freshly made object
  return {};
}

function evaluateLiteral() {
  return tag`Hello, ${"world"}!`;
}

console.log(evaluateLiteral() === evaluateLiteral()); // false; each time `tag` is called, it returns a new object
console.log(callHistory[0] === callHistory[1]); // true; all evaluations of the same tagged literal would pass in the same strings array

This allows the tag to cache the result based on the identity of its first argument. To further ensure the array value's stability, the first argument and its raw property are both frozen, so you can't mutate them in any way.Raw stringsThe special raw property, available on the first argument to the tag function, allows you to access the raw strings as they were entered, without processing escape sequences.
jsfunction tag(strings) {
  console.log(strings.raw[0]);
}

tag`string text line 1 \n string text line 2`;
// Logs "string text line 1 \n string text line 2",
// including the two characters '\' and 'n'

In addition, the String.raw() method exists to create raw strings just like the default template function and string concatenation would create.
jsconst str = String.raw`Hi\n${2 + 3}!`;
// "Hi\\n5!"

str.length;
// 6

Array.from(str).join(",");
// "H,i,\\,n,5,!"

String.raw functions like an "identity" tag if the literal doesn't contain any escape sequences. In case you want an actual identity tag that always works as if the literal is untagged, you can make a custom function that passes the "cooked" (i.e., escape sequences are processed) literal array to String.raw, pretending they are raw strings.
jsconst identity = (strings, ...values) =>
  String.raw({ raw: strings }, ...values);
console.log(identity`Hi\n${2 + 3}!`);
// Hi
// 5!

This is useful for many tools which give special treatment to literals tagged by a particular name.
jsconst html = (strings, ...values) => String.raw({ raw: strings }, ...values);
// Some formatters will format this literal's content as HTML
const doc = html`<!doctype html>
  <html lang="en-US">
    <head>
      <title>Hello</title>
    </head>
    <body>
      <h1>Hello world!</h1>
    </body>
  </html>`;
Tagged templates and escape sequencesIn normal template literals, the escape sequences in string literals are all allowed. Any other non-well-formed escape sequence is a syntax error. This includes:

\ followed by any decimal digit other than 0, or \0 followed by a decimal digit; for example \9 and \07 (which is a deprecated syntax)
\x followed by fewer than two hex digits (including none); for example \xz
\u not followed by { and followed by fewer than four hex digits (including none); for example \uz
\u{} enclosing an invalid Unicode code point — it contains a non-hex digit, or its value is greater than 10FFFF; for example \u{110000} and \u{z}


Note: \ followed by other characters, while they may be useless since nothing is escaped, are not syntax errors.

However, this is problematic for tagged templates, which, in addition to the "cooked" literal, also have access to the raw literals (escape sequences are preserved as-is).
Tagged templates enable the embedding of arbitrary string content, where escape sequences may follow a different syntax. Consider for an example where we embed LaTeX source text in JavaScript via String.raw. We want to still be able to use LaTeX macros that start with u or x without following JavaScript syntax restrictions. Therefore, the syntax restriction of well-formed escape sequences is removed from tagged templates. The example below uses MathJax to render LaTeX in one element:
jsconst node = document.getElementById("formula");
MathJax.typesetClear([node]);
// Throws in older ECMAScript versions (ES2016 and earlier)
// SyntaxError: malformed Unicode character escape sequence
node.textContent = String.raw`$\underline{u}$`;
MathJax.typesetPromise([node]);

However, illegal escape sequences must still be represented in the "cooked" representation. They will show up as undefined element in the "cooked" array:
jsfunction log(str) {
  console.log("Cooked:", str[0]);
  console.log("Raw:", str.raw[0]);
}

log`\unicode`;
// Cooked: undefined
// Raw: \unicode

Note that the escape-sequence restriction is only dropped from tagged templates, but not from untagged template literals:
jsconst bad = `bad escape sequence: \unicode`;
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-template-literalsBrowser compatibilitySee also
Numbers and strings guide
String
String.raw()
Lexical grammar
ES6 in Depth: Template strings on hacks.mozilla.org (2015)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nResources for Developers, by DevelopersDocumenting web technologies, including CSS, HTML, and JavaScript, since 2005.Search MDNClear search inputSearchFeatured articlesBlogJavaScript Temporal is comingA new way to handle dates and times is being added to JavaScript. Let's take a look at Temporal, what problems it solves, the current state, and what you'll find in the new documentation about it on MDN.
CSSCSS anchor positioningThe CSS anchor positioning module defines features that allow you to tether elements together. Certain elements are defined as anchor elements; anchor-positioned elements can then have their size and position set based on the size and location of the anchor elements to which they are bound.
Web APIsUsing the View Transition APIThis article explains the theory behind how the View Transition API works, how to create view transitions and customize the transition animations, and how to manipulate active view transitions. This covers view transitions for both DOM state updates in a single-page app (SPA), and navigating between documents in a multi-page app (MPA).
JavaScriptTemporalThe Temporal object enables date and time management in various scenarios, including built-in time zone and calendar representation, wall-clock time conversions, arithmetics, formatting, and more. It is designed as a full replacement for the Date object.
Latest newsMDN 2024 content projectsdeveloper.mozilla.org3 months agoA new learning experience on MDNdeveloper.mozilla.org4 months agoIntroducing the new MDN Community pagedeveloper.mozilla.org6 months agoRecent contributionszh-CN: create `webRequest.CertificateInfo`mdn/translated-contenta day ago[zh-tw] Global attributes classmdn/translated-contenta day agozh-cn: add new page for br instructionmdn/translated-content13 hours agozh-cn: add new page for block instructionmdn/translated-content13 hours agozh-cn: add new page for call instructionmdn/translated-content13 hours agoFix title typomdn/content8 hours agosimplify WritableStream examplemdn/content7 hours agoMake all JS articles reachable via sidebarmdn/content5 hours agoAdd more links to the Wasm sidebarmdn/contentan hour agoMerge Transforming_XML_with_XSLT subarticles into itselfmdn/contentan hour agoContributor SpotlightYash Raj BhartiMDN resonates with my passion to build a consistent and open web, where developers can learn and grow.Get involved →\n\nResources for Developers, by DevelopersDocumenting web technologies, including CSS, HTML, and JavaScript, since 2005.Search MDNClear search inputSearchFeatured articlesBlogJavaScript Temporal is comingA new way to handle dates and times is being added to JavaScript. Let's take a look at Temporal, what problems it solves, the current state, and what you'll find in the new documentation about it on MDN.
CSSCSS anchor positioningThe CSS anchor positioning module defines features that allow you to tether elements together. Certain elements are defined as anchor elements; anchor-positioned elements can then have their size and position set based on the size and location of the anchor elements to which they are bound.
Web APIsUsing the View Transition APIThis article explains the theory behind how the View Transition API works, how to create view transitions and customize the transition animations, and how to manipulate active view transitions. This covers view transitions for both DOM state updates in a single-page app (SPA), and navigating between documents in a multi-page app (MPA).
JavaScriptTemporalThe Temporal object enables date and time management in various scenarios, including built-in time zone and calendar representation, wall-clock time conversions, arithmetics, formatting, and more. It is designed as a full replacement for the Date object.
Latest newsMDN 2024 content projectsdeveloper.mozilla.org3 months agoA new learning experience on MDNdeveloper.mozilla.org4 months agoIntroducing the new MDN Community pagedeveloper.mozilla.org6 months agoRecent contributionszh-CN: create `webRequest.CertificateInfo`mdn/translated-contenta day ago[zh-tw] Global attributes classmdn/translated-contenta day agozh-cn: add new page for br instructionmdn/translated-content13 hours agozh-cn: add new page for block instructionmdn/translated-content13 hours agozh-cn: add new page for call instructionmdn/translated-content13 hours agoFix title typomdn/content8 hours agosimplify WritableStream examplemdn/content7 hours agoMake all JS articles reachable via sidebarmdn/content5 hours agoAdd more links to the Wasm sidebarmdn/contentan hour agoMerge Transforming_XML_with_XSLT subarticles into itselfmdn/contentan hour agoContributor SpotlightYash Raj BhartiMDN resonates with my passion to build a consistent and open web, where developers can learn and grow.Get involved →\n\n\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

Guides
HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

Guides
HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

Guides
HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nCSS: Cascading Style SheetsCascading Style Sheets (CSS) is a stylesheet language used to describe the presentation of a document written in HTML or XML (including XML dialects such as SVG, MathML or XHTML). CSS describes how elements should be rendered on screen, on paper, in speech, or on other media.
CSS is among the core languages of the open web and is standardized across Web browsers according to W3C specifications. Previously, the development of various parts of CSS specification was done synchronously, which allowed the versioning of the latest recommendations. You might have heard about CSS1, CSS2.1, or even CSS3. There will never be a CSS3 or a CSS4; rather, everything is now just "CSS" with individual CSS modules having version numbers.
After CSS 2.1, the scope of the specification increased significantly and the progress on different CSS modules started to differ so much, that it became more effective to develop and release recommendations separately per module. Instead of versioning the CSS specification, W3C now periodically takes a snapshot of the latest stable state of the CSS specification and individual modules progress. CSS modules now have version numbers, or levels, such as CSS Color Module Level 5.Beginner's tutorials
Your first website: Styling the content

This article provides a brief tour of what CSS is and how to use it, aimed at people who are completely new to web development.

CSS styling basics

Our Learn web development section's CSS basics module teaches CSS fundamentals from the ground up.

CSS text styling

Here we look at fundamentals including setting font, boldness, italics, line and letter spacing, drop shadows, and other text features. We round off the module by looking at applying custom fonts to your page, and styling lists and links.

CSS layout

Now it's time to look at how to correctly lay out your boxes in relation to one another, and the browser viewport. This module looks at floats, positioning, other modern layout tools, and building responsive designs that will adapt to different devices, screen sizes, and resolutions.

ReferenceThe CSS reference is an exhaustive reference for seasoned Web developers, describing every property and concept of CSS, including:

The syntax and forms of the language
Specificity, inheritance, and the cascade
CSS selectors, including pseudo-elements, nesting, scoping and shadow parts
CSS at-rules, including media and container queries
CSS values and units module, including numeric data types, textual data types and functional notations
Box model and margin collapse
The containing block
Stacking and block-formatting contexts
Initial, computed, used, and actual values
CSS shorthand properties
CSS flexible box, multi-column and grid layout
Animation, transitions, and transforms
CookbookThe CSS layout cookbook aims to bring together recipes for common layout patterns, things you might need to implement in your sites. In addition to providing code you can use as a starting point in your projects, these recipes highlight the different ways layout specifications can be used and the choices you can make as a developer.Tools for CSS development
You can use the W3C CSS Validation Service to check if your CSS is valid. This is an invaluable debugging tool.
Firefox Developer Tools lets you view and edit a page's live CSS via the Inspector and Style Editor tools.
The Web Developer extension for Firefox lets you track and edit live CSS on watched sites.
Meta bugs
Firefox: Firefox bug 1323667
See also
Web languages to which CSS is often applied: HTML, SVG, MathML, XHTML, and XML.
Stack Overflow questions about CSS\n\nCSS: Cascading Style SheetsCascading Style Sheets (CSS) is a stylesheet language used to describe the presentation of a document written in HTML or XML (including XML dialects such as SVG, MathML or XHTML). CSS describes how elements should be rendered on screen, on paper, in speech, or on other media.
CSS is among the core languages of the open web and is standardized across Web browsers according to W3C specifications. Previously, the development of various parts of CSS specification was done synchronously, which allowed the versioning of the latest recommendations. You might have heard about CSS1, CSS2.1, or even CSS3. There will never be a CSS3 or a CSS4; rather, everything is now just "CSS" with individual CSS modules having version numbers.
After CSS 2.1, the scope of the specification increased significantly and the progress on different CSS modules started to differ so much, that it became more effective to develop and release recommendations separately per module. Instead of versioning the CSS specification, W3C now periodically takes a snapshot of the latest stable state of the CSS specification and individual modules progress. CSS modules now have version numbers, or levels, such as CSS Color Module Level 5.Beginner's tutorials
Your first website: Styling the content

This article provides a brief tour of what CSS is and how to use it, aimed at people who are completely new to web development.

CSS styling basics

Our Learn web development section's CSS basics module teaches CSS fundamentals from the ground up.

CSS text styling

Here we look at fundamentals including setting font, boldness, italics, line and letter spacing, drop shadows, and other text features. We round off the module by looking at applying custom fonts to your page, and styling lists and links.

CSS layout

Now it's time to look at how to correctly lay out your boxes in relation to one another, and the browser viewport. This module looks at floats, positioning, other modern layout tools, and building responsive designs that will adapt to different devices, screen sizes, and resolutions.

ReferenceThe CSS reference is an exhaustive reference for seasoned Web developers, describing every property and concept of CSS, including:

The syntax and forms of the language
Specificity, inheritance, and the cascade
CSS selectors, including pseudo-elements, nesting, scoping and shadow parts
CSS at-rules, including media and container queries
CSS values and units module, including numeric data types, textual data types and functional notations
Box model and margin collapse
The containing block
Stacking and block-formatting contexts
Initial, computed, used, and actual values
CSS shorthand properties
CSS flexible box, multi-column and grid layout
Animation, transitions, and transforms
CookbookThe CSS layout cookbook aims to bring together recipes for common layout patterns, things you might need to implement in your sites. In addition to providing code you can use as a starting point in your projects, these recipes highlight the different ways layout specifications can be used and the choices you can make as a developer.Tools for CSS development
You can use the W3C CSS Validation Service to check if your CSS is valid. This is an invaluable debugging tool.
Firefox Developer Tools lets you view and edit a page's live CSS via the Inspector and Style Editor tools.
The Web Developer extension for Firefox lets you track and edit live CSS on watched sites.
Meta bugs
Firefox: Firefox bug 1323667
See also
Web languages to which CSS is often applied: HTML, SVG, MathML, XHTML, and XML.
Stack Overflow questions about CSS
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 22, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nCSS: Cascading Style SheetsCascading Style Sheets (CSS) is a stylesheet language used to describe the presentation of a document written in HTML or XML (including XML dialects such as SVG, MathML or XHTML). CSS describes how elements should be rendered on screen, on paper, in speech, or on other media.
CSS is among the core languages of the open web and is standardized across Web browsers according to W3C specifications. Previously, the development of various parts of CSS specification was done synchronously, which allowed the versioning of the latest recommendations. You might have heard about CSS1, CSS2.1, or even CSS3. There will never be a CSS3 or a CSS4; rather, everything is now just "CSS" with individual CSS modules having version numbers.
After CSS 2.1, the scope of the specification increased significantly and the progress on different CSS modules started to differ so much, that it became more effective to develop and release recommendations separately per module. Instead of versioning the CSS specification, W3C now periodically takes a snapshot of the latest stable state of the CSS specification and individual modules progress. CSS modules now have version numbers, or levels, such as CSS Color Module Level 5.Beginner's tutorials
Your first website: Styling the content

This article provides a brief tour of what CSS is and how to use it, aimed at people who are completely new to web development.

CSS styling basics

Our Learn web development section's CSS basics module teaches CSS fundamentals from the ground up.

CSS text styling

Here we look at fundamentals including setting font, boldness, italics, line and letter spacing, drop shadows, and other text features. We round off the module by looking at applying custom fonts to your page, and styling lists and links.

CSS layout

Now it's time to look at how to correctly lay out your boxes in relation to one another, and the browser viewport. This module looks at floats, positioning, other modern layout tools, and building responsive designs that will adapt to different devices, screen sizes, and resolutions.

ReferenceThe CSS reference is an exhaustive reference for seasoned Web developers, describing every property and concept of CSS, including:

The syntax and forms of the language
Specificity, inheritance, and the cascade
CSS selectors, including pseudo-elements, nesting, scoping and shadow parts
CSS at-rules, including media and container queries
CSS values and units module, including numeric data types, textual data types and functional notations
Box model and margin collapse
The containing block
Stacking and block-formatting contexts
Initial, computed, used, and actual values
CSS shorthand properties
CSS flexible box, multi-column and grid layout
Animation, transitions, and transforms
CookbookThe CSS layout cookbook aims to bring together recipes for common layout patterns, things you might need to implement in your sites. In addition to providing code you can use as a starting point in your projects, these recipes highlight the different ways layout specifications can be used and the choices you can make as a developer.Tools for CSS development
You can use the W3C CSS Validation Service to check if your CSS is valid. This is an invaluable debugging tool.
Firefox Developer Tools lets you view and edit a page's live CSS via the Inspector and Style Editor tools.
The Web Developer extension for Firefox lets you track and edit live CSS on watched sites.
Meta bugs
Firefox: Firefox bug 1323667
See also
Web languages to which CSS is often applied: HTML, SVG, MathML, XHTML, and XML.
Stack Overflow questions about CSS
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 22, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJavaScriptJavaScript (JS) is a lightweight interpreted (or just-in-time compiled) programming language with first-class functions. While it is most well-known as the scripting language for Web pages, many non-browser environments also use it, such as Node.js, Apache CouchDB and Adobe Acrobat. JavaScript is a prototype-based, multi-paradigm, single-threaded, dynamic language, supporting object-oriented, imperative, and declarative (e.g., functional programming) styles.
JavaScript's dynamic capabilities include runtime object construction, variable parameter lists, function variables, dynamic script creation (via eval), object introspection (via for...in and Object utilities), and source-code recovery (JavaScript functions store their source text and can be retrieved through toString()).
This section is dedicated to the JavaScript language itself, and not the parts that are specific to Web pages or other host environments. For information about APIs that are specific to Web pages, please see Web APIs and DOM.
The standards for JavaScript are the ECMAScript Language Specification (ECMA-262) and the ECMAScript Internationalization API specification (ECMA-402). As soon as one browser implements a feature, we try to document it. This means that cases where some proposals for new ECMAScript features have already been implemented in browsers, documentation and examples in MDN articles may use some of those new features. Most of the time, this happens between the stages 3 and 4, and is usually before the spec is officially published.
Do not confuse JavaScript with the Java programming language — JavaScript is not "Interpreted Java". Both "Java" and "JavaScript" are trademarks or registered trademarks of Oracle in the U.S. and other countries. However, the two programming languages have very different syntax, semantics, and use.
JavaScript documentation of core language features (pure ECMAScript, for the most part) includes the following:

The JavaScript guide
The JavaScript reference

For more information about JavaScript specifications and related technologies, see JavaScript technologies overview.Beginner's tutorialsLearn how to program in JavaScript from the ground up with our beginner's tutorials.

Your first website: Adding interactivity

This article provides a brief tour of what JavaScript is and how to use it, aimed at people who are completely new to web development.

Dynamic scripting with JavaScript

Our Learn web development section's JavaScript module teaches all the JavaScript fundamentals from the ground up.

JavaScript frameworks and libraries

JavaScript frameworks are an essential part of modern front-end web development, providing developers with tried and tested tools for building scalable, interactive web applications. Many modern companies use frameworks as a standard part of their tooling, so many front-end development jobs now require framework experience. In this set of articles, we aim to give you a comfortable starting point to help you begin learning frameworks.

JavaScript guidesFundamental language guides
JavaScript Guide

A much more detailed guide to the JavaScript language, aimed at those with previous programming experience either in JavaScript or another language.

Intermediate
Advanced JavaScript objects

The object-oriented nature of JavaScript is important to understand if you want to go further with your knowledge of the language and write more efficient code, therefore we've provided this module to help you.

Asynchronous JavaScript

In this module, we take a look at asynchronous JavaScript, why it is important, and how it can be used to effectively handle potential blocking operations, such as fetching resources from a server.

Client-side web APIs

Explores what APIs are, and how to use some of the most common APIs you'll come across often in your development work.

JavaScript language overview

An overview of the basic syntax and semantics of JavaScript for those coming from other programming languages to get up to speed.

JavaScript data structures

Overview of available data structures in JavaScript.

Equality comparisons and sameness

JavaScript provides three different value comparison operations: strict equality using ===, loose equality using ==, and the Object.is() method.

Enumerability and ownership of properties

How different methods that visit a group of object properties one-by-one handle the enumerability and ownership of properties.

Closures

A closure is the combination of a function and the lexical environment within which that function was declared.

Advanced
Inheritance and the prototype chain

Explanation of the widely misunderstood and underestimated prototype-based inheritance.

Memory Management

Memory life cycle and garbage collection in JavaScript.

ReferenceBrowse the complete JavaScript reference documentation.

Standard objects

Get to know standard built-in objects: Array, Boolean, Error, Function, JSON, Math, Number, Object, RegExp, String, Map, Set, WeakMap, WeakSet, and others.

Expressions and operators

Learn more about the behavior of JavaScript's operators instanceof, typeof, new, this, the operator precedence, and more.

Statements and declarations

Learn how do-while, for-in, for-of, try-catch, let, var, const, if-else, switch, and more JavaScript statements and keywords work.

Functions

Learn how to work with JavaScript's functions to develop your applications.

Classes

JavaScript classes are the most appropriate way to do object-oriented programming.\n\nJavaScriptJavaScript (JS) is a lightweight interpreted (or just-in-time compiled) programming language with first-class functions. While it is most well-known as the scripting language for Web pages, many non-browser environments also use it, such as Node.js, Apache CouchDB and Adobe Acrobat. JavaScript is a prototype-based, multi-paradigm, single-threaded, dynamic language, supporting object-oriented, imperative, and declarative (e.g., functional programming) styles.
JavaScript's dynamic capabilities include runtime object construction, variable parameter lists, function variables, dynamic script creation (via eval), object introspection (via for...in and Object utilities), and source-code recovery (JavaScript functions store their source text and can be retrieved through toString()).
This section is dedicated to the JavaScript language itself, and not the parts that are specific to Web pages or other host environments. For information about APIs that are specific to Web pages, please see Web APIs and DOM.
The standards for JavaScript are the ECMAScript Language Specification (ECMA-262) and the ECMAScript Internationalization API specification (ECMA-402). As soon as one browser implements a feature, we try to document it. This means that cases where some proposals for new ECMAScript features have already been implemented in browsers, documentation and examples in MDN articles may use some of those new features. Most of the time, this happens between the stages 3 and 4, and is usually before the spec is officially published.
Do not confuse JavaScript with the Java programming language — JavaScript is not "Interpreted Java". Both "Java" and "JavaScript" are trademarks or registered trademarks of Oracle in the U.S. and other countries. However, the two programming languages have very different syntax, semantics, and use.
JavaScript documentation of core language features (pure ECMAScript, for the most part) includes the following:

The JavaScript guide
The JavaScript reference

For more information about JavaScript specifications and related technologies, see JavaScript technologies overview.Beginner's tutorialsLearn how to program in JavaScript from the ground up with our beginner's tutorials.

Your first website: Adding interactivity

This article provides a brief tour of what JavaScript is and how to use it, aimed at people who are completely new to web development.

Dynamic scripting with JavaScript

Our Learn web development section's JavaScript module teaches all the JavaScript fundamentals from the ground up.

JavaScript frameworks and libraries

JavaScript frameworks are an essential part of modern front-end web development, providing developers with tried and tested tools for building scalable, interactive web applications. Many modern companies use frameworks as a standard part of their tooling, so many front-end development jobs now require framework experience. In this set of articles, we aim to give you a comfortable starting point to help you begin learning frameworks.

JavaScript guidesFundamental language guides
JavaScript Guide

A much more detailed guide to the JavaScript language, aimed at those with previous programming experience either in JavaScript or another language.

Intermediate
Advanced JavaScript objects

The object-oriented nature of JavaScript is important to understand if you want to go further with your knowledge of the language and write more efficient code, therefore we've provided this module to help you.

Asynchronous JavaScript

In this module, we take a look at asynchronous JavaScript, why it is important, and how it can be used to effectively handle potential blocking operations, such as fetching resources from a server.

Client-side web APIs

Explores what APIs are, and how to use some of the most common APIs you'll come across often in your development work.

JavaScript language overview

An overview of the basic syntax and semantics of JavaScript for those coming from other programming languages to get up to speed.

JavaScript data structures

Overview of available data structures in JavaScript.

Equality comparisons and sameness

JavaScript provides three different value comparison operations: strict equality using ===, loose equality using ==, and the Object.is() method.

Enumerability and ownership of properties

How different methods that visit a group of object properties one-by-one handle the enumerability and ownership of properties.

Closures

A closure is the combination of a function and the lexical environment within which that function was declared.

Advanced
Inheritance and the prototype chain

Explanation of the widely misunderstood and underestimated prototype-based inheritance.

Memory Management

Memory life cycle and garbage collection in JavaScript.

ReferenceBrowse the complete JavaScript reference documentation.

Standard objects

Get to know standard built-in objects: Array, Boolean, Error, Function, JSON, Math, Number, Object, RegExp, String, Map, Set, WeakMap, WeakSet, and others.

Expressions and operators

Learn more about the behavior of JavaScript's operators instanceof, typeof, new, this, the operator precedence, and more.

Statements and declarations

Learn how do-while, for-in, for-of, try-catch, let, var, const, if-else, switch, and more JavaScript statements and keywords work.

Functions

Learn how to work with JavaScript's functions to develop your applications.

Classes

JavaScript classes are the most appropriate way to do object-oriented programming.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJavaScriptJavaScript (JS) is a lightweight interpreted (or just-in-time compiled) programming language with first-class functions. While it is most well-known as the scripting language for Web pages, many non-browser environments also use it, such as Node.js, Apache CouchDB and Adobe Acrobat. JavaScript is a prototype-based, multi-paradigm, single-threaded, dynamic language, supporting object-oriented, imperative, and declarative (e.g., functional programming) styles.
JavaScript's dynamic capabilities include runtime object construction, variable parameter lists, function variables, dynamic script creation (via eval), object introspection (via for...in and Object utilities), and source-code recovery (JavaScript functions store their source text and can be retrieved through toString()).
This section is dedicated to the JavaScript language itself, and not the parts that are specific to Web pages or other host environments. For information about APIs that are specific to Web pages, please see Web APIs and DOM.
The standards for JavaScript are the ECMAScript Language Specification (ECMA-262) and the ECMAScript Internationalization API specification (ECMA-402). As soon as one browser implements a feature, we try to document it. This means that cases where some proposals for new ECMAScript features have already been implemented in browsers, documentation and examples in MDN articles may use some of those new features. Most of the time, this happens between the stages 3 and 4, and is usually before the spec is officially published.
Do not confuse JavaScript with the Java programming language — JavaScript is not "Interpreted Java". Both "Java" and "JavaScript" are trademarks or registered trademarks of Oracle in the U.S. and other countries. However, the two programming languages have very different syntax, semantics, and use.
JavaScript documentation of core language features (pure ECMAScript, for the most part) includes the following:

The JavaScript guide
The JavaScript reference

For more information about JavaScript specifications and related technologies, see JavaScript technologies overview.Beginner's tutorialsLearn how to program in JavaScript from the ground up with our beginner's tutorials.

Your first website: Adding interactivity

This article provides a brief tour of what JavaScript is and how to use it, aimed at people who are completely new to web development.

Dynamic scripting with JavaScript

Our Learn web development section's JavaScript module teaches all the JavaScript fundamentals from the ground up.

JavaScript frameworks and libraries

JavaScript frameworks are an essential part of modern front-end web development, providing developers with tried and tested tools for building scalable, interactive web applications. Many modern companies use frameworks as a standard part of their tooling, so many front-end development jobs now require framework experience. In this set of articles, we aim to give you a comfortable starting point to help you begin learning frameworks.

JavaScript guidesFundamental language guides
JavaScript Guide

A much more detailed guide to the JavaScript language, aimed at those with previous programming experience either in JavaScript or another language.

Intermediate
Advanced JavaScript objects

The object-oriented nature of JavaScript is important to understand if you want to go further with your knowledge of the language and write more efficient code, therefore we've provided this module to help you.

Asynchronous JavaScript

In this module, we take a look at asynchronous JavaScript, why it is important, and how it can be used to effectively handle potential blocking operations, such as fetching resources from a server.

Client-side web APIs

Explores what APIs are, and how to use some of the most common APIs you'll come across often in your development work.

JavaScript language overview

An overview of the basic syntax and semantics of JavaScript for those coming from other programming languages to get up to speed.

JavaScript data structures

Overview of available data structures in JavaScript.

Equality comparisons and sameness

JavaScript provides three different value comparison operations: strict equality using ===, loose equality using ==, and the Object.is() method.

Enumerability and ownership of properties

How different methods that visit a group of object properties one-by-one handle the enumerability and ownership of properties.

Closures

A closure is the combination of a function and the lexical environment within which that function was declared.

Advanced
Inheritance and the prototype chain

Explanation of the widely misunderstood and underestimated prototype-based inheritance.

Memory Management

Memory life cycle and garbage collection in JavaScript.

ReferenceBrowse the complete JavaScript reference documentation.

Standard objects

Get to know standard built-in objects: Array, Boolean, Error, Function, JSON, Math, Number, Object, RegExp, String, Map, Set, WeakMap, WeakSet, and others.

Expressions and operators

Learn more about the behavior of JavaScript's operators instanceof, typeof, new, this, the operator precedence, and more.

Statements and declarations

Learn how do-while, for-in, for-of, try-catch, let, var, const, if-else, switch, and more JavaScript statements and keywords work.

Functions

Learn how to work with JavaScript's functions to develop your applications.

Classes

JavaScript classes are the most appropriate way to do object-oriented programming.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nHTTPHypertext Transfer Protocol (HTTP) is an application-layer protocol for transmitting hypermedia documents, such as HTML.
It was designed for communication between web browsers and web servers, but it can also be used for other purposes, such as machine-to-machine communication, programmatic access to APIs, and more.
HTTP follows a classical client-server model, with a client opening a connection to make a request, then waiting until it receives a response from the server.
HTTP is a stateless protocol, meaning that the server does not keep any session data between two requests, although the later addition of cookies adds state to some client-server interactions.Reference documentationThe HTTP reference documentation contains detailed information about headers, request methods, status responses, and lists relevant specifications and standards documents.

HTTP headers

Message headers are used to send metadata about a resource or a HTTP message, and to describe the behavior of the client or the server.

HTTP request methods

Request methods indicate the purpose of the request and what is expected if the request is successful.
The most common methods are GET and POST for retrieving and sending data to servers, respectively, but there are other methods which serve different purposes.

HTTP response status codes

Response status codes indicate the outcome of a specific HTTP request.
Responses are grouped in five classes: informational, successful, redirections, client errors, and server errors.

HTTP resources and specifications

This page lists relevant resources about HTTP since it was first specified in the early 1990s.


The following subsections are also notable:

CSP directives

The Content-Security-Policy (CSP) response header allows website administrators to specify which resources the user agent is allowed to load for a given page.
This section lists directives that can be used in a CSP header, with individual documentation pages that describe how the directives work and how to use them.

Permissions-Policy directives

The Permissions-Policy response header provides a mechanism to allow or deny the use of browser features in a document or within any <iframe> element in the document.
This section lists directives that can be used in a Permissions-Policy header, with individual documentation pages that describe how the directives work and how to use them.

HTTP guidesHTTP is an extensible protocol that relies on concepts like resources and Uniform Resource Identifiers (URIs), a basic message structure, and client-server communication model.
On top of these concepts, numerous extensions have been developed over the years that add functionality and updated semantics, including additional HTTP methods and headers.
The guides below are listed in order from general overviews to specialized, use-case-driven topics.
Beginners are encouraged to start with the foundational guides before exploring more focused articles.

Overview of HTTP

The basic features of HTTP, what it can do, its intended use in web architecture, and its position in the protocol stack.

Evolution of HTTP

HTTP was created in the early 1990s and has been extended several times.
This article goes through its history and describes HTTP/0.9, HTTP/1.0, HTTP/1.1, through HTTP/2 and HTTP/3, as well as novelties introduced over the years.

A typical HTTP session

Describes the flow of an HTTP session, from establishing a connection, sending a request, to receiving a response.

HTTP messages

HTTP messages transmitted as requests and responses have a defined structure.
This article describes this general structure, its purpose, and the different types of messages.

MIME types

Since HTTP/1.0, different types of content can be transmitted.
This article explains how this is accomplished using the Content-Type header and the MIME standard.
A shortlist of common types used by web developers can be found in Common MIME types.

Compression in HTTP

Browsers and servers compress their messages before sending them over the network to reduce the amount of data that needs to be transmitted, improving transfer speed and bandwidth utilization.

HTTP caching

Caching is a highly important mechanism for delivering fast experiences on the Web and for efficient use of resources.
This article describes different methods of caching and how to use HTTP headers to control them.

HTTP authentication

Authentication is a way to verify the identity of a client when making requests to a server.
It ensures that only authorized users or systems can access certain resources.

Using HTTP cookies

Although HTTP is a stateless protocol, a server can send a Set-Cookie header with the response.
The client then returns the cookie's value with every subsequent request to the server in the form of a Cookie request header.
This adds the ability to store and exchange a small amount of data which effectively adds state to some client-server interactions.

Redirections in HTTP

URL redirection, also known as URL forwarding, is a technique to give more than one URL address to a page, a form, a whole website, or a web application.
HTTP has a special kind of response, called a HTTP redirect, for this operation.

HTTP conditional requests

In conditional requests, the outcome of a request depends on the value of a validator in the request.
This method is used heavily in caching and use cases such as resuming a download, preventing lost updates when modifying a document on the server, and more.

HTTP range requests

A range request asks the server to send a specific part (or parts) of a resource back to a client instead of the full resource.
Range requests are useful for cases when a client knows they need only part of a large file, or for cases where an application allows the user to pause and resume a download.

Content negotiation

HTTP defines a set of message headers, starting with Accept as a way for a browser to announce the format, language, or encoding it prefers.
This article explains how this advertisement happens, how the server is expected to react, and how it chooses the most adequate response to a request.

Connection management in HTTP/1.x

HTTP/1.1 was the first version of HTTP to support persistent connections and pipelining.
This article explains both concepts, including the pros and cons of each.

Protocol upgrade mechanism

HTTP/1.1 provides a mechanism to upgrade an already-established connection to a different protocol using the Upgrade header.
A client can upgrade a connection from HTTP/1.1 to HTTP/2, or an HTTP(S) connection to a WebSocket (ws / wss).

Proxy servers and tunneling

A proxy can be on the user's local computer, or anywhere between the user's computer and a destination server on the Internet.
This page outlines some basics about proxies and introduces a few configuration options.

HTTP Client hints

Client Hints are a set of response headers that a server can use to proactively request information from a client about the device, network, user, and user-agent-specific preferences.
The server can then determine which resources to send, based on the information that the client chooses to provide.

Network Error Logging 
Experimental


Network Error Logging is a mechanism that can be configured via the NEL HTTP response header.
This experimental header allows websites and applications to opt-in to receive reports about failed (or even successful) network fetches from supporting browsers.

Browser detection using the user agent

It's very rarely a good idea to use user agent sniffing to detect a browser, but there are edge cases that require it.
This document will guide you in doing this as correctly as possible when this is necessary, with an emphasis on considerations to make before embarking on this route.

Security and privacy
Permissions Policy

Permissions Policy provides mechanisms for web developers to explicitly declare what functionality can and cannot be used on a website.
You define a set of "policies" that restrict what APIs the site's code can access or modify the browser's default behavior for certain features.

Cross-Origin Resource Sharing (CORS)

Cross-site HTTP requests are requests for resources from a different domain than that of the resource making the request.
Web pages today very commonly load cross-site resources, for example, a page 'Domain A' (http://domaina.example/) requests an image on 'Domain B' (http://domainb.foo/image.jpg) via the img element.
CORS allows web developers to control how their site reacts to cross-site requests.

Content Security Policy (CSP)

CSP allows website administrators to use the Content-Security-Policy response header to control which resources the client is allowed to load for a given page.
The CSP guide describes the overall Content Security Policy mechanism which helps detect and mitigate certain types of attacks, including Cross-Site Scripting (XSS) and data injection attacks.

Cross-Origin Resource Policy (CORP)

CORP lets websites and applications opt in to protection against specific requests from other origins (such as those issued with elements like <script> and <img>), to mitigate speculative side-channel attacks.

Mozilla web security guidelines

A collection of tips to help operational teams with creating secure web applications.

Related resources
URIs

Uniform Resource Identifiers (URIs) are used to describe and locate resources on the web and are an essential component in HTTP requests.

Configuring servers for Ogg media

This guide covers a few server configuration changes that may be necessary for your web server to correctly serve Ogg media files.
This information may also be useful if you encounter other media types your server isn't already configured to recognize.

Tools & resourcesHelpful tools and resources for understanding and debugging HTTP.

Firefox Developer Tools

Network monitor

HTTP Observatory

A project designed to help developers, system administrators, and security professionals configure their sites safely and securely.

RedBot

Tools to check your cache-related headers.

nghttp2

An HTTP/2 client, server and proxy implementation written in C with load test and benchmarking tools and an HPACK encoder and decoder.

curl

A command-line tool for transferring data specified with URL syntax.
Supports HTTP, HTTPS, WS, WSS, among many other protocols.

How Browsers Work (2011)

A very comprehensive article on browser internals and request flow through HTTP protocol.\n\nHTTPHypertext Transfer Protocol (HTTP) is an application-layer protocol for transmitting hypermedia documents, such as HTML.
It was designed for communication between web browsers and web servers, but it can also be used for other purposes, such as machine-to-machine communication, programmatic access to APIs, and more.
HTTP follows a classical client-server model, with a client opening a connection to make a request, then waiting until it receives a response from the server.
HTTP is a stateless protocol, meaning that the server does not keep any session data between two requests, although the later addition of cookies adds state to some client-server interactions.Reference documentationThe HTTP reference documentation contains detailed information about headers, request methods, status responses, and lists relevant specifications and standards documents.

HTTP headers

Message headers are used to send metadata about a resource or a HTTP message, and to describe the behavior of the client or the server.

HTTP request methods

Request methods indicate the purpose of the request and what is expected if the request is successful.
The most common methods are GET and POST for retrieving and sending data to servers, respectively, but there are other methods which serve different purposes.

HTTP response status codes

Response status codes indicate the outcome of a specific HTTP request.
Responses are grouped in five classes: informational, successful, redirections, client errors, and server errors.

HTTP resources and specifications

This page lists relevant resources about HTTP since it was first specified in the early 1990s.


The following subsections are also notable:

CSP directives

The Content-Security-Policy (CSP) response header allows website administrators to specify which resources the user agent is allowed to load for a given page.
This section lists directives that can be used in a CSP header, with individual documentation pages that describe how the directives work and how to use them.

Permissions-Policy directives

The Permissions-Policy response header provides a mechanism to allow or deny the use of browser features in a document or within any <iframe> element in the document.
This section lists directives that can be used in a Permissions-Policy header, with individual documentation pages that describe how the directives work and how to use them.

HTTP guidesHTTP is an extensible protocol that relies on concepts like resources and Uniform Resource Identifiers (URIs), a basic message structure, and client-server communication model.
On top of these concepts, numerous extensions have been developed over the years that add functionality and updated semantics, including additional HTTP methods and headers.
The guides below are listed in order from general overviews to specialized, use-case-driven topics.
Beginners are encouraged to start with the foundational guides before exploring more focused articles.

Overview of HTTP

The basic features of HTTP, what it can do, its intended use in web architecture, and its position in the protocol stack.

Evolution of HTTP

HTTP was created in the early 1990s and has been extended several times.
This article goes through its history and describes HTTP/0.9, HTTP/1.0, HTTP/1.1, through HTTP/2 and HTTP/3, as well as novelties introduced over the years.

A typical HTTP session

Describes the flow of an HTTP session, from establishing a connection, sending a request, to receiving a response.

HTTP messages

HTTP messages transmitted as requests and responses have a defined structure.
This article describes this general structure, its purpose, and the different types of messages.

MIME types

Since HTTP/1.0, different types of content can be transmitted.
This article explains how this is accomplished using the Content-Type header and the MIME standard.
A shortlist of common types used by web developers can be found in Common MIME types.

Compression in HTTP

Browsers and servers compress their messages before sending them over the network to reduce the amount of data that needs to be transmitted, improving transfer speed and bandwidth utilization.

HTTP caching

Caching is a highly important mechanism for delivering fast experiences on the Web and for efficient use of resources.
This article describes different methods of caching and how to use HTTP headers to control them.

HTTP authentication

Authentication is a way to verify the identity of a client when making requests to a server.
It ensures that only authorized users or systems can access certain resources.

Using HTTP cookies

Although HTTP is a stateless protocol, a server can send a Set-Cookie header with the response.
The client then returns the cookie's value with every subsequent request to the server in the form of a Cookie request header.
This adds the ability to store and exchange a small amount of data which effectively adds state to some client-server interactions.

Redirections in HTTP

URL redirection, also known as URL forwarding, is a technique to give more than one URL address to a page, a form, a whole website, or a web application.
HTTP has a special kind of response, called a HTTP redirect, for this operation.

HTTP conditional requests

In conditional requests, the outcome of a request depends on the value of a validator in the request.
This method is used heavily in caching and use cases such as resuming a download, preventing lost updates when modifying a document on the server, and more.

HTTP range requests

A range request asks the server to send a specific part (or parts) of a resource back to a client instead of the full resource.
Range requests are useful for cases when a client knows they need only part of a large file, or for cases where an application allows the user to pause and resume a download.

Content negotiation

HTTP defines a set of message headers, starting with Accept as a way for a browser to announce the format, language, or encoding it prefers.
This article explains how this advertisement happens, how the server is expected to react, and how it chooses the most adequate response to a request.

Connection management in HTTP/1.x

HTTP/1.1 was the first version of HTTP to support persistent connections and pipelining.
This article explains both concepts, including the pros and cons of each.

Protocol upgrade mechanism

HTTP/1.1 provides a mechanism to upgrade an already-established connection to a different protocol using the Upgrade header.
A client can upgrade a connection from HTTP/1.1 to HTTP/2, or an HTTP(S) connection to a WebSocket (ws / wss).

Proxy servers and tunneling

A proxy can be on the user's local computer, or anywhere between the user's computer and a destination server on the Internet.
This page outlines some basics about proxies and introduces a few configuration options.

HTTP Client hints

Client Hints are a set of response headers that a server can use to proactively request information from a client about the device, network, user, and user-agent-specific preferences.
The server can then determine which resources to send, based on the information that the client chooses to provide.

Network Error Logging 
Experimental


Network Error Logging is a mechanism that can be configured via the NEL HTTP response header.
This experimental header allows websites and applications to opt-in to receive reports about failed (or even successful) network fetches from supporting browsers.

Browser detection using the user agent

It's very rarely a good idea to use user agent sniffing to detect a browser, but there are edge cases that require it.
This document will guide you in doing this as correctly as possible when this is necessary, with an emphasis on considerations to make before embarking on this route.

Security and privacy
Permissions Policy

Permissions Policy provides mechanisms for web developers to explicitly declare what functionality can and cannot be used on a website.
You define a set of "policies" that restrict what APIs the site's code can access or modify the browser's default behavior for certain features.

Cross-Origin Resource Sharing (CORS)

Cross-site HTTP requests are requests for resources from a different domain than that of the resource making the request.
Web pages today very commonly load cross-site resources, for example, a page 'Domain A' (http://domaina.example/) requests an image on 'Domain B' (http://domainb.foo/image.jpg) via the img element.
CORS allows web developers to control how their site reacts to cross-site requests.

Content Security Policy (CSP)

CSP allows website administrators to use the Content-Security-Policy response header to control which resources the client is allowed to load for a given page.
The CSP guide describes the overall Content Security Policy mechanism which helps detect and mitigate certain types of attacks, including Cross-Site Scripting (XSS) and data injection attacks.

Cross-Origin Resource Policy (CORP)

CORP lets websites and applications opt in to protection against specific requests from other origins (such as those issued with elements like <script> and <img>), to mitigate speculative side-channel attacks.

Mozilla web security guidelines

A collection of tips to help operational teams with creating secure web applications.

Related resources
URIs

Uniform Resource Identifiers (URIs) are used to describe and locate resources on the web and are an essential component in HTTP requests.

Configuring servers for Ogg media

This guide covers a few server configuration changes that may be necessary for your web server to correctly serve Ogg media files.
This information may also be useful if you encounter other media types your server isn't already configured to recognize.

Tools & resourcesHelpful tools and resources for understanding and debugging HTTP.

Firefox Developer Tools

Network monitor

HTTP Observatory

A project designed to help developers, system administrators, and security professionals configure their sites safely and securely.

RedBot

Tools to check your cache-related headers.

nghttp2

An HTTP/2 client, server and proxy implementation written in C with load test and benchmarking tools and an HPACK encoder and decoder.

curl

A command-line tool for transferring data specified with URL syntax.
Supports HTTP, HTTPS, WS, WSS, among many other protocols.

How Browsers Work (2011)

A very comprehensive article on browser internals and request flow through HTTP protocol.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 14, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nHTTPHypertext Transfer Protocol (HTTP) is an application-layer protocol for transmitting hypermedia documents, such as HTML.
It was designed for communication between web browsers and web servers, but it can also be used for other purposes, such as machine-to-machine communication, programmatic access to APIs, and more.
HTTP follows a classical client-server model, with a client opening a connection to make a request, then waiting until it receives a response from the server.
HTTP is a stateless protocol, meaning that the server does not keep any session data between two requests, although the later addition of cookies adds state to some client-server interactions.Reference documentationThe HTTP reference documentation contains detailed information about headers, request methods, status responses, and lists relevant specifications and standards documents.

HTTP headers

Message headers are used to send metadata about a resource or a HTTP message, and to describe the behavior of the client or the server.

HTTP request methods

Request methods indicate the purpose of the request and what is expected if the request is successful.
The most common methods are GET and POST for retrieving and sending data to servers, respectively, but there are other methods which serve different purposes.

HTTP response status codes

Response status codes indicate the outcome of a specific HTTP request.
Responses are grouped in five classes: informational, successful, redirections, client errors, and server errors.

HTTP resources and specifications

This page lists relevant resources about HTTP since it was first specified in the early 1990s.


The following subsections are also notable:

CSP directives

The Content-Security-Policy (CSP) response header allows website administrators to specify which resources the user agent is allowed to load for a given page.
This section lists directives that can be used in a CSP header, with individual documentation pages that describe how the directives work and how to use them.

Permissions-Policy directives

The Permissions-Policy response header provides a mechanism to allow or deny the use of browser features in a document or within any <iframe> element in the document.
This section lists directives that can be used in a Permissions-Policy header, with individual documentation pages that describe how the directives work and how to use them.

HTTP guidesHTTP is an extensible protocol that relies on concepts like resources and Uniform Resource Identifiers (URIs), a basic message structure, and client-server communication model.
On top of these concepts, numerous extensions have been developed over the years that add functionality and updated semantics, including additional HTTP methods and headers.
The guides below are listed in order from general overviews to specialized, use-case-driven topics.
Beginners are encouraged to start with the foundational guides before exploring more focused articles.

Overview of HTTP

The basic features of HTTP, what it can do, its intended use in web architecture, and its position in the protocol stack.

Evolution of HTTP

HTTP was created in the early 1990s and has been extended several times.
This article goes through its history and describes HTTP/0.9, HTTP/1.0, HTTP/1.1, through HTTP/2 and HTTP/3, as well as novelties introduced over the years.

A typical HTTP session

Describes the flow of an HTTP session, from establishing a connection, sending a request, to receiving a response.

HTTP messages

HTTP messages transmitted as requests and responses have a defined structure.
This article describes this general structure, its purpose, and the different types of messages.

MIME types

Since HTTP/1.0, different types of content can be transmitted.
This article explains how this is accomplished using the Content-Type header and the MIME standard.
A shortlist of common types used by web developers can be found in Common MIME types.

Compression in HTTP

Browsers and servers compress their messages before sending them over the network to reduce the amount of data that needs to be transmitted, improving transfer speed and bandwidth utilization.

HTTP caching

Caching is a highly important mechanism for delivering fast experiences on the Web and for efficient use of resources.
This article describes different methods of caching and how to use HTTP headers to control them.

HTTP authentication

Authentication is a way to verify the identity of a client when making requests to a server.
It ensures that only authorized users or systems can access certain resources.

Using HTTP cookies

Although HTTP is a stateless protocol, a server can send a Set-Cookie header with the response.
The client then returns the cookie's value with every subsequent request to the server in the form of a Cookie request header.
This adds the ability to store and exchange a small amount of data which effectively adds state to some client-server interactions.

Redirections in HTTP

URL redirection, also known as URL forwarding, is a technique to give more than one URL address to a page, a form, a whole website, or a web application.
HTTP has a special kind of response, called a HTTP redirect, for this operation.

HTTP conditional requests

In conditional requests, the outcome of a request depends on the value of a validator in the request.
This method is used heavily in caching and use cases such as resuming a download, preventing lost updates when modifying a document on the server, and more.

HTTP range requests

A range request asks the server to send a specific part (or parts) of a resource back to a client instead of the full resource.
Range requests are useful for cases when a client knows they need only part of a large file, or for cases where an application allows the user to pause and resume a download.

Content negotiation

HTTP defines a set of message headers, starting with Accept as a way for a browser to announce the format, language, or encoding it prefers.
This article explains how this advertisement happens, how the server is expected to react, and how it chooses the most adequate response to a request.

Connection management in HTTP/1.x

HTTP/1.1 was the first version of HTTP to support persistent connections and pipelining.
This article explains both concepts, including the pros and cons of each.

Protocol upgrade mechanism

HTTP/1.1 provides a mechanism to upgrade an already-established connection to a different protocol using the Upgrade header.
A client can upgrade a connection from HTTP/1.1 to HTTP/2, or an HTTP(S) connection to a WebSocket (ws / wss).

Proxy servers and tunneling

A proxy can be on the user's local computer, or anywhere between the user's computer and a destination server on the Internet.
This page outlines some basics about proxies and introduces a few configuration options.

HTTP Client hints

Client Hints are a set of response headers that a server can use to proactively request information from a client about the device, network, user, and user-agent-specific preferences.
The server can then determine which resources to send, based on the information that the client chooses to provide.

Network Error Logging 
Experimental


Network Error Logging is a mechanism that can be configured via the NEL HTTP response header.
This experimental header allows websites and applications to opt-in to receive reports about failed (or even successful) network fetches from supporting browsers.

Browser detection using the user agent

It's very rarely a good idea to use user agent sniffing to detect a browser, but there are edge cases that require it.
This document will guide you in doing this as correctly as possible when this is necessary, with an emphasis on considerations to make before embarking on this route.

Security and privacy
Permissions Policy

Permissions Policy provides mechanisms for web developers to explicitly declare what functionality can and cannot be used on a website.
You define a set of "policies" that restrict what APIs the site's code can access or modify the browser's default behavior for certain features.

Cross-Origin Resource Sharing (CORS)

Cross-site HTTP requests are requests for resources from a different domain than that of the resource making the request.
Web pages today very commonly load cross-site resources, for example, a page 'Domain A' (http://domaina.example/) requests an image on 'Domain B' (http://domainb.foo/image.jpg) via the img element.
CORS allows web developers to control how their site reacts to cross-site requests.

Content Security Policy (CSP)

CSP allows website administrators to use the Content-Security-Policy response header to control which resources the client is allowed to load for a given page.
The CSP guide describes the overall Content Security Policy mechanism which helps detect and mitigate certain types of attacks, including Cross-Site Scripting (XSS) and data injection attacks.

Cross-Origin Resource Policy (CORP)

CORP lets websites and applications opt in to protection against specific requests from other origins (such as those issued with elements like <script> and <img>), to mitigate speculative side-channel attacks.

Mozilla web security guidelines

A collection of tips to help operational teams with creating secure web applications.

Related resources
URIs

Uniform Resource Identifiers (URIs) are used to describe and locate resources on the web and are an essential component in HTTP requests.

Configuring servers for Ogg media

This guide covers a few server configuration changes that may be necessary for your web server to correctly serve Ogg media files.
This information may also be useful if you encounter other media types your server isn't already configured to recognize.

Tools & resourcesHelpful tools and resources for understanding and debugging HTTP.

Firefox Developer Tools

Network monitor

HTTP Observatory

A project designed to help developers, system administrators, and security professionals configure their sites safely and securely.

RedBot

Tools to check your cache-related headers.

nghttp2

An HTTP/2 client, server and proxy implementation written in C with load test and benchmarking tools and an HPACK encoder and decoder.

curl

A command-line tool for transferring data specified with URL syntax.
Supports HTTP, HTTPS, WS, WSS, among many other protocols.

How Browsers Work (2011)

A very comprehensive article on browser internals and request flow through HTTP protocol.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 14, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nWeb APIsWhen writing code for the Web, there are a large number of Web APIs available. Below is a list of all the APIs and interfaces (object types) that you may be able to use while developing your Web app or site.
Web APIs are typically used with JavaScript, although this doesn't always have to be the case.SpecificationsThis is a list of all the APIs that are available.
AAttribution Reporting API
Experimental
Audio Output Devices API
Experimental
BBackground Fetch API
Experimental
Background Synchronization APIBackground Tasks APIBadging APIBarcode Detection API
Experimental
Battery Status APIBeacon APIWeb Bluetooth API
Experimental
Broadcast Channel APICCSS Custom Highlight APICSS Font Loading APICSS Painting API
Experimental
CSS Properties and Values APICSS Typed Object Model APICSS Object Model (CSSOM)Canvas APIChannel Messaging APIClipboard APICompression Streams APICompute Pressure API
Experimental
Console APIContact Picker API
Experimental
Content Index API
Experimental
Cookie Store APICredential Management APIDDocument Object Model (DOM)Device Memory APIDevice orientation eventsDevice Posture API
Experimental
Document Picture-in-Picture API
Experimental
EEditContext API
Experimental
Encoding APIEncrypted Media Extensions APIEyeDropper API
Experimental
FFederated Credential Management (FedCM) API
Experimental
Fenced Frame API
Experimental
Fetch APIFile APIFile System APIFile and Directory Entries APIForce Touch events
Non-standard
Fullscreen APIGGamepad APIGeolocation APIGeometry interfacesHThe HTML DOM APIHTML Drag and Drop APIHistory APIHoudini APIsIIdle Detection API
Experimental
MediaStream Image Capture APIIndexedDB APIInk API
Experimental
InputDeviceCapabilities API
Experimental
Insertable Streams for MediaStreamTrack APIIntersection Observer APIInvoker Commands APIJJS Self-Profiling API
Experimental
KKeyboard API
Experimental
LLaunch Handler API
Experimental
Local Font Access API
Experimental
MMedia Capabilities APIMedia Capture and Streams API (Media Stream)Media Session APIMedia Source API
Experimental
MediaStream Recording APINNavigation API
Experimental
Network Information APIPPage Visibility APIPayment Handler API
Experimental
Payment Request APIPerformance APIsWeb Periodic Background Synchronization API
Experimental
Permissions APIPicture-in-Picture APIPointer eventsPointer Lock APIPopover APIPresentation API
Experimental
Prioritized Task Scheduling APIPush APIRRemote Playback APIReporting APIResize Observer APISSVG APIScreen Capture APIScreen Orientation APIScreen Wake Lock APISelection APISensor APIsServer-sent eventsService Worker APIShared Storage API
Experimental
Speculation Rules API
Experimental
Storage APIStorage Access APIStreams APITTopics API
Experimental

Non-standard
Touch eventsTrusted Types APIUUI EventsURL APIURL Fragment Text DirectivesURL Pattern API
Experimental
User-Agent Client Hints API
Experimental
VVibration APIView Transition APIVirtualKeyboard API
Experimental
Visual Viewport APIWWeb Animations APIWeb Audio APIWeb Authentication APIWeb ComponentsWeb Crypto APIWeb Locks APIWeb MIDI APIWeb NFC API
Experimental
Notifications APIWeb Serial API
Experimental
Web Share APIWeb Speech APIWeb Storage APIWeb Workers APIWebCodecs APIWebGL: 2D and 3D graphics for the webWebGPU API
Experimental
WebHID API
Experimental
WebOTP APIWebRTC APIThe WebSocket API (WebSockets)WebTransport APIWebUSB API
Experimental
WebVR API
Non-standard

Deprecated
WebVTT APIWebXR Device API
Experimental
Window Controls Overlay API
Experimental
Window Management API
Experimental
XXMLHttpRequest APIffetchLater() API
Experimental
InterfacesThis is a list of all the interfaces (that is, types of objects) that are available.
AAbortControllerAbortSignalAbsoluteOrientationSensorAbstractRangeAccelerometer
Experimental
AesCbcParamsAesCtrParamsAesGcmParamsAesKeyGenParamsAmbientLightSensor
Experimental
AnalyserNodeANGLE_instanced_arraysAnimationAnimationEffectAnimationEventAnimationPlaybackEventAnimationTimelineAttrAudioBufferAudioBufferSourceNodeAudioContextAudioDataAudioDecoderAudioDestinationNodeAudioEncoderAudioListenerAudioNodeAudioParamAudioParamDescriptorAudioParamMapAudioProcessingEvent
Deprecated
AudioScheduledSourceNodeAudioSinkInfo
Experimental
AudioTrackAudioTrackListAudioWorkletAudioWorkletGlobalScopeAudioWorkletNodeAudioWorkletProcessorAuthenticatorAssertionResponseAuthenticatorAttestationResponseAuthenticatorResponseBBackgroundFetchEvent
Experimental
BackgroundFetchManager
Experimental
BackgroundFetchRecord
Experimental
BackgroundFetchRegistration
Experimental
BackgroundFetchUpdateUIEvent
Experimental
BarcodeDetector
Experimental
BarPropBaseAudioContextBatteryManagerBeforeInstallPromptEvent
Experimental

Non-standard
BeforeUnloadEventBiquadFilterNodeBlobBlobEventBluetooth
Experimental
BluetoothCharacteristicProperties
Experimental
BluetoothDevice
Experimental
BluetoothRemoteGATTCharacteristic
Experimental
BluetoothRemoteGATTDescriptor
Experimental
BluetoothRemoteGATTServer
Experimental
BluetoothRemoteGATTService
Experimental
BluetoothUUIDBroadcastChannelBrowserCaptureMediaStreamTrack
Experimental
ByteLengthQueuingStrategyCCacheCacheStorageCanMakePaymentEvent
Experimental
CanvasCaptureMediaStreamTrackCanvasGradientCanvasPatternCanvasRenderingContext2DCaptureController
Experimental
CaretPositionCDATASectionChannelMergerNodeChannelSplitterNodeChapterInformation
Experimental
CharacterBoundsUpdateEvent
Experimental
CharacterDataClientClientsClipboardClipboardEventClipboardItemCloseEventCloseWatcher
Experimental
CommandEventCommentCompositionEventCompressionStreamcconsoleCConstantSourceNodeContactAddress
Experimental
ContactsManager
Experimental
ContentIndex
Experimental
ContentIndexEvent
Experimental
ContentVisibilityAutoStateChangeEventConvolverNodeCookieChangeEventCookieStoreCookieStoreManagerCountQueuingStrategyCredentialCredentialsContainerCropTarget
Experimental
CryptoCryptoKeyCryptoKeyPairCSPViolationReportBodyCSSCSSAnimationCSSConditionRuleCSSContainerRuleCSSCounterStyleRuleCSSFontFaceRuleCSSFontFeatureValuesRuleCSSFontPaletteValuesRuleCSSGroupingRuleCSSImageValueCSSImportRuleCSSKeyframeRuleCSSKeyframesRuleCSSKeywordValueCSSLayerBlockRuleCSSLayerStatementRuleCSSMathInvertCSSMathMaxCSSMathMinCSSMathNegateCSSMathProductCSSMathSumCSSMathValueCSSMatrixComponentCSSMediaRuleCSSNamespaceRuleCSSNestedDeclarationsCSSNumericArrayCSSNumericValueCSSPageDescriptors
Experimental
CSSPageRuleCSSPerspectiveCSSPositionTryDescriptors
Experimental
CSSPositionTryRule
Experimental
CSSPositionValue
Non-standard

Deprecated
CSSPrimitiveValue
Deprecated
CSSPropertyRuleCSSPseudoElement
Experimental
CSSRotateCSSRuleCSSRuleListCSSScaleCSSScopeRuleCSSSkewCSSSkewXCSSSkewYCSSStartingStyleRuleCSSStyleDeclarationCSSStyleRuleCSSStyleSheetCSSStyleValueCSSSupportsRuleCSSTransformComponentCSSTransformValueCSSTransitionCSSTranslateCSSUnitValueCSSUnparsedValueCSSValue
Deprecated
CSSValueList
Deprecated
CSSVariableReferenceValueCustomElementRegistryCustomEventCustomStateSetDDataTransferDataTransferItemDataTransferItemListDecompressionStreamDedicatedWorkerGlobalScopeDeferredRequestInit
Experimental
DelayNodeDelegatedInkTrailPresenter
Experimental
DeprecationReportBody
Experimental
DeviceMotionEventDeviceMotionEventAccelerationDeviceMotionEventRotationRateDeviceOrientationEventDevicePosture
Experimental
DirectoryEntrySync
Non-standard

Deprecated
DirectoryReaderSync
Non-standard

Deprecated
DocumentDocumentFragmentDocumentPictureInPicture
Experimental
DocumentPictureInPictureEvent
Experimental
DocumentTimelineDocumentTypeDOMError
Deprecated
DOMExceptionDOMHighResTimeStampDOMImplementationDOMMatrixDOMMatrixReadOnlyDOMParserDOMPointDOMPointReadOnlyDOMQuadDOMRectDOMRectListDOMRectReadOnlyDOMStringListDOMStringMapDOMTokenListDragEventDynamicsCompressorNodeEEcdhKeyDeriveParamsEcdsaParamsEcKeyGenParamsEcKeyImportParamsEditContext
Experimental
ElementElementInternalsEncodedAudioChunkEncodedVideoChunkErrorEventEventEventCountsEventSourceEventTargetExtendableCookieChangeEventExtendableEventExtendableMessageEventEyeDropper
Experimental
FFeaturePolicy
Experimental
FederatedCredential
Experimental
FederatedCredentialInitFence
Experimental
FencedFrameConfig
Experimental
FetchEventFetchLaterResult
Experimental
FileFileEntrySync
Non-standard

Deprecated
FileListFileReaderFileReaderSyncFileSystemFileSystemChangeRecordFileSystemDirectoryEntryFileSystemDirectoryHandleFileSystemDirectoryReaderFileSystemEntryFileSystemFileEntryFileSystemFileHandleFileSystemHandleFileSystemObserver
Experimental

Non-standard
FileSystemSync
Non-standard

Deprecated
FileSystemSyncAccessHandleFileSystemWritableFileStreamFocusEventFontData
Experimental
FontFaceFontFaceSetFontFaceSetLoadEventFormDataFormDataEventFragmentDirectiveGGainNodeGamepadGamepadButtonGamepadEventGamepadHapticActuatorGamepadPose
Experimental
GeolocationGeolocationCoordinatesGeolocationPositionGeolocationPositionErrorGestureEvent
Non-standard
GPU
Experimental
GPUAdapter
Experimental
GPUAdapterInfo
Experimental
GPUBindGroup
Experimental
GPUBindGroupLayout
Experimental
GPUBuffer
Experimental
GPUCanvasContext
Experimental
GPUCommandBuffer
Experimental
GPUCommandEncoder
Experimental
GPUCompilationInfo
Experimental
GPUCompilationMessage
Experimental
GPUComputePassEncoder
Experimental
GPUComputePipeline
Experimental
GPUDevice
Experimental
GPUDeviceLostInfo
Experimental
GPUError
Experimental
GPUExternalTexture
Experimental
GPUInternalError
Experimental
GPUOutOfMemoryError
Experimental
GPUPipelineError
Experimental
GPUPipelineLayout
Experimental
GPUQuerySet
Experimental
GPUQueue
Experimental
GPURenderBundle
Experimental
GPURenderBundleEncoder
Experimental
GPURenderPassEncoder
Experimental
GPURenderPipeline
Experimental
GPUSampler
Experimental
GPUShaderModule
Experimental
GPUSupportedFeatures
Experimental
GPUSupportedLimits
Experimental
GPUTexture
Experimental
GPUTextureView
Experimental
GPUUncapturedErrorEvent
Experimental
GPUValidationError
Experimental
GravitySensorGyroscopeHHashChangeEventHeadersHID
Experimental
HIDConnectionEvent
Experimental
HIDDevice
Experimental
HIDInputReportEvent
Experimental
HighlightHighlightRegistryHistoryHkdfParamsHmacImportParamsHmacKeyGenParamsHMDVRDevice
Non-standard

Deprecated
HTMLAllCollectionHTMLAnchorElementHTMLAreaElementHTMLAudioElementHTMLBaseElementHTMLBodyElementHTMLBRElementHTMLButtonElementHTMLCanvasElementHTMLCollectionHTMLDataElementHTMLDataListElementHTMLDetailsElementHTMLDialogElementHTMLDivElementHTMLDListElementHTMLDocumentHTMLElementHTMLEmbedElementHTMLFencedFrameElement
Experimental
HTMLFieldSetElementHTMLFontElement
Deprecated
HTMLFormControlsCollectionHTMLFormElementHTMLFrameSetElement
Deprecated
HTMLHeadElementHTMLHeadingElementHTMLHRElementHTMLHtmlElementHTMLIFrameElementHTMLImageElementHTMLInputElementHTMLLabelElementHTMLLegendElementHTMLLIElementHTMLLinkElementHTMLMapElementHTMLMarqueeElement
Deprecated
HTMLMediaElementHTMLMenuElementHTMLMetaElementHTMLMeterElementHTMLModElementHTMLObjectElementHTMLOListElementHTMLOptGroupElementHTMLOptionElementHTMLOptionsCollectionHTMLOutputElementHTMLParagraphElementHTMLParamElement
Deprecated
HTMLPictureElementHTMLPreElementHTMLProgressElementHTMLQuoteElementHTMLScriptElementHTMLSelectedContentElementHTMLSelectElementHTMLSlotElementHTMLSourceElementHTMLSpanElementHTMLStyleElementHTMLTableCaptionElementHTMLTableCellElementHTMLTableColElementHTMLTableElementHTMLTableRowElementHTMLTableSectionElementHTMLTemplateElementHTMLTextAreaElementHTMLTimeElementHTMLTitleElementHTMLTrackElementHTMLUListElementHTMLUnknownElementHTMLVideoElementIIDBCursorIDBCursorWithValueIDBDatabaseIDBFactoryIDBIndexIDBKeyRangeIDBObjectStoreIDBOpenDBRequestIDBRequestIDBTransactionIDBVersionChangeEventIdentityCredential
Experimental
IdentityCredentialRequestOptionsIdentityProvider
Experimental
IdleDeadlineIdleDetector
Experimental
IIRFilterNodeImageBitmapImageBitmapRenderingContextImageCaptureImageDataImageDecoderImageTrackImageTrackListInk
Experimental
InputDeviceCapabilities
Experimental
InputDeviceInfoInputEventInstallEventIntersectionObserverIntersectionObserverEntryInterventionReportBody
Experimental
KKeyboard
Experimental
KeyboardEventKeyboardLayoutMap
Experimental
KeyframeEffectLLargestContentfulPaintLaunchParams
Experimental
LaunchQueue
Experimental
LayoutShift
Experimental
LayoutShiftAttribution
Experimental
LinearAccelerationSensorLocationLockLockManagerMMagnetometer
Experimental
MathMLElementMediaCapabilitiesMediaDeviceInfoMediaDevicesMediaElementAudioSourceNodeMediaEncryptedEventMediaErrorMediaKeyMessageEventMediaKeysMediaKeySessionMediaKeyStatusMapMediaKeySystemAccessMediaListMediaMetadataMediaQueryListMediaQueryListEventMediaRecorderMediaRecorderErrorEvent
Non-standard

Deprecated
MediaSessionMediaSourceMediaSourceHandleMediaStreamMediaStreamAudioDestinationNodeMediaStreamAudioSourceNodeMediaStreamEvent
Non-standard

Deprecated
MediaStreamTrackMediaStreamTrackAudioSourceNodeMediaStreamTrackEventMediaStreamTrackGenerator
Experimental

Non-standard
MediaStreamTrackProcessorMediaTrackConstraintsMediaTrackSettingsMediaTrackSupportedConstraintsMerchantValidationEvent
Deprecated
MessageChannelMessageEventMessagePortMetadata
Experimental

Non-standard
MIDIAccessMIDIConnectionEventMIDIInputMIDIInputMapMIDIMessageEventMIDIOutputMIDIOutputMapMIDIPortMimeType
Deprecated
MimeTypeArray
Deprecated
MouseEventMouseScrollEvent
Non-standard

Deprecated
MutationEvent
Non-standard

Deprecated
MutationObserverMutationRecordNNamedNodeMapNavigateEvent
Experimental
Navigation
Experimental
NavigationActivation
Experimental
NavigationCurrentEntryChangeEvent
Experimental
NavigationDestination
Experimental
NavigationHistoryEntry
Experimental
NavigationPreloadManagerNavigationTransition
Experimental
NavigatorNavigatorLoginNavigatorUAData
Experimental
NDEFMessage
Experimental
NDEFReader
Experimental
NDEFReadingEvent
Experimental
NDEFRecord
Experimental
NetworkInformationNodeNodeIteratorNodeListNotificationNotificationEventNotRestoredReasonDetails
Experimental
NotRestoredReasons
Experimental
OOES_draw_buffers_indexedOfflineAudioCompletionEventOfflineAudioContextOffscreenCanvasOffscreenCanvasRenderingContext2DOrientationSensorOscillatorNodeOTPCredential
Experimental
OverconstrainedErrorPPageRevealEventPageSwapEventPageTransitionEventPaintRenderingContext2DPaintSizePaintWorkletGlobalScope
Experimental
PannerNodePasswordCredential
Experimental
PasswordCredentialInitPath2DPaymentAddress
Non-standard

Deprecated
PaymentManager
Experimental
PaymentMethodChangeEventPaymentRequestPaymentRequestEvent
Experimental
PaymentRequestUpdateEventPaymentResponsePbkdf2ParamsPerformancePerformanceElementTiming
Experimental
PerformanceEntryPerformanceEventTimingPerformanceLongAnimationFrameTiming
Experimental
PerformanceLongTaskTiming
Experimental
PerformanceMarkPerformanceMeasurePerformanceNavigation
Deprecated
PerformanceNavigationTimingPerformanceObserverPerformanceObserverEntryListPerformancePaintTimingPerformanceResourceTimingPerformanceScriptTiming
Experimental
PerformanceServerTimingPerformanceTiming
Deprecated
PeriodicSyncEvent
Experimental
PeriodicSyncManager
Experimental
PeriodicWavePermissionsPermissionStatusPictureInPictureEventPictureInPictureWindowPlugin
Deprecated
PluginArray
Deprecated
Point
Non-standard

Deprecated
PointerEventPopStateEventPositionSensorVRDevice
Non-standard

Deprecated
Presentation
Experimental
PresentationAvailability
Experimental
PresentationConnection
Experimental
PresentationConnectionAvailableEvent
Experimental
PresentationConnectionCloseEvent
Experimental
PresentationConnectionList
Experimental
PresentationReceiver
Experimental
PresentationRequest
Experimental
PressureObserver
Experimental
PressureRecord
Experimental
ProcessingInstructionProfiler
Experimental
ProgressEventPromiseRejectionEventPublicKeyCredentialPublicKeyCredentialCreationOptionsPublicKeyCredentialRequestOptionsPushEventPushManagerPushMessageDataPushSubscriptionPushSubscriptionOptionsRRadioNodeListRangeReadableByteStreamControllerReadableStreamReadableStreamBYOBReaderReadableStreamBYOBRequestReadableStreamDefaultControllerReadableStreamDefaultReaderRelativeOrientationSensorRemotePlaybackReportReportBodyReportingObserverRequestRequestInitResizeObserverResizeObserverEntryResizeObserverSizeResponseRestrictionTarget
Experimental
RsaHashedImportParamsRsaHashedKeyGenParamsRsaOaepParamsRsaPssParamsRTCAudioSourceStatsRTCCertificateRTCCertificateStatsRTCCodecStatsRTCDataChannelRTCDataChannelEventRTCDataChannelStatsRTCDtlsTransportRTCDTMFSenderRTCDTMFToneChangeEventRTCEncodedAudioFrameRTCEncodedVideoFrameRTCErrorRTCErrorEventRTCIceCandidateRTCIceCandidatePairRTCIceCandidatePairStatsRTCIceCandidateStatsRTCIceParametersRTCIceTransportRTCIdentityAssertion
Experimental
RTCInboundRtpStreamStatsRTCOutboundRtpStreamStatsRTCPeerConnectionRTCPeerConnectionIceErrorEventRTCPeerConnectionIceEventRTCPeerConnectionStatsRTCRemoteInboundRtpStreamStatsRTCRemoteOutboundRtpStreamStatsRTCRtpReceiverRTCRtpScriptTransformRTCRtpScriptTransformerRTCRtpSenderRTCRtpTransceiverRTCSctpTransportRTCSessionDescriptionRTCStatsReportRTCTrackEventRTCTransformEventRTCTransportStatsRTCVideoSourceStatsSSchedulerScheduling
Experimental
ScreenScreenDetailed
Experimental
ScreenDetails
Experimental
ScreenOrientationScriptProcessorNode
Deprecated
ScrollTimeline
Experimental
SecurePaymentConfirmationRequestSecurityPolicyViolationEventSelectionSensorSensorErrorEventSerial
Experimental
SerialPort
Experimental
ServiceWorkerServiceWorkerContainerServiceWorkerGlobalScopeServiceWorkerRegistrationShadowRootSharedStorage
Experimental
SharedStorageOperation
Experimental
SharedStorageRunOperation
Experimental
SharedStorageSelectURLOperation
Experimental
SharedStorageWorklet
Experimental
SharedStorageWorkletGlobalScope
Experimental
SharedWorkerSharedWorkerGlobalScopeSnapEvent
Experimental
SourceBufferSourceBufferListSpeechGrammar
Non-standard

Deprecated
SpeechGrammarList
Experimental
SpeechRecognitionSpeechRecognitionAlternativeSpeechRecognitionErrorEventSpeechRecognitionEventSpeechRecognitionResultSpeechRecognitionResultListSpeechSynthesisSpeechSynthesisErrorEventSpeechSynthesisEventSpeechSynthesisUtteranceSpeechSynthesisVoiceStaticRangeStereoPannerNodeStorageStorageAccessHandleStorageEventStorageManagerStylePropertyMapStylePropertyMapReadOnlyStyleSheetStyleSheetListSubmitEventSubtleCryptoSVGAElementSVGAngleSVGAnimateColorElement
Deprecated
SVGAnimatedAngleSVGAnimatedBooleanSVGAnimatedEnumerationSVGAnimatedIntegerSVGAnimatedLengthSVGAnimatedLengthListSVGAnimatedNumberSVGAnimatedNumberListSVGAnimatedPreserveAspectRatioSVGAnimatedRectSVGAnimatedStringSVGAnimatedTransformListSVGAnimateElementSVGAnimateMotionElementSVGAnimateTransformElementSVGAnimationElementSVGCircleElementSVGClipPathElementSVGComponentTransferFunctionElementSVGDefsElementSVGDescElementSVGDiscardElement
Experimental
SVGElementSVGEllipseElementSVGFEBlendElementSVGFEColorMatrixElementSVGFEComponentTransferElementSVGFECompositeElementSVGFEConvolveMatrixElementSVGFEDiffuseLightingElementSVGFEDisplacementMapElementSVGFEDistantLightElementSVGFEDropShadowElementSVGFEFloodElementSVGFEFuncAElementSVGFEFuncBElementSVGFEFuncGElementSVGFEFuncRElementSVGFEGaussianBlurElementSVGFEImageElementSVGFEMergeElementSVGFEMergeNodeElementSVGFEMorphologyElementSVGFEOffsetElementSVGFEPointLightElementSVGFESpecularLightingElementSVGFESpotLightElementSVGFETileElementSVGFETurbulenceElementSVGFilterElementSVGForeignObjectElementSVGGElementSVGGeometryElementSVGGradientElementSVGGraphicsElementSVGImageElementSVGLengthSVGLengthListSVGLinearGradientElementSVGLineElementSVGMarkerElementSVGMaskElementSVGMetadataElementSVGMPathElementSVGNumberSVGNumberListSVGPathElementSVGPatternElementSVGPoint
Deprecated
SVGPointListSVGPolygonElementSVGPolylineElementSVGPreserveAspectRatioSVGRadialGradientElementSVGRectSVGRectElementSVGRenderingIntent
Deprecated
SVGScriptElementSVGSetElementSVGStopElementSVGStringListSVGStyleElementSVGSVGElementSVGSwitchElementSVGSymbolElementSVGTextContentElementSVGTextElementSVGTextPathElementSVGTextPositioningElementSVGTitleElementSVGTransformSVGTransformListSVGTSpanElementSVGUnitTypesSVGUseElementSVGViewElementSyncEventSyncManagerTTaskAttributionTiming
Experimental
TaskControllerTaskPriorityChangeEventTaskSignalTextTextDecoderTextDecoderStreamTextEncoderTextEncoderStreamTextEvent
Deprecated
TextFormat
Experimental
TextFormatUpdateEvent
Experimental
TextMetricsTextTrackTextTrackCueTextTrackCueListTextTrackListTextUpdateEvent
Experimental
TimeEventTimeRangesToggleEventTouchTouchEventTouchListTrackEventTransformStreamTransformStreamDefaultControllerTransitionEventTreeWalkerTrustedHTMLTrustedScriptTrustedScriptURLTrustedTypePolicyTrustedTypePolicyFactoryUUIEventURLURLPattern
Experimental
URLSearchParamsUSB
Experimental
USBAlternateInterface
Experimental
USBConfiguration
Experimental
USBConnectionEvent
Experimental
USBDevice
Experimental
USBEndpoint
Experimental
USBInterface
Experimental
USBInTransferResult
Experimental
USBIsochronousInTransferPacket
Experimental
USBIsochronousInTransferResult
Experimental
USBIsochronousOutTransferPacket
Experimental
USBIsochronousOutTransferResult
Experimental
USBOutTransferResult
Experimental
UserActivationVValidityStateVideoColorSpaceVideoDecoderVideoEncoderVideoFrameVideoPlaybackQualityVideoTrackVideoTrackListViewTimeline
Experimental
ViewTransitionVirtualKeyboard
Experimental
VisibilityStateEntry
Experimental
VisualViewportVRDisplay
Non-standard

Deprecated
VRDisplayCapabilities
Non-standard

Deprecated
VRDisplayEvent
Non-standard

Deprecated
VREyeParameters
Non-standard

Deprecated
VRFieldOfView
Non-standard

Deprecated
VRFrameData
Non-standard

Deprecated
VRLayerInit
Deprecated
VRPose
Non-standard

Deprecated
VRStageParameters
Non-standard

Deprecated
VTTCueVTTRegionWWakeLockWakeLockSentinelWaveShaperNodeWebGL2RenderingContextWebGLActiveInfoWebGLBufferWebGLContextEventWebGLFramebufferWebGLObject
Experimental
WebGLProgramWebGLQueryWebGLRenderbufferWebGLRenderingContextWebGLSamplerWebGLShaderWebGLShaderPrecisionFormatWebGLSyncWebGLTextureWebGLTransformFeedbackWebGLUniformLocationWebGLVertexArrayObjectWebSocketWebSocketStream
Experimental
WebTransportWebTransportBidirectionalStreamWebTransportDatagramDuplexStreamWebTransportErrorWebTransportReceiveStream
Experimental
WebTransportSendStream
Experimental
WGSLLanguageFeatures
Experimental
WheelEventWindowWindowClientWindowControlsOverlay
Experimental
WindowControlsOverlayGeometryChangeEvent
Experimental
WindowSharedStorage
Experimental
WorkerWorkerGlobalScopeWorkerLocationWorkerNavigatorWorkletWorkletGlobalScopeWorkletSharedStorage
Experimental
WritableStreamWritableStreamDefaultControllerWritableStreamDefaultWriterXXMLDocumentXMLHttpRequestXMLHttpRequestEventTargetXMLHttpRequestUploadXMLSerializerXPathEvaluatorXPathExpressionXPathResultXRAnchor
Experimental
XRAnchorSet
Experimental
XRBoundedReferenceSpace
Experimental
XRCompositionLayer
Experimental
XRCPUDepthInformation
Experimental
XRCubeLayer
Experimental
XRCylinderLayer
Experimental
XRDepthInformation
Experimental
XREquirectLayer
Experimental
XRFrame
Experimental
XRHandXRHitTestResult
Experimental
XRHitTestSource
Experimental
XRInputSourceXRInputSourceArray
Experimental
XRInputSourceEventXRInputSourcesChangeEventXRJointPoseXRJointSpaceXRLayer
Experimental
XRLayerEvent
Experimental
XRLightEstimate
Experimental
XRLightProbe
Experimental
XRMediaBinding
Experimental
XRPoseXRProjectionLayer
Experimental
XRQuadLayer
Experimental
XRRay
Experimental
XRReferenceSpaceXRReferenceSpaceEventXRRenderState
Experimental
XRRigidTransformXRSession
Experimental
XRSessionEventXRSpaceXRSubImage
Experimental
XRSystem
Experimental
XRTransientInputHitTestResult
Experimental
XRTransientInputHitTestSource
Experimental
XRView
Experimental
XRViewerPoseXRViewportXRWebGLBinding
Experimental
XRWebGLDepthInformation
Experimental
XRWebGLLayer
Experimental
XRWebGLSubImage
Experimental
XSLTProcessorSee also
Web API event reference\n\nWeb APIsWhen writing code for the Web, there are a large number of Web APIs available. Below is a list of all the APIs and interfaces (object types) that you may be able to use while developing your Web app or site.
Web APIs are typically used with JavaScript, although this doesn't always have to be the case.SpecificationsThis is a list of all the APIs that are available.
AAttribution Reporting API
Experimental
Audio Output Devices API
Experimental
BBackground Fetch API
Experimental
Background Synchronization APIBackground Tasks APIBadging APIBarcode Detection API
Experimental
Battery Status APIBeacon APIWeb Bluetooth API
Experimental
Broadcast Channel APICCSS Custom Highlight APICSS Font Loading APICSS Painting API
Experimental
CSS Properties and Values APICSS Typed Object Model APICSS Object Model (CSSOM)Canvas APIChannel Messaging APIClipboard APICompression Streams APICompute Pressure API
Experimental
Console APIContact Picker API
Experimental
Content Index API
Experimental
Cookie Store APICredential Management APIDDocument Object Model (DOM)Device Memory APIDevice orientation eventsDevice Posture API
Experimental
Document Picture-in-Picture API
Experimental
EEditContext API
Experimental
Encoding APIEncrypted Media Extensions APIEyeDropper API
Experimental
FFederated Credential Management (FedCM) API
Experimental
Fenced Frame API
Experimental
Fetch APIFile APIFile System APIFile and Directory Entries APIForce Touch events
Non-standard
Fullscreen APIGGamepad APIGeolocation APIGeometry interfacesHThe HTML DOM APIHTML Drag and Drop APIHistory APIHoudini APIsIIdle Detection API
Experimental
MediaStream Image Capture APIIndexedDB APIInk API
Experimental
InputDeviceCapabilities API
Experimental
Insertable Streams for MediaStreamTrack APIIntersection Observer APIInvoker Commands APIJJS Self-Profiling API
Experimental
KKeyboard API
Experimental
LLaunch Handler API
Experimental
Local Font Access API
Experimental
MMedia Capabilities APIMedia Capture and Streams API (Media Stream)Media Session APIMedia Source API
Experimental
MediaStream Recording APINNavigation API
Experimental
Network Information APIPPage Visibility APIPayment Handler API
Experimental
Payment Request APIPerformance APIsWeb Periodic Background Synchronization API
Experimental
Permissions APIPicture-in-Picture APIPointer eventsPointer Lock APIPopover APIPresentation API
Experimental
Prioritized Task Scheduling APIPush APIRRemote Playback APIReporting APIResize Observer APISSVG APIScreen Capture APIScreen Orientation APIScreen Wake Lock APISelection APISensor APIsServer-sent eventsService Worker APIShared Storage API
Experimental
Speculation Rules API
Experimental
Storage APIStorage Access APIStreams APITTopics API
Experimental

Non-standard
Touch eventsTrusted Types APIUUI EventsURL APIURL Fragment Text DirectivesURL Pattern API
Experimental
User-Agent Client Hints API
Experimental
VVibration APIView Transition APIVirtualKeyboard API
Experimental
Visual Viewport APIWWeb Animations APIWeb Audio APIWeb Authentication APIWeb ComponentsWeb Crypto APIWeb Locks APIWeb MIDI APIWeb NFC API
Experimental
Notifications APIWeb Serial API
Experimental
Web Share APIWeb Speech APIWeb Storage APIWeb Workers APIWebCodecs APIWebGL: 2D and 3D graphics for the webWebGPU API
Experimental
WebHID API
Experimental
WebOTP APIWebRTC APIThe WebSocket API (WebSockets)WebTransport APIWebUSB API
Experimental
WebVR API
Non-standard

Deprecated
WebVTT APIWebXR Device API
Experimental
Window Controls Overlay API
Experimental
Window Management API
Experimental
XXMLHttpRequest APIffetchLater() API
Experimental
InterfacesThis is a list of all the interfaces (that is, types of objects) that are available.
AAbortControllerAbortSignalAbsoluteOrientationSensorAbstractRangeAccelerometer
Experimental
AesCbcParamsAesCtrParamsAesGcmParamsAesKeyGenParamsAmbientLightSensor
Experimental
AnalyserNodeANGLE_instanced_arraysAnimationAnimationEffectAnimationEventAnimationPlaybackEventAnimationTimelineAttrAudioBufferAudioBufferSourceNodeAudioContextAudioDataAudioDecoderAudioDestinationNodeAudioEncoderAudioListenerAudioNodeAudioParamAudioParamDescriptorAudioParamMapAudioProcessingEvent
Deprecated
AudioScheduledSourceNodeAudioSinkInfo
Experimental
AudioTrackAudioTrackListAudioWorkletAudioWorkletGlobalScopeAudioWorkletNodeAudioWorkletProcessorAuthenticatorAssertionResponseAuthenticatorAttestationResponseAuthenticatorResponseBBackgroundFetchEvent
Experimental
BackgroundFetchManager
Experimental
BackgroundFetchRecord
Experimental
BackgroundFetchRegistration
Experimental
BackgroundFetchUpdateUIEvent
Experimental
BarcodeDetector
Experimental
BarPropBaseAudioContextBatteryManagerBeforeInstallPromptEvent
Experimental

Non-standard
BeforeUnloadEventBiquadFilterNodeBlobBlobEventBluetooth
Experimental
BluetoothCharacteristicProperties
Experimental
BluetoothDevice
Experimental
BluetoothRemoteGATTCharacteristic
Experimental
BluetoothRemoteGATTDescriptor
Experimental
BluetoothRemoteGATTServer
Experimental
BluetoothRemoteGATTService
Experimental
BluetoothUUIDBroadcastChannelBrowserCaptureMediaStreamTrack
Experimental
ByteLengthQueuingStrategyCCacheCacheStorageCanMakePaymentEvent
Experimental
CanvasCaptureMediaStreamTrackCanvasGradientCanvasPatternCanvasRenderingContext2DCaptureController
Experimental
CaretPositionCDATASectionChannelMergerNodeChannelSplitterNodeChapterInformation
Experimental
CharacterBoundsUpdateEvent
Experimental
CharacterDataClientClientsClipboardClipboardEventClipboardItemCloseEventCloseWatcher
Experimental
CommandEventCommentCompositionEventCompressionStreamcconsoleCConstantSourceNodeContactAddress
Experimental
ContactsManager
Experimental
ContentIndex
Experimental
ContentIndexEvent
Experimental
ContentVisibilityAutoStateChangeEventConvolverNodeCookieChangeEventCookieStoreCookieStoreManagerCountQueuingStrategyCredentialCredentialsContainerCropTarget
Experimental
CryptoCryptoKeyCryptoKeyPairCSPViolationReportBodyCSSCSSAnimationCSSConditionRuleCSSContainerRuleCSSCounterStyleRuleCSSFontFaceRuleCSSFontFeatureValuesRuleCSSFontPaletteValuesRuleCSSGroupingRuleCSSImageValueCSSImportRuleCSSKeyframeRuleCSSKeyframesRuleCSSKeywordValueCSSLayerBlockRuleCSSLayerStatementRuleCSSMathInvertCSSMathMaxCSSMathMinCSSMathNegateCSSMathProductCSSMathSumCSSMathValueCSSMatrixComponentCSSMediaRuleCSSNamespaceRuleCSSNestedDeclarationsCSSNumericArrayCSSNumericValueCSSPageDescriptors
Experimental
CSSPageRuleCSSPerspectiveCSSPositionTryDescriptors
Experimental
CSSPositionTryRule
Experimental
CSSPositionValue
Non-standard

Deprecated
CSSPrimitiveValue
Deprecated
CSSPropertyRuleCSSPseudoElement
Experimental
CSSRotateCSSRuleCSSRuleListCSSScaleCSSScopeRuleCSSSkewCSSSkewXCSSSkewYCSSStartingStyleRuleCSSStyleDeclarationCSSStyleRuleCSSStyleSheetCSSStyleValueCSSSupportsRuleCSSTransformComponentCSSTransformValueCSSTransitionCSSTranslateCSSUnitValueCSSUnparsedValueCSSValue
Deprecated
CSSValueList
Deprecated
CSSVariableReferenceValueCustomElementRegistryCustomEventCustomStateSetDDataTransferDataTransferItemDataTransferItemListDecompressionStreamDedicatedWorkerGlobalScopeDeferredRequestInit
Experimental
DelayNodeDelegatedInkTrailPresenter
Experimental
DeprecationReportBody
Experimental
DeviceMotionEventDeviceMotionEventAccelerationDeviceMotionEventRotationRateDeviceOrientationEventDevicePosture
Experimental
DirectoryEntrySync
Non-standard

Deprecated
DirectoryReaderSync
Non-standard

Deprecated
DocumentDocumentFragmentDocumentPictureInPicture
Experimental
DocumentPictureInPictureEvent
Experimental
DocumentTimelineDocumentTypeDOMError
Deprecated
DOMExceptionDOMHighResTimeStampDOMImplementationDOMMatrixDOMMatrixReadOnlyDOMParserDOMPointDOMPointReadOnlyDOMQuadDOMRectDOMRectListDOMRectReadOnlyDOMStringListDOMStringMapDOMTokenListDragEventDynamicsCompressorNodeEEcdhKeyDeriveParamsEcdsaParamsEcKeyGenParamsEcKeyImportParamsEditContext
Experimental
ElementElementInternalsEncodedAudioChunkEncodedVideoChunkErrorEventEventEventCountsEventSourceEventTargetExtendableCookieChangeEventExtendableEventExtendableMessageEventEyeDropper
Experimental
FFeaturePolicy
Experimental
FederatedCredential
Experimental
FederatedCredentialInitFence
Experimental
FencedFrameConfig
Experimental
FetchEventFetchLaterResult
Experimental
FileFileEntrySync
Non-standard

Deprecated
FileListFileReaderFileReaderSyncFileSystemFileSystemChangeRecordFileSystemDirectoryEntryFileSystemDirectoryHandleFileSystemDirectoryReaderFileSystemEntryFileSystemFileEntryFileSystemFileHandleFileSystemHandleFileSystemObserver
Experimental

Non-standard
FileSystemSync
Non-standard

Deprecated
FileSystemSyncAccessHandleFileSystemWritableFileStreamFocusEventFontData
Experimental
FontFaceFontFaceSetFontFaceSetLoadEventFormDataFormDataEventFragmentDirectiveGGainNodeGamepadGamepadButtonGamepadEventGamepadHapticActuatorGamepadPose
Experimental
GeolocationGeolocationCoordinatesGeolocationPositionGeolocationPositionErrorGestureEvent
Non-standard
GPU
Experimental
GPUAdapter
Experimental
GPUAdapterInfo
Experimental
GPUBindGroup
Experimental
GPUBindGroupLayout
Experimental
GPUBuffer
Experimental
GPUCanvasContext
Experimental
GPUCommandBuffer
Experimental
GPUCommandEncoder
Experimental
GPUCompilationInfo
Experimental
GPUCompilationMessage
Experimental
GPUComputePassEncoder
Experimental
GPUComputePipeline
Experimental
GPUDevice
Experimental
GPUDeviceLostInfo
Experimental
GPUError
Experimental
GPUExternalTexture
Experimental
GPUInternalError
Experimental
GPUOutOfMemoryError
Experimental
GPUPipelineError
Experimental
GPUPipelineLayout
Experimental
GPUQuerySet
Experimental
GPUQueue
Experimental
GPURenderBundle
Experimental
GPURenderBundleEncoder
Experimental
GPURenderPassEncoder
Experimental
GPURenderPipeline
Experimental
GPUSampler
Experimental
GPUShaderModule
Experimental
GPUSupportedFeatures
Experimental
GPUSupportedLimits
Experimental
GPUTexture
Experimental
GPUTextureView
Experimental
GPUUncapturedErrorEvent
Experimental
GPUValidationError
Experimental
GravitySensorGyroscopeHHashChangeEventHeadersHID
Experimental
HIDConnectionEvent
Experimental
HIDDevice
Experimental
HIDInputReportEvent
Experimental
HighlightHighlightRegistryHistoryHkdfParamsHmacImportParamsHmacKeyGenParamsHMDVRDevice
Non-standard

Deprecated
HTMLAllCollectionHTMLAnchorElementHTMLAreaElementHTMLAudioElementHTMLBaseElementHTMLBodyElementHTMLBRElementHTMLButtonElementHTMLCanvasElementHTMLCollectionHTMLDataElementHTMLDataListElementHTMLDetailsElementHTMLDialogElementHTMLDivElementHTMLDListElementHTMLDocumentHTMLElementHTMLEmbedElementHTMLFencedFrameElement
Experimental
HTMLFieldSetElementHTMLFontElement
Deprecated
HTMLFormControlsCollectionHTMLFormElementHTMLFrameSetElement
Deprecated
HTMLHeadElementHTMLHeadingElementHTMLHRElementHTMLHtmlElementHTMLIFrameElementHTMLImageElementHTMLInputElementHTMLLabelElementHTMLLegendElementHTMLLIElementHTMLLinkElementHTMLMapElementHTMLMarqueeElement
Deprecated
HTMLMediaElementHTMLMenuElementHTMLMetaElementHTMLMeterElementHTMLModElementHTMLObjectElementHTMLOListElementHTMLOptGroupElementHTMLOptionElementHTMLOptionsCollectionHTMLOutputElementHTMLParagraphElementHTMLParamElement
Deprecated
HTMLPictureElementHTMLPreElementHTMLProgressElementHTMLQuoteElementHTMLScriptElementHTMLSelectedContentElementHTMLSelectElementHTMLSlotElementHTMLSourceElementHTMLSpanElementHTMLStyleElementHTMLTableCaptionElementHTMLTableCellElementHTMLTableColElementHTMLTableElementHTMLTableRowElementHTMLTableSectionElementHTMLTemplateElementHTMLTextAreaElementHTMLTimeElementHTMLTitleElementHTMLTrackElementHTMLUListElementHTMLUnknownElementHTMLVideoElementIIDBCursorIDBCursorWithValueIDBDatabaseIDBFactoryIDBIndexIDBKeyRangeIDBObjectStoreIDBOpenDBRequestIDBRequestIDBTransactionIDBVersionChangeEventIdentityCredential
Experimental
IdentityCredentialRequestOptionsIdentityProvider
Experimental
IdleDeadlineIdleDetector
Experimental
IIRFilterNodeImageBitmapImageBitmapRenderingContextImageCaptureImageDataImageDecoderImageTrackImageTrackListInk
Experimental
InputDeviceCapabilities
Experimental
InputDeviceInfoInputEventInstallEventIntersectionObserverIntersectionObserverEntryInterventionReportBody
Experimental
KKeyboard
Experimental
KeyboardEventKeyboardLayoutMap
Experimental
KeyframeEffectLLargestContentfulPaintLaunchParams
Experimental
LaunchQueue
Experimental
LayoutShift
Experimental
LayoutShiftAttribution
Experimental
LinearAccelerationSensorLocationLockLockManagerMMagnetometer
Experimental
MathMLElementMediaCapabilitiesMediaDeviceInfoMediaDevicesMediaElementAudioSourceNodeMediaEncryptedEventMediaErrorMediaKeyMessageEventMediaKeysMediaKeySessionMediaKeyStatusMapMediaKeySystemAccessMediaListMediaMetadataMediaQueryListMediaQueryListEventMediaRecorderMediaRecorderErrorEvent
Non-standard

Deprecated
MediaSessionMediaSourceMediaSourceHandleMediaStreamMediaStreamAudioDestinationNodeMediaStreamAudioSourceNodeMediaStreamEvent
Non-standard

Deprecated
MediaStreamTrackMediaStreamTrackAudioSourceNodeMediaStreamTrackEventMediaStreamTrackGenerator
Experimental

Non-standard
MediaStreamTrackProcessorMediaTrackConstraintsMediaTrackSettingsMediaTrackSupportedConstraintsMerchantValidationEvent
Deprecated
MessageChannelMessageEventMessagePortMetadata
Experimental

Non-standard
MIDIAccessMIDIConnectionEventMIDIInputMIDIInputMapMIDIMessageEventMIDIOutputMIDIOutputMapMIDIPortMimeType
Deprecated
MimeTypeArray
Deprecated
MouseEventMouseScrollEvent
Non-standard

Deprecated
MutationEvent
Non-standard

Deprecated
MutationObserverMutationRecordNNamedNodeMapNavigateEvent
Experimental
Navigation
Experimental
NavigationActivation
Experimental
NavigationCurrentEntryChangeEvent
Experimental
NavigationDestination
Experimental
NavigationHistoryEntry
Experimental
NavigationPreloadManagerNavigationTransition
Experimental
NavigatorNavigatorLoginNavigatorUAData
Experimental
NDEFMessage
Experimental
NDEFReader
Experimental
NDEFReadingEvent
Experimental
NDEFRecord
Experimental
NetworkInformationNodeNodeIteratorNodeListNotificationNotificationEventNotRestoredReasonDetails
Experimental
NotRestoredReasons
Experimental
OOES_draw_buffers_indexedOfflineAudioCompletionEventOfflineAudioContextOffscreenCanvasOffscreenCanvasRenderingContext2DOrientationSensorOscillatorNodeOTPCredential
Experimental
OverconstrainedErrorPPageRevealEventPageSwapEventPageTransitionEventPaintRenderingContext2DPaintSizePaintWorkletGlobalScope
Experimental
PannerNodePasswordCredential
Experimental
PasswordCredentialInitPath2DPaymentAddress
Non-standard

Deprecated
PaymentManager
Experimental
PaymentMethodChangeEventPaymentRequestPaymentRequestEvent
Experimental
PaymentRequestUpdateEventPaymentResponsePbkdf2ParamsPerformancePerformanceElementTiming
Experimental
PerformanceEntryPerformanceEventTimingPerformanceLongAnimationFrameTiming
Experimental
PerformanceLongTaskTiming
Experimental
PerformanceMarkPerformanceMeasurePerformanceNavigation
Deprecated
PerformanceNavigationTimingPerformanceObserverPerformanceObserverEntryListPerformancePaintTimingPerformanceResourceTimingPerformanceScriptTiming
Experimental
PerformanceServerTimingPerformanceTiming
Deprecated
PeriodicSyncEvent
Experimental
PeriodicSyncManager
Experimental
PeriodicWavePermissionsPermissionStatusPictureInPictureEventPictureInPictureWindowPlugin
Deprecated
PluginArray
Deprecated
Point
Non-standard

Deprecated
PointerEventPopStateEventPositionSensorVRDevice
Non-standard

Deprecated
Presentation
Experimental
PresentationAvailability
Experimental
PresentationConnection
Experimental
PresentationConnectionAvailableEvent
Experimental
PresentationConnectionCloseEvent
Experimental
PresentationConnectionList
Experimental
PresentationReceiver
Experimental
PresentationRequest
Experimental
PressureObserver
Experimental
PressureRecord
Experimental
ProcessingInstructionProfiler
Experimental
ProgressEventPromiseRejectionEventPublicKeyCredentialPublicKeyCredentialCreationOptionsPublicKeyCredentialRequestOptionsPushEventPushManagerPushMessageDataPushSubscriptionPushSubscriptionOptionsRRadioNodeListRangeReadableByteStreamControllerReadableStreamReadableStreamBYOBReaderReadableStreamBYOBRequestReadableStreamDefaultControllerReadableStreamDefaultReaderRelativeOrientationSensorRemotePlaybackReportReportBodyReportingObserverRequestRequestInitResizeObserverResizeObserverEntryResizeObserverSizeResponseRestrictionTarget
Experimental
RsaHashedImportParamsRsaHashedKeyGenParamsRsaOaepParamsRsaPssParamsRTCAudioSourceStatsRTCCertificateRTCCertificateStatsRTCCodecStatsRTCDataChannelRTCDataChannelEventRTCDataChannelStatsRTCDtlsTransportRTCDTMFSenderRTCDTMFToneChangeEventRTCEncodedAudioFrameRTCEncodedVideoFrameRTCErrorRTCErrorEventRTCIceCandidateRTCIceCandidatePairRTCIceCandidatePairStatsRTCIceCandidateStatsRTCIceParametersRTCIceTransportRTCIdentityAssertion
Experimental
RTCInboundRtpStreamStatsRTCOutboundRtpStreamStatsRTCPeerConnectionRTCPeerConnectionIceErrorEventRTCPeerConnectionIceEventRTCPeerConnectionStatsRTCRemoteInboundRtpStreamStatsRTCRemoteOutboundRtpStreamStatsRTCRtpReceiverRTCRtpScriptTransformRTCRtpScriptTransformerRTCRtpSenderRTCRtpTransceiverRTCSctpTransportRTCSessionDescriptionRTCStatsReportRTCTrackEventRTCTransformEventRTCTransportStatsRTCVideoSourceStatsSSchedulerScheduling
Experimental
ScreenScreenDetailed
Experimental
ScreenDetails
Experimental
ScreenOrientationScriptProcessorNode
Deprecated
ScrollTimeline
Experimental
SecurePaymentConfirmationRequestSecurityPolicyViolationEventSelectionSensorSensorErrorEventSerial
Experimental
SerialPort
Experimental
ServiceWorkerServiceWorkerContainerServiceWorkerGlobalScopeServiceWorkerRegistrationShadowRootSharedStorage
Experimental
SharedStorageOperation
Experimental
SharedStorageRunOperation
Experimental
SharedStorageSelectURLOperation
Experimental
SharedStorageWorklet
Experimental
SharedStorageWorkletGlobalScope
Experimental
SharedWorkerSharedWorkerGlobalScopeSnapEvent
Experimental
SourceBufferSourceBufferListSpeechGrammar
Non-standard

Deprecated
SpeechGrammarList
Experimental
SpeechRecognitionSpeechRecognitionAlternativeSpeechRecognitionErrorEventSpeechRecognitionEventSpeechRecognitionResultSpeechRecognitionResultListSpeechSynthesisSpeechSynthesisErrorEventSpeechSynthesisEventSpeechSynthesisUtteranceSpeechSynthesisVoiceStaticRangeStereoPannerNodeStorageStorageAccessHandleStorageEventStorageManagerStylePropertyMapStylePropertyMapReadOnlyStyleSheetStyleSheetListSubmitEventSubtleCryptoSVGAElementSVGAngleSVGAnimateColorElement
Deprecated
SVGAnimatedAngleSVGAnimatedBooleanSVGAnimatedEnumerationSVGAnimatedIntegerSVGAnimatedLengthSVGAnimatedLengthListSVGAnimatedNumberSVGAnimatedNumberListSVGAnimatedPreserveAspectRatioSVGAnimatedRectSVGAnimatedStringSVGAnimatedTransformListSVGAnimateElementSVGAnimateMotionElementSVGAnimateTransformElementSVGAnimationElementSVGCircleElementSVGClipPathElementSVGComponentTransferFunctionElementSVGDefsElementSVGDescElementSVGDiscardElement
Experimental
SVGElementSVGEllipseElementSVGFEBlendElementSVGFEColorMatrixElementSVGFEComponentTransferElementSVGFECompositeElementSVGFEConvolveMatrixElementSVGFEDiffuseLightingElementSVGFEDisplacementMapElementSVGFEDistantLightElementSVGFEDropShadowElementSVGFEFloodElementSVGFEFuncAElementSVGFEFuncBElementSVGFEFuncGElementSVGFEFuncRElementSVGFEGaussianBlurElementSVGFEImageElementSVGFEMergeElementSVGFEMergeNodeElementSVGFEMorphologyElementSVGFEOffsetElementSVGFEPointLightElementSVGFESpecularLightingElementSVGFESpotLightElementSVGFETileElementSVGFETurbulenceElementSVGFilterElementSVGForeignObjectElementSVGGElementSVGGeometryElementSVGGradientElementSVGGraphicsElementSVGImageElementSVGLengthSVGLengthListSVGLinearGradientElementSVGLineElementSVGMarkerElementSVGMaskElementSVGMetadataElementSVGMPathElementSVGNumberSVGNumberListSVGPathElementSVGPatternElementSVGPoint
Deprecated
SVGPointListSVGPolygonElementSVGPolylineElementSVGPreserveAspectRatioSVGRadialGradientElementSVGRectSVGRectElementSVGRenderingIntent
Deprecated
SVGScriptElementSVGSetElementSVGStopElementSVGStringListSVGStyleElementSVGSVGElementSVGSwitchElementSVGSymbolElementSVGTextContentElementSVGTextElementSVGTextPathElementSVGTextPositioningElementSVGTitleElementSVGTransformSVGTransformListSVGTSpanElementSVGUnitTypesSVGUseElementSVGViewElementSyncEventSyncManagerTTaskAttributionTiming
Experimental
TaskControllerTaskPriorityChangeEventTaskSignalTextTextDecoderTextDecoderStreamTextEncoderTextEncoderStreamTextEvent
Deprecated
TextFormat
Experimental
TextFormatUpdateEvent
Experimental
TextMetricsTextTrackTextTrackCueTextTrackCueListTextTrackListTextUpdateEvent
Experimental
TimeEventTimeRangesToggleEventTouchTouchEventTouchListTrackEventTransformStreamTransformStreamDefaultControllerTransitionEventTreeWalkerTrustedHTMLTrustedScriptTrustedScriptURLTrustedTypePolicyTrustedTypePolicyFactoryUUIEventURLURLPattern
Experimental
URLSearchParamsUSB
Experimental
USBAlternateInterface
Experimental
USBConfiguration
Experimental
USBConnectionEvent
Experimental
USBDevice
Experimental
USBEndpoint
Experimental
USBInterface
Experimental
USBInTransferResult
Experimental
USBIsochronousInTransferPacket
Experimental
USBIsochronousInTransferResult
Experimental
USBIsochronousOutTransferPacket
Experimental
USBIsochronousOutTransferResult
Experimental
USBOutTransferResult
Experimental
UserActivationVValidityStateVideoColorSpaceVideoDecoderVideoEncoderVideoFrameVideoPlaybackQualityVideoTrackVideoTrackListViewTimeline
Experimental
ViewTransitionVirtualKeyboard
Experimental
VisibilityStateEntry
Experimental
VisualViewportVRDisplay
Non-standard

Deprecated
VRDisplayCapabilities
Non-standard

Deprecated
VRDisplayEvent
Non-standard

Deprecated
VREyeParameters
Non-standard

Deprecated
VRFieldOfView
Non-standard

Deprecated
VRFrameData
Non-standard

Deprecated
VRLayerInit
Deprecated
VRPose
Non-standard

Deprecated
VRStageParameters
Non-standard

Deprecated
VTTCueVTTRegionWWakeLockWakeLockSentinelWaveShaperNodeWebGL2RenderingContextWebGLActiveInfoWebGLBufferWebGLContextEventWebGLFramebufferWebGLObject
Experimental
WebGLProgramWebGLQueryWebGLRenderbufferWebGLRenderingContextWebGLSamplerWebGLShaderWebGLShaderPrecisionFormatWebGLSyncWebGLTextureWebGLTransformFeedbackWebGLUniformLocationWebGLVertexArrayObjectWebSocketWebSocketStream
Experimental
WebTransportWebTransportBidirectionalStreamWebTransportDatagramDuplexStreamWebTransportErrorWebTransportReceiveStream
Experimental
WebTransportSendStream
Experimental
WGSLLanguageFeatures
Experimental
WheelEventWindowWindowClientWindowControlsOverlay
Experimental
WindowControlsOverlayGeometryChangeEvent
Experimental
WindowSharedStorage
Experimental
WorkerWorkerGlobalScopeWorkerLocationWorkerNavigatorWorkletWorkletGlobalScopeWorkletSharedStorage
Experimental
WritableStreamWritableStreamDefaultControllerWritableStreamDefaultWriterXXMLDocumentXMLHttpRequestXMLHttpRequestEventTargetXMLHttpRequestUploadXMLSerializerXPathEvaluatorXPathExpressionXPathResultXRAnchor
Experimental
XRAnchorSet
Experimental
XRBoundedReferenceSpace
Experimental
XRCompositionLayer
Experimental
XRCPUDepthInformation
Experimental
XRCubeLayer
Experimental
XRCylinderLayer
Experimental
XRDepthInformation
Experimental
XREquirectLayer
Experimental
XRFrame
Experimental
XRHandXRHitTestResult
Experimental
XRHitTestSource
Experimental
XRInputSourceXRInputSourceArray
Experimental
XRInputSourceEventXRInputSourcesChangeEventXRJointPoseXRJointSpaceXRLayer
Experimental
XRLayerEvent
Experimental
XRLightEstimate
Experimental
XRLightProbe
Experimental
XRMediaBinding
Experimental
XRPoseXRProjectionLayer
Experimental
XRQuadLayer
Experimental
XRRay
Experimental
XRReferenceSpaceXRReferenceSpaceEventXRRenderState
Experimental
XRRigidTransformXRSession
Experimental
XRSessionEventXRSpaceXRSubImage
Experimental
XRSystem
Experimental
XRTransientInputHitTestResult
Experimental
XRTransientInputHitTestSource
Experimental
XRView
Experimental
XRViewerPoseXRViewportXRWebGLBinding
Experimental
XRWebGLDepthInformation
Experimental
XRWebGLLayer
Experimental
XRWebGLSubImage
Experimental
XSLTProcessorSee also
Web API event reference
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 20, 2023 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWeb APIsWhen writing code for the Web, there are a large number of Web APIs available. Below is a list of all the APIs and interfaces (object types) that you may be able to use while developing your Web app or site.
Web APIs are typically used with JavaScript, although this doesn't always have to be the case.SpecificationsThis is a list of all the APIs that are available.
AAttribution Reporting API
Experimental
Audio Output Devices API
Experimental
BBackground Fetch API
Experimental
Background Synchronization APIBackground Tasks APIBadging APIBarcode Detection API
Experimental
Battery Status APIBeacon APIWeb Bluetooth API
Experimental
Broadcast Channel APICCSS Custom Highlight APICSS Font Loading APICSS Painting API
Experimental
CSS Properties and Values APICSS Typed Object Model APICSS Object Model (CSSOM)Canvas APIChannel Messaging APIClipboard APICompression Streams APICompute Pressure API
Experimental
Console APIContact Picker API
Experimental
Content Index API
Experimental
Cookie Store APICredential Management APIDDocument Object Model (DOM)Device Memory APIDevice orientation eventsDevice Posture API
Experimental
Document Picture-in-Picture API
Experimental
EEditContext API
Experimental
Encoding APIEncrypted Media Extensions APIEyeDropper API
Experimental
FFederated Credential Management (FedCM) API
Experimental
Fenced Frame API
Experimental
Fetch APIFile APIFile System APIFile and Directory Entries APIForce Touch events
Non-standard
Fullscreen APIGGamepad APIGeolocation APIGeometry interfacesHThe HTML DOM APIHTML Drag and Drop APIHistory APIHoudini APIsIIdle Detection API
Experimental
MediaStream Image Capture APIIndexedDB APIInk API
Experimental
InputDeviceCapabilities API
Experimental
Insertable Streams for MediaStreamTrack APIIntersection Observer APIInvoker Commands APIJJS Self-Profiling API
Experimental
KKeyboard API
Experimental
LLaunch Handler API
Experimental
Local Font Access API
Experimental
MMedia Capabilities APIMedia Capture and Streams API (Media Stream)Media Session APIMedia Source API
Experimental
MediaStream Recording APINNavigation API
Experimental
Network Information APIPPage Visibility APIPayment Handler API
Experimental
Payment Request APIPerformance APIsWeb Periodic Background Synchronization API
Experimental
Permissions APIPicture-in-Picture APIPointer eventsPointer Lock APIPopover APIPresentation API
Experimental
Prioritized Task Scheduling APIPush APIRRemote Playback APIReporting APIResize Observer APISSVG APIScreen Capture APIScreen Orientation APIScreen Wake Lock APISelection APISensor APIsServer-sent eventsService Worker APIShared Storage API
Experimental
Speculation Rules API
Experimental
Storage APIStorage Access APIStreams APITTopics API
Experimental

Non-standard
Touch eventsTrusted Types APIUUI EventsURL APIURL Fragment Text DirectivesURL Pattern API
Experimental
User-Agent Client Hints API
Experimental
VVibration APIView Transition APIVirtualKeyboard API
Experimental
Visual Viewport APIWWeb Animations APIWeb Audio APIWeb Authentication APIWeb ComponentsWeb Crypto APIWeb Locks APIWeb MIDI APIWeb NFC API
Experimental
Notifications APIWeb Serial API
Experimental
Web Share APIWeb Speech APIWeb Storage APIWeb Workers APIWebCodecs APIWebGL: 2D and 3D graphics for the webWebGPU API
Experimental
WebHID API
Experimental
WebOTP APIWebRTC APIThe WebSocket API (WebSockets)WebTransport APIWebUSB API
Experimental
WebVR API
Non-standard

Deprecated
WebVTT APIWebXR Device API
Experimental
Window Controls Overlay API
Experimental
Window Management API
Experimental
XXMLHttpRequest APIffetchLater() API
Experimental
InterfacesThis is a list of all the interfaces (that is, types of objects) that are available.
AAbortControllerAbortSignalAbsoluteOrientationSensorAbstractRangeAccelerometer
Experimental
AesCbcParamsAesCtrParamsAesGcmParamsAesKeyGenParamsAmbientLightSensor
Experimental
AnalyserNodeANGLE_instanced_arraysAnimationAnimationEffectAnimationEventAnimationPlaybackEventAnimationTimelineAttrAudioBufferAudioBufferSourceNodeAudioContextAudioDataAudioDecoderAudioDestinationNodeAudioEncoderAudioListenerAudioNodeAudioParamAudioParamDescriptorAudioParamMapAudioProcessingEvent
Deprecated
AudioScheduledSourceNodeAudioSinkInfo
Experimental
AudioTrackAudioTrackListAudioWorkletAudioWorkletGlobalScopeAudioWorkletNodeAudioWorkletProcessorAuthenticatorAssertionResponseAuthenticatorAttestationResponseAuthenticatorResponseBBackgroundFetchEvent
Experimental
BackgroundFetchManager
Experimental
BackgroundFetchRecord
Experimental
BackgroundFetchRegistration
Experimental
BackgroundFetchUpdateUIEvent
Experimental
BarcodeDetector
Experimental
BarPropBaseAudioContextBatteryManagerBeforeInstallPromptEvent
Experimental

Non-standard
BeforeUnloadEventBiquadFilterNodeBlobBlobEventBluetooth
Experimental
BluetoothCharacteristicProperties
Experimental
BluetoothDevice
Experimental
BluetoothRemoteGATTCharacteristic
Experimental
BluetoothRemoteGATTDescriptor
Experimental
BluetoothRemoteGATTServer
Experimental
BluetoothRemoteGATTService
Experimental
BluetoothUUIDBroadcastChannelBrowserCaptureMediaStreamTrack
Experimental
ByteLengthQueuingStrategyCCacheCacheStorageCanMakePaymentEvent
Experimental
CanvasCaptureMediaStreamTrackCanvasGradientCanvasPatternCanvasRenderingContext2DCaptureController
Experimental
CaretPositionCDATASectionChannelMergerNodeChannelSplitterNodeChapterInformation
Experimental
CharacterBoundsUpdateEvent
Experimental
CharacterDataClientClientsClipboardClipboardEventClipboardItemCloseEventCloseWatcher
Experimental
CommandEventCommentCompositionEventCompressionStreamcconsoleCConstantSourceNodeContactAddress
Experimental
ContactsManager
Experimental
ContentIndex
Experimental
ContentIndexEvent
Experimental
ContentVisibilityAutoStateChangeEventConvolverNodeCookieChangeEventCookieStoreCookieStoreManagerCountQueuingStrategyCredentialCredentialsContainerCropTarget
Experimental
CryptoCryptoKeyCryptoKeyPairCSPViolationReportBodyCSSCSSAnimationCSSConditionRuleCSSContainerRuleCSSCounterStyleRuleCSSFontFaceRuleCSSFontFeatureValuesRuleCSSFontPaletteValuesRuleCSSGroupingRuleCSSImageValueCSSImportRuleCSSKeyframeRuleCSSKeyframesRuleCSSKeywordValueCSSLayerBlockRuleCSSLayerStatementRuleCSSMathInvertCSSMathMaxCSSMathMinCSSMathNegateCSSMathProductCSSMathSumCSSMathValueCSSMatrixComponentCSSMediaRuleCSSNamespaceRuleCSSNestedDeclarationsCSSNumericArrayCSSNumericValueCSSPageDescriptors
Experimental
CSSPageRuleCSSPerspectiveCSSPositionTryDescriptors
Experimental
CSSPositionTryRule
Experimental
CSSPositionValue
Non-standard

Deprecated
CSSPrimitiveValue
Deprecated
CSSPropertyRuleCSSPseudoElement
Experimental
CSSRotateCSSRuleCSSRuleListCSSScaleCSSScopeRuleCSSSkewCSSSkewXCSSSkewYCSSStartingStyleRuleCSSStyleDeclarationCSSStyleRuleCSSStyleSheetCSSStyleValueCSSSupportsRuleCSSTransformComponentCSSTransformValueCSSTransitionCSSTranslateCSSUnitValueCSSUnparsedValueCSSValue
Deprecated
CSSValueList
Deprecated
CSSVariableReferenceValueCustomElementRegistryCustomEventCustomStateSetDDataTransferDataTransferItemDataTransferItemListDecompressionStreamDedicatedWorkerGlobalScopeDeferredRequestInit
Experimental
DelayNodeDelegatedInkTrailPresenter
Experimental
DeprecationReportBody
Experimental
DeviceMotionEventDeviceMotionEventAccelerationDeviceMotionEventRotationRateDeviceOrientationEventDevicePosture
Experimental
DirectoryEntrySync
Non-standard

Deprecated
DirectoryReaderSync
Non-standard

Deprecated
DocumentDocumentFragmentDocumentPictureInPicture
Experimental
DocumentPictureInPictureEvent
Experimental
DocumentTimelineDocumentTypeDOMError
Deprecated
DOMExceptionDOMHighResTimeStampDOMImplementationDOMMatrixDOMMatrixReadOnlyDOMParserDOMPointDOMPointReadOnlyDOMQuadDOMRectDOMRectListDOMRectReadOnlyDOMStringListDOMStringMapDOMTokenListDragEventDynamicsCompressorNodeEEcdhKeyDeriveParamsEcdsaParamsEcKeyGenParamsEcKeyImportParamsEditContext
Experimental
ElementElementInternalsEncodedAudioChunkEncodedVideoChunkErrorEventEventEventCountsEventSourceEventTargetExtendableCookieChangeEventExtendableEventExtendableMessageEventEyeDropper
Experimental
FFeaturePolicy
Experimental
FederatedCredential
Experimental
FederatedCredentialInitFence
Experimental
FencedFrameConfig
Experimental
FetchEventFetchLaterResult
Experimental
FileFileEntrySync
Non-standard

Deprecated
FileListFileReaderFileReaderSyncFileSystemFileSystemChangeRecordFileSystemDirectoryEntryFileSystemDirectoryHandleFileSystemDirectoryReaderFileSystemEntryFileSystemFileEntryFileSystemFileHandleFileSystemHandleFileSystemObserver
Experimental

Non-standard
FileSystemSync
Non-standard

Deprecated
FileSystemSyncAccessHandleFileSystemWritableFileStreamFocusEventFontData
Experimental
FontFaceFontFaceSetFontFaceSetLoadEventFormDataFormDataEventFragmentDirectiveGGainNodeGamepadGamepadButtonGamepadEventGamepadHapticActuatorGamepadPose
Experimental
GeolocationGeolocationCoordinatesGeolocationPositionGeolocationPositionErrorGestureEvent
Non-standard
GPU
Experimental
GPUAdapter
Experimental
GPUAdapterInfo
Experimental
GPUBindGroup
Experimental
GPUBindGroupLayout
Experimental
GPUBuffer
Experimental
GPUCanvasContext
Experimental
GPUCommandBuffer
Experimental
GPUCommandEncoder
Experimental
GPUCompilationInfo
Experimental
GPUCompilationMessage
Experimental
GPUComputePassEncoder
Experimental
GPUComputePipeline
Experimental
GPUDevice
Experimental
GPUDeviceLostInfo
Experimental
GPUError
Experimental
GPUExternalTexture
Experimental
GPUInternalError
Experimental
GPUOutOfMemoryError
Experimental
GPUPipelineError
Experimental
GPUPipelineLayout
Experimental
GPUQuerySet
Experimental
GPUQueue
Experimental
GPURenderBundle
Experimental
GPURenderBundleEncoder
Experimental
GPURenderPassEncoder
Experimental
GPURenderPipeline
Experimental
GPUSampler
Experimental
GPUShaderModule
Experimental
GPUSupportedFeatures
Experimental
GPUSupportedLimits
Experimental
GPUTexture
Experimental
GPUTextureView
Experimental
GPUUncapturedErrorEvent
Experimental
GPUValidationError
Experimental
GravitySensorGyroscopeHHashChangeEventHeadersHID
Experimental
HIDConnectionEvent
Experimental
HIDDevice
Experimental
HIDInputReportEvent
Experimental
HighlightHighlightRegistryHistoryHkdfParamsHmacImportParamsHmacKeyGenParamsHMDVRDevice
Non-standard

Deprecated
HTMLAllCollectionHTMLAnchorElementHTMLAreaElementHTMLAudioElementHTMLBaseElementHTMLBodyElementHTMLBRElementHTMLButtonElementHTMLCanvasElementHTMLCollectionHTMLDataElementHTMLDataListElementHTMLDetailsElementHTMLDialogElementHTMLDivElementHTMLDListElementHTMLDocumentHTMLElementHTMLEmbedElementHTMLFencedFrameElement
Experimental
HTMLFieldSetElementHTMLFontElement
Deprecated
HTMLFormControlsCollectionHTMLFormElementHTMLFrameSetElement
Deprecated
HTMLHeadElementHTMLHeadingElementHTMLHRElementHTMLHtmlElementHTMLIFrameElementHTMLImageElementHTMLInputElementHTMLLabelElementHTMLLegendElementHTMLLIElementHTMLLinkElementHTMLMapElementHTMLMarqueeElement
Deprecated
HTMLMediaElementHTMLMenuElementHTMLMetaElementHTMLMeterElementHTMLModElementHTMLObjectElementHTMLOListElementHTMLOptGroupElementHTMLOptionElementHTMLOptionsCollectionHTMLOutputElementHTMLParagraphElementHTMLParamElement
Deprecated
HTMLPictureElementHTMLPreElementHTMLProgressElementHTMLQuoteElementHTMLScriptElementHTMLSelectedContentElementHTMLSelectElementHTMLSlotElementHTMLSourceElementHTMLSpanElementHTMLStyleElementHTMLTableCaptionElementHTMLTableCellElementHTMLTableColElementHTMLTableElementHTMLTableRowElementHTMLTableSectionElementHTMLTemplateElementHTMLTextAreaElementHTMLTimeElementHTMLTitleElementHTMLTrackElementHTMLUListElementHTMLUnknownElementHTMLVideoElementIIDBCursorIDBCursorWithValueIDBDatabaseIDBFactoryIDBIndexIDBKeyRangeIDBObjectStoreIDBOpenDBRequestIDBRequestIDBTransactionIDBVersionChangeEventIdentityCredential
Experimental
IdentityCredentialRequestOptionsIdentityProvider
Experimental
IdleDeadlineIdleDetector
Experimental
IIRFilterNodeImageBitmapImageBitmapRenderingContextImageCaptureImageDataImageDecoderImageTrackImageTrackListInk
Experimental
InputDeviceCapabilities
Experimental
InputDeviceInfoInputEventInstallEventIntersectionObserverIntersectionObserverEntryInterventionReportBody
Experimental
KKeyboard
Experimental
KeyboardEventKeyboardLayoutMap
Experimental
KeyframeEffectLLargestContentfulPaintLaunchParams
Experimental
LaunchQueue
Experimental
LayoutShift
Experimental
LayoutShiftAttribution
Experimental
LinearAccelerationSensorLocationLockLockManagerMMagnetometer
Experimental
MathMLElementMediaCapabilitiesMediaDeviceInfoMediaDevicesMediaElementAudioSourceNodeMediaEncryptedEventMediaErrorMediaKeyMessageEventMediaKeysMediaKeySessionMediaKeyStatusMapMediaKeySystemAccessMediaListMediaMetadataMediaQueryListMediaQueryListEventMediaRecorderMediaRecorderErrorEvent
Non-standard

Deprecated
MediaSessionMediaSourceMediaSourceHandleMediaStreamMediaStreamAudioDestinationNodeMediaStreamAudioSourceNodeMediaStreamEvent
Non-standard

Deprecated
MediaStreamTrackMediaStreamTrackAudioSourceNodeMediaStreamTrackEventMediaStreamTrackGenerator
Experimental

Non-standard
MediaStreamTrackProcessorMediaTrackConstraintsMediaTrackSettingsMediaTrackSupportedConstraintsMerchantValidationEvent
Deprecated
MessageChannelMessageEventMessagePortMetadata
Experimental

Non-standard
MIDIAccessMIDIConnectionEventMIDIInputMIDIInputMapMIDIMessageEventMIDIOutputMIDIOutputMapMIDIPortMimeType
Deprecated
MimeTypeArray
Deprecated
MouseEventMouseScrollEvent
Non-standard

Deprecated
MutationEvent
Non-standard

Deprecated
MutationObserverMutationRecordNNamedNodeMapNavigateEvent
Experimental
Navigation
Experimental
NavigationActivation
Experimental
NavigationCurrentEntryChangeEvent
Experimental
NavigationDestination
Experimental
NavigationHistoryEntry
Experimental
NavigationPreloadManagerNavigationTransition
Experimental
NavigatorNavigatorLoginNavigatorUAData
Experimental
NDEFMessage
Experimental
NDEFReader
Experimental
NDEFReadingEvent
Experimental
NDEFRecord
Experimental
NetworkInformationNodeNodeIteratorNodeListNotificationNotificationEventNotRestoredReasonDetails
Experimental
NotRestoredReasons
Experimental
OOES_draw_buffers_indexedOfflineAudioCompletionEventOfflineAudioContextOffscreenCanvasOffscreenCanvasRenderingContext2DOrientationSensorOscillatorNodeOTPCredential
Experimental
OverconstrainedErrorPPageRevealEventPageSwapEventPageTransitionEventPaintRenderingContext2DPaintSizePaintWorkletGlobalScope
Experimental
PannerNodePasswordCredential
Experimental
PasswordCredentialInitPath2DPaymentAddress
Non-standard

Deprecated
PaymentManager
Experimental
PaymentMethodChangeEventPaymentRequestPaymentRequestEvent
Experimental
PaymentRequestUpdateEventPaymentResponsePbkdf2ParamsPerformancePerformanceElementTiming
Experimental
PerformanceEntryPerformanceEventTimingPerformanceLongAnimationFrameTiming
Experimental
PerformanceLongTaskTiming
Experimental
PerformanceMarkPerformanceMeasurePerformanceNavigation
Deprecated
PerformanceNavigationTimingPerformanceObserverPerformanceObserverEntryListPerformancePaintTimingPerformanceResourceTimingPerformanceScriptTiming
Experimental
PerformanceServerTimingPerformanceTiming
Deprecated
PeriodicSyncEvent
Experimental
PeriodicSyncManager
Experimental
PeriodicWavePermissionsPermissionStatusPictureInPictureEventPictureInPictureWindowPlugin
Deprecated
PluginArray
Deprecated
Point
Non-standard

Deprecated
PointerEventPopStateEventPositionSensorVRDevice
Non-standard

Deprecated
Presentation
Experimental
PresentationAvailability
Experimental
PresentationConnection
Experimental
PresentationConnectionAvailableEvent
Experimental
PresentationConnectionCloseEvent
Experimental
PresentationConnectionList
Experimental
PresentationReceiver
Experimental
PresentationRequest
Experimental
PressureObserver
Experimental
PressureRecord
Experimental
ProcessingInstructionProfiler
Experimental
ProgressEventPromiseRejectionEventPublicKeyCredentialPublicKeyCredentialCreationOptionsPublicKeyCredentialRequestOptionsPushEventPushManagerPushMessageDataPushSubscriptionPushSubscriptionOptionsRRadioNodeListRangeReadableByteStreamControllerReadableStreamReadableStreamBYOBReaderReadableStreamBYOBRequestReadableStreamDefaultControllerReadableStreamDefaultReaderRelativeOrientationSensorRemotePlaybackReportReportBodyReportingObserverRequestRequestInitResizeObserverResizeObserverEntryResizeObserverSizeResponseRestrictionTarget
Experimental
RsaHashedImportParamsRsaHashedKeyGenParamsRsaOaepParamsRsaPssParamsRTCAudioSourceStatsRTCCertificateRTCCertificateStatsRTCCodecStatsRTCDataChannelRTCDataChannelEventRTCDataChannelStatsRTCDtlsTransportRTCDTMFSenderRTCDTMFToneChangeEventRTCEncodedAudioFrameRTCEncodedVideoFrameRTCErrorRTCErrorEventRTCIceCandidateRTCIceCandidatePairRTCIceCandidatePairStatsRTCIceCandidateStatsRTCIceParametersRTCIceTransportRTCIdentityAssertion
Experimental
RTCInboundRtpStreamStatsRTCOutboundRtpStreamStatsRTCPeerConnectionRTCPeerConnectionIceErrorEventRTCPeerConnectionIceEventRTCPeerConnectionStatsRTCRemoteInboundRtpStreamStatsRTCRemoteOutboundRtpStreamStatsRTCRtpReceiverRTCRtpScriptTransformRTCRtpScriptTransformerRTCRtpSenderRTCRtpTransceiverRTCSctpTransportRTCSessionDescriptionRTCStatsReportRTCTrackEventRTCTransformEventRTCTransportStatsRTCVideoSourceStatsSSchedulerScheduling
Experimental
ScreenScreenDetailed
Experimental
ScreenDetails
Experimental
ScreenOrientationScriptProcessorNode
Deprecated
ScrollTimeline
Experimental
SecurePaymentConfirmationRequestSecurityPolicyViolationEventSelectionSensorSensorErrorEventSerial
Experimental
SerialPort
Experimental
ServiceWorkerServiceWorkerContainerServiceWorkerGlobalScopeServiceWorkerRegistrationShadowRootSharedStorage
Experimental
SharedStorageOperation
Experimental
SharedStorageRunOperation
Experimental
SharedStorageSelectURLOperation
Experimental
SharedStorageWorklet
Experimental
SharedStorageWorkletGlobalScope
Experimental
SharedWorkerSharedWorkerGlobalScopeSnapEvent
Experimental
SourceBufferSourceBufferListSpeechGrammar
Non-standard

Deprecated
SpeechGrammarList
Experimental
SpeechRecognitionSpeechRecognitionAlternativeSpeechRecognitionErrorEventSpeechRecognitionEventSpeechRecognitionResultSpeechRecognitionResultListSpeechSynthesisSpeechSynthesisErrorEventSpeechSynthesisEventSpeechSynthesisUtteranceSpeechSynthesisVoiceStaticRangeStereoPannerNodeStorageStorageAccessHandleStorageEventStorageManagerStylePropertyMapStylePropertyMapReadOnlyStyleSheetStyleSheetListSubmitEventSubtleCryptoSVGAElementSVGAngleSVGAnimateColorElement
Deprecated
SVGAnimatedAngleSVGAnimatedBooleanSVGAnimatedEnumerationSVGAnimatedIntegerSVGAnimatedLengthSVGAnimatedLengthListSVGAnimatedNumberSVGAnimatedNumberListSVGAnimatedPreserveAspectRatioSVGAnimatedRectSVGAnimatedStringSVGAnimatedTransformListSVGAnimateElementSVGAnimateMotionElementSVGAnimateTransformElementSVGAnimationElementSVGCircleElementSVGClipPathElementSVGComponentTransferFunctionElementSVGDefsElementSVGDescElementSVGDiscardElement
Experimental
SVGElementSVGEllipseElementSVGFEBlendElementSVGFEColorMatrixElementSVGFEComponentTransferElementSVGFECompositeElementSVGFEConvolveMatrixElementSVGFEDiffuseLightingElementSVGFEDisplacementMapElementSVGFEDistantLightElementSVGFEDropShadowElementSVGFEFloodElementSVGFEFuncAElementSVGFEFuncBElementSVGFEFuncGElementSVGFEFuncRElementSVGFEGaussianBlurElementSVGFEImageElementSVGFEMergeElementSVGFEMergeNodeElementSVGFEMorphologyElementSVGFEOffsetElementSVGFEPointLightElementSVGFESpecularLightingElementSVGFESpotLightElementSVGFETileElementSVGFETurbulenceElementSVGFilterElementSVGForeignObjectElementSVGGElementSVGGeometryElementSVGGradientElementSVGGraphicsElementSVGImageElementSVGLengthSVGLengthListSVGLinearGradientElementSVGLineElementSVGMarkerElementSVGMaskElementSVGMetadataElementSVGMPathElementSVGNumberSVGNumberListSVGPathElementSVGPatternElementSVGPoint
Deprecated
SVGPointListSVGPolygonElementSVGPolylineElementSVGPreserveAspectRatioSVGRadialGradientElementSVGRectSVGRectElementSVGRenderingIntent
Deprecated
SVGScriptElementSVGSetElementSVGStopElementSVGStringListSVGStyleElementSVGSVGElementSVGSwitchElementSVGSymbolElementSVGTextContentElementSVGTextElementSVGTextPathElementSVGTextPositioningElementSVGTitleElementSVGTransformSVGTransformListSVGTSpanElementSVGUnitTypesSVGUseElementSVGViewElementSyncEventSyncManagerTTaskAttributionTiming
Experimental
TaskControllerTaskPriorityChangeEventTaskSignalTextTextDecoderTextDecoderStreamTextEncoderTextEncoderStreamTextEvent
Deprecated
TextFormat
Experimental
TextFormatUpdateEvent
Experimental
TextMetricsTextTrackTextTrackCueTextTrackCueListTextTrackListTextUpdateEvent
Experimental
TimeEventTimeRangesToggleEventTouchTouchEventTouchListTrackEventTransformStreamTransformStreamDefaultControllerTransitionEventTreeWalkerTrustedHTMLTrustedScriptTrustedScriptURLTrustedTypePolicyTrustedTypePolicyFactoryUUIEventURLURLPattern
Experimental
URLSearchParamsUSB
Experimental
USBAlternateInterface
Experimental
USBConfiguration
Experimental
USBConnectionEvent
Experimental
USBDevice
Experimental
USBEndpoint
Experimental
USBInterface
Experimental
USBInTransferResult
Experimental
USBIsochronousInTransferPacket
Experimental
USBIsochronousInTransferResult
Experimental
USBIsochronousOutTransferPacket
Experimental
USBIsochronousOutTransferResult
Experimental
USBOutTransferResult
Experimental
UserActivationVValidityStateVideoColorSpaceVideoDecoderVideoEncoderVideoFrameVideoPlaybackQualityVideoTrackVideoTrackListViewTimeline
Experimental
ViewTransitionVirtualKeyboard
Experimental
VisibilityStateEntry
Experimental
VisualViewportVRDisplay
Non-standard

Deprecated
VRDisplayCapabilities
Non-standard

Deprecated
VRDisplayEvent
Non-standard

Deprecated
VREyeParameters
Non-standard

Deprecated
VRFieldOfView
Non-standard

Deprecated
VRFrameData
Non-standard

Deprecated
VRLayerInit
Deprecated
VRPose
Non-standard

Deprecated
VRStageParameters
Non-standard

Deprecated
VTTCueVTTRegionWWakeLockWakeLockSentinelWaveShaperNodeWebGL2RenderingContextWebGLActiveInfoWebGLBufferWebGLContextEventWebGLFramebufferWebGLObject
Experimental
WebGLProgramWebGLQueryWebGLRenderbufferWebGLRenderingContextWebGLSamplerWebGLShaderWebGLShaderPrecisionFormatWebGLSyncWebGLTextureWebGLTransformFeedbackWebGLUniformLocationWebGLVertexArrayObjectWebSocketWebSocketStream
Experimental
WebTransportWebTransportBidirectionalStreamWebTransportDatagramDuplexStreamWebTransportErrorWebTransportReceiveStream
Experimental
WebTransportSendStream
Experimental
WGSLLanguageFeatures
Experimental
WheelEventWindowWindowClientWindowControlsOverlay
Experimental
WindowControlsOverlayGeometryChangeEvent
Experimental
WindowSharedStorage
Experimental
WorkerWorkerGlobalScopeWorkerLocationWorkerNavigatorWorkletWorkletGlobalScopeWorkletSharedStorage
Experimental
WritableStreamWritableStreamDefaultControllerWritableStreamDefaultWriterXXMLDocumentXMLHttpRequestXMLHttpRequestEventTargetXMLHttpRequestUploadXMLSerializerXPathEvaluatorXPathExpressionXPathResultXRAnchor
Experimental
XRAnchorSet
Experimental
XRBoundedReferenceSpace
Experimental
XRCompositionLayer
Experimental
XRCPUDepthInformation
Experimental
XRCubeLayer
Experimental
XRCylinderLayer
Experimental
XRDepthInformation
Experimental
XREquirectLayer
Experimental
XRFrame
Experimental
XRHandXRHitTestResult
Experimental
XRHitTestSource
Experimental
XRInputSourceXRInputSourceArray
Experimental
XRInputSourceEventXRInputSourcesChangeEventXRJointPoseXRJointSpaceXRLayer
Experimental
XRLayerEvent
Experimental
XRLightEstimate
Experimental
XRLightProbe
Experimental
XRMediaBinding
Experimental
XRPoseXRProjectionLayer
Experimental
XRQuadLayer
Experimental
XRRay
Experimental
XRReferenceSpaceXRReferenceSpaceEventXRRenderState
Experimental
XRRigidTransformXRSession
Experimental
XRSessionEventXRSpaceXRSubImage
Experimental
XRSystem
Experimental
XRTransientInputHitTestResult
Experimental
XRTransientInputHitTestSource
Experimental
XRView
Experimental
XRViewerPoseXRViewportXRWebGLBinding
Experimental
XRWebGLDepthInformation
Experimental
XRWebGLLayer
Experimental
XRWebGLSubImage
Experimental
XSLTProcessorSee also
Web API event reference
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 20, 2023 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nBrowser extensionsExtensions, or add-ons, can modify and enhance the capability of a browser. Extensions for Firefox are built using the WebExtensions API cross-browser technology.
The technology for extensions in Firefox is, to a large extent, compatible with the extension API supported by Chromium-based browsers (such as Google Chrome, Microsoft Edge, Opera, Vivaldi). In most cases, extensions written for Chromium-based browsers run in Firefox with just a few changes.Key resources
Guides

Whether you're just beginning or looking for more advanced advice, learn about how extensions work and use the WebExtensions API from our extensive range of tutorials and guides.

References

Get comprehensive details about the methods, properties, types, and events of the WebExtensions APIs and full details about the manifest keys.

Firefox workflow

Discover how to build and publish extensions for Firefox: get the lowdown on developer tools, publication and distribution, and porting on Extension Workshop.



Note:
If you have ideas or questions or need help, you can reach us on the community forum or in the Add-ons Room on Matrix.
Get startedDiscover what extensions can do before building your first extension. Learn about the anatomy of an extension and get an overview of the extension development and publication workflow, Firefox style. Explore a little deeper with a comprehensive selection of example extensions that you can run right in Firefox.ConceptsGet detailed information on the concept that underpin extensions from an overview of the JavaScript API, through content scripts, match patterns, working with files, internationalization, and content security policy, to more advanced subjects such as native messaging, using the devtools APIs, and native manifests.User interfaceDiscover all the user interface components you can use in your extensions, with coding examples and tips.How toFrom patterns you'll regularly use such as work with the Tabs API and adding a button to the toolbar to more advanced topics such as intercepting HTTP requests and working with contextual identities, you'll find a range of tutorials to get you started.Firefox workflowWhen you are ready to create your extension for Firefox or port your Chrome extension, head over to Extension Workshop. It has details on:

The Firefox workflow, such as temporarily installing extensions during development, debugging, request the right permissions, and more.
The web-ext developer tool.
Porting a Google Chrome extension, differences between desktop and Android, and more.
Publishing and distribution overview, promoting your extension, the extension lifecycle best practices, and more.
ReferenceJavaScript APIsGet comprehensive details about the methods, properties, types, and events for all the JavaScript APIs. There is also detailed information about the compatibility of each API with the major browsers. Most reference pages also include coding examples and links to the extension examples that use the API.Manifest keysGet full details about the manifest keys, including all their properties and settings.\n\nBrowser extensionsExtensions, or add-ons, can modify and enhance the capability of a browser. Extensions for Firefox are built using the WebExtensions API cross-browser technology.
The technology for extensions in Firefox is, to a large extent, compatible with the extension API supported by Chromium-based browsers (such as Google Chrome, Microsoft Edge, Opera, Vivaldi). In most cases, extensions written for Chromium-based browsers run in Firefox with just a few changes.Key resources
Guides

Whether you're just beginning or looking for more advanced advice, learn about how extensions work and use the WebExtensions API from our extensive range of tutorials and guides.

References

Get comprehensive details about the methods, properties, types, and events of the WebExtensions APIs and full details about the manifest keys.

Firefox workflow

Discover how to build and publish extensions for Firefox: get the lowdown on developer tools, publication and distribution, and porting on Extension Workshop.



Note:
If you have ideas or questions or need help, you can reach us on the community forum or in the Add-ons Room on Matrix.
Get startedDiscover what extensions can do before building your first extension. Learn about the anatomy of an extension and get an overview of the extension development and publication workflow, Firefox style. Explore a little deeper with a comprehensive selection of example extensions that you can run right in Firefox.ConceptsGet detailed information on the concept that underpin extensions from an overview of the JavaScript API, through content scripts, match patterns, working with files, internationalization, and content security policy, to more advanced subjects such as native messaging, using the devtools APIs, and native manifests.User interfaceDiscover all the user interface components you can use in your extensions, with coding examples and tips.How toFrom patterns you'll regularly use such as work with the Tabs API and adding a button to the toolbar to more advanced topics such as intercepting HTTP requests and working with contextual identities, you'll find a range of tutorials to get you started.Firefox workflowWhen you are ready to create your extension for Firefox or port your Chrome extension, head over to Extension Workshop. It has details on:

The Firefox workflow, such as temporarily installing extensions during development, debugging, request the right permissions, and more.
The web-ext developer tool.
Porting a Google Chrome extension, differences between desktop and Android, and more.
Publishing and distribution overview, promoting your extension, the extension lifecycle best practices, and more.
ReferenceJavaScript APIsGet comprehensive details about the methods, properties, types, and events for all the JavaScript APIs. There is also detailed information about the compatibility of each API with the major browsers. Most reference pages also include coding examples and links to the extension examples that use the API.Manifest keysGet full details about the manifest keys, including all their properties and settings.Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 22, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nBrowser extensionsExtensions, or add-ons, can modify and enhance the capability of a browser. Extensions for Firefox are built using the WebExtensions API cross-browser technology.
The technology for extensions in Firefox is, to a large extent, compatible with the extension API supported by Chromium-based browsers (such as Google Chrome, Microsoft Edge, Opera, Vivaldi). In most cases, extensions written for Chromium-based browsers run in Firefox with just a few changes.Key resources
Guides

Whether you're just beginning or looking for more advanced advice, learn about how extensions work and use the WebExtensions API from our extensive range of tutorials and guides.

References

Get comprehensive details about the methods, properties, types, and events of the WebExtensions APIs and full details about the manifest keys.

Firefox workflow

Discover how to build and publish extensions for Firefox: get the lowdown on developer tools, publication and distribution, and porting on Extension Workshop.



Note:
If you have ideas or questions or need help, you can reach us on the community forum or in the Add-ons Room on Matrix.
Get startedDiscover what extensions can do before building your first extension. Learn about the anatomy of an extension and get an overview of the extension development and publication workflow, Firefox style. Explore a little deeper with a comprehensive selection of example extensions that you can run right in Firefox.ConceptsGet detailed information on the concept that underpin extensions from an overview of the JavaScript API, through content scripts, match patterns, working with files, internationalization, and content security policy, to more advanced subjects such as native messaging, using the devtools APIs, and native manifests.User interfaceDiscover all the user interface components you can use in your extensions, with coding examples and tips.How toFrom patterns you'll regularly use such as work with the Tabs API and adding a button to the toolbar to more advanced topics such as intercepting HTTP requests and working with contextual identities, you'll find a range of tutorials to get you started.Firefox workflowWhen you are ready to create your extension for Firefox or port your Chrome extension, head over to Extension Workshop. It has details on:

The Firefox workflow, such as temporarily installing extensions during development, debugging, request the right permissions, and more.
The web-ext developer tool.
Porting a Google Chrome extension, differences between desktop and Android, and more.
Publishing and distribution overview, promoting your extension, the extension lifecycle best practices, and more.
ReferenceJavaScript APIsGet comprehensive details about the methods, properties, types, and events for all the JavaScript APIs. There is also detailed information about the compatibility of each API with the major browsers. Most reference pages also include coding examples and links to the extension examples that use the API.Manifest keysGet full details about the manifest keys, including all their properties and settings.Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 22, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nAccessibilityAccessibility (often abbreviated to A11y — as in, "a", then 11 characters, and then "y") in web development means enabling as many people as possible to use websites, even when those people's abilities are limited in some way.
For many people, technology makes things easier. For people with disabilities, technology makes things possible. Accessibility means developing content to be as accessible as possible, no matter an individual's physical and cognitive abilities and how they access the web.

The Web is fundamentally designed to work for all people, whatever their hardware, software, language, location, or ability.
When the Web meets this goal, it is accessible to people with a diverse range of hearing, movement, sight, and cognitive ability. 
– (W3C - Accessibility)
Accessibility guides
Accessibility information for web authors

This document lists guidelines and regulations, how-to's, and tools for checking and repairing accessibility problems with websites.

Personalization to help browse safely

This article discusses making web content accessible for those with vestibular disorders, and those who support them, by taking advantage of personalization and accessibility settings built into the operating systems.

Accessible web applications and widgets

Most JavaScript libraries offer a library of client-side widgets that mimic the behavior of familiar desktop interfaces.
While this results in a widget that looks like its desktop counterpart, there usually isn't enough semantic information in the markup to be usable by an assistive technology.
This document describes techniques to improve accessibility of such widgets.

Keyboard-navigable JavaScript widgets

Until now, web developers who wanted to make their styled <div> and <span> based widgets accessible have lacked proper techniques.
Keyboard accessibility is part of the minimum accessibility requirements, which a developer should be aware of.
This document describes techniques to make JavaScript widgets accessible with the keyboard.

Mobile accessibility checklist

This document provides a concise checklist of accessibility requirements for mobile app developers.

Understanding the Web Content Accessibility Guidelines (WCAG)

A set of articles that provide quick explanations to help you understand the steps that need to be taken to conform to the recommendations outlined in the Web Content Accessibility Guidelines (WCAG).

Cognitive accessibility

Cognitive accessibility covers accessibility considerations for people with cognition and learning disabilities.
This document introduces cognitive accessibility and improving accessibility of the web for people with cognitive and learning differences.

Accessibility and spatial patterns

This document describes visual patterns that can induce physical symptoms in people who have photosensitive epilepsy, vestibular disorders, or other perceptual issues.

Web Accessibility: Understanding Colors and Luminance

While understanding color, luminance, and saturation is important for design and readability for all sighted users, they are essential for those with reduced vision and color-deficient vision and those with specific neurological, cognitive, and other impairments.

Web accessibility for seizures and physical reactions

Some types of visual web content can induce seizures in people with certain brain disorders.
This article helps you understand the types of content that can be problematic and find tools and strategies to help you avoid them.

ARIA

This is a collection of articles to learn how to use Accessible Rich Internet Applications (ARIA) to make your HTML documents more accessible.

Tutorials for beginnersThe MDN Accessibility Learning Area contains modern, up-to-date tutorials covering the following accessibility essentials:

What is accessibility?

This article starts off the module with a good look at what accessibility actually is — this includes what groups of people we need to consider and why, what tools different people use to interact with the Web, and how we can make accessibility part of our web development workflow.

HTML: A good basis for accessibility

A great deal of web content can be made accessible just by making sure that the correct HTML elements are used for the correct purpose at all times. This article looks in detail at how HTML can be used to ensure maximum accessibility.

CSS and JavaScript accessibility best practices

CSS and JavaScript, when used properly, also have the potential to allow for accessible web experiences. They can significantly harm accessibility if misused. This article outlines some CSS and JavaScript best practices that should be considered to ensure that even complex content is as accessible as possible.

WAI-ARIA basics

Following on from the previous article, sometimes making complex UI controls that involve unsemantic HTML and dynamic JavaScript-updated content can be difficult. WAI-ARIA is a technology that can help with such problems by adding in further semantics that browsers and assistive technologies can recognize and let users know what is going on. Here we'll show how to use it at a basic level to improve accessibility.

Accessible multimedia

Another category of content that can create accessibility problems is multimedia — video, audio, and image content need to be given proper textual alternatives so that they can be understood by assistive technologies and their users. This article shows how.

Mobile accessibility

With web access on mobile devices being so popular and popular platforms such as iOS and Android having fully-fledged accessibility tools, it is important to consider the accessibility of your web content on these platforms. This article looks at mobile-specific accessibility considerations.

References
ARIA reference

Reference documentation for Accessible Rich Internet Applications (ARIA) attributes and roles.

See also
Developer guides
WAI Interest Group\n\nAccessibilityAccessibility (often abbreviated to A11y — as in, "a", then 11 characters, and then "y") in web development means enabling as many people as possible to use websites, even when those people's abilities are limited in some way.
For many people, technology makes things easier. For people with disabilities, technology makes things possible. Accessibility means developing content to be as accessible as possible, no matter an individual's physical and cognitive abilities and how they access the web.

The Web is fundamentally designed to work for all people, whatever their hardware, software, language, location, or ability.
When the Web meets this goal, it is accessible to people with a diverse range of hearing, movement, sight, and cognitive ability. 
– (W3C - Accessibility)
Accessibility guides
Accessibility information for web authors

This document lists guidelines and regulations, how-to's, and tools for checking and repairing accessibility problems with websites.

Personalization to help browse safely

This article discusses making web content accessible for those with vestibular disorders, and those who support them, by taking advantage of personalization and accessibility settings built into the operating systems.

Accessible web applications and widgets

Most JavaScript libraries offer a library of client-side widgets that mimic the behavior of familiar desktop interfaces.
While this results in a widget that looks like its desktop counterpart, there usually isn't enough semantic information in the markup to be usable by an assistive technology.
This document describes techniques to improve accessibility of such widgets.

Keyboard-navigable JavaScript widgets

Until now, web developers who wanted to make their styled <div> and <span> based widgets accessible have lacked proper techniques.
Keyboard accessibility is part of the minimum accessibility requirements, which a developer should be aware of.
This document describes techniques to make JavaScript widgets accessible with the keyboard.

Mobile accessibility checklist

This document provides a concise checklist of accessibility requirements for mobile app developers.

Understanding the Web Content Accessibility Guidelines (WCAG)

A set of articles that provide quick explanations to help you understand the steps that need to be taken to conform to the recommendations outlined in the Web Content Accessibility Guidelines (WCAG).

Cognitive accessibility

Cognitive accessibility covers accessibility considerations for people with cognition and learning disabilities.
This document introduces cognitive accessibility and improving accessibility of the web for people with cognitive and learning differences.

Accessibility and spatial patterns

This document describes visual patterns that can induce physical symptoms in people who have photosensitive epilepsy, vestibular disorders, or other perceptual issues.

Web Accessibility: Understanding Colors and Luminance

While understanding color, luminance, and saturation is important for design and readability for all sighted users, they are essential for those with reduced vision and color-deficient vision and those with specific neurological, cognitive, and other impairments.

Web accessibility for seizures and physical reactions

Some types of visual web content can induce seizures in people with certain brain disorders.
This article helps you understand the types of content that can be problematic and find tools and strategies to help you avoid them.

ARIA

This is a collection of articles to learn how to use Accessible Rich Internet Applications (ARIA) to make your HTML documents more accessible.

Tutorials for beginnersThe MDN Accessibility Learning Area contains modern, up-to-date tutorials covering the following accessibility essentials:

What is accessibility?

This article starts off the module with a good look at what accessibility actually is — this includes what groups of people we need to consider and why, what tools different people use to interact with the Web, and how we can make accessibility part of our web development workflow.

HTML: A good basis for accessibility

A great deal of web content can be made accessible just by making sure that the correct HTML elements are used for the correct purpose at all times. This article looks in detail at how HTML can be used to ensure maximum accessibility.

CSS and JavaScript accessibility best practices

CSS and JavaScript, when used properly, also have the potential to allow for accessible web experiences. They can significantly harm accessibility if misused. This article outlines some CSS and JavaScript best practices that should be considered to ensure that even complex content is as accessible as possible.

WAI-ARIA basics

Following on from the previous article, sometimes making complex UI controls that involve unsemantic HTML and dynamic JavaScript-updated content can be difficult. WAI-ARIA is a technology that can help with such problems by adding in further semantics that browsers and assistive technologies can recognize and let users know what is going on. Here we'll show how to use it at a basic level to improve accessibility.

Accessible multimedia

Another category of content that can create accessibility problems is multimedia — video, audio, and image content need to be given proper textual alternatives so that they can be understood by assistive technologies and their users. This article shows how.

Mobile accessibility

With web access on mobile devices being so popular and popular platforms such as iOS and Android having fully-fledged accessibility tools, it is important to consider the accessibility of your web content on these platforms. This article looks at mobile-specific accessibility considerations.

References
ARIA reference

Reference documentation for Accessible Rich Internet Applications (ARIA) attributes and roles.

See also
Developer guides
WAI Interest Group
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nAccessibilityAccessibility (often abbreviated to A11y — as in, "a", then 11 characters, and then "y") in web development means enabling as many people as possible to use websites, even when those people's abilities are limited in some way.
For many people, technology makes things easier. For people with disabilities, technology makes things possible. Accessibility means developing content to be as accessible as possible, no matter an individual's physical and cognitive abilities and how they access the web.

The Web is fundamentally designed to work for all people, whatever their hardware, software, language, location, or ability.
When the Web meets this goal, it is accessible to people with a diverse range of hearing, movement, sight, and cognitive ability. 
– (W3C - Accessibility)
Accessibility guides
Accessibility information for web authors

This document lists guidelines and regulations, how-to's, and tools for checking and repairing accessibility problems with websites.

Personalization to help browse safely

This article discusses making web content accessible for those with vestibular disorders, and those who support them, by taking advantage of personalization and accessibility settings built into the operating systems.

Accessible web applications and widgets

Most JavaScript libraries offer a library of client-side widgets that mimic the behavior of familiar desktop interfaces.
While this results in a widget that looks like its desktop counterpart, there usually isn't enough semantic information in the markup to be usable by an assistive technology.
This document describes techniques to improve accessibility of such widgets.

Keyboard-navigable JavaScript widgets

Until now, web developers who wanted to make their styled <div> and <span> based widgets accessible have lacked proper techniques.
Keyboard accessibility is part of the minimum accessibility requirements, which a developer should be aware of.
This document describes techniques to make JavaScript widgets accessible with the keyboard.

Mobile accessibility checklist

This document provides a concise checklist of accessibility requirements for mobile app developers.

Understanding the Web Content Accessibility Guidelines (WCAG)

A set of articles that provide quick explanations to help you understand the steps that need to be taken to conform to the recommendations outlined in the Web Content Accessibility Guidelines (WCAG).

Cognitive accessibility

Cognitive accessibility covers accessibility considerations for people with cognition and learning disabilities.
This document introduces cognitive accessibility and improving accessibility of the web for people with cognitive and learning differences.

Accessibility and spatial patterns

This document describes visual patterns that can induce physical symptoms in people who have photosensitive epilepsy, vestibular disorders, or other perceptual issues.

Web Accessibility: Understanding Colors and Luminance

While understanding color, luminance, and saturation is important for design and readability for all sighted users, they are essential for those with reduced vision and color-deficient vision and those with specific neurological, cognitive, and other impairments.

Web accessibility for seizures and physical reactions

Some types of visual web content can induce seizures in people with certain brain disorders.
This article helps you understand the types of content that can be problematic and find tools and strategies to help you avoid them.

ARIA

This is a collection of articles to learn how to use Accessible Rich Internet Applications (ARIA) to make your HTML documents more accessible.

Tutorials for beginnersThe MDN Accessibility Learning Area contains modern, up-to-date tutorials covering the following accessibility essentials:

What is accessibility?

This article starts off the module with a good look at what accessibility actually is — this includes what groups of people we need to consider and why, what tools different people use to interact with the Web, and how we can make accessibility part of our web development workflow.

HTML: A good basis for accessibility

A great deal of web content can be made accessible just by making sure that the correct HTML elements are used for the correct purpose at all times. This article looks in detail at how HTML can be used to ensure maximum accessibility.

CSS and JavaScript accessibility best practices

CSS and JavaScript, when used properly, also have the potential to allow for accessible web experiences. They can significantly harm accessibility if misused. This article outlines some CSS and JavaScript best practices that should be considered to ensure that even complex content is as accessible as possible.

WAI-ARIA basics

Following on from the previous article, sometimes making complex UI controls that involve unsemantic HTML and dynamic JavaScript-updated content can be difficult. WAI-ARIA is a technology that can help with such problems by adding in further semantics that browsers and assistive technologies can recognize and let users know what is going on. Here we'll show how to use it at a basic level to improve accessibility.

Accessible multimedia

Another category of content that can create accessibility problems is multimedia — video, audio, and image content need to be given proper textual alternatives so that they can be understood by assistive technologies and their users. This article shows how.

Mobile accessibility

With web access on mobile devices being so popular and popular platforms such as iOS and Android having fully-fledged accessibility tools, it is important to consider the accessibility of your web content on these platforms. This article looks at mobile-specific accessibility considerations.

References
ARIA reference

Reference documentation for Accessible Rich Internet Applications (ARIA) attributes and roles.

See also
Developer guides
WAI Interest Group
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nLearn web developmentThe essential skillset for new front-end developersWelcome to MDN Learning Web Development (also known as Learn). This resource provides a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer, along with challenges and further recommended resources.About Learn web development

Teaches the essential skills and knowledge every front-end developer needs for career success and industry relevance, as defined in the MDN Curriculum.


Created by the MDN community and refined with insights from students, educators, and developers from the broader web community.


Designed to take you from "beginner" to "comfortable" (not "beginner" to "expert"), giving you enough knowledge to use more advanced resources (such as the rest of MDN).



Note:
Last updated: December 2024 (see changelog).
Don't know where to get started?
Never coded before?

Our Getting started modules provide setup tutorials and essential concepts and background information for complete beginners. You should start here if you are a complete beginner (i.e., you've not installed a code editor or written any code yet).

Want to master the essentials?

Our Core modules provide a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer.

Beyond the basics?

Our Extension modules cover useful additional skills to learn as you start to expand your knowledge and develop specialisms. Go onto these after you finish our Core.

Working at a school?

Use our modules to guide your teaching, check out our Educators page for more ideas, or enroll your students in Scrimba's Frontend Developer Career PathMDN learning partner.

Getting our code examplesThe code examples you'll encounter in the Learning Area are all available on GitHub:

The easiest way to get them is to download a ZIP of the latest main code branch.
If you are familiar with Git and GitHub, you could also choose to clone the repository.
Contact usIf you want to get in touch with us about anything, use the communication channels. We'd love to hear from you about anything you think is wrong or missing on the site, requests for new learning topics, requests for help with items you don't understand, or any other questions or concerns.
If you're interested in helping develop/improve the content, take a look at how you can help and get in touch! We are more than happy to talk to you, whether you are a learner, teacher, experienced web developer, or someone else interested in helping to improve the learning experience.See also
The Frontend Developer Career Path MDN learning partner

Scrimba's Frontend Developer Career Path teaches all you need to know to be a competent front-end web developer, with fun interactive lessons and challenges, knowledgeable teachers, and a supportive community. Go from zero to landing your first front-end job! Many of the course components are available as standalone free versions.

Codecademy

A great interactive site for learning programming languages from scratch.

freeCodeCamp.org

Interactive site with tutorials and projects to learn web development.

Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.\n\nLearn web developmentThe essential skillset for new front-end developersWelcome to MDN Learning Web Development (also known as Learn). This resource provides a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer, along with challenges and further recommended resources.About Learn web development

Teaches the essential skills and knowledge every front-end developer needs for career success and industry relevance, as defined in the MDN Curriculum.


Created by the MDN community and refined with insights from students, educators, and developers from the broader web community.


Designed to take you from "beginner" to "comfortable" (not "beginner" to "expert"), giving you enough knowledge to use more advanced resources (such as the rest of MDN).



Note:
Last updated: December 2024 (see changelog).
Don't know where to get started?
Never coded before?

Our Getting started modules provide setup tutorials and essential concepts and background information for complete beginners. You should start here if you are a complete beginner (i.e., you've not installed a code editor or written any code yet).

Want to master the essentials?

Our Core modules provide a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer.

Beyond the basics?

Our Extension modules cover useful additional skills to learn as you start to expand your knowledge and develop specialisms. Go onto these after you finish our Core.

Working at a school?

Use our modules to guide your teaching, check out our Educators page for more ideas, or enroll your students in Scrimba's Frontend Developer Career PathMDN learning partner.

Getting our code examplesThe code examples you'll encounter in the Learning Area are all available on GitHub:

The easiest way to get them is to download a ZIP of the latest main code branch.
If you are familiar with Git and GitHub, you could also choose to clone the repository.
Contact usIf you want to get in touch with us about anything, use the communication channels. We'd love to hear from you about anything you think is wrong or missing on the site, requests for new learning topics, requests for help with items you don't understand, or any other questions or concerns.
If you're interested in helping develop/improve the content, take a look at how you can help and get in touch! We are more than happy to talk to you, whether you are a learner, teacher, experienced web developer, or someone else interested in helping to improve the learning experience.See also
The Frontend Developer Career Path MDN learning partner

Scrimba's Frontend Developer Career Path teaches all you need to know to be a competent front-end web developer, with fun interactive lessons and challenges, knowledgeable teachers, and a supportive community. Go from zero to landing your first front-end job! Many of the course components are available as standalone free versions.

Codecademy

A great interactive site for learning programming languages from scratch.

freeCodeCamp.org

Interactive site with tutorials and projects to learn web development.

Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 15, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nLearn web developmentThe essential skillset for new front-end developersWelcome to MDN Learning Web Development (also known as Learn). This resource provides a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer, along with challenges and further recommended resources.About Learn web development

Teaches the essential skills and knowledge every front-end developer needs for career success and industry relevance, as defined in the MDN Curriculum.


Created by the MDN community and refined with insights from students, educators, and developers from the broader web community.


Designed to take you from "beginner" to "comfortable" (not "beginner" to "expert"), giving you enough knowledge to use more advanced resources (such as the rest of MDN).



Note:
Last updated: December 2024 (see changelog).
Don't know where to get started?
Never coded before?

Our Getting started modules provide setup tutorials and essential concepts and background information for complete beginners. You should start here if you are a complete beginner (i.e., you've not installed a code editor or written any code yet).

Want to master the essentials?

Our Core modules provide a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer.

Beyond the basics?

Our Extension modules cover useful additional skills to learn as you start to expand your knowledge and develop specialisms. Go onto these after you finish our Core.

Working at a school?

Use our modules to guide your teaching, check out our Educators page for more ideas, or enroll your students in Scrimba's Frontend Developer Career PathMDN learning partner.

Getting our code examplesThe code examples you'll encounter in the Learning Area are all available on GitHub:

The easiest way to get them is to download a ZIP of the latest main code branch.
If you are familiar with Git and GitHub, you could also choose to clone the repository.
Contact usIf you want to get in touch with us about anything, use the communication channels. We'd love to hear from you about anything you think is wrong or missing on the site, requests for new learning topics, requests for help with items you don't understand, or any other questions or concerns.
If you're interested in helping develop/improve the content, take a look at how you can help and get in touch! We are more than happy to talk to you, whether you are a learner, teacher, experienced web developer, or someone else interested in helping to improve the learning experience.See also
The Frontend Developer Career Path MDN learning partner

Scrimba's Frontend Developer Career Path teaches all you need to know to be a competent front-end web developer, with fun interactive lessons and challenges, knowledgeable teachers, and a supportive community. Go from zero to landing your first front-end job! Many of the course components are available as standalone free versions.

Codecademy

A great interactive site for learning programming languages from scratch.

freeCodeCamp.org

Interactive site with tutorials and projects to learn web development.

Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 15, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nStructuring content with HTML Overview: Core learning modules Next  
HTML is the technology that defines the content and structure of any website. Written properly, it should also define the semantics (meaning) of the content in a machine-readable way, which is vital for accessibility, search engine optimization, and making use of the built-in features browsers provide for content to work optimally. This module covers the basics of the language, before looking at key areas such as document structure, links, lists, images, forms, and more.PrerequisitesBefore starting this module, you don't need any previous HTML knowledge, but you should have at least basic familiarity with using computers and using the web passively (i.e., just looking at it and consuming content). You should have a basic work environment set up (as detailed in Installing basic software), and understand how to create and manage files (as detailed in Dealing with files). Both are parts of our Getting started with the web complete beginner's module.

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
Basic HTML syntax

Covers the absolute basics of HTML, to get you started — we define elements, attributes, and other important terms, and show where they fit in the language. We also show how a typical HTML page is structured and how an HTML element is structured, and explain other important basic language features. Along the way, we'll play with some HTML to get you interested!

What's in the head? Web page metadata

The head of an HTML document is the part that is not displayed in the web browser when the page is loaded. It contains metadata information such as the page <title>, links to CSS (if you want to style your HTML content with CSS), links to custom favicons, and metadata (data about the HTML, such as who wrote it, and important keywords that describe the document).

Headings and paragraphs

One of HTML's main jobs is to give text structure so that a browser can display an HTML document the way its developer intends. This article explains how HTML can be used to provide fundamental page structure by defining headings and paragraphs.

Emphasis and importance

The previous article looked at why semantics are important in HTML, and focused on headings and paragraphs. This article continues on the theme of semantics, looking at HTML elements that apply emphasis and importance to text (parallel to italics and bold text in print media).

Lists

Lists are everywhere in life—from your shopping list to the list of directions you subconsciously follow to get to your house every day, to the lists of instructions you are following in these tutorials! It may not surprise you that HTML has a convenient set of elements that allows us to define different types of list. On the web, we have three types of lists: unordered, ordered, and description lists. This lesson shows you how to use the different types.

Structuring documents

In addition to defining individual parts of your page (such as "a paragraph" or "an image"), HTML also boasts a number of block level elements used to define areas of your website (such as "the header", "the navigation menu", "the main content column"). This article looks into how to plan a basic website structure, and write the HTML to represent this structure.

Advanced text features

There are many other elements in HTML for defining text semantics, which we didn't get to in the Emphasis and importance article. The elements described in this article are less known, but still useful to know about (and this is still not a complete list by any means). Here you'll learn about marking up quotations, computer code and other related text, subscript and superscript, contact information, and more.

Creating links

Links (also known as hyperlinks) are really important — they are what makes the Web a web. This article shows the syntax required to make a link, and discusses link best practices.

Marking up a letter Challenge

We all learn to write a letter sooner or later; it is also a useful example to test our text formatting skills. In this challenge, you'll have a letter to mark up as a test for your HTML text formatting skills, as well as hyperlinks and proper use of the HTML <head> element.

Structuring a page of content Challenge

Structuring a page of content ready for laying it out using CSS is a very important skill to master, so in this challenge you'll be tested on your ability to think about how a page might end up looking, and choose appropriate structural semantics to build a layout on top of.

HTML images

In the beginning, the web was just text, and it was really quite boring. Fortunately, it wasn't too long before the ability to embed images (and other more interesting types of content) inside web pages was added. In this article we'll look at how to use the <img> element in depth, including the basics, annotating it with captions using <figure>, and detailing how it relates to CSS background images.

HTML video and audio

Now that we are comfortable with adding simple images to a webpage, the next step is to start adding video and audio players to your HTML documents! In this article we'll look at doing just that with the <video> and <audio> elements; we'll then finish off by looking at how to add captions/subtitles to your videos.

Mozilla splash page Challenge

In this challenge, we'll test your knowledge of some of the techniques discussed in the last couple of lessons, getting you to add some images and video to a funky splash page all about Mozilla!

HTML table basics

This article gets you started with HTML tables, covering the very basics such as rows, cells, headings, making cells span multiple columns and rows, and how to group together all the cells in a column for styling purposes.

HTML table accessibility

In this article we look at more HTML table accessibility features such as captions/summaries, grouping your rows into table head, body and footer sections, and scoping columns and rows.

Structuring a planet data table Challenge

In this challenge, we provide you with some data on the planets in our solar system. Your job is to structure it into an accessible HTML table.

Forms and buttons in HTML

HTML forms and buttons are powerful tools for interacting with users — most commonly they are used for collecting data from users or allowing them to control a user interface. In this article we provide an introduction to the basics of forms and buttons.

Debugging HTML

Writing HTML is fine, but what if something goes wrong, and you can't work out where the error in the code is? This article will introduce you to some tools that can help you find and fix errors in HTML.

Test your skills: HTML

This page lists HTML tests you can try so you can verify if you've understood the content in this module.

Additional tutorialsThese tutorials are not part of the learning pathway, but they are interesting nonetheless — you should consider these as stretch goals, to optionally study when you are done with the main Core articles.

Including vector graphics in HTML

Vector graphics are very useful in many circumstances — they have small file sizes and are highly scalable, so they don't pixelate when zoomed in or blown up to a large size. In this article we'll show you how to include one in your webpage.

From object to iframe — general embedding technologies

Developers commonly think of embedding media such as images, video and audio into web pages. In this article we take somewhat of a sideways step, looking at some elements that allow you to embed a wide variety of content types into your webpages: the <iframe>, <embed> and <object> elements. <iframe>s are for embedding other web pages, and the other two allow you to embed external resources such as PDF files.

See also
Learn HTML and CSS, Scrimba MDN learning partner

Scrimba's Learn HTML and CSS course teaches you HTML and CSS through building and deploying five awesome projects, with fun interactive lessons and challenges taught by knowledgeable teachers.

Learn HTML, Codecademy

Another useful resource for learning HTML basics.

The basics of semantic HTML, Scrimba MDN learning partner

This interactive lesson provides a useful description of HTML, with particular emphasis on why the semantic aspect of it is important.


 Overview: Core learning modules Next\n\nStructuring content with HTML Overview: Core learning modules Next  
HTML is the technology that defines the content and structure of any website. Written properly, it should also define the semantics (meaning) of the content in a machine-readable way, which is vital for accessibility, search engine optimization, and making use of the built-in features browsers provide for content to work optimally. This module covers the basics of the language, before looking at key areas such as document structure, links, lists, images, forms, and more.PrerequisitesBefore starting this module, you don't need any previous HTML knowledge, but you should have at least basic familiarity with using computers and using the web passively (i.e., just looking at it and consuming content). You should have a basic work environment set up (as detailed in Installing basic software), and understand how to create and manage files (as detailed in Dealing with files). Both are parts of our Getting started with the web complete beginner's module.

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
Basic HTML syntax

Covers the absolute basics of HTML, to get you started — we define elements, attributes, and other important terms, and show where they fit in the language. We also show how a typical HTML page is structured and how an HTML element is structured, and explain other important basic language features. Along the way, we'll play with some HTML to get you interested!

What's in the head? Web page metadata

The head of an HTML document is the part that is not displayed in the web browser when the page is loaded. It contains metadata information such as the page <title>, links to CSS (if you want to style your HTML content with CSS), links to custom favicons, and metadata (data about the HTML, such as who wrote it, and important keywords that describe the document).

Headings and paragraphs

One of HTML's main jobs is to give text structure so that a browser can display an HTML document the way its developer intends. This article explains how HTML can be used to provide fundamental page structure by defining headings and paragraphs.

Emphasis and importance

The previous article looked at why semantics are important in HTML, and focused on headings and paragraphs. This article continues on the theme of semantics, looking at HTML elements that apply emphasis and importance to text (parallel to italics and bold text in print media).

Lists

Lists are everywhere in life—from your shopping list to the list of directions you subconsciously follow to get to your house every day, to the lists of instructions you are following in these tutorials! It may not surprise you that HTML has a convenient set of elements that allows us to define different types of list. On the web, we have three types of lists: unordered, ordered, and description lists. This lesson shows you how to use the different types.

Structuring documents

In addition to defining individual parts of your page (such as "a paragraph" or "an image"), HTML also boasts a number of block level elements used to define areas of your website (such as "the header", "the navigation menu", "the main content column"). This article looks into how to plan a basic website structure, and write the HTML to represent this structure.

Advanced text features

There are many other elements in HTML for defining text semantics, which we didn't get to in the Emphasis and importance article. The elements described in this article are less known, but still useful to know about (and this is still not a complete list by any means). Here you'll learn about marking up quotations, computer code and other related text, subscript and superscript, contact information, and more.

Creating links

Links (also known as hyperlinks) are really important — they are what makes the Web a web. This article shows the syntax required to make a link, and discusses link best practices.

Marking up a letter Challenge

We all learn to write a letter sooner or later; it is also a useful example to test our text formatting skills. In this challenge, you'll have a letter to mark up as a test for your HTML text formatting skills, as well as hyperlinks and proper use of the HTML <head> element.

Structuring a page of content Challenge

Structuring a page of content ready for laying it out using CSS is a very important skill to master, so in this challenge you'll be tested on your ability to think about how a page might end up looking, and choose appropriate structural semantics to build a layout on top of.

HTML images

In the beginning, the web was just text, and it was really quite boring. Fortunately, it wasn't too long before the ability to embed images (and other more interesting types of content) inside web pages was added. In this article we'll look at how to use the <img> element in depth, including the basics, annotating it with captions using <figure>, and detailing how it relates to CSS background images.

HTML video and audio

Now that we are comfortable with adding simple images to a webpage, the next step is to start adding video and audio players to your HTML documents! In this article we'll look at doing just that with the <video> and <audio> elements; we'll then finish off by looking at how to add captions/subtitles to your videos.

Mozilla splash page Challenge

In this challenge, we'll test your knowledge of some of the techniques discussed in the last couple of lessons, getting you to add some images and video to a funky splash page all about Mozilla!

HTML table basics

This article gets you started with HTML tables, covering the very basics such as rows, cells, headings, making cells span multiple columns and rows, and how to group together all the cells in a column for styling purposes.

HTML table accessibility

In this article we look at more HTML table accessibility features such as captions/summaries, grouping your rows into table head, body and footer sections, and scoping columns and rows.

Structuring a planet data table Challenge

In this challenge, we provide you with some data on the planets in our solar system. Your job is to structure it into an accessible HTML table.

Forms and buttons in HTML

HTML forms and buttons are powerful tools for interacting with users — most commonly they are used for collecting data from users or allowing them to control a user interface. In this article we provide an introduction to the basics of forms and buttons.

Debugging HTML

Writing HTML is fine, but what if something goes wrong, and you can't work out where the error in the code is? This article will introduce you to some tools that can help you find and fix errors in HTML.

Test your skills: HTML

This page lists HTML tests you can try so you can verify if you've understood the content in this module.

Additional tutorialsThese tutorials are not part of the learning pathway, but they are interesting nonetheless — you should consider these as stretch goals, to optionally study when you are done with the main Core articles.

Including vector graphics in HTML

Vector graphics are very useful in many circumstances — they have small file sizes and are highly scalable, so they don't pixelate when zoomed in or blown up to a large size. In this article we'll show you how to include one in your webpage.

From object to iframe — general embedding technologies

Developers commonly think of embedding media such as images, video and audio into web pages. In this article we take somewhat of a sideways step, looking at some elements that allow you to embed a wide variety of content types into your webpages: the <iframe>, <embed> and <object> elements. <iframe>s are for embedding other web pages, and the other two allow you to embed external resources such as PDF files.

See also
Learn HTML and CSS, Scrimba MDN learning partner

Scrimba's Learn HTML and CSS course teaches you HTML and CSS through building and deploying five awesome projects, with fun interactive lessons and challenges taught by knowledgeable teachers.

Learn HTML, Codecademy

Another useful resource for learning HTML basics.

The basics of semantic HTML, Scrimba MDN learning partner

This interactive lesson provides a useful description of HTML, with particular emphasis on why the semantic aspect of it is important.


 Overview: Core learning modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 15, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nStructuring content with HTML Overview: Core learning modules Next  
HTML is the technology that defines the content and structure of any website. Written properly, it should also define the semantics (meaning) of the content in a machine-readable way, which is vital for accessibility, search engine optimization, and making use of the built-in features browsers provide for content to work optimally. This module covers the basics of the language, before looking at key areas such as document structure, links, lists, images, forms, and more.PrerequisitesBefore starting this module, you don't need any previous HTML knowledge, but you should have at least basic familiarity with using computers and using the web passively (i.e., just looking at it and consuming content). You should have a basic work environment set up (as detailed in Installing basic software), and understand how to create and manage files (as detailed in Dealing with files). Both are parts of our Getting started with the web complete beginner's module.

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
Basic HTML syntax

Covers the absolute basics of HTML, to get you started — we define elements, attributes, and other important terms, and show where they fit in the language. We also show how a typical HTML page is structured and how an HTML element is structured, and explain other important basic language features. Along the way, we'll play with some HTML to get you interested!

What's in the head? Web page metadata

The head of an HTML document is the part that is not displayed in the web browser when the page is loaded. It contains metadata information such as the page <title>, links to CSS (if you want to style your HTML content with CSS), links to custom favicons, and metadata (data about the HTML, such as who wrote it, and important keywords that describe the document).

Headings and paragraphs

One of HTML's main jobs is to give text structure so that a browser can display an HTML document the way its developer intends. This article explains how HTML can be used to provide fundamental page structure by defining headings and paragraphs.

Emphasis and importance

The previous article looked at why semantics are important in HTML, and focused on headings and paragraphs. This article continues on the theme of semantics, looking at HTML elements that apply emphasis and importance to text (parallel to italics and bold text in print media).

Lists

Lists are everywhere in life—from your shopping list to the list of directions you subconsciously follow to get to your house every day, to the lists of instructions you are following in these tutorials! It may not surprise you that HTML has a convenient set of elements that allows us to define different types of list. On the web, we have three types of lists: unordered, ordered, and description lists. This lesson shows you how to use the different types.

Structuring documents

In addition to defining individual parts of your page (such as "a paragraph" or "an image"), HTML also boasts a number of block level elements used to define areas of your website (such as "the header", "the navigation menu", "the main content column"). This article looks into how to plan a basic website structure, and write the HTML to represent this structure.

Advanced text features

There are many other elements in HTML for defining text semantics, which we didn't get to in the Emphasis and importance article. The elements described in this article are less known, but still useful to know about (and this is still not a complete list by any means). Here you'll learn about marking up quotations, computer code and other related text, subscript and superscript, contact information, and more.

Creating links

Links (also known as hyperlinks) are really important — they are what makes the Web a web. This article shows the syntax required to make a link, and discusses link best practices.

Marking up a letter Challenge

We all learn to write a letter sooner or later; it is also a useful example to test our text formatting skills. In this challenge, you'll have a letter to mark up as a test for your HTML text formatting skills, as well as hyperlinks and proper use of the HTML <head> element.

Structuring a page of content Challenge

Structuring a page of content ready for laying it out using CSS is a very important skill to master, so in this challenge you'll be tested on your ability to think about how a page might end up looking, and choose appropriate structural semantics to build a layout on top of.

HTML images

In the beginning, the web was just text, and it was really quite boring. Fortunately, it wasn't too long before the ability to embed images (and other more interesting types of content) inside web pages was added. In this article we'll look at how to use the <img> element in depth, including the basics, annotating it with captions using <figure>, and detailing how it relates to CSS background images.

HTML video and audio

Now that we are comfortable with adding simple images to a webpage, the next step is to start adding video and audio players to your HTML documents! In this article we'll look at doing just that with the <video> and <audio> elements; we'll then finish off by looking at how to add captions/subtitles to your videos.

Mozilla splash page Challenge

In this challenge, we'll test your knowledge of some of the techniques discussed in the last couple of lessons, getting you to add some images and video to a funky splash page all about Mozilla!

HTML table basics

This article gets you started with HTML tables, covering the very basics such as rows, cells, headings, making cells span multiple columns and rows, and how to group together all the cells in a column for styling purposes.

HTML table accessibility

In this article we look at more HTML table accessibility features such as captions/summaries, grouping your rows into table head, body and footer sections, and scoping columns and rows.

Structuring a planet data table Challenge

In this challenge, we provide you with some data on the planets in our solar system. Your job is to structure it into an accessible HTML table.

Forms and buttons in HTML

HTML forms and buttons are powerful tools for interacting with users — most commonly they are used for collecting data from users or allowing them to control a user interface. In this article we provide an introduction to the basics of forms and buttons.

Debugging HTML

Writing HTML is fine, but what if something goes wrong, and you can't work out where the error in the code is? This article will introduce you to some tools that can help you find and fix errors in HTML.

Test your skills: HTML

This page lists HTML tests you can try so you can verify if you've understood the content in this module.

Additional tutorialsThese tutorials are not part of the learning pathway, but they are interesting nonetheless — you should consider these as stretch goals, to optionally study when you are done with the main Core articles.

Including vector graphics in HTML

Vector graphics are very useful in many circumstances — they have small file sizes and are highly scalable, so they don't pixelate when zoomed in or blown up to a large size. In this article we'll show you how to include one in your webpage.

From object to iframe — general embedding technologies

Developers commonly think of embedding media such as images, video and audio into web pages. In this article we take somewhat of a sideways step, looking at some elements that allow you to embed a wide variety of content types into your webpages: the <iframe>, <embed> and <object> elements. <iframe>s are for embedding other web pages, and the other two allow you to embed external resources such as PDF files.

See also
Learn HTML and CSS, Scrimba MDN learning partner

Scrimba's Learn HTML and CSS course teaches you HTML and CSS through building and deploying five awesome projects, with fun interactive lessons and challenges taught by knowledgeable teachers.

Learn HTML, Codecademy

Another useful resource for learning HTML basics.

The basics of semantic HTML, Scrimba MDN learning partner

This interactive lesson provides a useful description of HTML, with particular emphasis on why the semantic aspect of it is important.


 Overview: Core learning modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 15, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nCSS styling basics Overview: Core learning modules Next  
CSS (Cascading Style Sheets) is used to style and layout web pages — for example, to alter the font, color, size, and spacing of your content, split it into multiple columns, or add animations and other decorative features. This module provides all the CSS fundamentals you'll need for now, including syntax, features, and techniques.PrerequisitesBefore starting this module, you should have a basic work environment set up (as detailed in Installing basic software), and understand how to create and manage files (as detailed in Dealing with files). You should also be familiar with HTML (work through our Structuring content with HTML module if not).

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
What is CSS?

CSS allows you to create great-looking web pages, but how does it work under the hood? This article explains what CSS, what the basic syntax looks like, and how your browser applies CSS to HTML to style it.

Getting started with CSS

In this article, we will take a simple HTML document and apply CSS to it, learning some practical details of the language along the way. We will also review the CSS syntax features you've not looked at yet.

Styling a biography page Challenge

In this challenge you will style a simple bio page, testing you on some of the skills you learned in the last couple of lessons including writing selectors and text styling.

Basic CSS selectors

In this article we'll recap some selector fundamentals, including the basic type, class, and ID selectors.

Attribute selectors

As you know from your study of HTML, elements can have attributes that give further detail about the element being marked up. In CSS you can use attribute selectors to target elements with certain attributes. This lesson will show you how to use these very useful selectors.

Pseudo-classes and pseudo-elements

The next set of selectors we will look at are referred to as pseudo-classes and pseudo-elements. There are a large number of these, and they often serve quite specific purposes. Once you know how to use them, you can look through the different types to see if there is something which works for the task you are trying to achieve.

Combinators

The final selectors we will look at are called combinators. Combinators are used to combine other selectors in a way that allows us to select elements based on their location in the DOM relative to other elements (for example, child or sibling).

The box model

Everything in CSS has a box around it, and understanding these boxes is key to being able to create more complex layouts with CSS, or to align items with other items. In this lesson, we will take a look at the CSS Box model. You'll get an understanding of how it works and the terminology that relates to it.

Handling conflicts

The aim of this lesson is to develop your understanding of some of the most fundamental concepts of CSS — the cascade, specificity, and inheritance — which control how CSS is applied to HTML and how conflicts between style declarations are resolved.

Values and units

CSS rules contain declarations, which in turn are composed of properties and values. Each property used in CSS has a value type that describes what kind of values it is allowed to have. In this lesson, we will take a look at some of the most frequently used value types, what they are, and how they work.

Sizing items in CSS

Understanding how big the different features in your design will be is important. In this lesson we will summarize the various ways elements get a size via CSS and define a few terms about sizing that will help you in the future.

Backgrounds and borders

In this lesson, we will take a look at some of the creative things you can do with CSS backgrounds and borders. From adding gradients, background images, and rounded corners, backgrounds and borders are the answer to a lot of styling questions in CSS.

Overflowing content

Overflow is what happens when there is too much content to fit inside an element box. In this lesson, you will learn how to manage overflow using CSS.

Images, media, and form elements

In this lesson we will take a look at how certain special elements are treated in CSS. Images, other media, and form elements behave a little differently from regular boxes in terms of your ability to style them with CSS. Understanding what is and isn't possible can save some frustration, and this lesson will highlight some of the main things that you need to know.

Styling tables

Styling an HTML table isn't the most glamorous job in the world, but sometimes we all have to do it. This article explains how to make HTML tables look good, with some specific table styling techniques highlighted.

Debugging CSS

This article will give you guidance on how to go about debugging a CSS problem, and show you how the DevTools included in all modern browsers can help you to find out what is going on.

Challenge: Fundamental CSS comprehension Challenge

This challenge provides a number of related exercises that must be completed in order to create the final design — a business card/gamer card/social media profile.

Challenge: Creating fancy letterheaded paper Challenge

If you want to make the right impression, writing a letter on nice letterheaded paper can be a really good start. In this challenge you will create an online template to achieve such a look.

Challenge: A cool-looking box Challenge

In this challenge, you'll get some more practice in creating cool-looking boxes by trying to create an eye-catching box.

Additional tutorialsThese tutorials are not part of the learning pathway, but they are interesting nonetheless — you should consider these as stretch goals, to optionally study when you are done with the main Core articles.

Advanced styling effects

This article will give you guidance on how to go about debugging a CSS problem, and show you how the DevTools included in all modern browsers can help you to find out what is going on.

Cascade layers

This lesson aims to introduce you to cascade layers, a more advanced feature that builds on the fundamental concepts of the CSS cascade and CSS specificity.

Handling different text directions

In recent years, CSS has evolved in order to better support different directionality of content, including right-to-left but also top-to-bottom content (such as Japanese) — these different directionalities are called writing modes. As you progress in your study and begin to work with layout, an understanding of writing modes will be very helpful to you, therefore we will introduce them in this article.

Organizing CSS

As you start to work on larger stylesheets and big projects you will discover that maintaining a huge CSS file can be challenging. In this article we will take a brief look at some best practices for writing your CSS to make it easily maintainable, and some of the solutions you will find in use by others to help improve maintainability.

See also
Learn HTML and CSS, Scrimba MDN learning partner

Scrimba's Learn HTML and CSS course teaches you HTML and CSS through building and deploying five awesome projects, with fun interactive lessons and challenges taught by knowledgeable teachers.

Write your first lines of CSS!, Scrimba MDN learning partner

This interactive lesson provides a useful introduction to CSS syntax.


 Overview: Core learning modules Next\n\nCSS styling basics Overview: Core learning modules Next  
CSS (Cascading Style Sheets) is used to style and layout web pages — for example, to alter the font, color, size, and spacing of your content, split it into multiple columns, or add animations and other decorative features. This module provides all the CSS fundamentals you'll need for now, including syntax, features, and techniques.PrerequisitesBefore starting this module, you should have a basic work environment set up (as detailed in Installing basic software), and understand how to create and manage files (as detailed in Dealing with files). You should also be familiar with HTML (work through our Structuring content with HTML module if not).

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
What is CSS?

CSS allows you to create great-looking web pages, but how does it work under the hood? This article explains what CSS, what the basic syntax looks like, and how your browser applies CSS to HTML to style it.

Getting started with CSS

In this article, we will take a simple HTML document and apply CSS to it, learning some practical details of the language along the way. We will also review the CSS syntax features you've not looked at yet.

Styling a biography page Challenge

In this challenge you will style a simple bio page, testing you on some of the skills you learned in the last couple of lessons including writing selectors and text styling.

Basic CSS selectors

In this article we'll recap some selector fundamentals, including the basic type, class, and ID selectors.

Attribute selectors

As you know from your study of HTML, elements can have attributes that give further detail about the element being marked up. In CSS you can use attribute selectors to target elements with certain attributes. This lesson will show you how to use these very useful selectors.

Pseudo-classes and pseudo-elements

The next set of selectors we will look at are referred to as pseudo-classes and pseudo-elements. There are a large number of these, and they often serve quite specific purposes. Once you know how to use them, you can look through the different types to see if there is something which works for the task you are trying to achieve.

Combinators

The final selectors we will look at are called combinators. Combinators are used to combine other selectors in a way that allows us to select elements based on their location in the DOM relative to other elements (for example, child or sibling).

The box model

Everything in CSS has a box around it, and understanding these boxes is key to being able to create more complex layouts with CSS, or to align items with other items. In this lesson, we will take a look at the CSS Box model. You'll get an understanding of how it works and the terminology that relates to it.

Handling conflicts

The aim of this lesson is to develop your understanding of some of the most fundamental concepts of CSS — the cascade, specificity, and inheritance — which control how CSS is applied to HTML and how conflicts between style declarations are resolved.

Values and units

CSS rules contain declarations, which in turn are composed of properties and values. Each property used in CSS has a value type that describes what kind of values it is allowed to have. In this lesson, we will take a look at some of the most frequently used value types, what they are, and how they work.

Sizing items in CSS

Understanding how big the different features in your design will be is important. In this lesson we will summarize the various ways elements get a size via CSS and define a few terms about sizing that will help you in the future.

Backgrounds and borders

In this lesson, we will take a look at some of the creative things you can do with CSS backgrounds and borders. From adding gradients, background images, and rounded corners, backgrounds and borders are the answer to a lot of styling questions in CSS.

Overflowing content

Overflow is what happens when there is too much content to fit inside an element box. In this lesson, you will learn how to manage overflow using CSS.

Images, media, and form elements

In this lesson we will take a look at how certain special elements are treated in CSS. Images, other media, and form elements behave a little differently from regular boxes in terms of your ability to style them with CSS. Understanding what is and isn't possible can save some frustration, and this lesson will highlight some of the main things that you need to know.

Styling tables

Styling an HTML table isn't the most glamorous job in the world, but sometimes we all have to do it. This article explains how to make HTML tables look good, with some specific table styling techniques highlighted.

Debugging CSS

This article will give you guidance on how to go about debugging a CSS problem, and show you how the DevTools included in all modern browsers can help you to find out what is going on.

Challenge: Fundamental CSS comprehension Challenge

This challenge provides a number of related exercises that must be completed in order to create the final design — a business card/gamer card/social media profile.

Challenge: Creating fancy letterheaded paper Challenge

If you want to make the right impression, writing a letter on nice letterheaded paper can be a really good start. In this challenge you will create an online template to achieve such a look.

Challenge: A cool-looking box Challenge

In this challenge, you'll get some more practice in creating cool-looking boxes by trying to create an eye-catching box.

Additional tutorialsThese tutorials are not part of the learning pathway, but they are interesting nonetheless — you should consider these as stretch goals, to optionally study when you are done with the main Core articles.

Advanced styling effects

This article will give you guidance on how to go about debugging a CSS problem, and show you how the DevTools included in all modern browsers can help you to find out what is going on.

Cascade layers

This lesson aims to introduce you to cascade layers, a more advanced feature that builds on the fundamental concepts of the CSS cascade and CSS specificity.

Handling different text directions

In recent years, CSS has evolved in order to better support different directionality of content, including right-to-left but also top-to-bottom content (such as Japanese) — these different directionalities are called writing modes. As you progress in your study and begin to work with layout, an understanding of writing modes will be very helpful to you, therefore we will introduce them in this article.

Organizing CSS

As you start to work on larger stylesheets and big projects you will discover that maintaining a huge CSS file can be challenging. In this article we will take a brief look at some best practices for writing your CSS to make it easily maintainable, and some of the solutions you will find in use by others to help improve maintainability.

See also
Learn HTML and CSS, Scrimba MDN learning partner

Scrimba's Learn HTML and CSS course teaches you HTML and CSS through building and deploying five awesome projects, with fun interactive lessons and challenges taught by knowledgeable teachers.

Write your first lines of CSS!, Scrimba MDN learning partner

This interactive lesson provides a useful introduction to CSS syntax.


 Overview: Core learning modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 15, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nCSS styling basics Overview: Core learning modules Next  
CSS (Cascading Style Sheets) is used to style and layout web pages — for example, to alter the font, color, size, and spacing of your content, split it into multiple columns, or add animations and other decorative features. This module provides all the CSS fundamentals you'll need for now, including syntax, features, and techniques.PrerequisitesBefore starting this module, you should have a basic work environment set up (as detailed in Installing basic software), and understand how to create and manage files (as detailed in Dealing with files). You should also be familiar with HTML (work through our Structuring content with HTML module if not).

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
What is CSS?

CSS allows you to create great-looking web pages, but how does it work under the hood? This article explains what CSS, what the basic syntax looks like, and how your browser applies CSS to HTML to style it.

Getting started with CSS

In this article, we will take a simple HTML document and apply CSS to it, learning some practical details of the language along the way. We will also review the CSS syntax features you've not looked at yet.

Styling a biography page Challenge

In this challenge you will style a simple bio page, testing you on some of the skills you learned in the last couple of lessons including writing selectors and text styling.

Basic CSS selectors

In this article we'll recap some selector fundamentals, including the basic type, class, and ID selectors.

Attribute selectors

As you know from your study of HTML, elements can have attributes that give further detail about the element being marked up. In CSS you can use attribute selectors to target elements with certain attributes. This lesson will show you how to use these very useful selectors.

Pseudo-classes and pseudo-elements

The next set of selectors we will look at are referred to as pseudo-classes and pseudo-elements. There are a large number of these, and they often serve quite specific purposes. Once you know how to use them, you can look through the different types to see if there is something which works for the task you are trying to achieve.

Combinators

The final selectors we will look at are called combinators. Combinators are used to combine other selectors in a way that allows us to select elements based on their location in the DOM relative to other elements (for example, child or sibling).

The box model

Everything in CSS has a box around it, and understanding these boxes is key to being able to create more complex layouts with CSS, or to align items with other items. In this lesson, we will take a look at the CSS Box model. You'll get an understanding of how it works and the terminology that relates to it.

Handling conflicts

The aim of this lesson is to develop your understanding of some of the most fundamental concepts of CSS — the cascade, specificity, and inheritance — which control how CSS is applied to HTML and how conflicts between style declarations are resolved.

Values and units

CSS rules contain declarations, which in turn are composed of properties and values. Each property used in CSS has a value type that describes what kind of values it is allowed to have. In this lesson, we will take a look at some of the most frequently used value types, what they are, and how they work.

Sizing items in CSS

Understanding how big the different features in your design will be is important. In this lesson we will summarize the various ways elements get a size via CSS and define a few terms about sizing that will help you in the future.

Backgrounds and borders

In this lesson, we will take a look at some of the creative things you can do with CSS backgrounds and borders. From adding gradients, background images, and rounded corners, backgrounds and borders are the answer to a lot of styling questions in CSS.

Overflowing content

Overflow is what happens when there is too much content to fit inside an element box. In this lesson, you will learn how to manage overflow using CSS.

Images, media, and form elements

In this lesson we will take a look at how certain special elements are treated in CSS. Images, other media, and form elements behave a little differently from regular boxes in terms of your ability to style them with CSS. Understanding what is and isn't possible can save some frustration, and this lesson will highlight some of the main things that you need to know.

Styling tables

Styling an HTML table isn't the most glamorous job in the world, but sometimes we all have to do it. This article explains how to make HTML tables look good, with some specific table styling techniques highlighted.

Debugging CSS

This article will give you guidance on how to go about debugging a CSS problem, and show you how the DevTools included in all modern browsers can help you to find out what is going on.

Challenge: Fundamental CSS comprehension Challenge

This challenge provides a number of related exercises that must be completed in order to create the final design — a business card/gamer card/social media profile.

Challenge: Creating fancy letterheaded paper Challenge

If you want to make the right impression, writing a letter on nice letterheaded paper can be a really good start. In this challenge you will create an online template to achieve such a look.

Challenge: A cool-looking box Challenge

In this challenge, you'll get some more practice in creating cool-looking boxes by trying to create an eye-catching box.

Additional tutorialsThese tutorials are not part of the learning pathway, but they are interesting nonetheless — you should consider these as stretch goals, to optionally study when you are done with the main Core articles.

Advanced styling effects

This article will give you guidance on how to go about debugging a CSS problem, and show you how the DevTools included in all modern browsers can help you to find out what is going on.

Cascade layers

This lesson aims to introduce you to cascade layers, a more advanced feature that builds on the fundamental concepts of the CSS cascade and CSS specificity.

Handling different text directions

In recent years, CSS has evolved in order to better support different directionality of content, including right-to-left but also top-to-bottom content (such as Japanese) — these different directionalities are called writing modes. As you progress in your study and begin to work with layout, an understanding of writing modes will be very helpful to you, therefore we will introduce them in this article.

Organizing CSS

As you start to work on larger stylesheets and big projects you will discover that maintaining a huge CSS file can be challenging. In this article we will take a brief look at some best practices for writing your CSS to make it easily maintainable, and some of the solutions you will find in use by others to help improve maintainability.

See also
Learn HTML and CSS, Scrimba MDN learning partner

Scrimba's Learn HTML and CSS course teaches you HTML and CSS through building and deploying five awesome projects, with fun interactive lessons and challenges taught by knowledgeable teachers.

Write your first lines of CSS!, Scrimba MDN learning partner

This interactive lesson provides a useful introduction to CSS syntax.


 Overview: Core learning modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 15, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nDynamic scripting with JavaScript Overview: Core learning modules Next  
JavaScript is a huge topic, with so many different features, styles, and techniques to learn, and so many APIs and tools built on top of it. This module focuses mostly on the essentials of the core language, plus some key surrounding topics — learning these topics will give you a solid basis to work from.PrerequisitesBefore starting this module, you don't need any previous JavaScript knowledge, but you should have worked through the previous modules in the course. You should at least know HTML and the basic fundamentals of CSS.

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
What is JavaScript?

Welcome to the MDN beginner's JavaScript course! In this first article we will look at JavaScript from a high level, answering questions such as "what is it?", and "what is it doing?", and making sure you are comfortable with JavaScript's purpose.

A first splash into JavaScript

Now you've learned something about the theory of JavaScript, and what you can do with it, we are going to give you a crash course on the basic features of JavaScript via a completely practical tutorial. Here you'll build up a simple "Guess the number" game, step by step.

What went wrong? Troubleshooting JavaScript

When you built up the "Guess the number" game in the previous article, you may have found that it didn't work. Never fear — this article aims to save you from tearing your hair out over such problems by providing you with some simple tips on how to find and fix errors in JavaScript programs.

Storing the information you need — Variables

After reading the last couple of articles you should now know what JavaScript is, what it can do for you, how you use it alongside other web technologies, and what its main features look like from a high level. In this article, we will get down to the real basics, looking at how to work with the most basic building blocks of JavaScript — Variables.

Basic math in JavaScript — numbers and operators

At this point in the course, we discuss maths in JavaScript — how we can combine operators and other features to successfully manipulate numbers to do our bidding.

Handling text — strings in JavaScript

Next, we'll turn our attention to strings — this is what pieces of text are called in programming. In this article, we'll look at all the common things that you really ought to know about strings when learning JavaScript, such as creating strings, escaping quotes in strings, and joining them together.

Useful string methods

Now we've looked at the very basics of strings, let's move up a gear and start thinking about what useful operations we can do on strings with built-in methods, such as finding the length of a text string, joining and splitting strings, substituting one character in a string for another, and more.

Arrays

In this lesson we'll look at arrays — a neat way of storing a list of data items under a single variable name. Here we look at why this is useful, then explore how to create an array, retrieve, add, and remove items stored in an array, and more besides.

Challenge: Silly story generator Challenge

In this challenge, you'll be tasked with taking some of the knowledge you've picked up in this module's articles and applying it to creating a fun app that generates random silly stories. Have fun!

Making decisions in your code — conditionals

In any programming language, the code needs to make decisions and carry out actions accordingly depending on different inputs. For example, in a game, if the player's number of lives is 0, then it's game over. In a weather app, if it is being looked at in the morning, show a sunrise graphic; show stars and a moon if it is nighttime. In this article, we'll explore how so-called conditional statements work in JavaScript.

Looping code

Programming languages are very useful for rapidly completing repetitive tasks, from multiple basic calculations to just about any other situation where you've got a lot of similar items of work to complete. Here we'll look at the loop structures available in JavaScript that handle such needs.

Functions — reusable blocks of code

Another essential concept in coding is functions, which allow you to store a piece of code that does a single task inside a defined block, and then call that code whenever you need it using a single short command — rather than having to type out the same code multiple times. In this article we'll explore fundamental concepts behind functions such as basic syntax, how to invoke and define them, scope, and parameters.

Build your own function

With most of the essential theory dealt with in the previous article, this article provides practical experience. Here you will get some practice building your own, custom function. Along the way, we'll also explain some useful details of dealing with functions.

Function return values

There's one last essential concept about functions for us to discuss — return values. Some functions don't return a significant value, but others do. It's important to understand what their values are, how to use them in your code, and how to make functions return useful values. We'll cover all of these below.

Introduction to events

In this article, we discuss some important concepts surrounding events, and look at the fundamentals of how they work in browsers.

Event bubbling

This article introduces the concepts of event bubbling, event capture, and event delegation, which are all about what happens when you add a listener to an element that contains another element, and an event then happens to the contained element.

Challenge: Image gallery Challenge

Now that we've looked at the fundamental building blocks of JavaScript, we'll test your knowledge of loops, functions, conditionals and events by getting you to build a fairly common item you'll see on a lot of websites — a JavaScript-powered image gallery.

Object basics

In this article, we'll look at fundamental JavaScript object syntax, and revisit some JavaScript features that we've already seen earlier in the course, reiterating the fact that many of the features you've already dealt with are objects.

DOM scripting introduction

When writing web pages and apps, one of the most common things you'll want to do is change the document structure in some way. This is usually done by manipulating the Document Object Model (DOM) via a set of built-in browser APIs for controlling HTML and styling information. In this article we'll introduce you to DOM scripting.

Making network requests with JavaScript

Another very common task in modern websites and applications is making network requests to retrieve individual data items from the server to update sections of a webpage without having to load an entire new page. This seemingly small detail has had a huge impact on the performance and behavior of sites, so in this article, we'll explain the concept and look at technologies that make it possible.

Working with JSON

JavaScript Object Notation (JSON) is a standard text-based format for representing structured data based on JavaScript object syntax. It is commonly used for transmitting data in web applications (e.g., sending some data from the server to the client, so it can be displayed on a web page, or vice versa). You'll come across it quite often, so in this article, we give you all you need to work with JSON using JavaScript, including parsing JSON so you can access data within it, and creating JSON.

JavaScript debugging and error handling

In this lesson, we will return to the subject of debugging JavaScript (which we first looked at in What went wrong?). Here we will delve deeper into techniques for tracking down errors, but also look at how to code defensively and handle errors in your code, avoiding problems in the first place.

Test your skills: JavaScript

This page lists JavaScript tests you can try so you can verify if you've understood the content in this module.

See also
Scrimba: Learn JavaScript MDN learning partner

Scrimba's Learn JavaScript course teaches you JavaScript through solving 140+ interactive coding challenges, building projects including a game, a browser extension, and even a mobile app. Scrimba features fun interactive lessons taught by knowledgeable teachers.

Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.


 Overview: Core learning modules Next\n\nDynamic scripting with JavaScript Overview: Core learning modules Next  
JavaScript is a huge topic, with so many different features, styles, and techniques to learn, and so many APIs and tools built on top of it. This module focuses mostly on the essentials of the core language, plus some key surrounding topics — learning these topics will give you a solid basis to work from.PrerequisitesBefore starting this module, you don't need any previous JavaScript knowledge, but you should have worked through the previous modules in the course. You should at least know HTML and the basic fundamentals of CSS.

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
What is JavaScript?

Welcome to the MDN beginner's JavaScript course! In this first article we will look at JavaScript from a high level, answering questions such as "what is it?", and "what is it doing?", and making sure you are comfortable with JavaScript's purpose.

A first splash into JavaScript

Now you've learned something about the theory of JavaScript, and what you can do with it, we are going to give you a crash course on the basic features of JavaScript via a completely practical tutorial. Here you'll build up a simple "Guess the number" game, step by step.

What went wrong? Troubleshooting JavaScript

When you built up the "Guess the number" game in the previous article, you may have found that it didn't work. Never fear — this article aims to save you from tearing your hair out over such problems by providing you with some simple tips on how to find and fix errors in JavaScript programs.

Storing the information you need — Variables

After reading the last couple of articles you should now know what JavaScript is, what it can do for you, how you use it alongside other web technologies, and what its main features look like from a high level. In this article, we will get down to the real basics, looking at how to work with the most basic building blocks of JavaScript — Variables.

Basic math in JavaScript — numbers and operators

At this point in the course, we discuss maths in JavaScript — how we can combine operators and other features to successfully manipulate numbers to do our bidding.

Handling text — strings in JavaScript

Next, we'll turn our attention to strings — this is what pieces of text are called in programming. In this article, we'll look at all the common things that you really ought to know about strings when learning JavaScript, such as creating strings, escaping quotes in strings, and joining them together.

Useful string methods

Now we've looked at the very basics of strings, let's move up a gear and start thinking about what useful operations we can do on strings with built-in methods, such as finding the length of a text string, joining and splitting strings, substituting one character in a string for another, and more.

Arrays

In this lesson we'll look at arrays — a neat way of storing a list of data items under a single variable name. Here we look at why this is useful, then explore how to create an array, retrieve, add, and remove items stored in an array, and more besides.

Challenge: Silly story generator Challenge

In this challenge, you'll be tasked with taking some of the knowledge you've picked up in this module's articles and applying it to creating a fun app that generates random silly stories. Have fun!

Making decisions in your code — conditionals

In any programming language, the code needs to make decisions and carry out actions accordingly depending on different inputs. For example, in a game, if the player's number of lives is 0, then it's game over. In a weather app, if it is being looked at in the morning, show a sunrise graphic; show stars and a moon if it is nighttime. In this article, we'll explore how so-called conditional statements work in JavaScript.

Looping code

Programming languages are very useful for rapidly completing repetitive tasks, from multiple basic calculations to just about any other situation where you've got a lot of similar items of work to complete. Here we'll look at the loop structures available in JavaScript that handle such needs.

Functions — reusable blocks of code

Another essential concept in coding is functions, which allow you to store a piece of code that does a single task inside a defined block, and then call that code whenever you need it using a single short command — rather than having to type out the same code multiple times. In this article we'll explore fundamental concepts behind functions such as basic syntax, how to invoke and define them, scope, and parameters.

Build your own function

With most of the essential theory dealt with in the previous article, this article provides practical experience. Here you will get some practice building your own, custom function. Along the way, we'll also explain some useful details of dealing with functions.

Function return values

There's one last essential concept about functions for us to discuss — return values. Some functions don't return a significant value, but others do. It's important to understand what their values are, how to use them in your code, and how to make functions return useful values. We'll cover all of these below.

Introduction to events

In this article, we discuss some important concepts surrounding events, and look at the fundamentals of how they work in browsers.

Event bubbling

This article introduces the concepts of event bubbling, event capture, and event delegation, which are all about what happens when you add a listener to an element that contains another element, and an event then happens to the contained element.

Challenge: Image gallery Challenge

Now that we've looked at the fundamental building blocks of JavaScript, we'll test your knowledge of loops, functions, conditionals and events by getting you to build a fairly common item you'll see on a lot of websites — a JavaScript-powered image gallery.

Object basics

In this article, we'll look at fundamental JavaScript object syntax, and revisit some JavaScript features that we've already seen earlier in the course, reiterating the fact that many of the features you've already dealt with are objects.

DOM scripting introduction

When writing web pages and apps, one of the most common things you'll want to do is change the document structure in some way. This is usually done by manipulating the Document Object Model (DOM) via a set of built-in browser APIs for controlling HTML and styling information. In this article we'll introduce you to DOM scripting.

Making network requests with JavaScript

Another very common task in modern websites and applications is making network requests to retrieve individual data items from the server to update sections of a webpage without having to load an entire new page. This seemingly small detail has had a huge impact on the performance and behavior of sites, so in this article, we'll explain the concept and look at technologies that make it possible.

Working with JSON

JavaScript Object Notation (JSON) is a standard text-based format for representing structured data based on JavaScript object syntax. It is commonly used for transmitting data in web applications (e.g., sending some data from the server to the client, so it can be displayed on a web page, or vice versa). You'll come across it quite often, so in this article, we give you all you need to work with JSON using JavaScript, including parsing JSON so you can access data within it, and creating JSON.

JavaScript debugging and error handling

In this lesson, we will return to the subject of debugging JavaScript (which we first looked at in What went wrong?). Here we will delve deeper into techniques for tracking down errors, but also look at how to code defensively and handle errors in your code, avoiding problems in the first place.

Test your skills: JavaScript

This page lists JavaScript tests you can try so you can verify if you've understood the content in this module.

See also
Scrimba: Learn JavaScript MDN learning partner

Scrimba's Learn JavaScript course teaches you JavaScript through solving 140+ interactive coding challenges, building projects including a game, a browser extension, and even a mobile app. Scrimba features fun interactive lessons taught by knowledgeable teachers.

Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.


 Overview: Core learning modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 15, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nDynamic scripting with JavaScript Overview: Core learning modules Next  
JavaScript is a huge topic, with so many different features, styles, and techniques to learn, and so many APIs and tools built on top of it. This module focuses mostly on the essentials of the core language, plus some key surrounding topics — learning these topics will give you a solid basis to work from.PrerequisitesBefore starting this module, you don't need any previous JavaScript knowledge, but you should have worked through the previous modules in the course. You should at least know HTML and the basic fundamentals of CSS.

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
What is JavaScript?

Welcome to the MDN beginner's JavaScript course! In this first article we will look at JavaScript from a high level, answering questions such as "what is it?", and "what is it doing?", and making sure you are comfortable with JavaScript's purpose.

A first splash into JavaScript

Now you've learned something about the theory of JavaScript, and what you can do with it, we are going to give you a crash course on the basic features of JavaScript via a completely practical tutorial. Here you'll build up a simple "Guess the number" game, step by step.

What went wrong? Troubleshooting JavaScript

When you built up the "Guess the number" game in the previous article, you may have found that it didn't work. Never fear — this article aims to save you from tearing your hair out over such problems by providing you with some simple tips on how to find and fix errors in JavaScript programs.

Storing the information you need — Variables

After reading the last couple of articles you should now know what JavaScript is, what it can do for you, how you use it alongside other web technologies, and what its main features look like from a high level. In this article, we will get down to the real basics, looking at how to work with the most basic building blocks of JavaScript — Variables.

Basic math in JavaScript — numbers and operators

At this point in the course, we discuss maths in JavaScript — how we can combine operators and other features to successfully manipulate numbers to do our bidding.

Handling text — strings in JavaScript

Next, we'll turn our attention to strings — this is what pieces of text are called in programming. In this article, we'll look at all the common things that you really ought to know about strings when learning JavaScript, such as creating strings, escaping quotes in strings, and joining them together.

Useful string methods

Now we've looked at the very basics of strings, let's move up a gear and start thinking about what useful operations we can do on strings with built-in methods, such as finding the length of a text string, joining and splitting strings, substituting one character in a string for another, and more.

Arrays

In this lesson we'll look at arrays — a neat way of storing a list of data items under a single variable name. Here we look at why this is useful, then explore how to create an array, retrieve, add, and remove items stored in an array, and more besides.

Challenge: Silly story generator Challenge

In this challenge, you'll be tasked with taking some of the knowledge you've picked up in this module's articles and applying it to creating a fun app that generates random silly stories. Have fun!

Making decisions in your code — conditionals

In any programming language, the code needs to make decisions and carry out actions accordingly depending on different inputs. For example, in a game, if the player's number of lives is 0, then it's game over. In a weather app, if it is being looked at in the morning, show a sunrise graphic; show stars and a moon if it is nighttime. In this article, we'll explore how so-called conditional statements work in JavaScript.

Looping code

Programming languages are very useful for rapidly completing repetitive tasks, from multiple basic calculations to just about any other situation where you've got a lot of similar items of work to complete. Here we'll look at the loop structures available in JavaScript that handle such needs.

Functions — reusable blocks of code

Another essential concept in coding is functions, which allow you to store a piece of code that does a single task inside a defined block, and then call that code whenever you need it using a single short command — rather than having to type out the same code multiple times. In this article we'll explore fundamental concepts behind functions such as basic syntax, how to invoke and define them, scope, and parameters.

Build your own function

With most of the essential theory dealt with in the previous article, this article provides practical experience. Here you will get some practice building your own, custom function. Along the way, we'll also explain some useful details of dealing with functions.

Function return values

There's one last essential concept about functions for us to discuss — return values. Some functions don't return a significant value, but others do. It's important to understand what their values are, how to use them in your code, and how to make functions return useful values. We'll cover all of these below.

Introduction to events

In this article, we discuss some important concepts surrounding events, and look at the fundamentals of how they work in browsers.

Event bubbling

This article introduces the concepts of event bubbling, event capture, and event delegation, which are all about what happens when you add a listener to an element that contains another element, and an event then happens to the contained element.

Challenge: Image gallery Challenge

Now that we've looked at the fundamental building blocks of JavaScript, we'll test your knowledge of loops, functions, conditionals and events by getting you to build a fairly common item you'll see on a lot of websites — a JavaScript-powered image gallery.

Object basics

In this article, we'll look at fundamental JavaScript object syntax, and revisit some JavaScript features that we've already seen earlier in the course, reiterating the fact that many of the features you've already dealt with are objects.

DOM scripting introduction

When writing web pages and apps, one of the most common things you'll want to do is change the document structure in some way. This is usually done by manipulating the Document Object Model (DOM) via a set of built-in browser APIs for controlling HTML and styling information. In this article we'll introduce you to DOM scripting.

Making network requests with JavaScript

Another very common task in modern websites and applications is making network requests to retrieve individual data items from the server to update sections of a webpage without having to load an entire new page. This seemingly small detail has had a huge impact on the performance and behavior of sites, so in this article, we'll explain the concept and look at technologies that make it possible.

Working with JSON

JavaScript Object Notation (JSON) is a standard text-based format for representing structured data based on JavaScript object syntax. It is commonly used for transmitting data in web applications (e.g., sending some data from the server to the client, so it can be displayed on a web page, or vice versa). You'll come across it quite often, so in this article, we give you all you need to work with JSON using JavaScript, including parsing JSON so you can access data within it, and creating JSON.

JavaScript debugging and error handling

In this lesson, we will return to the subject of debugging JavaScript (which we first looked at in What went wrong?). Here we will delve deeper into techniques for tracking down errors, but also look at how to code defensively and handle errors in your code, avoiding problems in the first place.

Test your skills: JavaScript

This page lists JavaScript tests you can try so you can verify if you've understood the content in this module.

See also
Scrimba: Learn JavaScript MDN learning partner

Scrimba's Learn JavaScript course teaches you JavaScript through solving 140+ interactive coding challenges, building projects including a game, a browser extension, and even a mobile app. Scrimba features fun interactive lessons taught by knowledgeable teachers.

Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.


 Overview: Core learning modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 15, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nAccessibility on the web Overview: Core learning modules Next  
Access to web content such as public services, education, e-commerce sites, and entertainment is a human right. No one should be excluded based on disability, race, geography, or other human characteristics. This module discusses the best practices and techniques you should learn to make your websites as accessible as possible.PrerequisitesYou should be familiar with HTML, CSS, and JavaScript before starting this module.

Note:
If you are working on a computer/tablet/other devices where you don't have the ability to create your own files, you can try out most of the code examples in an online coding program such as JS Bin or Glitch.
Tutorials and challenges
What is accessibility?

This article starts off the module with a good look at what accessibility is — this includes what groups of people we need to consider and why, what tools different people use to interact with the web, and how we can make accessibility part of our web development workflow.

Accessibility tooling and assistive technology

Next we turn our attention to accessibility tooling, providing information on the kinds of tools you can use to help solve accessibility issues, and the assistive technologies used by people with disabilities as they browse the web. You'll be using these tools throughout subsequent articles.

HTML: A good basis for accessibility

A great deal of web content can be made accessible just by making sure the correct HTML elements are always used for the correct purpose. This article looks in detail at how HTML can be used to ensure maximum accessibility.

CSS and JavaScript accessibility best practices

CSS and JavaScript, when used properly, also have the potential to allow for accessible web experiences, but if misused they can significantly harm accessibility. This article outlines some CSS and JavaScript best practices that should be considered to ensure that even complex content is as accessible as possible.

WAI-ARIA basics

Following on from the previous article, sometimes making complex UI controls that involve unsemantic HTML and dynamic JavaScript-updated content can be difficult. WAI-ARIA is a technology that can help with such problems by adding in further semantics that browsers and assistive technologies can recognize and use to let users know what is going on. Here we'll show how to use it at a basic level to improve accessibility.

Accessible multimedia

Another category of content that can create accessibility problems is multimedia — video, audio, and image content need to be given proper textual alternatives, so they can be understood by assistive technologies and their users. This article shows how.

Mobile accessibility

With web access on mobile devices being so popular, and popular platforms such as iOS and Android having fully-fledged accessibility tools, it is important to consider the accessibility of your web content on these platforms. This article looks at mobile-specific accessibility considerations.

Accessibility troubleshooting Challenge

In this challenge, we present to you a simple site with several accessibility issues that you need to diagnose and fix.

See also
Start Building Accessible Web Applications Today

An excellent series of video tutorials by Marcy Sutton.

Deque University resources

Includes code examples, screen reader references, and other useful resources.

WebAIM resources

Includes guides, checklists, tools, and more.

Web Accessibility Evaluation Tools List

Includes a list of web accessibility evaluation tools.

Learn Accessible Web Design MDN learning partner

Scrimba's Learn Accessible Web Design course teaches you how to write accessible HTML by solving interactive coding challenges and fixing a real-world website.


 Overview: Core learning modules Next\n\nAccessibility on the web Overview: Core learning modules Next  
Access to web content such as public services, education, e-commerce sites, and entertainment is a human right. No one should be excluded based on disability, race, geography, or other human characteristics. This module discusses the best practices and techniques you should learn to make your websites as accessible as possible.PrerequisitesYou should be familiar with HTML, CSS, and JavaScript before starting this module.

Note:
If you are working on a computer/tablet/other devices where you don't have the ability to create your own files, you can try out most of the code examples in an online coding program such as JS Bin or Glitch.
Tutorials and challenges
What is accessibility?

This article starts off the module with a good look at what accessibility is — this includes what groups of people we need to consider and why, what tools different people use to interact with the web, and how we can make accessibility part of our web development workflow.

Accessibility tooling and assistive technology

Next we turn our attention to accessibility tooling, providing information on the kinds of tools you can use to help solve accessibility issues, and the assistive technologies used by people with disabilities as they browse the web. You'll be using these tools throughout subsequent articles.

HTML: A good basis for accessibility

A great deal of web content can be made accessible just by making sure the correct HTML elements are always used for the correct purpose. This article looks in detail at how HTML can be used to ensure maximum accessibility.

CSS and JavaScript accessibility best practices

CSS and JavaScript, when used properly, also have the potential to allow for accessible web experiences, but if misused they can significantly harm accessibility. This article outlines some CSS and JavaScript best practices that should be considered to ensure that even complex content is as accessible as possible.

WAI-ARIA basics

Following on from the previous article, sometimes making complex UI controls that involve unsemantic HTML and dynamic JavaScript-updated content can be difficult. WAI-ARIA is a technology that can help with such problems by adding in further semantics that browsers and assistive technologies can recognize and use to let users know what is going on. Here we'll show how to use it at a basic level to improve accessibility.

Accessible multimedia

Another category of content that can create accessibility problems is multimedia — video, audio, and image content need to be given proper textual alternatives, so they can be understood by assistive technologies and their users. This article shows how.

Mobile accessibility

With web access on mobile devices being so popular, and popular platforms such as iOS and Android having fully-fledged accessibility tools, it is important to consider the accessibility of your web content on these platforms. This article looks at mobile-specific accessibility considerations.

Accessibility troubleshooting Challenge

In this challenge, we present to you a simple site with several accessibility issues that you need to diagnose and fix.

See also
Start Building Accessible Web Applications Today

An excellent series of video tutorials by Marcy Sutton.

Deque University resources

Includes code examples, screen reader references, and other useful resources.

WebAIM resources

Includes guides, checklists, tools, and more.

Web Accessibility Evaluation Tools List

Includes a list of web accessibility evaluation tools.

Learn Accessible Web Design MDN learning partner

Scrimba's Learn Accessible Web Design course teaches you how to write accessible HTML by solving interactive coding challenges and fixing a real-world website.


 Overview: Core learning modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 15, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nAccessibility on the web Overview: Core learning modules Next  
Access to web content such as public services, education, e-commerce sites, and entertainment is a human right. No one should be excluded based on disability, race, geography, or other human characteristics. This module discusses the best practices and techniques you should learn to make your websites as accessible as possible.PrerequisitesYou should be familiar with HTML, CSS, and JavaScript before starting this module.

Note:
If you are working on a computer/tablet/other devices where you don't have the ability to create your own files, you can try out most of the code examples in an online coding program such as JS Bin or Glitch.
Tutorials and challenges
What is accessibility?

This article starts off the module with a good look at what accessibility is — this includes what groups of people we need to consider and why, what tools different people use to interact with the web, and how we can make accessibility part of our web development workflow.

Accessibility tooling and assistive technology

Next we turn our attention to accessibility tooling, providing information on the kinds of tools you can use to help solve accessibility issues, and the assistive technologies used by people with disabilities as they browse the web. You'll be using these tools throughout subsequent articles.

HTML: A good basis for accessibility

A great deal of web content can be made accessible just by making sure the correct HTML elements are always used for the correct purpose. This article looks in detail at how HTML can be used to ensure maximum accessibility.

CSS and JavaScript accessibility best practices

CSS and JavaScript, when used properly, also have the potential to allow for accessible web experiences, but if misused they can significantly harm accessibility. This article outlines some CSS and JavaScript best practices that should be considered to ensure that even complex content is as accessible as possible.

WAI-ARIA basics

Following on from the previous article, sometimes making complex UI controls that involve unsemantic HTML and dynamic JavaScript-updated content can be difficult. WAI-ARIA is a technology that can help with such problems by adding in further semantics that browsers and assistive technologies can recognize and use to let users know what is going on. Here we'll show how to use it at a basic level to improve accessibility.

Accessible multimedia

Another category of content that can create accessibility problems is multimedia — video, audio, and image content need to be given proper textual alternatives, so they can be understood by assistive technologies and their users. This article shows how.

Mobile accessibility

With web access on mobile devices being so popular, and popular platforms such as iOS and Android having fully-fledged accessibility tools, it is important to consider the accessibility of your web content on these platforms. This article looks at mobile-specific accessibility considerations.

Accessibility troubleshooting Challenge

In this challenge, we present to you a simple site with several accessibility issues that you need to diagnose and fix.

See also
Start Building Accessible Web Applications Today

An excellent series of video tutorials by Marcy Sutton.

Deque University resources

Includes code examples, screen reader references, and other useful resources.

WebAIM resources

Includes guides, checklists, tools, and more.

Web Accessibility Evaluation Tools List

Includes a list of web accessibility evaluation tools.

Learn Accessible Web Design MDN learning partner

Scrimba's Learn Accessible Web Design course teaches you how to write accessible HTML by solving interactive coding challenges and fixing a real-world website.


 Overview: Core learning modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 15, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nMore MDN. Your MDN.Support MDN and make it your own.Get startedWhat's includedGo ads freeEnjoy MDN ads-free with an MDN Plus subscription.Support MDN and enjoy a focused, ad-free experience alongside other features such as curated collections, custom web platform updates, offline access, and more. Subscribers to paid tiers of MDN Plus have the option to browse MDN without ads.Learn more →AI HelpGet real-time assistance and support.No need to scroll through page after page to find your answers. Introducing an AI assistant that can answer all your web development questions in real time. Powered by OpenAI GPT-4o and GPT-4o mini.Learn more →PlaygroundWrite,Test and Share your code.Your playground to learn and share your amazing work with the world. By simply logging in, you can now spread your creativity far and wide.Learn more →UpdatesCompatibility changes at a glance.Filter and sort updates that matter most to build your projectThe Web doesn't have a changelog, but MDN can help. You can personalize and filter compatibility changes based on browsers or the tech category you are interested in whether that is JavaScript, CSS, etc.Learn more →CollectionsBuild your perfect library. Or let us build it for you.No more haphazard hunting through the vast virtual library: unleash your inner curator and collect your favorite articles in one place for convenient consultation.Learn more →Loading available plans…* Do you need MDN Plus for your company? Let us know and we’ll get back to you when it becomes available.\n\nMore MDN. Your MDN.Support MDN and make it your own.Get startedWhat's includedGo ads freeEnjoy MDN ads-free with an MDN Plus subscription.Support MDN and enjoy a focused, ad-free experience alongside other features such as curated collections, custom web platform updates, offline access, and more. Subscribers to paid tiers of MDN Plus have the option to browse MDN without ads.Learn more →AI HelpGet real-time assistance and support.No need to scroll through page after page to find your answers. Introducing an AI assistant that can answer all your web development questions in real time. Powered by OpenAI GPT-4o and GPT-4o mini.Learn more →PlaygroundWrite,Test and Share your code.Your playground to learn and share your amazing work with the world. By simply logging in, you can now spread your creativity far and wide.Learn more →UpdatesCompatibility changes at a glance.Filter and sort updates that matter most to build your projectThe Web doesn't have a changelog, but MDN can help. You can personalize and filter compatibility changes based on browsers or the tech category you are interested in whether that is JavaScript, CSS, etc.Learn more →CollectionsBuild your perfect library. Or let us build it for you.No more haphazard hunting through the vast virtual library: unleash your inner curator and collect your favorite articles in one place for convenient consultation.Learn more →Loading available plans…* Do you need MDN Plus for your company? Let us know and we’ll get back to you when it becomes available.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOverview

More MDN. Your MDN. Get started.
This page is an overview of the MDN Plus documentation and related resources.

MDN Plus is a premium subscription service launched by Mozilla. The service
allows users to customize their MDN Web Docs experience through premium features
such as Collections, filtering Updates and MDN Offline.
Learn more about MDN Plus on our website or in this
blogpost.\n\nOverview

More MDN. Your MDN. Get started.
This page is an overview of the MDN Plus documentation and related resources.

MDN Plus is a premium subscription service launched by Mozilla. The service
allows users to customize their MDN Web Docs experience through premium features
such as Collections, filtering Updates and MDN Offline.
Learn more about MDN Plus on our website or in this
blogpost.\n\nOverview

More MDN. Your MDN. Get started.
This page is an overview of the MDN Plus documentation and related resources.

MDN Plus is a premium subscription service launched by Mozilla. The service
allows users to customize their MDN Web Docs experience through premium features
such as Collections, filtering Updates and MDN Offline.
Learn more about MDN Plus on our website or in this
blogpost.\n\n\n\nFrequently asked questionsWhat is MDN Plus?MDN Plus is a premium subscription service launched in March 2022 by Mozilla.
The service allows users to customize their MDN Web Docs experience through
premium features such as Updates,
Collections and
MDN Offline.Why are we working on premium features on MDN?The extensive research we have done in 2020 and 2021 showed us that MDN users
would appreciate a customized experience on MDN. We’ve got information on what
you would find useful and what you would be interested in. All the premium
features we propose today reflect that feedback. MDN Plus is an initial step
towards making the experience on the site more interactive and helpful for our
users.How much does MDN Plus cost?A three-tiered pricing model has been put in place in order to try and
accommodate our users’ needs as much as possible:

MDN Core - A free plan, for those ones who want to try out a limited version
of the premium features.
MDN Plus 5 - A $5/month or $50/year plan that offers unlimited access to the
premium features included in MDN Plus.
MDN Supporter 10 - A $10/month or $100/year plan for users who want to
support MDN with a higher amount. On top of the MDN Plus premium features, MDN
supporters will be able to contribute and shape the product moving forward, by
having early access to premium features and a direct feedback channel with the
MDN team.

Subscribing for a yearly plan activates a 20% discount for all the paid options.Can I upgrade/downgrade my plan?Currently, you can only upgrade your plan. For getting a downgrade, please
cancel your current subscription first and then activate the new one.What is happening with the existing MDN Web Docs?Nothing. We will continue to develop & maintain our web documentation that will
remain free and accessible for everyone. There will be no change there. Even
more, we believe that MDN Web Docs will benefit from MDN Plus, as we plan to
reinvest part of the gains from MDN Plus and improve our documentation as well
as the overall user experience on the website.Are we violating any OS license obligation by adding a paid product to MDN?MDN content is made available under a CC BY-SA 2.5 license. That license doesn't
preclude Mozilla (or other users of MDN content) from having a paid product. MDN
Plus adds premium features like updates and collections on top of the free
content. Regular users can still access and reuse MDN content under the Creative
Commons license.Where will the money from MDN Plus go?Since its beginning in 2005, MDN Web Docs has been a project hosted and provided
by Mozilla. Mozilla covers the cost of infrastructure, development and
maintenance of the MDN platform, including a team of engineers and its own team
of dedicated writers.
Mozilla wants MDN Plus to help ensure that MDN's open source content continues
to be supported into the future. MDN Plus has been built only with Mozilla
resources, and any revenue generated by MDN Plus will stay within Mozilla. We
are looking into ways to reinvest some of these additional funds into open
source projects contributing to MDN but it is still in the early stages.Does the launch of MDN Plus impact the relationship with partners like OWD?The existence of a new subscription model will not detract from MDN's current
free Web Docs offering in any way. The current experience of accessing web
documentation will not change for users who do not wish to sign up for a premium
subscription. Open Web Docs (OWD) and Mozilla will continue to work closely
together on MDN for the best possible web platform documentation for everyone.
For more information about how our organizations work together, please check
this article.What regions is MDN Plus available in?The free version of MDN Plus is available worldwide. Anyone can create an MDN
Plus account and try out a limited version of the premium features. As for the
paid plans, they are currently available as follows: in the United States,
Canada (since March 24th, 2022), Austria, Belgium, Finland, France, the United
Kingdom, Germany, Ireland, Italy, Malaysia, the Netherlands, New Zealand, Puerto
Rico, Sweden, Singapore, Switzerland, Spain (since April 28th, 2022), Estonia,
Greece, Latvia, Lithuania, Portugal, Slovakia and Slovenia (since June 15th,
2022). We are working on expanding this list even further.I have an idea for MDN Plus, who should I contact?In case you have an idea you would like to share about MDN Plus, you can add
your suggestions to our mdn-community
repo.
If a subscriber, you can also leave us feedback by accessing the ‘Feedback’
option in the user menu.\n\nFrequently asked questionsWhat is MDN Plus?MDN Plus is a premium subscription service launched in March 2022 by Mozilla.
The service allows users to customize their MDN Web Docs experience through
premium features such as Updates,
Collections and
MDN Offline.Why are we working on premium features on MDN?The extensive research we have done in 2020 and 2021 showed us that MDN users
would appreciate a customized experience on MDN. We’ve got information on what
you would find useful and what you would be interested in. All the premium
features we propose today reflect that feedback. MDN Plus is an initial step
towards making the experience on the site more interactive and helpful for our
users.How much does MDN Plus cost?A three-tiered pricing model has been put in place in order to try and
accommodate our users’ needs as much as possible:

MDN Core - A free plan, for those ones who want to try out a limited version
of the premium features.
MDN Plus 5 - A $5/month or $50/year plan that offers unlimited access to the
premium features included in MDN Plus.
MDN Supporter 10 - A $10/month or $100/year plan for users who want to
support MDN with a higher amount. On top of the MDN Plus premium features, MDN
supporters will be able to contribute and shape the product moving forward, by
having early access to premium features and a direct feedback channel with the
MDN team.

Subscribing for a yearly plan activates a 20% discount for all the paid options.Can I upgrade/downgrade my plan?Currently, you can only upgrade your plan. For getting a downgrade, please
cancel your current subscription first and then activate the new one.What is happening with the existing MDN Web Docs?Nothing. We will continue to develop & maintain our web documentation that will
remain free and accessible for everyone. There will be no change there. Even
more, we believe that MDN Web Docs will benefit from MDN Plus, as we plan to
reinvest part of the gains from MDN Plus and improve our documentation as well
as the overall user experience on the website.Are we violating any OS license obligation by adding a paid product to MDN?MDN content is made available under a CC BY-SA 2.5 license. That license doesn't
preclude Mozilla (or other users of MDN content) from having a paid product. MDN
Plus adds premium features like updates and collections on top of the free
content. Regular users can still access and reuse MDN content under the Creative
Commons license.Where will the money from MDN Plus go?Since its beginning in 2005, MDN Web Docs has been a project hosted and provided
by Mozilla. Mozilla covers the cost of infrastructure, development and
maintenance of the MDN platform, including a team of engineers and its own team
of dedicated writers.
Mozilla wants MDN Plus to help ensure that MDN's open source content continues
to be supported into the future. MDN Plus has been built only with Mozilla
resources, and any revenue generated by MDN Plus will stay within Mozilla. We
are looking into ways to reinvest some of these additional funds into open
source projects contributing to MDN but it is still in the early stages.Does the launch of MDN Plus impact the relationship with partners like OWD?The existence of a new subscription model will not detract from MDN's current
free Web Docs offering in any way. The current experience of accessing web
documentation will not change for users who do not wish to sign up for a premium
subscription. Open Web Docs (OWD) and Mozilla will continue to work closely
together on MDN for the best possible web platform documentation for everyone.
For more information about how our organizations work together, please check
this article.What regions is MDN Plus available in?The free version of MDN Plus is available worldwide. Anyone can create an MDN
Plus account and try out a limited version of the premium features. As for the
paid plans, they are currently available as follows: in the United States,
Canada (since March 24th, 2022), Austria, Belgium, Finland, France, the United
Kingdom, Germany, Ireland, Italy, Malaysia, the Netherlands, New Zealand, Puerto
Rico, Sweden, Singapore, Switzerland, Spain (since April 28th, 2022), Estonia,
Greece, Latvia, Lithuania, Portugal, Slovakia and Slovenia (since June 15th,
2022). We are working on expanding this list even further.I have an idea for MDN Plus, who should I contact?In case you have an idea you would like to share about MDN Plus, you can add
your suggestions to our mdn-community
repo.
If a subscriber, you can also leave us feedback by accessing the ‘Feedback’
option in the user menu.\n\nFrequently asked questionsWhat is MDN Plus?MDN Plus is a premium subscription service launched in March 2022 by Mozilla.
The service allows users to customize their MDN Web Docs experience through
premium features such as Updates,
Collections and
MDN Offline.Why are we working on premium features on MDN?The extensive research we have done in 2020 and 2021 showed us that MDN users
would appreciate a customized experience on MDN. We’ve got information on what
you would find useful and what you would be interested in. All the premium
features we propose today reflect that feedback. MDN Plus is an initial step
towards making the experience on the site more interactive and helpful for our
users.How much does MDN Plus cost?A three-tiered pricing model has been put in place in order to try and
accommodate our users’ needs as much as possible:

MDN Core - A free plan, for those ones who want to try out a limited version
of the premium features.
MDN Plus 5 - A $5/month or $50/year plan that offers unlimited access to the
premium features included in MDN Plus.
MDN Supporter 10 - A $10/month or $100/year plan for users who want to
support MDN with a higher amount. On top of the MDN Plus premium features, MDN
supporters will be able to contribute and shape the product moving forward, by
having early access to premium features and a direct feedback channel with the
MDN team.

Subscribing for a yearly plan activates a 20% discount for all the paid options.Can I upgrade/downgrade my plan?Currently, you can only upgrade your plan. For getting a downgrade, please
cancel your current subscription first and then activate the new one.What is happening with the existing MDN Web Docs?Nothing. We will continue to develop & maintain our web documentation that will
remain free and accessible for everyone. There will be no change there. Even
more, we believe that MDN Web Docs will benefit from MDN Plus, as we plan to
reinvest part of the gains from MDN Plus and improve our documentation as well
as the overall user experience on the website.Are we violating any OS license obligation by adding a paid product to MDN?MDN content is made available under a CC BY-SA 2.5 license. That license doesn't
preclude Mozilla (or other users of MDN content) from having a paid product. MDN
Plus adds premium features like updates and collections on top of the free
content. Regular users can still access and reuse MDN content under the Creative
Commons license.Where will the money from MDN Plus go?Since its beginning in 2005, MDN Web Docs has been a project hosted and provided
by Mozilla. Mozilla covers the cost of infrastructure, development and
maintenance of the MDN platform, including a team of engineers and its own team
of dedicated writers.
Mozilla wants MDN Plus to help ensure that MDN's open source content continues
to be supported into the future. MDN Plus has been built only with Mozilla
resources, and any revenue generated by MDN Plus will stay within Mozilla. We
are looking into ways to reinvest some of these additional funds into open
source projects contributing to MDN but it is still in the early stages.Does the launch of MDN Plus impact the relationship with partners like OWD?The existence of a new subscription model will not detract from MDN's current
free Web Docs offering in any way. The current experience of accessing web
documentation will not change for users who do not wish to sign up for a premium
subscription. Open Web Docs (OWD) and Mozilla will continue to work closely
together on MDN for the best possible web platform documentation for everyone.
For more information about how our organizations work together, please check
this article.What regions is MDN Plus available in?The free version of MDN Plus is available worldwide. Anyone can create an MDN
Plus account and try out a limited version of the premium features. As for the
paid plans, they are currently available as follows: in the United States,
Canada (since March 24th, 2022), Austria, Belgium, Finland, France, the United
Kingdom, Germany, Ireland, Italy, Malaysia, the Netherlands, New Zealand, Puerto
Rico, Sweden, Singapore, Switzerland, Spain (since April 28th, 2022), Estonia,
Greece, Latvia, Lithuania, Portugal, Slovakia and Slovenia (since June 15th,
2022). We are working on expanding this list even further.I have an idea for MDN Plus, who should I contact?In case you have an idea you would like to share about MDN Plus, you can add
your suggestions to our mdn-community
repo.
If a subscriber, you can also leave us feedback by accessing the ‘Feedback’
option in the user menu.\n\n\n\nMDN CurriculumThe essential skillset for new front-end developersThe MDN Curriculum provides a structured guide to the essential skills and practices for being a successful front-end developer, along with recommended learning resources.
Last updated: February 2024About the curriculum
Beginner's level
Self-paced
Free

Defines the essential skills and knowledge every front-end developer needs for career success and industry relevance.
Created by Mozilla and refined with insights from students, educators, and developers from the broader web community.
Includes learning resource recommendations covering every curriculum topic, helping you become job-ready.
Learn moreLearn our curriculum with Scrimba's interactive Frontend Developer Career Path.ModulesGetting started1. Soft skillsDevelop a great attitude towards learning, researching, and collaborating to enhance your chances of success.Best Practices2. Environment setupFamiliarize yourself with your development environment and the tools you'll use to build websites.ToolingLet's beginCore1. Web standardsUnderstand how the web works at a high level, and the process for creating web technologies.Web Standards & Semantics2. Semantic HTMLLearn the fundamentals of HTML, the language used to define and structure web content.Web Standards & Semantics3. CSS fundamentalsDive into the fundamentals of CSS, the language you'll use to style and layout websites.Styling4. CSS text stylingFocus on using CSS to style text and apply custom web fonts.Styling5. CSS layoutLearn modern techniques for creating flexible layouts that work on a wide variety of devices.Styling6. JavaScript fundamentalsFocus on the core JavaScript language and fundamental surrounding topics.Scripting7. AccessibilityUnderstand the need for universal access to web content and how to write accessible code.Best Practices8. Design for developersAppreciate basic design theory, how to speak design language, and what makes websites look good.Best Practices9. Version controlUnderstand why version control is necessary, and use GitHub to store code and collaborate with others.ToolingLet's beginExtensions1. Transform & animate CSSAdd animations to your toolbox to enhance user experience and perceived performance.Web Standards & Semantics2. Custom JS objectsCreate custom JavaScript objects to gain a deeper understanding of object-oriented programming.Scripting3. Web APIsStudy common WebAPIs in depth to appreciate how WebAPIs work in general.Scripting4. PerformanceExplore how to create performant, fast-loading websites and enhance perceived performance.Best Practices5. Security and privacyLearn how to protect data from unauthorized access and how to treat user data responsibly.Best Practices6. TestingExplore the need for testing, and learn how to implement common test types.Best Practices7. JavaScript frameworksStudy the features of popular JavaScript frameworks, and use them to implement common use cases.Tooling8. CSS toolingLook at popular CSS tooling and understand what code problems they can solve.Tooling9. Other tooling typesUnderstand the purpose and usage of other tooling types commonly found in a web project.ToolingLet's beginLearn the curriculum with Scrimba and become job readyScrimba's Frontend Developer Career Path teaches the MDN Curriculum Core with fun interactive lessons and challenges, knowledgeable teachers, and a supportive community. Go from zero to landing your first front-end job!Find out moreHow can youboost your employability with the MDNCurriculum?Learn about research collaboration and other essential soft skills.Balance between modern tooling and long-term best practices.Get access to high-quality recommended resources.Get guidance from trusted voices.Don't know where toget started? 

Starting out with coding?
Begin with our "Getting started" and "Core" modules to grasp the essential skills for web development.
Core modules


Beyond the basics?
Dive deeper with our "Extensions" modules to develop specialized skills.
Extensions modules


Seeking employment?
Our "Soft skills" module, part of "Getting started", offers crucial insights to help you land your job.
Getting started modules


Working at a school?
Use our modules to guide your teaching, or enroll your students in Scrimba's Frontend Path.
Frontend Path\n\nMDN CurriculumThe essential skillset for new front-end developersThe MDN Curriculum provides a structured guide to the essential skills and practices for being a successful front-end developer, along with recommended learning resources.
Last updated: February 2024About the curriculum
Beginner's level
Self-paced
Free

Defines the essential skills and knowledge every front-end developer needs for career success and industry relevance.
Created by Mozilla and refined with insights from students, educators, and developers from the broader web community.
Includes learning resource recommendations covering every curriculum topic, helping you become job-ready.
Learn moreLearn our curriculum with Scrimba's interactive Frontend Developer Career Path.ModulesGetting started1. Soft skillsDevelop a great attitude towards learning, researching, and collaborating to enhance your chances of success.Best Practices2. Environment setupFamiliarize yourself with your development environment and the tools you'll use to build websites.ToolingLet's beginCore1. Web standardsUnderstand how the web works at a high level, and the process for creating web technologies.Web Standards & Semantics2. Semantic HTMLLearn the fundamentals of HTML, the language used to define and structure web content.Web Standards & Semantics3. CSS fundamentalsDive into the fundamentals of CSS, the language you'll use to style and layout websites.Styling4. CSS text stylingFocus on using CSS to style text and apply custom web fonts.Styling5. CSS layoutLearn modern techniques for creating flexible layouts that work on a wide variety of devices.Styling6. JavaScript fundamentalsFocus on the core JavaScript language and fundamental surrounding topics.Scripting7. AccessibilityUnderstand the need for universal access to web content and how to write accessible code.Best Practices8. Design for developersAppreciate basic design theory, how to speak design language, and what makes websites look good.Best Practices9. Version controlUnderstand why version control is necessary, and use GitHub to store code and collaborate with others.ToolingLet's beginExtensions1. Transform & animate CSSAdd animations to your toolbox to enhance user experience and perceived performance.Web Standards & Semantics2. Custom JS objectsCreate custom JavaScript objects to gain a deeper understanding of object-oriented programming.Scripting3. Web APIsStudy common WebAPIs in depth to appreciate how WebAPIs work in general.Scripting4. PerformanceExplore how to create performant, fast-loading websites and enhance perceived performance.Best Practices5. Security and privacyLearn how to protect data from unauthorized access and how to treat user data responsibly.Best Practices6. TestingExplore the need for testing, and learn how to implement common test types.Best Practices7. JavaScript frameworksStudy the features of popular JavaScript frameworks, and use them to implement common use cases.Tooling8. CSS toolingLook at popular CSS tooling and understand what code problems they can solve.Tooling9. Other tooling typesUnderstand the purpose and usage of other tooling types commonly found in a web project.ToolingLet's beginLearn the curriculum with Scrimba and become job readyScrimba's Frontend Developer Career Path teaches the MDN Curriculum Core with fun interactive lessons and challenges, knowledgeable teachers, and a supportive community. Go from zero to landing your first front-end job!Find out moreHow can youboost your employability with the MDNCurriculum?Learn about research collaboration and other essential soft skills.Balance between modern tooling and long-term best practices.Get access to high-quality recommended resources.Get guidance from trusted voices.Don't know where toget started? 

Starting out with coding?
Begin with our "Getting started" and "Core" modules to grasp the essential skills for web development.
Core modules


Beyond the basics?
Dive deeper with our "Extensions" modules to develop specialized skills.
Extensions modules


Seeking employment?
Our "Soft skills" module, part of "Getting started", offers crucial insights to help you land your job.
Getting started modules


Working at a school?
Use our modules to guide your teaching, or enroll your students in Scrimba's Frontend Path.
Frontend Path\n\nMDN CurriculumThe essential skillset for new front-end developersThe MDN Curriculum provides a structured guide to the essential skills and practices for being a successful front-end developer, along with recommended learning resources.
Last updated: February 2024About the curriculum
Beginner's level
Self-paced
Free

Defines the essential skills and knowledge every front-end developer needs for career success and industry relevance.
Created by Mozilla and refined with insights from students, educators, and developers from the broader web community.
Includes learning resource recommendations covering every curriculum topic, helping you become job-ready.
Learn moreLearn our curriculum with Scrimba's interactive Frontend Developer Career Path.ModulesGetting started1. Soft skillsDevelop a great attitude towards learning, researching, and collaborating to enhance your chances of success.Best Practices2. Environment setupFamiliarize yourself with your development environment and the tools you'll use to build websites.ToolingLet's beginCore1. Web standardsUnderstand how the web works at a high level, and the process for creating web technologies.Web Standards & Semantics2. Semantic HTMLLearn the fundamentals of HTML, the language used to define and structure web content.Web Standards & Semantics3. CSS fundamentalsDive into the fundamentals of CSS, the language you'll use to style and layout websites.Styling4. CSS text stylingFocus on using CSS to style text and apply custom web fonts.Styling5. CSS layoutLearn modern techniques for creating flexible layouts that work on a wide variety of devices.Styling6. JavaScript fundamentalsFocus on the core JavaScript language and fundamental surrounding topics.Scripting7. AccessibilityUnderstand the need for universal access to web content and how to write accessible code.Best Practices8. Design for developersAppreciate basic design theory, how to speak design language, and what makes websites look good.Best Practices9. Version controlUnderstand why version control is necessary, and use GitHub to store code and collaborate with others.ToolingLet's beginExtensions1. Transform & animate CSSAdd animations to your toolbox to enhance user experience and perceived performance.Web Standards & Semantics2. Custom JS objectsCreate custom JavaScript objects to gain a deeper understanding of object-oriented programming.Scripting3. Web APIsStudy common WebAPIs in depth to appreciate how WebAPIs work in general.Scripting4. PerformanceExplore how to create performant, fast-loading websites and enhance perceived performance.Best Practices5. Security and privacyLearn how to protect data from unauthorized access and how to treat user data responsibly.Best Practices6. TestingExplore the need for testing, and learn how to implement common test types.Best Practices7. JavaScript frameworksStudy the features of popular JavaScript frameworks, and use them to implement common use cases.Tooling8. CSS toolingLook at popular CSS tooling and understand what code problems they can solve.Tooling9. Other tooling typesUnderstand the purpose and usage of other tooling types commonly found in a web project.ToolingLet's beginLearn the curriculum with Scrimba and become job readyScrimba's Frontend Developer Career Path teaches the MDN Curriculum Core with fun interactive lessons and challenges, knowledgeable teachers, and a supportive community. Go from zero to landing your first front-end job!Find out moreHow can youboost your employability with the MDNCurriculum?Learn about research collaboration and other essential soft skills.Balance between modern tooling and long-term best practices.Get access to high-quality recommended resources.Get guidance from trusted voices.Don't know where toget started? 

Starting out with coding?
Begin with our "Getting started" and "Core" modules to grasp the essential skills for web development.
Core modules


Beyond the basics?
Dive deeper with our "Extensions" modules to develop specialized skills.
Extensions modules


Seeking employment?
Our "Soft skills" module, part of "Getting started", offers crucial insights to help you land your job.
Getting started modules


Working at a school?
Use our modules to guide your teaching, or enroll your students in Scrimba's Frontend Path.
Frontend Path\n\n\n\nDefault styles for h1 elements are changingSimon PietersApril 11, 20254 minute readBrowsers are starting to roll out changes in default UA styles for nested section headings. This post describes the incoming changes, how to identify if it's an issue on your websites, and hints for conformant and better-structured pages.
Read more →Implications of Global Privacy ControlLola OdelolaMarch 15, 20255 minute readGlobal Privacy Control (GPC) is on the way to becoming a formal privacy standard with the recent publication of its first working draft. Let's take a look at what the implications are for developers and users.Read more →JavaScript Temporal is comingBrian SmithJanuary 24, 20255 minute readA new way to handle dates and times is being added to JavaScript. Let's take a look at Temporal, what problems it solves, the current state, and what you'll find in the new documentation about it on MDN.
Read more →Fix your website's Largest Contentful Paint by optimizing image loadingDebugBearJanuary 13, 202510 minute readLearn techniques to improve the Largest Contentful Paint metric, a part of Core Web Vitals, for your website.
SponsoredRead more →MDN 2024 content projectsVadim MakeevJanuary 8, 20259 minute readLet's have a look at MDN Web Docs content projects in 2024, with highlights of our top picks and recommended reading, and at what's next on MDN for 2025.
Read more →A new learning experience on MDNRuth JohnDecember 20, 20244 minute readThere's a new Learn Web Development section on MDN that merges the MDN Curriculum with the Learn section. Here's the background to these changes, what's new, and what you can expect to see in the future.
Read more →Countdown to the holidays with daily coding challengesSonal SoodDecember 1, 20242 minute readJoin JavaScriptmas this December for daily coding challenges designed to boost your skills and bring festive fun. Solve challenges on Scrimba, learn something new, and take part for a chance to win exciting prizes!
Read more →Monitoring and optimizing website performanceDebugBearNovember 11, 202412 minute readLearn about reading network request waterfalls, identifying common network performance issues, and optimizing page rendering.
SponsoredRead more →How to land your first developer jobPer BorgenNovember 1, 202411 minute readHere are six effective strategies for landing your first developer job. These are especially relevant if you're self-taught or breaking into the tech industry without a traditional CS degree.
SponsoredRead more →Introducing the new MDN Community pagePranshu KhannaOctober 15, 20245 minute readWe are thrilled to announce the new MDN community page that will be a hub to recognize our contributors and a place for contributors to get involved.
Read more →Fixing your website's JavaScript performanceDebugBearOctober 9, 20249 minute readLearn about lesser-known web performance bottlenecks connected to excessive JavaScript usage, like long tasks, large bundle sizes, and hydration issues.
SponsoredRead more →Get back to school! Supercharge your learning with MDN and ScrimbaHermina CondeiSeptember 12, 20242 minute readFor many of us, the holidays are over, and the time has come to focus.  Now is an ideal time to dive into learning web development, and you're in luck — MDN and Scrimba are offering a 30% discount on select courses for the next month!
Read more →Efficient data handling with the Streams APIVultrSeptember 6, 20246 minute readThis post demonstrates how to use the Streams API in a web application to fetch and transform text on the fly.  By processing the data as it arrives, this approach enhances performance, responsiveness, and resource efficiency.
SponsoredRead more →Locale-sensitive text segmentation in JavaScript with Intl.SegmenterBrian SmithSeptember 3, 20245 minute readLearn how to use Intl.Segmenter for locale-sensitive text segmentation in JavaScript to simplify localization, count words or sentences in different languages, and more.Read more →Optimize your workflow with Git stashGitLabAugust 28, 20248 minute readLearn how to use Git stash to break down large commits. Discover a better approach for saving work when switching branches.SponsoredRead more →How to debug mobile apps across devicesLambdaTestAugust 7, 20248 minute readThis post explores what mobile app debugging is, commonly used techniques, and how you can debug mobile apps on multiple devices.SponsoredRead more →Exclusive accordions using the HTML details elementBrian SmithAugust 5, 20243 minute readThe 'name' attribute of the HTML details element is gaining more support across browsers. Learn how this feature allows creating exclusive accordions without scripting widgets from scratch.Read more →Exploring the Broadcast Channel API for cross-tab communicationVultrJuly 12, 20244 minute readThis article explains how to use the Broadcast Channel API to build synchronized and interconnected web applications.SponsoredRead more →MDN partners with Scrimba to enhance web development learningHermina CondeiJuly 9, 20246 minute readWe have chosen Scrimba as a course partner for the MDN Curriculum. This blog post explores what the partnership means practically, and how we will provide an even better web education experience together.Read more →Introducing the MDN HTTP ObservatoryHermina CondeiJuly 2, 20247 minute readFirst released in 2016, the HTTP Observatory became popular in the web community with a combination of helpful security audits and educational material. Fast forward to 2024, and we are delighted to announce that Observatory's new home is MDN. Read on to find out more about what this entails, and give the HTTP Observatory a warm welcome!Read more →Static Site Generation (SSG) with Next.jsVultrJune 28, 20247 minute readThis guide explains how to use Static Site Generation in Next.js to build scalable and secure web applications with fast loading times and a focus on performance.SponsoredRead more →New JavaScript Set methodsBrian SmithJune 24, 20245 minute readNew JavaScript Set methods are landing across browsers. Learn about sets, how you can use these methods to compare different sets, create new sets with specific properties, and more.Read more →Securing APIs: Express rate limit and slow downVultrMay 28, 20246 minute readThis guide introduces you to rate limits and slow down mechanisms. Learn how to apply slow down and rate limit mechanisms in Express applications.SponsoredRead more →Using the Page Visibility APIBrian SmithMay 10, 20246 minute readThis post takes a look at what page visibility is, how you can use the Page Visibility API in your applications, and describes pitfalls to avoid if you build features around this functionality.Read more →A year of publishing the MDN BlogThe MDN TeamMay 3, 20245 minute readWe've been writing about web development and the web platform on the MDN Blog since May 2023. Here's our highlights and top posts along with our favorites.Read more →Setting up service workers on VultrVultrApril 23, 20246 minute readThis guide introduces you to service workers and their lifecycle. Learn how to deploy a project using service workers with HTTPS on Vultr.SponsoredRead more →Interop 2023: MDN updatesBrian SmithMarch 27, 20246 minute readInterop 2023 has successfully concluded, and the Interop 2024 project is now officially underway. Learn what Interop is, discover the updates from Interop 2023 now on MDN, and find out what's coming to the web next.Read more →Testing JavaScript with Jest on VultrVultrMarch 22, 20247 minute readThis guide introduces you to the common types of tests and the testing conventions. Learn how to test JavaScript with Jest on Vultr.SponsoredRead more →Creating color palettes with the CSS color-mix() functionMichelle BarkerMarch 8, 20247 minute readWorking with colors on the web just got more interesting! In this article, we’ll explore how to use the CSS color-mix() function to create variations in color palettes.Read more →Modernizing conventional test automation with TestGridTestGridFebruary 29, 202412 minute readThis post reflects on the conventional test automation methods using Selenium and Appium. Learn how you can use TestGrid's unified testing platform to enhance the conventional methods and also leverage the modern codeless testing techniques.SponsoredRead more →Lift-off: The MDN Curriculum launchHermina CondeiFebruary 27, 20246 minute readThe long-awaited MDN Curriculum is now live on MDN, providing a structured guide to the essential front-end development skills and best practices for industry newcomers. Learn all the key details in this article.Read more →Creating effective technical documentationDipika BhattacharyaFebruary 13, 20247 minute readThis article provides an overview of the core components required for creating effective technical documentation. Learn the best practices to make your documentation clear, consistent, and well-structured.Read more →Leveraging Bun on Vultr: A superior Node.js alternativeVultrJanuary 17, 20245 minute readThis guide explains Bun functionalities as a runtime package manager and a bundler. It also explains the benefits of built-in Bun APIs and how to use Bun's Vultr marketplace application.SponsoredRead more →Border images in CSS: A key focus area for Interop 2023Dipika BhattacharyaDecember 19, 202310 minute readAligning with Interop 2023's emphasis on cross-browser consistency, this post walks you through various `border-image` properties that you can control to create captivating web designs. Learn how to use custom graphics for enhancing the look of your websites that appear consistent across different browsers.Read more →Build AI-powered applications using OpenLLM and Vultr Cloud GPUVultrDecember 12, 20237 minute readLearn how to build AI-powered apps using OpenLLM and Vultr Cloud GPU. This guide shows how to generate API responses using a Large Language Model. It also covers instructions for setting up an Nginx server and implementing SSL security.SponsoredRead more →Saying goodbye to third-party cookies in 2024Chris MillsDecember 8, 20238 minute readThe tail end of 2023 welcomes positive news for web privacy, as Chrome announces it is to join Firefox and Safari in deprecating third-party cookies in 2024. Find out more details about these changes, and what they mean for web developers.Read more →Baseline's evolution on MDNVadim MakeevDecember 5, 20234 minute readToday we're updating the Baseline widgets and introducing a new one, along with the updated definition of Baseline.Read more →Developer essentials: JavaScript console methodsBrian SmithNovember 30, 20236 minute readThe JavaScript console is an essential tool for web development. Learn new and fun ways to use the console to display data and debug your code.Read more →Getting started with CSS container queriesMichelle BarkerNovember 16, 20238 minute readCSS container queries are a powerful new tool for our CSS layout toolbox. In this post we'll dive into the practicalities of building a layout with container queries.Read more →Deploying Node.js applications with PM2 on VultrVultrNovember 8, 20237 minute readLearn how to deploy a Node.js application on Vultr using PM2 to create persistent services. This guide shows how to efficiently use resources via PM2 cluster mode. It also covers Nginx server setup and SSL security.SponsoredRead more →VS Code: Tips and tricks for beginnersDipika BhattacharyaNovember 7, 20238 minute readDiscover essential tips and tricks for using Visual Studio Code (VS Code), a powerful IDE. Learn how to leverage its integrated editing features and Git support, and explore a few extensions.Read more →Coming Soon: MDN Observatory 2.0The MDN TeamOctober 25, 20232 minute readObservatory 2.0 is launching soon as part of the Mozilla Developer Network as the MDN Observatory with new security scoring standards and other exciting updates.Read more →Optimizing DevSecOps workflows with GitLab's conditional CI/CD pipelinesGitLabOctober 23, 20238 minute readThis guide explores the various types of CI/CD pipelines and helps you understand their specific use cases. Learn how to leverage rules to create highly efficient DevSecOps workflows.SponsoredRead more →Introduction to web sustainabilityMichelle BarkerOctober 11, 20238 minute readWhat can web designers and developers do to build a more sustainable web? This post explores the environmental impacts of web technologies and looks at some of the ways we can build greener websites.Read more →Migrating from GitHub to GitLab seamlessly: A step-by-step guideGitLabOctober 5, 20239 minute readThinking about making the move from GitHub to GitLab? This guide demystifies the migration process, addressing common concerns for DevSecOps teams that are looking to seamlessly transition between the two platforms. This post provides a step-by-step guided tutorial on how to migrate your data from GitHub into GitLab.SponsoredRead more →Announcing the MDN front-end developer curriculumThe MDN TeamAugust 14, 20235 minute readMDN has created a curriculum for aspiring front-end developers to build a rewarding and successful career. Take a look at the curriculum, who it's for, and the research it's based on.Read more →Creating custom easing effects in CSS animations using the linear() functionMichelle BarkerAugust 1, 202310 minute readThe new CSS linear() timing function enables custom easing in animations. Explore how linear() works compared with other timing functions used for easing, with practical examples.Read more →Securing your CDN: Why and how should you use SRITerence EdenJuly 21, 20234 minute readRelying on external resources for your website is always fraught with risks. Learn how to protect your website and its visitors by using SRI to secure third-party content.Read more →Scroll progress animations in CSSMichelle BarkerJuly 14, 20237 minute readScroll-driven animations are coming to CSS! In this post, we'll look at a few types of animations and learn how to link them to the scroll progress of a container.Read more →Reflections on AI Explain: A postmortemThe MDN TeamJuly 11, 202310 minute readWe recently launched a feature called AI Explain, but we have rolled this back for now. In this post, we look into the story behind AI Explain: its development, launch, and the reasons that led us to press the pause button.Read more →Developer essentials: How to search code using grepBrian SmithJuly 3, 20239 minute readgrep is a powerful tool for searching code from the terminal. This post will show you how to use grep and why it's an essential developer tool.Read more →Introducing AI Help (Beta): Your Companion for Web DevelopmentHermina CondeiJune 27, 20233 minute readWe're introducing an AI assistant powered by MDN and OpenAI GPT 3.5 to answer all your web development questions in real time.Read more →Learn how to use hue in CSS colors with HSLBrian SmithJune 26, 20237 minute readHues are a bright way to define colors in CSS. Learn about hues, color wheels, how to use color functions, and how you can create vibrant color palettes for your website using hue.Read more →Introducing the MDN Playground: Bring your code to life!Florian DiemingerJune 22, 20236 minute readMDN is launching a code Playground. Users can prototype ideas and expand all live samples into an interactive experience.Read more →MDN doc updates: CSS selectors & media queries, WebGPU & WebTransport APIs, Progressive web appsDipika BhattacharyaJune 13, 20236 minute readDiscover CSS :lang(), experimental media queries, manipulating graphics with WebGPU, client-server communication with WebTransport, ECMAScript module support, and more.Read more →How to draw any regular shape with just one JavaScript functionRuth JohnMay 26, 20234 minute readLearn how to use JavaScript to draw any regular shape to a HTML canvas with a single function, and how to modify it to draw multiple shapes.Read more →New reference pages on MDN for JavaScript regular expressionsBrian SmithMay 23, 20235 minute readSee the latest updates to the MDN reference pages about JavaScript regular expressions, including new sections on sub-features and browser compatibility information.Read more →Celebrating Global Accessibility Awareness DaySchalk NeethlingMay 18, 20236 minute readIn celebration of Global Accessibility Awareness Day in 2023, we share some tools and guidelines to help you make the web more accessible.Read more →Using HTML landmark roles to improve accessibilitySchalk NeethlingMay 15, 202311 minute readLearn what HTML landmark roles are, how they improve accessibility, and how you can include them on your website effectively.Read more →Introducing Baseline: a unified view of stable web featuresHermina CondeiMay 10, 20233 minute readMDN leads the way in implementing WebDX community group's efforts, delivering a clear and simple baseline for the web platform to developers.Read more →How :not() chains multiple selectorsDipika BhattacharyaMay 5, 20234 minute readLearn how the CSS `:not()` pseudo-class behaves when multiple selectors are passed as argument.Read more →New functions, gradients, and hues in CSS colors (Level 4)Brian SmithMay 3, 20239 minute readLearn what's new in CSS Colors Module Level 4, including color spaces, color functions, fancy gradients, and support for wide-gamut displays.Read more →Welcome to the MDN blogRuth JohnMay 3, 20232 minute readThe MDN blog publishes web development news, tutorials, and insights as an extension of MDN Web Docs, helping you discover, learn, and create for the web.Read more →\n\nBlog it betterDefault styles for h1 elements are changingSimon PietersApril 11, 20254 minute readBrowsers are starting to roll out changes in default UA styles for nested section headings. This post describes the incoming changes, how to identify if it's an issue on your websites, and hints for conformant and better-structured pages.
Read more →Implications of Global Privacy ControlLola OdelolaMarch 15, 20255 minute readGlobal Privacy Control (GPC) is on the way to becoming a formal privacy standard with the recent publication of its first working draft. Let's take a look at what the implications are for developers and users.Read more →JavaScript Temporal is comingBrian SmithJanuary 24, 20255 minute readA new way to handle dates and times is being added to JavaScript. Let's take a look at Temporal, what problems it solves, the current state, and what you'll find in the new documentation about it on MDN.
Read more →Fix your website's Largest Contentful Paint by optimizing image loadingDebugBearJanuary 13, 202510 minute readLearn techniques to improve the Largest Contentful Paint metric, a part of Core Web Vitals, for your website.
SponsoredRead more →MDN 2024 content projectsVadim MakeevJanuary 8, 20259 minute readLet's have a look at MDN Web Docs content projects in 2024, with highlights of our top picks and recommended reading, and at what's next on MDN for 2025.
Read more →A new learning experience on MDNRuth JohnDecember 20, 20244 minute readThere's a new Learn Web Development section on MDN that merges the MDN Curriculum with the Learn section. Here's the background to these changes, what's new, and what you can expect to see in the future.
Read more →Countdown to the holidays with daily coding challengesSonal SoodDecember 1, 20242 minute readJoin JavaScriptmas this December for daily coding challenges designed to boost your skills and bring festive fun. Solve challenges on Scrimba, learn something new, and take part for a chance to win exciting prizes!
Read more →Monitoring and optimizing website performanceDebugBearNovember 11, 202412 minute readLearn about reading network request waterfalls, identifying common network performance issues, and optimizing page rendering.
SponsoredRead more →How to land your first developer jobPer BorgenNovember 1, 202411 minute readHere are six effective strategies for landing your first developer job. These are especially relevant if you're self-taught or breaking into the tech industry without a traditional CS degree.
SponsoredRead more →Introducing the new MDN Community pagePranshu KhannaOctober 15, 20245 minute readWe are thrilled to announce the new MDN community page that will be a hub to recognize our contributors and a place for contributors to get involved.
Read more →Fixing your website's JavaScript performanceDebugBearOctober 9, 20249 minute readLearn about lesser-known web performance bottlenecks connected to excessive JavaScript usage, like long tasks, large bundle sizes, and hydration issues.
SponsoredRead more →Get back to school! Supercharge your learning with MDN and ScrimbaHermina CondeiSeptember 12, 20242 minute readFor many of us, the holidays are over, and the time has come to focus.  Now is an ideal time to dive into learning web development, and you're in luck — MDN and Scrimba are offering a 30% discount on select courses for the next month!
Read more →Efficient data handling with the Streams APIVultrSeptember 6, 20246 minute readThis post demonstrates how to use the Streams API in a web application to fetch and transform text on the fly.  By processing the data as it arrives, this approach enhances performance, responsiveness, and resource efficiency.
SponsoredRead more →Locale-sensitive text segmentation in JavaScript with Intl.SegmenterBrian SmithSeptember 3, 20245 minute readLearn how to use Intl.Segmenter for locale-sensitive text segmentation in JavaScript to simplify localization, count words or sentences in different languages, and more.Read more →Optimize your workflow with Git stashGitLabAugust 28, 20248 minute readLearn how to use Git stash to break down large commits. Discover a better approach for saving work when switching branches.SponsoredRead more →How to debug mobile apps across devicesLambdaTestAugust 7, 20248 minute readThis post explores what mobile app debugging is, commonly used techniques, and how you can debug mobile apps on multiple devices.SponsoredRead more →Exclusive accordions using the HTML details elementBrian SmithAugust 5, 20243 minute readThe 'name' attribute of the HTML details element is gaining more support across browsers. Learn how this feature allows creating exclusive accordions without scripting widgets from scratch.Read more →Exploring the Broadcast Channel API for cross-tab communicationVultrJuly 12, 20244 minute readThis article explains how to use the Broadcast Channel API to build synchronized and interconnected web applications.SponsoredRead more →MDN partners with Scrimba to enhance web development learningHermina CondeiJuly 9, 20246 minute readWe have chosen Scrimba as a course partner for the MDN Curriculum. This blog post explores what the partnership means practically, and how we will provide an even better web education experience together.Read more →Introducing the MDN HTTP ObservatoryHermina CondeiJuly 2, 20247 minute readFirst released in 2016, the HTTP Observatory became popular in the web community with a combination of helpful security audits and educational material. Fast forward to 2024, and we are delighted to announce that Observatory's new home is MDN. Read on to find out more about what this entails, and give the HTTP Observatory a warm welcome!Read more →Static Site Generation (SSG) with Next.jsVultrJune 28, 20247 minute readThis guide explains how to use Static Site Generation in Next.js to build scalable and secure web applications with fast loading times and a focus on performance.SponsoredRead more →New JavaScript Set methodsBrian SmithJune 24, 20245 minute readNew JavaScript Set methods are landing across browsers. Learn about sets, how you can use these methods to compare different sets, create new sets with specific properties, and more.Read more →Securing APIs: Express rate limit and slow downVultrMay 28, 20246 minute readThis guide introduces you to rate limits and slow down mechanisms. Learn how to apply slow down and rate limit mechanisms in Express applications.SponsoredRead more →Using the Page Visibility APIBrian SmithMay 10, 20246 minute readThis post takes a look at what page visibility is, how you can use the Page Visibility API in your applications, and describes pitfalls to avoid if you build features around this functionality.Read more →A year of publishing the MDN BlogThe MDN TeamMay 3, 20245 minute readWe've been writing about web development and the web platform on the MDN Blog since May 2023. Here's our highlights and top posts along with our favorites.Read more →Setting up service workers on VultrVultrApril 23, 20246 minute readThis guide introduces you to service workers and their lifecycle. Learn how to deploy a project using service workers with HTTPS on Vultr.SponsoredRead more →Interop 2023: MDN updatesBrian SmithMarch 27, 20246 minute readInterop 2023 has successfully concluded, and the Interop 2024 project is now officially underway. Learn what Interop is, discover the updates from Interop 2023 now on MDN, and find out what's coming to the web next.Read more →Testing JavaScript with Jest on VultrVultrMarch 22, 20247 minute readThis guide introduces you to the common types of tests and the testing conventions. Learn how to test JavaScript with Jest on Vultr.SponsoredRead more →Creating color palettes with the CSS color-mix() functionMichelle BarkerMarch 8, 20247 minute readWorking with colors on the web just got more interesting! In this article, we’ll explore how to use the CSS color-mix() function to create variations in color palettes.Read more →Modernizing conventional test automation with TestGridTestGridFebruary 29, 202412 minute readThis post reflects on the conventional test automation methods using Selenium and Appium. Learn how you can use TestGrid's unified testing platform to enhance the conventional methods and also leverage the modern codeless testing techniques.SponsoredRead more →Lift-off: The MDN Curriculum launchHermina CondeiFebruary 27, 20246 minute readThe long-awaited MDN Curriculum is now live on MDN, providing a structured guide to the essential front-end development skills and best practices for industry newcomers. Learn all the key details in this article.Read more →Creating effective technical documentationDipika BhattacharyaFebruary 13, 20247 minute readThis article provides an overview of the core components required for creating effective technical documentation. Learn the best practices to make your documentation clear, consistent, and well-structured.Read more →Leveraging Bun on Vultr: A superior Node.js alternativeVultrJanuary 17, 20245 minute readThis guide explains Bun functionalities as a runtime package manager and a bundler. It also explains the benefits of built-in Bun APIs and how to use Bun's Vultr marketplace application.SponsoredRead more →Border images in CSS: A key focus area for Interop 2023Dipika BhattacharyaDecember 19, 202310 minute readAligning with Interop 2023's emphasis on cross-browser consistency, this post walks you through various `border-image` properties that you can control to create captivating web designs. Learn how to use custom graphics for enhancing the look of your websites that appear consistent across different browsers.Read more →Build AI-powered applications using OpenLLM and Vultr Cloud GPUVultrDecember 12, 20237 minute readLearn how to build AI-powered apps using OpenLLM and Vultr Cloud GPU. This guide shows how to generate API responses using a Large Language Model. It also covers instructions for setting up an Nginx server and implementing SSL security.SponsoredRead more →Saying goodbye to third-party cookies in 2024Chris MillsDecember 8, 20238 minute readThe tail end of 2023 welcomes positive news for web privacy, as Chrome announces it is to join Firefox and Safari in deprecating third-party cookies in 2024. Find out more details about these changes, and what they mean for web developers.Read more →Baseline's evolution on MDNVadim MakeevDecember 5, 20234 minute readToday we're updating the Baseline widgets and introducing a new one, along with the updated definition of Baseline.Read more →Developer essentials: JavaScript console methodsBrian SmithNovember 30, 20236 minute readThe JavaScript console is an essential tool for web development. Learn new and fun ways to use the console to display data and debug your code.Read more →Getting started with CSS container queriesMichelle BarkerNovember 16, 20238 minute readCSS container queries are a powerful new tool for our CSS layout toolbox. In this post we'll dive into the practicalities of building a layout with container queries.Read more →Deploying Node.js applications with PM2 on VultrVultrNovember 8, 20237 minute readLearn how to deploy a Node.js application on Vultr using PM2 to create persistent services. This guide shows how to efficiently use resources via PM2 cluster mode. It also covers Nginx server setup and SSL security.SponsoredRead more →VS Code: Tips and tricks for beginnersDipika BhattacharyaNovember 7, 20238 minute readDiscover essential tips and tricks for using Visual Studio Code (VS Code), a powerful IDE. Learn how to leverage its integrated editing features and Git support, and explore a few extensions.Read more →Coming Soon: MDN Observatory 2.0The MDN TeamOctober 25, 20232 minute readObservatory 2.0 is launching soon as part of the Mozilla Developer Network as the MDN Observatory with new security scoring standards and other exciting updates.Read more →Optimizing DevSecOps workflows with GitLab's conditional CI/CD pipelinesGitLabOctober 23, 20238 minute readThis guide explores the various types of CI/CD pipelines and helps you understand their specific use cases. Learn how to leverage rules to create highly efficient DevSecOps workflows.SponsoredRead more →Introduction to web sustainabilityMichelle BarkerOctober 11, 20238 minute readWhat can web designers and developers do to build a more sustainable web? This post explores the environmental impacts of web technologies and looks at some of the ways we can build greener websites.Read more →Migrating from GitHub to GitLab seamlessly: A step-by-step guideGitLabOctober 5, 20239 minute readThinking about making the move from GitHub to GitLab? This guide demystifies the migration process, addressing common concerns for DevSecOps teams that are looking to seamlessly transition between the two platforms. This post provides a step-by-step guided tutorial on how to migrate your data from GitHub into GitLab.SponsoredRead more →Announcing the MDN front-end developer curriculumThe MDN TeamAugust 14, 20235 minute readMDN has created a curriculum for aspiring front-end developers to build a rewarding and successful career. Take a look at the curriculum, who it's for, and the research it's based on.Read more →Creating custom easing effects in CSS animations using the linear() functionMichelle BarkerAugust 1, 202310 minute readThe new CSS linear() timing function enables custom easing in animations. Explore how linear() works compared with other timing functions used for easing, with practical examples.Read more →Securing your CDN: Why and how should you use SRITerence EdenJuly 21, 20234 minute readRelying on external resources for your website is always fraught with risks. Learn how to protect your website and its visitors by using SRI to secure third-party content.Read more →Scroll progress animations in CSSMichelle BarkerJuly 14, 20237 minute readScroll-driven animations are coming to CSS! In this post, we'll look at a few types of animations and learn how to link them to the scroll progress of a container.Read more →Reflections on AI Explain: A postmortemThe MDN TeamJuly 11, 202310 minute readWe recently launched a feature called AI Explain, but we have rolled this back for now. In this post, we look into the story behind AI Explain: its development, launch, and the reasons that led us to press the pause button.Read more →Developer essentials: How to search code using grepBrian SmithJuly 3, 20239 minute readgrep is a powerful tool for searching code from the terminal. This post will show you how to use grep and why it's an essential developer tool.Read more →Introducing AI Help (Beta): Your Companion for Web DevelopmentHermina CondeiJune 27, 20233 minute readWe're introducing an AI assistant powered by MDN and OpenAI GPT 3.5 to answer all your web development questions in real time.Read more →Learn how to use hue in CSS colors with HSLBrian SmithJune 26, 20237 minute readHues are a bright way to define colors in CSS. Learn about hues, color wheels, how to use color functions, and how you can create vibrant color palettes for your website using hue.Read more →Introducing the MDN Playground: Bring your code to life!Florian DiemingerJune 22, 20236 minute readMDN is launching a code Playground. Users can prototype ideas and expand all live samples into an interactive experience.Read more →MDN doc updates: CSS selectors & media queries, WebGPU & WebTransport APIs, Progressive web appsDipika BhattacharyaJune 13, 20236 minute readDiscover CSS :lang(), experimental media queries, manipulating graphics with WebGPU, client-server communication with WebTransport, ECMAScript module support, and more.Read more →How to draw any regular shape with just one JavaScript functionRuth JohnMay 26, 20234 minute readLearn how to use JavaScript to draw any regular shape to a HTML canvas with a single function, and how to modify it to draw multiple shapes.Read more →New reference pages on MDN for JavaScript regular expressionsBrian SmithMay 23, 20235 minute readSee the latest updates to the MDN reference pages about JavaScript regular expressions, including new sections on sub-features and browser compatibility information.Read more →Celebrating Global Accessibility Awareness DaySchalk NeethlingMay 18, 20236 minute readIn celebration of Global Accessibility Awareness Day in 2023, we share some tools and guidelines to help you make the web more accessible.Read more →Using HTML landmark roles to improve accessibilitySchalk NeethlingMay 15, 202311 minute readLearn what HTML landmark roles are, how they improve accessibility, and how you can include them on your website effectively.Read more →Introducing Baseline: a unified view of stable web featuresHermina CondeiMay 10, 20233 minute readMDN leads the way in implementing WebDX community group's efforts, delivering a clear and simple baseline for the web platform to developers.Read more →How :not() chains multiple selectorsDipika BhattacharyaMay 5, 20234 minute readLearn how the CSS `:not()` pseudo-class behaves when multiple selectors are passed as argument.Read more →New functions, gradients, and hues in CSS colors (Level 4)Brian SmithMay 3, 20239 minute readLearn what's new in CSS Colors Module Level 4, including color spaces, color functions, fancy gradients, and support for wide-gamut displays.Read more →Welcome to the MDN blogRuth JohnMay 3, 20232 minute readThe MDN blog publishes web development news, tutorials, and insights as an extension of MDN Web Docs, helping you discover, learn, and create for the web.Read more →\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nJavaScript referenceThe JavaScript reference serves as a repository of facts about the JavaScript language. The entire language is described here in detail. As you write JavaScript code, you'll refer to these pages often (thus the title "JavaScript reference").
The JavaScript language is intended to be used within some larger environment, be it a browser, server-side scripts, or similar. For the most part, this reference attempts to be environment-agnostic and does not target a web browser environment.
If you are new to JavaScript, start with the guide. Once you have a firm grasp of the fundamentals, you can use the reference to get more details on individual objects and language constructs.Built-insJavaScript standard built-in objects, along with their methods and properties.Value properties
globalThis
Infinity
NaN
undefined
Function properties
eval()
isFinite()
isNaN()
parseFloat()
parseInt()
decodeURI()
decodeURIComponent()
encodeURI()
encodeURIComponent()
escape() 
Deprecated

unescape() 
Deprecated

Fundamental objects
Object
Function
Boolean
Symbol
Error objects
Error
AggregateError
EvalError
RangeError
ReferenceError
SyntaxError
TypeError
URIError
InternalError 
Non-standard

Numbers and dates
Number
BigInt
Math
Date
Temporal
Text processing
String
RegExp
Indexed collections
Array
Int8Array
Uint8Array
Uint8ClampedArray
Int16Array
Uint16Array
Int32Array
Uint32Array
BigInt64Array
BigUint64Array
Float16Array
Float32Array
Float64Array
Keyed collections
Map
Set
WeakMap
WeakSet
Structured data
ArrayBuffer
SharedArrayBuffer
DataView
Atomics
JSON
Managing memory
WeakRef
FinalizationRegistry
Control abstraction objects
Iterator
AsyncIterator
Promise
GeneratorFunction
AsyncGeneratorFunction
Generator
AsyncGenerator
AsyncFunction
Reflection
Reflect
Proxy
Internationalization
Intl
Intl.Collator
Intl.DateTimeFormat
Intl.DisplayNames
Intl.DurationFormat
Intl.ListFormat
Intl.Locale
Intl.NumberFormat
Intl.PluralRules
Intl.RelativeTimeFormat
Intl.Segmenter
StatementsJavaScript statements and declarationsControl flow
return
break
continue
throw
if...else
switch
try...catch
Declaring variables
var
let
const
Functions and classes
function
function*
async function
async function*
class
Iterations
do...while
for
for...in
for...of
for await...of
while
Others
Empty
Block
Expression statement
debugger
export
import
label
with 
Deprecated

Expressions and operatorsJavaScript expressions and operators.Primary expressions
this
Literals
[]
{}
function
class
function*
async function
async function*
/ab+c/i
`string`
( )
Left-hand-side expressions
Property accessors
?.
new
new.target
import.meta
super
import()
Increment and decrement
A++
A--
++A
--A
Unary operators
delete
void
typeof
+
-
~
!
await
Arithmetic operators
**
*
/
%
+ (Plus)
-
Relational operators
< (Less than)
> (Greater than)
<=
>=
instanceof
in
Equality operators
==
!=
===
!==
Bitwise shift operators
<<
>>
>>>
Binary bitwise operators
&
|
^
Binary logical operators
&&
||
??
Conditional (ternary) operator
(condition ? ifTrue : ifFalse)
Assignment operators
=
*=
/=
%=
+=
-=
<<=
>>=
>>>=
&=
^=
|=
**=
&&=
||=
??=
[a, b] = arr, { a, b } = obj
Yield operators
yield
yield*
Spread syntax
...obj
Comma operator
,
FunctionsJavaScript functions.

Arrow Functions
Default parameters
Rest parameters
arguments
Method definitions
getter
setter
ClassesJavaScript classes.

constructor
extends
Private properties
Public class fields
static
Static initialization blocks
Regular expressionsJavaScript regular expressions.

Backreference: \1, \2
Capturing group: (...)
Character class: [...], [^...]
Character class escape: \d, \D, \w, \W,  , \S
Character escape: \n, \u{...}
Disjunction: |
Input boundary assertion: ^, $
Literal character: a, b
Lookahead assertion: (?=...), (?!...)
Lookbehind assertion: (?<=...), (?<!...)
Modifier: (?ims-ims:...)
Named backreference: \k<name>
Named capturing group: (?<name>...)
Non-capturing group: (?:...)
Quantifier: *, +, ?, {n}, {n,}, {n,m}
Unicode character class escape: \p{...}, \P{...}
Wildcard: .
Word boundary assertion: \b, \B
Additional reference pages
Execution model
Lexical grammar
Data types and data structures
Iteration protocols
Trailing commas
Errors
Strict mode
Deprecated features\n\nJavaScript referenceThe JavaScript reference serves as a repository of facts about the JavaScript language. The entire language is described here in detail. As you write JavaScript code, you'll refer to these pages often (thus the title "JavaScript reference").
The JavaScript language is intended to be used within some larger environment, be it a browser, server-side scripts, or similar. For the most part, this reference attempts to be environment-agnostic and does not target a web browser environment.
If you are new to JavaScript, start with the guide. Once you have a firm grasp of the fundamentals, you can use the reference to get more details on individual objects and language constructs.Built-insJavaScript standard built-in objects, along with their methods and properties.Value properties
globalThis
Infinity
NaN
undefined
Function properties
eval()
isFinite()
isNaN()
parseFloat()
parseInt()
decodeURI()
decodeURIComponent()
encodeURI()
encodeURIComponent()
escape() 
Deprecated

unescape() 
Deprecated

Fundamental objects
Object
Function
Boolean
Symbol
Error objects
Error
AggregateError
EvalError
RangeError
ReferenceError
SyntaxError
TypeError
URIError
InternalError 
Non-standard

Numbers and dates
Number
BigInt
Math
Date
Temporal
Text processing
String
RegExp
Indexed collections
Array
Int8Array
Uint8Array
Uint8ClampedArray
Int16Array
Uint16Array
Int32Array
Uint32Array
BigInt64Array
BigUint64Array
Float16Array
Float32Array
Float64Array
Keyed collections
Map
Set
WeakMap
WeakSet
Structured data
ArrayBuffer
SharedArrayBuffer
DataView
Atomics
JSON
Managing memory
WeakRef
FinalizationRegistry
Control abstraction objects
Iterator
AsyncIterator
Promise
GeneratorFunction
AsyncGeneratorFunction
Generator
AsyncGenerator
AsyncFunction
Reflection
Reflect
Proxy
Internationalization
Intl
Intl.Collator
Intl.DateTimeFormat
Intl.DisplayNames
Intl.DurationFormat
Intl.ListFormat
Intl.Locale
Intl.NumberFormat
Intl.PluralRules
Intl.RelativeTimeFormat
Intl.Segmenter
StatementsJavaScript statements and declarationsControl flow
return
break
continue
throw
if...else
switch
try...catch
Declaring variables
var
let
const
Functions and classes
function
function*
async function
async function*
class
Iterations
do...while
for
for...in
for...of
for await...of
while
Others
Empty
Block
Expression statement
debugger
export
import
label
with 
Deprecated

Expressions and operatorsJavaScript expressions and operators.Primary expressions
this
Literals
[]
{}
function
class
function*
async function
async function*
/ab+c/i
`string`
( )
Left-hand-side expressions
Property accessors
?.
new
new.target
import.meta
super
import()
Increment and decrement
A++
A--
++A
--A
Unary operators
delete
void
typeof
+
-
~
!
await
Arithmetic operators
**
*
/
%
+ (Plus)
-
Relational operators
< (Less than)
> (Greater than)
<=
>=
instanceof
in
Equality operators
==
!=
===
!==
Bitwise shift operators
<<
>>
>>>
Binary bitwise operators
&
|
^
Binary logical operators
&&
||
??
Conditional (ternary) operator
(condition ? ifTrue : ifFalse)
Assignment operators
=
*=
/=
%=
+=
-=
<<=
>>=
>>>=
&=
^=
|=
**=
&&=
||=
??=
[a, b] = arr, { a, b } = obj
Yield operators
yield
yield*
Spread syntax
...obj
Comma operator
,
FunctionsJavaScript functions.

Arrow Functions
Default parameters
Rest parameters
arguments
Method definitions
getter
setter
ClassesJavaScript classes.

constructor
extends
Private properties
Public class fields
static
Static initialization blocks
Regular expressionsJavaScript regular expressions.

Backreference: \1, \2
Capturing group: (...)
Character class: [...], [^...]
Character class escape: \d, \D, \w, \W,  , \S
Character escape: \n, \u{...}
Disjunction: |
Input boundary assertion: ^, $
Literal character: a, b
Lookahead assertion: (?=...), (?!...)
Lookbehind assertion: (?<=...), (?<!...)
Modifier: (?ims-ims:...)
Named backreference: \k<name>
Named capturing group: (?<name>...)
Non-capturing group: (?:...)
Quantifier: *, +, ?, {n}, {n,}, {n,m}
Unicode character class escape: \p{...}, \P{...}
Wildcard: .
Word boundary assertion: \b, \B
Additional reference pages
Execution model
Lexical grammar
Data types and data structures
Iteration protocols
Trailing commas
Errors
Strict mode
Deprecated features
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 7, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJavaScript referenceThe JavaScript reference serves as a repository of facts about the JavaScript language. The entire language is described here in detail. As you write JavaScript code, you'll refer to these pages often (thus the title "JavaScript reference").
The JavaScript language is intended to be used within some larger environment, be it a browser, server-side scripts, or similar. For the most part, this reference attempts to be environment-agnostic and does not target a web browser environment.
If you are new to JavaScript, start with the guide. Once you have a firm grasp of the fundamentals, you can use the reference to get more details on individual objects and language constructs.Built-insJavaScript standard built-in objects, along with their methods and properties.Value properties
globalThis
Infinity
NaN
undefined
Function properties
eval()
isFinite()
isNaN()
parseFloat()
parseInt()
decodeURI()
decodeURIComponent()
encodeURI()
encodeURIComponent()
escape() 
Deprecated

unescape() 
Deprecated

Fundamental objects
Object
Function
Boolean
Symbol
Error objects
Error
AggregateError
EvalError
RangeError
ReferenceError
SyntaxError
TypeError
URIError
InternalError 
Non-standard

Numbers and dates
Number
BigInt
Math
Date
Temporal
Text processing
String
RegExp
Indexed collections
Array
Int8Array
Uint8Array
Uint8ClampedArray
Int16Array
Uint16Array
Int32Array
Uint32Array
BigInt64Array
BigUint64Array
Float16Array
Float32Array
Float64Array
Keyed collections
Map
Set
WeakMap
WeakSet
Structured data
ArrayBuffer
SharedArrayBuffer
DataView
Atomics
JSON
Managing memory
WeakRef
FinalizationRegistry
Control abstraction objects
Iterator
AsyncIterator
Promise
GeneratorFunction
AsyncGeneratorFunction
Generator
AsyncGenerator
AsyncFunction
Reflection
Reflect
Proxy
Internationalization
Intl
Intl.Collator
Intl.DateTimeFormat
Intl.DisplayNames
Intl.DurationFormat
Intl.ListFormat
Intl.Locale
Intl.NumberFormat
Intl.PluralRules
Intl.RelativeTimeFormat
Intl.Segmenter
StatementsJavaScript statements and declarationsControl flow
return
break
continue
throw
if...else
switch
try...catch
Declaring variables
var
let
const
Functions and classes
function
function*
async function
async function*
class
Iterations
do...while
for
for...in
for...of
for await...of
while
Others
Empty
Block
Expression statement
debugger
export
import
label
with 
Deprecated

Expressions and operatorsJavaScript expressions and operators.Primary expressions
this
Literals
[]
{}
function
class
function*
async function
async function*
/ab+c/i
`string`
( )
Left-hand-side expressions
Property accessors
?.
new
new.target
import.meta
super
import()
Increment and decrement
A++
A--
++A
--A
Unary operators
delete
void
typeof
+
-
~
!
await
Arithmetic operators
**
*
/
%
+ (Plus)
-
Relational operators
< (Less than)
> (Greater than)
<=
>=
instanceof
in
Equality operators
==
!=
===
!==
Bitwise shift operators
<<
>>
>>>
Binary bitwise operators
&
|
^
Binary logical operators
&&
||
??
Conditional (ternary) operator
(condition ? ifTrue : ifFalse)
Assignment operators
=
*=
/=
%=
+=
-=
<<=
>>=
>>>=
&=
^=
|=
**=
&&=
||=
??=
[a, b] = arr, { a, b } = obj
Yield operators
yield
yield*
Spread syntax
...obj
Comma operator
,
FunctionsJavaScript functions.

Arrow Functions
Default parameters
Rest parameters
arguments
Method definitions
getter
setter
ClassesJavaScript classes.

constructor
extends
Private properties
Public class fields
static
Static initialization blocks
Regular expressionsJavaScript regular expressions.

Backreference: \1, \2
Capturing group: (...)
Character class: [...], [^...]
Character class escape: \d, \D, \w, \W,  , \S
Character escape: \n, \u{...}
Disjunction: |
Input boundary assertion: ^, $
Literal character: a, b
Lookahead assertion: (?=...), (?!...)
Lookbehind assertion: (?<=...), (?<!...)
Modifier: (?ims-ims:...)
Named backreference: \k<name>
Named capturing group: (?<name>...)
Non-capturing group: (?:...)
Quantifier: *, +, ?, {n}, {n,}, {n,m}
Unicode character class escape: \p{...}, \P{...}
Wildcard: .
Word boundary assertion: \b, \B
Additional reference pages
Execution model
Lexical grammar
Data types and data structures
Iteration protocols
Trailing commas
Errors
Strict mode
Deprecated features
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 7, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nTemplate Literale (Vorlagen-Strings)Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackTemplate Literale sind Literale, die durch Backticks (`) begrenzt sind. Sie ermöglichen mehrzeilige Strings, String-Interpolation mit eingebetteten Ausdrücken und spezielle Konstrukte, die als getaggte Templates bezeichnet werden.
Template Literale werden manchmal informell Vorlagen-Strings genannt, da sie am häufigsten für die String-Interpolation verwendet werden (um Strings zu erzeugen, indem Platzhalter ersetzt werden). Ein getaggtes Template Literal muss jedoch nicht zu einem String führen; es kann mit einer benutzerdefinierten Tag-Funktion verwendet werden, um beliebige Operationen auf den verschiedenen Teilen des Template Literals auszuführen.Syntaxjs`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tagFunction`string text ${expression} string text`
Parameter
string text

Der String-Text, der Teil des Template Literals wird. Fast alle Zeichen sind buchstäblich erlaubt, einschließlich Zeilenumbrüche und anderer Leerzeichen. Ungültige Escape-Sequenzen führen jedoch zu einem Syntaxfehler, es sei denn, es wird eine Tag-Funktion verwendet.

expression

Ein Ausdruck, der an der aktuellen Position eingefügt wird, dessen Wert in einen String umgewandelt oder an tagFunction übergeben wird.

tagFunction

Wenn angegeben, wird diese mit dem Array der Template-Strings und den Ersetzungsausdrücken aufgerufen, und der Rückgabewert wird zum Wert des Template Literals. Siehe getaggte Templates.

BeschreibungTemplate Literale sind in Backtick-Zeichen (`) eingeschlossen, anstatt in doppelten oder einfachen Anführungszeichen.
Neben normalen Strings können Template Literale auch andere Teile enthalten, die Platzhalter genannt werden. Diese sind eingebettete Ausdrücke, die durch ein Dollarzeichen und geschweifte Klammern begrenzt sind: ${expression}. Die Strings und Platzhalter werden an eine Funktion übergeben – entweder eine Standardfunktion oder eine von Ihnen bereitgestellte Funktion. Die Standardfunktion (wenn Sie keine eigene bereitstellen) führt nur die String-Interpolation durch, um die Platzhalter zu ersetzen und die Teile dann zu einem einzelnen String zu verketten.
Um eine eigene Funktion bereitzustellen, setzen Sie den Funktionsnamen vor das Template Literal; das Ergebnis wird als getaggtes Template bezeichnet. In diesem Fall wird das Template Literal an Ihre Tag-Funktion übergeben, bei der Sie dann beliebige Operationen auf den verschiedenen Teilen des Template Literals ausführen können.
Um einen Backtick in einem Template Literal zu maskieren, setzen Sie einen Backslash (\) vor den Backtick.
js`\`` === "`"; // true

Dollarzeichen können ebenfalls maskiert werden, um die Interpolation zu verhindern.
js`\${1}` === "${1}"; // true
Mehrzeilige StringsAlle in der Quelle eingefügten Zeilenumbrüche sind Teil des Template Literals.
Mit normalen Strings müssten Sie die folgende Syntax verwenden, um mehrzeilige Strings zu erhalten:
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
// string text line 2"

Mit Template Literalen können Sie dasselbe mit diesem tun:
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"

Wie bei normalen String-Literalen können Sie einen einzeiligen String über mehrere Zeilen für die Lesbarkeit des Quellcodes schreiben, indem Sie den Zeilenumbruch mit einem Backslash (\) maskieren:
jsconsole.log(`string text line 1 \
string text line 2`);
// "string text line 1 string text line 2"
String-InterpolationOhne Template Literale, wenn Sie Ausgabewerte von Ausdrücken mit Strings kombinieren möchten, würden Sie diese verketten mit dem Plus-Operator +:
jsconst a = 5;
const b = 10;
console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");
// "Fifteen is 15 and
// not 20."

Das kann schwer lesbar sein – besonders, wenn Sie mehrere Ausdrücke haben.
Mit Template Literalen können Sie den Verketten-Operator vermeiden – und die Lesbarkeit Ihres Codes verbessern – indem Sie Platzhalter in der Form ${expression} verwenden, um Ersetzungen für eingebettete Ausdrücke durchzuführen:
jsconst a = 5;
const b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
// "Fifteen is 15 and
// not 20."

Beachten Sie, dass es einen kleinen Unterschied zwischen den beiden Syntaxen gibt. Template Literale zwingen ihre Ausdrücke direkt zu Strings, während Addition ihre Operanden zuerst zu Primitiven zwingt. Für mehr Informationen siehe die Referenzseite für den + Operator.Verschachtelung von TemplatesIn bestimmten Fällen ist das Verschachteln eines Templates der einfachste (und vielleicht lesbarere) Weg, um konfigurierbare Strings zu haben. Innerhalb eines durch Backticks begrenzten Templates ist es einfach, innere Backticks zuzulassen, indem man sie in einem ${expression}-Platzhalter innerhalb des Templates verwendet.
Zum Beispiel, ohne Template Literale, wenn Sie einen bestimmten Wert basierend auf einer bestimmten Bedingung zurückgeben möchten, könnten Sie etwas wie das Folgende tun:
jslet classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

Mit einem Template Literal, aber ohne Verschachtelung, könnten Sie dies tun:
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

Mit der Verschachtelung von Template Literalen können Sie dies tun:
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
Getaggte TemplatesEine fortschrittlichere Form von Template Literalen sind getaggte Templates.
Tags ermöglichen das Parsen von Template Literalen mit einer Funktion. Das erste Argument einer Tag-Funktion enthält ein Array von String-Werten. Die verbleibenden Argumente beziehen sich auf die Ausdrücke.
Die Tag-Funktion kann dann beliebige Operationen an diesen Argumenten durchführen und den manipulierten String zurückgeben. (Alternativ kann sie etwas völlig anderes zurückgeben, wie in einem der folgenden Beispiele beschrieben.)
Der Name der Funktion, die für das Tag verwendet wird, kann beliebig sein.
jsconst person = "Mike";
const age = 28;

function myTag(strings, personExp, ageExp) {
  const str0 = strings[0]; // "That "
  const str1 = strings[1]; // " is a "
  const str2 = strings[2]; // "."

  const ageStr = ageExp < 100 ? "youngster" : "centenarian";

  // We can even return a string built using a template literal
  return `${str0}${personExp}${str1}${ageStr}${str2}`;
}

const output = myTag`That ${person} is a ${age}.`;

console.log(output);
// That Mike is a youngster.

Das Tag muss kein einfacher Bezeichner sein. Sie können jeden Ausdruck mit Priorität größer als 16 verwenden, was Eigenschaftszugriff, Funktionsaufruf, Neuen Ausdruck, oder sogar ein anderes getaggtes Template Literal einschließt.
jsconsole.log`Hello`; // [ 'Hello' ]
console.log.bind(1, 2)`Hello`; // 2 [ 'Hello' ]
new Function("console.log(arguments)")`Hello`; // [Arguments] { '0': [ 'Hello' ] }

function recursive(strings, ...values) {
  console.log(strings, values);
  return recursive;
}
recursive`Hello``World`;
// [ 'Hello' ] []
// [ 'World' ] []

Obwohl syntaktisch erlaubt, werfen nicht getaggte Template Literale Strings und einen TypeError, wenn sie verkettet sind.
jsconsole.log(`Hello``World`); // TypeError: "Hello" is not a function

Die einzige Ausnahme ist die optionale Verkettung, die einen Syntaxfehler auslöst.
jsconsole.log?.`Hello`; // SyntaxError: Invalid tagged template on optional chain
console?.log`Hello`; // SyntaxError: Invalid tagged template on optional chain

Beachten Sie, dass diese zwei Ausdrücke immer noch analysierbar sind. Dies bedeutet, dass sie nicht der automatischen Semikolon-Einfügung unterliegen, die nur Semikolons einfügt, um Code zu korrigieren, der sonst nicht analysierbar ist.
js// Still a syntax error
const a = console?.log
`Hello`

Tag-Funktionen müssen nicht einmal einen String zurückgeben!
jsfunction template(strings, ...keys) {
  return (...values) => {
    const dict = values[values.length - 1] || {};
    const result = [strings[0]];
    keys.forEach((key, i) => {
      const value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

const t1Closure = template`${0}${1}${0}!`;
// const t1Closure = template(["","","","!"],0,1,0);
t1Closure("Y", "A"); // "YAY!"

const t2Closure = template`${0} ${"foo"}!`;
// const t2Closure = template([""," ","!"],0,"foo");
t2Closure("Hello", { foo: "World" }); // "Hello World!"

const t3Closure = template`I'm ${"name"}. I'm almost ${"age"} years old.`;
// const t3Closure = template(["I'm ", ". I'm almost ", " years old."], "name", "age");
t3Closure("foo", { name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."
t3Closure({ name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."

Das erste von der Tag-Funktion empfangene Argument ist ein Array von Strings. Für jedes Template-Literal entspricht seine Länge der Anzahl der Ersetzungen (Vorkommen von ${…}) plus eins und ist daher immer nicht leer.
Für jeden bestimmten getaggten Template-Literal-Ausdruck wird die Tag-Funktion immer mit demselben literalen Array aufgerufen, egal wie oft das Literal ausgewertet wird.
jsconst callHistory = [];

function tag(strings, ...values) {
  callHistory.push(strings);
  // Return a freshly made object
  return {};
}

function evaluateLiteral() {
  return tag`Hello, ${"world"}!`;
}

console.log(evaluateLiteral() === evaluateLiteral()); // false; each time `tag` is called, it returns a new object
console.log(callHistory[0] === callHistory[1]); // true; all evaluations of the same tagged literal would pass in the same strings array

Dies ermöglicht es dem Tag, das Ergebnis basierend auf der Identität seines ersten Arguments zu cachen. Um den Wert des Arrays weiter zu sichern, sind das erste Argument und seine rohe Eigenschaft beide eingefroren, sodass Sie sie in keiner Weise ändern können.Rohe StringsDie spezielle rohe Eigenschaft, die im ersten Argument der Tag-Funktion verfügbar ist, ermöglicht den Zugriff auf die rohen Strings, wie sie eingegeben wurden, ohne Escape-Sequenzen zu verarbeiten.
jsfunction tag(strings) {
  console.log(strings.raw[0]);
}

tag`string text line 1 \n string text line 2`;
// Logs "string text line 1 \n string text line 2",
// including the two characters '\' and 'n'

Darüber hinaus existiert die Methode String.raw(), um rohe Strings zu erstellen, genau wie die Standard-Template-Funktion und String-Konkatenation es tun würden.
jsconst str = String.raw`Hi\n${2 + 3}!`;
// "Hi\\n5!"

str.length;
// 6

Array.from(str).join(",");
// "H,i,\\,n,5,!"

String.raw funktioniert wie ein "Identitäts" Tag, wenn das Literal keine Escape-Sequenzen enthält. Falls Sie ein tatsächliches Identitätstag wünschen, das immer so funktioniert, als ob das Literal nicht getaggt ist, können Sie eine benutzerdefinierte Funktion erstellen, die das "gekochte" (d.h. Escape-Sequenzen sind verarbeitet) literale Array an String.raw übergibt, als wären sie rohe Strings.
jsconst identity = (strings, ...values) =>
  String.raw({ raw: strings }, ...values);
console.log(identity`Hi\n${2 + 3}!`);
// Hi
// 5!

Dies ist nützlich für viele Tools, die Literale behandeln, die von einem bestimmten Namen getaggt sind.
jsconst html = (strings, ...values) => String.raw({ raw: strings }, ...values);
// Some formatters will format this literal's content as HTML
const doc = html`<!doctype html>
  <html lang="en-US">
    <head>
      <title>Hello</title>
    </head>
    <body>
      <h1>Hello world!</h1>
    </body>
  </html>`;
Getaggte Templates und Escape-SequenzenIn normalen Template Literalen sind die Escape-Sequenzen in String-Literalen alle erlaubt. Jede andere nicht gut geformte Escape-Sequenz ist ein Syntaxfehler. Dazu gehören:

\ gefolgt von einer Dezimalziffer außer 0, oder \0 gefolgt von einer Dezimalziffer; zum Beispiel \9 und \07 (was eine veraltete Syntax ist)
\x gefolgt von weniger als zwei Hex-Ziffern (einschließlich keiner); zum Beispiel \xz
\u nicht gefolgt von { und gefolgt von weniger als vier Hex-Ziffern (einschließlich keiner); zum Beispiel \uz
\u{} umschließt einen ungültigen Unicode-Codepunkt – es enthält eine nicht-Hex-Ziffer oder sein Wert ist größer als 10FFFF; zum Beispiel \u{110000} und \u{z}


Note: \ gefolgt von anderen Zeichen, obwohl sie nutzlos sein können, da nichts maskiert wird, sind keine Syntaxfehler.

Dies ist jedoch problematisch für getaggte Templates, die, zusätzlich zu dem "gekochten" Literal, auch Zugriff auf die rohen Literale haben (Escape-Sequenzen bleiben unverändert).
Getaggte Templates ermöglichen die Einbettung beliebigen String-Inhalts, bei dem Escape-Sequenzen einer anderen Syntax folgen können. Betrachten Sie ein Beispiel, bei dem wir LaTeX-Quelltext in JavaScript über String.raw einbetten. Wir möchten weiterhin LaTeX-Makros verwenden können, die mit u oder x beginnen, ohne den JavaScript-Syntaxbeschränkungen folgen zu müssen. Daher wird die Syntaxbeschränkung für gut geformte Escape-Sequenzen von getaggten Templates entfernt. Das folgende Beispiel verwendet MathJax, um LaTeX in einem Element darzustellen:
jsconst node = document.getElementById("formula");
MathJax.typesetClear([node]);
// Throws in older ECMAScript versions (ES2016 and earlier)
// SyntaxError: malformed Unicode character escape sequence
node.textContent = String.raw`$\underline{u}$`;
MathJax.typesetPromise([node]);

Ungültige Escape-Sequenzen müssen jedoch weiterhin in der "gekochten" Darstellung dargestellt werden. Sie werden als undefined-Element im "gekochten" Array angezeigt:
jsfunction log(str) {
  console.log("Cooked:", str[0]);
  console.log("Raw:", str.raw[0]);
}

log`\unicode`;
// Cooked: undefined
// Raw: \unicode

Beachten Sie, dass die Escape-Sequenz-Beschränkung nur von getaggten Templates entfernt wird, nicht jedoch von nicht getaggten Template Literalen:
jsconst bad = `bad escape sequence: \unicode`;
SpezifikationenSpecificationECMAScript® 2026 Language Specification # sec-template-literalsBrowser-KompatibilitätSiehe auch
Zahlen und Strings Leitfaden
String
String.raw()
Lexikalische Grammatik
ES6 in der Tiefe: Vorlagen-Strings auf hacks.mozilla.org (2015)\n\nTemplate Literale (Vorlagen-Strings)Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackTemplate Literale sind Literale, die durch Backticks (`) begrenzt sind. Sie ermöglichen mehrzeilige Strings, String-Interpolation mit eingebetteten Ausdrücken und spezielle Konstrukte, die als getaggte Templates bezeichnet werden.
Template Literale werden manchmal informell Vorlagen-Strings genannt, da sie am häufigsten für die String-Interpolation verwendet werden (um Strings zu erzeugen, indem Platzhalter ersetzt werden). Ein getaggtes Template Literal muss jedoch nicht zu einem String führen; es kann mit einer benutzerdefinierten Tag-Funktion verwendet werden, um beliebige Operationen auf den verschiedenen Teilen des Template Literals auszuführen.Syntaxjs`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tagFunction`string text ${expression} string text`
Parameter
string text

Der String-Text, der Teil des Template Literals wird. Fast alle Zeichen sind buchstäblich erlaubt, einschließlich Zeilenumbrüche und anderer Leerzeichen. Ungültige Escape-Sequenzen führen jedoch zu einem Syntaxfehler, es sei denn, es wird eine Tag-Funktion verwendet.

expression

Ein Ausdruck, der an der aktuellen Position eingefügt wird, dessen Wert in einen String umgewandelt oder an tagFunction übergeben wird.

tagFunction

Wenn angegeben, wird diese mit dem Array der Template-Strings und den Ersetzungsausdrücken aufgerufen, und der Rückgabewert wird zum Wert des Template Literals. Siehe getaggte Templates.

BeschreibungTemplate Literale sind in Backtick-Zeichen (`) eingeschlossen, anstatt in doppelten oder einfachen Anführungszeichen.
Neben normalen Strings können Template Literale auch andere Teile enthalten, die Platzhalter genannt werden. Diese sind eingebettete Ausdrücke, die durch ein Dollarzeichen und geschweifte Klammern begrenzt sind: ${expression}. Die Strings und Platzhalter werden an eine Funktion übergeben – entweder eine Standardfunktion oder eine von Ihnen bereitgestellte Funktion. Die Standardfunktion (wenn Sie keine eigene bereitstellen) führt nur die String-Interpolation durch, um die Platzhalter zu ersetzen und die Teile dann zu einem einzelnen String zu verketten.
Um eine eigene Funktion bereitzustellen, setzen Sie den Funktionsnamen vor das Template Literal; das Ergebnis wird als getaggtes Template bezeichnet. In diesem Fall wird das Template Literal an Ihre Tag-Funktion übergeben, bei der Sie dann beliebige Operationen auf den verschiedenen Teilen des Template Literals ausführen können.
Um einen Backtick in einem Template Literal zu maskieren, setzen Sie einen Backslash (\) vor den Backtick.
js`\`` === "`"; // true

Dollarzeichen können ebenfalls maskiert werden, um die Interpolation zu verhindern.
js`\${1}` === "${1}"; // true
Mehrzeilige StringsAlle in der Quelle eingefügten Zeilenumbrüche sind Teil des Template Literals.
Mit normalen Strings müssten Sie die folgende Syntax verwenden, um mehrzeilige Strings zu erhalten:
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
// string text line 2"

Mit Template Literalen können Sie dasselbe mit diesem tun:
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"

Wie bei normalen String-Literalen können Sie einen einzeiligen String über mehrere Zeilen für die Lesbarkeit des Quellcodes schreiben, indem Sie den Zeilenumbruch mit einem Backslash (\) maskieren:
jsconsole.log(`string text line 1 \
string text line 2`);
// "string text line 1 string text line 2"
String-InterpolationOhne Template Literale, wenn Sie Ausgabewerte von Ausdrücken mit Strings kombinieren möchten, würden Sie diese verketten mit dem Plus-Operator +:
jsconst a = 5;
const b = 10;
console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");
// "Fifteen is 15 and
// not 20."

Das kann schwer lesbar sein – besonders, wenn Sie mehrere Ausdrücke haben.
Mit Template Literalen können Sie den Verketten-Operator vermeiden – und die Lesbarkeit Ihres Codes verbessern – indem Sie Platzhalter in der Form ${expression} verwenden, um Ersetzungen für eingebettete Ausdrücke durchzuführen:
jsconst a = 5;
const b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
// "Fifteen is 15 and
// not 20."

Beachten Sie, dass es einen kleinen Unterschied zwischen den beiden Syntaxen gibt. Template Literale zwingen ihre Ausdrücke direkt zu Strings, während Addition ihre Operanden zuerst zu Primitiven zwingt. Für mehr Informationen siehe die Referenzseite für den + Operator.Verschachtelung von TemplatesIn bestimmten Fällen ist das Verschachteln eines Templates der einfachste (und vielleicht lesbarere) Weg, um konfigurierbare Strings zu haben. Innerhalb eines durch Backticks begrenzten Templates ist es einfach, innere Backticks zuzulassen, indem man sie in einem ${expression}-Platzhalter innerhalb des Templates verwendet.
Zum Beispiel, ohne Template Literale, wenn Sie einen bestimmten Wert basierend auf einer bestimmten Bedingung zurückgeben möchten, könnten Sie etwas wie das Folgende tun:
jslet classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

Mit einem Template Literal, aber ohne Verschachtelung, könnten Sie dies tun:
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

Mit der Verschachtelung von Template Literalen können Sie dies tun:
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
Getaggte TemplatesEine fortschrittlichere Form von Template Literalen sind getaggte Templates.
Tags ermöglichen das Parsen von Template Literalen mit einer Funktion. Das erste Argument einer Tag-Funktion enthält ein Array von String-Werten. Die verbleibenden Argumente beziehen sich auf die Ausdrücke.
Die Tag-Funktion kann dann beliebige Operationen an diesen Argumenten durchführen und den manipulierten String zurückgeben. (Alternativ kann sie etwas völlig anderes zurückgeben, wie in einem der folgenden Beispiele beschrieben.)
Der Name der Funktion, die für das Tag verwendet wird, kann beliebig sein.
jsconst person = "Mike";
const age = 28;

function myTag(strings, personExp, ageExp) {
  const str0 = strings[0]; // "That "
  const str1 = strings[1]; // " is a "
  const str2 = strings[2]; // "."

  const ageStr = ageExp < 100 ? "youngster" : "centenarian";

  // We can even return a string built using a template literal
  return `${str0}${personExp}${str1}${ageStr}${str2}`;
}

const output = myTag`That ${person} is a ${age}.`;

console.log(output);
// That Mike is a youngster.

Das Tag muss kein einfacher Bezeichner sein. Sie können jeden Ausdruck mit Priorität größer als 16 verwenden, was Eigenschaftszugriff, Funktionsaufruf, Neuen Ausdruck, oder sogar ein anderes getaggtes Template Literal einschließt.
jsconsole.log`Hello`; // [ 'Hello' ]
console.log.bind(1, 2)`Hello`; // 2 [ 'Hello' ]
new Function("console.log(arguments)")`Hello`; // [Arguments] { '0': [ 'Hello' ] }

function recursive(strings, ...values) {
  console.log(strings, values);
  return recursive;
}
recursive`Hello``World`;
// [ 'Hello' ] []
// [ 'World' ] []

Obwohl syntaktisch erlaubt, werfen nicht getaggte Template Literale Strings und einen TypeError, wenn sie verkettet sind.
jsconsole.log(`Hello``World`); // TypeError: "Hello" is not a function

Die einzige Ausnahme ist die optionale Verkettung, die einen Syntaxfehler auslöst.
jsconsole.log?.`Hello`; // SyntaxError: Invalid tagged template on optional chain
console?.log`Hello`; // SyntaxError: Invalid tagged template on optional chain

Beachten Sie, dass diese zwei Ausdrücke immer noch analysierbar sind. Dies bedeutet, dass sie nicht der automatischen Semikolon-Einfügung unterliegen, die nur Semikolons einfügt, um Code zu korrigieren, der sonst nicht analysierbar ist.
js// Still a syntax error
const a = console?.log
`Hello`

Tag-Funktionen müssen nicht einmal einen String zurückgeben!
jsfunction template(strings, ...keys) {
  return (...values) => {
    const dict = values[values.length - 1] || {};
    const result = [strings[0]];
    keys.forEach((key, i) => {
      const value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

const t1Closure = template`${0}${1}${0}!`;
// const t1Closure = template(["","","","!"],0,1,0);
t1Closure("Y", "A"); // "YAY!"

const t2Closure = template`${0} ${"foo"}!`;
// const t2Closure = template([""," ","!"],0,"foo");
t2Closure("Hello", { foo: "World" }); // "Hello World!"

const t3Closure = template`I'm ${"name"}. I'm almost ${"age"} years old.`;
// const t3Closure = template(["I'm ", ". I'm almost ", " years old."], "name", "age");
t3Closure("foo", { name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."
t3Closure({ name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."

Das erste von der Tag-Funktion empfangene Argument ist ein Array von Strings. Für jedes Template-Literal entspricht seine Länge der Anzahl der Ersetzungen (Vorkommen von ${…}) plus eins und ist daher immer nicht leer.
Für jeden bestimmten getaggten Template-Literal-Ausdruck wird die Tag-Funktion immer mit demselben literalen Array aufgerufen, egal wie oft das Literal ausgewertet wird.
jsconst callHistory = [];

function tag(strings, ...values) {
  callHistory.push(strings);
  // Return a freshly made object
  return {};
}

function evaluateLiteral() {
  return tag`Hello, ${"world"}!`;
}

console.log(evaluateLiteral() === evaluateLiteral()); // false; each time `tag` is called, it returns a new object
console.log(callHistory[0] === callHistory[1]); // true; all evaluations of the same tagged literal would pass in the same strings array

Dies ermöglicht es dem Tag, das Ergebnis basierend auf der Identität seines ersten Arguments zu cachen. Um den Wert des Arrays weiter zu sichern, sind das erste Argument und seine rohe Eigenschaft beide eingefroren, sodass Sie sie in keiner Weise ändern können.Rohe StringsDie spezielle rohe Eigenschaft, die im ersten Argument der Tag-Funktion verfügbar ist, ermöglicht den Zugriff auf die rohen Strings, wie sie eingegeben wurden, ohne Escape-Sequenzen zu verarbeiten.
jsfunction tag(strings) {
  console.log(strings.raw[0]);
}

tag`string text line 1 \n string text line 2`;
// Logs "string text line 1 \n string text line 2",
// including the two characters '\' and 'n'

Darüber hinaus existiert die Methode String.raw(), um rohe Strings zu erstellen, genau wie die Standard-Template-Funktion und String-Konkatenation es tun würden.
jsconst str = String.raw`Hi\n${2 + 3}!`;
// "Hi\\n5!"

str.length;
// 6

Array.from(str).join(",");
// "H,i,\\,n,5,!"

String.raw funktioniert wie ein "Identitäts" Tag, wenn das Literal keine Escape-Sequenzen enthält. Falls Sie ein tatsächliches Identitätstag wünschen, das immer so funktioniert, als ob das Literal nicht getaggt ist, können Sie eine benutzerdefinierte Funktion erstellen, die das "gekochte" (d.h. Escape-Sequenzen sind verarbeitet) literale Array an String.raw übergibt, als wären sie rohe Strings.
jsconst identity = (strings, ...values) =>
  String.raw({ raw: strings }, ...values);
console.log(identity`Hi\n${2 + 3}!`);
// Hi
// 5!

Dies ist nützlich für viele Tools, die Literale behandeln, die von einem bestimmten Namen getaggt sind.
jsconst html = (strings, ...values) => String.raw({ raw: strings }, ...values);
// Some formatters will format this literal's content as HTML
const doc = html`<!doctype html>
  <html lang="en-US">
    <head>
      <title>Hello</title>
    </head>
    <body>
      <h1>Hello world!</h1>
    </body>
  </html>`;
Getaggte Templates und Escape-SequenzenIn normalen Template Literalen sind die Escape-Sequenzen in String-Literalen alle erlaubt. Jede andere nicht gut geformte Escape-Sequenz ist ein Syntaxfehler. Dazu gehören:

\ gefolgt von einer Dezimalziffer außer 0, oder \0 gefolgt von einer Dezimalziffer; zum Beispiel \9 und \07 (was eine veraltete Syntax ist)
\x gefolgt von weniger als zwei Hex-Ziffern (einschließlich keiner); zum Beispiel \xz
\u nicht gefolgt von { und gefolgt von weniger als vier Hex-Ziffern (einschließlich keiner); zum Beispiel \uz
\u{} umschließt einen ungültigen Unicode-Codepunkt – es enthält eine nicht-Hex-Ziffer oder sein Wert ist größer als 10FFFF; zum Beispiel \u{110000} und \u{z}


Note: \ gefolgt von anderen Zeichen, obwohl sie nutzlos sein können, da nichts maskiert wird, sind keine Syntaxfehler.

Dies ist jedoch problematisch für getaggte Templates, die, zusätzlich zu dem "gekochten" Literal, auch Zugriff auf die rohen Literale haben (Escape-Sequenzen bleiben unverändert).
Getaggte Templates ermöglichen die Einbettung beliebigen String-Inhalts, bei dem Escape-Sequenzen einer anderen Syntax folgen können. Betrachten Sie ein Beispiel, bei dem wir LaTeX-Quelltext in JavaScript über String.raw einbetten. Wir möchten weiterhin LaTeX-Makros verwenden können, die mit u oder x beginnen, ohne den JavaScript-Syntaxbeschränkungen folgen zu müssen. Daher wird die Syntaxbeschränkung für gut geformte Escape-Sequenzen von getaggten Templates entfernt. Das folgende Beispiel verwendet MathJax, um LaTeX in einem Element darzustellen:
jsconst node = document.getElementById("formula");
MathJax.typesetClear([node]);
// Throws in older ECMAScript versions (ES2016 and earlier)
// SyntaxError: malformed Unicode character escape sequence
node.textContent = String.raw`$\underline{u}$`;
MathJax.typesetPromise([node]);

Ungültige Escape-Sequenzen müssen jedoch weiterhin in der "gekochten" Darstellung dargestellt werden. Sie werden als undefined-Element im "gekochten" Array angezeigt:
jsfunction log(str) {
  console.log("Cooked:", str[0]);
  console.log("Raw:", str.raw[0]);
}

log`\unicode`;
// Cooked: undefined
// Raw: \unicode

Beachten Sie, dass die Escape-Sequenz-Beschränkung nur von getaggten Templates entfernt wird, nicht jedoch von nicht getaggten Template Literalen:
jsconst bad = `bad escape sequence: \unicode`;
SpezifikationenSpecificationECMAScript® 2026 Language Specification # sec-template-literalsBrowser-KompatibilitätSiehe auch
Zahlen und Strings Leitfaden
String
String.raw()
Lexikalische Grammatik
ES6 in der Tiefe: Vorlagen-Strings auf hacks.mozilla.org (2015)
MDN-Feedback-BoxWar diese Übersetzung hilfreich?JaNeinDiese Seite wurde automatisch aus dem Englischen übersetzt.Übersetzung auf GitHub anzeigen • Fehler mit dieser Übersetzung melden\n\nTemplate Literale (Vorlagen-Strings)Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackTemplate Literale sind Literale, die durch Backticks (`) begrenzt sind. Sie ermöglichen mehrzeilige Strings, String-Interpolation mit eingebetteten Ausdrücken und spezielle Konstrukte, die als getaggte Templates bezeichnet werden.
Template Literale werden manchmal informell Vorlagen-Strings genannt, da sie am häufigsten für die String-Interpolation verwendet werden (um Strings zu erzeugen, indem Platzhalter ersetzt werden). Ein getaggtes Template Literal muss jedoch nicht zu einem String führen; es kann mit einer benutzerdefinierten Tag-Funktion verwendet werden, um beliebige Operationen auf den verschiedenen Teilen des Template Literals auszuführen.Syntaxjs`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tagFunction`string text ${expression} string text`
Parameter
string text

Der String-Text, der Teil des Template Literals wird. Fast alle Zeichen sind buchstäblich erlaubt, einschließlich Zeilenumbrüche und anderer Leerzeichen. Ungültige Escape-Sequenzen führen jedoch zu einem Syntaxfehler, es sei denn, es wird eine Tag-Funktion verwendet.

expression

Ein Ausdruck, der an der aktuellen Position eingefügt wird, dessen Wert in einen String umgewandelt oder an tagFunction übergeben wird.

tagFunction

Wenn angegeben, wird diese mit dem Array der Template-Strings und den Ersetzungsausdrücken aufgerufen, und der Rückgabewert wird zum Wert des Template Literals. Siehe getaggte Templates.

BeschreibungTemplate Literale sind in Backtick-Zeichen (`) eingeschlossen, anstatt in doppelten oder einfachen Anführungszeichen.
Neben normalen Strings können Template Literale auch andere Teile enthalten, die Platzhalter genannt werden. Diese sind eingebettete Ausdrücke, die durch ein Dollarzeichen und geschweifte Klammern begrenzt sind: ${expression}. Die Strings und Platzhalter werden an eine Funktion übergeben – entweder eine Standardfunktion oder eine von Ihnen bereitgestellte Funktion. Die Standardfunktion (wenn Sie keine eigene bereitstellen) führt nur die String-Interpolation durch, um die Platzhalter zu ersetzen und die Teile dann zu einem einzelnen String zu verketten.
Um eine eigene Funktion bereitzustellen, setzen Sie den Funktionsnamen vor das Template Literal; das Ergebnis wird als getaggtes Template bezeichnet. In diesem Fall wird das Template Literal an Ihre Tag-Funktion übergeben, bei der Sie dann beliebige Operationen auf den verschiedenen Teilen des Template Literals ausführen können.
Um einen Backtick in einem Template Literal zu maskieren, setzen Sie einen Backslash (\) vor den Backtick.
js`\`` === "`"; // true

Dollarzeichen können ebenfalls maskiert werden, um die Interpolation zu verhindern.
js`\${1}` === "${1}"; // true
Mehrzeilige StringsAlle in der Quelle eingefügten Zeilenumbrüche sind Teil des Template Literals.
Mit normalen Strings müssten Sie die folgende Syntax verwenden, um mehrzeilige Strings zu erhalten:
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
// string text line 2"

Mit Template Literalen können Sie dasselbe mit diesem tun:
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"

Wie bei normalen String-Literalen können Sie einen einzeiligen String über mehrere Zeilen für die Lesbarkeit des Quellcodes schreiben, indem Sie den Zeilenumbruch mit einem Backslash (\) maskieren:
jsconsole.log(`string text line 1 \
string text line 2`);
// "string text line 1 string text line 2"
String-InterpolationOhne Template Literale, wenn Sie Ausgabewerte von Ausdrücken mit Strings kombinieren möchten, würden Sie diese verketten mit dem Plus-Operator +:
jsconst a = 5;
const b = 10;
console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");
// "Fifteen is 15 and
// not 20."

Das kann schwer lesbar sein – besonders, wenn Sie mehrere Ausdrücke haben.
Mit Template Literalen können Sie den Verketten-Operator vermeiden – und die Lesbarkeit Ihres Codes verbessern – indem Sie Platzhalter in der Form ${expression} verwenden, um Ersetzungen für eingebettete Ausdrücke durchzuführen:
jsconst a = 5;
const b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
// "Fifteen is 15 and
// not 20."

Beachten Sie, dass es einen kleinen Unterschied zwischen den beiden Syntaxen gibt. Template Literale zwingen ihre Ausdrücke direkt zu Strings, während Addition ihre Operanden zuerst zu Primitiven zwingt. Für mehr Informationen siehe die Referenzseite für den + Operator.Verschachtelung von TemplatesIn bestimmten Fällen ist das Verschachteln eines Templates der einfachste (und vielleicht lesbarere) Weg, um konfigurierbare Strings zu haben. Innerhalb eines durch Backticks begrenzten Templates ist es einfach, innere Backticks zuzulassen, indem man sie in einem ${expression}-Platzhalter innerhalb des Templates verwendet.
Zum Beispiel, ohne Template Literale, wenn Sie einen bestimmten Wert basierend auf einer bestimmten Bedingung zurückgeben möchten, könnten Sie etwas wie das Folgende tun:
jslet classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

Mit einem Template Literal, aber ohne Verschachtelung, könnten Sie dies tun:
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

Mit der Verschachtelung von Template Literalen können Sie dies tun:
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
Getaggte TemplatesEine fortschrittlichere Form von Template Literalen sind getaggte Templates.
Tags ermöglichen das Parsen von Template Literalen mit einer Funktion. Das erste Argument einer Tag-Funktion enthält ein Array von String-Werten. Die verbleibenden Argumente beziehen sich auf die Ausdrücke.
Die Tag-Funktion kann dann beliebige Operationen an diesen Argumenten durchführen und den manipulierten String zurückgeben. (Alternativ kann sie etwas völlig anderes zurückgeben, wie in einem der folgenden Beispiele beschrieben.)
Der Name der Funktion, die für das Tag verwendet wird, kann beliebig sein.
jsconst person = "Mike";
const age = 28;

function myTag(strings, personExp, ageExp) {
  const str0 = strings[0]; // "That "
  const str1 = strings[1]; // " is a "
  const str2 = strings[2]; // "."

  const ageStr = ageExp < 100 ? "youngster" : "centenarian";

  // We can even return a string built using a template literal
  return `${str0}${personExp}${str1}${ageStr}${str2}`;
}

const output = myTag`That ${person} is a ${age}.`;

console.log(output);
// That Mike is a youngster.

Das Tag muss kein einfacher Bezeichner sein. Sie können jeden Ausdruck mit Priorität größer als 16 verwenden, was Eigenschaftszugriff, Funktionsaufruf, Neuen Ausdruck, oder sogar ein anderes getaggtes Template Literal einschließt.
jsconsole.log`Hello`; // [ 'Hello' ]
console.log.bind(1, 2)`Hello`; // 2 [ 'Hello' ]
new Function("console.log(arguments)")`Hello`; // [Arguments] { '0': [ 'Hello' ] }

function recursive(strings, ...values) {
  console.log(strings, values);
  return recursive;
}
recursive`Hello``World`;
// [ 'Hello' ] []
// [ 'World' ] []

Obwohl syntaktisch erlaubt, werfen nicht getaggte Template Literale Strings und einen TypeError, wenn sie verkettet sind.
jsconsole.log(`Hello``World`); // TypeError: "Hello" is not a function

Die einzige Ausnahme ist die optionale Verkettung, die einen Syntaxfehler auslöst.
jsconsole.log?.`Hello`; // SyntaxError: Invalid tagged template on optional chain
console?.log`Hello`; // SyntaxError: Invalid tagged template on optional chain

Beachten Sie, dass diese zwei Ausdrücke immer noch analysierbar sind. Dies bedeutet, dass sie nicht der automatischen Semikolon-Einfügung unterliegen, die nur Semikolons einfügt, um Code zu korrigieren, der sonst nicht analysierbar ist.
js// Still a syntax error
const a = console?.log
`Hello`

Tag-Funktionen müssen nicht einmal einen String zurückgeben!
jsfunction template(strings, ...keys) {
  return (...values) => {
    const dict = values[values.length - 1] || {};
    const result = [strings[0]];
    keys.forEach((key, i) => {
      const value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

const t1Closure = template`${0}${1}${0}!`;
// const t1Closure = template(["","","","!"],0,1,0);
t1Closure("Y", "A"); // "YAY!"

const t2Closure = template`${0} ${"foo"}!`;
// const t2Closure = template([""," ","!"],0,"foo");
t2Closure("Hello", { foo: "World" }); // "Hello World!"

const t3Closure = template`I'm ${"name"}. I'm almost ${"age"} years old.`;
// const t3Closure = template(["I'm ", ". I'm almost ", " years old."], "name", "age");
t3Closure("foo", { name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."
t3Closure({ name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."

Das erste von der Tag-Funktion empfangene Argument ist ein Array von Strings. Für jedes Template-Literal entspricht seine Länge der Anzahl der Ersetzungen (Vorkommen von ${…}) plus eins und ist daher immer nicht leer.
Für jeden bestimmten getaggten Template-Literal-Ausdruck wird die Tag-Funktion immer mit demselben literalen Array aufgerufen, egal wie oft das Literal ausgewertet wird.
jsconst callHistory = [];

function tag(strings, ...values) {
  callHistory.push(strings);
  // Return a freshly made object
  return {};
}

function evaluateLiteral() {
  return tag`Hello, ${"world"}!`;
}

console.log(evaluateLiteral() === evaluateLiteral()); // false; each time `tag` is called, it returns a new object
console.log(callHistory[0] === callHistory[1]); // true; all evaluations of the same tagged literal would pass in the same strings array

Dies ermöglicht es dem Tag, das Ergebnis basierend auf der Identität seines ersten Arguments zu cachen. Um den Wert des Arrays weiter zu sichern, sind das erste Argument und seine rohe Eigenschaft beide eingefroren, sodass Sie sie in keiner Weise ändern können.Rohe StringsDie spezielle rohe Eigenschaft, die im ersten Argument der Tag-Funktion verfügbar ist, ermöglicht den Zugriff auf die rohen Strings, wie sie eingegeben wurden, ohne Escape-Sequenzen zu verarbeiten.
jsfunction tag(strings) {
  console.log(strings.raw[0]);
}

tag`string text line 1 \n string text line 2`;
// Logs "string text line 1 \n string text line 2",
// including the two characters '\' and 'n'

Darüber hinaus existiert die Methode String.raw(), um rohe Strings zu erstellen, genau wie die Standard-Template-Funktion und String-Konkatenation es tun würden.
jsconst str = String.raw`Hi\n${2 + 3}!`;
// "Hi\\n5!"

str.length;
// 6

Array.from(str).join(",");
// "H,i,\\,n,5,!"

String.raw funktioniert wie ein "Identitäts" Tag, wenn das Literal keine Escape-Sequenzen enthält. Falls Sie ein tatsächliches Identitätstag wünschen, das immer so funktioniert, als ob das Literal nicht getaggt ist, können Sie eine benutzerdefinierte Funktion erstellen, die das "gekochte" (d.h. Escape-Sequenzen sind verarbeitet) literale Array an String.raw übergibt, als wären sie rohe Strings.
jsconst identity = (strings, ...values) =>
  String.raw({ raw: strings }, ...values);
console.log(identity`Hi\n${2 + 3}!`);
// Hi
// 5!

Dies ist nützlich für viele Tools, die Literale behandeln, die von einem bestimmten Namen getaggt sind.
jsconst html = (strings, ...values) => String.raw({ raw: strings }, ...values);
// Some formatters will format this literal's content as HTML
const doc = html`<!doctype html>
  <html lang="en-US">
    <head>
      <title>Hello</title>
    </head>
    <body>
      <h1>Hello world!</h1>
    </body>
  </html>`;
Getaggte Templates und Escape-SequenzenIn normalen Template Literalen sind die Escape-Sequenzen in String-Literalen alle erlaubt. Jede andere nicht gut geformte Escape-Sequenz ist ein Syntaxfehler. Dazu gehören:

\ gefolgt von einer Dezimalziffer außer 0, oder \0 gefolgt von einer Dezimalziffer; zum Beispiel \9 und \07 (was eine veraltete Syntax ist)
\x gefolgt von weniger als zwei Hex-Ziffern (einschließlich keiner); zum Beispiel \xz
\u nicht gefolgt von { und gefolgt von weniger als vier Hex-Ziffern (einschließlich keiner); zum Beispiel \uz
\u{} umschließt einen ungültigen Unicode-Codepunkt – es enthält eine nicht-Hex-Ziffer oder sein Wert ist größer als 10FFFF; zum Beispiel \u{110000} und \u{z}


Note: \ gefolgt von anderen Zeichen, obwohl sie nutzlos sein können, da nichts maskiert wird, sind keine Syntaxfehler.

Dies ist jedoch problematisch für getaggte Templates, die, zusätzlich zu dem "gekochten" Literal, auch Zugriff auf die rohen Literale haben (Escape-Sequenzen bleiben unverändert).
Getaggte Templates ermöglichen die Einbettung beliebigen String-Inhalts, bei dem Escape-Sequenzen einer anderen Syntax folgen können. Betrachten Sie ein Beispiel, bei dem wir LaTeX-Quelltext in JavaScript über String.raw einbetten. Wir möchten weiterhin LaTeX-Makros verwenden können, die mit u oder x beginnen, ohne den JavaScript-Syntaxbeschränkungen folgen zu müssen. Daher wird die Syntaxbeschränkung für gut geformte Escape-Sequenzen von getaggten Templates entfernt. Das folgende Beispiel verwendet MathJax, um LaTeX in einem Element darzustellen:
jsconst node = document.getElementById("formula");
MathJax.typesetClear([node]);
// Throws in older ECMAScript versions (ES2016 and earlier)
// SyntaxError: malformed Unicode character escape sequence
node.textContent = String.raw`$\underline{u}$`;
MathJax.typesetPromise([node]);

Ungültige Escape-Sequenzen müssen jedoch weiterhin in der "gekochten" Darstellung dargestellt werden. Sie werden als undefined-Element im "gekochten" Array angezeigt:
jsfunction log(str) {
  console.log("Cooked:", str[0]);
  console.log("Raw:", str.raw[0]);
}

log`\unicode`;
// Cooked: undefined
// Raw: \unicode

Beachten Sie, dass die Escape-Sequenz-Beschränkung nur von getaggten Templates entfernt wird, nicht jedoch von nicht getaggten Template Literalen:
jsconst bad = `bad escape sequence: \unicode`;
SpezifikationenSpecificationECMAScript® 2026 Language Specification # sec-template-literalsBrowser-KompatibilitätSiehe auch
Zahlen und Strings Leitfaden
String
String.raw()
Lexikalische Grammatik
ES6 in der Tiefe: Vorlagen-Strings auf hacks.mozilla.org (2015)
MDN-Feedback-BoxWar diese Übersetzung hilfreich?JaNeinDiese Seite wurde automatisch aus dem Englischen übersetzt.Übersetzung auf GitHub anzeigen • Fehler mit dieser Übersetzung melden\n\n\n\nPlantillas literales (plantillas de cadenas)Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackLas plantillas literales son cadenas literales que habilitan el uso de expresiones incrustadas. Con ellas, es posible utilizar cadenas de caracteres de más de una línea, y funcionalidades de interpolación de cadenas de caracteres.
En ediciones anteriores de la especificación ES2015, solían llamarse "plantillas de cadenas de caracteres".Sintaxis`texto de cadena de caracteres`

`línea 1 de la cadena de caracteres
  línea 2 de la cadena de caracteres`

`texto de cadena de caracteres ${expresión} texto adicional`

etiqueta`texto de cadena de caracteres ${expresión} texto adicional`
DescripciónLas plantillas literales se delimitan con el caracter de comillas o tildes invertidas (` `) (grave accent), en lugar de las comillas sencillas o dobles.
Las plantillas de cadena de caracteres pueden contener marcadores, identificados por el signo de dólar y envueltos en llaves (${expresión}). Las expresiones contenidas en los marcadores, junto con el texto entre ellas, son enviados como argumentos a una función.
La función por defecto sencillamente concatena las partes para formar una única cadena de caracteres. Si hay una expresión antes de la plantilla literal (aquí indicada mediante etiqueta), se le conoce como "plantilla etiquetada". En este caso, la expresión de etiqueta (típicamente una función) es llamada con la plantilla literal como parámetro, que luego puede ser manipulada antes de ser devuelta.
En caso de querer escapar una comilla o tilde invertida en una plantilla literal, se debe poner una barra invertida (\) antes de la comilla o tilde invertida.
js`\`` === "`"; // --> true (cierto)
Cadenas de más de una líneaLos caracteres de fin de línea encontrados forman parte de la plantilla literal.
Utilizando cadenas de caracteres normales, sería necesario utilizar la siguiente sintaxis para producir cadenas de más de una línea:
jsconsole.log("línea 1 de cadena de texto\n" + "línea 2 de cadena de texto");
// "línea 1 de cadena de texto
// línea 2 de cadena de texto"

Utilizando plantillas literales, se puede obtener el mismo resultado de la siguiente forma:
jsconsole.log(`línea 1 de la cadena de texto
línea 2 de la cadena de texto`);
// "línea 1 de la cadena de texto
// línea 2 de la cadena de texto"
Interpolación de expresionesPara insertar expresiones dentro de cadenas de caracteres normales, se utilizaría la siguiente sintaxis:
jslet a = 5;
let b = 10;
console.log("Quince es " + (a + b) + " y\nno " + (2 * a + b) + ".");
// "Quince es 15 y
// no 20."

Ahora, con las plantillas literales, se pueden utilizar sus nuevas capacidades (es decir, insertar expresiones con ${ } e incluir caracteres de fin de linea literales dentro de la cadena) para simplificar la sintaxis:
jslet a = 5;
let b = 10;
console.log(`Quince es ${a + b} y
no ${2 * a + b}.`);
// "Quince es 15 y
// no 20."
Anidamiento de plantillasEn ciertos casos, anidar una plantilla es la forma más fácil, e incluso más legible, de tener cadenas configurables. Dentro de una plantilla con tildes invertidas, es sencillo permitir tildes invertidas interiores simplemente usándolas dentro de un marcador de posición ${ } dentro de la plantilla.
Por ejemplo, si la condición a es true (cierta): entonces return (devuelva) este literal con plantilla.
En ES5:
jslet classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

En ES2015 con plantillas literales y sin anidamiento:
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

En ES5 con plantillas literales anidadas:
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
Plantillas etiquetadasUna forma más avanzada de plantillas literales son las plantillas etiquetadas.
Con ellas es posible modificar la salida de las plantillas utilizando una función. El primer argumento contiene un array con una o más cadenas de caracteres. El segundo y subsiguientes argumentos se asocian con las expresiones de la plantilla.
La función de etiqueta puede ejecutar cualesquiera operaciones deseadas con estos argumentos, y luego devolver la cadena manipulada. (También puede devolver algo totalmente distinto, como se muestra en uno de los siguientes ejemplos.)
El nombre de la función utilizada con la etiqueta no es nada especial, se puede utilizar cualquier nombre de función en su lugar.
jslet persona = "Mike";
let edad = 28;

function myTag(strings, expPersona, expEdad) {
  let str0 = strings[0]; // "Ese "
  let str1 = strings[1]; // " es un "

  // Tecnicamente, hay una cadena de
  // caracteres después de la expresión
  // final (en nuestro ejemplo) pero
  // está vacia (""), asi que se ignora.
  // let str2 = strings[2];

  let strEdad;
  if (expEdad > 99) {
    strEdad = "viejo";
  } else {
    strEdad = "joven";
  }

  // Podemos incluso retornar una cadena de
  // caracteres utilizando una plantilla literal.
  return `${str0}${expPersona}${str1}${strEdad}`;
}

var salida = myTag`Ese ${persona} es un ${edad}`;

console.log(salida);
// Ese Mike es un joven

Las funciones de etiqueta incluso pueden devolver valores que no sean cadenas de caracteres:
jsfunction plantilla(cadenas, ...claves) {
  return function (...valores) {
    let diccio = valores[valores.length - 1] || {};
    let resultado = [cadenas[0]];
    claves.forEach(function (clave, i) {
      let valor = Number.isInteger(clave) ? valores[clave] : diccio[clave];
      resultado.push(valor, cadenas[i + 1]);
    });
    return resultado.join("");
  };
}

let t1Closure = plantilla`¡${0}${1}${2}${2}${3}!`;
//let t1Closure = plantilla(["¡","","","","","","!"],0,1,2,3);
t1Closure("H", "U", "R", "A"); // "¡HURRA!"

let t2Closure = plantilla`${0} ${"foo"}!`;
//let t2Closure = plantilla(["¡",""," ","!"],0,"foo");
t2Closure("Hola", { foo: "Mundo" }); // "¡Hola Mundo!"

let t3Closure = plantilla`Me llamo ${"nombre"}. Tengo casi ${"edad"} años.`;
//let t3Closure = plantilla(["Me llamo ", ". Tengo casi ", " años."], "nombre", "edad");
t3Closure("foo", { nombre: "MDN", edad: 30 }); //"Me llamo MDN. Tengo casi 30 años."
t3Closure({ nombre: "MDN", edad: 30 }); //"Me llamo MDN. Tengo casi 30 años."
Cadenas en crudo (raw)La propiedad especial raw, disponible en el primer argumento de la función de etiqueta, permite acceso a las cadenas de caracteres tal como fueron ingresadas, sin procesar secuencias de escape.
jsfunction etiqueta(cadenas) {
  console.log(cadenas.raw[0]);
}

etiqueta`texto de cadena de caracteres 1 \n texto de cadena de caracteres 2`;
// muestra "texto de cadena de caracteres 1 \n texto de cadena de caracteres 2" ,
// incluyendo los caracteres '\' y 'n'

Adicionalmente, el método String.raw() permite crear cadenas de caracteres en crudo tal como serían generadas por la función por defecto de plantilla, concatenando sus partes.
jslet cadena = String.raw`¡Hola\n${2 + 3}!`;
// "¡Hola\n5!"

cadena.length;
// 9

Array.from(cadena).join(",");
// "¡,H,o,l,a,\,n,5,!"
Plantillas etiquetadas y secuencias de escapeComportamiento en ES2016
Comenzando con ECMAScript 2016, las plantillas etiquetadas se comportan de acuerdo con las normas de las siguientes secuencias de escape:

Secuencias de escape de formato Unicode comenzando con "\u", como \u00A9
Secuencias de escape de formato Unicode de punto de código, indicadas con "\u{}", como \u{2F804}
Secuencias de escape de numeros hexadecimales comenzando con "\x", como \xA9
Secuencias de escape de octales literales comenzando con "\0o" seguidas de uno o más dígitos, como \0o251

Esto significa que una plantilla etiquetada como la siguiente podría causar problemas, dado que, de acuerdo con la gramática de ECMAScript, un analizador buscará secuencias de escape de formato Unicode válidas pero encontrará sintaxis equivocado:
jslatex`\unicode`;
// En ECMAScript 2016 y versiones anteriores, lanza
// SyntaxError: malformed Unicode character escape sequence
Revision de secuencias de escape no permitidas en ES2018Las plantillas etiquetadas deberías permitir la inserción de lenguages (como los DSL, o LaTeX), en donde otras secuencias de escape se ven comúnmente. La propuesta para ECMAScript Template Literal Revision (Revisión de Plantilla Literal) (Cuarta Etapa, en camino a ser integrada al estándar de ECMAScript 2018) elimina la restricción de las secuencias de escape en ECMAScript para las plantillas etiquetadas.
Aún así, las secuencias de escape no permitidas deben ser representadas en la representación "cocinada" de la cadena. Aparecerán como elementos no definidos en el array llamado "cocinado" en el siguiente ejemplo.
jsfunction latex(str) {
  return { cocinado: str[0], "en crudo": str.raw[0] };
}

latex`\unicode`;

// { cocinado: undefined, en crudo: "\\unicode" }

Cabe destacar que la restricción para secuencias de escape solo ha sido eliminada para plantillas etiquetadas. Aún permanece para plantillas literales sin etiqueta:
jslet bad = `bad escape sequence: \unicode`;
EspecificacionesSpecificationECMAScript® 2026 Language Specification # sec-template-literalsCompatibilidad con navegadoresVer también
String
String.raw()
Lexical grammar
Template-like strings in ES3 compatible syntax\n\nPlantillas literales (plantillas de cadenas)Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackLas plantillas literales son cadenas literales que habilitan el uso de expresiones incrustadas. Con ellas, es posible utilizar cadenas de caracteres de más de una línea, y funcionalidades de interpolación de cadenas de caracteres.
En ediciones anteriores de la especificación ES2015, solían llamarse "plantillas de cadenas de caracteres".Sintaxis`texto de cadena de caracteres`

`línea 1 de la cadena de caracteres
  línea 2 de la cadena de caracteres`

`texto de cadena de caracteres ${expresión} texto adicional`

etiqueta`texto de cadena de caracteres ${expresión} texto adicional`
DescripciónLas plantillas literales se delimitan con el caracter de comillas o tildes invertidas (` `) (grave accent), en lugar de las comillas sencillas o dobles.
Las plantillas de cadena de caracteres pueden contener marcadores, identificados por el signo de dólar y envueltos en llaves (${expresión}). Las expresiones contenidas en los marcadores, junto con el texto entre ellas, son enviados como argumentos a una función.
La función por defecto sencillamente concatena las partes para formar una única cadena de caracteres. Si hay una expresión antes de la plantilla literal (aquí indicada mediante etiqueta), se le conoce como "plantilla etiquetada". En este caso, la expresión de etiqueta (típicamente una función) es llamada con la plantilla literal como parámetro, que luego puede ser manipulada antes de ser devuelta.
En caso de querer escapar una comilla o tilde invertida en una plantilla literal, se debe poner una barra invertida (\) antes de la comilla o tilde invertida.
js`\`` === "`"; // --> true (cierto)
Cadenas de más de una líneaLos caracteres de fin de línea encontrados forman parte de la plantilla literal.
Utilizando cadenas de caracteres normales, sería necesario utilizar la siguiente sintaxis para producir cadenas de más de una línea:
jsconsole.log("línea 1 de cadena de texto\n" + "línea 2 de cadena de texto");
// "línea 1 de cadena de texto
// línea 2 de cadena de texto"

Utilizando plantillas literales, se puede obtener el mismo resultado de la siguiente forma:
jsconsole.log(`línea 1 de la cadena de texto
línea 2 de la cadena de texto`);
// "línea 1 de la cadena de texto
// línea 2 de la cadena de texto"
Interpolación de expresionesPara insertar expresiones dentro de cadenas de caracteres normales, se utilizaría la siguiente sintaxis:
jslet a = 5;
let b = 10;
console.log("Quince es " + (a + b) + " y\nno " + (2 * a + b) + ".");
// "Quince es 15 y
// no 20."

Ahora, con las plantillas literales, se pueden utilizar sus nuevas capacidades (es decir, insertar expresiones con ${ } e incluir caracteres de fin de linea literales dentro de la cadena) para simplificar la sintaxis:
jslet a = 5;
let b = 10;
console.log(`Quince es ${a + b} y
no ${2 * a + b}.`);
// "Quince es 15 y
// no 20."
Anidamiento de plantillasEn ciertos casos, anidar una plantilla es la forma más fácil, e incluso más legible, de tener cadenas configurables. Dentro de una plantilla con tildes invertidas, es sencillo permitir tildes invertidas interiores simplemente usándolas dentro de un marcador de posición ${ } dentro de la plantilla.
Por ejemplo, si la condición a es true (cierta): entonces return (devuelva) este literal con plantilla.
En ES5:
jslet classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

En ES2015 con plantillas literales y sin anidamiento:
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

En ES5 con plantillas literales anidadas:
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
Plantillas etiquetadasUna forma más avanzada de plantillas literales son las plantillas etiquetadas.
Con ellas es posible modificar la salida de las plantillas utilizando una función. El primer argumento contiene un array con una o más cadenas de caracteres. El segundo y subsiguientes argumentos se asocian con las expresiones de la plantilla.
La función de etiqueta puede ejecutar cualesquiera operaciones deseadas con estos argumentos, y luego devolver la cadena manipulada. (También puede devolver algo totalmente distinto, como se muestra en uno de los siguientes ejemplos.)
El nombre de la función utilizada con la etiqueta no es nada especial, se puede utilizar cualquier nombre de función en su lugar.
jslet persona = "Mike";
let edad = 28;

function myTag(strings, expPersona, expEdad) {
  let str0 = strings[0]; // "Ese "
  let str1 = strings[1]; // " es un "

  // Tecnicamente, hay una cadena de
  // caracteres después de la expresión
  // final (en nuestro ejemplo) pero
  // está vacia (""), asi que se ignora.
  // let str2 = strings[2];

  let strEdad;
  if (expEdad > 99) {
    strEdad = "viejo";
  } else {
    strEdad = "joven";
  }

  // Podemos incluso retornar una cadena de
  // caracteres utilizando una plantilla literal.
  return `${str0}${expPersona}${str1}${strEdad}`;
}

var salida = myTag`Ese ${persona} es un ${edad}`;

console.log(salida);
// Ese Mike es un joven

Las funciones de etiqueta incluso pueden devolver valores que no sean cadenas de caracteres:
jsfunction plantilla(cadenas, ...claves) {
  return function (...valores) {
    let diccio = valores[valores.length - 1] || {};
    let resultado = [cadenas[0]];
    claves.forEach(function (clave, i) {
      let valor = Number.isInteger(clave) ? valores[clave] : diccio[clave];
      resultado.push(valor, cadenas[i + 1]);
    });
    return resultado.join("");
  };
}

let t1Closure = plantilla`¡${0}${1}${2}${2}${3}!`;
//let t1Closure = plantilla(["¡","","","","","","!"],0,1,2,3);
t1Closure("H", "U", "R", "A"); // "¡HURRA!"

let t2Closure = plantilla`${0} ${"foo"}!`;
//let t2Closure = plantilla(["¡",""," ","!"],0,"foo");
t2Closure("Hola", { foo: "Mundo" }); // "¡Hola Mundo!"

let t3Closure = plantilla`Me llamo ${"nombre"}. Tengo casi ${"edad"} años.`;
//let t3Closure = plantilla(["Me llamo ", ". Tengo casi ", " años."], "nombre", "edad");
t3Closure("foo", { nombre: "MDN", edad: 30 }); //"Me llamo MDN. Tengo casi 30 años."
t3Closure({ nombre: "MDN", edad: 30 }); //"Me llamo MDN. Tengo casi 30 años."
Cadenas en crudo (raw)La propiedad especial raw, disponible en el primer argumento de la función de etiqueta, permite acceso a las cadenas de caracteres tal como fueron ingresadas, sin procesar secuencias de escape.
jsfunction etiqueta(cadenas) {
  console.log(cadenas.raw[0]);
}

etiqueta`texto de cadena de caracteres 1 \n texto de cadena de caracteres 2`;
// muestra "texto de cadena de caracteres 1 \n texto de cadena de caracteres 2" ,
// incluyendo los caracteres '\' y 'n'

Adicionalmente, el método String.raw() permite crear cadenas de caracteres en crudo tal como serían generadas por la función por defecto de plantilla, concatenando sus partes.
jslet cadena = String.raw`¡Hola\n${2 + 3}!`;
// "¡Hola\n5!"

cadena.length;
// 9

Array.from(cadena).join(",");
// "¡,H,o,l,a,\,n,5,!"
Plantillas etiquetadas y secuencias de escapeComportamiento en ES2016
Comenzando con ECMAScript 2016, las plantillas etiquetadas se comportan de acuerdo con las normas de las siguientes secuencias de escape:

Secuencias de escape de formato Unicode comenzando con "\u", como \u00A9
Secuencias de escape de formato Unicode de punto de código, indicadas con "\u{}", como \u{2F804}
Secuencias de escape de numeros hexadecimales comenzando con "\x", como \xA9
Secuencias de escape de octales literales comenzando con "\0o" seguidas de uno o más dígitos, como \0o251

Esto significa que una plantilla etiquetada como la siguiente podría causar problemas, dado que, de acuerdo con la gramática de ECMAScript, un analizador buscará secuencias de escape de formato Unicode válidas pero encontrará sintaxis equivocado:
jslatex`\unicode`;
// En ECMAScript 2016 y versiones anteriores, lanza
// SyntaxError: malformed Unicode character escape sequence
Revision de secuencias de escape no permitidas en ES2018Las plantillas etiquetadas deberías permitir la inserción de lenguages (como los DSL, o LaTeX), en donde otras secuencias de escape se ven comúnmente. La propuesta para ECMAScript Template Literal Revision (Revisión de Plantilla Literal) (Cuarta Etapa, en camino a ser integrada al estándar de ECMAScript 2018) elimina la restricción de las secuencias de escape en ECMAScript para las plantillas etiquetadas.
Aún así, las secuencias de escape no permitidas deben ser representadas en la representación "cocinada" de la cadena. Aparecerán como elementos no definidos en el array llamado "cocinado" en el siguiente ejemplo.
jsfunction latex(str) {
  return { cocinado: str[0], "en crudo": str.raw[0] };
}

latex`\unicode`;

// { cocinado: undefined, en crudo: "\\unicode" }

Cabe destacar que la restricción para secuencias de escape solo ha sido eliminada para plantillas etiquetadas. Aún permanece para plantillas literales sin etiqueta:
jslet bad = `bad escape sequence: \unicode`;
EspecificacionesSpecificationECMAScript® 2026 Language Specification # sec-template-literalsCompatibilidad con navegadoresVer también
String
String.raw()
Lexical grammar
Template-like strings in ES3 compatible syntax
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 17 dic 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nPlantillas literales (plantillas de cadenas)Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackLas plantillas literales son cadenas literales que habilitan el uso de expresiones incrustadas. Con ellas, es posible utilizar cadenas de caracteres de más de una línea, y funcionalidades de interpolación de cadenas de caracteres.
En ediciones anteriores de la especificación ES2015, solían llamarse "plantillas de cadenas de caracteres".Sintaxis`texto de cadena de caracteres`

`línea 1 de la cadena de caracteres
  línea 2 de la cadena de caracteres`

`texto de cadena de caracteres ${expresión} texto adicional`

etiqueta`texto de cadena de caracteres ${expresión} texto adicional`
DescripciónLas plantillas literales se delimitan con el caracter de comillas o tildes invertidas (` `) (grave accent), en lugar de las comillas sencillas o dobles.
Las plantillas de cadena de caracteres pueden contener marcadores, identificados por el signo de dólar y envueltos en llaves (${expresión}). Las expresiones contenidas en los marcadores, junto con el texto entre ellas, son enviados como argumentos a una función.
La función por defecto sencillamente concatena las partes para formar una única cadena de caracteres. Si hay una expresión antes de la plantilla literal (aquí indicada mediante etiqueta), se le conoce como "plantilla etiquetada". En este caso, la expresión de etiqueta (típicamente una función) es llamada con la plantilla literal como parámetro, que luego puede ser manipulada antes de ser devuelta.
En caso de querer escapar una comilla o tilde invertida en una plantilla literal, se debe poner una barra invertida (\) antes de la comilla o tilde invertida.
js`\`` === "`"; // --> true (cierto)
Cadenas de más de una líneaLos caracteres de fin de línea encontrados forman parte de la plantilla literal.
Utilizando cadenas de caracteres normales, sería necesario utilizar la siguiente sintaxis para producir cadenas de más de una línea:
jsconsole.log("línea 1 de cadena de texto\n" + "línea 2 de cadena de texto");
// "línea 1 de cadena de texto
// línea 2 de cadena de texto"

Utilizando plantillas literales, se puede obtener el mismo resultado de la siguiente forma:
jsconsole.log(`línea 1 de la cadena de texto
línea 2 de la cadena de texto`);
// "línea 1 de la cadena de texto
// línea 2 de la cadena de texto"
Interpolación de expresionesPara insertar expresiones dentro de cadenas de caracteres normales, se utilizaría la siguiente sintaxis:
jslet a = 5;
let b = 10;
console.log("Quince es " + (a + b) + " y\nno " + (2 * a + b) + ".");
// "Quince es 15 y
// no 20."

Ahora, con las plantillas literales, se pueden utilizar sus nuevas capacidades (es decir, insertar expresiones con ${ } e incluir caracteres de fin de linea literales dentro de la cadena) para simplificar la sintaxis:
jslet a = 5;
let b = 10;
console.log(`Quince es ${a + b} y
no ${2 * a + b}.`);
// "Quince es 15 y
// no 20."
Anidamiento de plantillasEn ciertos casos, anidar una plantilla es la forma más fácil, e incluso más legible, de tener cadenas configurables. Dentro de una plantilla con tildes invertidas, es sencillo permitir tildes invertidas interiores simplemente usándolas dentro de un marcador de posición ${ } dentro de la plantilla.
Por ejemplo, si la condición a es true (cierta): entonces return (devuelva) este literal con plantilla.
En ES5:
jslet classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

En ES2015 con plantillas literales y sin anidamiento:
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

En ES5 con plantillas literales anidadas:
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
Plantillas etiquetadasUna forma más avanzada de plantillas literales son las plantillas etiquetadas.
Con ellas es posible modificar la salida de las plantillas utilizando una función. El primer argumento contiene un array con una o más cadenas de caracteres. El segundo y subsiguientes argumentos se asocian con las expresiones de la plantilla.
La función de etiqueta puede ejecutar cualesquiera operaciones deseadas con estos argumentos, y luego devolver la cadena manipulada. (También puede devolver algo totalmente distinto, como se muestra en uno de los siguientes ejemplos.)
El nombre de la función utilizada con la etiqueta no es nada especial, se puede utilizar cualquier nombre de función en su lugar.
jslet persona = "Mike";
let edad = 28;

function myTag(strings, expPersona, expEdad) {
  let str0 = strings[0]; // "Ese "
  let str1 = strings[1]; // " es un "

  // Tecnicamente, hay una cadena de
  // caracteres después de la expresión
  // final (en nuestro ejemplo) pero
  // está vacia (""), asi que se ignora.
  // let str2 = strings[2];

  let strEdad;
  if (expEdad > 99) {
    strEdad = "viejo";
  } else {
    strEdad = "joven";
  }

  // Podemos incluso retornar una cadena de
  // caracteres utilizando una plantilla literal.
  return `${str0}${expPersona}${str1}${strEdad}`;
}

var salida = myTag`Ese ${persona} es un ${edad}`;

console.log(salida);
// Ese Mike es un joven

Las funciones de etiqueta incluso pueden devolver valores que no sean cadenas de caracteres:
jsfunction plantilla(cadenas, ...claves) {
  return function (...valores) {
    let diccio = valores[valores.length - 1] || {};
    let resultado = [cadenas[0]];
    claves.forEach(function (clave, i) {
      let valor = Number.isInteger(clave) ? valores[clave] : diccio[clave];
      resultado.push(valor, cadenas[i + 1]);
    });
    return resultado.join("");
  };
}

let t1Closure = plantilla`¡${0}${1}${2}${2}${3}!`;
//let t1Closure = plantilla(["¡","","","","","","!"],0,1,2,3);
t1Closure("H", "U", "R", "A"); // "¡HURRA!"

let t2Closure = plantilla`${0} ${"foo"}!`;
//let t2Closure = plantilla(["¡",""," ","!"],0,"foo");
t2Closure("Hola", { foo: "Mundo" }); // "¡Hola Mundo!"

let t3Closure = plantilla`Me llamo ${"nombre"}. Tengo casi ${"edad"} años.`;
//let t3Closure = plantilla(["Me llamo ", ". Tengo casi ", " años."], "nombre", "edad");
t3Closure("foo", { nombre: "MDN", edad: 30 }); //"Me llamo MDN. Tengo casi 30 años."
t3Closure({ nombre: "MDN", edad: 30 }); //"Me llamo MDN. Tengo casi 30 años."
Cadenas en crudo (raw)La propiedad especial raw, disponible en el primer argumento de la función de etiqueta, permite acceso a las cadenas de caracteres tal como fueron ingresadas, sin procesar secuencias de escape.
jsfunction etiqueta(cadenas) {
  console.log(cadenas.raw[0]);
}

etiqueta`texto de cadena de caracteres 1 \n texto de cadena de caracteres 2`;
// muestra "texto de cadena de caracteres 1 \n texto de cadena de caracteres 2" ,
// incluyendo los caracteres '\' y 'n'

Adicionalmente, el método String.raw() permite crear cadenas de caracteres en crudo tal como serían generadas por la función por defecto de plantilla, concatenando sus partes.
jslet cadena = String.raw`¡Hola\n${2 + 3}!`;
// "¡Hola\n5!"

cadena.length;
// 9

Array.from(cadena).join(",");
// "¡,H,o,l,a,\,n,5,!"
Plantillas etiquetadas y secuencias de escapeComportamiento en ES2016
Comenzando con ECMAScript 2016, las plantillas etiquetadas se comportan de acuerdo con las normas de las siguientes secuencias de escape:

Secuencias de escape de formato Unicode comenzando con "\u", como \u00A9
Secuencias de escape de formato Unicode de punto de código, indicadas con "\u{}", como \u{2F804}
Secuencias de escape de numeros hexadecimales comenzando con "\x", como \xA9
Secuencias de escape de octales literales comenzando con "\0o" seguidas de uno o más dígitos, como \0o251

Esto significa que una plantilla etiquetada como la siguiente podría causar problemas, dado que, de acuerdo con la gramática de ECMAScript, un analizador buscará secuencias de escape de formato Unicode válidas pero encontrará sintaxis equivocado:
jslatex`\unicode`;
// En ECMAScript 2016 y versiones anteriores, lanza
// SyntaxError: malformed Unicode character escape sequence
Revision de secuencias de escape no permitidas en ES2018Las plantillas etiquetadas deberías permitir la inserción de lenguages (como los DSL, o LaTeX), en donde otras secuencias de escape se ven comúnmente. La propuesta para ECMAScript Template Literal Revision (Revisión de Plantilla Literal) (Cuarta Etapa, en camino a ser integrada al estándar de ECMAScript 2018) elimina la restricción de las secuencias de escape en ECMAScript para las plantillas etiquetadas.
Aún así, las secuencias de escape no permitidas deben ser representadas en la representación "cocinada" de la cadena. Aparecerán como elementos no definidos en el array llamado "cocinado" en el siguiente ejemplo.
jsfunction latex(str) {
  return { cocinado: str[0], "en crudo": str.raw[0] };
}

latex`\unicode`;

// { cocinado: undefined, en crudo: "\\unicode" }

Cabe destacar que la restricción para secuencias de escape solo ha sido eliminada para plantillas etiquetadas. Aún permanece para plantillas literales sin etiqueta:
jslet bad = `bad escape sequence: \unicode`;
EspecificacionesSpecificationECMAScript® 2026 Language Specification # sec-template-literalsCompatibilidad con navegadoresVer también
String
String.raw()
Lexical grammar
Template-like strings in ES3 compatible syntax
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 17 dic 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nLittéraux de gabaritsBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackLes littéraux de gabarits sont des littéraux de chaînes de caractères permettant d'intégrer des expressions. Avec eux, on peut utiliser des chaînes de caractères multi-lignes et des fonctionnalités d'interpolation.

Note :
Dans les premières versions de la spécification ECMAScript 2015, cette fonctionnalité était intitulée « gabarits de chaîne de caractères ». Dans la suite de cet article, les expressions « gabarits de texte », « gabarits de libellés », « littéraux de gabarits » et « gabarits » seront équivalents.
Syntaxejs`texte``ligne de texte 1
  ligne de texte 2``texte ${expression} texte`;

etiquette`texte ${expression} texte`;
DescriptionLes gabarits sont délimités par des caractères accent grave (` `) au lieu des apostrophes doubles ou simples. Les gabarits peuvent contenir des espaces réservés (placeholders). Ces espaces sont indiqués par le signe dollar ($) et des accolades (${expression}). Les expressions dans les espaces réservés et le texte compris dans ces espaces sont passés à une fonction.
Pour créer la chaîne finale, la fonction par défaut concatène simplement les différentes parties en une seule chaîne. Toutefois, on peut utiliser une fonction spécifique pour obtenir un comportement différent et recomposer la chaîne avec une autre logique. On parlera alors de gabarit étiqueté (cf. ci-après).
jslet rep = 42;
console.log(`La réponse est ${rep}`); // Gabarit simple avec la concaténation par défaut

function concatenationAdHoc(chaines, reponse) {
  let parite;
  if (reponse % 2 === 0) {
    parite = "paire";
  } else {
    parite = "impaire";
  }
  return `${chaines[0]}${parite}.`;
}
// concaténation spécifique où on modifie la sortie
console.log(concatenationAdHoc`La réponse est ${rep}.`);

Pour utiliser des accents graves dans un gabarit, on les échappera avec une barre oblique inverse (\) :
js`\`` === "`"; // true
Les chaînes de caractères multi-lignesTous les caractères de saut de ligne insérés dans la source font partie du gabarit. Avec des chaînes de caractères normales, il aurait fallu utiliser la syntaxe suivante pour obtenir des chaînes multi-lignes :
jsconsole.log("ligne de texte 1\n" + "ligne de texte 2");
// "ligne de texte 1
// ligne de texte 2"

Pour obtenir le même effet avec les gabarits, on peut désormais écrire :
jsconsole.log(`ligne de texte 1
ligne de texte 2`);
// "ligne de texte 1
//  ligne de texte 2"
Interpolation d'expressionsPour intégrer des expressions dans des chaînes de caractères normales, il fallait utiliser la syntaxe suivante :
jslet a = 5;
let b = 10;
console.log("Quinze vaut " + (a + b) + " et\nnon " + (2 * a + b) + ".");
// "Quinze vaut 15 et
// non 20."

On peut désormais utiliser le sucre syntaxique fourni par les gabarits pour rendre les substitutions plus lisibles :
jslet a = 5;
let b = 10;
console.log(`Quinze vaut ${a + b} et
non ${2 * a + b}.`);
// "Quinze vaut 15 et
// non 20."
Imbrication de gabaritsParfois, l'imbrication d'un gabarit est la solution la plus simple (et peut-être la plus lisible) pour obtenir des chaînes de caractères configurables.
En ES5 :
jslet classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

En ES2015 avec des gabarits et sans imbrication :
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

En ES2015 avec des gabarits imbriqués :
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
Gabarits étiquetésLes gabarits étiquetés (tagged templates) sont une forme plus avancée de gabarits. On peut ici utiliser une fonction pour analyser les différents fragments du gabarit. Le premier argument passé à la fonction est l'ensemble de valeurs issues de chaînes de caractères sous la forme d'un tableau. Les arguments ensuite passés à la fonction seront les expressions contenues dans le gabarit. La fonction pourra ainsi créer une chaîne avec une autre forme de concaténation et utiliser une logique spécifique. La fonction utilisée pour le formatage du gabarit peut être nommée comme n'importe quelle autre fonction.
jslet personne = "Michou";
let age = 28;

function monEtiquette(chaines, expPersonne, expAge) {
  let chn0 = chaines[0]; // "ce "
  let chn1 = chaines[1]; // " est un "

  // Techniquement, il y a une chaîne après
  // l'expression finale (dans notre exemple),
  // mais elle est vide (""), donc ne pas en tenir compte.
  // var chn2 = chaines[2];

  let chnAge;
  if (expAge > 99) {
    chnAge = "centenaire";
  } else {
    chnAge = "jeunot";
  }
  // On peut tout à fait renvoyer une chaîne construite
  // avec un gabarit
  return `${chn0}${expPersonne}${chn1}${chnAge}`;
}

let sortie = monEtiquette`ce ${personne} est un ${age}`;

console.log(sortie);
// ce Michou est un jeunot
Chaînes brutesLa propriété spéciale raw, disponible sur le premier argument de la fonction du gabarit étiqueté, vous permet d'accéder aux chaînes brutes, telles qu'elles ont été entrées, sans traiter les séquences d'échappement.
jsfunction etiquette(chaines) {
  console.log(chaines.raw[0]);
}

etiquette`ligne de texte 1 \n ligne de texte 2`;
// affichera dans la console :
// "ligne de texte 1 \n ligne de texte 2"

En outre, la méthode String.raw() a pour fonction de créer des chaînes de caractères brutes, exactement comme la fonction de gabarit et de concaténation de chaînes par défaut le ferait :
jslet chn = String.raw`Salut\n${2 + 3}!`;
// "Salut\n5!"

chn.length;
// 9

chn.split("").join(",");
// "S,a,l,u,t,\,n,5,!"
Les gabarits étiquetés et les séquences d'échappementComportement de ES2016
Quant à ECMAScript 2016, les gabarits étiquetés se conforment aux règles de séquences d'échappement suivantes :

Les séquences d'échappement Unicode commencent par "\u", par exemple\u00A9
Les séquences d'échappement pour les points de code Unicode sont indiquées par "\u{}", par exemple \u{2F804}
Les séquences d'échappement hexadécimales commencent par "\x", par exemple \xA9
Les séquences d'échappement octales commencent par un "\0o" suivi d'un (ou plusieurs) chiffre(s), par exemple \0o251.

Cela signifie qu'un gabarit étiqueté comme celui qui suit pose problème du fait que, selon la grammaire ECMAScript, un analyseur recherchera des séquences d'échappement Unicode valides, mais trouvera la syntaxe mal formée :
jslatex`\unicode`;
// Génère, dans les anciennes versions ECMAScript (ES2016 et précédentes)
// SyntaxError: malformed Unicode character escape sequence

Révision ES2018 pour les séquences d'échappement illégales
Les gabarits étiquetés doivent permettre l'intégration d'autres langages (par exemple, des DSL ou du LaTeX), dans lesquels d'autres séquences d'échappement sont fréquentes. La proposition Template Literal Revision pour ECMAScript (étape 4, à intégrer dans le standard ECMAScript 2018) supprime la restriction syntaxique des séquences d'échappement dans les gabarits étiquetés.
Toutefois, les séquences d'échappement illégales doivent toujours être représentées dans la version "bidouillée". Elles seront affichées comme un élément undefined dans le tableau "bidouillé" :
jsfunction latex(chn) {
  return { bidouillee: chn[0], brute: chn.raw[0] };
}

latex`\unicode`;

// { bidouillee: undefined, brute: "\\unicode" }

Notez que la restriction sur les séquences d'échappement est uniquement supprimée pour les gabarits étiquetés, et non pour les gabarits de libellés non étiquetés :
jslet mauvaise = `mauvaise séquence d'échappement : \unicode`;
SpécificationsSpecificationECMAScript® 2026 Language Specification # sec-template-literalsCompatibilité des navigateursVoir aussi
String
String.raw()
Grammaire lexicale
Template-like strings in ES3 compatible syntax
ES6 en détails : les gabarits de libellé sur tech.mozfr.org
Styled Components\n\nLittéraux de gabaritsBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackLes littéraux de gabarits sont des littéraux de chaînes de caractères permettant d'intégrer des expressions. Avec eux, on peut utiliser des chaînes de caractères multi-lignes et des fonctionnalités d'interpolation.

Note :
Dans les premières versions de la spécification ECMAScript 2015, cette fonctionnalité était intitulée « gabarits de chaîne de caractères ». Dans la suite de cet article, les expressions « gabarits de texte », « gabarits de libellés », « littéraux de gabarits » et « gabarits » seront équivalents.
Syntaxejs`texte``ligne de texte 1
  ligne de texte 2``texte ${expression} texte`;

etiquette`texte ${expression} texte`;
DescriptionLes gabarits sont délimités par des caractères accent grave (` `) au lieu des apostrophes doubles ou simples. Les gabarits peuvent contenir des espaces réservés (placeholders). Ces espaces sont indiqués par le signe dollar ($) et des accolades (${expression}). Les expressions dans les espaces réservés et le texte compris dans ces espaces sont passés à une fonction.
Pour créer la chaîne finale, la fonction par défaut concatène simplement les différentes parties en une seule chaîne. Toutefois, on peut utiliser une fonction spécifique pour obtenir un comportement différent et recomposer la chaîne avec une autre logique. On parlera alors de gabarit étiqueté (cf. ci-après).
jslet rep = 42;
console.log(`La réponse est ${rep}`); // Gabarit simple avec la concaténation par défaut

function concatenationAdHoc(chaines, reponse) {
  let parite;
  if (reponse % 2 === 0) {
    parite = "paire";
  } else {
    parite = "impaire";
  }
  return `${chaines[0]}${parite}.`;
}
// concaténation spécifique où on modifie la sortie
console.log(concatenationAdHoc`La réponse est ${rep}.`);

Pour utiliser des accents graves dans un gabarit, on les échappera avec une barre oblique inverse (\) :
js`\`` === "`"; // true
Les chaînes de caractères multi-lignesTous les caractères de saut de ligne insérés dans la source font partie du gabarit. Avec des chaînes de caractères normales, il aurait fallu utiliser la syntaxe suivante pour obtenir des chaînes multi-lignes :
jsconsole.log("ligne de texte 1\n" + "ligne de texte 2");
// "ligne de texte 1
// ligne de texte 2"

Pour obtenir le même effet avec les gabarits, on peut désormais écrire :
jsconsole.log(`ligne de texte 1
ligne de texte 2`);
// "ligne de texte 1
//  ligne de texte 2"
Interpolation d'expressionsPour intégrer des expressions dans des chaînes de caractères normales, il fallait utiliser la syntaxe suivante :
jslet a = 5;
let b = 10;
console.log("Quinze vaut " + (a + b) + " et\nnon " + (2 * a + b) + ".");
// "Quinze vaut 15 et
// non 20."

On peut désormais utiliser le sucre syntaxique fourni par les gabarits pour rendre les substitutions plus lisibles :
jslet a = 5;
let b = 10;
console.log(`Quinze vaut ${a + b} et
non ${2 * a + b}.`);
// "Quinze vaut 15 et
// non 20."
Imbrication de gabaritsParfois, l'imbrication d'un gabarit est la solution la plus simple (et peut-être la plus lisible) pour obtenir des chaînes de caractères configurables.
En ES5 :
jslet classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

En ES2015 avec des gabarits et sans imbrication :
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

En ES2015 avec des gabarits imbriqués :
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
Gabarits étiquetésLes gabarits étiquetés (tagged templates) sont une forme plus avancée de gabarits. On peut ici utiliser une fonction pour analyser les différents fragments du gabarit. Le premier argument passé à la fonction est l'ensemble de valeurs issues de chaînes de caractères sous la forme d'un tableau. Les arguments ensuite passés à la fonction seront les expressions contenues dans le gabarit. La fonction pourra ainsi créer une chaîne avec une autre forme de concaténation et utiliser une logique spécifique. La fonction utilisée pour le formatage du gabarit peut être nommée comme n'importe quelle autre fonction.
jslet personne = "Michou";
let age = 28;

function monEtiquette(chaines, expPersonne, expAge) {
  let chn0 = chaines[0]; // "ce "
  let chn1 = chaines[1]; // " est un "

  // Techniquement, il y a une chaîne après
  // l'expression finale (dans notre exemple),
  // mais elle est vide (""), donc ne pas en tenir compte.
  // var chn2 = chaines[2];

  let chnAge;
  if (expAge > 99) {
    chnAge = "centenaire";
  } else {
    chnAge = "jeunot";
  }
  // On peut tout à fait renvoyer une chaîne construite
  // avec un gabarit
  return `${chn0}${expPersonne}${chn1}${chnAge}`;
}

let sortie = monEtiquette`ce ${personne} est un ${age}`;

console.log(sortie);
// ce Michou est un jeunot
Chaînes brutesLa propriété spéciale raw, disponible sur le premier argument de la fonction du gabarit étiqueté, vous permet d'accéder aux chaînes brutes, telles qu'elles ont été entrées, sans traiter les séquences d'échappement.
jsfunction etiquette(chaines) {
  console.log(chaines.raw[0]);
}

etiquette`ligne de texte 1 \n ligne de texte 2`;
// affichera dans la console :
// "ligne de texte 1 \n ligne de texte 2"

En outre, la méthode String.raw() a pour fonction de créer des chaînes de caractères brutes, exactement comme la fonction de gabarit et de concaténation de chaînes par défaut le ferait :
jslet chn = String.raw`Salut\n${2 + 3}!`;
// "Salut\n5!"

chn.length;
// 9

chn.split("").join(",");
// "S,a,l,u,t,\,n,5,!"
Les gabarits étiquetés et les séquences d'échappementComportement de ES2016
Quant à ECMAScript 2016, les gabarits étiquetés se conforment aux règles de séquences d'échappement suivantes :

Les séquences d'échappement Unicode commencent par "\u", par exemple\u00A9
Les séquences d'échappement pour les points de code Unicode sont indiquées par "\u{}", par exemple \u{2F804}
Les séquences d'échappement hexadécimales commencent par "\x", par exemple \xA9
Les séquences d'échappement octales commencent par un "\0o" suivi d'un (ou plusieurs) chiffre(s), par exemple \0o251.

Cela signifie qu'un gabarit étiqueté comme celui qui suit pose problème du fait que, selon la grammaire ECMAScript, un analyseur recherchera des séquences d'échappement Unicode valides, mais trouvera la syntaxe mal formée :
jslatex`\unicode`;
// Génère, dans les anciennes versions ECMAScript (ES2016 et précédentes)
// SyntaxError: malformed Unicode character escape sequence

Révision ES2018 pour les séquences d'échappement illégales
Les gabarits étiquetés doivent permettre l'intégration d'autres langages (par exemple, des DSL ou du LaTeX), dans lesquels d'autres séquences d'échappement sont fréquentes. La proposition Template Literal Revision pour ECMAScript (étape 4, à intégrer dans le standard ECMAScript 2018) supprime la restriction syntaxique des séquences d'échappement dans les gabarits étiquetés.
Toutefois, les séquences d'échappement illégales doivent toujours être représentées dans la version "bidouillée". Elles seront affichées comme un élément undefined dans le tableau "bidouillé" :
jsfunction latex(chn) {
  return { bidouillee: chn[0], brute: chn.raw[0] };
}

latex`\unicode`;

// { bidouillee: undefined, brute: "\\unicode" }

Notez que la restriction sur les séquences d'échappement est uniquement supprimée pour les gabarits étiquetés, et non pour les gabarits de libellés non étiquetés :
jslet mauvaise = `mauvaise séquence d'échappement : \unicode`;
SpécificationsSpecificationECMAScript® 2026 Language Specification # sec-template-literalsCompatibilité des navigateursVoir aussi
String
String.raw()
Grammaire lexicale
Template-like strings in ES3 compatible syntax
ES6 en détails : les gabarits de libellé sur tech.mozfr.org
Styled Components
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 17 déc. 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nLittéraux de gabaritsBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackLes littéraux de gabarits sont des littéraux de chaînes de caractères permettant d'intégrer des expressions. Avec eux, on peut utiliser des chaînes de caractères multi-lignes et des fonctionnalités d'interpolation.

Note :
Dans les premières versions de la spécification ECMAScript 2015, cette fonctionnalité était intitulée « gabarits de chaîne de caractères ». Dans la suite de cet article, les expressions « gabarits de texte », « gabarits de libellés », « littéraux de gabarits » et « gabarits » seront équivalents.
Syntaxejs`texte``ligne de texte 1
  ligne de texte 2``texte ${expression} texte`;

etiquette`texte ${expression} texte`;
DescriptionLes gabarits sont délimités par des caractères accent grave (` `) au lieu des apostrophes doubles ou simples. Les gabarits peuvent contenir des espaces réservés (placeholders). Ces espaces sont indiqués par le signe dollar ($) et des accolades (${expression}). Les expressions dans les espaces réservés et le texte compris dans ces espaces sont passés à une fonction.
Pour créer la chaîne finale, la fonction par défaut concatène simplement les différentes parties en une seule chaîne. Toutefois, on peut utiliser une fonction spécifique pour obtenir un comportement différent et recomposer la chaîne avec une autre logique. On parlera alors de gabarit étiqueté (cf. ci-après).
jslet rep = 42;
console.log(`La réponse est ${rep}`); // Gabarit simple avec la concaténation par défaut

function concatenationAdHoc(chaines, reponse) {
  let parite;
  if (reponse % 2 === 0) {
    parite = "paire";
  } else {
    parite = "impaire";
  }
  return `${chaines[0]}${parite}.`;
}
// concaténation spécifique où on modifie la sortie
console.log(concatenationAdHoc`La réponse est ${rep}.`);

Pour utiliser des accents graves dans un gabarit, on les échappera avec une barre oblique inverse (\) :
js`\`` === "`"; // true
Les chaînes de caractères multi-lignesTous les caractères de saut de ligne insérés dans la source font partie du gabarit. Avec des chaînes de caractères normales, il aurait fallu utiliser la syntaxe suivante pour obtenir des chaînes multi-lignes :
jsconsole.log("ligne de texte 1\n" + "ligne de texte 2");
// "ligne de texte 1
// ligne de texte 2"

Pour obtenir le même effet avec les gabarits, on peut désormais écrire :
jsconsole.log(`ligne de texte 1
ligne de texte 2`);
// "ligne de texte 1
//  ligne de texte 2"
Interpolation d'expressionsPour intégrer des expressions dans des chaînes de caractères normales, il fallait utiliser la syntaxe suivante :
jslet a = 5;
let b = 10;
console.log("Quinze vaut " + (a + b) + " et\nnon " + (2 * a + b) + ".");
// "Quinze vaut 15 et
// non 20."

On peut désormais utiliser le sucre syntaxique fourni par les gabarits pour rendre les substitutions plus lisibles :
jslet a = 5;
let b = 10;
console.log(`Quinze vaut ${a + b} et
non ${2 * a + b}.`);
// "Quinze vaut 15 et
// non 20."
Imbrication de gabaritsParfois, l'imbrication d'un gabarit est la solution la plus simple (et peut-être la plus lisible) pour obtenir des chaînes de caractères configurables.
En ES5 :
jslet classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

En ES2015 avec des gabarits et sans imbrication :
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

En ES2015 avec des gabarits imbriqués :
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
Gabarits étiquetésLes gabarits étiquetés (tagged templates) sont une forme plus avancée de gabarits. On peut ici utiliser une fonction pour analyser les différents fragments du gabarit. Le premier argument passé à la fonction est l'ensemble de valeurs issues de chaînes de caractères sous la forme d'un tableau. Les arguments ensuite passés à la fonction seront les expressions contenues dans le gabarit. La fonction pourra ainsi créer une chaîne avec une autre forme de concaténation et utiliser une logique spécifique. La fonction utilisée pour le formatage du gabarit peut être nommée comme n'importe quelle autre fonction.
jslet personne = "Michou";
let age = 28;

function monEtiquette(chaines, expPersonne, expAge) {
  let chn0 = chaines[0]; // "ce "
  let chn1 = chaines[1]; // " est un "

  // Techniquement, il y a une chaîne après
  // l'expression finale (dans notre exemple),
  // mais elle est vide (""), donc ne pas en tenir compte.
  // var chn2 = chaines[2];

  let chnAge;
  if (expAge > 99) {
    chnAge = "centenaire";
  } else {
    chnAge = "jeunot";
  }
  // On peut tout à fait renvoyer une chaîne construite
  // avec un gabarit
  return `${chn0}${expPersonne}${chn1}${chnAge}`;
}

let sortie = monEtiquette`ce ${personne} est un ${age}`;

console.log(sortie);
// ce Michou est un jeunot
Chaînes brutesLa propriété spéciale raw, disponible sur le premier argument de la fonction du gabarit étiqueté, vous permet d'accéder aux chaînes brutes, telles qu'elles ont été entrées, sans traiter les séquences d'échappement.
jsfunction etiquette(chaines) {
  console.log(chaines.raw[0]);
}

etiquette`ligne de texte 1 \n ligne de texte 2`;
// affichera dans la console :
// "ligne de texte 1 \n ligne de texte 2"

En outre, la méthode String.raw() a pour fonction de créer des chaînes de caractères brutes, exactement comme la fonction de gabarit et de concaténation de chaînes par défaut le ferait :
jslet chn = String.raw`Salut\n${2 + 3}!`;
// "Salut\n5!"

chn.length;
// 9

chn.split("").join(",");
// "S,a,l,u,t,\,n,5,!"
Les gabarits étiquetés et les séquences d'échappementComportement de ES2016
Quant à ECMAScript 2016, les gabarits étiquetés se conforment aux règles de séquences d'échappement suivantes :

Les séquences d'échappement Unicode commencent par "\u", par exemple\u00A9
Les séquences d'échappement pour les points de code Unicode sont indiquées par "\u{}", par exemple \u{2F804}
Les séquences d'échappement hexadécimales commencent par "\x", par exemple \xA9
Les séquences d'échappement octales commencent par un "\0o" suivi d'un (ou plusieurs) chiffre(s), par exemple \0o251.

Cela signifie qu'un gabarit étiqueté comme celui qui suit pose problème du fait que, selon la grammaire ECMAScript, un analyseur recherchera des séquences d'échappement Unicode valides, mais trouvera la syntaxe mal formée :
jslatex`\unicode`;
// Génère, dans les anciennes versions ECMAScript (ES2016 et précédentes)
// SyntaxError: malformed Unicode character escape sequence

Révision ES2018 pour les séquences d'échappement illégales
Les gabarits étiquetés doivent permettre l'intégration d'autres langages (par exemple, des DSL ou du LaTeX), dans lesquels d'autres séquences d'échappement sont fréquentes. La proposition Template Literal Revision pour ECMAScript (étape 4, à intégrer dans le standard ECMAScript 2018) supprime la restriction syntaxique des séquences d'échappement dans les gabarits étiquetés.
Toutefois, les séquences d'échappement illégales doivent toujours être représentées dans la version "bidouillée". Elles seront affichées comme un élément undefined dans le tableau "bidouillé" :
jsfunction latex(chn) {
  return { bidouillee: chn[0], brute: chn.raw[0] };
}

latex`\unicode`;

// { bidouillee: undefined, brute: "\\unicode" }

Notez que la restriction sur les séquences d'échappement est uniquement supprimée pour les gabarits étiquetés, et non pour les gabarits de libellés non étiquetés :
jslet mauvaise = `mauvaise séquence d'échappement : \unicode`;
SpécificationsSpecificationECMAScript® 2026 Language Specification # sec-template-literalsCompatibilité des navigateursVoir aussi
String
String.raw()
Grammaire lexicale
Template-like strings in ES3 compatible syntax
ES6 en détails : les gabarits de libellé sur tech.mozfr.org
Styled Components
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 17 déc. 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nテンプレートリテラル (テンプレート文字列)Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackテンプレートリテラルは逆引用符 (`) で区切られたリテラルで、複数行の文字列、埋め込み式による文字列の補間、タグ付きテンプレートと呼ばれる特殊な構文を許可します。
テンプレートリテラルは非公式に「テンプレート文字列」と呼ばれることもあります。文字列の補間のためにもっともよく使用されるからです。しかし、タグ付けされたテンプレートリテラルが文字列になるとは限りません。カスタムのタグ関数と併用することで、テンプレートリテラルのさまざまな部分に対して、任意の操作を実行することができます。構文js`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tagFunction`string text ${expression} string text`
引数
string text

テンプレートリテラルに含まれる文字列テキストです。ほとんどの文字はそのまま使用できますが、改行やその他のホワイトスペース文字も含まれます。ただし、タグ関数を使用しない限り、無効なエスケープシーケンスは構文エラーの原因となります。

expression

現在の位置に挿入される式で、その値は文字列に変換されるか、 tagFunction に渡されます。

tagFunction

指定された場合、テンプレート文字列の配列と置換式とともに呼び出され、返値がテンプレートリテラルの値となります。タグ付きテンプレートを参照してください。

解説テンプレートリテラルは、二重引用符や単一引用符の代わりに逆引用符文字 (`) で囲みます。
テンプレートリテラルは、通常の文字列を持つことができるだけでなく、プレースホルダーと呼ばれる、ドル記号と波括弧で囲まれた ${expression} という形の埋め込まれた式の部品を含むことができます。文字列とプレースホルダーは、既定の関数またはユーザーが指定した関数に渡されます。既定の関数（ユーザーが関数を指定しない場合）は、プレースホルダーの置換を行う文字列の補間を実行し、その部分を単一の文字列に結合します。
独自の関数を使用するには、テンプレートリテラルの前に関数名を指定します。その結果は、タグ付きテンプレートと呼ばれます。この場合、テンプレートリテラルはタグ関数に渡され、そこでテンプレートリテラルの異なる部分に対して任意の操作を実行することができます。
テンプレートリテラル内で逆引用符文字をエスケープするには、逆引用符文字の前にバックスラッシュ (\) を置きます。
js`\`` === "`"; // true

ドル記号も同様にエスケープすることで、補間を防ぐことができます。
js`\${1}` === "${1}"; // true
複数行の文字列ソースの中に挿入された改行文字は、すべてテンプレートリテラルの一部になります。
通常の文字列を使う場合は、複数行の文字列を得るために次のような構文を使用する必要があります。
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
// string text line 2"

テンプレートリテラルを使用すれば、同じものを次のように書くことができます。
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"

通常の文字列リテラルと同様に、ソースコードの可読性を高めるために、改行をバックスラッシュ (\) でエスケープすることで、単一行の文字列を複数行にわたって記述することができます。
jsconsole.log(`string text line 1 \
string text line 2`);
// "string text line 1 string text line 2"
文字列の補間テンプレートリテラルなしで、式からの出力と文字列を結合したい場合、結合は加算演算子 + を使用して行うことになります。
jsconst a = 5;
const b = 10;
console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");
// "Fifteen is 15 and
// not 20."

特に複数の式がある場合は、読みづらい場合があります。
テンプレートリテラルを使用すると、埋め込み式の置換を行う際に、${expression} 形式のプレースホルダーを使用することで、連結演算子を使わずに、コードの可読性を向上させることができます。
jsconst a = 5;
const b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
// "Fifteen is 15 and
// not 20."

2 つの構文には軽微な違いがあることに注意してください。 テンプレートリテラルは、その式を直接文字列に変換しますが、加算ではまずオペランドをプリミティブに変換します。 詳細は、 + 演算子のリファレンスページをご覧ください。入れ子のテンプレート場合によっては、テンプレートを入れ子にすると、構成可能な文字列を得るのにもっとも簡単に（かつ、おそらくより読みやすく）なることがあります。逆引用符で区切られたテンプレートでは、テンプレート内にあるプレイスホルダー ${expression} の内部で逆引用符を使用することができます。
例えば、テンプレートリテラルがなければ、特定の条件に基づいて特定の値を返したい場合、次のような方法をとることができます。
jslet classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

入れ子なしのテンプレートリテラルを使用すれば、次のようにすることができます。
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

テンプレートリテラルを入れ子で使用すると、次のようにすることができます。
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
タグ付きテンプレートタグ付きテンプレートは、テンプレートリテラルのより高度な形式です。
タグを使用すると、テンプレートリテラルを関数で解析できます。タグ関数の最初の引数には、文字列リテラルの配列を含みます。残りの引数は式に関連付けられます。
タグ関数は、これらの引数に対して何でも望み通りの操作を実行することができ、加工された文字列を返します。（または、以下の例の一つで示しているように、まったく異なるものを返すこともできます。）
タグに使用される関数の名前は、自由に指定できます。
jsconst person = "Mike";
const age = 28;

function myTag(strings, personExp, ageExp) {
  const str0 = strings[0]; // "That "
  const str1 = strings[1]; // " is a "
  const str2 = strings[2]; // "."

  const ageStr = ageExp < 100 ? "youngster" : "centenarian";

  // テンプレートリテラルを用いて組み立てた文字列を返すこともできます
  return `${str0}${personExp}${str1}${ageStr}${str2}`;
}

const output = myTag`That ${person} is a ${age}.`;

console.log(output);
// That Mike is a youngster.

タグは単なる識別子である必要はありません。 16 より大きな優先順位を持つ任意の式を使用でき、これにはプロパティアクセス、関数呼び出し、new 式、さらには別のタグ付きテンプレートリテラルも含まれます。
jsconsole.log`Hello`; // [ 'Hello' ]
console.log.bind(1, 2)`Hello`; // 2 [ 'Hello' ]
new Function("console.log(arguments)")`Hello`; // [Arguments] { '0': [ 'Hello' ] }

function recursive(strings, ...values) {
  console.log(strings, values);
  return recursive;
}
recursive`Hello``World`;
// [ 'Hello' ] []
// [ 'World' ] []

構文上は技術的に許可されていますが、タグ付けされていないテンプレートリテラルは文字列であり、連結すると TypeError が発生します。
jsconsole.log(`Hello``World`); // TypeError: "Hello" is not a function

唯一の例外はオプショナルチェーンで、これは構文エラーが発生します。
jsconsole.log?.`Hello`; // SyntaxError: Invalid tagged template on optional chain
console?.log`Hello`; // SyntaxError: Invalid tagged template on optional chain

なお、次の 2 つの式は依然として解釈可能です。つまり、自動セミコロン挿入の対象にはなりません。自動セミコロン挿入は、解釈不可能なコードを修正するためにのみセミコロンを挿入します。
js// Still a syntax error
const a = console?.log
`Hello`

タグ関数は文字列を返さなくても構いません。
jsfunction template(strings, ...keys) {
  return (...values) => {
    const dict = values[values.length - 1] || {};
    const result = [strings[0]];
    keys.forEach((key, i) => {
      const value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

const t1Closure = template`${0}${1}${0}!`;
// const t1Closure = template(["","","","!"],0,1,0);
t1Closure("Y", "A"); // "YAY!"

const t2Closure = template`${0} ${"foo"}!`;
// const t2Closure = template([""," ","!"],0,"foo");
t2Closure("Hello", { foo: "World" }); // "Hello World!"

const t3Closure = template`I'm ${"name"}. I'm almost ${"age"} years old.`;
// const t3Closure = template(["I'm ", ". I'm almost ", " years old."], "name", "age");
t3Closure("foo", { name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."
t3Closure({ name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."

タグ関数の先頭の引数は、文字列の配列です。どのテンプレートリテラルでも、その長さは置換の数（${…} の発生回数）に 1 を加えたものと同じであり、したがって常に空ではありません。
タグ付きのテンプレートリテラル式については、そのリテラルが何度評価されても、タグ関数は常にまったく同じリテラル配列を引数として呼び出されます。
jsconst callHistory = [];

function tag(strings, ...values) {
  callHistory.push(strings);
  // Return a freshly made object
  return {};
}

function evaluateLiteral() {
  return tag`Hello, ${"world"}!`;
}

console.log(evaluateLiteral() === evaluateLiteral()); // false。 `tag` が呼び出されるたびに新しいオブジェクトを返す
console.log(callHistory[0] === callHistory[1]); // true。 同じタグ付きリテラルのすべての評価は、同じ文字列配列に格納されます。

これにより、タグは第 1 引数の識別子に基づいて結果をキャッシュすることができます。配列値の安定性をさらに保証するために、第 1 引数と raw プロパティはどちらも凍結され、変更することはできません。加工前の文字列タグ関数に渡される第 1 引数では、特別な raw プロパティが利用できます。このプロパティを通して、エスケープシーケンスを処理する前の、入力された通りの加工前の文字列を参照することができます。
jsfunction tag(strings) {
  console.log(strings.raw[0]);
}

tag`string text line 1 \n string text line 2`;
// Logs "string text line 1 \n string text line 2",
// including the two characters '\' and 'n'

加えて、 String.raw() メソッドがあり、既定のテンプレート関数のように文字列を連結した形で加工前の文字列を生成することができます。
jsconst str = String.raw`Hi\n${2 + 3}!`;
// "Hi\\n5!"

str.length;
// 6

Array.from(str).join(",");
// "H,i,\\,n,5,!"

リテラルにエスケープシーケンスが含まれていない場合、String.raw 関数は "identity" タグのように機能します。 リテラルにタグを付けない場合と同様に常にうまくいく実際の identity タグが必要な場合は、エスケープシーケンスが処理された「加工された」リテラル配列を String.raw に渡し、生の文字列であるかのように見せかけるカスタム関数を作成することができます。
jsconst identity = (strings, ...values) =>
  String.raw({ raw: strings }, ...values);
console.log(identity`Hi\n${2 + 3}!`);
// Hi
// 5!

これは、特定の名前付きリテラルに特別な処理を行う多くのツールにとって有益なものです。
jsconst html = (strings, ...values) => String.raw({ raw: strings }, ...values);
// 一部のフォーマッターは、このリテラルのコンテンツを HTML として書式化します。
const doc = html`<!doctype html>
  <html lang="en-US">
    <head>
      <title>Hello</title>
    </head>
    <body>
      <h1>Hello world!</h1>
    </body>
  </html>`;
タグ付きテンプレートとエスケープシーケンス通常のテンプレートリテラルでは、文字列リテラル内のエスケープシーケンスはすべて許可されています。それ以外にも、適切に形成されていないエスケープシーケンスはすべて構文エラーとなります。 これには以下が含まれます。

\ に 0 以外の任意の数字が、または \0 に数字が続いたもの。例えば \9 や \07（これは 非推奨の構文です）
\x に 2 桁以下（ないものも含む）の 16 進数が続いたもの。例えば \xz
\u に { が続かず、 4 桁以下（ないものも含む）の 16 進数が通づいたもの。例えば \uz
\u{} で有効な Unicode コードポイントを囲んだもの。ここには 16 進数以外のもの、まてゃあ 10FFFF 以上の値。例えば \u{110000} や \u{z}


メモ: \ に他の文字が続くと、何もエスケープされていないので、無意味かもしれませんが、構文エラーではありません。

しかし、これはタグ付きテンプレートにとっては問題です。「加工済み」リテラルに加えて、生のリテラルにもアクセスできるからです（エスケープシーケンスはそのまま保持されます）。
タグ付きテンプレートでは、任意の文字列コンテンツを埋め込むことができ、エスケープシーケンスは異なる構文に従うことがあります。例えば、String.raw を使用して JavaScript で LaTeX のソーステキストを埋め込む場合を考えてみましょう。JavaScript の構文制限に従うことなく、u または x で始まる LaTeX マクロを使用できるようにしたい場合もあります。そのため、タグ付きテンプレートでは、正しく形成されたエスケープシーケンスの構文制限が解除されます。下記は、MathJax を使用して LaTeX を 1 つの要素でレンダリングする例です。
jsconst node = document.getElementById("formula");
MathJax.typesetClear([node]);
// 古い ECMAScript バージョン (ES2016 以前) では、以下のような例外が投げられる
// SyntaxError: malformed Unicode character escape sequence
node.textContent = String.raw`$\underline{u}$`;
MathJax.typesetPromise([node]);

しかし、埋め込んで「加工された」結果の中においても、不正なエスケープシーケンスがあれば、それを提示する必要があります。こうした不正なエスケープシーケンスは、「加工された」の配列の中では、undefined の要素として表示されます。
jsfunction log(str) {
  console.log("Cooked:", str[0]);
  console.log("Raw:", str.raw[0]);
}

log`\unicode`;
// Cooked: undefined
// Raw: \unicode

このエスケープシーケンスの制約は、タグ付きテンプレートのみが除外となります。タグ付きでないテンプレートリテラルの場合は、除外対象ではありません。
jsconst bad = `bad escape sequence: \unicode`;
仕様書SpecificationECMAScript® 2026 Language Specification # sec-template-literalsブラウザーの互換性関連情報
テキスト整形ガイド
String
String.raw()
字句文法
ES6 in Depth: Template strings (hacks.mozilla.org, 2015)\n\nテンプレートリテラル (テンプレート文字列)Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackテンプレートリテラルは逆引用符 (`) で区切られたリテラルで、複数行の文字列、埋め込み式による文字列の補間、タグ付きテンプレートと呼ばれる特殊な構文を許可します。
テンプレートリテラルは非公式に「テンプレート文字列」と呼ばれることもあります。文字列の補間のためにもっともよく使用されるからです。しかし、タグ付けされたテンプレートリテラルが文字列になるとは限りません。カスタムのタグ関数と併用することで、テンプレートリテラルのさまざまな部分に対して、任意の操作を実行することができます。構文js`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tagFunction`string text ${expression} string text`
引数
string text

テンプレートリテラルに含まれる文字列テキストです。ほとんどの文字はそのまま使用できますが、改行やその他のホワイトスペース文字も含まれます。ただし、タグ関数を使用しない限り、無効なエスケープシーケンスは構文エラーの原因となります。

expression

現在の位置に挿入される式で、その値は文字列に変換されるか、 tagFunction に渡されます。

tagFunction

指定された場合、テンプレート文字列の配列と置換式とともに呼び出され、返値がテンプレートリテラルの値となります。タグ付きテンプレートを参照してください。

解説テンプレートリテラルは、二重引用符や単一引用符の代わりに逆引用符文字 (`) で囲みます。
テンプレートリテラルは、通常の文字列を持つことができるだけでなく、プレースホルダーと呼ばれる、ドル記号と波括弧で囲まれた ${expression} という形の埋め込まれた式の部品を含むことができます。文字列とプレースホルダーは、既定の関数またはユーザーが指定した関数に渡されます。既定の関数（ユーザーが関数を指定しない場合）は、プレースホルダーの置換を行う文字列の補間を実行し、その部分を単一の文字列に結合します。
独自の関数を使用するには、テンプレートリテラルの前に関数名を指定します。その結果は、タグ付きテンプレートと呼ばれます。この場合、テンプレートリテラルはタグ関数に渡され、そこでテンプレートリテラルの異なる部分に対して任意の操作を実行することができます。
テンプレートリテラル内で逆引用符文字をエスケープするには、逆引用符文字の前にバックスラッシュ (\) を置きます。
js`\`` === "`"; // true

ドル記号も同様にエスケープすることで、補間を防ぐことができます。
js`\${1}` === "${1}"; // true
複数行の文字列ソースの中に挿入された改行文字は、すべてテンプレートリテラルの一部になります。
通常の文字列を使う場合は、複数行の文字列を得るために次のような構文を使用する必要があります。
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
// string text line 2"

テンプレートリテラルを使用すれば、同じものを次のように書くことができます。
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"

通常の文字列リテラルと同様に、ソースコードの可読性を高めるために、改行をバックスラッシュ (\) でエスケープすることで、単一行の文字列を複数行にわたって記述することができます。
jsconsole.log(`string text line 1 \
string text line 2`);
// "string text line 1 string text line 2"
文字列の補間テンプレートリテラルなしで、式からの出力と文字列を結合したい場合、結合は加算演算子 + を使用して行うことになります。
jsconst a = 5;
const b = 10;
console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");
// "Fifteen is 15 and
// not 20."

特に複数の式がある場合は、読みづらい場合があります。
テンプレートリテラルを使用すると、埋め込み式の置換を行う際に、${expression} 形式のプレースホルダーを使用することで、連結演算子を使わずに、コードの可読性を向上させることができます。
jsconst a = 5;
const b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
// "Fifteen is 15 and
// not 20."

2 つの構文には軽微な違いがあることに注意してください。 テンプレートリテラルは、その式を直接文字列に変換しますが、加算ではまずオペランドをプリミティブに変換します。 詳細は、 + 演算子のリファレンスページをご覧ください。入れ子のテンプレート場合によっては、テンプレートを入れ子にすると、構成可能な文字列を得るのにもっとも簡単に（かつ、おそらくより読みやすく）なることがあります。逆引用符で区切られたテンプレートでは、テンプレート内にあるプレイスホルダー ${expression} の内部で逆引用符を使用することができます。
例えば、テンプレートリテラルがなければ、特定の条件に基づいて特定の値を返したい場合、次のような方法をとることができます。
jslet classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

入れ子なしのテンプレートリテラルを使用すれば、次のようにすることができます。
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

テンプレートリテラルを入れ子で使用すると、次のようにすることができます。
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
タグ付きテンプレートタグ付きテンプレートは、テンプレートリテラルのより高度な形式です。
タグを使用すると、テンプレートリテラルを関数で解析できます。タグ関数の最初の引数には、文字列リテラルの配列を含みます。残りの引数は式に関連付けられます。
タグ関数は、これらの引数に対して何でも望み通りの操作を実行することができ、加工された文字列を返します。（または、以下の例の一つで示しているように、まったく異なるものを返すこともできます。）
タグに使用される関数の名前は、自由に指定できます。
jsconst person = "Mike";
const age = 28;

function myTag(strings, personExp, ageExp) {
  const str0 = strings[0]; // "That "
  const str1 = strings[1]; // " is a "
  const str2 = strings[2]; // "."

  const ageStr = ageExp < 100 ? "youngster" : "centenarian";

  // テンプレートリテラルを用いて組み立てた文字列を返すこともできます
  return `${str0}${personExp}${str1}${ageStr}${str2}`;
}

const output = myTag`That ${person} is a ${age}.`;

console.log(output);
// That Mike is a youngster.

タグは単なる識別子である必要はありません。 16 より大きな優先順位を持つ任意の式を使用でき、これにはプロパティアクセス、関数呼び出し、new 式、さらには別のタグ付きテンプレートリテラルも含まれます。
jsconsole.log`Hello`; // [ 'Hello' ]
console.log.bind(1, 2)`Hello`; // 2 [ 'Hello' ]
new Function("console.log(arguments)")`Hello`; // [Arguments] { '0': [ 'Hello' ] }

function recursive(strings, ...values) {
  console.log(strings, values);
  return recursive;
}
recursive`Hello``World`;
// [ 'Hello' ] []
// [ 'World' ] []

構文上は技術的に許可されていますが、タグ付けされていないテンプレートリテラルは文字列であり、連結すると TypeError が発生します。
jsconsole.log(`Hello``World`); // TypeError: "Hello" is not a function

唯一の例外はオプショナルチェーンで、これは構文エラーが発生します。
jsconsole.log?.`Hello`; // SyntaxError: Invalid tagged template on optional chain
console?.log`Hello`; // SyntaxError: Invalid tagged template on optional chain

なお、次の 2 つの式は依然として解釈可能です。つまり、自動セミコロン挿入の対象にはなりません。自動セミコロン挿入は、解釈不可能なコードを修正するためにのみセミコロンを挿入します。
js// Still a syntax error
const a = console?.log
`Hello`

タグ関数は文字列を返さなくても構いません。
jsfunction template(strings, ...keys) {
  return (...values) => {
    const dict = values[values.length - 1] || {};
    const result = [strings[0]];
    keys.forEach((key, i) => {
      const value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

const t1Closure = template`${0}${1}${0}!`;
// const t1Closure = template(["","","","!"],0,1,0);
t1Closure("Y", "A"); // "YAY!"

const t2Closure = template`${0} ${"foo"}!`;
// const t2Closure = template([""," ","!"],0,"foo");
t2Closure("Hello", { foo: "World" }); // "Hello World!"

const t3Closure = template`I'm ${"name"}. I'm almost ${"age"} years old.`;
// const t3Closure = template(["I'm ", ". I'm almost ", " years old."], "name", "age");
t3Closure("foo", { name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."
t3Closure({ name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."

タグ関数の先頭の引数は、文字列の配列です。どのテンプレートリテラルでも、その長さは置換の数（${…} の発生回数）に 1 を加えたものと同じであり、したがって常に空ではありません。
タグ付きのテンプレートリテラル式については、そのリテラルが何度評価されても、タグ関数は常にまったく同じリテラル配列を引数として呼び出されます。
jsconst callHistory = [];

function tag(strings, ...values) {
  callHistory.push(strings);
  // Return a freshly made object
  return {};
}

function evaluateLiteral() {
  return tag`Hello, ${"world"}!`;
}

console.log(evaluateLiteral() === evaluateLiteral()); // false。 `tag` が呼び出されるたびに新しいオブジェクトを返す
console.log(callHistory[0] === callHistory[1]); // true。 同じタグ付きリテラルのすべての評価は、同じ文字列配列に格納されます。

これにより、タグは第 1 引数の識別子に基づいて結果をキャッシュすることができます。配列値の安定性をさらに保証するために、第 1 引数と raw プロパティはどちらも凍結され、変更することはできません。加工前の文字列タグ関数に渡される第 1 引数では、特別な raw プロパティが利用できます。このプロパティを通して、エスケープシーケンスを処理する前の、入力された通りの加工前の文字列を参照することができます。
jsfunction tag(strings) {
  console.log(strings.raw[0]);
}

tag`string text line 1 \n string text line 2`;
// Logs "string text line 1 \n string text line 2",
// including the two characters '\' and 'n'

加えて、 String.raw() メソッドがあり、既定のテンプレート関数のように文字列を連結した形で加工前の文字列を生成することができます。
jsconst str = String.raw`Hi\n${2 + 3}!`;
// "Hi\\n5!"

str.length;
// 6

Array.from(str).join(",");
// "H,i,\\,n,5,!"

リテラルにエスケープシーケンスが含まれていない場合、String.raw 関数は "identity" タグのように機能します。 リテラルにタグを付けない場合と同様に常にうまくいく実際の identity タグが必要な場合は、エスケープシーケンスが処理された「加工された」リテラル配列を String.raw に渡し、生の文字列であるかのように見せかけるカスタム関数を作成することができます。
jsconst identity = (strings, ...values) =>
  String.raw({ raw: strings }, ...values);
console.log(identity`Hi\n${2 + 3}!`);
// Hi
// 5!

これは、特定の名前付きリテラルに特別な処理を行う多くのツールにとって有益なものです。
jsconst html = (strings, ...values) => String.raw({ raw: strings }, ...values);
// 一部のフォーマッターは、このリテラルのコンテンツを HTML として書式化します。
const doc = html`<!doctype html>
  <html lang="en-US">
    <head>
      <title>Hello</title>
    </head>
    <body>
      <h1>Hello world!</h1>
    </body>
  </html>`;
タグ付きテンプレートとエスケープシーケンス通常のテンプレートリテラルでは、文字列リテラル内のエスケープシーケンスはすべて許可されています。それ以外にも、適切に形成されていないエスケープシーケンスはすべて構文エラーとなります。 これには以下が含まれます。

\ に 0 以外の任意の数字が、または \0 に数字が続いたもの。例えば \9 や \07（これは 非推奨の構文です）
\x に 2 桁以下（ないものも含む）の 16 進数が続いたもの。例えば \xz
\u に { が続かず、 4 桁以下（ないものも含む）の 16 進数が通づいたもの。例えば \uz
\u{} で有効な Unicode コードポイントを囲んだもの。ここには 16 進数以外のもの、まてゃあ 10FFFF 以上の値。例えば \u{110000} や \u{z}


メモ: \ に他の文字が続くと、何もエスケープされていないので、無意味かもしれませんが、構文エラーではありません。

しかし、これはタグ付きテンプレートにとっては問題です。「加工済み」リテラルに加えて、生のリテラルにもアクセスできるからです（エスケープシーケンスはそのまま保持されます）。
タグ付きテンプレートでは、任意の文字列コンテンツを埋め込むことができ、エスケープシーケンスは異なる構文に従うことがあります。例えば、String.raw を使用して JavaScript で LaTeX のソーステキストを埋め込む場合を考えてみましょう。JavaScript の構文制限に従うことなく、u または x で始まる LaTeX マクロを使用できるようにしたい場合もあります。そのため、タグ付きテンプレートでは、正しく形成されたエスケープシーケンスの構文制限が解除されます。下記は、MathJax を使用して LaTeX を 1 つの要素でレンダリングする例です。
jsconst node = document.getElementById("formula");
MathJax.typesetClear([node]);
// 古い ECMAScript バージョン (ES2016 以前) では、以下のような例外が投げられる
// SyntaxError: malformed Unicode character escape sequence
node.textContent = String.raw`$\underline{u}$`;
MathJax.typesetPromise([node]);

しかし、埋め込んで「加工された」結果の中においても、不正なエスケープシーケンスがあれば、それを提示する必要があります。こうした不正なエスケープシーケンスは、「加工された」の配列の中では、undefined の要素として表示されます。
jsfunction log(str) {
  console.log("Cooked:", str[0]);
  console.log("Raw:", str.raw[0]);
}

log`\unicode`;
// Cooked: undefined
// Raw: \unicode

このエスケープシーケンスの制約は、タグ付きテンプレートのみが除外となります。タグ付きでないテンプレートリテラルの場合は、除外対象ではありません。
jsconst bad = `bad escape sequence: \unicode`;
仕様書SpecificationECMAScript® 2026 Language Specification # sec-template-literalsブラウザーの互換性関連情報
テキスト整形ガイド
String
String.raw()
字句文法
ES6 in Depth: Template strings (hacks.mozilla.org, 2015)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025年3月21日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nテンプレートリテラル (テンプレート文字列)Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackテンプレートリテラルは逆引用符 (`) で区切られたリテラルで、複数行の文字列、埋め込み式による文字列の補間、タグ付きテンプレートと呼ばれる特殊な構文を許可します。
テンプレートリテラルは非公式に「テンプレート文字列」と呼ばれることもあります。文字列の補間のためにもっともよく使用されるからです。しかし、タグ付けされたテンプレートリテラルが文字列になるとは限りません。カスタムのタグ関数と併用することで、テンプレートリテラルのさまざまな部分に対して、任意の操作を実行することができます。構文js`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tagFunction`string text ${expression} string text`
引数
string text

テンプレートリテラルに含まれる文字列テキストです。ほとんどの文字はそのまま使用できますが、改行やその他のホワイトスペース文字も含まれます。ただし、タグ関数を使用しない限り、無効なエスケープシーケンスは構文エラーの原因となります。

expression

現在の位置に挿入される式で、その値は文字列に変換されるか、 tagFunction に渡されます。

tagFunction

指定された場合、テンプレート文字列の配列と置換式とともに呼び出され、返値がテンプレートリテラルの値となります。タグ付きテンプレートを参照してください。

解説テンプレートリテラルは、二重引用符や単一引用符の代わりに逆引用符文字 (`) で囲みます。
テンプレートリテラルは、通常の文字列を持つことができるだけでなく、プレースホルダーと呼ばれる、ドル記号と波括弧で囲まれた ${expression} という形の埋め込まれた式の部品を含むことができます。文字列とプレースホルダーは、既定の関数またはユーザーが指定した関数に渡されます。既定の関数（ユーザーが関数を指定しない場合）は、プレースホルダーの置換を行う文字列の補間を実行し、その部分を単一の文字列に結合します。
独自の関数を使用するには、テンプレートリテラルの前に関数名を指定します。その結果は、タグ付きテンプレートと呼ばれます。この場合、テンプレートリテラルはタグ関数に渡され、そこでテンプレートリテラルの異なる部分に対して任意の操作を実行することができます。
テンプレートリテラル内で逆引用符文字をエスケープするには、逆引用符文字の前にバックスラッシュ (\) を置きます。
js`\`` === "`"; // true

ドル記号も同様にエスケープすることで、補間を防ぐことができます。
js`\${1}` === "${1}"; // true
複数行の文字列ソースの中に挿入された改行文字は、すべてテンプレートリテラルの一部になります。
通常の文字列を使う場合は、複数行の文字列を得るために次のような構文を使用する必要があります。
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
// string text line 2"

テンプレートリテラルを使用すれば、同じものを次のように書くことができます。
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"

通常の文字列リテラルと同様に、ソースコードの可読性を高めるために、改行をバックスラッシュ (\) でエスケープすることで、単一行の文字列を複数行にわたって記述することができます。
jsconsole.log(`string text line 1 \
string text line 2`);
// "string text line 1 string text line 2"
文字列の補間テンプレートリテラルなしで、式からの出力と文字列を結合したい場合、結合は加算演算子 + を使用して行うことになります。
jsconst a = 5;
const b = 10;
console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");
// "Fifteen is 15 and
// not 20."

特に複数の式がある場合は、読みづらい場合があります。
テンプレートリテラルを使用すると、埋め込み式の置換を行う際に、${expression} 形式のプレースホルダーを使用することで、連結演算子を使わずに、コードの可読性を向上させることができます。
jsconst a = 5;
const b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
// "Fifteen is 15 and
// not 20."

2 つの構文には軽微な違いがあることに注意してください。 テンプレートリテラルは、その式を直接文字列に変換しますが、加算ではまずオペランドをプリミティブに変換します。 詳細は、 + 演算子のリファレンスページをご覧ください。入れ子のテンプレート場合によっては、テンプレートを入れ子にすると、構成可能な文字列を得るのにもっとも簡単に（かつ、おそらくより読みやすく）なることがあります。逆引用符で区切られたテンプレートでは、テンプレート内にあるプレイスホルダー ${expression} の内部で逆引用符を使用することができます。
例えば、テンプレートリテラルがなければ、特定の条件に基づいて特定の値を返したい場合、次のような方法をとることができます。
jslet classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

入れ子なしのテンプレートリテラルを使用すれば、次のようにすることができます。
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

テンプレートリテラルを入れ子で使用すると、次のようにすることができます。
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
タグ付きテンプレートタグ付きテンプレートは、テンプレートリテラルのより高度な形式です。
タグを使用すると、テンプレートリテラルを関数で解析できます。タグ関数の最初の引数には、文字列リテラルの配列を含みます。残りの引数は式に関連付けられます。
タグ関数は、これらの引数に対して何でも望み通りの操作を実行することができ、加工された文字列を返します。（または、以下の例の一つで示しているように、まったく異なるものを返すこともできます。）
タグに使用される関数の名前は、自由に指定できます。
jsconst person = "Mike";
const age = 28;

function myTag(strings, personExp, ageExp) {
  const str0 = strings[0]; // "That "
  const str1 = strings[1]; // " is a "
  const str2 = strings[2]; // "."

  const ageStr = ageExp < 100 ? "youngster" : "centenarian";

  // テンプレートリテラルを用いて組み立てた文字列を返すこともできます
  return `${str0}${personExp}${str1}${ageStr}${str2}`;
}

const output = myTag`That ${person} is a ${age}.`;

console.log(output);
// That Mike is a youngster.

タグは単なる識別子である必要はありません。 16 より大きな優先順位を持つ任意の式を使用でき、これにはプロパティアクセス、関数呼び出し、new 式、さらには別のタグ付きテンプレートリテラルも含まれます。
jsconsole.log`Hello`; // [ 'Hello' ]
console.log.bind(1, 2)`Hello`; // 2 [ 'Hello' ]
new Function("console.log(arguments)")`Hello`; // [Arguments] { '0': [ 'Hello' ] }

function recursive(strings, ...values) {
  console.log(strings, values);
  return recursive;
}
recursive`Hello``World`;
// [ 'Hello' ] []
// [ 'World' ] []

構文上は技術的に許可されていますが、タグ付けされていないテンプレートリテラルは文字列であり、連結すると TypeError が発生します。
jsconsole.log(`Hello``World`); // TypeError: "Hello" is not a function

唯一の例外はオプショナルチェーンで、これは構文エラーが発生します。
jsconsole.log?.`Hello`; // SyntaxError: Invalid tagged template on optional chain
console?.log`Hello`; // SyntaxError: Invalid tagged template on optional chain

なお、次の 2 つの式は依然として解釈可能です。つまり、自動セミコロン挿入の対象にはなりません。自動セミコロン挿入は、解釈不可能なコードを修正するためにのみセミコロンを挿入します。
js// Still a syntax error
const a = console?.log
`Hello`

タグ関数は文字列を返さなくても構いません。
jsfunction template(strings, ...keys) {
  return (...values) => {
    const dict = values[values.length - 1] || {};
    const result = [strings[0]];
    keys.forEach((key, i) => {
      const value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

const t1Closure = template`${0}${1}${0}!`;
// const t1Closure = template(["","","","!"],0,1,0);
t1Closure("Y", "A"); // "YAY!"

const t2Closure = template`${0} ${"foo"}!`;
// const t2Closure = template([""," ","!"],0,"foo");
t2Closure("Hello", { foo: "World" }); // "Hello World!"

const t3Closure = template`I'm ${"name"}. I'm almost ${"age"} years old.`;
// const t3Closure = template(["I'm ", ". I'm almost ", " years old."], "name", "age");
t3Closure("foo", { name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."
t3Closure({ name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."

タグ関数の先頭の引数は、文字列の配列です。どのテンプレートリテラルでも、その長さは置換の数（${…} の発生回数）に 1 を加えたものと同じであり、したがって常に空ではありません。
タグ付きのテンプレートリテラル式については、そのリテラルが何度評価されても、タグ関数は常にまったく同じリテラル配列を引数として呼び出されます。
jsconst callHistory = [];

function tag(strings, ...values) {
  callHistory.push(strings);
  // Return a freshly made object
  return {};
}

function evaluateLiteral() {
  return tag`Hello, ${"world"}!`;
}

console.log(evaluateLiteral() === evaluateLiteral()); // false。 `tag` が呼び出されるたびに新しいオブジェクトを返す
console.log(callHistory[0] === callHistory[1]); // true。 同じタグ付きリテラルのすべての評価は、同じ文字列配列に格納されます。

これにより、タグは第 1 引数の識別子に基づいて結果をキャッシュすることができます。配列値の安定性をさらに保証するために、第 1 引数と raw プロパティはどちらも凍結され、変更することはできません。加工前の文字列タグ関数に渡される第 1 引数では、特別な raw プロパティが利用できます。このプロパティを通して、エスケープシーケンスを処理する前の、入力された通りの加工前の文字列を参照することができます。
jsfunction tag(strings) {
  console.log(strings.raw[0]);
}

tag`string text line 1 \n string text line 2`;
// Logs "string text line 1 \n string text line 2",
// including the two characters '\' and 'n'

加えて、 String.raw() メソッドがあり、既定のテンプレート関数のように文字列を連結した形で加工前の文字列を生成することができます。
jsconst str = String.raw`Hi\n${2 + 3}!`;
// "Hi\\n5!"

str.length;
// 6

Array.from(str).join(",");
// "H,i,\\,n,5,!"

リテラルにエスケープシーケンスが含まれていない場合、String.raw 関数は "identity" タグのように機能します。 リテラルにタグを付けない場合と同様に常にうまくいく実際の identity タグが必要な場合は、エスケープシーケンスが処理された「加工された」リテラル配列を String.raw に渡し、生の文字列であるかのように見せかけるカスタム関数を作成することができます。
jsconst identity = (strings, ...values) =>
  String.raw({ raw: strings }, ...values);
console.log(identity`Hi\n${2 + 3}!`);
// Hi
// 5!

これは、特定の名前付きリテラルに特別な処理を行う多くのツールにとって有益なものです。
jsconst html = (strings, ...values) => String.raw({ raw: strings }, ...values);
// 一部のフォーマッターは、このリテラルのコンテンツを HTML として書式化します。
const doc = html`<!doctype html>
  <html lang="en-US">
    <head>
      <title>Hello</title>
    </head>
    <body>
      <h1>Hello world!</h1>
    </body>
  </html>`;
タグ付きテンプレートとエスケープシーケンス通常のテンプレートリテラルでは、文字列リテラル内のエスケープシーケンスはすべて許可されています。それ以外にも、適切に形成されていないエスケープシーケンスはすべて構文エラーとなります。 これには以下が含まれます。

\ に 0 以外の任意の数字が、または \0 に数字が続いたもの。例えば \9 や \07（これは 非推奨の構文です）
\x に 2 桁以下（ないものも含む）の 16 進数が続いたもの。例えば \xz
\u に { が続かず、 4 桁以下（ないものも含む）の 16 進数が通づいたもの。例えば \uz
\u{} で有効な Unicode コードポイントを囲んだもの。ここには 16 進数以外のもの、まてゃあ 10FFFF 以上の値。例えば \u{110000} や \u{z}


メモ: \ に他の文字が続くと、何もエスケープされていないので、無意味かもしれませんが、構文エラーではありません。

しかし、これはタグ付きテンプレートにとっては問題です。「加工済み」リテラルに加えて、生のリテラルにもアクセスできるからです（エスケープシーケンスはそのまま保持されます）。
タグ付きテンプレートでは、任意の文字列コンテンツを埋め込むことができ、エスケープシーケンスは異なる構文に従うことがあります。例えば、String.raw を使用して JavaScript で LaTeX のソーステキストを埋め込む場合を考えてみましょう。JavaScript の構文制限に従うことなく、u または x で始まる LaTeX マクロを使用できるようにしたい場合もあります。そのため、タグ付きテンプレートでは、正しく形成されたエスケープシーケンスの構文制限が解除されます。下記は、MathJax を使用して LaTeX を 1 つの要素でレンダリングする例です。
jsconst node = document.getElementById("formula");
MathJax.typesetClear([node]);
// 古い ECMAScript バージョン (ES2016 以前) では、以下のような例外が投げられる
// SyntaxError: malformed Unicode character escape sequence
node.textContent = String.raw`$\underline{u}$`;
MathJax.typesetPromise([node]);

しかし、埋め込んで「加工された」結果の中においても、不正なエスケープシーケンスがあれば、それを提示する必要があります。こうした不正なエスケープシーケンスは、「加工された」の配列の中では、undefined の要素として表示されます。
jsfunction log(str) {
  console.log("Cooked:", str[0]);
  console.log("Raw:", str.raw[0]);
}

log`\unicode`;
// Cooked: undefined
// Raw: \unicode

このエスケープシーケンスの制約は、タグ付きテンプレートのみが除外となります。タグ付きでないテンプレートリテラルの場合は、除外対象ではありません。
jsconst bad = `bad escape sequence: \unicode`;
仕様書SpecificationECMAScript® 2026 Language Specification # sec-template-literalsブラウザーの互換性関連情報
テキスト整形ガイド
String
String.raw()
字句文法
ES6 in Depth: Template strings (hacks.mozilla.org, 2015)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025年3月21日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nTemplate literalsBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedback템플릿 리터럴은 내장된 표현식을 허용하는 문자열 리터럴입니다. 여러 줄로 이뤄진 문자열과 문자 보간기능을 사용할 수 있습니다. 이전 버전의 ES2015사양 명세에서는 "template strings" (템플릿 문자열) 라고 불려 왔습니다.Syntax    `string text`

    `string text line 1
     string text line 2`

    `string text ${expression} string text`

    tag `string text ${expression} string text`
Description템플릿 리터럴은 이중 따옴표 나 작은 따옴표 대신 백틱(` `) (grave accent) 을 이용합니다. 템플릿 리터럴은 또한 플레이스 홀더를 이용하여 표현식을 넣을 수 있는데, 이는 $와 중괄호( $ {expression} ) 로 표기할 수 있습니다. 플레이스 홀더 안에서의 표현식과 그 사이의 텍스트는 함께 함수로 전달됩니다. 기본 함수는 단순히 해당 부분을 단일 문자열로 연결시켜 줍니다. 템플릿 리터럴 앞에 어떠한 표현식이 있다면(여기에서는 태그), 템플릿 리터럴은 "태그가 지정된 템플릿"이라고 불리게 됩니다. 이 때, 태그 표현식 (주로 함수)이 처리된 템플릿 리터럴과 함께 호출되면, 출력하기 전에 조작할 수 있습니다. 템플릿 리터럴 안에서 백틱 문자를 사용하려면 백틱 앞에 백슬러쉬(\)를 넣으십시오.
js`\`` === "`"; // --> true
Multi-line stringssource 내에 삽입되는 newline characters(\n)은 template literal의 일부가 됩니다.
일반 string 들을 사용하여, multi-line strings 들을 얻기 위해서는 아래와 같은 문법을 사용해야 할 것입니다.
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
// string text line 2"

같은 효과를 template literal을 통해 얻기 위해서는, 아래와 같이 적을 수 있습니다.
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"
Expression interpolation(표현식 삽입법)표현식(expression)을 일반 문자열(normal strings)에 삽입하기 위해서, 당신은 다음의 문법을 사용할 수 있을 것입니다.
jsvar a = 5;
var b = 10;
console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");
// "Fifteen is 15 and
// not 20."

template literals을 이용하면, 이를 더욱 읽기 쉽도록 다음과 같은 문법 설탕(syntactic sugar) 을 활용할 수 있습니다.
jsvar a = 5;
var b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
// "Fifteen is 15 and
// not 20."
Nesting templates특정한 경우 템플릿을 중첩하는 것이 구성 가능한 문자열을 읽는 읽기 가장 쉬운 방법입니다. 백 스페이스 템플릿 내에서 템플릿 내의 자리 표시자${}에 내부 백틱을 사용하는 것이 쉽습니다. 예를 들어, 조건 a가 참이면:이 템플릿을 문자 그대로 반환합니다.
In ES5:
jsvar classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

ES2015에서 중첩(nesting)없이 템플릿 리터럴 사용한 경우:
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

ES2015에서 중첩된(nested) 템플릿 리터럴을 사용한 경우:
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
Tagged templatestemplate literals 의 더욱 발전된 한 형태는 tagged templates 입니다. 태그를 사용하면 템플릿 리터럴을 함수로 파싱 할 수 있습니다. 태그 함수의 첫 번째 인수는 문자열 값의 배열을 포함합니다. 나머지 인수는 표현식과 관련됩니다. 결국 함수는 조작 된 문자열을 반환 할 수 있습니다 (또는 다음 예제에서 설명하는 것과 완전히 다른 결과를 반환 할 수 있습니다). function 이름은 원하는 어떤 것이든 가능합니다.
jsvar person = "Mike";
var age = 28;

function myTag(strings, personExp, ageExp) {
  var str0 = strings[0]; // "that "
  var str1 = strings[1]; // " is a "

  // 사실 이 예제의 string에서 표현식이 두 개 삽입되었으므로
  // ${age} 뒤에는 ''인 string이 존재하여
  // 기술적으로 strings 배열의 크기는 3이 됩니다.
  // 하지만 빈 string이므로 무시하겠습니다.
  // var str2 = strings[2];

  var ageStr;
  if (ageExp > 99) {
    ageStr = "centenarian";
  } else {
    ageStr = "youngster";
  }

  // 심지어 이 함수내에서도 template literal을 반환할 수 있습니다.
  return str0 + personExp + str1 + ageStr;
}

var output = myTag`that ${person} is a ${age}`;

console.log(output);
// that Mike is a youngster

다음 예시에서 보여지듯이, Tag function 들은 string 을 반환할 필요는 없습니다.
jsfunction template(strings, ...keys) {
  return function (...values) {
    var dict = values[values.length - 1] || {};
    var result = [strings[0]];
    keys.forEach(function (key, i) {
      var value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

var t1Closure = template`${0}${1}${0}!`;
t1Closure("Y", "A"); // "YAY!"
var t2Closure = template`${0} ${"foo"}!`;
t2Closure("Hello", { foo: "World" }); // "Hello World!"
Raw strings태그 지정된 템플릿의 첫 번째 함수 인수에서 사용할 수있는 특별한 raw property을 사용하면 escape sequences 처리하지 않고 원시 문자열을 입력 한대로 액세스 할 수 있습니다.
jsfunction tag(strings) {
  console.log(strings.raw[0]);
}

tag`string text line 1 \n string text line 2`;
// logs "string text line 1 \n string text line 2" ,
// including the two characters '\' and 'n'

추가로, default template function 과 string 병합으로 생성될 것 같은 raw string 을 생성하기 위한 String.raw() method가 존재합니다.
jsvar str = String.raw`Hi\n${2 + 3}!`;
// "Hi\n5!"

str.length;
// 6

str.split("").join(",");
// "H,i,\,n,5,!"
Tagged templates and escape sequencesES2016 behavior
ECMAScript 2016에서 tagged templates은 다음 escape sequences의 규칙을 따릅니다.

Unicode escapes started by "\u", for example \u00A9
Unicode code point escapes indicated by "\u{}", for example \u{2F804}
Hexadecimal escapes started by "\x", for example \xA9
Octal literal escapes started by "\" and (a) digit(s), for example \251

이는 다음과 같은 tagged template이 문제가 된다는 것을 의미하는데, ECMAScript문법에 따라, parser는 유효한 유니 코드 탈출 시퀀스가 있는지 확인하지만 형식이 잘못되었기 때문에 오류가 발생합니다.
    latex`\unicode`
    // Throws in older ECMAScript versions (ES2016 and earlier)
    // SyntaxError: malformed Unicode character escape sequence

ES2018 revision of illegal escape sequences
Tagged templates은 다른 escapes sequences가 일반적으로 사용되는 언어 (예 : DSLs 또는 LaTeX)의 임베딩을 허용해야합니다. ECMAScript proposal Template Literal Revision (4 단계, ECMAScript 2018 표준에 통합됨)은 tagged templates에서 ECMAScript escape sequences의 구문 제한을 제거합니다.
그러나 illegal escape sequences는 여전히 "cooked"라고 표현되어야합니다. "cooked"배열의 undefined 요소로 나타납니다 :
jsfunction latex(str) {
  return { cooked: str[0], raw: str.raw[0] };
}

latex`\unicode`;

// { cooked: undefined, raw: "\\unicode" }

escape sequence 제한은 tagged templates에만 적용되며 untagged template literals에는 적용되지 않습니다.

경고 :
let bad = bad escape sequence: \unicode;
명세서SpecificationECMAScript® 2026 Language Specification # sec-template-literals브라우저 호환성See also
String
String.raw()
Lexical grammar
Template-like strings in ES3 compatible syntax
"ES6 in Depth: Template strings" on hacks.mozilla.org\n\nTemplate literalsBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedback템플릿 리터럴은 내장된 표현식을 허용하는 문자열 리터럴입니다. 여러 줄로 이뤄진 문자열과 문자 보간기능을 사용할 수 있습니다. 이전 버전의 ES2015사양 명세에서는 "template strings" (템플릿 문자열) 라고 불려 왔습니다.Syntax    `string text`

    `string text line 1
     string text line 2`

    `string text ${expression} string text`

    tag `string text ${expression} string text`
Description템플릿 리터럴은 이중 따옴표 나 작은 따옴표 대신 백틱(` `) (grave accent) 을 이용합니다. 템플릿 리터럴은 또한 플레이스 홀더를 이용하여 표현식을 넣을 수 있는데, 이는 $와 중괄호( $ {expression} ) 로 표기할 수 있습니다. 플레이스 홀더 안에서의 표현식과 그 사이의 텍스트는 함께 함수로 전달됩니다. 기본 함수는 단순히 해당 부분을 단일 문자열로 연결시켜 줍니다. 템플릿 리터럴 앞에 어떠한 표현식이 있다면(여기에서는 태그), 템플릿 리터럴은 "태그가 지정된 템플릿"이라고 불리게 됩니다. 이 때, 태그 표현식 (주로 함수)이 처리된 템플릿 리터럴과 함께 호출되면, 출력하기 전에 조작할 수 있습니다. 템플릿 리터럴 안에서 백틱 문자를 사용하려면 백틱 앞에 백슬러쉬(\)를 넣으십시오.
js`\`` === "`"; // --> true
Multi-line stringssource 내에 삽입되는 newline characters(\n)은 template literal의 일부가 됩니다.
일반 string 들을 사용하여, multi-line strings 들을 얻기 위해서는 아래와 같은 문법을 사용해야 할 것입니다.
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
// string text line 2"

같은 효과를 template literal을 통해 얻기 위해서는, 아래와 같이 적을 수 있습니다.
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"
Expression interpolation(표현식 삽입법)표현식(expression)을 일반 문자열(normal strings)에 삽입하기 위해서, 당신은 다음의 문법을 사용할 수 있을 것입니다.
jsvar a = 5;
var b = 10;
console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");
// "Fifteen is 15 and
// not 20."

template literals을 이용하면, 이를 더욱 읽기 쉽도록 다음과 같은 문법 설탕(syntactic sugar) 을 활용할 수 있습니다.
jsvar a = 5;
var b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
// "Fifteen is 15 and
// not 20."
Nesting templates특정한 경우 템플릿을 중첩하는 것이 구성 가능한 문자열을 읽는 읽기 가장 쉬운 방법입니다. 백 스페이스 템플릿 내에서 템플릿 내의 자리 표시자${}에 내부 백틱을 사용하는 것이 쉽습니다. 예를 들어, 조건 a가 참이면:이 템플릿을 문자 그대로 반환합니다.
In ES5:
jsvar classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

ES2015에서 중첩(nesting)없이 템플릿 리터럴 사용한 경우:
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

ES2015에서 중첩된(nested) 템플릿 리터럴을 사용한 경우:
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
Tagged templatestemplate literals 의 더욱 발전된 한 형태는 tagged templates 입니다. 태그를 사용하면 템플릿 리터럴을 함수로 파싱 할 수 있습니다. 태그 함수의 첫 번째 인수는 문자열 값의 배열을 포함합니다. 나머지 인수는 표현식과 관련됩니다. 결국 함수는 조작 된 문자열을 반환 할 수 있습니다 (또는 다음 예제에서 설명하는 것과 완전히 다른 결과를 반환 할 수 있습니다). function 이름은 원하는 어떤 것이든 가능합니다.
jsvar person = "Mike";
var age = 28;

function myTag(strings, personExp, ageExp) {
  var str0 = strings[0]; // "that "
  var str1 = strings[1]; // " is a "

  // 사실 이 예제의 string에서 표현식이 두 개 삽입되었으므로
  // ${age} 뒤에는 ''인 string이 존재하여
  // 기술적으로 strings 배열의 크기는 3이 됩니다.
  // 하지만 빈 string이므로 무시하겠습니다.
  // var str2 = strings[2];

  var ageStr;
  if (ageExp > 99) {
    ageStr = "centenarian";
  } else {
    ageStr = "youngster";
  }

  // 심지어 이 함수내에서도 template literal을 반환할 수 있습니다.
  return str0 + personExp + str1 + ageStr;
}

var output = myTag`that ${person} is a ${age}`;

console.log(output);
// that Mike is a youngster

다음 예시에서 보여지듯이, Tag function 들은 string 을 반환할 필요는 없습니다.
jsfunction template(strings, ...keys) {
  return function (...values) {
    var dict = values[values.length - 1] || {};
    var result = [strings[0]];
    keys.forEach(function (key, i) {
      var value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

var t1Closure = template`${0}${1}${0}!`;
t1Closure("Y", "A"); // "YAY!"
var t2Closure = template`${0} ${"foo"}!`;
t2Closure("Hello", { foo: "World" }); // "Hello World!"
Raw strings태그 지정된 템플릿의 첫 번째 함수 인수에서 사용할 수있는 특별한 raw property을 사용하면 escape sequences 처리하지 않고 원시 문자열을 입력 한대로 액세스 할 수 있습니다.
jsfunction tag(strings) {
  console.log(strings.raw[0]);
}

tag`string text line 1 \n string text line 2`;
// logs "string text line 1 \n string text line 2" ,
// including the two characters '\' and 'n'

추가로, default template function 과 string 병합으로 생성될 것 같은 raw string 을 생성하기 위한 String.raw() method가 존재합니다.
jsvar str = String.raw`Hi\n${2 + 3}!`;
// "Hi\n5!"

str.length;
// 6

str.split("").join(",");
// "H,i,\,n,5,!"
Tagged templates and escape sequencesES2016 behavior
ECMAScript 2016에서 tagged templates은 다음 escape sequences의 규칙을 따릅니다.

Unicode escapes started by "\u", for example \u00A9
Unicode code point escapes indicated by "\u{}", for example \u{2F804}
Hexadecimal escapes started by "\x", for example \xA9
Octal literal escapes started by "\" and (a) digit(s), for example \251

이는 다음과 같은 tagged template이 문제가 된다는 것을 의미하는데, ECMAScript문법에 따라, parser는 유효한 유니 코드 탈출 시퀀스가 있는지 확인하지만 형식이 잘못되었기 때문에 오류가 발생합니다.
    latex`\unicode`
    // Throws in older ECMAScript versions (ES2016 and earlier)
    // SyntaxError: malformed Unicode character escape sequence

ES2018 revision of illegal escape sequences
Tagged templates은 다른 escapes sequences가 일반적으로 사용되는 언어 (예 : DSLs 또는 LaTeX)의 임베딩을 허용해야합니다. ECMAScript proposal Template Literal Revision (4 단계, ECMAScript 2018 표준에 통합됨)은 tagged templates에서 ECMAScript escape sequences의 구문 제한을 제거합니다.
그러나 illegal escape sequences는 여전히 "cooked"라고 표현되어야합니다. "cooked"배열의 undefined 요소로 나타납니다 :
jsfunction latex(str) {
  return { cooked: str[0], raw: str.raw[0] };
}

latex`\unicode`;

// { cooked: undefined, raw: "\\unicode" }

escape sequence 제한은 tagged templates에만 적용되며 untagged template literals에는 적용되지 않습니다.

경고 :
let bad = bad escape sequence: \unicode;
명세서SpecificationECMAScript® 2026 Language Specification # sec-template-literals브라우저 호환성See also
String
String.raw()
Lexical grammar
Template-like strings in ES3 compatible syntax
"ES6 in Depth: Template strings" on hacks.mozilla.org
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2024년 12월 17일 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nTemplate literalsBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedback템플릿 리터럴은 내장된 표현식을 허용하는 문자열 리터럴입니다. 여러 줄로 이뤄진 문자열과 문자 보간기능을 사용할 수 있습니다. 이전 버전의 ES2015사양 명세에서는 "template strings" (템플릿 문자열) 라고 불려 왔습니다.Syntax    `string text`

    `string text line 1
     string text line 2`

    `string text ${expression} string text`

    tag `string text ${expression} string text`
Description템플릿 리터럴은 이중 따옴표 나 작은 따옴표 대신 백틱(` `) (grave accent) 을 이용합니다. 템플릿 리터럴은 또한 플레이스 홀더를 이용하여 표현식을 넣을 수 있는데, 이는 $와 중괄호( $ {expression} ) 로 표기할 수 있습니다. 플레이스 홀더 안에서의 표현식과 그 사이의 텍스트는 함께 함수로 전달됩니다. 기본 함수는 단순히 해당 부분을 단일 문자열로 연결시켜 줍니다. 템플릿 리터럴 앞에 어떠한 표현식이 있다면(여기에서는 태그), 템플릿 리터럴은 "태그가 지정된 템플릿"이라고 불리게 됩니다. 이 때, 태그 표현식 (주로 함수)이 처리된 템플릿 리터럴과 함께 호출되면, 출력하기 전에 조작할 수 있습니다. 템플릿 리터럴 안에서 백틱 문자를 사용하려면 백틱 앞에 백슬러쉬(\)를 넣으십시오.
js`\`` === "`"; // --> true
Multi-line stringssource 내에 삽입되는 newline characters(\n)은 template literal의 일부가 됩니다.
일반 string 들을 사용하여, multi-line strings 들을 얻기 위해서는 아래와 같은 문법을 사용해야 할 것입니다.
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
// string text line 2"

같은 효과를 template literal을 통해 얻기 위해서는, 아래와 같이 적을 수 있습니다.
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"
Expression interpolation(표현식 삽입법)표현식(expression)을 일반 문자열(normal strings)에 삽입하기 위해서, 당신은 다음의 문법을 사용할 수 있을 것입니다.
jsvar a = 5;
var b = 10;
console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");
// "Fifteen is 15 and
// not 20."

template literals을 이용하면, 이를 더욱 읽기 쉽도록 다음과 같은 문법 설탕(syntactic sugar) 을 활용할 수 있습니다.
jsvar a = 5;
var b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
// "Fifteen is 15 and
// not 20."
Nesting templates특정한 경우 템플릿을 중첩하는 것이 구성 가능한 문자열을 읽는 읽기 가장 쉬운 방법입니다. 백 스페이스 템플릿 내에서 템플릿 내의 자리 표시자${}에 내부 백틱을 사용하는 것이 쉽습니다. 예를 들어, 조건 a가 참이면:이 템플릿을 문자 그대로 반환합니다.
In ES5:
jsvar classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

ES2015에서 중첩(nesting)없이 템플릿 리터럴 사용한 경우:
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

ES2015에서 중첩된(nested) 템플릿 리터럴을 사용한 경우:
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
Tagged templatestemplate literals 의 더욱 발전된 한 형태는 tagged templates 입니다. 태그를 사용하면 템플릿 리터럴을 함수로 파싱 할 수 있습니다. 태그 함수의 첫 번째 인수는 문자열 값의 배열을 포함합니다. 나머지 인수는 표현식과 관련됩니다. 결국 함수는 조작 된 문자열을 반환 할 수 있습니다 (또는 다음 예제에서 설명하는 것과 완전히 다른 결과를 반환 할 수 있습니다). function 이름은 원하는 어떤 것이든 가능합니다.
jsvar person = "Mike";
var age = 28;

function myTag(strings, personExp, ageExp) {
  var str0 = strings[0]; // "that "
  var str1 = strings[1]; // " is a "

  // 사실 이 예제의 string에서 표현식이 두 개 삽입되었으므로
  // ${age} 뒤에는 ''인 string이 존재하여
  // 기술적으로 strings 배열의 크기는 3이 됩니다.
  // 하지만 빈 string이므로 무시하겠습니다.
  // var str2 = strings[2];

  var ageStr;
  if (ageExp > 99) {
    ageStr = "centenarian";
  } else {
    ageStr = "youngster";
  }

  // 심지어 이 함수내에서도 template literal을 반환할 수 있습니다.
  return str0 + personExp + str1 + ageStr;
}

var output = myTag`that ${person} is a ${age}`;

console.log(output);
// that Mike is a youngster

다음 예시에서 보여지듯이, Tag function 들은 string 을 반환할 필요는 없습니다.
jsfunction template(strings, ...keys) {
  return function (...values) {
    var dict = values[values.length - 1] || {};
    var result = [strings[0]];
    keys.forEach(function (key, i) {
      var value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

var t1Closure = template`${0}${1}${0}!`;
t1Closure("Y", "A"); // "YAY!"
var t2Closure = template`${0} ${"foo"}!`;
t2Closure("Hello", { foo: "World" }); // "Hello World!"
Raw strings태그 지정된 템플릿의 첫 번째 함수 인수에서 사용할 수있는 특별한 raw property을 사용하면 escape sequences 처리하지 않고 원시 문자열을 입력 한대로 액세스 할 수 있습니다.
jsfunction tag(strings) {
  console.log(strings.raw[0]);
}

tag`string text line 1 \n string text line 2`;
// logs "string text line 1 \n string text line 2" ,
// including the two characters '\' and 'n'

추가로, default template function 과 string 병합으로 생성될 것 같은 raw string 을 생성하기 위한 String.raw() method가 존재합니다.
jsvar str = String.raw`Hi\n${2 + 3}!`;
// "Hi\n5!"

str.length;
// 6

str.split("").join(",");
// "H,i,\,n,5,!"
Tagged templates and escape sequencesES2016 behavior
ECMAScript 2016에서 tagged templates은 다음 escape sequences의 규칙을 따릅니다.

Unicode escapes started by "\u", for example \u00A9
Unicode code point escapes indicated by "\u{}", for example \u{2F804}
Hexadecimal escapes started by "\x", for example \xA9
Octal literal escapes started by "\" and (a) digit(s), for example \251

이는 다음과 같은 tagged template이 문제가 된다는 것을 의미하는데, ECMAScript문법에 따라, parser는 유효한 유니 코드 탈출 시퀀스가 있는지 확인하지만 형식이 잘못되었기 때문에 오류가 발생합니다.
    latex`\unicode`
    // Throws in older ECMAScript versions (ES2016 and earlier)
    // SyntaxError: malformed Unicode character escape sequence

ES2018 revision of illegal escape sequences
Tagged templates은 다른 escapes sequences가 일반적으로 사용되는 언어 (예 : DSLs 또는 LaTeX)의 임베딩을 허용해야합니다. ECMAScript proposal Template Literal Revision (4 단계, ECMAScript 2018 표준에 통합됨)은 tagged templates에서 ECMAScript escape sequences의 구문 제한을 제거합니다.
그러나 illegal escape sequences는 여전히 "cooked"라고 표현되어야합니다. "cooked"배열의 undefined 요소로 나타납니다 :
jsfunction latex(str) {
  return { cooked: str[0], raw: str.raw[0] };
}

latex`\unicode`;

// { cooked: undefined, raw: "\\unicode" }

escape sequence 제한은 tagged templates에만 적용되며 untagged template literals에는 적용되지 않습니다.

경고 :
let bad = bad escape sequence: \unicode;
명세서SpecificationECMAScript® 2026 Language Specification # sec-template-literals브라우저 호환성See also
String
String.raw()
Lexical grammar
Template-like strings in ES3 compatible syntax
"ES6 in Depth: Template strings" on hacks.mozilla.org
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2024년 12월 17일 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nTemplate stringsBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackTemplate Strings são strings que permitem expressões embutidas. Você pode utilizar string multi-linhas e interpolação de string com elas.
Basicamente é uma nova forma de criar strings e tornar o seu código um pouco mais legível.Sintaxejs`corpo de texto`

`texto linha 1
 texto linha 2`

`texto string ${expression} texto string`

tag `texto string ${expression} texto string`
DescriçãoTemplate strings são envolvidas por (acentos graves) (` `) em vez de aspas simples ou duplas. Template strings podem possuir placeholders. Estes são indicados por um cifrão seguido de chaves (${expression}). As expressões nos placeholders, bem como o texto em volta delas são passados a uma função. A função padrão apenas concatena as partes em uma string única. Se existir uma expressão precedendo a template string (função tag exemplo), a template string é definida como "tagged template string". No caso, a expressão tag (geralmente uma função) é chamada pela template string processada, que você pode manipular antes de produzir o resultado.
js`\`` === "`"; // --> true
Strings multi-linhasQualquer caracter de nova linha inserido no código é parte da template string. Utilizando strings normais, você teria de usar a síntaxe a seguir para obter strings multi-linhas:
jsconsole.log("texto string linha 1\n" + "texto string linha 2");
// "texto string linha 1
// texto string linha 2"

Para obter o mesmo efeito com strings multi-linhas, você agora pode escrever:
jsconsole.log(`texto string linha 1
texto string linha 2`);
// "texto string linha 1
//  texto string linha 2"
Interpolação de ExpressõesPara encapsular expressões dentro de strings, você precisava utilizar a seguinte sintaxe:
jsvar a = 5;
var b = 10;
console.log("Quinze é " + (a + b) + " e\nnão " + (2 * a + b) + ".");
// "Quinze é 15 e
// não 20."

Agora, com template strings, você pode utilizar as substituições sintáticas tornando o código mais legível:
jsvar a = 5;
var b = 10;
console.log(`Quinze é ${a + b} e
não ${2 * a + b}.`);
// "Quinze é 15 e
// não 20."
Tagged template stringsUma forma mais avançada dos template string são os template strings com marcações ou tags, ou tagged template strings. Com eles, você tem a possibilidade de modificar a saída dos template strings usando uma função. O primeiro argumento contém um array de literais ("Hello" e "World" neste exemplo). Do segundo em diante e cada argumento subsequente contém valores previamente processados (algumas vezes chamados cooked) pelas expressões de substituição ("15" e "50" no caso do exemplo). No final, a função retorna a string ja manipulada:
jsvar a = 5;
var b = 10;

function tag(strings, ...values) {
  console.log(strings[0]); // "Hello "
  console.log(strings[1]); // " world "
  console.log(values[0]); // 15
  console.log(values[1]); // 50

  return "Bazinga!";
}

tag`Hello ${a + b} world ${a * b}`;
// "Bazinga!"
Strings RawA propriedade especial raw, disponível no primeiro argumento da função da tagged template string acima, permite o acesso as strings de maneira pura (raw) exatamente como elas foram especificadas:
jsfunction tag(strings, ...values) {
  return strings.raw[0];
}

tag`string text line 1 \n string text line 2`;
// "string text line 1 \\n string text line 2"

Adicionalmente, o método String.raw() permite a criação de strings cruas, exatamente como as template functions e as concatenações deveram criar.
jsString.raw`Hi\n${2 + 3}!`; // "Hi\\n5!"
EspecificaçõesSpecificationECMAScript® 2026 Language Specification # sec-template-literalsCompatibilidade com navegadoresVeja também
String
String.raw()
Gramática léxica
Template-like strings in ES3 compatible syntax
"ES6 in Depth: Template strings" on hacks.mozilla.org
https://styled-components.com/\n\nTemplate stringsBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackTemplate Strings são strings que permitem expressões embutidas. Você pode utilizar string multi-linhas e interpolação de string com elas.
Basicamente é uma nova forma de criar strings e tornar o seu código um pouco mais legível.Sintaxejs`corpo de texto`

`texto linha 1
 texto linha 2`

`texto string ${expression} texto string`

tag `texto string ${expression} texto string`
DescriçãoTemplate strings são envolvidas por (acentos graves) (` `) em vez de aspas simples ou duplas. Template strings podem possuir placeholders. Estes são indicados por um cifrão seguido de chaves (${expression}). As expressões nos placeholders, bem como o texto em volta delas são passados a uma função. A função padrão apenas concatena as partes em uma string única. Se existir uma expressão precedendo a template string (função tag exemplo), a template string é definida como "tagged template string". No caso, a expressão tag (geralmente uma função) é chamada pela template string processada, que você pode manipular antes de produzir o resultado.
js`\`` === "`"; // --> true
Strings multi-linhasQualquer caracter de nova linha inserido no código é parte da template string. Utilizando strings normais, você teria de usar a síntaxe a seguir para obter strings multi-linhas:
jsconsole.log("texto string linha 1\n" + "texto string linha 2");
// "texto string linha 1
// texto string linha 2"

Para obter o mesmo efeito com strings multi-linhas, você agora pode escrever:
jsconsole.log(`texto string linha 1
texto string linha 2`);
// "texto string linha 1
//  texto string linha 2"
Interpolação de ExpressõesPara encapsular expressões dentro de strings, você precisava utilizar a seguinte sintaxe:
jsvar a = 5;
var b = 10;
console.log("Quinze é " + (a + b) + " e\nnão " + (2 * a + b) + ".");
// "Quinze é 15 e
// não 20."

Agora, com template strings, você pode utilizar as substituições sintáticas tornando o código mais legível:
jsvar a = 5;
var b = 10;
console.log(`Quinze é ${a + b} e
não ${2 * a + b}.`);
// "Quinze é 15 e
// não 20."
Tagged template stringsUma forma mais avançada dos template string são os template strings com marcações ou tags, ou tagged template strings. Com eles, você tem a possibilidade de modificar a saída dos template strings usando uma função. O primeiro argumento contém um array de literais ("Hello" e "World" neste exemplo). Do segundo em diante e cada argumento subsequente contém valores previamente processados (algumas vezes chamados cooked) pelas expressões de substituição ("15" e "50" no caso do exemplo). No final, a função retorna a string ja manipulada:
jsvar a = 5;
var b = 10;

function tag(strings, ...values) {
  console.log(strings[0]); // "Hello "
  console.log(strings[1]); // " world "
  console.log(values[0]); // 15
  console.log(values[1]); // 50

  return "Bazinga!";
}

tag`Hello ${a + b} world ${a * b}`;
// "Bazinga!"
Strings RawA propriedade especial raw, disponível no primeiro argumento da função da tagged template string acima, permite o acesso as strings de maneira pura (raw) exatamente como elas foram especificadas:
jsfunction tag(strings, ...values) {
  return strings.raw[0];
}

tag`string text line 1 \n string text line 2`;
// "string text line 1 \\n string text line 2"

Adicionalmente, o método String.raw() permite a criação de strings cruas, exatamente como as template functions e as concatenações deveram criar.
jsString.raw`Hi\n${2 + 3}!`; // "Hi\\n5!"
EspecificaçõesSpecificationECMAScript® 2026 Language Specification # sec-template-literalsCompatibilidade com navegadoresVeja também
String
String.raw()
Gramática léxica
Template-like strings in ES3 compatible syntax
"ES6 in Depth: Template strings" on hacks.mozilla.org
https://styled-components.com/
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 4 de ago. de 2023 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nTemplate stringsBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackTemplate Strings são strings que permitem expressões embutidas. Você pode utilizar string multi-linhas e interpolação de string com elas.
Basicamente é uma nova forma de criar strings e tornar o seu código um pouco mais legível.Sintaxejs`corpo de texto`

`texto linha 1
 texto linha 2`

`texto string ${expression} texto string`

tag `texto string ${expression} texto string`
DescriçãoTemplate strings são envolvidas por (acentos graves) (` `) em vez de aspas simples ou duplas. Template strings podem possuir placeholders. Estes são indicados por um cifrão seguido de chaves (${expression}). As expressões nos placeholders, bem como o texto em volta delas são passados a uma função. A função padrão apenas concatena as partes em uma string única. Se existir uma expressão precedendo a template string (função tag exemplo), a template string é definida como "tagged template string". No caso, a expressão tag (geralmente uma função) é chamada pela template string processada, que você pode manipular antes de produzir o resultado.
js`\`` === "`"; // --> true
Strings multi-linhasQualquer caracter de nova linha inserido no código é parte da template string. Utilizando strings normais, você teria de usar a síntaxe a seguir para obter strings multi-linhas:
jsconsole.log("texto string linha 1\n" + "texto string linha 2");
// "texto string linha 1
// texto string linha 2"

Para obter o mesmo efeito com strings multi-linhas, você agora pode escrever:
jsconsole.log(`texto string linha 1
texto string linha 2`);
// "texto string linha 1
//  texto string linha 2"
Interpolação de ExpressõesPara encapsular expressões dentro de strings, você precisava utilizar a seguinte sintaxe:
jsvar a = 5;
var b = 10;
console.log("Quinze é " + (a + b) + " e\nnão " + (2 * a + b) + ".");
// "Quinze é 15 e
// não 20."

Agora, com template strings, você pode utilizar as substituições sintáticas tornando o código mais legível:
jsvar a = 5;
var b = 10;
console.log(`Quinze é ${a + b} e
não ${2 * a + b}.`);
// "Quinze é 15 e
// não 20."
Tagged template stringsUma forma mais avançada dos template string são os template strings com marcações ou tags, ou tagged template strings. Com eles, você tem a possibilidade de modificar a saída dos template strings usando uma função. O primeiro argumento contém um array de literais ("Hello" e "World" neste exemplo). Do segundo em diante e cada argumento subsequente contém valores previamente processados (algumas vezes chamados cooked) pelas expressões de substituição ("15" e "50" no caso do exemplo). No final, a função retorna a string ja manipulada:
jsvar a = 5;
var b = 10;

function tag(strings, ...values) {
  console.log(strings[0]); // "Hello "
  console.log(strings[1]); // " world "
  console.log(values[0]); // 15
  console.log(values[1]); // 50

  return "Bazinga!";
}

tag`Hello ${a + b} world ${a * b}`;
// "Bazinga!"
Strings RawA propriedade especial raw, disponível no primeiro argumento da função da tagged template string acima, permite o acesso as strings de maneira pura (raw) exatamente como elas foram especificadas:
jsfunction tag(strings, ...values) {
  return strings.raw[0];
}

tag`string text line 1 \n string text line 2`;
// "string text line 1 \\n string text line 2"

Adicionalmente, o método String.raw() permite a criação de strings cruas, exatamente como as template functions e as concatenações deveram criar.
jsString.raw`Hi\n${2 + 3}!`; // "Hi\\n5!"
EspecificaçõesSpecificationECMAScript® 2026 Language Specification # sec-template-literalsCompatibilidade com navegadoresVeja também
String
String.raw()
Gramática léxica
Template-like strings in ES3 compatible syntax
"ES6 in Depth: Template strings" on hacks.mozilla.org
https://styled-components.com/
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 4 de ago. de 2023 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nШаблонные строкиBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackШаблонными литералами называются строковые литералы, допускающие использование выражений внутри. С ними вы можете использовать многострочные литералы и строковую интерполяцию. В спецификациях до ES2015 они назывались "шаблонными строками".Синтаксис`строка текста`

`строка текста 1
 строка текста 2`

`строка текста ${выражение} строка текста`

tag `строка текста ${выражение} строка текста`
ОписаниеШаблонные литералы заключены в обратные кавычки (` `) вместо двойных или одинарных. Они могут содержать подстановки, обозначаемые знаком доллара и фигурными скобками (${выражение}). Выражения в подстановках и текст между ними передаются в функцию. По умолчанию функция просто объединяет все части в строку. Если перед строкой есть выражение (здесь это tag), то шаблонная строка называется "теговым шаблоном". В этом случае, теговое выражение (обычно функция) вызывается с обработанным шаблонным литералом, который вы можете изменить перед выводом. Для экранирования обратной кавычки в шаблонных литералах указывается обратный слеш \.
js`\`` === "`"; // --> true
Многострочные литералыСимволы новой строки являются частью шаблонных литералов. Используя обычные строки, вставка переноса потребовала бы следующего синтаксиса:
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
//  string text line 2"

То же с использованием шаблонных литералов:
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
//  string text line 2"
Интерполяция выраженийДля вставки выражений в обычные строки вам пришлось бы использовать следующий синтаксис:
jsvar a = 5;
var b = 10;
console.log("Fifteen is " + (a + b) + " and not " + (2 * a + b) + ".");
// "Fifteen is 15 and not 20."

Теперь, при помощи шаблонных литералов, вам доступен "синтаксический сахар", делающий подстановки вроде той более читабельными:
jsvar a = 5;
var b = 10;
console.log(`Fifteen is ${a + b} and not ${2 * a + b}.`);
// "Fifteen is 15 and not 20."
Вложенные шаблоныВременами, вложить шаблон — это кратчайший и, возможно, более читабельный способ составить строку. Просто поместите внутрь шаблона с обратными кавычками ещё одни, обернув их в подстановку ${ }. Например, если выражение истинно, можно вернуть шаблонный литерал.
В ES5:
jsvar classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

В ES2015 с шаблонными литералами без вложения:
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

В ES2015 с вложенными шаблонными литералами:
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
Теговые шаблоныРасширенной формой шаблонных литералов являются теговые шаблоны. Они позволяют разбирать шаблонные литералы с помощью функции. Первый аргумент такой функции содержит массив строковых значений, а остальные содержат выражения из подстановок. В итоге, функция должна вернуть собранную строку (или что-либо совсем иное, как будет показано далее). Имя функции может быть любым.
jsvar person = "Mike";
var age = 28;

function myTag(strings, personExp, ageExp) {
  var str0 = strings[0]; // "That "
  var str1 = strings[1]; // " is a "

  // Технически, в конце итогового выражения
  // (в нашем примере) есть ещё одна строка,
  // но она пустая (""), так что пропустим её.
  // var str2 = strings[2];

  var ageStr;
  if (ageExp > 99) {
    ageStr = "centenarian";
  } else {
    ageStr = "youngster";
  }

  // Мы даже можем вернуть строку, построенную другим шаблонным литералом
  return `${str0}${personExp}${str1}${ageStr}`;
}

var output = myTag`That ${person} is a ${age}`;

console.log(output);
// That Mike is a youngster

Функция тега не обязана возвращать строку, как показано в примере ниже:
jsfunction template(strings, ...keys) {
  return function (...values) {
    var dict = values[values.length - 1] || {};
    var result = [strings[0]];
    keys.forEach(function (key, i) {
      var value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

var t1Closure = template`${0}${1}${0}!`;
t1Closure("Y", "A"); // "YAY!"
var t2Closure = template`${0} ${"foo"}!`;
t2Closure("Hello", { foo: "World" }); // "Hello World!"
Сырые строкиСпециальное свойство raw, доступное для первого аргумента тегового шаблона, позволяет получить строку в том виде, в каком она была введена, без экранирования.
jsfunction tag(strings) {
  return strings.raw[0];
}

tag`string text line 1 \\n string text line 2`;
// выводит "string text line 1 \\n string text line 2",
// включая 'n' и два символа '\'

Вдобавок, существует метод String.raw(), возвращающий точно такую же исходную строку, какую вернула бы функция шаблона по умолчанию и строковая конкатенация вместе.
jsvar str = String.raw`Hi\n${2 + 3}!`;
// "Hi\n5!"

str.length;
// 6

str.split("").join(",");
// "H,i,\,n,5,!"
Теговые шаблоны и экранирование символовПоведение в ES2016
В ECMAScript 2016 теговые шаблоны следуют правилам экранирования следующих символов:

символы Unicode, начинающиеся с "\u", например, \u00A9
точки кода Unicode, начинающиеся с "\u{}", например, \u{2F804}
шестнадцатеричные представления символов, начинающиеся с "\x", например, \xA9
восьмеричные представления символов, начинающиеся с "\", например, \251

Отсюда вытекает проблема теговых шаблонов: следуя грамматике ECMAScript, анализатор кода, найдя символ \, будет искать корректное представление символа Unicode, но может не найти его вовсе. Пример ниже показывает это:
jslatex`\unicode`;
// В старых версиях ECMAScript (ES2016 и раньше) выкинет исключение:
// SyntaxError: malformed Unicode character escape sequence

Поведение в ES2018
Теговые шаблоны должны позволять встраивать языки (например, DSLs или LaTeX), в которых широко используются многие другие экранирования. Предложение Редакция шаблонных литералов (уровень 4, одобренный к добавлению в стандарт ECMAScript 2018) устраняет синтаксические ограничения экранирования теговых шаблонов в ECMAScript.
Однако, некорректное экранирование символов по-прежнему нужно отображать в "приготовленном" отображении. Оно показывается в виде undefined в "приготовленном" массиве:
jsfunction latex(str) {
  return { cooked: str[0], raw: str.raw[0] };
}

latex`\unicode`;

// { cooked: undefined, raw: "\unicode" }

Заметьте, что ограничение на экранирование символов проявляется лишь в теговых шаблонах, и не проявляется в нетеговых шаблонных литералах:
jslet bad = `bad escape sequence: \unicode`;
СпецификацииSpecificationECMAScript® 2026 Language Specification # sec-template-literalsСовместимость с браузерамиСмотрите также
String
String.raw()
Лексическая грамматика
Подобные шаблонам строки в ES3-совместимом синтаксисе
ES6 в деталях: шаблонные строки\n\nШаблонные строкиBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackШаблонными литералами называются строковые литералы, допускающие использование выражений внутри. С ними вы можете использовать многострочные литералы и строковую интерполяцию. В спецификациях до ES2015 они назывались "шаблонными строками".Синтаксис`строка текста`

`строка текста 1
 строка текста 2`

`строка текста ${выражение} строка текста`

tag `строка текста ${выражение} строка текста`
ОписаниеШаблонные литералы заключены в обратные кавычки (` `) вместо двойных или одинарных. Они могут содержать подстановки, обозначаемые знаком доллара и фигурными скобками (${выражение}). Выражения в подстановках и текст между ними передаются в функцию. По умолчанию функция просто объединяет все части в строку. Если перед строкой есть выражение (здесь это tag), то шаблонная строка называется "теговым шаблоном". В этом случае, теговое выражение (обычно функция) вызывается с обработанным шаблонным литералом, который вы можете изменить перед выводом. Для экранирования обратной кавычки в шаблонных литералах указывается обратный слеш \.
js`\`` === "`"; // --> true
Многострочные литералыСимволы новой строки являются частью шаблонных литералов. Используя обычные строки, вставка переноса потребовала бы следующего синтаксиса:
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
//  string text line 2"

То же с использованием шаблонных литералов:
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
//  string text line 2"
Интерполяция выраженийДля вставки выражений в обычные строки вам пришлось бы использовать следующий синтаксис:
jsvar a = 5;
var b = 10;
console.log("Fifteen is " + (a + b) + " and not " + (2 * a + b) + ".");
// "Fifteen is 15 and not 20."

Теперь, при помощи шаблонных литералов, вам доступен "синтаксический сахар", делающий подстановки вроде той более читабельными:
jsvar a = 5;
var b = 10;
console.log(`Fifteen is ${a + b} and not ${2 * a + b}.`);
// "Fifteen is 15 and not 20."
Вложенные шаблоныВременами, вложить шаблон — это кратчайший и, возможно, более читабельный способ составить строку. Просто поместите внутрь шаблона с обратными кавычками ещё одни, обернув их в подстановку ${ }. Например, если выражение истинно, можно вернуть шаблонный литерал.
В ES5:
jsvar classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

В ES2015 с шаблонными литералами без вложения:
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

В ES2015 с вложенными шаблонными литералами:
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
Теговые шаблоныРасширенной формой шаблонных литералов являются теговые шаблоны. Они позволяют разбирать шаблонные литералы с помощью функции. Первый аргумент такой функции содержит массив строковых значений, а остальные содержат выражения из подстановок. В итоге, функция должна вернуть собранную строку (или что-либо совсем иное, как будет показано далее). Имя функции может быть любым.
jsvar person = "Mike";
var age = 28;

function myTag(strings, personExp, ageExp) {
  var str0 = strings[0]; // "That "
  var str1 = strings[1]; // " is a "

  // Технически, в конце итогового выражения
  // (в нашем примере) есть ещё одна строка,
  // но она пустая (""), так что пропустим её.
  // var str2 = strings[2];

  var ageStr;
  if (ageExp > 99) {
    ageStr = "centenarian";
  } else {
    ageStr = "youngster";
  }

  // Мы даже можем вернуть строку, построенную другим шаблонным литералом
  return `${str0}${personExp}${str1}${ageStr}`;
}

var output = myTag`That ${person} is a ${age}`;

console.log(output);
// That Mike is a youngster

Функция тега не обязана возвращать строку, как показано в примере ниже:
jsfunction template(strings, ...keys) {
  return function (...values) {
    var dict = values[values.length - 1] || {};
    var result = [strings[0]];
    keys.forEach(function (key, i) {
      var value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

var t1Closure = template`${0}${1}${0}!`;
t1Closure("Y", "A"); // "YAY!"
var t2Closure = template`${0} ${"foo"}!`;
t2Closure("Hello", { foo: "World" }); // "Hello World!"
Сырые строкиСпециальное свойство raw, доступное для первого аргумента тегового шаблона, позволяет получить строку в том виде, в каком она была введена, без экранирования.
jsfunction tag(strings) {
  return strings.raw[0];
}

tag`string text line 1 \\n string text line 2`;
// выводит "string text line 1 \\n string text line 2",
// включая 'n' и два символа '\'

Вдобавок, существует метод String.raw(), возвращающий точно такую же исходную строку, какую вернула бы функция шаблона по умолчанию и строковая конкатенация вместе.
jsvar str = String.raw`Hi\n${2 + 3}!`;
// "Hi\n5!"

str.length;
// 6

str.split("").join(",");
// "H,i,\,n,5,!"
Теговые шаблоны и экранирование символовПоведение в ES2016
В ECMAScript 2016 теговые шаблоны следуют правилам экранирования следующих символов:

символы Unicode, начинающиеся с "\u", например, \u00A9
точки кода Unicode, начинающиеся с "\u{}", например, \u{2F804}
шестнадцатеричные представления символов, начинающиеся с "\x", например, \xA9
восьмеричные представления символов, начинающиеся с "\", например, \251

Отсюда вытекает проблема теговых шаблонов: следуя грамматике ECMAScript, анализатор кода, найдя символ \, будет искать корректное представление символа Unicode, но может не найти его вовсе. Пример ниже показывает это:
jslatex`\unicode`;
// В старых версиях ECMAScript (ES2016 и раньше) выкинет исключение:
// SyntaxError: malformed Unicode character escape sequence

Поведение в ES2018
Теговые шаблоны должны позволять встраивать языки (например, DSLs или LaTeX), в которых широко используются многие другие экранирования. Предложение Редакция шаблонных литералов (уровень 4, одобренный к добавлению в стандарт ECMAScript 2018) устраняет синтаксические ограничения экранирования теговых шаблонов в ECMAScript.
Однако, некорректное экранирование символов по-прежнему нужно отображать в "приготовленном" отображении. Оно показывается в виде undefined в "приготовленном" массиве:
jsfunction latex(str) {
  return { cooked: str[0], raw: str.raw[0] };
}

latex`\unicode`;

// { cooked: undefined, raw: "\unicode" }

Заметьте, что ограничение на экранирование символов проявляется лишь в теговых шаблонах, и не проявляется в нетеговых шаблонных литералах:
jslet bad = `bad escape sequence: \unicode`;
СпецификацииSpecificationECMAScript® 2026 Language Specification # sec-template-literalsСовместимость с браузерамиСмотрите также
String
String.raw()
Лексическая грамматика
Подобные шаблонам строки в ES3-совместимом синтаксисе
ES6 в деталях: шаблонные строки
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 17 дек. 2024 г. by MDN contributors.View this page on GitHub • Report a problem with this content\n\nШаблонные строкиBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackШаблонными литералами называются строковые литералы, допускающие использование выражений внутри. С ними вы можете использовать многострочные литералы и строковую интерполяцию. В спецификациях до ES2015 они назывались "шаблонными строками".Синтаксис`строка текста`

`строка текста 1
 строка текста 2`

`строка текста ${выражение} строка текста`

tag `строка текста ${выражение} строка текста`
ОписаниеШаблонные литералы заключены в обратные кавычки (` `) вместо двойных или одинарных. Они могут содержать подстановки, обозначаемые знаком доллара и фигурными скобками (${выражение}). Выражения в подстановках и текст между ними передаются в функцию. По умолчанию функция просто объединяет все части в строку. Если перед строкой есть выражение (здесь это tag), то шаблонная строка называется "теговым шаблоном". В этом случае, теговое выражение (обычно функция) вызывается с обработанным шаблонным литералом, который вы можете изменить перед выводом. Для экранирования обратной кавычки в шаблонных литералах указывается обратный слеш \.
js`\`` === "`"; // --> true
Многострочные литералыСимволы новой строки являются частью шаблонных литералов. Используя обычные строки, вставка переноса потребовала бы следующего синтаксиса:
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
//  string text line 2"

То же с использованием шаблонных литералов:
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
//  string text line 2"
Интерполяция выраженийДля вставки выражений в обычные строки вам пришлось бы использовать следующий синтаксис:
jsvar a = 5;
var b = 10;
console.log("Fifteen is " + (a + b) + " and not " + (2 * a + b) + ".");
// "Fifteen is 15 and not 20."

Теперь, при помощи шаблонных литералов, вам доступен "синтаксический сахар", делающий подстановки вроде той более читабельными:
jsvar a = 5;
var b = 10;
console.log(`Fifteen is ${a + b} and not ${2 * a + b}.`);
// "Fifteen is 15 and not 20."
Вложенные шаблоныВременами, вложить шаблон — это кратчайший и, возможно, более читабельный способ составить строку. Просто поместите внутрь шаблона с обратными кавычками ещё одни, обернув их в подстановку ${ }. Например, если выражение истинно, можно вернуть шаблонный литерал.
В ES5:
jsvar classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

В ES2015 с шаблонными литералами без вложения:
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

В ES2015 с вложенными шаблонными литералами:
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
Теговые шаблоныРасширенной формой шаблонных литералов являются теговые шаблоны. Они позволяют разбирать шаблонные литералы с помощью функции. Первый аргумент такой функции содержит массив строковых значений, а остальные содержат выражения из подстановок. В итоге, функция должна вернуть собранную строку (или что-либо совсем иное, как будет показано далее). Имя функции может быть любым.
jsvar person = "Mike";
var age = 28;

function myTag(strings, personExp, ageExp) {
  var str0 = strings[0]; // "That "
  var str1 = strings[1]; // " is a "

  // Технически, в конце итогового выражения
  // (в нашем примере) есть ещё одна строка,
  // но она пустая (""), так что пропустим её.
  // var str2 = strings[2];

  var ageStr;
  if (ageExp > 99) {
    ageStr = "centenarian";
  } else {
    ageStr = "youngster";
  }

  // Мы даже можем вернуть строку, построенную другим шаблонным литералом
  return `${str0}${personExp}${str1}${ageStr}`;
}

var output = myTag`That ${person} is a ${age}`;

console.log(output);
// That Mike is a youngster

Функция тега не обязана возвращать строку, как показано в примере ниже:
jsfunction template(strings, ...keys) {
  return function (...values) {
    var dict = values[values.length - 1] || {};
    var result = [strings[0]];
    keys.forEach(function (key, i) {
      var value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

var t1Closure = template`${0}${1}${0}!`;
t1Closure("Y", "A"); // "YAY!"
var t2Closure = template`${0} ${"foo"}!`;
t2Closure("Hello", { foo: "World" }); // "Hello World!"
Сырые строкиСпециальное свойство raw, доступное для первого аргумента тегового шаблона, позволяет получить строку в том виде, в каком она была введена, без экранирования.
jsfunction tag(strings) {
  return strings.raw[0];
}

tag`string text line 1 \\n string text line 2`;
// выводит "string text line 1 \\n string text line 2",
// включая 'n' и два символа '\'

Вдобавок, существует метод String.raw(), возвращающий точно такую же исходную строку, какую вернула бы функция шаблона по умолчанию и строковая конкатенация вместе.
jsvar str = String.raw`Hi\n${2 + 3}!`;
// "Hi\n5!"

str.length;
// 6

str.split("").join(",");
// "H,i,\,n,5,!"
Теговые шаблоны и экранирование символовПоведение в ES2016
В ECMAScript 2016 теговые шаблоны следуют правилам экранирования следующих символов:

символы Unicode, начинающиеся с "\u", например, \u00A9
точки кода Unicode, начинающиеся с "\u{}", например, \u{2F804}
шестнадцатеричные представления символов, начинающиеся с "\x", например, \xA9
восьмеричные представления символов, начинающиеся с "\", например, \251

Отсюда вытекает проблема теговых шаблонов: следуя грамматике ECMAScript, анализатор кода, найдя символ \, будет искать корректное представление символа Unicode, но может не найти его вовсе. Пример ниже показывает это:
jslatex`\unicode`;
// В старых версиях ECMAScript (ES2016 и раньше) выкинет исключение:
// SyntaxError: malformed Unicode character escape sequence

Поведение в ES2018
Теговые шаблоны должны позволять встраивать языки (например, DSLs или LaTeX), в которых широко используются многие другие экранирования. Предложение Редакция шаблонных литералов (уровень 4, одобренный к добавлению в стандарт ECMAScript 2018) устраняет синтаксические ограничения экранирования теговых шаблонов в ECMAScript.
Однако, некорректное экранирование символов по-прежнему нужно отображать в "приготовленном" отображении. Оно показывается в виде undefined в "приготовленном" массиве:
jsfunction latex(str) {
  return { cooked: str[0], raw: str.raw[0] };
}

latex`\unicode`;

// { cooked: undefined, raw: "\unicode" }

Заметьте, что ограничение на экранирование символов проявляется лишь в теговых шаблонах, и не проявляется в нетеговых шаблонных литералах:
jslet bad = `bad escape sequence: \unicode`;
СпецификацииSpecificationECMAScript® 2026 Language Specification # sec-template-literalsСовместимость с браузерамиСмотрите также
String
String.raw()
Лексическая грамматика
Подобные шаблонам строки в ES3-совместимом синтаксисе
ES6 в деталях: шаблонные строки
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 17 дек. 2024 г. by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\n模板字符串Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedback模板字面量是用反引号（`）分隔的字面量，允许多行字符串、带嵌入表达式的字符串插值和一种叫带标签的模板的特殊结构。
模板字面量有时被非正式地叫作模板字符串，因为它们最常被用作字符串插值（通过替换占位符来创建字符串）。然而，带标签的模板字面量可能不会产生字符串——它可以与自定义标签函数一起使用，来对模板字面量的不同部分执行任何操作。语法js`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tagFunction`string text ${expression} string text`
参数
string text

将成为模板字面量的一部分的字符串文本。几乎允许所有字符，包括换行符和其他空白字符。但是，除非使用了标签函数，否则无效的转义序列将导致语法错误。

expression

要插入当前位置的表达式，其值被转换为字符串或传递给 tagFunction。

tagFunction

如果指定，将使用模板字符串数组和替换表达式调用它，返回值将成为模板字面量的值。见带标签的模板。

描述模板字面量用反引号（`）括起来，而不是双引号（"）或单引号（'）。
除了普通字符串外，模板字面量还可以包含占位符——一种由美元符号和大括号分隔的嵌入式表达式：${expression}。字符串和占位符被传递给一个函数（要么是默认函数，要么是自定义函数）。默认函数（当未提供自定义函数时）只执行字符串插值来替换占位符，然后将这些部分拼接到一个字符串中。
若要提供自定义函数，需在模板字面量之前加上函数名（结果被称为带标签的模板）。此时，模板字面量被传递给你的标签函数，然后就可以在那里对模板文本的不同部分执行任何操作。
若要转义模板字面量中的反引号（`），需在反引号之前加一个反斜杠（\）。
js`\`` === "`"; // true

美元符号 $ 也可以被转义，来阻止插值。
js`\${1}` === "${1}"; // true
多行字符串在源码中插入的任何换行符都是模板字面量的一部分。
使用普通字符串，可以通过下面的方式得到多行字符串：
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
// string text line 2"

使用模板字面量，下面的代码同样可以做到：
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"
字符串插值如果没有模板字面量，当你想组合表达式的输出与字符串时，可以使用加法运算符 + 连接它们：
jsconst a = 5;
const b = 10;
console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");
// "Fifteen is 15 and
// not 20."

这可能很难阅读，尤其是当存在多个表达式时。
有了模板字面量，就可以通过使用占位符 ${expression} 嵌入待替换的表达式，从而避免串联运算符，并提高代码的可读性：
jsconst a = 5;
const b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
// "Fifteen is 15 and
// not 20."

注意，这两种语法有一点小区别：模板字面量直接将其表达式强制转换为字符串，而加法则会先强制转换为原语类型。更多相关信息，参见加法（+）运算符。嵌套模板在某些情况下，嵌套模板是具有可配置字符串的最简单的（也许还是更可读的）方法。在反引号分隔的模板中，允许在占位符 ${expression} 中使用内层的反引号。
例如，不用模板字面量的情况下，如果你想根据特定条件返回某个值，可以执行以下操作：
jslet classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

用模板字面量但不嵌套时，你可以这么做：
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

用嵌套模板字面量时，你可以这么做：
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
带标签的模板带标签的模板是模板字面量的一种更高级的形式，它允许你使用函数解析模板字面量。标签函数的第一个参数包含一个字符串数组，其余的参数与表达式相关。你可以用标签函数对这些参数执行任何操作，并返回被操作过的字符串（或者，也可返回完全不同的内容，见下面的示例）。用作标签的函数名没有限制。
jsconst person = "Mike";
const age = 28;

function myTag(strings, personExp, ageExp) {
  const str0 = strings[0]; // "That "
  const str1 = strings[1]; // " is a "
  const str2 = strings[2]; // "."

  const ageStr = ageExp > 99 ? "centenarian" : "youngster";

  // 我们甚至可以返回使用模板字面量构建的字符串
  return `${str0}${personExp}${str1}${ageStr}${str2}`;
}

const output = myTag`That ${person} is a ${age}.`;

console.log(output);
// That Mike is a youngster.

标签不必是普通的标识符，你可以使用任何优先级大于 16 的表达式，包括属性访问、函数调用、new 表达式，甚至其他带标签的模板字面量。
jsconsole.log`Hello`; // [ 'Hello' ]
console.log.bind(1, 2)`Hello`; // 2 [ 'Hello' ]
new Function("console.log(arguments)")`Hello`; // [Arguments] { '0': [ 'Hello' ] }

function recursive(strings, ...values) {
  console.log(strings, values);
  return recursive;
}
recursive`Hello``World`;
// [ 'Hello' ] []
// [ 'World' ] []

虽然语法从技术上允许这么做，但不带标签的模板字面量是字符串，并且在链式调用时会抛出 TypeError。
jsconsole.log(`Hello``World`); // TypeError: "Hello" is not a function

唯一的例外是可选链，这将抛出语法错误。
jsconsole.log?.`Hello`; // SyntaxError: Invalid tagged template on optional chain
console?.log`Hello`; // SyntaxError: Invalid tagged template on optional chain

请注意，这两个表达式仍然是可解析的。这意味着它们将不受自动分号补全的影响，其只会插入分号来修复无法解析的代码。
js// 仍是语法错误
const a = console?.log
`Hello`

标签函数甚至不需要返回字符串！
jsfunction template(strings, ...keys) {
  return (...values) => {
    const dict = values[values.length - 1] || {};
    const result = [strings[0]];
    keys.forEach((key, i) => {
      const value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

const t1Closure = template`${0}${1}${0}!`;
// const t1Closure = template(["","","","!"],0,1,0);
t1Closure("Y", "A"); // "YAY!"

const t2Closure = template`${0} ${"foo"}!`;
// const t2Closure = template([""," ","!"],0,"foo");
t2Closure("Hello", { foo: "World" }); // "Hello World!"

const t3Closure = template`I'm ${"name"}. I'm almost ${"age"} years old.`;
// const t3Closure = template(["I'm ", ". I'm almost ", " years old."], "name", "age");
t3Closure("foo", { name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."
t3Closure({ name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."

标签函数接收到的第一个参数是一个字符串数组。对于任何模板字面量，其长度等于替换次数（${…} 出现次数）加一，因此总是非空的。对于任何特定的带标签的模板字面量表达式，无论对字面量求值多少次，都将始终使用完全相同的字面量数组调用标签函数。
jsconst callHistory = [];

function tag(strings, ...values) {
  callHistory.push(strings);
  // Return a freshly made object
  return {};
}

function evaluateLiteral() {
  return tag`Hello, ${"world"}!`;
}

console.log(evaluateLiteral() === evaluateLiteral()); // false; each time `tag` is called, it returns a new object
console.log(callHistory[0] === callHistory[1]); // true; all evaluations of the same tagged literal would pass in the same strings array

这允许标签函数以其第一个参数作为标识来缓存结果。为了进一步确保数组值不变，第一个参数及其 raw 属性都会被冻结，因此你将无法改变它们。原始字符串在标签函数的第一个参数中，存在一个特殊的属性 raw ，我们可以通过它来访问模板字符串的原始字符串，而无需转义特殊字符。
jsfunction tag(strings) {
  console.log(strings.raw[0]);
}

tag`string text line 1 \n string text line 2`;
// logs "string text line 1 \n string text line 2" ,
// including the two characters '\' and 'n'

另外，使用 String.raw() 方法创建原始字符串和使用默认模板函数和字符串连接创建是一样的。
jslet str = String.raw`Hi\n${2+3}!`;
// "Hi\\n5!"

str.length;.
// 6

str.split('').join(',');.
// "H,i,\\,n,5,!"

如果字面量不包含任何转义序列，String.raw 函数就像一个“identity”标签。如果你想要一个始终像不带标签的字面量那样的实际标识标签，可以用自定义函数，将“cooked”（例如，经转义序列处理过的）字面量数组传递给 String.raw，将它们当成原始字符串。
jsconst identity = (strings, ...values) =>
  String.raw({ raw: strings }, ...values);
console.log(identity`Hi\n${2 + 3}!`);
// Hi
// 5!

这对于许多工具来说很有用，它们要对以特定名称为标签的字面量作特殊处理。
jsconst html = (strings, ...values) => String.raw({ raw: strings }, ...values);
// 一些格式化程序会将此字面量的内容格式化为 HTML
const doc = html`<!doctype html>
  <html lang="en-US">
    <head>
      <title>Hello</title>
    </head>
    <body>
      <h1>Hello world!</h1>
    </body>
  </html>`;
带标签的模板字面量及转义序列在普通模板字面量中，字符串字面量中的转义序列都是允许的，任何其他格式不正确的转义序列都是语法错误，包括：

\ 后跟 0 以外的任何十进制数字，或 \0 后跟一个十进制数字，例如 \9 和 \07（这是一种已弃用的语法）
\x 后跟两位以下十六进制数字，例如\xz
\u 后不跟 {，并且后跟四个以下十六进制数字，例如 \uz
\u{} 包含无效的 Unicode 码点——包含一个非十六进制数字，或者它的值大于 10FFFF，例如 \u{110000} 和 \u{z}


备注： \ 后面跟着其他字符，虽然它们可能没有用，因为没有转义，但它们不是语法错误。

然而，这对于带标签的模板来说是有问题的，除了“cooked”字面量外，这些模板还可以访问原始字面量（转义序列按原样保留）。带标签的模板应该允许嵌入语言（例如 DSL 或 LaTeX），在这些语言里其他转义序列是常见的。因此，从带标签的模板中删除了转义序列诸多格式的语法限制。
不过，非法转义序列在“cooked”当中仍然会体现出来。它们将以 undefined 元素的形式存在于“cooked”数组之中：
jsfunction latex(str) {
  return { cooked: str[0], raw: str.raw[0] };
}

latex`\unicode`;

// { cooked: undefined, raw: "\\unicode" }

值得注意的是，这一转义序列限制只对带标签的模板字面量移除，而不包括不带标签的模板字面量：
jsconst bad = `bad escape sequence: \unicode`;
规范SpecificationECMAScript® 2026 Language Specification # sec-template-literals浏览器兼容性参见
String
String.raw()
词法语法
ES3 中的类模板字符串
hacks.mozilla.org 上的《深度学习 ES6 之模板字面量》\n\n模板字符串Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedback模板字面量是用反引号（`）分隔的字面量，允许多行字符串、带嵌入表达式的字符串插值和一种叫带标签的模板的特殊结构。
模板字面量有时被非正式地叫作模板字符串，因为它们最常被用作字符串插值（通过替换占位符来创建字符串）。然而，带标签的模板字面量可能不会产生字符串——它可以与自定义标签函数一起使用，来对模板字面量的不同部分执行任何操作。语法js`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tagFunction`string text ${expression} string text`
参数
string text

将成为模板字面量的一部分的字符串文本。几乎允许所有字符，包括换行符和其他空白字符。但是，除非使用了标签函数，否则无效的转义序列将导致语法错误。

expression

要插入当前位置的表达式，其值被转换为字符串或传递给 tagFunction。

tagFunction

如果指定，将使用模板字符串数组和替换表达式调用它，返回值将成为模板字面量的值。见带标签的模板。

描述模板字面量用反引号（`）括起来，而不是双引号（"）或单引号（'）。
除了普通字符串外，模板字面量还可以包含占位符——一种由美元符号和大括号分隔的嵌入式表达式：${expression}。字符串和占位符被传递给一个函数（要么是默认函数，要么是自定义函数）。默认函数（当未提供自定义函数时）只执行字符串插值来替换占位符，然后将这些部分拼接到一个字符串中。
若要提供自定义函数，需在模板字面量之前加上函数名（结果被称为带标签的模板）。此时，模板字面量被传递给你的标签函数，然后就可以在那里对模板文本的不同部分执行任何操作。
若要转义模板字面量中的反引号（`），需在反引号之前加一个反斜杠（\）。
js`\`` === "`"; // true

美元符号 $ 也可以被转义，来阻止插值。
js`\${1}` === "${1}"; // true
多行字符串在源码中插入的任何换行符都是模板字面量的一部分。
使用普通字符串，可以通过下面的方式得到多行字符串：
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
// string text line 2"

使用模板字面量，下面的代码同样可以做到：
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"
字符串插值如果没有模板字面量，当你想组合表达式的输出与字符串时，可以使用加法运算符 + 连接它们：
jsconst a = 5;
const b = 10;
console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");
// "Fifteen is 15 and
// not 20."

这可能很难阅读，尤其是当存在多个表达式时。
有了模板字面量，就可以通过使用占位符 ${expression} 嵌入待替换的表达式，从而避免串联运算符，并提高代码的可读性：
jsconst a = 5;
const b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
// "Fifteen is 15 and
// not 20."

注意，这两种语法有一点小区别：模板字面量直接将其表达式强制转换为字符串，而加法则会先强制转换为原语类型。更多相关信息，参见加法（+）运算符。嵌套模板在某些情况下，嵌套模板是具有可配置字符串的最简单的（也许还是更可读的）方法。在反引号分隔的模板中，允许在占位符 ${expression} 中使用内层的反引号。
例如，不用模板字面量的情况下，如果你想根据特定条件返回某个值，可以执行以下操作：
jslet classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

用模板字面量但不嵌套时，你可以这么做：
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

用嵌套模板字面量时，你可以这么做：
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
带标签的模板带标签的模板是模板字面量的一种更高级的形式，它允许你使用函数解析模板字面量。标签函数的第一个参数包含一个字符串数组，其余的参数与表达式相关。你可以用标签函数对这些参数执行任何操作，并返回被操作过的字符串（或者，也可返回完全不同的内容，见下面的示例）。用作标签的函数名没有限制。
jsconst person = "Mike";
const age = 28;

function myTag(strings, personExp, ageExp) {
  const str0 = strings[0]; // "That "
  const str1 = strings[1]; // " is a "
  const str2 = strings[2]; // "."

  const ageStr = ageExp > 99 ? "centenarian" : "youngster";

  // 我们甚至可以返回使用模板字面量构建的字符串
  return `${str0}${personExp}${str1}${ageStr}${str2}`;
}

const output = myTag`That ${person} is a ${age}.`;

console.log(output);
// That Mike is a youngster.

标签不必是普通的标识符，你可以使用任何优先级大于 16 的表达式，包括属性访问、函数调用、new 表达式，甚至其他带标签的模板字面量。
jsconsole.log`Hello`; // [ 'Hello' ]
console.log.bind(1, 2)`Hello`; // 2 [ 'Hello' ]
new Function("console.log(arguments)")`Hello`; // [Arguments] { '0': [ 'Hello' ] }

function recursive(strings, ...values) {
  console.log(strings, values);
  return recursive;
}
recursive`Hello``World`;
// [ 'Hello' ] []
// [ 'World' ] []

虽然语法从技术上允许这么做，但不带标签的模板字面量是字符串，并且在链式调用时会抛出 TypeError。
jsconsole.log(`Hello``World`); // TypeError: "Hello" is not a function

唯一的例外是可选链，这将抛出语法错误。
jsconsole.log?.`Hello`; // SyntaxError: Invalid tagged template on optional chain
console?.log`Hello`; // SyntaxError: Invalid tagged template on optional chain

请注意，这两个表达式仍然是可解析的。这意味着它们将不受自动分号补全的影响，其只会插入分号来修复无法解析的代码。
js// 仍是语法错误
const a = console?.log
`Hello`

标签函数甚至不需要返回字符串！
jsfunction template(strings, ...keys) {
  return (...values) => {
    const dict = values[values.length - 1] || {};
    const result = [strings[0]];
    keys.forEach((key, i) => {
      const value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

const t1Closure = template`${0}${1}${0}!`;
// const t1Closure = template(["","","","!"],0,1,0);
t1Closure("Y", "A"); // "YAY!"

const t2Closure = template`${0} ${"foo"}!`;
// const t2Closure = template([""," ","!"],0,"foo");
t2Closure("Hello", { foo: "World" }); // "Hello World!"

const t3Closure = template`I'm ${"name"}. I'm almost ${"age"} years old.`;
// const t3Closure = template(["I'm ", ". I'm almost ", " years old."], "name", "age");
t3Closure("foo", { name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."
t3Closure({ name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."

标签函数接收到的第一个参数是一个字符串数组。对于任何模板字面量，其长度等于替换次数（${…} 出现次数）加一，因此总是非空的。对于任何特定的带标签的模板字面量表达式，无论对字面量求值多少次，都将始终使用完全相同的字面量数组调用标签函数。
jsconst callHistory = [];

function tag(strings, ...values) {
  callHistory.push(strings);
  // Return a freshly made object
  return {};
}

function evaluateLiteral() {
  return tag`Hello, ${"world"}!`;
}

console.log(evaluateLiteral() === evaluateLiteral()); // false; each time `tag` is called, it returns a new object
console.log(callHistory[0] === callHistory[1]); // true; all evaluations of the same tagged literal would pass in the same strings array

这允许标签函数以其第一个参数作为标识来缓存结果。为了进一步确保数组值不变，第一个参数及其 raw 属性都会被冻结，因此你将无法改变它们。原始字符串在标签函数的第一个参数中，存在一个特殊的属性 raw ，我们可以通过它来访问模板字符串的原始字符串，而无需转义特殊字符。
jsfunction tag(strings) {
  console.log(strings.raw[0]);
}

tag`string text line 1 \n string text line 2`;
// logs "string text line 1 \n string text line 2" ,
// including the two characters '\' and 'n'

另外，使用 String.raw() 方法创建原始字符串和使用默认模板函数和字符串连接创建是一样的。
jslet str = String.raw`Hi\n${2+3}!`;
// "Hi\\n5!"

str.length;.
// 6

str.split('').join(',');.
// "H,i,\\,n,5,!"

如果字面量不包含任何转义序列，String.raw 函数就像一个“identity”标签。如果你想要一个始终像不带标签的字面量那样的实际标识标签，可以用自定义函数，将“cooked”（例如，经转义序列处理过的）字面量数组传递给 String.raw，将它们当成原始字符串。
jsconst identity = (strings, ...values) =>
  String.raw({ raw: strings }, ...values);
console.log(identity`Hi\n${2 + 3}!`);
// Hi
// 5!

这对于许多工具来说很有用，它们要对以特定名称为标签的字面量作特殊处理。
jsconst html = (strings, ...values) => String.raw({ raw: strings }, ...values);
// 一些格式化程序会将此字面量的内容格式化为 HTML
const doc = html`<!doctype html>
  <html lang="en-US">
    <head>
      <title>Hello</title>
    </head>
    <body>
      <h1>Hello world!</h1>
    </body>
  </html>`;
带标签的模板字面量及转义序列在普通模板字面量中，字符串字面量中的转义序列都是允许的，任何其他格式不正确的转义序列都是语法错误，包括：

\ 后跟 0 以外的任何十进制数字，或 \0 后跟一个十进制数字，例如 \9 和 \07（这是一种已弃用的语法）
\x 后跟两位以下十六进制数字，例如\xz
\u 后不跟 {，并且后跟四个以下十六进制数字，例如 \uz
\u{} 包含无效的 Unicode 码点——包含一个非十六进制数字，或者它的值大于 10FFFF，例如 \u{110000} 和 \u{z}


备注： \ 后面跟着其他字符，虽然它们可能没有用，因为没有转义，但它们不是语法错误。

然而，这对于带标签的模板来说是有问题的，除了“cooked”字面量外，这些模板还可以访问原始字面量（转义序列按原样保留）。带标签的模板应该允许嵌入语言（例如 DSL 或 LaTeX），在这些语言里其他转义序列是常见的。因此，从带标签的模板中删除了转义序列诸多格式的语法限制。
不过，非法转义序列在“cooked”当中仍然会体现出来。它们将以 undefined 元素的形式存在于“cooked”数组之中：
jsfunction latex(str) {
  return { cooked: str[0], raw: str.raw[0] };
}

latex`\unicode`;

// { cooked: undefined, raw: "\\unicode" }

值得注意的是，这一转义序列限制只对带标签的模板字面量移除，而不包括不带标签的模板字面量：
jsconst bad = `bad escape sequence: \unicode`;
规范SpecificationECMAScript® 2026 Language Specification # sec-template-literals浏览器兼容性参见
String
String.raw()
词法语法
ES3 中的类模板字符串
hacks.mozilla.org 上的《深度学习 ES6 之模板字面量》
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2024年12月21日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n模板字符串Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedback模板字面量是用反引号（`）分隔的字面量，允许多行字符串、带嵌入表达式的字符串插值和一种叫带标签的模板的特殊结构。
模板字面量有时被非正式地叫作模板字符串，因为它们最常被用作字符串插值（通过替换占位符来创建字符串）。然而，带标签的模板字面量可能不会产生字符串——它可以与自定义标签函数一起使用，来对模板字面量的不同部分执行任何操作。语法js`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tagFunction`string text ${expression} string text`
参数
string text

将成为模板字面量的一部分的字符串文本。几乎允许所有字符，包括换行符和其他空白字符。但是，除非使用了标签函数，否则无效的转义序列将导致语法错误。

expression

要插入当前位置的表达式，其值被转换为字符串或传递给 tagFunction。

tagFunction

如果指定，将使用模板字符串数组和替换表达式调用它，返回值将成为模板字面量的值。见带标签的模板。

描述模板字面量用反引号（`）括起来，而不是双引号（"）或单引号（'）。
除了普通字符串外，模板字面量还可以包含占位符——一种由美元符号和大括号分隔的嵌入式表达式：${expression}。字符串和占位符被传递给一个函数（要么是默认函数，要么是自定义函数）。默认函数（当未提供自定义函数时）只执行字符串插值来替换占位符，然后将这些部分拼接到一个字符串中。
若要提供自定义函数，需在模板字面量之前加上函数名（结果被称为带标签的模板）。此时，模板字面量被传递给你的标签函数，然后就可以在那里对模板文本的不同部分执行任何操作。
若要转义模板字面量中的反引号（`），需在反引号之前加一个反斜杠（\）。
js`\`` === "`"; // true

美元符号 $ 也可以被转义，来阻止插值。
js`\${1}` === "${1}"; // true
多行字符串在源码中插入的任何换行符都是模板字面量的一部分。
使用普通字符串，可以通过下面的方式得到多行字符串：
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
// string text line 2"

使用模板字面量，下面的代码同样可以做到：
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"
字符串插值如果没有模板字面量，当你想组合表达式的输出与字符串时，可以使用加法运算符 + 连接它们：
jsconst a = 5;
const b = 10;
console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");
// "Fifteen is 15 and
// not 20."

这可能很难阅读，尤其是当存在多个表达式时。
有了模板字面量，就可以通过使用占位符 ${expression} 嵌入待替换的表达式，从而避免串联运算符，并提高代码的可读性：
jsconst a = 5;
const b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
// "Fifteen is 15 and
// not 20."

注意，这两种语法有一点小区别：模板字面量直接将其表达式强制转换为字符串，而加法则会先强制转换为原语类型。更多相关信息，参见加法（+）运算符。嵌套模板在某些情况下，嵌套模板是具有可配置字符串的最简单的（也许还是更可读的）方法。在反引号分隔的模板中，允许在占位符 ${expression} 中使用内层的反引号。
例如，不用模板字面量的情况下，如果你想根据特定条件返回某个值，可以执行以下操作：
jslet classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

用模板字面量但不嵌套时，你可以这么做：
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

用嵌套模板字面量时，你可以这么做：
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
带标签的模板带标签的模板是模板字面量的一种更高级的形式，它允许你使用函数解析模板字面量。标签函数的第一个参数包含一个字符串数组，其余的参数与表达式相关。你可以用标签函数对这些参数执行任何操作，并返回被操作过的字符串（或者，也可返回完全不同的内容，见下面的示例）。用作标签的函数名没有限制。
jsconst person = "Mike";
const age = 28;

function myTag(strings, personExp, ageExp) {
  const str0 = strings[0]; // "That "
  const str1 = strings[1]; // " is a "
  const str2 = strings[2]; // "."

  const ageStr = ageExp > 99 ? "centenarian" : "youngster";

  // 我们甚至可以返回使用模板字面量构建的字符串
  return `${str0}${personExp}${str1}${ageStr}${str2}`;
}

const output = myTag`That ${person} is a ${age}.`;

console.log(output);
// That Mike is a youngster.

标签不必是普通的标识符，你可以使用任何优先级大于 16 的表达式，包括属性访问、函数调用、new 表达式，甚至其他带标签的模板字面量。
jsconsole.log`Hello`; // [ 'Hello' ]
console.log.bind(1, 2)`Hello`; // 2 [ 'Hello' ]
new Function("console.log(arguments)")`Hello`; // [Arguments] { '0': [ 'Hello' ] }

function recursive(strings, ...values) {
  console.log(strings, values);
  return recursive;
}
recursive`Hello``World`;
// [ 'Hello' ] []
// [ 'World' ] []

虽然语法从技术上允许这么做，但不带标签的模板字面量是字符串，并且在链式调用时会抛出 TypeError。
jsconsole.log(`Hello``World`); // TypeError: "Hello" is not a function

唯一的例外是可选链，这将抛出语法错误。
jsconsole.log?.`Hello`; // SyntaxError: Invalid tagged template on optional chain
console?.log`Hello`; // SyntaxError: Invalid tagged template on optional chain

请注意，这两个表达式仍然是可解析的。这意味着它们将不受自动分号补全的影响，其只会插入分号来修复无法解析的代码。
js// 仍是语法错误
const a = console?.log
`Hello`

标签函数甚至不需要返回字符串！
jsfunction template(strings, ...keys) {
  return (...values) => {
    const dict = values[values.length - 1] || {};
    const result = [strings[0]];
    keys.forEach((key, i) => {
      const value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

const t1Closure = template`${0}${1}${0}!`;
// const t1Closure = template(["","","","!"],0,1,0);
t1Closure("Y", "A"); // "YAY!"

const t2Closure = template`${0} ${"foo"}!`;
// const t2Closure = template([""," ","!"],0,"foo");
t2Closure("Hello", { foo: "World" }); // "Hello World!"

const t3Closure = template`I'm ${"name"}. I'm almost ${"age"} years old.`;
// const t3Closure = template(["I'm ", ". I'm almost ", " years old."], "name", "age");
t3Closure("foo", { name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."
t3Closure({ name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."

标签函数接收到的第一个参数是一个字符串数组。对于任何模板字面量，其长度等于替换次数（${…} 出现次数）加一，因此总是非空的。对于任何特定的带标签的模板字面量表达式，无论对字面量求值多少次，都将始终使用完全相同的字面量数组调用标签函数。
jsconst callHistory = [];

function tag(strings, ...values) {
  callHistory.push(strings);
  // Return a freshly made object
  return {};
}

function evaluateLiteral() {
  return tag`Hello, ${"world"}!`;
}

console.log(evaluateLiteral() === evaluateLiteral()); // false; each time `tag` is called, it returns a new object
console.log(callHistory[0] === callHistory[1]); // true; all evaluations of the same tagged literal would pass in the same strings array

这允许标签函数以其第一个参数作为标识来缓存结果。为了进一步确保数组值不变，第一个参数及其 raw 属性都会被冻结，因此你将无法改变它们。原始字符串在标签函数的第一个参数中，存在一个特殊的属性 raw ，我们可以通过它来访问模板字符串的原始字符串，而无需转义特殊字符。
jsfunction tag(strings) {
  console.log(strings.raw[0]);
}

tag`string text line 1 \n string text line 2`;
// logs "string text line 1 \n string text line 2" ,
// including the two characters '\' and 'n'

另外，使用 String.raw() 方法创建原始字符串和使用默认模板函数和字符串连接创建是一样的。
jslet str = String.raw`Hi\n${2+3}!`;
// "Hi\\n5!"

str.length;.
// 6

str.split('').join(',');.
// "H,i,\\,n,5,!"

如果字面量不包含任何转义序列，String.raw 函数就像一个“identity”标签。如果你想要一个始终像不带标签的字面量那样的实际标识标签，可以用自定义函数，将“cooked”（例如，经转义序列处理过的）字面量数组传递给 String.raw，将它们当成原始字符串。
jsconst identity = (strings, ...values) =>
  String.raw({ raw: strings }, ...values);
console.log(identity`Hi\n${2 + 3}!`);
// Hi
// 5!

这对于许多工具来说很有用，它们要对以特定名称为标签的字面量作特殊处理。
jsconst html = (strings, ...values) => String.raw({ raw: strings }, ...values);
// 一些格式化程序会将此字面量的内容格式化为 HTML
const doc = html`<!doctype html>
  <html lang="en-US">
    <head>
      <title>Hello</title>
    </head>
    <body>
      <h1>Hello world!</h1>
    </body>
  </html>`;
带标签的模板字面量及转义序列在普通模板字面量中，字符串字面量中的转义序列都是允许的，任何其他格式不正确的转义序列都是语法错误，包括：

\ 后跟 0 以外的任何十进制数字，或 \0 后跟一个十进制数字，例如 \9 和 \07（这是一种已弃用的语法）
\x 后跟两位以下十六进制数字，例如\xz
\u 后不跟 {，并且后跟四个以下十六进制数字，例如 \uz
\u{} 包含无效的 Unicode 码点——包含一个非十六进制数字，或者它的值大于 10FFFF，例如 \u{110000} 和 \u{z}


备注： \ 后面跟着其他字符，虽然它们可能没有用，因为没有转义，但它们不是语法错误。

然而，这对于带标签的模板来说是有问题的，除了“cooked”字面量外，这些模板还可以访问原始字面量（转义序列按原样保留）。带标签的模板应该允许嵌入语言（例如 DSL 或 LaTeX），在这些语言里其他转义序列是常见的。因此，从带标签的模板中删除了转义序列诸多格式的语法限制。
不过，非法转义序列在“cooked”当中仍然会体现出来。它们将以 undefined 元素的形式存在于“cooked”数组之中：
jsfunction latex(str) {
  return { cooked: str[0], raw: str.raw[0] };
}

latex`\unicode`;

// { cooked: undefined, raw: "\\unicode" }

值得注意的是，这一转义序列限制只对带标签的模板字面量移除，而不包括不带标签的模板字面量：
jsconst bad = `bad escape sequence: \unicode`;
规范SpecificationECMAScript® 2026 Language Specification # sec-template-literals浏览器兼容性参见
String
String.raw()
词法语法
ES3 中的类模板字符串
hacks.mozilla.org 上的《深度学习 ES6 之模板字面量》
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2024年12月21日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\n樣板字面值Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedback樣板字面值（Template literals）是允許嵌入運算式的字串字面值（string literals）。你可以透過樣板字面值來使用多行字串及字串內插（string interpolation）功能。他們在 ES2015 規範的先行版本中被稱為「樣板字串（template strings）」。語法`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tag `string text ${expression} string text`
描述樣板字面值（Template literals）被反引號（back-tick，重音符號）：` ` 字元封閉，代替了雙或單引號。樣板字面值可以包含由錢字元及花括號所構成（${expression}）的佔位符（placeholders）。這個在佔位符中的運算式以及在它們之間的文字會被傳入一個函式。預設函式只是將這些部分組合成一個單一的字串。如果在樣板字面值前有一個運算式（tag here），則此樣板字串被稱為「標籤樣板字面值（tagged template literal）」。在此情況下，標籤運算式（通常是一個函式）會被呼叫來處理樣板字面值，讓你可以在函式回傳之前進行操作。要在樣板字面值中跳脫一個反引號，可以於反引號前加上一個反斜線（backslash）\ 。
js`\`` === "`"; // --> true
多行字串任何在樣板字面值中使用、插入的換行符號，都是樣板字面值的一部份。在普通的字串中，我們需要使用如下的語法以達到換行的效果：
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
// string text line 2"

但使用樣板字面值，你只需要撰寫如下所示的程式碼，就能達到同樣的效果：
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"
運算式內插要在普通的字串中內嵌運算式，我們必須使用如下語法：
jsvar a = 5;
var b = 10;
console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");
// "Fifteen is 15 and
// not 20."

現在有了樣板字面值，我們可以用一種更優雅的寫法，讓語法更具可讀性：
jsvar a = 5;
var b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
// "Fifteen is 15 and
// not 20."
巢狀樣板In certain times, nesting a template is the easiest and perhaps more readable way to have configurable strings. Within a backticked template it is simple to allow inner backticks simply by using them inside a placeholder ${ } within the template. For instance, if condition a is true: then return this templated literal.
In ES5:
jsvar classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

In ES2015 with template literals and without nesting:
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

In ES2015 with nested template literals:
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
標籤樣板字面值標籤樣板字面值是一種更高級的樣板字面值形式，允許你透過標籤函數操作樣板字面值的輸出。標籤函數的第一個參數是一字串陣列，其餘參數則是處理過的表達式。最終，你可以返回一個經處理後的字串，甚至是完全不一樣的東西（如下述第二個範例中）。標籤函數的名稱可以是任何你想要的。
jsvar person = "Mike";
var age = 28;

function myTag(strings, personExp, ageExp) {
  var str0 = strings[0]; // "that "
  var str1 = strings[1]; // " is a "

  // There is technically a string after
  // the final expression (in our example),
  // but it is empty (""), so disregard.
  // var str2 = strings[2];

  var ageStr;
  if (ageExp > 99) {
    ageStr = "centenarian";
  } else {
    ageStr = "youngster";
  }

  return str0 + personExp + str1 + ageStr;
}

var output = myTag`that ${person} is a ${age}`;

console.log(output);
// that Mike is a youngster

標籤函數不一定要回傳一個字串，如下列範例：
jsfunction template(strings, ...keys) {
  return function (...values) {
    var dict = values[values.length - 1] || {};
    var result = [strings[0]];
    keys.forEach(function (key, i) {
      var value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

var t1Closure = template`${0}${1}${0}!`;
t1Closure("Y", "A"); // "YAY!"
var t2Closure = template`${0} ${"foo"}!`;
t2Closure("Hello", { foo: "World" }); // "Hello World!"
原始字串標籤函數的第一個參數，帶有一個特殊的屬性「 raw 」，允許你獲取原始輸入的、未處理任何轉義序列的字串值。
jsfunction tag(strings) {
  console.log(strings.raw[0]);
}

tag`string text line 1 \n string text line 2`;
// logs "string text line 1 \n string text line 2" ,
// including the two characters '\' and 'n'

此外, 使用 String.raw() 方法建立的原始字串，也與預設的樣板函數和字串串接會建立的字串相同。
jsvar str = String.raw`Hi\n${2 + 3}!`;
// "Hi\n5!"

str.length;
// 6

str.split("").join(",");
// "H,i,\,n,5,!"
標籤樣板字面值和跳脫序列在 ES2016 的規範中，標籤樣板字面值遵守下列跳脫序列（escape sequences）規則：

萬國碼 (Unicode) 跳脫序列由 "\u" 作為開頭, 例： \u00A9
萬國碼位 (Unicode code point) 由 "\u{}" 作為開頭, 例： \u{2F804}
十六進位制碼由 "\x" 作為開頭, 例： \xA9
十進位制碼由 "\" 作為開頭, 例： \251

這表示像是下述的標籤樣板字面值是有問題的，因為根據 ECMAScript 規範，一個語法分析器會嘗試以萬國碼轉義序列去解析它，然後發現序列有誤：
jslatex`\unicode`;
// Throws in older ECMAScript versions (ES2016 and earlier)
// SyntaxError: malformed Unicode character escape sequence

Tagged template literals should allow the embedding of languages (for example DSLs, or LaTeX), where other escapes sequences are common. The ECMAScript proposal Template Literal Revision (stage 4, to be integrated in the ECMAScript 2018 standard) removes the syntax restriction of ECMAScript escape sequences from tagged template literals.
However, illegal escape sequence must still be represented in the "cooked" representation. They will show up as undefined element in the "cooked" array:
l be represented in the "cooked" representation. They will show up as undefined element in the "cooked" array:
jsfunction latex(str) {
  return { cooked: str[0], raw: str.raw[0] };
}

latex`\unicode`;

// { cooked: undefined, raw: "\\unicode" }

Note that the escape sequence restriction is only dropped from tagged template literals and not from untagged template literals:
jslet bad = `bad escape sequence: \unicode`;
規範SpecificationECMAScript® 2026 Language Specification # sec-template-literals瀏覽器相容性參見
String
String.raw()
Lexical grammar
Template-like strings in ES3 compatible syntax
"ES6 in Depth: Template strings" on hacks.mozilla.org\n\n樣板字面值Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedback樣板字面值（Template literals）是允許嵌入運算式的字串字面值（string literals）。你可以透過樣板字面值來使用多行字串及字串內插（string interpolation）功能。他們在 ES2015 規範的先行版本中被稱為「樣板字串（template strings）」。語法`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tag `string text ${expression} string text`
描述樣板字面值（Template literals）被反引號（back-tick，重音符號）：` ` 字元封閉，代替了雙或單引號。樣板字面值可以包含由錢字元及花括號所構成（${expression}）的佔位符（placeholders）。這個在佔位符中的運算式以及在它們之間的文字會被傳入一個函式。預設函式只是將這些部分組合成一個單一的字串。如果在樣板字面值前有一個運算式（tag here），則此樣板字串被稱為「標籤樣板字面值（tagged template literal）」。在此情況下，標籤運算式（通常是一個函式）會被呼叫來處理樣板字面值，讓你可以在函式回傳之前進行操作。要在樣板字面值中跳脫一個反引號，可以於反引號前加上一個反斜線（backslash）\ 。
js`\`` === "`"; // --> true
多行字串任何在樣板字面值中使用、插入的換行符號，都是樣板字面值的一部份。在普通的字串中，我們需要使用如下的語法以達到換行的效果：
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
// string text line 2"

但使用樣板字面值，你只需要撰寫如下所示的程式碼，就能達到同樣的效果：
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"
運算式內插要在普通的字串中內嵌運算式，我們必須使用如下語法：
jsvar a = 5;
var b = 10;
console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");
// "Fifteen is 15 and
// not 20."

現在有了樣板字面值，我們可以用一種更優雅的寫法，讓語法更具可讀性：
jsvar a = 5;
var b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
// "Fifteen is 15 and
// not 20."
巢狀樣板In certain times, nesting a template is the easiest and perhaps more readable way to have configurable strings. Within a backticked template it is simple to allow inner backticks simply by using them inside a placeholder ${ } within the template. For instance, if condition a is true: then return this templated literal.
In ES5:
jsvar classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

In ES2015 with template literals and without nesting:
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

In ES2015 with nested template literals:
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
標籤樣板字面值標籤樣板字面值是一種更高級的樣板字面值形式，允許你透過標籤函數操作樣板字面值的輸出。標籤函數的第一個參數是一字串陣列，其餘參數則是處理過的表達式。最終，你可以返回一個經處理後的字串，甚至是完全不一樣的東西（如下述第二個範例中）。標籤函數的名稱可以是任何你想要的。
jsvar person = "Mike";
var age = 28;

function myTag(strings, personExp, ageExp) {
  var str0 = strings[0]; // "that "
  var str1 = strings[1]; // " is a "

  // There is technically a string after
  // the final expression (in our example),
  // but it is empty (""), so disregard.
  // var str2 = strings[2];

  var ageStr;
  if (ageExp > 99) {
    ageStr = "centenarian";
  } else {
    ageStr = "youngster";
  }

  return str0 + personExp + str1 + ageStr;
}

var output = myTag`that ${person} is a ${age}`;

console.log(output);
// that Mike is a youngster

標籤函數不一定要回傳一個字串，如下列範例：
jsfunction template(strings, ...keys) {
  return function (...values) {
    var dict = values[values.length - 1] || {};
    var result = [strings[0]];
    keys.forEach(function (key, i) {
      var value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

var t1Closure = template`${0}${1}${0}!`;
t1Closure("Y", "A"); // "YAY!"
var t2Closure = template`${0} ${"foo"}!`;
t2Closure("Hello", { foo: "World" }); // "Hello World!"
原始字串標籤函數的第一個參數，帶有一個特殊的屬性「 raw 」，允許你獲取原始輸入的、未處理任何轉義序列的字串值。
jsfunction tag(strings) {
  console.log(strings.raw[0]);
}

tag`string text line 1 \n string text line 2`;
// logs "string text line 1 \n string text line 2" ,
// including the two characters '\' and 'n'

此外, 使用 String.raw() 方法建立的原始字串，也與預設的樣板函數和字串串接會建立的字串相同。
jsvar str = String.raw`Hi\n${2 + 3}!`;
// "Hi\n5!"

str.length;
// 6

str.split("").join(",");
// "H,i,\,n,5,!"
標籤樣板字面值和跳脫序列在 ES2016 的規範中，標籤樣板字面值遵守下列跳脫序列（escape sequences）規則：

萬國碼 (Unicode) 跳脫序列由 "\u" 作為開頭, 例： \u00A9
萬國碼位 (Unicode code point) 由 "\u{}" 作為開頭, 例： \u{2F804}
十六進位制碼由 "\x" 作為開頭, 例： \xA9
十進位制碼由 "\" 作為開頭, 例： \251

這表示像是下述的標籤樣板字面值是有問題的，因為根據 ECMAScript 規範，一個語法分析器會嘗試以萬國碼轉義序列去解析它，然後發現序列有誤：
jslatex`\unicode`;
// Throws in older ECMAScript versions (ES2016 and earlier)
// SyntaxError: malformed Unicode character escape sequence

Tagged template literals should allow the embedding of languages (for example DSLs, or LaTeX), where other escapes sequences are common. The ECMAScript proposal Template Literal Revision (stage 4, to be integrated in the ECMAScript 2018 standard) removes the syntax restriction of ECMAScript escape sequences from tagged template literals.
However, illegal escape sequence must still be represented in the "cooked" representation. They will show up as undefined element in the "cooked" array:
l be represented in the "cooked" representation. They will show up as undefined element in the "cooked" array:
jsfunction latex(str) {
  return { cooked: str[0], raw: str.raw[0] };
}

latex`\unicode`;

// { cooked: undefined, raw: "\\unicode" }

Note that the escape sequence restriction is only dropped from tagged template literals and not from untagged template literals:
jslet bad = `bad escape sequence: \unicode`;
規範SpecificationECMAScript® 2026 Language Specification # sec-template-literals瀏覽器相容性參見
String
String.raw()
Lexical grammar
Template-like strings in ES3 compatible syntax
"ES6 in Depth: Template strings" on hacks.mozilla.org
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2024年12月13日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n樣板字面值Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedback樣板字面值（Template literals）是允許嵌入運算式的字串字面值（string literals）。你可以透過樣板字面值來使用多行字串及字串內插（string interpolation）功能。他們在 ES2015 規範的先行版本中被稱為「樣板字串（template strings）」。語法`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tag `string text ${expression} string text`
描述樣板字面值（Template literals）被反引號（back-tick，重音符號）：` ` 字元封閉，代替了雙或單引號。樣板字面值可以包含由錢字元及花括號所構成（${expression}）的佔位符（placeholders）。這個在佔位符中的運算式以及在它們之間的文字會被傳入一個函式。預設函式只是將這些部分組合成一個單一的字串。如果在樣板字面值前有一個運算式（tag here），則此樣板字串被稱為「標籤樣板字面值（tagged template literal）」。在此情況下，標籤運算式（通常是一個函式）會被呼叫來處理樣板字面值，讓你可以在函式回傳之前進行操作。要在樣板字面值中跳脫一個反引號，可以於反引號前加上一個反斜線（backslash）\ 。
js`\`` === "`"; // --> true
多行字串任何在樣板字面值中使用、插入的換行符號，都是樣板字面值的一部份。在普通的字串中，我們需要使用如下的語法以達到換行的效果：
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
// string text line 2"

但使用樣板字面值，你只需要撰寫如下所示的程式碼，就能達到同樣的效果：
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"
運算式內插要在普通的字串中內嵌運算式，我們必須使用如下語法：
jsvar a = 5;
var b = 10;
console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");
// "Fifteen is 15 and
// not 20."

現在有了樣板字面值，我們可以用一種更優雅的寫法，讓語法更具可讀性：
jsvar a = 5;
var b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
// "Fifteen is 15 and
// not 20."
巢狀樣板In certain times, nesting a template is the easiest and perhaps more readable way to have configurable strings. Within a backticked template it is simple to allow inner backticks simply by using them inside a placeholder ${ } within the template. For instance, if condition a is true: then return this templated literal.
In ES5:
jsvar classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

In ES2015 with template literals and without nesting:
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

In ES2015 with nested template literals:
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
標籤樣板字面值標籤樣板字面值是一種更高級的樣板字面值形式，允許你透過標籤函數操作樣板字面值的輸出。標籤函數的第一個參數是一字串陣列，其餘參數則是處理過的表達式。最終，你可以返回一個經處理後的字串，甚至是完全不一樣的東西（如下述第二個範例中）。標籤函數的名稱可以是任何你想要的。
jsvar person = "Mike";
var age = 28;

function myTag(strings, personExp, ageExp) {
  var str0 = strings[0]; // "that "
  var str1 = strings[1]; // " is a "

  // There is technically a string after
  // the final expression (in our example),
  // but it is empty (""), so disregard.
  // var str2 = strings[2];

  var ageStr;
  if (ageExp > 99) {
    ageStr = "centenarian";
  } else {
    ageStr = "youngster";
  }

  return str0 + personExp + str1 + ageStr;
}

var output = myTag`that ${person} is a ${age}`;

console.log(output);
// that Mike is a youngster

標籤函數不一定要回傳一個字串，如下列範例：
jsfunction template(strings, ...keys) {
  return function (...values) {
    var dict = values[values.length - 1] || {};
    var result = [strings[0]];
    keys.forEach(function (key, i) {
      var value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

var t1Closure = template`${0}${1}${0}!`;
t1Closure("Y", "A"); // "YAY!"
var t2Closure = template`${0} ${"foo"}!`;
t2Closure("Hello", { foo: "World" }); // "Hello World!"
原始字串標籤函數的第一個參數，帶有一個特殊的屬性「 raw 」，允許你獲取原始輸入的、未處理任何轉義序列的字串值。
jsfunction tag(strings) {
  console.log(strings.raw[0]);
}

tag`string text line 1 \n string text line 2`;
// logs "string text line 1 \n string text line 2" ,
// including the two characters '\' and 'n'

此外, 使用 String.raw() 方法建立的原始字串，也與預設的樣板函數和字串串接會建立的字串相同。
jsvar str = String.raw`Hi\n${2 + 3}!`;
// "Hi\n5!"

str.length;
// 6

str.split("").join(",");
// "H,i,\,n,5,!"
標籤樣板字面值和跳脫序列在 ES2016 的規範中，標籤樣板字面值遵守下列跳脫序列（escape sequences）規則：

萬國碼 (Unicode) 跳脫序列由 "\u" 作為開頭, 例： \u00A9
萬國碼位 (Unicode code point) 由 "\u{}" 作為開頭, 例： \u{2F804}
十六進位制碼由 "\x" 作為開頭, 例： \xA9
十進位制碼由 "\" 作為開頭, 例： \251

這表示像是下述的標籤樣板字面值是有問題的，因為根據 ECMAScript 規範，一個語法分析器會嘗試以萬國碼轉義序列去解析它，然後發現序列有誤：
jslatex`\unicode`;
// Throws in older ECMAScript versions (ES2016 and earlier)
// SyntaxError: malformed Unicode character escape sequence

Tagged template literals should allow the embedding of languages (for example DSLs, or LaTeX), where other escapes sequences are common. The ECMAScript proposal Template Literal Revision (stage 4, to be integrated in the ECMAScript 2018 standard) removes the syntax restriction of ECMAScript escape sequences from tagged template literals.
However, illegal escape sequence must still be represented in the "cooked" representation. They will show up as undefined element in the "cooked" array:
l be represented in the "cooked" representation. They will show up as undefined element in the "cooked" array:
jsfunction latex(str) {
  return { cooked: str[0], raw: str.raw[0] };
}

latex`\unicode`;

// { cooked: undefined, raw: "\\unicode" }

Note that the escape sequence restriction is only dropped from tagged template literals and not from untagged template literals:
jslet bad = `bad escape sequence: \unicode`;
規範SpecificationECMAScript® 2026 Language Specification # sec-template-literals瀏覽器相容性參見
String
String.raw()
Lexical grammar
Template-like strings in ES3 compatible syntax
"ES6 in Depth: Template strings" on hacks.mozilla.org
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2024年12月13日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nTemplate literals (Template strings)Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackTemplate literals are literals delimited with backtick (`) characters, allowing for multi-line strings, string interpolation with embedded expressions, and special constructs called tagged templates.
Template literals are sometimes informally called template strings, because they are used most commonly for string interpolation (to create strings by doing substitution of placeholders). However, a tagged template literal may not result in a string; it can be used with a custom tag function to perform whatever operations you want on the different parts of the template literal.Syntaxjs`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tagFunction`string text ${expression} string text`
Parameters
string text

The string text that will become part of the template literal. Almost all characters are allowed literally, including line breaks and other whitespace characters. However, invalid escape sequences will cause a syntax error, unless a tag function is used.

expression

An expression to be inserted in the current position, whose value is converted to a string or passed to tagFunction.

tagFunction

If specified, it will be called with the template strings array and substitution expressions, and the return value becomes the value of the template literal. See tagged templates.

DescriptionTemplate literals are enclosed by backtick (`) characters instead of double or single quotes.
Along with having normal strings, template literals can also contain other parts called placeholders, which are embedded expressions delimited by a dollar sign and curly braces: ${expression}. The strings and placeholders get passed to a function — either a default function, or a function you supply. The default function (when you don't supply your own) just performs string interpolation to do substitution of the placeholders and then concatenate the parts into a single string.
To supply a function of your own, precede the template literal with a function name; the result is called a tagged template. In that case, the template literal is passed to your tag function, where you can then perform whatever operations you want on the different parts of the template literal.
To escape a backtick in a template literal, put a backslash (\) before the backtick.
js`\`` === "`"; // true

Dollar signs can be escaped as well to prevent interpolation.
js`\${1}` === "${1}"; // true
Multi-line stringsAny newline characters inserted in the source are part of the template literal.
Using normal strings, you would have to use the following syntax in order to get multi-line strings:
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
// string text line 2"

Using template literals, you can do the same with this:
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"

Like normal string literals, you can write a single-line string across multiple lines for source code readability, by escaping the newline with a backslash (\):
jsconsole.log(`string text line 1 \
string text line 2`);
// "string text line 1 string text line 2"
String interpolationWithout template literals, when you want to combine output from expressions with strings, you'd concatenate them using the addition operator +:
jsconst a = 5;
const b = 10;
console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");
// "Fifteen is 15 and
// not 20."

That can be hard to read – especially when you have multiple expressions.
With template literals, you can avoid the concatenation operator — and improve the readability of your code — by using placeholders of the form ${expression} to perform substitutions for embedded expressions:
jsconst a = 5;
const b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
// "Fifteen is 15 and
// not 20."

Note that there's a mild difference between the two syntaxes. Template literals coerce their expressions directly to strings, while addition coerces its operands to primitives first. For more information, see the reference page for the + operator.Nesting templatesIn certain cases, nesting a template is the easiest (and perhaps more readable) way to have configurable strings. Within a backtick-delimited template, it is simple to allow inner backticks by using them inside an ${expression} placeholder within the template.
For example, without template literals, if you wanted to return a certain value based on a particular condition, you could do something like the following:
jslet classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

With a template literal but without nesting, you could do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

With nesting of template literals, you can do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
Tagged templatesA more advanced form of template literals are tagged templates.
Tags allow you to parse template literals with a function. The first argument of a tag function contains an array of string values. The remaining arguments are related to the expressions.
The tag function can then perform whatever operations on these arguments you wish, and return the manipulated string. (Alternatively, it can return something completely different, as described in one of the following examples.)
The name of the function used for the tag can be whatever you want.
jsconst person = "Mike";
const age = 28;

function myTag(strings, personExp, ageExp) {
  const str0 = strings[0]; // "That "
  const str1 = strings[1]; // " is a "
  const str2 = strings[2]; // "."

  const ageStr = ageExp < 100 ? "youngster" : "centenarian";

  // We can even return a string built using a template literal
  return `${str0}${personExp}${str1}${ageStr}${str2}`;
}

const output = myTag`That ${person} is a ${age}.`;

console.log(output);
// That Mike is a youngster.

The tag does not have to be a plain identifier. You can use any expression with precedence greater than 16, which includes property access, function call, new expression, or even another tagged template literal.
jsconsole.log`Hello`; // [ 'Hello' ]
console.log.bind(1, 2)`Hello`; // 2 [ 'Hello' ]
new Function("console.log(arguments)")`Hello`; // [Arguments] { '0': [ 'Hello' ] }

function recursive(strings, ...values) {
  console.log(strings, values);
  return recursive;
}
recursive`Hello``World`;
// [ 'Hello' ] []
// [ 'World' ] []

While technically permitted by the syntax, untagged template literals are strings and will throw a TypeError when chained.
jsconsole.log(`Hello``World`); // TypeError: "Hello" is not a function

The only exception is optional chaining, which will throw a syntax error.
jsconsole.log?.`Hello`; // SyntaxError: Invalid tagged template on optional chain
console?.log`Hello`; // SyntaxError: Invalid tagged template on optional chain

Note that these two expressions are still parsable. This means they would not be subject to automatic semicolon insertion, which will only insert semicolons to fix code that's otherwise unparsable.
js// Still a syntax error
const a = console?.log
`Hello`

Tag functions don't even need to return a string!
jsfunction template(strings, ...keys) {
  return (...values) => {
    const dict = values[values.length - 1] || {};
    const result = [strings[0]];
    keys.forEach((key, i) => {
      const value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

const t1Closure = template`${0}${1}${0}!`;
// const t1Closure = template(["","","","!"],0,1,0);
t1Closure("Y", "A"); // "YAY!"

const t2Closure = template`${0} ${"foo"}!`;
// const t2Closure = template([""," ","!"],0,"foo");
t2Closure("Hello", { foo: "World" }); // "Hello World!"

const t3Closure = template`I'm ${"name"}. I'm almost ${"age"} years old.`;
// const t3Closure = template(["I'm ", ". I'm almost ", " years old."], "name", "age");
t3Closure("foo", { name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."
t3Closure({ name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."

The first argument received by the tag function is an array of strings. For any template literal, its length is equal to the number of substitutions (occurrences of ${…}) plus one, and is therefore always non-empty.
For any particular tagged template literal expression, the tag function will always be called with the exact same literal array, no matter how many times the literal is evaluated.
jsconst callHistory = [];

function tag(strings, ...values) {
  callHistory.push(strings);
  // Return a freshly made object
  return {};
}

function evaluateLiteral() {
  return tag`Hello, ${"world"}!`;
}

console.log(evaluateLiteral() === evaluateLiteral()); // false; each time `tag` is called, it returns a new object
console.log(callHistory[0] === callHistory[1]); // true; all evaluations of the same tagged literal would pass in the same strings array

This allows the tag to cache the result based on the identity of its first argument. To further ensure the array value's stability, the first argument and its raw property are both frozen, so you can't mutate them in any way.Raw stringsThe special raw property, available on the first argument to the tag function, allows you to access the raw strings as they were entered, without processing escape sequences.
jsfunction tag(strings) {
  console.log(strings.raw[0]);
}

tag`string text line 1 \n string text line 2`;
// Logs "string text line 1 \n string text line 2",
// including the two characters '\' and 'n'

In addition, the String.raw() method exists to create raw strings just like the default template function and string concatenation would create.
jsconst str = String.raw`Hi\n${2 + 3}!`;
// "Hi\\n5!"

str.length;
// 6

Array.from(str).join(",");
// "H,i,\\,n,5,!"

String.raw functions like an "identity" tag if the literal doesn't contain any escape sequences. In case you want an actual identity tag that always works as if the literal is untagged, you can make a custom function that passes the "cooked" (i.e., escape sequences are processed) literal array to String.raw, pretending they are raw strings.
jsconst identity = (strings, ...values) =>
  String.raw({ raw: strings }, ...values);
console.log(identity`Hi\n${2 + 3}!`);
// Hi
// 5!

This is useful for many tools which give special treatment to literals tagged by a particular name.
jsconst html = (strings, ...values) => String.raw({ raw: strings }, ...values);
// Some formatters will format this literal's content as HTML
const doc = html`<!doctype html>
  <html lang="en-US">
    <head>
      <title>Hello</title>
    </head>
    <body>
      <h1>Hello world!</h1>
    </body>
  </html>`;
Tagged templates and escape sequencesIn normal template literals, the escape sequences in string literals are all allowed. Any other non-well-formed escape sequence is a syntax error. This includes:

\ followed by any decimal digit other than 0, or \0 followed by a decimal digit; for example \9 and \07 (which is a deprecated syntax)
\x followed by fewer than two hex digits (including none); for example \xz
\u not followed by { and followed by fewer than four hex digits (including none); for example \uz
\u{} enclosing an invalid Unicode code point — it contains a non-hex digit, or its value is greater than 10FFFF; for example \u{110000} and \u{z}


Note: \ followed by other characters, while they may be useless since nothing is escaped, are not syntax errors.

However, this is problematic for tagged templates, which, in addition to the "cooked" literal, also have access to the raw literals (escape sequences are preserved as-is).
Tagged templates enable the embedding of arbitrary string content, where escape sequences may follow a different syntax. Consider for an example where we embed LaTeX source text in JavaScript via String.raw. We want to still be able to use LaTeX macros that start with u or x without following JavaScript syntax restrictions. Therefore, the syntax restriction of well-formed escape sequences is removed from tagged templates. The example below uses MathJax to render LaTeX in one element:
jsconst node = document.getElementById("formula");
MathJax.typesetClear([node]);
// Throws in older ECMAScript versions (ES2016 and earlier)
// SyntaxError: malformed Unicode character escape sequence
node.textContent = String.raw`$\underline{u}$`;
MathJax.typesetPromise([node]);

However, illegal escape sequences must still be represented in the "cooked" representation. They will show up as undefined element in the "cooked" array:
jsfunction log(str) {
  console.log("Cooked:", str[0]);
  console.log("Raw:", str.raw[0]);
}

log`\unicode`;
// Cooked: undefined
// Raw: \unicode

Note that the escape-sequence restriction is only dropped from tagged templates, but not from untagged template literals:
jsconst bad = `bad escape sequence: \unicode`;
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-template-literalsBrowser compatibilitySee also
Numbers and strings guide
String
String.raw()
Lexical grammar
ES6 in Depth: Template strings on hacks.mozilla.org (2015)\n\nTemplate literals (Template strings)Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackTemplate literals are literals delimited with backtick (`) characters, allowing for multi-line strings, string interpolation with embedded expressions, and special constructs called tagged templates.
Template literals are sometimes informally called template strings, because they are used most commonly for string interpolation (to create strings by doing substitution of placeholders). However, a tagged template literal may not result in a string; it can be used with a custom tag function to perform whatever operations you want on the different parts of the template literal.Syntaxjs`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tagFunction`string text ${expression} string text`
Parameters
string text

The string text that will become part of the template literal. Almost all characters are allowed literally, including line breaks and other whitespace characters. However, invalid escape sequences will cause a syntax error, unless a tag function is used.

expression

An expression to be inserted in the current position, whose value is converted to a string or passed to tagFunction.

tagFunction

If specified, it will be called with the template strings array and substitution expressions, and the return value becomes the value of the template literal. See tagged templates.

DescriptionTemplate literals are enclosed by backtick (`) characters instead of double or single quotes.
Along with having normal strings, template literals can also contain other parts called placeholders, which are embedded expressions delimited by a dollar sign and curly braces: ${expression}. The strings and placeholders get passed to a function — either a default function, or a function you supply. The default function (when you don't supply your own) just performs string interpolation to do substitution of the placeholders and then concatenate the parts into a single string.
To supply a function of your own, precede the template literal with a function name; the result is called a tagged template. In that case, the template literal is passed to your tag function, where you can then perform whatever operations you want on the different parts of the template literal.
To escape a backtick in a template literal, put a backslash (\) before the backtick.
js`\`` === "`"; // true

Dollar signs can be escaped as well to prevent interpolation.
js`\${1}` === "${1}"; // true
Multi-line stringsAny newline characters inserted in the source are part of the template literal.
Using normal strings, you would have to use the following syntax in order to get multi-line strings:
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
// string text line 2"

Using template literals, you can do the same with this:
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"

Like normal string literals, you can write a single-line string across multiple lines for source code readability, by escaping the newline with a backslash (\):
jsconsole.log(`string text line 1 \
string text line 2`);
// "string text line 1 string text line 2"
String interpolationWithout template literals, when you want to combine output from expressions with strings, you'd concatenate them using the addition operator +:
jsconst a = 5;
const b = 10;
console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");
// "Fifteen is 15 and
// not 20."

That can be hard to read – especially when you have multiple expressions.
With template literals, you can avoid the concatenation operator — and improve the readability of your code — by using placeholders of the form ${expression} to perform substitutions for embedded expressions:
jsconst a = 5;
const b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
// "Fifteen is 15 and
// not 20."

Note that there's a mild difference between the two syntaxes. Template literals coerce their expressions directly to strings, while addition coerces its operands to primitives first. For more information, see the reference page for the + operator.Nesting templatesIn certain cases, nesting a template is the easiest (and perhaps more readable) way to have configurable strings. Within a backtick-delimited template, it is simple to allow inner backticks by using them inside an ${expression} placeholder within the template.
For example, without template literals, if you wanted to return a certain value based on a particular condition, you could do something like the following:
jslet classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

With a template literal but without nesting, you could do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

With nesting of template literals, you can do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
Tagged templatesA more advanced form of template literals are tagged templates.
Tags allow you to parse template literals with a function. The first argument of a tag function contains an array of string values. The remaining arguments are related to the expressions.
The tag function can then perform whatever operations on these arguments you wish, and return the manipulated string. (Alternatively, it can return something completely different, as described in one of the following examples.)
The name of the function used for the tag can be whatever you want.
jsconst person = "Mike";
const age = 28;

function myTag(strings, personExp, ageExp) {
  const str0 = strings[0]; // "That "
  const str1 = strings[1]; // " is a "
  const str2 = strings[2]; // "."

  const ageStr = ageExp < 100 ? "youngster" : "centenarian";

  // We can even return a string built using a template literal
  return `${str0}${personExp}${str1}${ageStr}${str2}`;
}

const output = myTag`That ${person} is a ${age}.`;

console.log(output);
// That Mike is a youngster.

The tag does not have to be a plain identifier. You can use any expression with precedence greater than 16, which includes property access, function call, new expression, or even another tagged template literal.
jsconsole.log`Hello`; // [ 'Hello' ]
console.log.bind(1, 2)`Hello`; // 2 [ 'Hello' ]
new Function("console.log(arguments)")`Hello`; // [Arguments] { '0': [ 'Hello' ] }

function recursive(strings, ...values) {
  console.log(strings, values);
  return recursive;
}
recursive`Hello``World`;
// [ 'Hello' ] []
// [ 'World' ] []

While technically permitted by the syntax, untagged template literals are strings and will throw a TypeError when chained.
jsconsole.log(`Hello``World`); // TypeError: "Hello" is not a function

The only exception is optional chaining, which will throw a syntax error.
jsconsole.log?.`Hello`; // SyntaxError: Invalid tagged template on optional chain
console?.log`Hello`; // SyntaxError: Invalid tagged template on optional chain

Note that these two expressions are still parsable. This means they would not be subject to automatic semicolon insertion, which will only insert semicolons to fix code that's otherwise unparsable.
js// Still a syntax error
const a = console?.log
`Hello`

Tag functions don't even need to return a string!
jsfunction template(strings, ...keys) {
  return (...values) => {
    const dict = values[values.length - 1] || {};
    const result = [strings[0]];
    keys.forEach((key, i) => {
      const value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

const t1Closure = template`${0}${1}${0}!`;
// const t1Closure = template(["","","","!"],0,1,0);
t1Closure("Y", "A"); // "YAY!"

const t2Closure = template`${0} ${"foo"}!`;
// const t2Closure = template([""," ","!"],0,"foo");
t2Closure("Hello", { foo: "World" }); // "Hello World!"

const t3Closure = template`I'm ${"name"}. I'm almost ${"age"} years old.`;
// const t3Closure = template(["I'm ", ". I'm almost ", " years old."], "name", "age");
t3Closure("foo", { name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."
t3Closure({ name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."

The first argument received by the tag function is an array of strings. For any template literal, its length is equal to the number of substitutions (occurrences of ${…}) plus one, and is therefore always non-empty.
For any particular tagged template literal expression, the tag function will always be called with the exact same literal array, no matter how many times the literal is evaluated.
jsconst callHistory = [];

function tag(strings, ...values) {
  callHistory.push(strings);
  // Return a freshly made object
  return {};
}

function evaluateLiteral() {
  return tag`Hello, ${"world"}!`;
}

console.log(evaluateLiteral() === evaluateLiteral()); // false; each time `tag` is called, it returns a new object
console.log(callHistory[0] === callHistory[1]); // true; all evaluations of the same tagged literal would pass in the same strings array

This allows the tag to cache the result based on the identity of its first argument. To further ensure the array value's stability, the first argument and its raw property are both frozen, so you can't mutate them in any way.Raw stringsThe special raw property, available on the first argument to the tag function, allows you to access the raw strings as they were entered, without processing escape sequences.
jsfunction tag(strings) {
  console.log(strings.raw[0]);
}

tag`string text line 1 \n string text line 2`;
// Logs "string text line 1 \n string text line 2",
// including the two characters '\' and 'n'

In addition, the String.raw() method exists to create raw strings just like the default template function and string concatenation would create.
jsconst str = String.raw`Hi\n${2 + 3}!`;
// "Hi\\n5!"

str.length;
// 6

Array.from(str).join(",");
// "H,i,\\,n,5,!"

String.raw functions like an "identity" tag if the literal doesn't contain any escape sequences. In case you want an actual identity tag that always works as if the literal is untagged, you can make a custom function that passes the "cooked" (i.e., escape sequences are processed) literal array to String.raw, pretending they are raw strings.
jsconst identity = (strings, ...values) =>
  String.raw({ raw: strings }, ...values);
console.log(identity`Hi\n${2 + 3}!`);
// Hi
// 5!

This is useful for many tools which give special treatment to literals tagged by a particular name.
jsconst html = (strings, ...values) => String.raw({ raw: strings }, ...values);
// Some formatters will format this literal's content as HTML
const doc = html`<!doctype html>
  <html lang="en-US">
    <head>
      <title>Hello</title>
    </head>
    <body>
      <h1>Hello world!</h1>
    </body>
  </html>`;
Tagged templates and escape sequencesIn normal template literals, the escape sequences in string literals are all allowed. Any other non-well-formed escape sequence is a syntax error. This includes:

\ followed by any decimal digit other than 0, or \0 followed by a decimal digit; for example \9 and \07 (which is a deprecated syntax)
\x followed by fewer than two hex digits (including none); for example \xz
\u not followed by { and followed by fewer than four hex digits (including none); for example \uz
\u{} enclosing an invalid Unicode code point — it contains a non-hex digit, or its value is greater than 10FFFF; for example \u{110000} and \u{z}


Note: \ followed by other characters, while they may be useless since nothing is escaped, are not syntax errors.

However, this is problematic for tagged templates, which, in addition to the "cooked" literal, also have access to the raw literals (escape sequences are preserved as-is).
Tagged templates enable the embedding of arbitrary string content, where escape sequences may follow a different syntax. Consider for an example where we embed LaTeX source text in JavaScript via String.raw. We want to still be able to use LaTeX macros that start with u or x without following JavaScript syntax restrictions. Therefore, the syntax restriction of well-formed escape sequences is removed from tagged templates. The example below uses MathJax to render LaTeX in one element:
jsconst node = document.getElementById("formula");
MathJax.typesetClear([node]);
// Throws in older ECMAScript versions (ES2016 and earlier)
// SyntaxError: malformed Unicode character escape sequence
node.textContent = String.raw`$\underline{u}$`;
MathJax.typesetPromise([node]);

However, illegal escape sequences must still be represented in the "cooked" representation. They will show up as undefined element in the "cooked" array:
jsfunction log(str) {
  console.log("Cooked:", str[0]);
  console.log("Raw:", str.raw[0]);
}

log`\unicode`;
// Cooked: undefined
// Raw: \unicode

Note that the escape-sequence restriction is only dropped from tagged templates, but not from untagged template literals:
jsconst bad = `bad escape sequence: \unicode`;
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-template-literalsBrowser compatibilitySee also
Numbers and strings guide
String
String.raw()
Lexical grammar
ES6 in Depth: Template strings on hacks.mozilla.org (2015)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nTemplate literals (Template strings)Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackTemplate literals are literals delimited with backtick (`) characters, allowing for multi-line strings, string interpolation with embedded expressions, and special constructs called tagged templates.
Template literals are sometimes informally called template strings, because they are used most commonly for string interpolation (to create strings by doing substitution of placeholders). However, a tagged template literal may not result in a string; it can be used with a custom tag function to perform whatever operations you want on the different parts of the template literal.Syntaxjs`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tagFunction`string text ${expression} string text`
Parameters
string text

The string text that will become part of the template literal. Almost all characters are allowed literally, including line breaks and other whitespace characters. However, invalid escape sequences will cause a syntax error, unless a tag function is used.

expression

An expression to be inserted in the current position, whose value is converted to a string or passed to tagFunction.

tagFunction

If specified, it will be called with the template strings array and substitution expressions, and the return value becomes the value of the template literal. See tagged templates.

DescriptionTemplate literals are enclosed by backtick (`) characters instead of double or single quotes.
Along with having normal strings, template literals can also contain other parts called placeholders, which are embedded expressions delimited by a dollar sign and curly braces: ${expression}. The strings and placeholders get passed to a function — either a default function, or a function you supply. The default function (when you don't supply your own) just performs string interpolation to do substitution of the placeholders and then concatenate the parts into a single string.
To supply a function of your own, precede the template literal with a function name; the result is called a tagged template. In that case, the template literal is passed to your tag function, where you can then perform whatever operations you want on the different parts of the template literal.
To escape a backtick in a template literal, put a backslash (\) before the backtick.
js`\`` === "`"; // true

Dollar signs can be escaped as well to prevent interpolation.
js`\${1}` === "${1}"; // true
Multi-line stringsAny newline characters inserted in the source are part of the template literal.
Using normal strings, you would have to use the following syntax in order to get multi-line strings:
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
// string text line 2"

Using template literals, you can do the same with this:
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"

Like normal string literals, you can write a single-line string across multiple lines for source code readability, by escaping the newline with a backslash (\):
jsconsole.log(`string text line 1 \
string text line 2`);
// "string text line 1 string text line 2"
String interpolationWithout template literals, when you want to combine output from expressions with strings, you'd concatenate them using the addition operator +:
jsconst a = 5;
const b = 10;
console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");
// "Fifteen is 15 and
// not 20."

That can be hard to read – especially when you have multiple expressions.
With template literals, you can avoid the concatenation operator — and improve the readability of your code — by using placeholders of the form ${expression} to perform substitutions for embedded expressions:
jsconst a = 5;
const b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
// "Fifteen is 15 and
// not 20."

Note that there's a mild difference between the two syntaxes. Template literals coerce their expressions directly to strings, while addition coerces its operands to primitives first. For more information, see the reference page for the + operator.Nesting templatesIn certain cases, nesting a template is the easiest (and perhaps more readable) way to have configurable strings. Within a backtick-delimited template, it is simple to allow inner backticks by using them inside an ${expression} placeholder within the template.
For example, without template literals, if you wanted to return a certain value based on a particular condition, you could do something like the following:
jslet classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

With a template literal but without nesting, you could do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

With nesting of template literals, you can do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
Tagged templatesA more advanced form of template literals are tagged templates.
Tags allow you to parse template literals with a function. The first argument of a tag function contains an array of string values. The remaining arguments are related to the expressions.
The tag function can then perform whatever operations on these arguments you wish, and return the manipulated string. (Alternatively, it can return something completely different, as described in one of the following examples.)
The name of the function used for the tag can be whatever you want.
jsconst person = "Mike";
const age = 28;

function myTag(strings, personExp, ageExp) {
  const str0 = strings[0]; // "That "
  const str1 = strings[1]; // " is a "
  const str2 = strings[2]; // "."

  const ageStr = ageExp < 100 ? "youngster" : "centenarian";

  // We can even return a string built using a template literal
  return `${str0}${personExp}${str1}${ageStr}${str2}`;
}

const output = myTag`That ${person} is a ${age}.`;

console.log(output);
// That Mike is a youngster.

The tag does not have to be a plain identifier. You can use any expression with precedence greater than 16, which includes property access, function call, new expression, or even another tagged template literal.
jsconsole.log`Hello`; // [ 'Hello' ]
console.log.bind(1, 2)`Hello`; // 2 [ 'Hello' ]
new Function("console.log(arguments)")`Hello`; // [Arguments] { '0': [ 'Hello' ] }

function recursive(strings, ...values) {
  console.log(strings, values);
  return recursive;
}
recursive`Hello``World`;
// [ 'Hello' ] []
// [ 'World' ] []

While technically permitted by the syntax, untagged template literals are strings and will throw a TypeError when chained.
jsconsole.log(`Hello``World`); // TypeError: "Hello" is not a function

The only exception is optional chaining, which will throw a syntax error.
jsconsole.log?.`Hello`; // SyntaxError: Invalid tagged template on optional chain
console?.log`Hello`; // SyntaxError: Invalid tagged template on optional chain

Note that these two expressions are still parsable. This means they would not be subject to automatic semicolon insertion, which will only insert semicolons to fix code that's otherwise unparsable.
js// Still a syntax error
const a = console?.log
`Hello`

Tag functions don't even need to return a string!
jsfunction template(strings, ...keys) {
  return (...values) => {
    const dict = values[values.length - 1] || {};
    const result = [strings[0]];
    keys.forEach((key, i) => {
      const value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

const t1Closure = template`${0}${1}${0}!`;
// const t1Closure = template(["","","","!"],0,1,0);
t1Closure("Y", "A"); // "YAY!"

const t2Closure = template`${0} ${"foo"}!`;
// const t2Closure = template([""," ","!"],0,"foo");
t2Closure("Hello", { foo: "World" }); // "Hello World!"

const t3Closure = template`I'm ${"name"}. I'm almost ${"age"} years old.`;
// const t3Closure = template(["I'm ", ". I'm almost ", " years old."], "name", "age");
t3Closure("foo", { name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."
t3Closure({ name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."

The first argument received by the tag function is an array of strings. For any template literal, its length is equal to the number of substitutions (occurrences of ${…}) plus one, and is therefore always non-empty.
For any particular tagged template literal expression, the tag function will always be called with the exact same literal array, no matter how many times the literal is evaluated.
jsconst callHistory = [];

function tag(strings, ...values) {
  callHistory.push(strings);
  // Return a freshly made object
  return {};
}

function evaluateLiteral() {
  return tag`Hello, ${"world"}!`;
}

console.log(evaluateLiteral() === evaluateLiteral()); // false; each time `tag` is called, it returns a new object
console.log(callHistory[0] === callHistory[1]); // true; all evaluations of the same tagged literal would pass in the same strings array

This allows the tag to cache the result based on the identity of its first argument. To further ensure the array value's stability, the first argument and its raw property are both frozen, so you can't mutate them in any way.Raw stringsThe special raw property, available on the first argument to the tag function, allows you to access the raw strings as they were entered, without processing escape sequences.
jsfunction tag(strings) {
  console.log(strings.raw[0]);
}

tag`string text line 1 \n string text line 2`;
// Logs "string text line 1 \n string text line 2",
// including the two characters '\' and 'n'

In addition, the String.raw() method exists to create raw strings just like the default template function and string concatenation would create.
jsconst str = String.raw`Hi\n${2 + 3}!`;
// "Hi\\n5!"

str.length;
// 6

Array.from(str).join(",");
// "H,i,\\,n,5,!"

String.raw functions like an "identity" tag if the literal doesn't contain any escape sequences. In case you want an actual identity tag that always works as if the literal is untagged, you can make a custom function that passes the "cooked" (i.e., escape sequences are processed) literal array to String.raw, pretending they are raw strings.
jsconst identity = (strings, ...values) =>
  String.raw({ raw: strings }, ...values);
console.log(identity`Hi\n${2 + 3}!`);
// Hi
// 5!

This is useful for many tools which give special treatment to literals tagged by a particular name.
jsconst html = (strings, ...values) => String.raw({ raw: strings }, ...values);
// Some formatters will format this literal's content as HTML
const doc = html`<!doctype html>
  <html lang="en-US">
    <head>
      <title>Hello</title>
    </head>
    <body>
      <h1>Hello world!</h1>
    </body>
  </html>`;
Tagged templates and escape sequencesIn normal template literals, the escape sequences in string literals are all allowed. Any other non-well-formed escape sequence is a syntax error. This includes:

\ followed by any decimal digit other than 0, or \0 followed by a decimal digit; for example \9 and \07 (which is a deprecated syntax)
\x followed by fewer than two hex digits (including none); for example \xz
\u not followed by { and followed by fewer than four hex digits (including none); for example \uz
\u{} enclosing an invalid Unicode code point — it contains a non-hex digit, or its value is greater than 10FFFF; for example \u{110000} and \u{z}


Note: \ followed by other characters, while they may be useless since nothing is escaped, are not syntax errors.

However, this is problematic for tagged templates, which, in addition to the "cooked" literal, also have access to the raw literals (escape sequences are preserved as-is).
Tagged templates enable the embedding of arbitrary string content, where escape sequences may follow a different syntax. Consider for an example where we embed LaTeX source text in JavaScript via String.raw. We want to still be able to use LaTeX macros that start with u or x without following JavaScript syntax restrictions. Therefore, the syntax restriction of well-formed escape sequences is removed from tagged templates. The example below uses MathJax to render LaTeX in one element:
jsconst node = document.getElementById("formula");
MathJax.typesetClear([node]);
// Throws in older ECMAScript versions (ES2016 and earlier)
// SyntaxError: malformed Unicode character escape sequence
node.textContent = String.raw`$\underline{u}$`;
MathJax.typesetPromise([node]);

However, illegal escape sequences must still be represented in the "cooked" representation. They will show up as undefined element in the "cooked" array:
jsfunction log(str) {
  console.log("Cooked:", str[0]);
  console.log("Raw:", str.raw[0]);
}

log`\unicode`;
// Cooked: undefined
// Raw: \unicode

Note that the escape-sequence restriction is only dropped from tagged templates, but not from untagged template literals:
jsconst bad = `bad escape sequence: \unicode`;
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-template-literalsBrowser compatibilitySee also
Numbers and strings guide
String
String.raw()
Lexical grammar
ES6 in Depth: Template strings on hacks.mozilla.org (2015)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nTemplate literals (Template strings)Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackTemplate literals are literals delimited with backtick (`) characters, allowing for multi-line strings, string interpolation with embedded expressions, and special constructs called tagged templates.
Template literals are sometimes informally called template strings, because they are used most commonly for string interpolation (to create strings by doing substitution of placeholders). However, a tagged template literal may not result in a string; it can be used with a custom tag function to perform whatever operations you want on the different parts of the template literal.Syntaxjs`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tagFunction`string text ${expression} string text`
Parameters
string text

The string text that will become part of the template literal. Almost all characters are allowed literally, including line breaks and other whitespace characters. However, invalid escape sequences will cause a syntax error, unless a tag function is used.

expression

An expression to be inserted in the current position, whose value is converted to a string or passed to tagFunction.

tagFunction

If specified, it will be called with the template strings array and substitution expressions, and the return value becomes the value of the template literal. See tagged templates.

DescriptionTemplate literals are enclosed by backtick (`) characters instead of double or single quotes.
Along with having normal strings, template literals can also contain other parts called placeholders, which are embedded expressions delimited by a dollar sign and curly braces: ${expression}. The strings and placeholders get passed to a function — either a default function, or a function you supply. The default function (when you don't supply your own) just performs string interpolation to do substitution of the placeholders and then concatenate the parts into a single string.
To supply a function of your own, precede the template literal with a function name; the result is called a tagged template. In that case, the template literal is passed to your tag function, where you can then perform whatever operations you want on the different parts of the template literal.
To escape a backtick in a template literal, put a backslash (\) before the backtick.
js`\`` === "`"; // true

Dollar signs can be escaped as well to prevent interpolation.
js`\${1}` === "${1}"; // true
Multi-line stringsAny newline characters inserted in the source are part of the template literal.
Using normal strings, you would have to use the following syntax in order to get multi-line strings:
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
// string text line 2"

Using template literals, you can do the same with this:
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"

Like normal string literals, you can write a single-line string across multiple lines for source code readability, by escaping the newline with a backslash (\):
jsconsole.log(`string text line 1 \
string text line 2`);
// "string text line 1 string text line 2"
String interpolationWithout template literals, when you want to combine output from expressions with strings, you'd concatenate them using the addition operator +:
jsconst a = 5;
const b = 10;
console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");
// "Fifteen is 15 and
// not 20."

That can be hard to read – especially when you have multiple expressions.
With template literals, you can avoid the concatenation operator — and improve the readability of your code — by using placeholders of the form ${expression} to perform substitutions for embedded expressions:
jsconst a = 5;
const b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
// "Fifteen is 15 and
// not 20."

Note that there's a mild difference between the two syntaxes. Template literals coerce their expressions directly to strings, while addition coerces its operands to primitives first. For more information, see the reference page for the + operator.Nesting templatesIn certain cases, nesting a template is the easiest (and perhaps more readable) way to have configurable strings. Within a backtick-delimited template, it is simple to allow inner backticks by using them inside an ${expression} placeholder within the template.
For example, without template literals, if you wanted to return a certain value based on a particular condition, you could do something like the following:
jslet classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

With a template literal but without nesting, you could do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

With nesting of template literals, you can do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
Tagged templatesA more advanced form of template literals are tagged templates.
Tags allow you to parse template literals with a function. The first argument of a tag function contains an array of string values. The remaining arguments are related to the expressions.
The tag function can then perform whatever operations on these arguments you wish, and return the manipulated string. (Alternatively, it can return something completely different, as described in one of the following examples.)
The name of the function used for the tag can be whatever you want.
jsconst person = "Mike";
const age = 28;

function myTag(strings, personExp, ageExp) {
  const str0 = strings[0]; // "That "
  const str1 = strings[1]; // " is a "
  const str2 = strings[2]; // "."

  const ageStr = ageExp < 100 ? "youngster" : "centenarian";

  // We can even return a string built using a template literal
  return `${str0}${personExp}${str1}${ageStr}${str2}`;
}

const output = myTag`That ${person} is a ${age}.`;

console.log(output);
// That Mike is a youngster.

The tag does not have to be a plain identifier. You can use any expression with precedence greater than 16, which includes property access, function call, new expression, or even another tagged template literal.
jsconsole.log`Hello`; // [ 'Hello' ]
console.log.bind(1, 2)`Hello`; // 2 [ 'Hello' ]
new Function("console.log(arguments)")`Hello`; // [Arguments] { '0': [ 'Hello' ] }

function recursive(strings, ...values) {
  console.log(strings, values);
  return recursive;
}
recursive`Hello``World`;
// [ 'Hello' ] []
// [ 'World' ] []

While technically permitted by the syntax, untagged template literals are strings and will throw a TypeError when chained.
jsconsole.log(`Hello``World`); // TypeError: "Hello" is not a function

The only exception is optional chaining, which will throw a syntax error.
jsconsole.log?.`Hello`; // SyntaxError: Invalid tagged template on optional chain
console?.log`Hello`; // SyntaxError: Invalid tagged template on optional chain

Note that these two expressions are still parsable. This means they would not be subject to automatic semicolon insertion, which will only insert semicolons to fix code that's otherwise unparsable.
js// Still a syntax error
const a = console?.log
`Hello`

Tag functions don't even need to return a string!
jsfunction template(strings, ...keys) {
  return (...values) => {
    const dict = values[values.length - 1] || {};
    const result = [strings[0]];
    keys.forEach((key, i) => {
      const value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

const t1Closure = template`${0}${1}${0}!`;
// const t1Closure = template(["","","","!"],0,1,0);
t1Closure("Y", "A"); // "YAY!"

const t2Closure = template`${0} ${"foo"}!`;
// const t2Closure = template([""," ","!"],0,"foo");
t2Closure("Hello", { foo: "World" }); // "Hello World!"

const t3Closure = template`I'm ${"name"}. I'm almost ${"age"} years old.`;
// const t3Closure = template(["I'm ", ". I'm almost ", " years old."], "name", "age");
t3Closure("foo", { name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."
t3Closure({ name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."

The first argument received by the tag function is an array of strings. For any template literal, its length is equal to the number of substitutions (occurrences of ${…}) plus one, and is therefore always non-empty.
For any particular tagged template literal expression, the tag function will always be called with the exact same literal array, no matter how many times the literal is evaluated.
jsconst callHistory = [];

function tag(strings, ...values) {
  callHistory.push(strings);
  // Return a freshly made object
  return {};
}

function evaluateLiteral() {
  return tag`Hello, ${"world"}!`;
}

console.log(evaluateLiteral() === evaluateLiteral()); // false; each time `tag` is called, it returns a new object
console.log(callHistory[0] === callHistory[1]); // true; all evaluations of the same tagged literal would pass in the same strings array

This allows the tag to cache the result based on the identity of its first argument. To further ensure the array value's stability, the first argument and its raw property are both frozen, so you can't mutate them in any way.Raw stringsThe special raw property, available on the first argument to the tag function, allows you to access the raw strings as they were entered, without processing escape sequences.
jsfunction tag(strings) {
  console.log(strings.raw[0]);
}

tag`string text line 1 \n string text line 2`;
// Logs "string text line 1 \n string text line 2",
// including the two characters '\' and 'n'

In addition, the String.raw() method exists to create raw strings just like the default template function and string concatenation would create.
jsconst str = String.raw`Hi\n${2 + 3}!`;
// "Hi\\n5!"

str.length;
// 6

Array.from(str).join(",");
// "H,i,\\,n,5,!"

String.raw functions like an "identity" tag if the literal doesn't contain any escape sequences. In case you want an actual identity tag that always works as if the literal is untagged, you can make a custom function that passes the "cooked" (i.e., escape sequences are processed) literal array to String.raw, pretending they are raw strings.
jsconst identity = (strings, ...values) =>
  String.raw({ raw: strings }, ...values);
console.log(identity`Hi\n${2 + 3}!`);
// Hi
// 5!

This is useful for many tools which give special treatment to literals tagged by a particular name.
jsconst html = (strings, ...values) => String.raw({ raw: strings }, ...values);
// Some formatters will format this literal's content as HTML
const doc = html`<!doctype html>
  <html lang="en-US">
    <head>
      <title>Hello</title>
    </head>
    <body>
      <h1>Hello world!</h1>
    </body>
  </html>`;
Tagged templates and escape sequencesIn normal template literals, the escape sequences in string literals are all allowed. Any other non-well-formed escape sequence is a syntax error. This includes:

\ followed by any decimal digit other than 0, or \0 followed by a decimal digit; for example \9 and \07 (which is a deprecated syntax)
\x followed by fewer than two hex digits (including none); for example \xz
\u not followed by { and followed by fewer than four hex digits (including none); for example \uz
\u{} enclosing an invalid Unicode code point — it contains a non-hex digit, or its value is greater than 10FFFF; for example \u{110000} and \u{z}


Note: \ followed by other characters, while they may be useless since nothing is escaped, are not syntax errors.

However, this is problematic for tagged templates, which, in addition to the "cooked" literal, also have access to the raw literals (escape sequences are preserved as-is).
Tagged templates enable the embedding of arbitrary string content, where escape sequences may follow a different syntax. Consider for an example where we embed LaTeX source text in JavaScript via String.raw. We want to still be able to use LaTeX macros that start with u or x without following JavaScript syntax restrictions. Therefore, the syntax restriction of well-formed escape sequences is removed from tagged templates. The example below uses MathJax to render LaTeX in one element:
jsconst node = document.getElementById("formula");
MathJax.typesetClear([node]);
// Throws in older ECMAScript versions (ES2016 and earlier)
// SyntaxError: malformed Unicode character escape sequence
node.textContent = String.raw`$\underline{u}$`;
MathJax.typesetPromise([node]);

However, illegal escape sequences must still be represented in the "cooked" representation. They will show up as undefined element in the "cooked" array:
jsfunction log(str) {
  console.log("Cooked:", str[0]);
  console.log("Raw:", str.raw[0]);
}

log`\unicode`;
// Cooked: undefined
// Raw: \unicode

Note that the escape-sequence restriction is only dropped from tagged templates, but not from untagged template literals:
jsconst bad = `bad escape sequence: \unicode`;
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-template-literalsBrowser compatibilitySee also
Numbers and strings guide
String
String.raw()
Lexical grammar
ES6 in Depth: Template strings on hacks.mozilla.org (2015)\n\nTemplate literals (Template strings)Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackTemplate literals are literals delimited with backtick (`) characters, allowing for multi-line strings, string interpolation with embedded expressions, and special constructs called tagged templates.
Template literals are sometimes informally called template strings, because they are used most commonly for string interpolation (to create strings by doing substitution of placeholders). However, a tagged template literal may not result in a string; it can be used with a custom tag function to perform whatever operations you want on the different parts of the template literal.Syntaxjs`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tagFunction`string text ${expression} string text`
Parameters
string text

The string text that will become part of the template literal. Almost all characters are allowed literally, including line breaks and other whitespace characters. However, invalid escape sequences will cause a syntax error, unless a tag function is used.

expression

An expression to be inserted in the current position, whose value is converted to a string or passed to tagFunction.

tagFunction

If specified, it will be called with the template strings array and substitution expressions, and the return value becomes the value of the template literal. See tagged templates.

DescriptionTemplate literals are enclosed by backtick (`) characters instead of double or single quotes.
Along with having normal strings, template literals can also contain other parts called placeholders, which are embedded expressions delimited by a dollar sign and curly braces: ${expression}. The strings and placeholders get passed to a function — either a default function, or a function you supply. The default function (when you don't supply your own) just performs string interpolation to do substitution of the placeholders and then concatenate the parts into a single string.
To supply a function of your own, precede the template literal with a function name; the result is called a tagged template. In that case, the template literal is passed to your tag function, where you can then perform whatever operations you want on the different parts of the template literal.
To escape a backtick in a template literal, put a backslash (\) before the backtick.
js`\`` === "`"; // true

Dollar signs can be escaped as well to prevent interpolation.
js`\${1}` === "${1}"; // true
Multi-line stringsAny newline characters inserted in the source are part of the template literal.
Using normal strings, you would have to use the following syntax in order to get multi-line strings:
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
// string text line 2"

Using template literals, you can do the same with this:
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"

Like normal string literals, you can write a single-line string across multiple lines for source code readability, by escaping the newline with a backslash (\):
jsconsole.log(`string text line 1 \
string text line 2`);
// "string text line 1 string text line 2"
String interpolationWithout template literals, when you want to combine output from expressions with strings, you'd concatenate them using the addition operator +:
jsconst a = 5;
const b = 10;
console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");
// "Fifteen is 15 and
// not 20."

That can be hard to read – especially when you have multiple expressions.
With template literals, you can avoid the concatenation operator — and improve the readability of your code — by using placeholders of the form ${expression} to perform substitutions for embedded expressions:
jsconst a = 5;
const b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
// "Fifteen is 15 and
// not 20."

Note that there's a mild difference between the two syntaxes. Template literals coerce their expressions directly to strings, while addition coerces its operands to primitives first. For more information, see the reference page for the + operator.Nesting templatesIn certain cases, nesting a template is the easiest (and perhaps more readable) way to have configurable strings. Within a backtick-delimited template, it is simple to allow inner backticks by using them inside an ${expression} placeholder within the template.
For example, without template literals, if you wanted to return a certain value based on a particular condition, you could do something like the following:
jslet classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

With a template literal but without nesting, you could do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

With nesting of template literals, you can do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
Tagged templatesA more advanced form of template literals are tagged templates.
Tags allow you to parse template literals with a function. The first argument of a tag function contains an array of string values. The remaining arguments are related to the expressions.
The tag function can then perform whatever operations on these arguments you wish, and return the manipulated string. (Alternatively, it can return something completely different, as described in one of the following examples.)
The name of the function used for the tag can be whatever you want.
jsconst person = "Mike";
const age = 28;

function myTag(strings, personExp, ageExp) {
  const str0 = strings[0]; // "That "
  const str1 = strings[1]; // " is a "
  const str2 = strings[2]; // "."

  const ageStr = ageExp < 100 ? "youngster" : "centenarian";

  // We can even return a string built using a template literal
  return `${str0}${personExp}${str1}${ageStr}${str2}`;
}

const output = myTag`That ${person} is a ${age}.`;

console.log(output);
// That Mike is a youngster.

The tag does not have to be a plain identifier. You can use any expression with precedence greater than 16, which includes property access, function call, new expression, or even another tagged template literal.
jsconsole.log`Hello`; // [ 'Hello' ]
console.log.bind(1, 2)`Hello`; // 2 [ 'Hello' ]
new Function("console.log(arguments)")`Hello`; // [Arguments] { '0': [ 'Hello' ] }

function recursive(strings, ...values) {
  console.log(strings, values);
  return recursive;
}
recursive`Hello``World`;
// [ 'Hello' ] []
// [ 'World' ] []

While technically permitted by the syntax, untagged template literals are strings and will throw a TypeError when chained.
jsconsole.log(`Hello``World`); // TypeError: "Hello" is not a function

The only exception is optional chaining, which will throw a syntax error.
jsconsole.log?.`Hello`; // SyntaxError: Invalid tagged template on optional chain
console?.log`Hello`; // SyntaxError: Invalid tagged template on optional chain

Note that these two expressions are still parsable. This means they would not be subject to automatic semicolon insertion, which will only insert semicolons to fix code that's otherwise unparsable.
js// Still a syntax error
const a = console?.log
`Hello`

Tag functions don't even need to return a string!
jsfunction template(strings, ...keys) {
  return (...values) => {
    const dict = values[values.length - 1] || {};
    const result = [strings[0]];
    keys.forEach((key, i) => {
      const value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

const t1Closure = template`${0}${1}${0}!`;
// const t1Closure = template(["","","","!"],0,1,0);
t1Closure("Y", "A"); // "YAY!"

const t2Closure = template`${0} ${"foo"}!`;
// const t2Closure = template([""," ","!"],0,"foo");
t2Closure("Hello", { foo: "World" }); // "Hello World!"

const t3Closure = template`I'm ${"name"}. I'm almost ${"age"} years old.`;
// const t3Closure = template(["I'm ", ". I'm almost ", " years old."], "name", "age");
t3Closure("foo", { name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."
t3Closure({ name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."

The first argument received by the tag function is an array of strings. For any template literal, its length is equal to the number of substitutions (occurrences of ${…}) plus one, and is therefore always non-empty.
For any particular tagged template literal expression, the tag function will always be called with the exact same literal array, no matter how many times the literal is evaluated.
jsconst callHistory = [];

function tag(strings, ...values) {
  callHistory.push(strings);
  // Return a freshly made object
  return {};
}

function evaluateLiteral() {
  return tag`Hello, ${"world"}!`;
}

console.log(evaluateLiteral() === evaluateLiteral()); // false; each time `tag` is called, it returns a new object
console.log(callHistory[0] === callHistory[1]); // true; all evaluations of the same tagged literal would pass in the same strings array

This allows the tag to cache the result based on the identity of its first argument. To further ensure the array value's stability, the first argument and its raw property are both frozen, so you can't mutate them in any way.Raw stringsThe special raw property, available on the first argument to the tag function, allows you to access the raw strings as they were entered, without processing escape sequences.
jsfunction tag(strings) {
  console.log(strings.raw[0]);
}

tag`string text line 1 \n string text line 2`;
// Logs "string text line 1 \n string text line 2",
// including the two characters '\' and 'n'

In addition, the String.raw() method exists to create raw strings just like the default template function and string concatenation would create.
jsconst str = String.raw`Hi\n${2 + 3}!`;
// "Hi\\n5!"

str.length;
// 6

Array.from(str).join(",");
// "H,i,\\,n,5,!"

String.raw functions like an "identity" tag if the literal doesn't contain any escape sequences. In case you want an actual identity tag that always works as if the literal is untagged, you can make a custom function that passes the "cooked" (i.e., escape sequences are processed) literal array to String.raw, pretending they are raw strings.
jsconst identity = (strings, ...values) =>
  String.raw({ raw: strings }, ...values);
console.log(identity`Hi\n${2 + 3}!`);
// Hi
// 5!

This is useful for many tools which give special treatment to literals tagged by a particular name.
jsconst html = (strings, ...values) => String.raw({ raw: strings }, ...values);
// Some formatters will format this literal's content as HTML
const doc = html`<!doctype html>
  <html lang="en-US">
    <head>
      <title>Hello</title>
    </head>
    <body>
      <h1>Hello world!</h1>
    </body>
  </html>`;
Tagged templates and escape sequencesIn normal template literals, the escape sequences in string literals are all allowed. Any other non-well-formed escape sequence is a syntax error. This includes:

\ followed by any decimal digit other than 0, or \0 followed by a decimal digit; for example \9 and \07 (which is a deprecated syntax)
\x followed by fewer than two hex digits (including none); for example \xz
\u not followed by { and followed by fewer than four hex digits (including none); for example \uz
\u{} enclosing an invalid Unicode code point — it contains a non-hex digit, or its value is greater than 10FFFF; for example \u{110000} and \u{z}


Note: \ followed by other characters, while they may be useless since nothing is escaped, are not syntax errors.

However, this is problematic for tagged templates, which, in addition to the "cooked" literal, also have access to the raw literals (escape sequences are preserved as-is).
Tagged templates enable the embedding of arbitrary string content, where escape sequences may follow a different syntax. Consider for an example where we embed LaTeX source text in JavaScript via String.raw. We want to still be able to use LaTeX macros that start with u or x without following JavaScript syntax restrictions. Therefore, the syntax restriction of well-formed escape sequences is removed from tagged templates. The example below uses MathJax to render LaTeX in one element:
jsconst node = document.getElementById("formula");
MathJax.typesetClear([node]);
// Throws in older ECMAScript versions (ES2016 and earlier)
// SyntaxError: malformed Unicode character escape sequence
node.textContent = String.raw`$\underline{u}$`;
MathJax.typesetPromise([node]);

However, illegal escape sequences must still be represented in the "cooked" representation. They will show up as undefined element in the "cooked" array:
jsfunction log(str) {
  console.log("Cooked:", str[0]);
  console.log("Raw:", str.raw[0]);
}

log`\unicode`;
// Cooked: undefined
// Raw: \unicode

Note that the escape-sequence restriction is only dropped from tagged templates, but not from untagged template literals:
jsconst bad = `bad escape sequence: \unicode`;
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-template-literalsBrowser compatibilitySee also
Numbers and strings guide
String
String.raw()
Lexical grammar
ES6 in Depth: Template strings on hacks.mozilla.org (2015)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nTemplate literals (Template strings)Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackTemplate literals are literals delimited with backtick (`) characters, allowing for multi-line strings, string interpolation with embedded expressions, and special constructs called tagged templates.
Template literals are sometimes informally called template strings, because they are used most commonly for string interpolation (to create strings by doing substitution of placeholders). However, a tagged template literal may not result in a string; it can be used with a custom tag function to perform whatever operations you want on the different parts of the template literal.Syntaxjs`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tagFunction`string text ${expression} string text`
Parameters
string text

The string text that will become part of the template literal. Almost all characters are allowed literally, including line breaks and other whitespace characters. However, invalid escape sequences will cause a syntax error, unless a tag function is used.

expression

An expression to be inserted in the current position, whose value is converted to a string or passed to tagFunction.

tagFunction

If specified, it will be called with the template strings array and substitution expressions, and the return value becomes the value of the template literal. See tagged templates.

DescriptionTemplate literals are enclosed by backtick (`) characters instead of double or single quotes.
Along with having normal strings, template literals can also contain other parts called placeholders, which are embedded expressions delimited by a dollar sign and curly braces: ${expression}. The strings and placeholders get passed to a function — either a default function, or a function you supply. The default function (when you don't supply your own) just performs string interpolation to do substitution of the placeholders and then concatenate the parts into a single string.
To supply a function of your own, precede the template literal with a function name; the result is called a tagged template. In that case, the template literal is passed to your tag function, where you can then perform whatever operations you want on the different parts of the template literal.
To escape a backtick in a template literal, put a backslash (\) before the backtick.
js`\`` === "`"; // true

Dollar signs can be escaped as well to prevent interpolation.
js`\${1}` === "${1}"; // true
Multi-line stringsAny newline characters inserted in the source are part of the template literal.
Using normal strings, you would have to use the following syntax in order to get multi-line strings:
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
// string text line 2"

Using template literals, you can do the same with this:
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"

Like normal string literals, you can write a single-line string across multiple lines for source code readability, by escaping the newline with a backslash (\):
jsconsole.log(`string text line 1 \
string text line 2`);
// "string text line 1 string text line 2"
String interpolationWithout template literals, when you want to combine output from expressions with strings, you'd concatenate them using the addition operator +:
jsconst a = 5;
const b = 10;
console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");
// "Fifteen is 15 and
// not 20."

That can be hard to read – especially when you have multiple expressions.
With template literals, you can avoid the concatenation operator — and improve the readability of your code — by using placeholders of the form ${expression} to perform substitutions for embedded expressions:
jsconst a = 5;
const b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
// "Fifteen is 15 and
// not 20."

Note that there's a mild difference between the two syntaxes. Template literals coerce their expressions directly to strings, while addition coerces its operands to primitives first. For more information, see the reference page for the + operator.Nesting templatesIn certain cases, nesting a template is the easiest (and perhaps more readable) way to have configurable strings. Within a backtick-delimited template, it is simple to allow inner backticks by using them inside an ${expression} placeholder within the template.
For example, without template literals, if you wanted to return a certain value based on a particular condition, you could do something like the following:
jslet classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

With a template literal but without nesting, you could do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

With nesting of template literals, you can do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
Tagged templatesA more advanced form of template literals are tagged templates.
Tags allow you to parse template literals with a function. The first argument of a tag function contains an array of string values. The remaining arguments are related to the expressions.
The tag function can then perform whatever operations on these arguments you wish, and return the manipulated string. (Alternatively, it can return something completely different, as described in one of the following examples.)
The name of the function used for the tag can be whatever you want.
jsconst person = "Mike";
const age = 28;

function myTag(strings, personExp, ageExp) {
  const str0 = strings[0]; // "That "
  const str1 = strings[1]; // " is a "
  const str2 = strings[2]; // "."

  const ageStr = ageExp < 100 ? "youngster" : "centenarian";

  // We can even return a string built using a template literal
  return `${str0}${personExp}${str1}${ageStr}${str2}`;
}

const output = myTag`That ${person} is a ${age}.`;

console.log(output);
// That Mike is a youngster.

The tag does not have to be a plain identifier. You can use any expression with precedence greater than 16, which includes property access, function call, new expression, or even another tagged template literal.
jsconsole.log`Hello`; // [ 'Hello' ]
console.log.bind(1, 2)`Hello`; // 2 [ 'Hello' ]
new Function("console.log(arguments)")`Hello`; // [Arguments] { '0': [ 'Hello' ] }

function recursive(strings, ...values) {
  console.log(strings, values);
  return recursive;
}
recursive`Hello``World`;
// [ 'Hello' ] []
// [ 'World' ] []

While technically permitted by the syntax, untagged template literals are strings and will throw a TypeError when chained.
jsconsole.log(`Hello``World`); // TypeError: "Hello" is not a function

The only exception is optional chaining, which will throw a syntax error.
jsconsole.log?.`Hello`; // SyntaxError: Invalid tagged template on optional chain
console?.log`Hello`; // SyntaxError: Invalid tagged template on optional chain

Note that these two expressions are still parsable. This means they would not be subject to automatic semicolon insertion, which will only insert semicolons to fix code that's otherwise unparsable.
js// Still a syntax error
const a = console?.log
`Hello`

Tag functions don't even need to return a string!
jsfunction template(strings, ...keys) {
  return (...values) => {
    const dict = values[values.length - 1] || {};
    const result = [strings[0]];
    keys.forEach((key, i) => {
      const value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

const t1Closure = template`${0}${1}${0}!`;
// const t1Closure = template(["","","","!"],0,1,0);
t1Closure("Y", "A"); // "YAY!"

const t2Closure = template`${0} ${"foo"}!`;
// const t2Closure = template([""," ","!"],0,"foo");
t2Closure("Hello", { foo: "World" }); // "Hello World!"

const t3Closure = template`I'm ${"name"}. I'm almost ${"age"} years old.`;
// const t3Closure = template(["I'm ", ". I'm almost ", " years old."], "name", "age");
t3Closure("foo", { name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."
t3Closure({ name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."

The first argument received by the tag function is an array of strings. For any template literal, its length is equal to the number of substitutions (occurrences of ${…}) plus one, and is therefore always non-empty.
For any particular tagged template literal expression, the tag function will always be called with the exact same literal array, no matter how many times the literal is evaluated.
jsconst callHistory = [];

function tag(strings, ...values) {
  callHistory.push(strings);
  // Return a freshly made object
  return {};
}

function evaluateLiteral() {
  return tag`Hello, ${"world"}!`;
}

console.log(evaluateLiteral() === evaluateLiteral()); // false; each time `tag` is called, it returns a new object
console.log(callHistory[0] === callHistory[1]); // true; all evaluations of the same tagged literal would pass in the same strings array

This allows the tag to cache the result based on the identity of its first argument. To further ensure the array value's stability, the first argument and its raw property are both frozen, so you can't mutate them in any way.Raw stringsThe special raw property, available on the first argument to the tag function, allows you to access the raw strings as they were entered, without processing escape sequences.
jsfunction tag(strings) {
  console.log(strings.raw[0]);
}

tag`string text line 1 \n string text line 2`;
// Logs "string text line 1 \n string text line 2",
// including the two characters '\' and 'n'

In addition, the String.raw() method exists to create raw strings just like the default template function and string concatenation would create.
jsconst str = String.raw`Hi\n${2 + 3}!`;
// "Hi\\n5!"

str.length;
// 6

Array.from(str).join(",");
// "H,i,\\,n,5,!"

String.raw functions like an "identity" tag if the literal doesn't contain any escape sequences. In case you want an actual identity tag that always works as if the literal is untagged, you can make a custom function that passes the "cooked" (i.e., escape sequences are processed) literal array to String.raw, pretending they are raw strings.
jsconst identity = (strings, ...values) =>
  String.raw({ raw: strings }, ...values);
console.log(identity`Hi\n${2 + 3}!`);
// Hi
// 5!

This is useful for many tools which give special treatment to literals tagged by a particular name.
jsconst html = (strings, ...values) => String.raw({ raw: strings }, ...values);
// Some formatters will format this literal's content as HTML
const doc = html`<!doctype html>
  <html lang="en-US">
    <head>
      <title>Hello</title>
    </head>
    <body>
      <h1>Hello world!</h1>
    </body>
  </html>`;
Tagged templates and escape sequencesIn normal template literals, the escape sequences in string literals are all allowed. Any other non-well-formed escape sequence is a syntax error. This includes:

\ followed by any decimal digit other than 0, or \0 followed by a decimal digit; for example \9 and \07 (which is a deprecated syntax)
\x followed by fewer than two hex digits (including none); for example \xz
\u not followed by { and followed by fewer than four hex digits (including none); for example \uz
\u{} enclosing an invalid Unicode code point — it contains a non-hex digit, or its value is greater than 10FFFF; for example \u{110000} and \u{z}


Note: \ followed by other characters, while they may be useless since nothing is escaped, are not syntax errors.

However, this is problematic for tagged templates, which, in addition to the "cooked" literal, also have access to the raw literals (escape sequences are preserved as-is).
Tagged templates enable the embedding of arbitrary string content, where escape sequences may follow a different syntax. Consider for an example where we embed LaTeX source text in JavaScript via String.raw. We want to still be able to use LaTeX macros that start with u or x without following JavaScript syntax restrictions. Therefore, the syntax restriction of well-formed escape sequences is removed from tagged templates. The example below uses MathJax to render LaTeX in one element:
jsconst node = document.getElementById("formula");
MathJax.typesetClear([node]);
// Throws in older ECMAScript versions (ES2016 and earlier)
// SyntaxError: malformed Unicode character escape sequence
node.textContent = String.raw`$\underline{u}$`;
MathJax.typesetPromise([node]);

However, illegal escape sequences must still be represented in the "cooked" representation. They will show up as undefined element in the "cooked" array:
jsfunction log(str) {
  console.log("Cooked:", str[0]);
  console.log("Raw:", str.raw[0]);
}

log`\unicode`;
// Cooked: undefined
// Raw: \unicode

Note that the escape-sequence restriction is only dropped from tagged templates, but not from untagged template literals:
jsconst bad = `bad escape sequence: \unicode`;
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-template-literalsBrowser compatibilitySee also
Numbers and strings guide
String
String.raw()
Lexical grammar
ES6 in Depth: Template strings on hacks.mozilla.org (2015)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nTemplate literals (Template strings)Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackTemplate literals are literals delimited with backtick (`) characters, allowing for multi-line strings, string interpolation with embedded expressions, and special constructs called tagged templates.
Template literals are sometimes informally called template strings, because they are used most commonly for string interpolation (to create strings by doing substitution of placeholders). However, a tagged template literal may not result in a string; it can be used with a custom tag function to perform whatever operations you want on the different parts of the template literal.Syntaxjs`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tagFunction`string text ${expression} string text`
Parameters
string text

The string text that will become part of the template literal. Almost all characters are allowed literally, including line breaks and other whitespace characters. However, invalid escape sequences will cause a syntax error, unless a tag function is used.

expression

An expression to be inserted in the current position, whose value is converted to a string or passed to tagFunction.

tagFunction

If specified, it will be called with the template strings array and substitution expressions, and the return value becomes the value of the template literal. See tagged templates.

DescriptionTemplate literals are enclosed by backtick (`) characters instead of double or single quotes.
Along with having normal strings, template literals can also contain other parts called placeholders, which are embedded expressions delimited by a dollar sign and curly braces: ${expression}. The strings and placeholders get passed to a function — either a default function, or a function you supply. The default function (when you don't supply your own) just performs string interpolation to do substitution of the placeholders and then concatenate the parts into a single string.
To supply a function of your own, precede the template literal with a function name; the result is called a tagged template. In that case, the template literal is passed to your tag function, where you can then perform whatever operations you want on the different parts of the template literal.
To escape a backtick in a template literal, put a backslash (\) before the backtick.
js`\`` === "`"; // true

Dollar signs can be escaped as well to prevent interpolation.
js`\${1}` === "${1}"; // true
Multi-line stringsAny newline characters inserted in the source are part of the template literal.
Using normal strings, you would have to use the following syntax in order to get multi-line strings:
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
// string text line 2"

Using template literals, you can do the same with this:
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"

Like normal string literals, you can write a single-line string across multiple lines for source code readability, by escaping the newline with a backslash (\):
jsconsole.log(`string text line 1 \
string text line 2`);
// "string text line 1 string text line 2"
String interpolationWithout template literals, when you want to combine output from expressions with strings, you'd concatenate them using the addition operator +:
jsconst a = 5;
const b = 10;
console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");
// "Fifteen is 15 and
// not 20."

That can be hard to read – especially when you have multiple expressions.
With template literals, you can avoid the concatenation operator — and improve the readability of your code — by using placeholders of the form ${expression} to perform substitutions for embedded expressions:
jsconst a = 5;
const b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
// "Fifteen is 15 and
// not 20."

Note that there's a mild difference between the two syntaxes. Template literals coerce their expressions directly to strings, while addition coerces its operands to primitives first. For more information, see the reference page for the + operator.Nesting templatesIn certain cases, nesting a template is the easiest (and perhaps more readable) way to have configurable strings. Within a backtick-delimited template, it is simple to allow inner backticks by using them inside an ${expression} placeholder within the template.
For example, without template literals, if you wanted to return a certain value based on a particular condition, you could do something like the following:
jslet classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

With a template literal but without nesting, you could do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

With nesting of template literals, you can do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
Tagged templatesA more advanced form of template literals are tagged templates.
Tags allow you to parse template literals with a function. The first argument of a tag function contains an array of string values. The remaining arguments are related to the expressions.
The tag function can then perform whatever operations on these arguments you wish, and return the manipulated string. (Alternatively, it can return something completely different, as described in one of the following examples.)
The name of the function used for the tag can be whatever you want.
jsconst person = "Mike";
const age = 28;

function myTag(strings, personExp, ageExp) {
  const str0 = strings[0]; // "That "
  const str1 = strings[1]; // " is a "
  const str2 = strings[2]; // "."

  const ageStr = ageExp < 100 ? "youngster" : "centenarian";

  // We can even return a string built using a template literal
  return `${str0}${personExp}${str1}${ageStr}${str2}`;
}

const output = myTag`That ${person} is a ${age}.`;

console.log(output);
// That Mike is a youngster.

The tag does not have to be a plain identifier. You can use any expression with precedence greater than 16, which includes property access, function call, new expression, or even another tagged template literal.
jsconsole.log`Hello`; // [ 'Hello' ]
console.log.bind(1, 2)`Hello`; // 2 [ 'Hello' ]
new Function("console.log(arguments)")`Hello`; // [Arguments] { '0': [ 'Hello' ] }

function recursive(strings, ...values) {
  console.log(strings, values);
  return recursive;
}
recursive`Hello``World`;
// [ 'Hello' ] []
// [ 'World' ] []

While technically permitted by the syntax, untagged template literals are strings and will throw a TypeError when chained.
jsconsole.log(`Hello``World`); // TypeError: "Hello" is not a function

The only exception is optional chaining, which will throw a syntax error.
jsconsole.log?.`Hello`; // SyntaxError: Invalid tagged template on optional chain
console?.log`Hello`; // SyntaxError: Invalid tagged template on optional chain

Note that these two expressions are still parsable. This means they would not be subject to automatic semicolon insertion, which will only insert semicolons to fix code that's otherwise unparsable.
js// Still a syntax error
const a = console?.log
`Hello`

Tag functions don't even need to return a string!
jsfunction template(strings, ...keys) {
  return (...values) => {
    const dict = values[values.length - 1] || {};
    const result = [strings[0]];
    keys.forEach((key, i) => {
      const value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

const t1Closure = template`${0}${1}${0}!`;
// const t1Closure = template(["","","","!"],0,1,0);
t1Closure("Y", "A"); // "YAY!"

const t2Closure = template`${0} ${"foo"}!`;
// const t2Closure = template([""," ","!"],0,"foo");
t2Closure("Hello", { foo: "World" }); // "Hello World!"

const t3Closure = template`I'm ${"name"}. I'm almost ${"age"} years old.`;
// const t3Closure = template(["I'm ", ". I'm almost ", " years old."], "name", "age");
t3Closure("foo", { name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."
t3Closure({ name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."

The first argument received by the tag function is an array of strings. For any template literal, its length is equal to the number of substitutions (occurrences of ${…}) plus one, and is therefore always non-empty.
For any particular tagged template literal expression, the tag function will always be called with the exact same literal array, no matter how many times the literal is evaluated.
jsconst callHistory = [];

function tag(strings, ...values) {
  callHistory.push(strings);
  // Return a freshly made object
  return {};
}

function evaluateLiteral() {
  return tag`Hello, ${"world"}!`;
}

console.log(evaluateLiteral() === evaluateLiteral()); // false; each time `tag` is called, it returns a new object
console.log(callHistory[0] === callHistory[1]); // true; all evaluations of the same tagged literal would pass in the same strings array

This allows the tag to cache the result based on the identity of its first argument. To further ensure the array value's stability, the first argument and its raw property are both frozen, so you can't mutate them in any way.Raw stringsThe special raw property, available on the first argument to the tag function, allows you to access the raw strings as they were entered, without processing escape sequences.
jsfunction tag(strings) {
  console.log(strings.raw[0]);
}

tag`string text line 1 \n string text line 2`;
// Logs "string text line 1 \n string text line 2",
// including the two characters '\' and 'n'

In addition, the String.raw() method exists to create raw strings just like the default template function and string concatenation would create.
jsconst str = String.raw`Hi\n${2 + 3}!`;
// "Hi\\n5!"

str.length;
// 6

Array.from(str).join(",");
// "H,i,\\,n,5,!"

String.raw functions like an "identity" tag if the literal doesn't contain any escape sequences. In case you want an actual identity tag that always works as if the literal is untagged, you can make a custom function that passes the "cooked" (i.e., escape sequences are processed) literal array to String.raw, pretending they are raw strings.
jsconst identity = (strings, ...values) =>
  String.raw({ raw: strings }, ...values);
console.log(identity`Hi\n${2 + 3}!`);
// Hi
// 5!

This is useful for many tools which give special treatment to literals tagged by a particular name.
jsconst html = (strings, ...values) => String.raw({ raw: strings }, ...values);
// Some formatters will format this literal's content as HTML
const doc = html`<!doctype html>
  <html lang="en-US">
    <head>
      <title>Hello</title>
    </head>
    <body>
      <h1>Hello world!</h1>
    </body>
  </html>`;
Tagged templates and escape sequencesIn normal template literals, the escape sequences in string literals are all allowed. Any other non-well-formed escape sequence is a syntax error. This includes:

\ followed by any decimal digit other than 0, or \0 followed by a decimal digit; for example \9 and \07 (which is a deprecated syntax)
\x followed by fewer than two hex digits (including none); for example \xz
\u not followed by { and followed by fewer than four hex digits (including none); for example \uz
\u{} enclosing an invalid Unicode code point — it contains a non-hex digit, or its value is greater than 10FFFF; for example \u{110000} and \u{z}


Note: \ followed by other characters, while they may be useless since nothing is escaped, are not syntax errors.

However, this is problematic for tagged templates, which, in addition to the "cooked" literal, also have access to the raw literals (escape sequences are preserved as-is).
Tagged templates enable the embedding of arbitrary string content, where escape sequences may follow a different syntax. Consider for an example where we embed LaTeX source text in JavaScript via String.raw. We want to still be able to use LaTeX macros that start with u or x without following JavaScript syntax restrictions. Therefore, the syntax restriction of well-formed escape sequences is removed from tagged templates. The example below uses MathJax to render LaTeX in one element:
jsconst node = document.getElementById("formula");
MathJax.typesetClear([node]);
// Throws in older ECMAScript versions (ES2016 and earlier)
// SyntaxError: malformed Unicode character escape sequence
node.textContent = String.raw`$\underline{u}$`;
MathJax.typesetPromise([node]);

However, illegal escape sequences must still be represented in the "cooked" representation. They will show up as undefined element in the "cooked" array:
jsfunction log(str) {
  console.log("Cooked:", str[0]);
  console.log("Raw:", str.raw[0]);
}

log`\unicode`;
// Cooked: undefined
// Raw: \unicode

Note that the escape-sequence restriction is only dropped from tagged templates, but not from untagged template literals:
jsconst bad = `bad escape sequence: \unicode`;
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-template-literalsBrowser compatibilitySee also
Numbers and strings guide
String
String.raw()
Lexical grammar
ES6 in Depth: Template strings on hacks.mozilla.org (2015)\n\nTemplate literals (Template strings)Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackTemplate literals are literals delimited with backtick (`) characters, allowing for multi-line strings, string interpolation with embedded expressions, and special constructs called tagged templates.
Template literals are sometimes informally called template strings, because they are used most commonly for string interpolation (to create strings by doing substitution of placeholders). However, a tagged template literal may not result in a string; it can be used with a custom tag function to perform whatever operations you want on the different parts of the template literal.Syntaxjs`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tagFunction`string text ${expression} string text`
Parameters
string text

The string text that will become part of the template literal. Almost all characters are allowed literally, including line breaks and other whitespace characters. However, invalid escape sequences will cause a syntax error, unless a tag function is used.

expression

An expression to be inserted in the current position, whose value is converted to a string or passed to tagFunction.

tagFunction

If specified, it will be called with the template strings array and substitution expressions, and the return value becomes the value of the template literal. See tagged templates.

DescriptionTemplate literals are enclosed by backtick (`) characters instead of double or single quotes.
Along with having normal strings, template literals can also contain other parts called placeholders, which are embedded expressions delimited by a dollar sign and curly braces: ${expression}. The strings and placeholders get passed to a function — either a default function, or a function you supply. The default function (when you don't supply your own) just performs string interpolation to do substitution of the placeholders and then concatenate the parts into a single string.
To supply a function of your own, precede the template literal with a function name; the result is called a tagged template. In that case, the template literal is passed to your tag function, where you can then perform whatever operations you want on the different parts of the template literal.
To escape a backtick in a template literal, put a backslash (\) before the backtick.
js`\`` === "`"; // true

Dollar signs can be escaped as well to prevent interpolation.
js`\${1}` === "${1}"; // true
Multi-line stringsAny newline characters inserted in the source are part of the template literal.
Using normal strings, you would have to use the following syntax in order to get multi-line strings:
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
// string text line 2"

Using template literals, you can do the same with this:
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"

Like normal string literals, you can write a single-line string across multiple lines for source code readability, by escaping the newline with a backslash (\):
jsconsole.log(`string text line 1 \
string text line 2`);
// "string text line 1 string text line 2"
String interpolationWithout template literals, when you want to combine output from expressions with strings, you'd concatenate them using the addition operator +:
jsconst a = 5;
const b = 10;
console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");
// "Fifteen is 15 and
// not 20."

That can be hard to read – especially when you have multiple expressions.
With template literals, you can avoid the concatenation operator — and improve the readability of your code — by using placeholders of the form ${expression} to perform substitutions for embedded expressions:
jsconst a = 5;
const b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
// "Fifteen is 15 and
// not 20."

Note that there's a mild difference between the two syntaxes. Template literals coerce their expressions directly to strings, while addition coerces its operands to primitives first. For more information, see the reference page for the + operator.Nesting templatesIn certain cases, nesting a template is the easiest (and perhaps more readable) way to have configurable strings. Within a backtick-delimited template, it is simple to allow inner backticks by using them inside an ${expression} placeholder within the template.
For example, without template literals, if you wanted to return a certain value based on a particular condition, you could do something like the following:
jslet classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

With a template literal but without nesting, you could do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

With nesting of template literals, you can do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
Tagged templatesA more advanced form of template literals are tagged templates.
Tags allow you to parse template literals with a function. The first argument of a tag function contains an array of string values. The remaining arguments are related to the expressions.
The tag function can then perform whatever operations on these arguments you wish, and return the manipulated string. (Alternatively, it can return something completely different, as described in one of the following examples.)
The name of the function used for the tag can be whatever you want.
jsconst person = "Mike";
const age = 28;

function myTag(strings, personExp, ageExp) {
  const str0 = strings[0]; // "That "
  const str1 = strings[1]; // " is a "
  const str2 = strings[2]; // "."

  const ageStr = ageExp < 100 ? "youngster" : "centenarian";

  // We can even return a string built using a template literal
  return `${str0}${personExp}${str1}${ageStr}${str2}`;
}

const output = myTag`That ${person} is a ${age}.`;

console.log(output);
// That Mike is a youngster.

The tag does not have to be a plain identifier. You can use any expression with precedence greater than 16, which includes property access, function call, new expression, or even another tagged template literal.
jsconsole.log`Hello`; // [ 'Hello' ]
console.log.bind(1, 2)`Hello`; // 2 [ 'Hello' ]
new Function("console.log(arguments)")`Hello`; // [Arguments] { '0': [ 'Hello' ] }

function recursive(strings, ...values) {
  console.log(strings, values);
  return recursive;
}
recursive`Hello``World`;
// [ 'Hello' ] []
// [ 'World' ] []

While technically permitted by the syntax, untagged template literals are strings and will throw a TypeError when chained.
jsconsole.log(`Hello``World`); // TypeError: "Hello" is not a function

The only exception is optional chaining, which will throw a syntax error.
jsconsole.log?.`Hello`; // SyntaxError: Invalid tagged template on optional chain
console?.log`Hello`; // SyntaxError: Invalid tagged template on optional chain

Note that these two expressions are still parsable. This means they would not be subject to automatic semicolon insertion, which will only insert semicolons to fix code that's otherwise unparsable.
js// Still a syntax error
const a = console?.log
`Hello`

Tag functions don't even need to return a string!
jsfunction template(strings, ...keys) {
  return (...values) => {
    const dict = values[values.length - 1] || {};
    const result = [strings[0]];
    keys.forEach((key, i) => {
      const value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

const t1Closure = template`${0}${1}${0}!`;
// const t1Closure = template(["","","","!"],0,1,0);
t1Closure("Y", "A"); // "YAY!"

const t2Closure = template`${0} ${"foo"}!`;
// const t2Closure = template([""," ","!"],0,"foo");
t2Closure("Hello", { foo: "World" }); // "Hello World!"

const t3Closure = template`I'm ${"name"}. I'm almost ${"age"} years old.`;
// const t3Closure = template(["I'm ", ". I'm almost ", " years old."], "name", "age");
t3Closure("foo", { name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."
t3Closure({ name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."

The first argument received by the tag function is an array of strings. For any template literal, its length is equal to the number of substitutions (occurrences of ${…}) plus one, and is therefore always non-empty.
For any particular tagged template literal expression, the tag function will always be called with the exact same literal array, no matter how many times the literal is evaluated.
jsconst callHistory = [];

function tag(strings, ...values) {
  callHistory.push(strings);
  // Return a freshly made object
  return {};
}

function evaluateLiteral() {
  return tag`Hello, ${"world"}!`;
}

console.log(evaluateLiteral() === evaluateLiteral()); // false; each time `tag` is called, it returns a new object
console.log(callHistory[0] === callHistory[1]); // true; all evaluations of the same tagged literal would pass in the same strings array

This allows the tag to cache the result based on the identity of its first argument. To further ensure the array value's stability, the first argument and its raw property are both frozen, so you can't mutate them in any way.Raw stringsThe special raw property, available on the first argument to the tag function, allows you to access the raw strings as they were entered, without processing escape sequences.
jsfunction tag(strings) {
  console.log(strings.raw[0]);
}

tag`string text line 1 \n string text line 2`;
// Logs "string text line 1 \n string text line 2",
// including the two characters '\' and 'n'

In addition, the String.raw() method exists to create raw strings just like the default template function and string concatenation would create.
jsconst str = String.raw`Hi\n${2 + 3}!`;
// "Hi\\n5!"

str.length;
// 6

Array.from(str).join(",");
// "H,i,\\,n,5,!"

String.raw functions like an "identity" tag if the literal doesn't contain any escape sequences. In case you want an actual identity tag that always works as if the literal is untagged, you can make a custom function that passes the "cooked" (i.e., escape sequences are processed) literal array to String.raw, pretending they are raw strings.
jsconst identity = (strings, ...values) =>
  String.raw({ raw: strings }, ...values);
console.log(identity`Hi\n${2 + 3}!`);
// Hi
// 5!

This is useful for many tools which give special treatment to literals tagged by a particular name.
jsconst html = (strings, ...values) => String.raw({ raw: strings }, ...values);
// Some formatters will format this literal's content as HTML
const doc = html`<!doctype html>
  <html lang="en-US">
    <head>
      <title>Hello</title>
    </head>
    <body>
      <h1>Hello world!</h1>
    </body>
  </html>`;
Tagged templates and escape sequencesIn normal template literals, the escape sequences in string literals are all allowed. Any other non-well-formed escape sequence is a syntax error. This includes:

\ followed by any decimal digit other than 0, or \0 followed by a decimal digit; for example \9 and \07 (which is a deprecated syntax)
\x followed by fewer than two hex digits (including none); for example \xz
\u not followed by { and followed by fewer than four hex digits (including none); for example \uz
\u{} enclosing an invalid Unicode code point — it contains a non-hex digit, or its value is greater than 10FFFF; for example \u{110000} and \u{z}


Note: \ followed by other characters, while they may be useless since nothing is escaped, are not syntax errors.

However, this is problematic for tagged templates, which, in addition to the "cooked" literal, also have access to the raw literals (escape sequences are preserved as-is).
Tagged templates enable the embedding of arbitrary string content, where escape sequences may follow a different syntax. Consider for an example where we embed LaTeX source text in JavaScript via String.raw. We want to still be able to use LaTeX macros that start with u or x without following JavaScript syntax restrictions. Therefore, the syntax restriction of well-formed escape sequences is removed from tagged templates. The example below uses MathJax to render LaTeX in one element:
jsconst node = document.getElementById("formula");
MathJax.typesetClear([node]);
// Throws in older ECMAScript versions (ES2016 and earlier)
// SyntaxError: malformed Unicode character escape sequence
node.textContent = String.raw`$\underline{u}$`;
MathJax.typesetPromise([node]);

However, illegal escape sequences must still be represented in the "cooked" representation. They will show up as undefined element in the "cooked" array:
jsfunction log(str) {
  console.log("Cooked:", str[0]);
  console.log("Raw:", str.raw[0]);
}

log`\unicode`;
// Cooked: undefined
// Raw: \unicode

Note that the escape-sequence restriction is only dropped from tagged templates, but not from untagged template literals:
jsconst bad = `bad escape sequence: \unicode`;
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-template-literalsBrowser compatibilitySee also
Numbers and strings guide
String
String.raw()
Lexical grammar
ES6 in Depth: Template strings on hacks.mozilla.org (2015)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nTemplate literals (Template strings)Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackTemplate literals are literals delimited with backtick (`) characters, allowing for multi-line strings, string interpolation with embedded expressions, and special constructs called tagged templates.
Template literals are sometimes informally called template strings, because they are used most commonly for string interpolation (to create strings by doing substitution of placeholders). However, a tagged template literal may not result in a string; it can be used with a custom tag function to perform whatever operations you want on the different parts of the template literal.Syntaxjs`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tagFunction`string text ${expression} string text`
Parameters
string text

The string text that will become part of the template literal. Almost all characters are allowed literally, including line breaks and other whitespace characters. However, invalid escape sequences will cause a syntax error, unless a tag function is used.

expression

An expression to be inserted in the current position, whose value is converted to a string or passed to tagFunction.

tagFunction

If specified, it will be called with the template strings array and substitution expressions, and the return value becomes the value of the template literal. See tagged templates.

DescriptionTemplate literals are enclosed by backtick (`) characters instead of double or single quotes.
Along with having normal strings, template literals can also contain other parts called placeholders, which are embedded expressions delimited by a dollar sign and curly braces: ${expression}. The strings and placeholders get passed to a function — either a default function, or a function you supply. The default function (when you don't supply your own) just performs string interpolation to do substitution of the placeholders and then concatenate the parts into a single string.
To supply a function of your own, precede the template literal with a function name; the result is called a tagged template. In that case, the template literal is passed to your tag function, where you can then perform whatever operations you want on the different parts of the template literal.
To escape a backtick in a template literal, put a backslash (\) before the backtick.
js`\`` === "`"; // true

Dollar signs can be escaped as well to prevent interpolation.
js`\${1}` === "${1}"; // true
Multi-line stringsAny newline characters inserted in the source are part of the template literal.
Using normal strings, you would have to use the following syntax in order to get multi-line strings:
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
// string text line 2"

Using template literals, you can do the same with this:
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"

Like normal string literals, you can write a single-line string across multiple lines for source code readability, by escaping the newline with a backslash (\):
jsconsole.log(`string text line 1 \
string text line 2`);
// "string text line 1 string text line 2"
String interpolationWithout template literals, when you want to combine output from expressions with strings, you'd concatenate them using the addition operator +:
jsconst a = 5;
const b = 10;
console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");
// "Fifteen is 15 and
// not 20."

That can be hard to read – especially when you have multiple expressions.
With template literals, you can avoid the concatenation operator — and improve the readability of your code — by using placeholders of the form ${expression} to perform substitutions for embedded expressions:
jsconst a = 5;
const b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
// "Fifteen is 15 and
// not 20."

Note that there's a mild difference between the two syntaxes. Template literals coerce their expressions directly to strings, while addition coerces its operands to primitives first. For more information, see the reference page for the + operator.Nesting templatesIn certain cases, nesting a template is the easiest (and perhaps more readable) way to have configurable strings. Within a backtick-delimited template, it is simple to allow inner backticks by using them inside an ${expression} placeholder within the template.
For example, without template literals, if you wanted to return a certain value based on a particular condition, you could do something like the following:
jslet classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

With a template literal but without nesting, you could do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

With nesting of template literals, you can do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
Tagged templatesA more advanced form of template literals are tagged templates.
Tags allow you to parse template literals with a function. The first argument of a tag function contains an array of string values. The remaining arguments are related to the expressions.
The tag function can then perform whatever operations on these arguments you wish, and return the manipulated string. (Alternatively, it can return something completely different, as described in one of the following examples.)
The name of the function used for the tag can be whatever you want.
jsconst person = "Mike";
const age = 28;

function myTag(strings, personExp, ageExp) {
  const str0 = strings[0]; // "That "
  const str1 = strings[1]; // " is a "
  const str2 = strings[2]; // "."

  const ageStr = ageExp < 100 ? "youngster" : "centenarian";

  // We can even return a string built using a template literal
  return `${str0}${personExp}${str1}${ageStr}${str2}`;
}

const output = myTag`That ${person} is a ${age}.`;

console.log(output);
// That Mike is a youngster.

The tag does not have to be a plain identifier. You can use any expression with precedence greater than 16, which includes property access, function call, new expression, or even another tagged template literal.
jsconsole.log`Hello`; // [ 'Hello' ]
console.log.bind(1, 2)`Hello`; // 2 [ 'Hello' ]
new Function("console.log(arguments)")`Hello`; // [Arguments] { '0': [ 'Hello' ] }

function recursive(strings, ...values) {
  console.log(strings, values);
  return recursive;
}
recursive`Hello``World`;
// [ 'Hello' ] []
// [ 'World' ] []

While technically permitted by the syntax, untagged template literals are strings and will throw a TypeError when chained.
jsconsole.log(`Hello``World`); // TypeError: "Hello" is not a function

The only exception is optional chaining, which will throw a syntax error.
jsconsole.log?.`Hello`; // SyntaxError: Invalid tagged template on optional chain
console?.log`Hello`; // SyntaxError: Invalid tagged template on optional chain

Note that these two expressions are still parsable. This means they would not be subject to automatic semicolon insertion, which will only insert semicolons to fix code that's otherwise unparsable.
js// Still a syntax error
const a = console?.log
`Hello`

Tag functions don't even need to return a string!
jsfunction template(strings, ...keys) {
  return (...values) => {
    const dict = values[values.length - 1] || {};
    const result = [strings[0]];
    keys.forEach((key, i) => {
      const value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

const t1Closure = template`${0}${1}${0}!`;
// const t1Closure = template(["","","","!"],0,1,0);
t1Closure("Y", "A"); // "YAY!"

const t2Closure = template`${0} ${"foo"}!`;
// const t2Closure = template([""," ","!"],0,"foo");
t2Closure("Hello", { foo: "World" }); // "Hello World!"

const t3Closure = template`I'm ${"name"}. I'm almost ${"age"} years old.`;
// const t3Closure = template(["I'm ", ". I'm almost ", " years old."], "name", "age");
t3Closure("foo", { name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."
t3Closure({ name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."

The first argument received by the tag function is an array of strings. For any template literal, its length is equal to the number of substitutions (occurrences of ${…}) plus one, and is therefore always non-empty.
For any particular tagged template literal expression, the tag function will always be called with the exact same literal array, no matter how many times the literal is evaluated.
jsconst callHistory = [];

function tag(strings, ...values) {
  callHistory.push(strings);
  // Return a freshly made object
  return {};
}

function evaluateLiteral() {
  return tag`Hello, ${"world"}!`;
}

console.log(evaluateLiteral() === evaluateLiteral()); // false; each time `tag` is called, it returns a new object
console.log(callHistory[0] === callHistory[1]); // true; all evaluations of the same tagged literal would pass in the same strings array

This allows the tag to cache the result based on the identity of its first argument. To further ensure the array value's stability, the first argument and its raw property are both frozen, so you can't mutate them in any way.Raw stringsThe special raw property, available on the first argument to the tag function, allows you to access the raw strings as they were entered, without processing escape sequences.
jsfunction tag(strings) {
  console.log(strings.raw[0]);
}

tag`string text line 1 \n string text line 2`;
// Logs "string text line 1 \n string text line 2",
// including the two characters '\' and 'n'

In addition, the String.raw() method exists to create raw strings just like the default template function and string concatenation would create.
jsconst str = String.raw`Hi\n${2 + 3}!`;
// "Hi\\n5!"

str.length;
// 6

Array.from(str).join(",");
// "H,i,\\,n,5,!"

String.raw functions like an "identity" tag if the literal doesn't contain any escape sequences. In case you want an actual identity tag that always works as if the literal is untagged, you can make a custom function that passes the "cooked" (i.e., escape sequences are processed) literal array to String.raw, pretending they are raw strings.
jsconst identity = (strings, ...values) =>
  String.raw({ raw: strings }, ...values);
console.log(identity`Hi\n${2 + 3}!`);
// Hi
// 5!

This is useful for many tools which give special treatment to literals tagged by a particular name.
jsconst html = (strings, ...values) => String.raw({ raw: strings }, ...values);
// Some formatters will format this literal's content as HTML
const doc = html`<!doctype html>
  <html lang="en-US">
    <head>
      <title>Hello</title>
    </head>
    <body>
      <h1>Hello world!</h1>
    </body>
  </html>`;
Tagged templates and escape sequencesIn normal template literals, the escape sequences in string literals are all allowed. Any other non-well-formed escape sequence is a syntax error. This includes:

\ followed by any decimal digit other than 0, or \0 followed by a decimal digit; for example \9 and \07 (which is a deprecated syntax)
\x followed by fewer than two hex digits (including none); for example \xz
\u not followed by { and followed by fewer than four hex digits (including none); for example \uz
\u{} enclosing an invalid Unicode code point — it contains a non-hex digit, or its value is greater than 10FFFF; for example \u{110000} and \u{z}


Note: \ followed by other characters, while they may be useless since nothing is escaped, are not syntax errors.

However, this is problematic for tagged templates, which, in addition to the "cooked" literal, also have access to the raw literals (escape sequences are preserved as-is).
Tagged templates enable the embedding of arbitrary string content, where escape sequences may follow a different syntax. Consider for an example where we embed LaTeX source text in JavaScript via String.raw. We want to still be able to use LaTeX macros that start with u or x without following JavaScript syntax restrictions. Therefore, the syntax restriction of well-formed escape sequences is removed from tagged templates. The example below uses MathJax to render LaTeX in one element:
jsconst node = document.getElementById("formula");
MathJax.typesetClear([node]);
// Throws in older ECMAScript versions (ES2016 and earlier)
// SyntaxError: malformed Unicode character escape sequence
node.textContent = String.raw`$\underline{u}$`;
MathJax.typesetPromise([node]);

However, illegal escape sequences must still be represented in the "cooked" representation. They will show up as undefined element in the "cooked" array:
jsfunction log(str) {
  console.log("Cooked:", str[0]);
  console.log("Raw:", str.raw[0]);
}

log`\unicode`;
// Cooked: undefined
// Raw: \unicode

Note that the escape-sequence restriction is only dropped from tagged templates, but not from untagged template literals:
jsconst bad = `bad escape sequence: \unicode`;
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-template-literalsBrowser compatibilitySee also
Numbers and strings guide
String
String.raw()
Lexical grammar
ES6 in Depth: Template strings on hacks.mozilla.org (2015)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nTemplate literals (Template strings)Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackTemplate literals are literals delimited with backtick (`) characters, allowing for multi-line strings, string interpolation with embedded expressions, and special constructs called tagged templates.
Template literals are sometimes informally called template strings, because they are used most commonly for string interpolation (to create strings by doing substitution of placeholders). However, a tagged template literal may not result in a string; it can be used with a custom tag function to perform whatever operations you want on the different parts of the template literal.Syntaxjs`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tagFunction`string text ${expression} string text`
Parameters
string text

The string text that will become part of the template literal. Almost all characters are allowed literally, including line breaks and other whitespace characters. However, invalid escape sequences will cause a syntax error, unless a tag function is used.

expression

An expression to be inserted in the current position, whose value is converted to a string or passed to tagFunction.

tagFunction

If specified, it will be called with the template strings array and substitution expressions, and the return value becomes the value of the template literal. See tagged templates.

DescriptionTemplate literals are enclosed by backtick (`) characters instead of double or single quotes.
Along with having normal strings, template literals can also contain other parts called placeholders, which are embedded expressions delimited by a dollar sign and curly braces: ${expression}. The strings and placeholders get passed to a function — either a default function, or a function you supply. The default function (when you don't supply your own) just performs string interpolation to do substitution of the placeholders and then concatenate the parts into a single string.
To supply a function of your own, precede the template literal with a function name; the result is called a tagged template. In that case, the template literal is passed to your tag function, where you can then perform whatever operations you want on the different parts of the template literal.
To escape a backtick in a template literal, put a backslash (\) before the backtick.
js`\`` === "`"; // true

Dollar signs can be escaped as well to prevent interpolation.
js`\${1}` === "${1}"; // true
Multi-line stringsAny newline characters inserted in the source are part of the template literal.
Using normal strings, you would have to use the following syntax in order to get multi-line strings:
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
// string text line 2"

Using template literals, you can do the same with this:
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"

Like normal string literals, you can write a single-line string across multiple lines for source code readability, by escaping the newline with a backslash (\):
jsconsole.log(`string text line 1 \
string text line 2`);
// "string text line 1 string text line 2"
String interpolationWithout template literals, when you want to combine output from expressions with strings, you'd concatenate them using the addition operator +:
jsconst a = 5;
const b = 10;
console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");
// "Fifteen is 15 and
// not 20."

That can be hard to read – especially when you have multiple expressions.
With template literals, you can avoid the concatenation operator — and improve the readability of your code — by using placeholders of the form ${expression} to perform substitutions for embedded expressions:
jsconst a = 5;
const b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
// "Fifteen is 15 and
// not 20."

Note that there's a mild difference between the two syntaxes. Template literals coerce their expressions directly to strings, while addition coerces its operands to primitives first. For more information, see the reference page for the + operator.Nesting templatesIn certain cases, nesting a template is the easiest (and perhaps more readable) way to have configurable strings. Within a backtick-delimited template, it is simple to allow inner backticks by using them inside an ${expression} placeholder within the template.
For example, without template literals, if you wanted to return a certain value based on a particular condition, you could do something like the following:
jslet classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

With a template literal but without nesting, you could do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

With nesting of template literals, you can do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
Tagged templatesA more advanced form of template literals are tagged templates.
Tags allow you to parse template literals with a function. The first argument of a tag function contains an array of string values. The remaining arguments are related to the expressions.
The tag function can then perform whatever operations on these arguments you wish, and return the manipulated string. (Alternatively, it can return something completely different, as described in one of the following examples.)
The name of the function used for the tag can be whatever you want.
jsconst person = "Mike";
const age = 28;

function myTag(strings, personExp, ageExp) {
  const str0 = strings[0]; // "That "
  const str1 = strings[1]; // " is a "
  const str2 = strings[2]; // "."

  const ageStr = ageExp < 100 ? "youngster" : "centenarian";

  // We can even return a string built using a template literal
  return `${str0}${personExp}${str1}${ageStr}${str2}`;
}

const output = myTag`That ${person} is a ${age}.`;

console.log(output);
// That Mike is a youngster.

The tag does not have to be a plain identifier. You can use any expression with precedence greater than 16, which includes property access, function call, new expression, or even another tagged template literal.
jsconsole.log`Hello`; // [ 'Hello' ]
console.log.bind(1, 2)`Hello`; // 2 [ 'Hello' ]
new Function("console.log(arguments)")`Hello`; // [Arguments] { '0': [ 'Hello' ] }

function recursive(strings, ...values) {
  console.log(strings, values);
  return recursive;
}
recursive`Hello``World`;
// [ 'Hello' ] []
// [ 'World' ] []

While technically permitted by the syntax, untagged template literals are strings and will throw a TypeError when chained.
jsconsole.log(`Hello``World`); // TypeError: "Hello" is not a function

The only exception is optional chaining, which will throw a syntax error.
jsconsole.log?.`Hello`; // SyntaxError: Invalid tagged template on optional chain
console?.log`Hello`; // SyntaxError: Invalid tagged template on optional chain

Note that these two expressions are still parsable. This means they would not be subject to automatic semicolon insertion, which will only insert semicolons to fix code that's otherwise unparsable.
js// Still a syntax error
const a = console?.log
`Hello`

Tag functions don't even need to return a string!
jsfunction template(strings, ...keys) {
  return (...values) => {
    const dict = values[values.length - 1] || {};
    const result = [strings[0]];
    keys.forEach((key, i) => {
      const value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

const t1Closure = template`${0}${1}${0}!`;
// const t1Closure = template(["","","","!"],0,1,0);
t1Closure("Y", "A"); // "YAY!"

const t2Closure = template`${0} ${"foo"}!`;
// const t2Closure = template([""," ","!"],0,"foo");
t2Closure("Hello", { foo: "World" }); // "Hello World!"

const t3Closure = template`I'm ${"name"}. I'm almost ${"age"} years old.`;
// const t3Closure = template(["I'm ", ". I'm almost ", " years old."], "name", "age");
t3Closure("foo", { name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."
t3Closure({ name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."

The first argument received by the tag function is an array of strings. For any template literal, its length is equal to the number of substitutions (occurrences of ${…}) plus one, and is therefore always non-empty.
For any particular tagged template literal expression, the tag function will always be called with the exact same literal array, no matter how many times the literal is evaluated.
jsconst callHistory = [];

function tag(strings, ...values) {
  callHistory.push(strings);
  // Return a freshly made object
  return {};
}

function evaluateLiteral() {
  return tag`Hello, ${"world"}!`;
}

console.log(evaluateLiteral() === evaluateLiteral()); // false; each time `tag` is called, it returns a new object
console.log(callHistory[0] === callHistory[1]); // true; all evaluations of the same tagged literal would pass in the same strings array

This allows the tag to cache the result based on the identity of its first argument. To further ensure the array value's stability, the first argument and its raw property are both frozen, so you can't mutate them in any way.Raw stringsThe special raw property, available on the first argument to the tag function, allows you to access the raw strings as they were entered, without processing escape sequences.
jsfunction tag(strings) {
  console.log(strings.raw[0]);
}

tag`string text line 1 \n string text line 2`;
// Logs "string text line 1 \n string text line 2",
// including the two characters '\' and 'n'

In addition, the String.raw() method exists to create raw strings just like the default template function and string concatenation would create.
jsconst str = String.raw`Hi\n${2 + 3}!`;
// "Hi\\n5!"

str.length;
// 6

Array.from(str).join(",");
// "H,i,\\,n,5,!"

String.raw functions like an "identity" tag if the literal doesn't contain any escape sequences. In case you want an actual identity tag that always works as if the literal is untagged, you can make a custom function that passes the "cooked" (i.e., escape sequences are processed) literal array to String.raw, pretending they are raw strings.
jsconst identity = (strings, ...values) =>
  String.raw({ raw: strings }, ...values);
console.log(identity`Hi\n${2 + 3}!`);
// Hi
// 5!

This is useful for many tools which give special treatment to literals tagged by a particular name.
jsconst html = (strings, ...values) => String.raw({ raw: strings }, ...values);
// Some formatters will format this literal's content as HTML
const doc = html`<!doctype html>
  <html lang="en-US">
    <head>
      <title>Hello</title>
    </head>
    <body>
      <h1>Hello world!</h1>
    </body>
  </html>`;
Tagged templates and escape sequencesIn normal template literals, the escape sequences in string literals are all allowed. Any other non-well-formed escape sequence is a syntax error. This includes:

\ followed by any decimal digit other than 0, or \0 followed by a decimal digit; for example \9 and \07 (which is a deprecated syntax)
\x followed by fewer than two hex digits (including none); for example \xz
\u not followed by { and followed by fewer than four hex digits (including none); for example \uz
\u{} enclosing an invalid Unicode code point — it contains a non-hex digit, or its value is greater than 10FFFF; for example \u{110000} and \u{z}


Note: \ followed by other characters, while they may be useless since nothing is escaped, are not syntax errors.

However, this is problematic for tagged templates, which, in addition to the "cooked" literal, also have access to the raw literals (escape sequences are preserved as-is).
Tagged templates enable the embedding of arbitrary string content, where escape sequences may follow a different syntax. Consider for an example where we embed LaTeX source text in JavaScript via String.raw. We want to still be able to use LaTeX macros that start with u or x without following JavaScript syntax restrictions. Therefore, the syntax restriction of well-formed escape sequences is removed from tagged templates. The example below uses MathJax to render LaTeX in one element:
jsconst node = document.getElementById("formula");
MathJax.typesetClear([node]);
// Throws in older ECMAScript versions (ES2016 and earlier)
// SyntaxError: malformed Unicode character escape sequence
node.textContent = String.raw`$\underline{u}$`;
MathJax.typesetPromise([node]);

However, illegal escape sequences must still be represented in the "cooked" representation. They will show up as undefined element in the "cooked" array:
jsfunction log(str) {
  console.log("Cooked:", str[0]);
  console.log("Raw:", str.raw[0]);
}

log`\unicode`;
// Cooked: undefined
// Raw: \unicode

Note that the escape-sequence restriction is only dropped from tagged templates, but not from untagged template literals:
jsconst bad = `bad escape sequence: \unicode`;
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-template-literalsBrowser compatibilitySee also
Numbers and strings guide
String
String.raw()
Lexical grammar
ES6 in Depth: Template strings on hacks.mozilla.org (2015)\n\nTemplate literals (Template strings)Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackTemplate literals are literals delimited with backtick (`) characters, allowing for multi-line strings, string interpolation with embedded expressions, and special constructs called tagged templates.
Template literals are sometimes informally called template strings, because they are used most commonly for string interpolation (to create strings by doing substitution of placeholders). However, a tagged template literal may not result in a string; it can be used with a custom tag function to perform whatever operations you want on the different parts of the template literal.Syntaxjs`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tagFunction`string text ${expression} string text`
Parameters
string text

The string text that will become part of the template literal. Almost all characters are allowed literally, including line breaks and other whitespace characters. However, invalid escape sequences will cause a syntax error, unless a tag function is used.

expression

An expression to be inserted in the current position, whose value is converted to a string or passed to tagFunction.

tagFunction

If specified, it will be called with the template strings array and substitution expressions, and the return value becomes the value of the template literal. See tagged templates.

DescriptionTemplate literals are enclosed by backtick (`) characters instead of double or single quotes.
Along with having normal strings, template literals can also contain other parts called placeholders, which are embedded expressions delimited by a dollar sign and curly braces: ${expression}. The strings and placeholders get passed to a function — either a default function, or a function you supply. The default function (when you don't supply your own) just performs string interpolation to do substitution of the placeholders and then concatenate the parts into a single string.
To supply a function of your own, precede the template literal with a function name; the result is called a tagged template. In that case, the template literal is passed to your tag function, where you can then perform whatever operations you want on the different parts of the template literal.
To escape a backtick in a template literal, put a backslash (\) before the backtick.
js`\`` === "`"; // true

Dollar signs can be escaped as well to prevent interpolation.
js`\${1}` === "${1}"; // true
Multi-line stringsAny newline characters inserted in the source are part of the template literal.
Using normal strings, you would have to use the following syntax in order to get multi-line strings:
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
// string text line 2"

Using template literals, you can do the same with this:
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"

Like normal string literals, you can write a single-line string across multiple lines for source code readability, by escaping the newline with a backslash (\):
jsconsole.log(`string text line 1 \
string text line 2`);
// "string text line 1 string text line 2"
String interpolationWithout template literals, when you want to combine output from expressions with strings, you'd concatenate them using the addition operator +:
jsconst a = 5;
const b = 10;
console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");
// "Fifteen is 15 and
// not 20."

That can be hard to read – especially when you have multiple expressions.
With template literals, you can avoid the concatenation operator — and improve the readability of your code — by using placeholders of the form ${expression} to perform substitutions for embedded expressions:
jsconst a = 5;
const b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
// "Fifteen is 15 and
// not 20."

Note that there's a mild difference between the two syntaxes. Template literals coerce their expressions directly to strings, while addition coerces its operands to primitives first. For more information, see the reference page for the + operator.Nesting templatesIn certain cases, nesting a template is the easiest (and perhaps more readable) way to have configurable strings. Within a backtick-delimited template, it is simple to allow inner backticks by using them inside an ${expression} placeholder within the template.
For example, without template literals, if you wanted to return a certain value based on a particular condition, you could do something like the following:
jslet classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

With a template literal but without nesting, you could do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

With nesting of template literals, you can do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
Tagged templatesA more advanced form of template literals are tagged templates.
Tags allow you to parse template literals with a function. The first argument of a tag function contains an array of string values. The remaining arguments are related to the expressions.
The tag function can then perform whatever operations on these arguments you wish, and return the manipulated string. (Alternatively, it can return something completely different, as described in one of the following examples.)
The name of the function used for the tag can be whatever you want.
jsconst person = "Mike";
const age = 28;

function myTag(strings, personExp, ageExp) {
  const str0 = strings[0]; // "That "
  const str1 = strings[1]; // " is a "
  const str2 = strings[2]; // "."

  const ageStr = ageExp < 100 ? "youngster" : "centenarian";

  // We can even return a string built using a template literal
  return `${str0}${personExp}${str1}${ageStr}${str2}`;
}

const output = myTag`That ${person} is a ${age}.`;

console.log(output);
// That Mike is a youngster.

The tag does not have to be a plain identifier. You can use any expression with precedence greater than 16, which includes property access, function call, new expression, or even another tagged template literal.
jsconsole.log`Hello`; // [ 'Hello' ]
console.log.bind(1, 2)`Hello`; // 2 [ 'Hello' ]
new Function("console.log(arguments)")`Hello`; // [Arguments] { '0': [ 'Hello' ] }

function recursive(strings, ...values) {
  console.log(strings, values);
  return recursive;
}
recursive`Hello``World`;
// [ 'Hello' ] []
// [ 'World' ] []

While technically permitted by the syntax, untagged template literals are strings and will throw a TypeError when chained.
jsconsole.log(`Hello``World`); // TypeError: "Hello" is not a function

The only exception is optional chaining, which will throw a syntax error.
jsconsole.log?.`Hello`; // SyntaxError: Invalid tagged template on optional chain
console?.log`Hello`; // SyntaxError: Invalid tagged template on optional chain

Note that these two expressions are still parsable. This means they would not be subject to automatic semicolon insertion, which will only insert semicolons to fix code that's otherwise unparsable.
js// Still a syntax error
const a = console?.log
`Hello`

Tag functions don't even need to return a string!
jsfunction template(strings, ...keys) {
  return (...values) => {
    const dict = values[values.length - 1] || {};
    const result = [strings[0]];
    keys.forEach((key, i) => {
      const value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

const t1Closure = template`${0}${1}${0}!`;
// const t1Closure = template(["","","","!"],0,1,0);
t1Closure("Y", "A"); // "YAY!"

const t2Closure = template`${0} ${"foo"}!`;
// const t2Closure = template([""," ","!"],0,"foo");
t2Closure("Hello", { foo: "World" }); // "Hello World!"

const t3Closure = template`I'm ${"name"}. I'm almost ${"age"} years old.`;
// const t3Closure = template(["I'm ", ". I'm almost ", " years old."], "name", "age");
t3Closure("foo", { name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."
t3Closure({ name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."

The first argument received by the tag function is an array of strings. For any template literal, its length is equal to the number of substitutions (occurrences of ${…}) plus one, and is therefore always non-empty.
For any particular tagged template literal expression, the tag function will always be called with the exact same literal array, no matter how many times the literal is evaluated.
jsconst callHistory = [];

function tag(strings, ...values) {
  callHistory.push(strings);
  // Return a freshly made object
  return {};
}

function evaluateLiteral() {
  return tag`Hello, ${"world"}!`;
}

console.log(evaluateLiteral() === evaluateLiteral()); // false; each time `tag` is called, it returns a new object
console.log(callHistory[0] === callHistory[1]); // true; all evaluations of the same tagged literal would pass in the same strings array

This allows the tag to cache the result based on the identity of its first argument. To further ensure the array value's stability, the first argument and its raw property are both frozen, so you can't mutate them in any way.Raw stringsThe special raw property, available on the first argument to the tag function, allows you to access the raw strings as they were entered, without processing escape sequences.
jsfunction tag(strings) {
  console.log(strings.raw[0]);
}

tag`string text line 1 \n string text line 2`;
// Logs "string text line 1 \n string text line 2",
// including the two characters '\' and 'n'

In addition, the String.raw() method exists to create raw strings just like the default template function and string concatenation would create.
jsconst str = String.raw`Hi\n${2 + 3}!`;
// "Hi\\n5!"

str.length;
// 6

Array.from(str).join(",");
// "H,i,\\,n,5,!"

String.raw functions like an "identity" tag if the literal doesn't contain any escape sequences. In case you want an actual identity tag that always works as if the literal is untagged, you can make a custom function that passes the "cooked" (i.e., escape sequences are processed) literal array to String.raw, pretending they are raw strings.
jsconst identity = (strings, ...values) =>
  String.raw({ raw: strings }, ...values);
console.log(identity`Hi\n${2 + 3}!`);
// Hi
// 5!

This is useful for many tools which give special treatment to literals tagged by a particular name.
jsconst html = (strings, ...values) => String.raw({ raw: strings }, ...values);
// Some formatters will format this literal's content as HTML
const doc = html`<!doctype html>
  <html lang="en-US">
    <head>
      <title>Hello</title>
    </head>
    <body>
      <h1>Hello world!</h1>
    </body>
  </html>`;
Tagged templates and escape sequencesIn normal template literals, the escape sequences in string literals are all allowed. Any other non-well-formed escape sequence is a syntax error. This includes:

\ followed by any decimal digit other than 0, or \0 followed by a decimal digit; for example \9 and \07 (which is a deprecated syntax)
\x followed by fewer than two hex digits (including none); for example \xz
\u not followed by { and followed by fewer than four hex digits (including none); for example \uz
\u{} enclosing an invalid Unicode code point — it contains a non-hex digit, or its value is greater than 10FFFF; for example \u{110000} and \u{z}


Note: \ followed by other characters, while they may be useless since nothing is escaped, are not syntax errors.

However, this is problematic for tagged templates, which, in addition to the "cooked" literal, also have access to the raw literals (escape sequences are preserved as-is).
Tagged templates enable the embedding of arbitrary string content, where escape sequences may follow a different syntax. Consider for an example where we embed LaTeX source text in JavaScript via String.raw. We want to still be able to use LaTeX macros that start with u or x without following JavaScript syntax restrictions. Therefore, the syntax restriction of well-formed escape sequences is removed from tagged templates. The example below uses MathJax to render LaTeX in one element:
jsconst node = document.getElementById("formula");
MathJax.typesetClear([node]);
// Throws in older ECMAScript versions (ES2016 and earlier)
// SyntaxError: malformed Unicode character escape sequence
node.textContent = String.raw`$\underline{u}$`;
MathJax.typesetPromise([node]);

However, illegal escape sequences must still be represented in the "cooked" representation. They will show up as undefined element in the "cooked" array:
jsfunction log(str) {
  console.log("Cooked:", str[0]);
  console.log("Raw:", str.raw[0]);
}

log`\unicode`;
// Cooked: undefined
// Raw: \unicode

Note that the escape-sequence restriction is only dropped from tagged templates, but not from untagged template literals:
jsconst bad = `bad escape sequence: \unicode`;
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-template-literalsBrowser compatibilitySee also
Numbers and strings guide
String
String.raw()
Lexical grammar
ES6 in Depth: Template strings on hacks.mozilla.org (2015)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nTemplate literals (Template strings)Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackTemplate literals are literals delimited with backtick (`) characters, allowing for multi-line strings, string interpolation with embedded expressions, and special constructs called tagged templates.
Template literals are sometimes informally called template strings, because they are used most commonly for string interpolation (to create strings by doing substitution of placeholders). However, a tagged template literal may not result in a string; it can be used with a custom tag function to perform whatever operations you want on the different parts of the template literal.Syntaxjs`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tagFunction`string text ${expression} string text`
Parameters
string text

The string text that will become part of the template literal. Almost all characters are allowed literally, including line breaks and other whitespace characters. However, invalid escape sequences will cause a syntax error, unless a tag function is used.

expression

An expression to be inserted in the current position, whose value is converted to a string or passed to tagFunction.

tagFunction

If specified, it will be called with the template strings array and substitution expressions, and the return value becomes the value of the template literal. See tagged templates.

DescriptionTemplate literals are enclosed by backtick (`) characters instead of double or single quotes.
Along with having normal strings, template literals can also contain other parts called placeholders, which are embedded expressions delimited by a dollar sign and curly braces: ${expression}. The strings and placeholders get passed to a function — either a default function, or a function you supply. The default function (when you don't supply your own) just performs string interpolation to do substitution of the placeholders and then concatenate the parts into a single string.
To supply a function of your own, precede the template literal with a function name; the result is called a tagged template. In that case, the template literal is passed to your tag function, where you can then perform whatever operations you want on the different parts of the template literal.
To escape a backtick in a template literal, put a backslash (\) before the backtick.
js`\`` === "`"; // true

Dollar signs can be escaped as well to prevent interpolation.
js`\${1}` === "${1}"; // true
Multi-line stringsAny newline characters inserted in the source are part of the template literal.
Using normal strings, you would have to use the following syntax in order to get multi-line strings:
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
// string text line 2"

Using template literals, you can do the same with this:
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"

Like normal string literals, you can write a single-line string across multiple lines for source code readability, by escaping the newline with a backslash (\):
jsconsole.log(`string text line 1 \
string text line 2`);
// "string text line 1 string text line 2"
String interpolationWithout template literals, when you want to combine output from expressions with strings, you'd concatenate them using the addition operator +:
jsconst a = 5;
const b = 10;
console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");
// "Fifteen is 15 and
// not 20."

That can be hard to read – especially when you have multiple expressions.
With template literals, you can avoid the concatenation operator — and improve the readability of your code — by using placeholders of the form ${expression} to perform substitutions for embedded expressions:
jsconst a = 5;
const b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
// "Fifteen is 15 and
// not 20."

Note that there's a mild difference between the two syntaxes. Template literals coerce their expressions directly to strings, while addition coerces its operands to primitives first. For more information, see the reference page for the + operator.Nesting templatesIn certain cases, nesting a template is the easiest (and perhaps more readable) way to have configurable strings. Within a backtick-delimited template, it is simple to allow inner backticks by using them inside an ${expression} placeholder within the template.
For example, without template literals, if you wanted to return a certain value based on a particular condition, you could do something like the following:
jslet classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

With a template literal but without nesting, you could do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

With nesting of template literals, you can do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
Tagged templatesA more advanced form of template literals are tagged templates.
Tags allow you to parse template literals with a function. The first argument of a tag function contains an array of string values. The remaining arguments are related to the expressions.
The tag function can then perform whatever operations on these arguments you wish, and return the manipulated string. (Alternatively, it can return something completely different, as described in one of the following examples.)
The name of the function used for the tag can be whatever you want.
jsconst person = "Mike";
const age = 28;

function myTag(strings, personExp, ageExp) {
  const str0 = strings[0]; // "That "
  const str1 = strings[1]; // " is a "
  const str2 = strings[2]; // "."

  const ageStr = ageExp < 100 ? "youngster" : "centenarian";

  // We can even return a string built using a template literal
  return `${str0}${personExp}${str1}${ageStr}${str2}`;
}

const output = myTag`That ${person} is a ${age}.`;

console.log(output);
// That Mike is a youngster.

The tag does not have to be a plain identifier. You can use any expression with precedence greater than 16, which includes property access, function call, new expression, or even another tagged template literal.
jsconsole.log`Hello`; // [ 'Hello' ]
console.log.bind(1, 2)`Hello`; // 2 [ 'Hello' ]
new Function("console.log(arguments)")`Hello`; // [Arguments] { '0': [ 'Hello' ] }

function recursive(strings, ...values) {
  console.log(strings, values);
  return recursive;
}
recursive`Hello``World`;
// [ 'Hello' ] []
// [ 'World' ] []

While technically permitted by the syntax, untagged template literals are strings and will throw a TypeError when chained.
jsconsole.log(`Hello``World`); // TypeError: "Hello" is not a function

The only exception is optional chaining, which will throw a syntax error.
jsconsole.log?.`Hello`; // SyntaxError: Invalid tagged template on optional chain
console?.log`Hello`; // SyntaxError: Invalid tagged template on optional chain

Note that these two expressions are still parsable. This means they would not be subject to automatic semicolon insertion, which will only insert semicolons to fix code that's otherwise unparsable.
js// Still a syntax error
const a = console?.log
`Hello`

Tag functions don't even need to return a string!
jsfunction template(strings, ...keys) {
  return (...values) => {
    const dict = values[values.length - 1] || {};
    const result = [strings[0]];
    keys.forEach((key, i) => {
      const value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

const t1Closure = template`${0}${1}${0}!`;
// const t1Closure = template(["","","","!"],0,1,0);
t1Closure("Y", "A"); // "YAY!"

const t2Closure = template`${0} ${"foo"}!`;
// const t2Closure = template([""," ","!"],0,"foo");
t2Closure("Hello", { foo: "World" }); // "Hello World!"

const t3Closure = template`I'm ${"name"}. I'm almost ${"age"} years old.`;
// const t3Closure = template(["I'm ", ". I'm almost ", " years old."], "name", "age");
t3Closure("foo", { name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."
t3Closure({ name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."

The first argument received by the tag function is an array of strings. For any template literal, its length is equal to the number of substitutions (occurrences of ${…}) plus one, and is therefore always non-empty.
For any particular tagged template literal expression, the tag function will always be called with the exact same literal array, no matter how many times the literal is evaluated.
jsconst callHistory = [];

function tag(strings, ...values) {
  callHistory.push(strings);
  // Return a freshly made object
  return {};
}

function evaluateLiteral() {
  return tag`Hello, ${"world"}!`;
}

console.log(evaluateLiteral() === evaluateLiteral()); // false; each time `tag` is called, it returns a new object
console.log(callHistory[0] === callHistory[1]); // true; all evaluations of the same tagged literal would pass in the same strings array

This allows the tag to cache the result based on the identity of its first argument. To further ensure the array value's stability, the first argument and its raw property are both frozen, so you can't mutate them in any way.Raw stringsThe special raw property, available on the first argument to the tag function, allows you to access the raw strings as they were entered, without processing escape sequences.
jsfunction tag(strings) {
  console.log(strings.raw[0]);
}

tag`string text line 1 \n string text line 2`;
// Logs "string text line 1 \n string text line 2",
// including the two characters '\' and 'n'

In addition, the String.raw() method exists to create raw strings just like the default template function and string concatenation would create.
jsconst str = String.raw`Hi\n${2 + 3}!`;
// "Hi\\n5!"

str.length;
// 6

Array.from(str).join(",");
// "H,i,\\,n,5,!"

String.raw functions like an "identity" tag if the literal doesn't contain any escape sequences. In case you want an actual identity tag that always works as if the literal is untagged, you can make a custom function that passes the "cooked" (i.e., escape sequences are processed) literal array to String.raw, pretending they are raw strings.
jsconst identity = (strings, ...values) =>
  String.raw({ raw: strings }, ...values);
console.log(identity`Hi\n${2 + 3}!`);
// Hi
// 5!

This is useful for many tools which give special treatment to literals tagged by a particular name.
jsconst html = (strings, ...values) => String.raw({ raw: strings }, ...values);
// Some formatters will format this literal's content as HTML
const doc = html`<!doctype html>
  <html lang="en-US">
    <head>
      <title>Hello</title>
    </head>
    <body>
      <h1>Hello world!</h1>
    </body>
  </html>`;
Tagged templates and escape sequencesIn normal template literals, the escape sequences in string literals are all allowed. Any other non-well-formed escape sequence is a syntax error. This includes:

\ followed by any decimal digit other than 0, or \0 followed by a decimal digit; for example \9 and \07 (which is a deprecated syntax)
\x followed by fewer than two hex digits (including none); for example \xz
\u not followed by { and followed by fewer than four hex digits (including none); for example \uz
\u{} enclosing an invalid Unicode code point — it contains a non-hex digit, or its value is greater than 10FFFF; for example \u{110000} and \u{z}


Note: \ followed by other characters, while they may be useless since nothing is escaped, are not syntax errors.

However, this is problematic for tagged templates, which, in addition to the "cooked" literal, also have access to the raw literals (escape sequences are preserved as-is).
Tagged templates enable the embedding of arbitrary string content, where escape sequences may follow a different syntax. Consider for an example where we embed LaTeX source text in JavaScript via String.raw. We want to still be able to use LaTeX macros that start with u or x without following JavaScript syntax restrictions. Therefore, the syntax restriction of well-formed escape sequences is removed from tagged templates. The example below uses MathJax to render LaTeX in one element:
jsconst node = document.getElementById("formula");
MathJax.typesetClear([node]);
// Throws in older ECMAScript versions (ES2016 and earlier)
// SyntaxError: malformed Unicode character escape sequence
node.textContent = String.raw`$\underline{u}$`;
MathJax.typesetPromise([node]);

However, illegal escape sequences must still be represented in the "cooked" representation. They will show up as undefined element in the "cooked" array:
jsfunction log(str) {
  console.log("Cooked:", str[0]);
  console.log("Raw:", str.raw[0]);
}

log`\unicode`;
// Cooked: undefined
// Raw: \unicode

Note that the escape-sequence restriction is only dropped from tagged templates, but not from untagged template literals:
jsconst bad = `bad escape sequence: \unicode`;
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-template-literalsBrowser compatibilitySee also
Numbers and strings guide
String
String.raw()
Lexical grammar
ES6 in Depth: Template strings on hacks.mozilla.org (2015)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nTemplate literals (Template strings)Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackTemplate literals are literals delimited with backtick (`) characters, allowing for multi-line strings, string interpolation with embedded expressions, and special constructs called tagged templates.
Template literals are sometimes informally called template strings, because they are used most commonly for string interpolation (to create strings by doing substitution of placeholders). However, a tagged template literal may not result in a string; it can be used with a custom tag function to perform whatever operations you want on the different parts of the template literal.Syntaxjs`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tagFunction`string text ${expression} string text`
Parameters
string text

The string text that will become part of the template literal. Almost all characters are allowed literally, including line breaks and other whitespace characters. However, invalid escape sequences will cause a syntax error, unless a tag function is used.

expression

An expression to be inserted in the current position, whose value is converted to a string or passed to tagFunction.

tagFunction

If specified, it will be called with the template strings array and substitution expressions, and the return value becomes the value of the template literal. See tagged templates.

DescriptionTemplate literals are enclosed by backtick (`) characters instead of double or single quotes.
Along with having normal strings, template literals can also contain other parts called placeholders, which are embedded expressions delimited by a dollar sign and curly braces: ${expression}. The strings and placeholders get passed to a function — either a default function, or a function you supply. The default function (when you don't supply your own) just performs string interpolation to do substitution of the placeholders and then concatenate the parts into a single string.
To supply a function of your own, precede the template literal with a function name; the result is called a tagged template. In that case, the template literal is passed to your tag function, where you can then perform whatever operations you want on the different parts of the template literal.
To escape a backtick in a template literal, put a backslash (\) before the backtick.
js`\`` === "`"; // true

Dollar signs can be escaped as well to prevent interpolation.
js`\${1}` === "${1}"; // true
Multi-line stringsAny newline characters inserted in the source are part of the template literal.
Using normal strings, you would have to use the following syntax in order to get multi-line strings:
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
// string text line 2"

Using template literals, you can do the same with this:
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"

Like normal string literals, you can write a single-line string across multiple lines for source code readability, by escaping the newline with a backslash (\):
jsconsole.log(`string text line 1 \
string text line 2`);
// "string text line 1 string text line 2"
String interpolationWithout template literals, when you want to combine output from expressions with strings, you'd concatenate them using the addition operator +:
jsconst a = 5;
const b = 10;
console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");
// "Fifteen is 15 and
// not 20."

That can be hard to read – especially when you have multiple expressions.
With template literals, you can avoid the concatenation operator — and improve the readability of your code — by using placeholders of the form ${expression} to perform substitutions for embedded expressions:
jsconst a = 5;
const b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
// "Fifteen is 15 and
// not 20."

Note that there's a mild difference between the two syntaxes. Template literals coerce their expressions directly to strings, while addition coerces its operands to primitives first. For more information, see the reference page for the + operator.Nesting templatesIn certain cases, nesting a template is the easiest (and perhaps more readable) way to have configurable strings. Within a backtick-delimited template, it is simple to allow inner backticks by using them inside an ${expression} placeholder within the template.
For example, without template literals, if you wanted to return a certain value based on a particular condition, you could do something like the following:
jslet classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

With a template literal but without nesting, you could do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

With nesting of template literals, you can do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
Tagged templatesA more advanced form of template literals are tagged templates.
Tags allow you to parse template literals with a function. The first argument of a tag function contains an array of string values. The remaining arguments are related to the expressions.
The tag function can then perform whatever operations on these arguments you wish, and return the manipulated string. (Alternatively, it can return something completely different, as described in one of the following examples.)
The name of the function used for the tag can be whatever you want.
jsconst person = "Mike";
const age = 28;

function myTag(strings, personExp, ageExp) {
  const str0 = strings[0]; // "That "
  const str1 = strings[1]; // " is a "
  const str2 = strings[2]; // "."

  const ageStr = ageExp < 100 ? "youngster" : "centenarian";

  // We can even return a string built using a template literal
  return `${str0}${personExp}${str1}${ageStr}${str2}`;
}

const output = myTag`That ${person} is a ${age}.`;

console.log(output);
// That Mike is a youngster.

The tag does not have to be a plain identifier. You can use any expression with precedence greater than 16, which includes property access, function call, new expression, or even another tagged template literal.
jsconsole.log`Hello`; // [ 'Hello' ]
console.log.bind(1, 2)`Hello`; // 2 [ 'Hello' ]
new Function("console.log(arguments)")`Hello`; // [Arguments] { '0': [ 'Hello' ] }

function recursive(strings, ...values) {
  console.log(strings, values);
  return recursive;
}
recursive`Hello``World`;
// [ 'Hello' ] []
// [ 'World' ] []

While technically permitted by the syntax, untagged template literals are strings and will throw a TypeError when chained.
jsconsole.log(`Hello``World`); // TypeError: "Hello" is not a function

The only exception is optional chaining, which will throw a syntax error.
jsconsole.log?.`Hello`; // SyntaxError: Invalid tagged template on optional chain
console?.log`Hello`; // SyntaxError: Invalid tagged template on optional chain

Note that these two expressions are still parsable. This means they would not be subject to automatic semicolon insertion, which will only insert semicolons to fix code that's otherwise unparsable.
js// Still a syntax error
const a = console?.log
`Hello`

Tag functions don't even need to return a string!
jsfunction template(strings, ...keys) {
  return (...values) => {
    const dict = values[values.length - 1] || {};
    const result = [strings[0]];
    keys.forEach((key, i) => {
      const value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

const t1Closure = template`${0}${1}${0}!`;
// const t1Closure = template(["","","","!"],0,1,0);
t1Closure("Y", "A"); // "YAY!"

const t2Closure = template`${0} ${"foo"}!`;
// const t2Closure = template([""," ","!"],0,"foo");
t2Closure("Hello", { foo: "World" }); // "Hello World!"

const t3Closure = template`I'm ${"name"}. I'm almost ${"age"} years old.`;
// const t3Closure = template(["I'm ", ". I'm almost ", " years old."], "name", "age");
t3Closure("foo", { name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."
t3Closure({ name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."

The first argument received by the tag function is an array of strings. For any template literal, its length is equal to the number of substitutions (occurrences of ${…}) plus one, and is therefore always non-empty.
For any particular tagged template literal expression, the tag function will always be called with the exact same literal array, no matter how many times the literal is evaluated.
jsconst callHistory = [];

function tag(strings, ...values) {
  callHistory.push(strings);
  // Return a freshly made object
  return {};
}

function evaluateLiteral() {
  return tag`Hello, ${"world"}!`;
}

console.log(evaluateLiteral() === evaluateLiteral()); // false; each time `tag` is called, it returns a new object
console.log(callHistory[0] === callHistory[1]); // true; all evaluations of the same tagged literal would pass in the same strings array

This allows the tag to cache the result based on the identity of its first argument. To further ensure the array value's stability, the first argument and its raw property are both frozen, so you can't mutate them in any way.Raw stringsThe special raw property, available on the first argument to the tag function, allows you to access the raw strings as they were entered, without processing escape sequences.
jsfunction tag(strings) {
  console.log(strings.raw[0]);
}

tag`string text line 1 \n string text line 2`;
// Logs "string text line 1 \n string text line 2",
// including the two characters '\' and 'n'

In addition, the String.raw() method exists to create raw strings just like the default template function and string concatenation would create.
jsconst str = String.raw`Hi\n${2 + 3}!`;
// "Hi\\n5!"

str.length;
// 6

Array.from(str).join(",");
// "H,i,\\,n,5,!"

String.raw functions like an "identity" tag if the literal doesn't contain any escape sequences. In case you want an actual identity tag that always works as if the literal is untagged, you can make a custom function that passes the "cooked" (i.e., escape sequences are processed) literal array to String.raw, pretending they are raw strings.
jsconst identity = (strings, ...values) =>
  String.raw({ raw: strings }, ...values);
console.log(identity`Hi\n${2 + 3}!`);
// Hi
// 5!

This is useful for many tools which give special treatment to literals tagged by a particular name.
jsconst html = (strings, ...values) => String.raw({ raw: strings }, ...values);
// Some formatters will format this literal's content as HTML
const doc = html`<!doctype html>
  <html lang="en-US">
    <head>
      <title>Hello</title>
    </head>
    <body>
      <h1>Hello world!</h1>
    </body>
  </html>`;
Tagged templates and escape sequencesIn normal template literals, the escape sequences in string literals are all allowed. Any other non-well-formed escape sequence is a syntax error. This includes:

\ followed by any decimal digit other than 0, or \0 followed by a decimal digit; for example \9 and \07 (which is a deprecated syntax)
\x followed by fewer than two hex digits (including none); for example \xz
\u not followed by { and followed by fewer than four hex digits (including none); for example \uz
\u{} enclosing an invalid Unicode code point — it contains a non-hex digit, or its value is greater than 10FFFF; for example \u{110000} and \u{z}


Note: \ followed by other characters, while they may be useless since nothing is escaped, are not syntax errors.

However, this is problematic for tagged templates, which, in addition to the "cooked" literal, also have access to the raw literals (escape sequences are preserved as-is).
Tagged templates enable the embedding of arbitrary string content, where escape sequences may follow a different syntax. Consider for an example where we embed LaTeX source text in JavaScript via String.raw. We want to still be able to use LaTeX macros that start with u or x without following JavaScript syntax restrictions. Therefore, the syntax restriction of well-formed escape sequences is removed from tagged templates. The example below uses MathJax to render LaTeX in one element:
jsconst node = document.getElementById("formula");
MathJax.typesetClear([node]);
// Throws in older ECMAScript versions (ES2016 and earlier)
// SyntaxError: malformed Unicode character escape sequence
node.textContent = String.raw`$\underline{u}$`;
MathJax.typesetPromise([node]);

However, illegal escape sequences must still be represented in the "cooked" representation. They will show up as undefined element in the "cooked" array:
jsfunction log(str) {
  console.log("Cooked:", str[0]);
  console.log("Raw:", str.raw[0]);
}

log`\unicode`;
// Cooked: undefined
// Raw: \unicode

Note that the escape-sequence restriction is only dropped from tagged templates, but not from untagged template literals:
jsconst bad = `bad escape sequence: \unicode`;
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-template-literalsBrowser compatibilitySee also
Numbers and strings guide
String
String.raw()
Lexical grammar
ES6 in Depth: Template strings on hacks.mozilla.org (2015)\n\nTemplate literals (Template strings)Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackTemplate literals are literals delimited with backtick (`) characters, allowing for multi-line strings, string interpolation with embedded expressions, and special constructs called tagged templates.
Template literals are sometimes informally called template strings, because they are used most commonly for string interpolation (to create strings by doing substitution of placeholders). However, a tagged template literal may not result in a string; it can be used with a custom tag function to perform whatever operations you want on the different parts of the template literal.Syntaxjs`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tagFunction`string text ${expression} string text`
Parameters
string text

The string text that will become part of the template literal. Almost all characters are allowed literally, including line breaks and other whitespace characters. However, invalid escape sequences will cause a syntax error, unless a tag function is used.

expression

An expression to be inserted in the current position, whose value is converted to a string or passed to tagFunction.

tagFunction

If specified, it will be called with the template strings array and substitution expressions, and the return value becomes the value of the template literal. See tagged templates.

DescriptionTemplate literals are enclosed by backtick (`) characters instead of double or single quotes.
Along with having normal strings, template literals can also contain other parts called placeholders, which are embedded expressions delimited by a dollar sign and curly braces: ${expression}. The strings and placeholders get passed to a function — either a default function, or a function you supply. The default function (when you don't supply your own) just performs string interpolation to do substitution of the placeholders and then concatenate the parts into a single string.
To supply a function of your own, precede the template literal with a function name; the result is called a tagged template. In that case, the template literal is passed to your tag function, where you can then perform whatever operations you want on the different parts of the template literal.
To escape a backtick in a template literal, put a backslash (\) before the backtick.
js`\`` === "`"; // true

Dollar signs can be escaped as well to prevent interpolation.
js`\${1}` === "${1}"; // true
Multi-line stringsAny newline characters inserted in the source are part of the template literal.
Using normal strings, you would have to use the following syntax in order to get multi-line strings:
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
// string text line 2"

Using template literals, you can do the same with this:
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"

Like normal string literals, you can write a single-line string across multiple lines for source code readability, by escaping the newline with a backslash (\):
jsconsole.log(`string text line 1 \
string text line 2`);
// "string text line 1 string text line 2"
String interpolationWithout template literals, when you want to combine output from expressions with strings, you'd concatenate them using the addition operator +:
jsconst a = 5;
const b = 10;
console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");
// "Fifteen is 15 and
// not 20."

That can be hard to read – especially when you have multiple expressions.
With template literals, you can avoid the concatenation operator — and improve the readability of your code — by using placeholders of the form ${expression} to perform substitutions for embedded expressions:
jsconst a = 5;
const b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
// "Fifteen is 15 and
// not 20."

Note that there's a mild difference between the two syntaxes. Template literals coerce their expressions directly to strings, while addition coerces its operands to primitives first. For more information, see the reference page for the + operator.Nesting templatesIn certain cases, nesting a template is the easiest (and perhaps more readable) way to have configurable strings. Within a backtick-delimited template, it is simple to allow inner backticks by using them inside an ${expression} placeholder within the template.
For example, without template literals, if you wanted to return a certain value based on a particular condition, you could do something like the following:
jslet classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

With a template literal but without nesting, you could do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

With nesting of template literals, you can do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
Tagged templatesA more advanced form of template literals are tagged templates.
Tags allow you to parse template literals with a function. The first argument of a tag function contains an array of string values. The remaining arguments are related to the expressions.
The tag function can then perform whatever operations on these arguments you wish, and return the manipulated string. (Alternatively, it can return something completely different, as described in one of the following examples.)
The name of the function used for the tag can be whatever you want.
jsconst person = "Mike";
const age = 28;

function myTag(strings, personExp, ageExp) {
  const str0 = strings[0]; // "That "
  const str1 = strings[1]; // " is a "
  const str2 = strings[2]; // "."

  const ageStr = ageExp < 100 ? "youngster" : "centenarian";

  // We can even return a string built using a template literal
  return `${str0}${personExp}${str1}${ageStr}${str2}`;
}

const output = myTag`That ${person} is a ${age}.`;

console.log(output);
// That Mike is a youngster.

The tag does not have to be a plain identifier. You can use any expression with precedence greater than 16, which includes property access, function call, new expression, or even another tagged template literal.
jsconsole.log`Hello`; // [ 'Hello' ]
console.log.bind(1, 2)`Hello`; // 2 [ 'Hello' ]
new Function("console.log(arguments)")`Hello`; // [Arguments] { '0': [ 'Hello' ] }

function recursive(strings, ...values) {
  console.log(strings, values);
  return recursive;
}
recursive`Hello``World`;
// [ 'Hello' ] []
// [ 'World' ] []

While technically permitted by the syntax, untagged template literals are strings and will throw a TypeError when chained.
jsconsole.log(`Hello``World`); // TypeError: "Hello" is not a function

The only exception is optional chaining, which will throw a syntax error.
jsconsole.log?.`Hello`; // SyntaxError: Invalid tagged template on optional chain
console?.log`Hello`; // SyntaxError: Invalid tagged template on optional chain

Note that these two expressions are still parsable. This means they would not be subject to automatic semicolon insertion, which will only insert semicolons to fix code that's otherwise unparsable.
js// Still a syntax error
const a = console?.log
`Hello`

Tag functions don't even need to return a string!
jsfunction template(strings, ...keys) {
  return (...values) => {
    const dict = values[values.length - 1] || {};
    const result = [strings[0]];
    keys.forEach((key, i) => {
      const value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

const t1Closure = template`${0}${1}${0}!`;
// const t1Closure = template(["","","","!"],0,1,0);
t1Closure("Y", "A"); // "YAY!"

const t2Closure = template`${0} ${"foo"}!`;
// const t2Closure = template([""," ","!"],0,"foo");
t2Closure("Hello", { foo: "World" }); // "Hello World!"

const t3Closure = template`I'm ${"name"}. I'm almost ${"age"} years old.`;
// const t3Closure = template(["I'm ", ". I'm almost ", " years old."], "name", "age");
t3Closure("foo", { name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."
t3Closure({ name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."

The first argument received by the tag function is an array of strings. For any template literal, its length is equal to the number of substitutions (occurrences of ${…}) plus one, and is therefore always non-empty.
For any particular tagged template literal expression, the tag function will always be called with the exact same literal array, no matter how many times the literal is evaluated.
jsconst callHistory = [];

function tag(strings, ...values) {
  callHistory.push(strings);
  // Return a freshly made object
  return {};
}

function evaluateLiteral() {
  return tag`Hello, ${"world"}!`;
}

console.log(evaluateLiteral() === evaluateLiteral()); // false; each time `tag` is called, it returns a new object
console.log(callHistory[0] === callHistory[1]); // true; all evaluations of the same tagged literal would pass in the same strings array

This allows the tag to cache the result based on the identity of its first argument. To further ensure the array value's stability, the first argument and its raw property are both frozen, so you can't mutate them in any way.Raw stringsThe special raw property, available on the first argument to the tag function, allows you to access the raw strings as they were entered, without processing escape sequences.
jsfunction tag(strings) {
  console.log(strings.raw[0]);
}

tag`string text line 1 \n string text line 2`;
// Logs "string text line 1 \n string text line 2",
// including the two characters '\' and 'n'

In addition, the String.raw() method exists to create raw strings just like the default template function and string concatenation would create.
jsconst str = String.raw`Hi\n${2 + 3}!`;
// "Hi\\n5!"

str.length;
// 6

Array.from(str).join(",");
// "H,i,\\,n,5,!"

String.raw functions like an "identity" tag if the literal doesn't contain any escape sequences. In case you want an actual identity tag that always works as if the literal is untagged, you can make a custom function that passes the "cooked" (i.e., escape sequences are processed) literal array to String.raw, pretending they are raw strings.
jsconst identity = (strings, ...values) =>
  String.raw({ raw: strings }, ...values);
console.log(identity`Hi\n${2 + 3}!`);
// Hi
// 5!

This is useful for many tools which give special treatment to literals tagged by a particular name.
jsconst html = (strings, ...values) => String.raw({ raw: strings }, ...values);
// Some formatters will format this literal's content as HTML
const doc = html`<!doctype html>
  <html lang="en-US">
    <head>
      <title>Hello</title>
    </head>
    <body>
      <h1>Hello world!</h1>
    </body>
  </html>`;
Tagged templates and escape sequencesIn normal template literals, the escape sequences in string literals are all allowed. Any other non-well-formed escape sequence is a syntax error. This includes:

\ followed by any decimal digit other than 0, or \0 followed by a decimal digit; for example \9 and \07 (which is a deprecated syntax)
\x followed by fewer than two hex digits (including none); for example \xz
\u not followed by { and followed by fewer than four hex digits (including none); for example \uz
\u{} enclosing an invalid Unicode code point — it contains a non-hex digit, or its value is greater than 10FFFF; for example \u{110000} and \u{z}


Note: \ followed by other characters, while they may be useless since nothing is escaped, are not syntax errors.

However, this is problematic for tagged templates, which, in addition to the "cooked" literal, also have access to the raw literals (escape sequences are preserved as-is).
Tagged templates enable the embedding of arbitrary string content, where escape sequences may follow a different syntax. Consider for an example where we embed LaTeX source text in JavaScript via String.raw. We want to still be able to use LaTeX macros that start with u or x without following JavaScript syntax restrictions. Therefore, the syntax restriction of well-formed escape sequences is removed from tagged templates. The example below uses MathJax to render LaTeX in one element:
jsconst node = document.getElementById("formula");
MathJax.typesetClear([node]);
// Throws in older ECMAScript versions (ES2016 and earlier)
// SyntaxError: malformed Unicode character escape sequence
node.textContent = String.raw`$\underline{u}$`;
MathJax.typesetPromise([node]);

However, illegal escape sequences must still be represented in the "cooked" representation. They will show up as undefined element in the "cooked" array:
jsfunction log(str) {
  console.log("Cooked:", str[0]);
  console.log("Raw:", str.raw[0]);
}

log`\unicode`;
// Cooked: undefined
// Raw: \unicode

Note that the escape-sequence restriction is only dropped from tagged templates, but not from untagged template literals:
jsconst bad = `bad escape sequence: \unicode`;
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-template-literalsBrowser compatibilitySee also
Numbers and strings guide
String
String.raw()
Lexical grammar
ES6 in Depth: Template strings on hacks.mozilla.org (2015)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nTemplate literals (Template strings)Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackTemplate literals are literals delimited with backtick (`) characters, allowing for multi-line strings, string interpolation with embedded expressions, and special constructs called tagged templates.
Template literals are sometimes informally called template strings, because they are used most commonly for string interpolation (to create strings by doing substitution of placeholders). However, a tagged template literal may not result in a string; it can be used with a custom tag function to perform whatever operations you want on the different parts of the template literal.Syntaxjs`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tagFunction`string text ${expression} string text`
Parameters
string text

The string text that will become part of the template literal. Almost all characters are allowed literally, including line breaks and other whitespace characters. However, invalid escape sequences will cause a syntax error, unless a tag function is used.

expression

An expression to be inserted in the current position, whose value is converted to a string or passed to tagFunction.

tagFunction

If specified, it will be called with the template strings array and substitution expressions, and the return value becomes the value of the template literal. See tagged templates.

DescriptionTemplate literals are enclosed by backtick (`) characters instead of double or single quotes.
Along with having normal strings, template literals can also contain other parts called placeholders, which are embedded expressions delimited by a dollar sign and curly braces: ${expression}. The strings and placeholders get passed to a function — either a default function, or a function you supply. The default function (when you don't supply your own) just performs string interpolation to do substitution of the placeholders and then concatenate the parts into a single string.
To supply a function of your own, precede the template literal with a function name; the result is called a tagged template. In that case, the template literal is passed to your tag function, where you can then perform whatever operations you want on the different parts of the template literal.
To escape a backtick in a template literal, put a backslash (\) before the backtick.
js`\`` === "`"; // true

Dollar signs can be escaped as well to prevent interpolation.
js`\${1}` === "${1}"; // true
Multi-line stringsAny newline characters inserted in the source are part of the template literal.
Using normal strings, you would have to use the following syntax in order to get multi-line strings:
jsconsole.log("string text line 1\n" + "string text line 2");
// "string text line 1
// string text line 2"

Using template literals, you can do the same with this:
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"

Like normal string literals, you can write a single-line string across multiple lines for source code readability, by escaping the newline with a backslash (\):
jsconsole.log(`string text line 1 \
string text line 2`);
// "string text line 1 string text line 2"
String interpolationWithout template literals, when you want to combine output from expressions with strings, you'd concatenate them using the addition operator +:
jsconst a = 5;
const b = 10;
console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");
// "Fifteen is 15 and
// not 20."

That can be hard to read – especially when you have multiple expressions.
With template literals, you can avoid the concatenation operator — and improve the readability of your code — by using placeholders of the form ${expression} to perform substitutions for embedded expressions:
jsconst a = 5;
const b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
// "Fifteen is 15 and
// not 20."

Note that there's a mild difference between the two syntaxes. Template literals coerce their expressions directly to strings, while addition coerces its operands to primitives first. For more information, see the reference page for the + operator.Nesting templatesIn certain cases, nesting a template is the easiest (and perhaps more readable) way to have configurable strings. Within a backtick-delimited template, it is simple to allow inner backticks by using them inside an ${expression} placeholder within the template.
For example, without template literals, if you wanted to return a certain value based on a particular condition, you could do something like the following:
jslet classes = "header";
classes += isLargeScreen()
  ? ""
  : item.isCollapsed
    ? " icon-expander"
    : " icon-collapser";

With a template literal but without nesting, you could do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : item.isCollapsed ? "icon-expander" : "icon-collapser"
}`;

With nesting of template literals, you can do this:
jsconst classes = `header ${
  isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
}`;
Tagged templatesA more advanced form of template literals are tagged templates.
Tags allow you to parse template literals with a function. The first argument of a tag function contains an array of string values. The remaining arguments are related to the expressions.
The tag function can then perform whatever operations on these arguments you wish, and return the manipulated string. (Alternatively, it can return something completely different, as described in one of the following examples.)
The name of the function used for the tag can be whatever you want.
jsconst person = "Mike";
const age = 28;

function myTag(strings, personExp, ageExp) {
  const str0 = strings[0]; // "That "
  const str1 = strings[1]; // " is a "
  const str2 = strings[2]; // "."

  const ageStr = ageExp < 100 ? "youngster" : "centenarian";

  // We can even return a string built using a template literal
  return `${str0}${personExp}${str1}${ageStr}${str2}`;
}

const output = myTag`That ${person} is a ${age}.`;

console.log(output);
// That Mike is a youngster.

The tag does not have to be a plain identifier. You can use any expression with precedence greater than 16, which includes property access, function call, new expression, or even another tagged template literal.
jsconsole.log`Hello`; // [ 'Hello' ]
console.log.bind(1, 2)`Hello`; // 2 [ 'Hello' ]
new Function("console.log(arguments)")`Hello`; // [Arguments] { '0': [ 'Hello' ] }

function recursive(strings, ...values) {
  console.log(strings, values);
  return recursive;
}
recursive`Hello``World`;
// [ 'Hello' ] []
// [ 'World' ] []

While technically permitted by the syntax, untagged template literals are strings and will throw a TypeError when chained.
jsconsole.log(`Hello``World`); // TypeError: "Hello" is not a function

The only exception is optional chaining, which will throw a syntax error.
jsconsole.log?.`Hello`; // SyntaxError: Invalid tagged template on optional chain
console?.log`Hello`; // SyntaxError: Invalid tagged template on optional chain

Note that these two expressions are still parsable. This means they would not be subject to automatic semicolon insertion, which will only insert semicolons to fix code that's otherwise unparsable.
js// Still a syntax error
const a = console?.log
`Hello`

Tag functions don't even need to return a string!
jsfunction template(strings, ...keys) {
  return (...values) => {
    const dict = values[values.length - 1] || {};
    const result = [strings[0]];
    keys.forEach((key, i) => {
      const value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join("");
  };
}

const t1Closure = template`${0}${1}${0}!`;
// const t1Closure = template(["","","","!"],0,1,0);
t1Closure("Y", "A"); // "YAY!"

const t2Closure = template`${0} ${"foo"}!`;
// const t2Closure = template([""," ","!"],0,"foo");
t2Closure("Hello", { foo: "World" }); // "Hello World!"

const t3Closure = template`I'm ${"name"}. I'm almost ${"age"} years old.`;
// const t3Closure = template(["I'm ", ". I'm almost ", " years old."], "name", "age");
t3Closure("foo", { name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."
t3Closure({ name: "MDN", age: 30 }); // "I'm MDN. I'm almost 30 years old."

The first argument received by the tag function is an array of strings. For any template literal, its length is equal to the number of substitutions (occurrences of ${…}) plus one, and is therefore always non-empty.
For any particular tagged template literal expression, the tag function will always be called with the exact same literal array, no matter how many times the literal is evaluated.
jsconst callHistory = [];

function tag(strings, ...values) {
  callHistory.push(strings);
  // Return a freshly made object
  return {};
}

function evaluateLiteral() {
  return tag`Hello, ${"world"}!`;
}

console.log(evaluateLiteral() === evaluateLiteral()); // false; each time `tag` is called, it returns a new object
console.log(callHistory[0] === callHistory[1]); // true; all evaluations of the same tagged literal would pass in the same strings array

This allows the tag to cache the result based on the identity of its first argument. To further ensure the array value's stability, the first argument and its raw property are both frozen, so you can't mutate them in any way.Raw stringsThe special raw property, available on the first argument to the tag function, allows you to access the raw strings as they were entered, without processing escape sequences.
jsfunction tag(strings) {
  console.log(strings.raw[0]);
}

tag`string text line 1 \n string text line 2`;
// Logs "string text line 1 \n string text line 2",
// including the two characters '\' and 'n'

In addition, the String.raw() method exists to create raw strings just like the default template function and string concatenation would create.
jsconst str = String.raw`Hi\n${2 + 3}!`;
// "Hi\\n5!"

str.length;
// 6

Array.from(str).join(",");
// "H,i,\\,n,5,!"

String.raw functions like an "identity" tag if the literal doesn't contain any escape sequences. In case you want an actual identity tag that always works as if the literal is untagged, you can make a custom function that passes the "cooked" (i.e., escape sequences are processed) literal array to String.raw, pretending they are raw strings.
jsconst identity = (strings, ...values) =>
  String.raw({ raw: strings }, ...values);
console.log(identity`Hi\n${2 + 3}!`);
// Hi
// 5!

This is useful for many tools which give special treatment to literals tagged by a particular name.
jsconst html = (strings, ...values) => String.raw({ raw: strings }, ...values);
// Some formatters will format this literal's content as HTML
const doc = html`<!doctype html>
  <html lang="en-US">
    <head>
      <title>Hello</title>
    </head>
    <body>
      <h1>Hello world!</h1>
    </body>
  </html>`;
Tagged templates and escape sequencesIn normal template literals, the escape sequences in string literals are all allowed. Any other non-well-formed escape sequence is a syntax error. This includes:

\ followed by any decimal digit other than 0, or \0 followed by a decimal digit; for example \9 and \07 (which is a deprecated syntax)
\x followed by fewer than two hex digits (including none); for example \xz
\u not followed by { and followed by fewer than four hex digits (including none); for example \uz
\u{} enclosing an invalid Unicode code point — it contains a non-hex digit, or its value is greater than 10FFFF; for example \u{110000} and \u{z}


Note: \ followed by other characters, while they may be useless since nothing is escaped, are not syntax errors.

However, this is problematic for tagged templates, which, in addition to the "cooked" literal, also have access to the raw literals (escape sequences are preserved as-is).
Tagged templates enable the embedding of arbitrary string content, where escape sequences may follow a different syntax. Consider for an example where we embed LaTeX source text in JavaScript via String.raw. We want to still be able to use LaTeX macros that start with u or x without following JavaScript syntax restrictions. Therefore, the syntax restriction of well-formed escape sequences is removed from tagged templates. The example below uses MathJax to render LaTeX in one element:
jsconst node = document.getElementById("formula");
MathJax.typesetClear([node]);
// Throws in older ECMAScript versions (ES2016 and earlier)
// SyntaxError: malformed Unicode character escape sequence
node.textContent = String.raw`$\underline{u}$`;
MathJax.typesetPromise([node]);

However, illegal escape sequences must still be represented in the "cooked" representation. They will show up as undefined element in the "cooked" array:
jsfunction log(str) {
  console.log("Cooked:", str[0]);
  console.log("Raw:", str.raw[0]);
}

log`\unicode`;
// Cooked: undefined
// Raw: \unicode

Note that the escape-sequence restriction is only dropped from tagged templates, but not from untagged template literals:
jsconst bad = `bad escape sequence: \unicode`;
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-template-literalsBrowser compatibilitySee also
Numbers and strings guide
String
String.raw()
Lexical grammar
ES6 in Depth: Template strings on hacks.mozilla.org (2015)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJavaScript: Adding interactivity Previous  Overview: Your first website Next  
JavaScript is a programming language that adds interactivity to websites. This happens in games, in the behavior of responses when buttons are pressed or with data entry on forms, with dynamic styling, with animation, etc. This article helps you get started with JavaScript and furthers your understanding of what is possible.

  
    
      Prerequisites:
      
        Basic familiarity with your computer operating system, the basic software you will use to build a website, and file systems.
      
    
    
      Learning outcomes:
      
        
          The purpose and function of JavaScript.
          JavaScript language fundamentals such as variables, operators, conditionals, functions, and events.
        
      
    
  
What is JavaScript?JavaScript is a powerful programming language that can add interactivity to a website.
It was invented by Brendan Eich.
JavaScript is versatile and beginner-friendly.
With more experience, you'll be able to create games, animated 2D and 3D graphics, comprehensive database-driven apps, and much more!
JavaScript itself is relatively compact, yet very flexible. Developers have written a variety of tools on top of the core JavaScript language, unlocking a vast amount of functionality with minimum effort. These include:

Browser Application Programming Interfaces (APIs) built into web browsers, providing functionality such as dynamically creating HTML and setting CSS styles, collecting and manipulating a video stream from a user's webcam, or generating 3D graphics and audio samples.
Third-party APIs that allow developers to incorporate functionality in sites from other content providers, such as YouTube or Facebook.
Third-party frameworks and libraries that you can apply to HTML to accelerate the work of building sites and applications.

It's outside the scope of this article—as a light introduction to JavaScript—to present the details of how the core JavaScript language is different from the tools listed above. You can learn more in our Core modules, as well as in other parts of MDN.
The section below introduces some aspects of the core language and offers an opportunity to play with a few browser API features too. Have fun!A "Hello world!" exampleJavaScript is one of the most popular modern web technologies! As your JavaScript skills grow, your websites will enter a new dimension of power and creativity.
However, getting comfortable with JavaScript is more challenging than getting comfortable with HTML and CSS. You should start small, and progress gradually. To begin, let's examine how to add JavaScript to your page for creating a Hello world! example. (Hello world! is the standard for introductory programming examples.)

Warning:
If you haven't been following along with the rest of our course, download this example code and use it as a starting point.



Inside your first-website folder or the example folder you have just downloaded, create a new folder named scripts.


Within the scripts folder, create a new text document called main.js, and save it.


Go to your index.html file and enter this code on a new line, just before the closing </body> tag:
html<script src="scripts/main.js"></script>

This is doing the same job as the <link> element for CSS. It applies the JavaScript to the page, so it can have an effect on the HTML (along with the CSS, and anything else on the page).


Add this code to your scripts/main.js file:
jsconst myHeading = document.querySelector("h1");
myHeading.textContent = "Hello world!";



Make sure the HTML and JavaScript files are saved, then load index.html in your browser. You should see something like this:




Note:
The reason the above instructions place the <script> element near the bottom of the HTML file is that the browser reads code in the order it appears in the file.
If the JavaScript loads first and it is supposed to affect the HTML that hasn't loaded yet, there could be problems. Placing JavaScript near the bottom of an HTML page is one way to accommodate this dependency.
What happened?We have used JavaScript to change the heading text to Hello world!. We did this by using a function called querySelector() to grab a reference to your heading, and then store it in a variable called myHeading. This is similar to what we did using CSS selectors. When you want to do something to an element, you need to select it first.
Following that, the code set the value of the myHeading variable's textContent property (which represents the content of the heading) to Hello world!.

Note:
Both of the features you used in this exercise are parts of the Document Object Model (DOM) API, which has the capability to manipulate documents.
Language basics crash courseTo give you a better understanding of how JavaScript works, let's explain some of the core features of the language. It's worth noting that these features are common to all programming languages. If you master these fundamentals, you have a head start on coding in other languages too!

Warning:
In this article, try entering the example code lines into your JavaScript console to see what happens. For more details on JavaScript consoles, see Discover browser developer tools.
VariablesVariables are containers that store values. You start by declaring a variable with the let keyword, followed by the name you give to the variable:
jslet myVariable;

A semicolon at the end of a line indicates where a statement ends. It is only required when you need to separate statements on a single line. However, some people believe it's good practice to have semicolons at the end of each statement. There are other rules for when you should and shouldn't use semicolons. For more details, see Your Guide to Semicolons in JavaScript.
You can name a variable nearly anything, but there are some restrictions. (See this section about naming rules.) If you are unsure, you can check your variable name to see if it's valid.
JavaScript is case sensitive. This means myVariable is not the same as myvariable. If you have problems in your code, check the case!
After declaring a variable, you can give it a value:
jsmyVariable = "Bob";

Also, you can do both these operations on the same line:
jslet myVariable = "Bob";

You retrieve the value by calling the variable name:
jsmyVariable;

After assigning a value to a variable, you can change it later in the code:
jslet myVariable = "Bob";
myVariable = "Steve";

Note that variables may hold values that have different data types:

  
    
      Variable
      Explanation
      Example
    
  
  
    
      String
      
        This is a sequence of text known as a string. To signify that the value
        is a string, enclose it in single or double quote marks.
      
      let myVariable = 'Bob'; or let myVariable = "Bob";
    
    
      Number
      This is a number. Numbers don't have quotes around them.
      let myVariable = 10;
    
    
      Boolean
      
        This is a True/False value. The words true and
        false are special keywords that don't need quote marks.
      
      let myVariable = true;
    
    
      Array
      
        This is a structure that allows you to store multiple values in a single
        reference.
      
      
        let myVariable = [1,'Bob','Steve',10];Refer to each
        member of the array like this:myVariable[0],
        myVariable[1], etc.
      
    
    
      Object
      
        This can be anything. Everything in JavaScript is an object and can be
        stored in a variable. Keep this in mind as you learn.
      
      
        let myVariable = document.querySelector('h1');All of
        the above examples too.
      
    
  

So why do we need variables? Variables are necessary to do anything interesting in programming. If values couldn't change, then you couldn't do anything dynamic, like personalize a greeting message or change an image displayed in an image gallery.CommentsComments are snippets of text that can be added along with code. The browser ignores text marked as comments. You can write comments in JavaScript just as you can in CSS:
js/*
Everything in between is a comment.
*/

If your comment contains no line breaks, you can put it behind two slashes like this:
js// This is a comment
OperatorsAn operator is a mathematical symbol that produces a result based on two values (or variables). In the following table, you can see some of the simplest operators, along with some examples to try in the JavaScript console.

  
    
      Operator
      Explanation
      Symbol(s)
      Example
    
  
  
    
      Addition
      Add two numbers together or combine two strings.
      +
      
        6 + 9;'Hello ' + 'world!';
      
    
    
      Subtraction, Multiplication, Division
      These do what you'd expect them to do in basic math.
      -, *, /
      
        9 - 3;8 * 2; // multiply in JS is an asterisk9 / 3;
      
    
    
      Assignment
      As you've seen already: this assigns a value to a variable.
      =
      let myVariable = 'Bob';
    
    
      Strict equality
      
        This performs a test to see if two values are equal and of the same data type. It returns a
        true/false (Boolean) result.
      
      ===
      
        let myVariable = 3;myVariable === 4;
      
    
    
      Not, Does-not-equal
      
        This returns the logically opposite value of what it precedes. It turns
        a true into a false, etc.. When it is used
        alongside the Equality operator, the negation operator tests whether two
        values are not equal.
      
      !, !==
      
        
          For "Not", the basic expression is true, but the
          comparison returns false because we negate it:
        
        
          let myVariable = 3;!(myVariable === 3);
        
        
          "Does-not-equal" gives basically the same result with different
          syntax. Here we are testing "is myVariable NOT equal to
          3". This returns false because myVariable IS
          equal to 3:
        
        
          let myVariable = 3;myVariable !== 3;
        
      
    
  

There are a lot more operators to explore, but this is enough for now. See Expressions and operators for a complete list.

Note:
Mixing data types can lead to some strange results when performing calculations. Be careful that you are referring to your variables correctly, and getting the results you expect. For example, enter '35' + '25' into your console. Why don't you get the result you expected? Because the quote marks turn the numbers into strings, so you've ended up concatenating strings rather than adding numbers. If you enter 35 + 25 you'll get the total of the two numbers.
ConditionalsConditionals are code structures used to test if an expression returns true or not. A very common form of conditionals is the if...else statement. For example:
jslet iceCream = "chocolate";
if (iceCream === "chocolate") {
  alert("Yay, I love chocolate ice cream!");
} else {
  alert("Awwww, but chocolate is my favorite…");
}

The expression inside the if () is the test. This uses the strict equality operator (as described above) to compare the variable iceCream with the string chocolate to see if the two are equal. If this comparison returns true, the first block of code runs. If the comparison is not true, the second block of code—after the else keyword—runs instead.FunctionsFunctions are a way of packaging functionality that you wish to reuse. It's possible to define a body of code as a function that executes when you call the function name in your code. This is a good alternative to repeatedly writing the same code. You have already seen some uses of functions. For example:
jslet myVariable = document.querySelector("h1");

jsalert("hello!");

The document.querySelector() and alert() functions are built into the browser.
If you see something which looks like a variable name, but it's followed by parentheses — () — it is likely to be a function. Functions often take arguments: bits of data they need to do their job. Arguments go inside the parentheses, separated by commas if there is more than one argument.
For example, the alert() function makes a pop-up box appear inside the browser window, but we need to give it a string as an argument to tell the function what message to display.
You can also define your own functions. In the next example, we create a simple function which takes two numbers as arguments and multiplies them:
jsfunction multiply(num1, num2) {
  let result = num1 * num2;
  return result;
}

Try running this in the console; then test with several arguments. For example:
jsmultiply(4, 7);
multiply(20, 20);
multiply(0.5, 3);


Note:
The return statement tells the browser to return the result variable out of the function so it is available to use. This is necessary because variables defined inside functions are only available inside those functions. This is called variable scoping. (Read more about variable scoping.)


Note:
If you want some more practice at writing functions, our learning partner Scrimba has several interactive function challenges that you can access for free, and many other learning topics besides. See Write a function that logs the sum MDN learning partner for an example.
EventsReal interactivity on a website requires event handlers. These are code structures that listen for activity in the browser, and run code in response. The most obvious example is handling the click event, which is fired by the browser when you click on something with your mouse. To demonstrate this, enter the following into your console, then click on the current webpage:
jsdocument.querySelector("html").addEventListener("click", function () {
  alert("Ouch! Stop poking me!");
});

There are a number of ways to attach an event handler to an element.
Here we select the <html> element. We then call its addEventListener() function, passing in the name of the event to listen for ('click') and a function to run when the event happens.
The function we just passed to addEventListener() here is called an anonymous function, because it doesn't have a name. There's an alternative way of writing anonymous functions, which we call an arrow function.
An arrow function uses () => instead of function ():
jsdocument.querySelector("html").addEventListener("click", () => {
  alert("Ouch! Stop poking me!");
});
Supercharging our example websiteWith our review of JavaScript basics completed, let's add some new features to our example site.
Before going any further, delete the current contents of your main.js file — the bit you added earlier during the "Hello world!" example — and save the empty file. If you don't, the existing code will clash with the new code you are about to add.Adding an image changerIn this section, you will learn how to use JavaScript and DOM API features to alternate the display between two images. This change will happen as a user clicks the displayed image.


Choose another image to feature on your example site. Ideally, the image will be the same size as the image you added previously, or as close as possible.


Save this image in your images folder.


Add the following JavaScript code to your main.js file, making sure to replace firefox2.png and both instances of firefox-icon.png with your second and first image names, respectively.
jsconst myImage = document.querySelector("img");

myImage.addEventListener("click", () => {
  const mySrc = myImage.getAttribute("src");
  if (mySrc === "images/firefox-icon.png") {
    myImage.setAttribute("src", "images/firefox2.png");
  } else {
    myImage.setAttribute("src", "images/firefox-icon.png");
  }
});



Save all files and load index.html in the browser. Now when you click the image, it should change to the other one.


In the above code, you stored a reference to your <img> element in myImage. Next, you gave it a click event handler function with no name (an "anonymous" function). Every time this element is clicked, the function:


Retrieves the value of the image's src attribute.


Uses a conditional to check if the src value is equal to the path of the original image:

If it is, the code changes the src value to the path of the second image, forcing the other image to be loaded inside the <img> element.
If it isn't (meaning it must already have changed), the src value swaps back to the original image path.


Adding a personalized welcome messageNext, let's change the page heading to a personalized welcome message when the user first visits the site. This welcome message will persist. Should the user leave the site and return later, we will save the message using the Web Storage API. We will also include an option to change the username, and therefore, the welcome message.


In index.html, add the following line just before the <script> element:
html<button>Change user</button>



In main.js, place the following code at the bottom of the file, exactly as it is written. This creates references to the new button and the heading, storing each inside variables:
jslet myButton = document.querySelector("button");
let myHeading = document.querySelector("h1");



Add the following function to set the personalized greeting. This won't do anything yet; we will call the function later on.
jsfunction setUserName() {
  const myName = prompt("Please enter your name.");
  localStorage.setItem("name", myName);
  myHeading.textContent = `Mozilla is cool, ${myName}`;
}

The setUserName() function contains a prompt() function, which displays a dialog box, similar to alert(). This prompt() function does more than alert(), asking the user to enter data, and storing it in a variable after the user clicks OK. In this case, we are asking the user to enter a name. Next, the code calls on the localStorage API, which allows us to store data in the browser and retrieve it later. We use localStorage's setItem() function to create and store a data item called "name", setting its value to the myName variable which contains the user's entry for the name. Finally, we set the textContent of the heading to a string, plus the user's newly stored name.


Add the following condition block after the function declaration. We could call this initialization code, as it structures the app when it first loads.
jsif (!localStorage.getItem("name")) {
  setUserName();
} else {
  const storedName = localStorage.getItem("name");
  myHeading.textContent = `Mozilla is cool, ${storedName}`;
}

This first line of this block uses the negation operator (logical NOT, represented by the !) to check whether the name data item is already stored in localStorage. If not, the setUserName() function runs to create it. If it exists (that is, the user set a user name during a previous visit), we retrieve the stored name using getItem() and set the textContent of the heading to a string, plus the user's name, as we did inside setUserName().


Add a click event handler function to the button, as shown below. When clicked, setUserName() runs. This allows the user to enter a different name by pressing the button.
jsmyButton.addEventListener("click", () => {
  setUserName();
});


A user name of null?When you run the example and get the dialog box that prompts you to enter your user name, try pressing the Cancel button. You should end up with a title that reads Mozilla is cool, null. This happens because the value is set as null when you cancel the prompt. null is a special value in JavaScript that refers to the absence of a value.
Also, try clicking OK without entering a name. You should end up with a title that reads Mozilla is cool, because you've set myName to an empty string.
To avoid these problems, you could check that the user hasn't entered a blank name. Update your setUserName() function to this:
jsfunction setUserName() {
  const myName = prompt("Please enter your name.");
  if (!myName) {
    setUserName();
  } else {
    localStorage.setItem("name", myName);
    myHeading.textContent = `Mozilla is cool, ${myName}`;
  }
}

In human language, this means: If myName has no value, run setUserName() again from the start. If it does have a value (if the above statement is not true), then store the value in localStorage and set it as the heading's text.ConclusionIf you have followed all the instructions in this article, you should end up with a page that looks something like the image below. You can also view our version.

If you get stuck, you can compare your work with our finished example code on GitHub.
Now that you've finished creating your website, the next step is to get it online so that others can check it out. We'll show you how to do so in our next article — Publishing your website.See also
Scrimba: Learn JavaScript MDN learning partner

Scrimba's Learn JavaScript course teaches you JavaScript through solving 140+ interactive coding challenges, building projects including a game, a browser extension, and even a mobile app. Scrimba features fun interactive lessons taught by knowledgeable teachers.

Learn JavaScript

This is an excellent resource for aspiring web developers! Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by an automated assessment. The first 40 lessons are free. The complete course is available for a small one-time payment.


 Previous  Overview: Your first website Next\n\nJavaScript: Adding interactivity Previous  Overview: Your first website Next  
JavaScript is a programming language that adds interactivity to websites. This happens in games, in the behavior of responses when buttons are pressed or with data entry on forms, with dynamic styling, with animation, etc. This article helps you get started with JavaScript and furthers your understanding of what is possible.

  
    
      Prerequisites:
      
        Basic familiarity with your computer operating system, the basic software you will use to build a website, and file systems.
      
    
    
      Learning outcomes:
      
        
          The purpose and function of JavaScript.
          JavaScript language fundamentals such as variables, operators, conditionals, functions, and events.
        
      
    
  
What is JavaScript?JavaScript is a powerful programming language that can add interactivity to a website.
It was invented by Brendan Eich.
JavaScript is versatile and beginner-friendly.
With more experience, you'll be able to create games, animated 2D and 3D graphics, comprehensive database-driven apps, and much more!
JavaScript itself is relatively compact, yet very flexible. Developers have written a variety of tools on top of the core JavaScript language, unlocking a vast amount of functionality with minimum effort. These include:

Browser Application Programming Interfaces (APIs) built into web browsers, providing functionality such as dynamically creating HTML and setting CSS styles, collecting and manipulating a video stream from a user's webcam, or generating 3D graphics and audio samples.
Third-party APIs that allow developers to incorporate functionality in sites from other content providers, such as YouTube or Facebook.
Third-party frameworks and libraries that you can apply to HTML to accelerate the work of building sites and applications.

It's outside the scope of this article—as a light introduction to JavaScript—to present the details of how the core JavaScript language is different from the tools listed above. You can learn more in our Core modules, as well as in other parts of MDN.
The section below introduces some aspects of the core language and offers an opportunity to play with a few browser API features too. Have fun!A "Hello world!" exampleJavaScript is one of the most popular modern web technologies! As your JavaScript skills grow, your websites will enter a new dimension of power and creativity.
However, getting comfortable with JavaScript is more challenging than getting comfortable with HTML and CSS. You should start small, and progress gradually. To begin, let's examine how to add JavaScript to your page for creating a Hello world! example. (Hello world! is the standard for introductory programming examples.)

Warning:
If you haven't been following along with the rest of our course, download this example code and use it as a starting point.



Inside your first-website folder or the example folder you have just downloaded, create a new folder named scripts.


Within the scripts folder, create a new text document called main.js, and save it.


Go to your index.html file and enter this code on a new line, just before the closing </body> tag:
html<script src="scripts/main.js"></script>

This is doing the same job as the <link> element for CSS. It applies the JavaScript to the page, so it can have an effect on the HTML (along with the CSS, and anything else on the page).


Add this code to your scripts/main.js file:
jsconst myHeading = document.querySelector("h1");
myHeading.textContent = "Hello world!";



Make sure the HTML and JavaScript files are saved, then load index.html in your browser. You should see something like this:




Note:
The reason the above instructions place the <script> element near the bottom of the HTML file is that the browser reads code in the order it appears in the file.
If the JavaScript loads first and it is supposed to affect the HTML that hasn't loaded yet, there could be problems. Placing JavaScript near the bottom of an HTML page is one way to accommodate this dependency.
What happened?We have used JavaScript to change the heading text to Hello world!. We did this by using a function called querySelector() to grab a reference to your heading, and then store it in a variable called myHeading. This is similar to what we did using CSS selectors. When you want to do something to an element, you need to select it first.
Following that, the code set the value of the myHeading variable's textContent property (which represents the content of the heading) to Hello world!.

Note:
Both of the features you used in this exercise are parts of the Document Object Model (DOM) API, which has the capability to manipulate documents.
Language basics crash courseTo give you a better understanding of how JavaScript works, let's explain some of the core features of the language. It's worth noting that these features are common to all programming languages. If you master these fundamentals, you have a head start on coding in other languages too!

Warning:
In this article, try entering the example code lines into your JavaScript console to see what happens. For more details on JavaScript consoles, see Discover browser developer tools.
VariablesVariables are containers that store values. You start by declaring a variable with the let keyword, followed by the name you give to the variable:
jslet myVariable;

A semicolon at the end of a line indicates where a statement ends. It is only required when you need to separate statements on a single line. However, some people believe it's good practice to have semicolons at the end of each statement. There are other rules for when you should and shouldn't use semicolons. For more details, see Your Guide to Semicolons in JavaScript.
You can name a variable nearly anything, but there are some restrictions. (See this section about naming rules.) If you are unsure, you can check your variable name to see if it's valid.
JavaScript is case sensitive. This means myVariable is not the same as myvariable. If you have problems in your code, check the case!
After declaring a variable, you can give it a value:
jsmyVariable = "Bob";

Also, you can do both these operations on the same line:
jslet myVariable = "Bob";

You retrieve the value by calling the variable name:
jsmyVariable;

After assigning a value to a variable, you can change it later in the code:
jslet myVariable = "Bob";
myVariable = "Steve";

Note that variables may hold values that have different data types:

  
    
      Variable
      Explanation
      Example
    
  
  
    
      String
      
        This is a sequence of text known as a string. To signify that the value
        is a string, enclose it in single or double quote marks.
      
      let myVariable = 'Bob'; or let myVariable = "Bob";
    
    
      Number
      This is a number. Numbers don't have quotes around them.
      let myVariable = 10;
    
    
      Boolean
      
        This is a True/False value. The words true and
        false are special keywords that don't need quote marks.
      
      let myVariable = true;
    
    
      Array
      
        This is a structure that allows you to store multiple values in a single
        reference.
      
      
        let myVariable = [1,'Bob','Steve',10];Refer to each
        member of the array like this:myVariable[0],
        myVariable[1], etc.
      
    
    
      Object
      
        This can be anything. Everything in JavaScript is an object and can be
        stored in a variable. Keep this in mind as you learn.
      
      
        let myVariable = document.querySelector('h1');All of
        the above examples too.
      
    
  

So why do we need variables? Variables are necessary to do anything interesting in programming. If values couldn't change, then you couldn't do anything dynamic, like personalize a greeting message or change an image displayed in an image gallery.CommentsComments are snippets of text that can be added along with code. The browser ignores text marked as comments. You can write comments in JavaScript just as you can in CSS:
js/*
Everything in between is a comment.
*/

If your comment contains no line breaks, you can put it behind two slashes like this:
js// This is a comment
OperatorsAn operator is a mathematical symbol that produces a result based on two values (or variables). In the following table, you can see some of the simplest operators, along with some examples to try in the JavaScript console.

  
    
      Operator
      Explanation
      Symbol(s)
      Example
    
  
  
    
      Addition
      Add two numbers together or combine two strings.
      +
      
        6 + 9;'Hello ' + 'world!';
      
    
    
      Subtraction, Multiplication, Division
      These do what you'd expect them to do in basic math.
      -, *, /
      
        9 - 3;8 * 2; // multiply in JS is an asterisk9 / 3;
      
    
    
      Assignment
      As you've seen already: this assigns a value to a variable.
      =
      let myVariable = 'Bob';
    
    
      Strict equality
      
        This performs a test to see if two values are equal and of the same data type. It returns a
        true/false (Boolean) result.
      
      ===
      
        let myVariable = 3;myVariable === 4;
      
    
    
      Not, Does-not-equal
      
        This returns the logically opposite value of what it precedes. It turns
        a true into a false, etc.. When it is used
        alongside the Equality operator, the negation operator tests whether two
        values are not equal.
      
      !, !==
      
        
          For "Not", the basic expression is true, but the
          comparison returns false because we negate it:
        
        
          let myVariable = 3;!(myVariable === 3);
        
        
          "Does-not-equal" gives basically the same result with different
          syntax. Here we are testing "is myVariable NOT equal to
          3". This returns false because myVariable IS
          equal to 3:
        
        
          let myVariable = 3;myVariable !== 3;
        
      
    
  

There are a lot more operators to explore, but this is enough for now. See Expressions and operators for a complete list.

Note:
Mixing data types can lead to some strange results when performing calculations. Be careful that you are referring to your variables correctly, and getting the results you expect. For example, enter '35' + '25' into your console. Why don't you get the result you expected? Because the quote marks turn the numbers into strings, so you've ended up concatenating strings rather than adding numbers. If you enter 35 + 25 you'll get the total of the two numbers.
ConditionalsConditionals are code structures used to test if an expression returns true or not. A very common form of conditionals is the if...else statement. For example:
jslet iceCream = "chocolate";
if (iceCream === "chocolate") {
  alert("Yay, I love chocolate ice cream!");
} else {
  alert("Awwww, but chocolate is my favorite…");
}

The expression inside the if () is the test. This uses the strict equality operator (as described above) to compare the variable iceCream with the string chocolate to see if the two are equal. If this comparison returns true, the first block of code runs. If the comparison is not true, the second block of code—after the else keyword—runs instead.FunctionsFunctions are a way of packaging functionality that you wish to reuse. It's possible to define a body of code as a function that executes when you call the function name in your code. This is a good alternative to repeatedly writing the same code. You have already seen some uses of functions. For example:
jslet myVariable = document.querySelector("h1");

jsalert("hello!");

The document.querySelector() and alert() functions are built into the browser.
If you see something which looks like a variable name, but it's followed by parentheses — () — it is likely to be a function. Functions often take arguments: bits of data they need to do their job. Arguments go inside the parentheses, separated by commas if there is more than one argument.
For example, the alert() function makes a pop-up box appear inside the browser window, but we need to give it a string as an argument to tell the function what message to display.
You can also define your own functions. In the next example, we create a simple function which takes two numbers as arguments and multiplies them:
jsfunction multiply(num1, num2) {
  let result = num1 * num2;
  return result;
}

Try running this in the console; then test with several arguments. For example:
jsmultiply(4, 7);
multiply(20, 20);
multiply(0.5, 3);


Note:
The return statement tells the browser to return the result variable out of the function so it is available to use. This is necessary because variables defined inside functions are only available inside those functions. This is called variable scoping. (Read more about variable scoping.)


Note:
If you want some more practice at writing functions, our learning partner Scrimba has several interactive function challenges that you can access for free, and many other learning topics besides. See Write a function that logs the sum MDN learning partner for an example.
EventsReal interactivity on a website requires event handlers. These are code structures that listen for activity in the browser, and run code in response. The most obvious example is handling the click event, which is fired by the browser when you click on something with your mouse. To demonstrate this, enter the following into your console, then click on the current webpage:
jsdocument.querySelector("html").addEventListener("click", function () {
  alert("Ouch! Stop poking me!");
});

There are a number of ways to attach an event handler to an element.
Here we select the <html> element. We then call its addEventListener() function, passing in the name of the event to listen for ('click') and a function to run when the event happens.
The function we just passed to addEventListener() here is called an anonymous function, because it doesn't have a name. There's an alternative way of writing anonymous functions, which we call an arrow function.
An arrow function uses () => instead of function ():
jsdocument.querySelector("html").addEventListener("click", () => {
  alert("Ouch! Stop poking me!");
});
Supercharging our example websiteWith our review of JavaScript basics completed, let's add some new features to our example site.
Before going any further, delete the current contents of your main.js file — the bit you added earlier during the "Hello world!" example — and save the empty file. If you don't, the existing code will clash with the new code you are about to add.Adding an image changerIn this section, you will learn how to use JavaScript and DOM API features to alternate the display between two images. This change will happen as a user clicks the displayed image.


Choose another image to feature on your example site. Ideally, the image will be the same size as the image you added previously, or as close as possible.


Save this image in your images folder.


Add the following JavaScript code to your main.js file, making sure to replace firefox2.png and both instances of firefox-icon.png with your second and first image names, respectively.
jsconst myImage = document.querySelector("img");

myImage.addEventListener("click", () => {
  const mySrc = myImage.getAttribute("src");
  if (mySrc === "images/firefox-icon.png") {
    myImage.setAttribute("src", "images/firefox2.png");
  } else {
    myImage.setAttribute("src", "images/firefox-icon.png");
  }
});



Save all files and load index.html in the browser. Now when you click the image, it should change to the other one.


In the above code, you stored a reference to your <img> element in myImage. Next, you gave it a click event handler function with no name (an "anonymous" function). Every time this element is clicked, the function:


Retrieves the value of the image's src attribute.


Uses a conditional to check if the src value is equal to the path of the original image:

If it is, the code changes the src value to the path of the second image, forcing the other image to be loaded inside the <img> element.
If it isn't (meaning it must already have changed), the src value swaps back to the original image path.


Adding a personalized welcome messageNext, let's change the page heading to a personalized welcome message when the user first visits the site. This welcome message will persist. Should the user leave the site and return later, we will save the message using the Web Storage API. We will also include an option to change the username, and therefore, the welcome message.


In index.html, add the following line just before the <script> element:
html<button>Change user</button>



In main.js, place the following code at the bottom of the file, exactly as it is written. This creates references to the new button and the heading, storing each inside variables:
jslet myButton = document.querySelector("button");
let myHeading = document.querySelector("h1");



Add the following function to set the personalized greeting. This won't do anything yet; we will call the function later on.
jsfunction setUserName() {
  const myName = prompt("Please enter your name.");
  localStorage.setItem("name", myName);
  myHeading.textContent = `Mozilla is cool, ${myName}`;
}

The setUserName() function contains a prompt() function, which displays a dialog box, similar to alert(). This prompt() function does more than alert(), asking the user to enter data, and storing it in a variable after the user clicks OK. In this case, we are asking the user to enter a name. Next, the code calls on the localStorage API, which allows us to store data in the browser and retrieve it later. We use localStorage's setItem() function to create and store a data item called "name", setting its value to the myName variable which contains the user's entry for the name. Finally, we set the textContent of the heading to a string, plus the user's newly stored name.


Add the following condition block after the function declaration. We could call this initialization code, as it structures the app when it first loads.
jsif (!localStorage.getItem("name")) {
  setUserName();
} else {
  const storedName = localStorage.getItem("name");
  myHeading.textContent = `Mozilla is cool, ${storedName}`;
}

This first line of this block uses the negation operator (logical NOT, represented by the !) to check whether the name data item is already stored in localStorage. If not, the setUserName() function runs to create it. If it exists (that is, the user set a user name during a previous visit), we retrieve the stored name using getItem() and set the textContent of the heading to a string, plus the user's name, as we did inside setUserName().


Add a click event handler function to the button, as shown below. When clicked, setUserName() runs. This allows the user to enter a different name by pressing the button.
jsmyButton.addEventListener("click", () => {
  setUserName();
});


A user name of null?When you run the example and get the dialog box that prompts you to enter your user name, try pressing the Cancel button. You should end up with a title that reads Mozilla is cool, null. This happens because the value is set as null when you cancel the prompt. null is a special value in JavaScript that refers to the absence of a value.
Also, try clicking OK without entering a name. You should end up with a title that reads Mozilla is cool, because you've set myName to an empty string.
To avoid these problems, you could check that the user hasn't entered a blank name. Update your setUserName() function to this:
jsfunction setUserName() {
  const myName = prompt("Please enter your name.");
  if (!myName) {
    setUserName();
  } else {
    localStorage.setItem("name", myName);
    myHeading.textContent = `Mozilla is cool, ${myName}`;
  }
}

In human language, this means: If myName has no value, run setUserName() again from the start. If it does have a value (if the above statement is not true), then store the value in localStorage and set it as the heading's text.ConclusionIf you have followed all the instructions in this article, you should end up with a page that looks something like the image below. You can also view our version.

If you get stuck, you can compare your work with our finished example code on GitHub.
Now that you've finished creating your website, the next step is to get it online so that others can check it out. We'll show you how to do so in our next article — Publishing your website.See also
Scrimba: Learn JavaScript MDN learning partner

Scrimba's Learn JavaScript course teaches you JavaScript through solving 140+ interactive coding challenges, building projects including a game, a browser extension, and even a mobile app. Scrimba features fun interactive lessons taught by knowledgeable teachers.

Learn JavaScript

This is an excellent resource for aspiring web developers! Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by an automated assessment. The first 40 lessons are free. The complete course is available for a small one-time payment.


 Previous  Overview: Your first website Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 15, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJavaScript: Adding interactivity Previous  Overview: Your first website Next  
JavaScript is a programming language that adds interactivity to websites. This happens in games, in the behavior of responses when buttons are pressed or with data entry on forms, with dynamic styling, with animation, etc. This article helps you get started with JavaScript and furthers your understanding of what is possible.

  
    
      Prerequisites:
      
        Basic familiarity with your computer operating system, the basic software you will use to build a website, and file systems.
      
    
    
      Learning outcomes:
      
        
          The purpose and function of JavaScript.
          JavaScript language fundamentals such as variables, operators, conditionals, functions, and events.
        
      
    
  
What is JavaScript?JavaScript is a powerful programming language that can add interactivity to a website.
It was invented by Brendan Eich.
JavaScript is versatile and beginner-friendly.
With more experience, you'll be able to create games, animated 2D and 3D graphics, comprehensive database-driven apps, and much more!
JavaScript itself is relatively compact, yet very flexible. Developers have written a variety of tools on top of the core JavaScript language, unlocking a vast amount of functionality with minimum effort. These include:

Browser Application Programming Interfaces (APIs) built into web browsers, providing functionality such as dynamically creating HTML and setting CSS styles, collecting and manipulating a video stream from a user's webcam, or generating 3D graphics and audio samples.
Third-party APIs that allow developers to incorporate functionality in sites from other content providers, such as YouTube or Facebook.
Third-party frameworks and libraries that you can apply to HTML to accelerate the work of building sites and applications.

It's outside the scope of this article—as a light introduction to JavaScript—to present the details of how the core JavaScript language is different from the tools listed above. You can learn more in our Core modules, as well as in other parts of MDN.
The section below introduces some aspects of the core language and offers an opportunity to play with a few browser API features too. Have fun!A "Hello world!" exampleJavaScript is one of the most popular modern web technologies! As your JavaScript skills grow, your websites will enter a new dimension of power and creativity.
However, getting comfortable with JavaScript is more challenging than getting comfortable with HTML and CSS. You should start small, and progress gradually. To begin, let's examine how to add JavaScript to your page for creating a Hello world! example. (Hello world! is the standard for introductory programming examples.)

Warning:
If you haven't been following along with the rest of our course, download this example code and use it as a starting point.



Inside your first-website folder or the example folder you have just downloaded, create a new folder named scripts.


Within the scripts folder, create a new text document called main.js, and save it.


Go to your index.html file and enter this code on a new line, just before the closing </body> tag:
html<script src="scripts/main.js"></script>

This is doing the same job as the <link> element for CSS. It applies the JavaScript to the page, so it can have an effect on the HTML (along with the CSS, and anything else on the page).


Add this code to your scripts/main.js file:
jsconst myHeading = document.querySelector("h1");
myHeading.textContent = "Hello world!";



Make sure the HTML and JavaScript files are saved, then load index.html in your browser. You should see something like this:




Note:
The reason the above instructions place the <script> element near the bottom of the HTML file is that the browser reads code in the order it appears in the file.
If the JavaScript loads first and it is supposed to affect the HTML that hasn't loaded yet, there could be problems. Placing JavaScript near the bottom of an HTML page is one way to accommodate this dependency.
What happened?We have used JavaScript to change the heading text to Hello world!. We did this by using a function called querySelector() to grab a reference to your heading, and then store it in a variable called myHeading. This is similar to what we did using CSS selectors. When you want to do something to an element, you need to select it first.
Following that, the code set the value of the myHeading variable's textContent property (which represents the content of the heading) to Hello world!.

Note:
Both of the features you used in this exercise are parts of the Document Object Model (DOM) API, which has the capability to manipulate documents.
Language basics crash courseTo give you a better understanding of how JavaScript works, let's explain some of the core features of the language. It's worth noting that these features are common to all programming languages. If you master these fundamentals, you have a head start on coding in other languages too!

Warning:
In this article, try entering the example code lines into your JavaScript console to see what happens. For more details on JavaScript consoles, see Discover browser developer tools.
VariablesVariables are containers that store values. You start by declaring a variable with the let keyword, followed by the name you give to the variable:
jslet myVariable;

A semicolon at the end of a line indicates where a statement ends. It is only required when you need to separate statements on a single line. However, some people believe it's good practice to have semicolons at the end of each statement. There are other rules for when you should and shouldn't use semicolons. For more details, see Your Guide to Semicolons in JavaScript.
You can name a variable nearly anything, but there are some restrictions. (See this section about naming rules.) If you are unsure, you can check your variable name to see if it's valid.
JavaScript is case sensitive. This means myVariable is not the same as myvariable. If you have problems in your code, check the case!
After declaring a variable, you can give it a value:
jsmyVariable = "Bob";

Also, you can do both these operations on the same line:
jslet myVariable = "Bob";

You retrieve the value by calling the variable name:
jsmyVariable;

After assigning a value to a variable, you can change it later in the code:
jslet myVariable = "Bob";
myVariable = "Steve";

Note that variables may hold values that have different data types:

  
    
      Variable
      Explanation
      Example
    
  
  
    
      String
      
        This is a sequence of text known as a string. To signify that the value
        is a string, enclose it in single or double quote marks.
      
      let myVariable = 'Bob'; or let myVariable = "Bob";
    
    
      Number
      This is a number. Numbers don't have quotes around them.
      let myVariable = 10;
    
    
      Boolean
      
        This is a True/False value. The words true and
        false are special keywords that don't need quote marks.
      
      let myVariable = true;
    
    
      Array
      
        This is a structure that allows you to store multiple values in a single
        reference.
      
      
        let myVariable = [1,'Bob','Steve',10];Refer to each
        member of the array like this:myVariable[0],
        myVariable[1], etc.
      
    
    
      Object
      
        This can be anything. Everything in JavaScript is an object and can be
        stored in a variable. Keep this in mind as you learn.
      
      
        let myVariable = document.querySelector('h1');All of
        the above examples too.
      
    
  

So why do we need variables? Variables are necessary to do anything interesting in programming. If values couldn't change, then you couldn't do anything dynamic, like personalize a greeting message or change an image displayed in an image gallery.CommentsComments are snippets of text that can be added along with code. The browser ignores text marked as comments. You can write comments in JavaScript just as you can in CSS:
js/*
Everything in between is a comment.
*/

If your comment contains no line breaks, you can put it behind two slashes like this:
js// This is a comment
OperatorsAn operator is a mathematical symbol that produces a result based on two values (or variables). In the following table, you can see some of the simplest operators, along with some examples to try in the JavaScript console.

  
    
      Operator
      Explanation
      Symbol(s)
      Example
    
  
  
    
      Addition
      Add two numbers together or combine two strings.
      +
      
        6 + 9;'Hello ' + 'world!';
      
    
    
      Subtraction, Multiplication, Division
      These do what you'd expect them to do in basic math.
      -, *, /
      
        9 - 3;8 * 2; // multiply in JS is an asterisk9 / 3;
      
    
    
      Assignment
      As you've seen already: this assigns a value to a variable.
      =
      let myVariable = 'Bob';
    
    
      Strict equality
      
        This performs a test to see if two values are equal and of the same data type. It returns a
        true/false (Boolean) result.
      
      ===
      
        let myVariable = 3;myVariable === 4;
      
    
    
      Not, Does-not-equal
      
        This returns the logically opposite value of what it precedes. It turns
        a true into a false, etc.. When it is used
        alongside the Equality operator, the negation operator tests whether two
        values are not equal.
      
      !, !==
      
        
          For "Not", the basic expression is true, but the
          comparison returns false because we negate it:
        
        
          let myVariable = 3;!(myVariable === 3);
        
        
          "Does-not-equal" gives basically the same result with different
          syntax. Here we are testing "is myVariable NOT equal to
          3". This returns false because myVariable IS
          equal to 3:
        
        
          let myVariable = 3;myVariable !== 3;
        
      
    
  

There are a lot more operators to explore, but this is enough for now. See Expressions and operators for a complete list.

Note:
Mixing data types can lead to some strange results when performing calculations. Be careful that you are referring to your variables correctly, and getting the results you expect. For example, enter '35' + '25' into your console. Why don't you get the result you expected? Because the quote marks turn the numbers into strings, so you've ended up concatenating strings rather than adding numbers. If you enter 35 + 25 you'll get the total of the two numbers.
ConditionalsConditionals are code structures used to test if an expression returns true or not. A very common form of conditionals is the if...else statement. For example:
jslet iceCream = "chocolate";
if (iceCream === "chocolate") {
  alert("Yay, I love chocolate ice cream!");
} else {
  alert("Awwww, but chocolate is my favorite…");
}

The expression inside the if () is the test. This uses the strict equality operator (as described above) to compare the variable iceCream with the string chocolate to see if the two are equal. If this comparison returns true, the first block of code runs. If the comparison is not true, the second block of code—after the else keyword—runs instead.FunctionsFunctions are a way of packaging functionality that you wish to reuse. It's possible to define a body of code as a function that executes when you call the function name in your code. This is a good alternative to repeatedly writing the same code. You have already seen some uses of functions. For example:
jslet myVariable = document.querySelector("h1");

jsalert("hello!");

The document.querySelector() and alert() functions are built into the browser.
If you see something which looks like a variable name, but it's followed by parentheses — () — it is likely to be a function. Functions often take arguments: bits of data they need to do their job. Arguments go inside the parentheses, separated by commas if there is more than one argument.
For example, the alert() function makes a pop-up box appear inside the browser window, but we need to give it a string as an argument to tell the function what message to display.
You can also define your own functions. In the next example, we create a simple function which takes two numbers as arguments and multiplies them:
jsfunction multiply(num1, num2) {
  let result = num1 * num2;
  return result;
}

Try running this in the console; then test with several arguments. For example:
jsmultiply(4, 7);
multiply(20, 20);
multiply(0.5, 3);


Note:
The return statement tells the browser to return the result variable out of the function so it is available to use. This is necessary because variables defined inside functions are only available inside those functions. This is called variable scoping. (Read more about variable scoping.)


Note:
If you want some more practice at writing functions, our learning partner Scrimba has several interactive function challenges that you can access for free, and many other learning topics besides. See Write a function that logs the sum MDN learning partner for an example.
EventsReal interactivity on a website requires event handlers. These are code structures that listen for activity in the browser, and run code in response. The most obvious example is handling the click event, which is fired by the browser when you click on something with your mouse. To demonstrate this, enter the following into your console, then click on the current webpage:
jsdocument.querySelector("html").addEventListener("click", function () {
  alert("Ouch! Stop poking me!");
});

There are a number of ways to attach an event handler to an element.
Here we select the <html> element. We then call its addEventListener() function, passing in the name of the event to listen for ('click') and a function to run when the event happens.
The function we just passed to addEventListener() here is called an anonymous function, because it doesn't have a name. There's an alternative way of writing anonymous functions, which we call an arrow function.
An arrow function uses () => instead of function ():
jsdocument.querySelector("html").addEventListener("click", () => {
  alert("Ouch! Stop poking me!");
});
Supercharging our example websiteWith our review of JavaScript basics completed, let's add some new features to our example site.
Before going any further, delete the current contents of your main.js file — the bit you added earlier during the "Hello world!" example — and save the empty file. If you don't, the existing code will clash with the new code you are about to add.Adding an image changerIn this section, you will learn how to use JavaScript and DOM API features to alternate the display between two images. This change will happen as a user clicks the displayed image.


Choose another image to feature on your example site. Ideally, the image will be the same size as the image you added previously, or as close as possible.


Save this image in your images folder.


Add the following JavaScript code to your main.js file, making sure to replace firefox2.png and both instances of firefox-icon.png with your second and first image names, respectively.
jsconst myImage = document.querySelector("img");

myImage.addEventListener("click", () => {
  const mySrc = myImage.getAttribute("src");
  if (mySrc === "images/firefox-icon.png") {
    myImage.setAttribute("src", "images/firefox2.png");
  } else {
    myImage.setAttribute("src", "images/firefox-icon.png");
  }
});



Save all files and load index.html in the browser. Now when you click the image, it should change to the other one.


In the above code, you stored a reference to your <img> element in myImage. Next, you gave it a click event handler function with no name (an "anonymous" function). Every time this element is clicked, the function:


Retrieves the value of the image's src attribute.


Uses a conditional to check if the src value is equal to the path of the original image:

If it is, the code changes the src value to the path of the second image, forcing the other image to be loaded inside the <img> element.
If it isn't (meaning it must already have changed), the src value swaps back to the original image path.


Adding a personalized welcome messageNext, let's change the page heading to a personalized welcome message when the user first visits the site. This welcome message will persist. Should the user leave the site and return later, we will save the message using the Web Storage API. We will also include an option to change the username, and therefore, the welcome message.


In index.html, add the following line just before the <script> element:
html<button>Change user</button>



In main.js, place the following code at the bottom of the file, exactly as it is written. This creates references to the new button and the heading, storing each inside variables:
jslet myButton = document.querySelector("button");
let myHeading = document.querySelector("h1");



Add the following function to set the personalized greeting. This won't do anything yet; we will call the function later on.
jsfunction setUserName() {
  const myName = prompt("Please enter your name.");
  localStorage.setItem("name", myName);
  myHeading.textContent = `Mozilla is cool, ${myName}`;
}

The setUserName() function contains a prompt() function, which displays a dialog box, similar to alert(). This prompt() function does more than alert(), asking the user to enter data, and storing it in a variable after the user clicks OK. In this case, we are asking the user to enter a name. Next, the code calls on the localStorage API, which allows us to store data in the browser and retrieve it later. We use localStorage's setItem() function to create and store a data item called "name", setting its value to the myName variable which contains the user's entry for the name. Finally, we set the textContent of the heading to a string, plus the user's newly stored name.


Add the following condition block after the function declaration. We could call this initialization code, as it structures the app when it first loads.
jsif (!localStorage.getItem("name")) {
  setUserName();
} else {
  const storedName = localStorage.getItem("name");
  myHeading.textContent = `Mozilla is cool, ${storedName}`;
}

This first line of this block uses the negation operator (logical NOT, represented by the !) to check whether the name data item is already stored in localStorage. If not, the setUserName() function runs to create it. If it exists (that is, the user set a user name during a previous visit), we retrieve the stored name using getItem() and set the textContent of the heading to a string, plus the user's name, as we did inside setUserName().


Add a click event handler function to the button, as shown below. When clicked, setUserName() runs. This allows the user to enter a different name by pressing the button.
jsmyButton.addEventListener("click", () => {
  setUserName();
});


A user name of null?When you run the example and get the dialog box that prompts you to enter your user name, try pressing the Cancel button. You should end up with a title that reads Mozilla is cool, null. This happens because the value is set as null when you cancel the prompt. null is a special value in JavaScript that refers to the absence of a value.
Also, try clicking OK without entering a name. You should end up with a title that reads Mozilla is cool, because you've set myName to an empty string.
To avoid these problems, you could check that the user hasn't entered a blank name. Update your setUserName() function to this:
jsfunction setUserName() {
  const myName = prompt("Please enter your name.");
  if (!myName) {
    setUserName();
  } else {
    localStorage.setItem("name", myName);
    myHeading.textContent = `Mozilla is cool, ${myName}`;
  }
}

In human language, this means: If myName has no value, run setUserName() again from the start. If it does have a value (if the above statement is not true), then store the value in localStorage and set it as the heading's text.ConclusionIf you have followed all the instructions in this article, you should end up with a page that looks something like the image below. You can also view our version.

If you get stuck, you can compare your work with our finished example code on GitHub.
Now that you've finished creating your website, the next step is to get it online so that others can check it out. We'll show you how to do so in our next article — Publishing your website.See also
Scrimba: Learn JavaScript MDN learning partner

Scrimba's Learn JavaScript course teaches you JavaScript through solving 140+ interactive coding challenges, building projects including a game, a browser extension, and even a mobile app. Scrimba features fun interactive lessons taught by knowledgeable teachers.

Learn JavaScript

This is an excellent resource for aspiring web developers! Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by an automated assessment. The first 40 lessons are free. The complete course is available for a small one-time payment.


 Previous  Overview: Your first website Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 15, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJavaScript frameworks and libraries Overview: Core learning modules Next  
JavaScript frameworks are an essential part of modern front-end web development, providing developers with tried and tested tools for building scalable, interactive web applications. Many modern companies use frameworks as a standard part of their tooling, so many front-end development jobs now require framework experience. In this set of articles, we are aiming to give you a comfortable starting point to help you begin learning frameworks.
As an aspiring front-end developer, it can be hard to work out where to begin when learning frameworks — there are so many frameworks to choose from, new ones appear all the time, they mostly work in a similar way but do some things differently, and there are some specific things to be careful about when using frameworks.
We are not aiming to exhaustively teach you everything you need to know about React/ReactDOM, or Vue, or some other specific framework; the framework teams' own docs (and other resources) do that job already. Instead, we want to back up and first answer more fundamental questions such as:

Why should I use a framework? What problems do they solve for me?
What questions should I ask when trying to choose a framework? Do I even need to use a framework?
What features do frameworks have? How do they work in general, and how do frameworks' implementations of these features differ?
How do they relate to "vanilla" JavaScript or HTML?

After that, we'll provide some tutorials covering the essentials React, a popular framework choice, to provide you with enough context and familiarity to start going into greater depth yourself. We want you to go forward and learn about frameworks in a pragmatic way that doesn't forget about web platform fundamental best practices such as accessibility.
We also provide some tutorials covering the basics of other framework choices, for those who want to make a different choice to React.PrerequisitesYou should really learn the basics of the core web languages first before attempting to move on to learning client-side frameworks — HTML, CSS, and especially JavaScript.
Your code will be richer and more professional as a result, and you'll be able to troubleshoot problems with more confidence if you understand the fundamental web platform features that the frameworks are building on top of.Introductory tutorials
Introduction to client-side frameworks

We begin our look at frameworks with a general overview of the area, looking at a brief history of JavaScript and frameworks, why frameworks exist and what they give us, how to start thinking about choosing a framework to learn, and what alternatives there are to client-side frameworks.

Framework main features

Each major JavaScript framework has a different approach to updating the DOM, handling browser events, and providing an enjoyable developer experience. This article will explore the main features of "the big 4" frameworks, looking at how frameworks tend to work from a high level and the differences between them.

React tutorials
Note:
React tutorials last tested in January 2023, with React/ReactDOM 18.2.0 and create-react-app 5.0.1.
If you need to check your code against our version, you can find a finished version of the sample React app code in our todo-react repository. For a running live version, see https://mdn.github.io/todo-react/.


Getting started with React

In this article we will say hello to React. We'll discover a little bit of detail about its background and use cases, set up a basic React toolchain on our local computer, and create and play with a simple starter app, learning a bit about how React works in the process.

Beginning our React ToDo app

Let's say that we've been tasked with creating a proof-of-concept in React – an app that allows users to add, edit, and delete tasks they want to work on, and also mark tasks as complete without deleting them. This article will walk you through putting the basic App component structure and styling in place, ready for individual component definition and interactivity, which we'll add later.

Componentizing our React app

At this point, our app is a monolith. Before we can make it do things, we need to break it apart into manageable, descriptive components. React doesn't have any hard rules for what is and isn't a component – that's up to you! In this article, we will show you a sensible way to break our app up into components.

React interactivity: Events and state

With our component plan worked out, it's now time to start updating our app from a completely static UI to one that actually allows us to interact and change things. In this article we'll do this, digging into events and state along the way.

React interactivity: Editing, filtering, conditional rendering

As we near the end of our React journey (for now at least), we'll add the finishing touches to the main areas of functionality in our Todo list app. This includes allowing you to edit existing tasks and filtering the list of tasks between all, completed, and incomplete tasks. We'll look at conditional UI rendering along the way.

Accessibility in React

In our final tutorial article, we'll focus on (pun intended) accessibility, including focus management in React, which can improve usability and reduce confusion for both keyboard-only and screen reader users.

React resources

Our final article provides you with a list of React resources that you can use to go further in your learning.

Other framework choicesEmber tutorials
Note:
Ember tutorials last tested in May 2020, with Ember/Ember CLI version 3.18.0.
If you need to check your code against our version, you can find a finished version of the sample Ember app code in the ember-todomvc-tutorial repository. For a running live version, see https://nullvoxpopuli.github.io/ember-todomvc-tutorial/ (this also includes a few additional features not covered in the tutorial).


Getting started with Ember

In our first Ember article we will look at how Ember works and what it's useful for, install the Ember toolchain locally, create a sample app, and then do some initial setup to get it ready for development.

Ember app structure and componentization

In this article we'll get right on with planning out the structure of our TodoMVC Ember app, adding in the HTML for it, and then breaking that HTML structure into components.

Ember interactivity: Events, classes and state

At this point we'll start adding some interactivity to our app, providing the ability to add and display new todo items. Along the way, we'll look at using events in Ember, creating component classes to contain JavaScript code to control interactive features, and setting up a service to keep track of the data state of our app.

Ember Interactivity: Footer functionality, conditional rendering

Now it's time to start tackling the footer functionality in our app. Here we'll get the todo counter to update to show the correct number of todos still to complete, and correctly apply styling to completed todos (i.e., where the checkbox has been checked). We'll also wire up our "Clear completed" button. Along the way, we'll learn about using conditional rendering in our templates.

Routing in Ember

In this article we learn about routing or URL-based filtering as it is sometimes referred to. We'll use it to provide a unique URL for each of the three todo views — "All", "Active", and "Completed".

Ember resources and troubleshooting

Our final Ember article provides you with a list of resources that you can use to go further in your learning, plus some useful troubleshooting and other information.

Vue tutorials
Note:
Vue tutorial last tested in January 2023, with Vue 3.2.45.
If you need to check your code against our version, you can find a finished version of the sample Vue app code in our todo-vue repository. For a running live version, see https://mdn.github.io/todo-vue/.


Getting started with Vue

Now let's introduce Vue, the third of our frameworks. In this article, we'll look at a little bit of Vue background, learn how to install it and create a new project, study the high-level structure of the whole project and an individual component, see how to run the project locally, and get it prepared to start building our example.

Creating our first Vue component

Now it's time to dive deeper into Vue, and create our own custom component — we'll start by creating a component to represent each item in the todo list. Along the way, we'll learn about a few important concepts such as calling components inside other components, passing data to them via props and saving data state.

Rendering a list of Vue components

At this point we've got a fully working component; we're now ready to add multiple ToDoItem components to our app. In this article we'll look at adding a set of todo item data to our App.vue component, which we'll then loop through and display inside ToDoItem components using the v-for directive.

Adding a new todo form: Vue events, methods, and models

We now have sample data in place and a loop that takes each bit of data and renders it inside a ToDoItem in our app. What we really need next is the ability to allow our users to enter their own todo items into the app, and for that, we'll need a text <input>, an event to fire when the data is submitted, a method to fire upon submission to add the data and rerender the list, and a model to control the data. This is what we'll cover in this article.

Styling Vue components with CSS

The time has finally come to make our app look a bit nicer. In this article, we'll explore the different ways of styling Vue components with CSS.

Using Vue computed properties

In this article we'll add a counter that displays the number of completed todo items, using a feature of Vue called computed properties. These work similarly to methods but only re-run when one of their dependencies changes.

Vue conditional rendering: editing existing todos

Now it is time to add one of the major parts of functionality that we're still missing — the ability to edit existing todo items. To do this, we will take advantage of Vue's conditional rendering capabilities — namely v-if and v-else — to allow us to toggle between the existing todo item view and an edit view where you can update todo item labels. We'll also look at adding functionality to delete todo items.

Vue refs and lifecycle methods for focus management

We are nearly done with Vue. The last bit of functionality to look at is focus management, or put another way, how we can improve our app's keyboard accessibility. We'll look at using Vue refs to handle this — an advanced feature that allows you to have direct access to the underlying DOM nodes below the virtual DOM, or direct access from one component to the internal DOM structure of a child component.

Vue resources

Now we'll round off our study of Vue by giving you a list of resources that you can use to go further in your learning, plus some other useful tips.

Svelte tutorials
Note:
Svelte tutorials last tested in August 2020, with Svelte 3.24.1.
If you need to check your code against our version, you can find a finished version of the sample Svelte app code as it should be after each article, in our mdn-svelte-tutorial repo. For a running live version, see our Svelte REPL at https://svelte.dev/repl/378dd79e0dfe4486a8f10823f3813190?version=3.23.2.


Getting started with Svelte

In this article we'll provide a quick introduction to the Svelte framework. We will see how Svelte works and what sets it apart from the rest of the frameworks and tools we've seen so far. Then we will learn how to set up our development environment, create a sample app, understand the structure of the project, and see how to run it locally and build it for production.

Starting our Svelte Todo list app

Now that we have a basic understanding of how things work in Svelte, we can start building our example app: a todo list. In this article we will first have a look at the desired functionality of our app, then we'll create a Todos.svelte component and put static markup and styles in place, leaving everything ready to start developing our To-Do list app features, which we'll go on to in subsequent articles.

Dynamic behavior in Svelte: working with variables and props

Now that we have our markup and styles ready we can start developing the required features for our Svelte To-Do list app. In this article we'll be using variables and props to make our app dynamic, allowing us to add and delete todos, mark them as complete, and filter them by status.

Componentizing our Svelte app

The central objective of this article is to look at how to break our app into manageable components and share information between them. We'll componentize our app, then add more functionality to allow users to update existing components.

Advanced Svelte: Reactivity, lifecycle, accessibility

In this article we will add the app's final features and further componentize our app. We will learn how to deal with reactivity issues related to updating objects and arrays. To avoid common pitfalls, we'll have to dig a little deeper into Svelte's reactivity system. We'll also look at solving some accessibility focus issues, and more besides.

Working with Svelte stores

In this article we will show another way to handle state management in Svelte — Stores. Stores are global data repositories that hold values. Components can subscribe to stores and receive notifications when their values change.

TypeScript support in Svelte

We will now learn how to use TypeScript in Svelte applications. First we'll learn what TypeScript is and what benefits it can bring us. Then we'll see how to configure our project to work with TypeScript files. Finally we will go over our app and see what modifications we have to make to fully take advantage of TypeScript features.

Deployment and next steps

In this final article we will look at how to deploy your application and get it online, and also share some of the resources that you should go on to, to continue your Svelte learning journey.

Angular tutorials
Note:
Angular tutorials last tested in April 2021, with Angular CLI (NG) 11.2.5.


Getting started with Angular

In this article we look at what Angular has to offer, install the prerequisites and set up a sample app, and look at Angular's basic architecture.

Beginning our Angular todo list app

At this point, we are ready to start creating our to-do list application using Angular. The finished application will display a list of to-do items and includes editing, deleting, and adding features. In this article you will get to know your application structure, and work up to displaying a basic list of to-do items.

Styling our Angular app

Now that we've got our basic application structure set up and started displaying something useful, let's switch gears and spend an article looking at how Angular handles styling of applications.

Creating an item component

Components provide a way for you to organize your application. This article walks you through creating a component to handle the individual items in the list, and adding check, edit, and delete functionality. The Angular event model is covered here.

Filtering our to-do items

Now let's move on to adding functionality to allow users to filter their to-do items, so they can view active, completed, or all items.

Building Angular applications and further resources

This final Angular article covers how to build an app ready for production, and provides further resources for you to continue your learning journey.

Which frameworks did we choose?We cover five frameworks in our tutorials — Angular, Ember, React/ReactDOM, Svelte, and Vue:

They are popular choices that will be around for a while — like with any software tool, it is good to stick with actively-developed choices that are likely to not be discontinued next week, and which will be desirable additions to your skill set when looking for a job.
They have strong communities and good documentation. It is very important to be able to get help with learning a complex subject, especially when you are just starting out.
We don't have the resources to cover all modern frameworks. That list would be very difficult to keep up-to-date anyway, as new ones appear all the time.
As a beginner, trying to choose what to focus on out of the huge number of choices available is a very real problem. Keeping the list short is therefore helpful.

We want to say this upfront — we've not chosen the frameworks we are focusing on because we think they are the best, or because we endorse them in any way. We just think they score highly on the above criteria.
 Overview: Core learning modules Next\n\nJavaScript frameworks and libraries Overview: Core learning modules Next  
JavaScript frameworks are an essential part of modern front-end web development, providing developers with tried and tested tools for building scalable, interactive web applications. Many modern companies use frameworks as a standard part of their tooling, so many front-end development jobs now require framework experience. In this set of articles, we are aiming to give you a comfortable starting point to help you begin learning frameworks.
As an aspiring front-end developer, it can be hard to work out where to begin when learning frameworks — there are so many frameworks to choose from, new ones appear all the time, they mostly work in a similar way but do some things differently, and there are some specific things to be careful about when using frameworks.
We are not aiming to exhaustively teach you everything you need to know about React/ReactDOM, or Vue, or some other specific framework; the framework teams' own docs (and other resources) do that job already. Instead, we want to back up and first answer more fundamental questions such as:

Why should I use a framework? What problems do they solve for me?
What questions should I ask when trying to choose a framework? Do I even need to use a framework?
What features do frameworks have? How do they work in general, and how do frameworks' implementations of these features differ?
How do they relate to "vanilla" JavaScript or HTML?

After that, we'll provide some tutorials covering the essentials React, a popular framework choice, to provide you with enough context and familiarity to start going into greater depth yourself. We want you to go forward and learn about frameworks in a pragmatic way that doesn't forget about web platform fundamental best practices such as accessibility.
We also provide some tutorials covering the basics of other framework choices, for those who want to make a different choice to React.PrerequisitesYou should really learn the basics of the core web languages first before attempting to move on to learning client-side frameworks — HTML, CSS, and especially JavaScript.
Your code will be richer and more professional as a result, and you'll be able to troubleshoot problems with more confidence if you understand the fundamental web platform features that the frameworks are building on top of.Introductory tutorials
Introduction to client-side frameworks

We begin our look at frameworks with a general overview of the area, looking at a brief history of JavaScript and frameworks, why frameworks exist and what they give us, how to start thinking about choosing a framework to learn, and what alternatives there are to client-side frameworks.

Framework main features

Each major JavaScript framework has a different approach to updating the DOM, handling browser events, and providing an enjoyable developer experience. This article will explore the main features of "the big 4" frameworks, looking at how frameworks tend to work from a high level and the differences between them.

React tutorials
Note:
React tutorials last tested in January 2023, with React/ReactDOM 18.2.0 and create-react-app 5.0.1.
If you need to check your code against our version, you can find a finished version of the sample React app code in our todo-react repository. For a running live version, see https://mdn.github.io/todo-react/.


Getting started with React

In this article we will say hello to React. We'll discover a little bit of detail about its background and use cases, set up a basic React toolchain on our local computer, and create and play with a simple starter app, learning a bit about how React works in the process.

Beginning our React ToDo app

Let's say that we've been tasked with creating a proof-of-concept in React – an app that allows users to add, edit, and delete tasks they want to work on, and also mark tasks as complete without deleting them. This article will walk you through putting the basic App component structure and styling in place, ready for individual component definition and interactivity, which we'll add later.

Componentizing our React app

At this point, our app is a monolith. Before we can make it do things, we need to break it apart into manageable, descriptive components. React doesn't have any hard rules for what is and isn't a component – that's up to you! In this article, we will show you a sensible way to break our app up into components.

React interactivity: Events and state

With our component plan worked out, it's now time to start updating our app from a completely static UI to one that actually allows us to interact and change things. In this article we'll do this, digging into events and state along the way.

React interactivity: Editing, filtering, conditional rendering

As we near the end of our React journey (for now at least), we'll add the finishing touches to the main areas of functionality in our Todo list app. This includes allowing you to edit existing tasks and filtering the list of tasks between all, completed, and incomplete tasks. We'll look at conditional UI rendering along the way.

Accessibility in React

In our final tutorial article, we'll focus on (pun intended) accessibility, including focus management in React, which can improve usability and reduce confusion for both keyboard-only and screen reader users.

React resources

Our final article provides you with a list of React resources that you can use to go further in your learning.

Other framework choicesEmber tutorials
Note:
Ember tutorials last tested in May 2020, with Ember/Ember CLI version 3.18.0.
If you need to check your code against our version, you can find a finished version of the sample Ember app code in the ember-todomvc-tutorial repository. For a running live version, see https://nullvoxpopuli.github.io/ember-todomvc-tutorial/ (this also includes a few additional features not covered in the tutorial).


Getting started with Ember

In our first Ember article we will look at how Ember works and what it's useful for, install the Ember toolchain locally, create a sample app, and then do some initial setup to get it ready for development.

Ember app structure and componentization

In this article we'll get right on with planning out the structure of our TodoMVC Ember app, adding in the HTML for it, and then breaking that HTML structure into components.

Ember interactivity: Events, classes and state

At this point we'll start adding some interactivity to our app, providing the ability to add and display new todo items. Along the way, we'll look at using events in Ember, creating component classes to contain JavaScript code to control interactive features, and setting up a service to keep track of the data state of our app.

Ember Interactivity: Footer functionality, conditional rendering

Now it's time to start tackling the footer functionality in our app. Here we'll get the todo counter to update to show the correct number of todos still to complete, and correctly apply styling to completed todos (i.e., where the checkbox has been checked). We'll also wire up our "Clear completed" button. Along the way, we'll learn about using conditional rendering in our templates.

Routing in Ember

In this article we learn about routing or URL-based filtering as it is sometimes referred to. We'll use it to provide a unique URL for each of the three todo views — "All", "Active", and "Completed".

Ember resources and troubleshooting

Our final Ember article provides you with a list of resources that you can use to go further in your learning, plus some useful troubleshooting and other information.

Vue tutorials
Note:
Vue tutorial last tested in January 2023, with Vue 3.2.45.
If you need to check your code against our version, you can find a finished version of the sample Vue app code in our todo-vue repository. For a running live version, see https://mdn.github.io/todo-vue/.


Getting started with Vue

Now let's introduce Vue, the third of our frameworks. In this article, we'll look at a little bit of Vue background, learn how to install it and create a new project, study the high-level structure of the whole project and an individual component, see how to run the project locally, and get it prepared to start building our example.

Creating our first Vue component

Now it's time to dive deeper into Vue, and create our own custom component — we'll start by creating a component to represent each item in the todo list. Along the way, we'll learn about a few important concepts such as calling components inside other components, passing data to them via props and saving data state.

Rendering a list of Vue components

At this point we've got a fully working component; we're now ready to add multiple ToDoItem components to our app. In this article we'll look at adding a set of todo item data to our App.vue component, which we'll then loop through and display inside ToDoItem components using the v-for directive.

Adding a new todo form: Vue events, methods, and models

We now have sample data in place and a loop that takes each bit of data and renders it inside a ToDoItem in our app. What we really need next is the ability to allow our users to enter their own todo items into the app, and for that, we'll need a text <input>, an event to fire when the data is submitted, a method to fire upon submission to add the data and rerender the list, and a model to control the data. This is what we'll cover in this article.

Styling Vue components with CSS

The time has finally come to make our app look a bit nicer. In this article, we'll explore the different ways of styling Vue components with CSS.

Using Vue computed properties

In this article we'll add a counter that displays the number of completed todo items, using a feature of Vue called computed properties. These work similarly to methods but only re-run when one of their dependencies changes.

Vue conditional rendering: editing existing todos

Now it is time to add one of the major parts of functionality that we're still missing — the ability to edit existing todo items. To do this, we will take advantage of Vue's conditional rendering capabilities — namely v-if and v-else — to allow us to toggle between the existing todo item view and an edit view where you can update todo item labels. We'll also look at adding functionality to delete todo items.

Vue refs and lifecycle methods for focus management

We are nearly done with Vue. The last bit of functionality to look at is focus management, or put another way, how we can improve our app's keyboard accessibility. We'll look at using Vue refs to handle this — an advanced feature that allows you to have direct access to the underlying DOM nodes below the virtual DOM, or direct access from one component to the internal DOM structure of a child component.

Vue resources

Now we'll round off our study of Vue by giving you a list of resources that you can use to go further in your learning, plus some other useful tips.

Svelte tutorials
Note:
Svelte tutorials last tested in August 2020, with Svelte 3.24.1.
If you need to check your code against our version, you can find a finished version of the sample Svelte app code as it should be after each article, in our mdn-svelte-tutorial repo. For a running live version, see our Svelte REPL at https://svelte.dev/repl/378dd79e0dfe4486a8f10823f3813190?version=3.23.2.


Getting started with Svelte

In this article we'll provide a quick introduction to the Svelte framework. We will see how Svelte works and what sets it apart from the rest of the frameworks and tools we've seen so far. Then we will learn how to set up our development environment, create a sample app, understand the structure of the project, and see how to run it locally and build it for production.

Starting our Svelte Todo list app

Now that we have a basic understanding of how things work in Svelte, we can start building our example app: a todo list. In this article we will first have a look at the desired functionality of our app, then we'll create a Todos.svelte component and put static markup and styles in place, leaving everything ready to start developing our To-Do list app features, which we'll go on to in subsequent articles.

Dynamic behavior in Svelte: working with variables and props

Now that we have our markup and styles ready we can start developing the required features for our Svelte To-Do list app. In this article we'll be using variables and props to make our app dynamic, allowing us to add and delete todos, mark them as complete, and filter them by status.

Componentizing our Svelte app

The central objective of this article is to look at how to break our app into manageable components and share information between them. We'll componentize our app, then add more functionality to allow users to update existing components.

Advanced Svelte: Reactivity, lifecycle, accessibility

In this article we will add the app's final features and further componentize our app. We will learn how to deal with reactivity issues related to updating objects and arrays. To avoid common pitfalls, we'll have to dig a little deeper into Svelte's reactivity system. We'll also look at solving some accessibility focus issues, and more besides.

Working with Svelte stores

In this article we will show another way to handle state management in Svelte — Stores. Stores are global data repositories that hold values. Components can subscribe to stores and receive notifications when their values change.

TypeScript support in Svelte

We will now learn how to use TypeScript in Svelte applications. First we'll learn what TypeScript is and what benefits it can bring us. Then we'll see how to configure our project to work with TypeScript files. Finally we will go over our app and see what modifications we have to make to fully take advantage of TypeScript features.

Deployment and next steps

In this final article we will look at how to deploy your application and get it online, and also share some of the resources that you should go on to, to continue your Svelte learning journey.

Angular tutorials
Note:
Angular tutorials last tested in April 2021, with Angular CLI (NG) 11.2.5.


Getting started with Angular

In this article we look at what Angular has to offer, install the prerequisites and set up a sample app, and look at Angular's basic architecture.

Beginning our Angular todo list app

At this point, we are ready to start creating our to-do list application using Angular. The finished application will display a list of to-do items and includes editing, deleting, and adding features. In this article you will get to know your application structure, and work up to displaying a basic list of to-do items.

Styling our Angular app

Now that we've got our basic application structure set up and started displaying something useful, let's switch gears and spend an article looking at how Angular handles styling of applications.

Creating an item component

Components provide a way for you to organize your application. This article walks you through creating a component to handle the individual items in the list, and adding check, edit, and delete functionality. The Angular event model is covered here.

Filtering our to-do items

Now let's move on to adding functionality to allow users to filter their to-do items, so they can view active, completed, or all items.

Building Angular applications and further resources

This final Angular article covers how to build an app ready for production, and provides further resources for you to continue your learning journey.

Which frameworks did we choose?We cover five frameworks in our tutorials — Angular, Ember, React/ReactDOM, Svelte, and Vue:

They are popular choices that will be around for a while — like with any software tool, it is good to stick with actively-developed choices that are likely to not be discontinued next week, and which will be desirable additions to your skill set when looking for a job.
They have strong communities and good documentation. It is very important to be able to get help with learning a complex subject, especially when you are just starting out.
We don't have the resources to cover all modern frameworks. That list would be very difficult to keep up-to-date anyway, as new ones appear all the time.
As a beginner, trying to choose what to focus on out of the huge number of choices available is a very real problem. Keeping the list short is therefore helpful.

We want to say this upfront — we've not chosen the frameworks we are focusing on because we think they are the best, or because we endorse them in any way. We just think they score highly on the above criteria.
 Overview: Core learning modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJavaScript frameworks and libraries Overview: Core learning modules Next  
JavaScript frameworks are an essential part of modern front-end web development, providing developers with tried and tested tools for building scalable, interactive web applications. Many modern companies use frameworks as a standard part of their tooling, so many front-end development jobs now require framework experience. In this set of articles, we are aiming to give you a comfortable starting point to help you begin learning frameworks.
As an aspiring front-end developer, it can be hard to work out where to begin when learning frameworks — there are so many frameworks to choose from, new ones appear all the time, they mostly work in a similar way but do some things differently, and there are some specific things to be careful about when using frameworks.
We are not aiming to exhaustively teach you everything you need to know about React/ReactDOM, or Vue, or some other specific framework; the framework teams' own docs (and other resources) do that job already. Instead, we want to back up and first answer more fundamental questions such as:

Why should I use a framework? What problems do they solve for me?
What questions should I ask when trying to choose a framework? Do I even need to use a framework?
What features do frameworks have? How do they work in general, and how do frameworks' implementations of these features differ?
How do they relate to "vanilla" JavaScript or HTML?

After that, we'll provide some tutorials covering the essentials React, a popular framework choice, to provide you with enough context and familiarity to start going into greater depth yourself. We want you to go forward and learn about frameworks in a pragmatic way that doesn't forget about web platform fundamental best practices such as accessibility.
We also provide some tutorials covering the basics of other framework choices, for those who want to make a different choice to React.PrerequisitesYou should really learn the basics of the core web languages first before attempting to move on to learning client-side frameworks — HTML, CSS, and especially JavaScript.
Your code will be richer and more professional as a result, and you'll be able to troubleshoot problems with more confidence if you understand the fundamental web platform features that the frameworks are building on top of.Introductory tutorials
Introduction to client-side frameworks

We begin our look at frameworks with a general overview of the area, looking at a brief history of JavaScript and frameworks, why frameworks exist and what they give us, how to start thinking about choosing a framework to learn, and what alternatives there are to client-side frameworks.

Framework main features

Each major JavaScript framework has a different approach to updating the DOM, handling browser events, and providing an enjoyable developer experience. This article will explore the main features of "the big 4" frameworks, looking at how frameworks tend to work from a high level and the differences between them.

React tutorials
Note:
React tutorials last tested in January 2023, with React/ReactDOM 18.2.0 and create-react-app 5.0.1.
If you need to check your code against our version, you can find a finished version of the sample React app code in our todo-react repository. For a running live version, see https://mdn.github.io/todo-react/.


Getting started with React

In this article we will say hello to React. We'll discover a little bit of detail about its background and use cases, set up a basic React toolchain on our local computer, and create and play with a simple starter app, learning a bit about how React works in the process.

Beginning our React ToDo app

Let's say that we've been tasked with creating a proof-of-concept in React – an app that allows users to add, edit, and delete tasks they want to work on, and also mark tasks as complete without deleting them. This article will walk you through putting the basic App component structure and styling in place, ready for individual component definition and interactivity, which we'll add later.

Componentizing our React app

At this point, our app is a monolith. Before we can make it do things, we need to break it apart into manageable, descriptive components. React doesn't have any hard rules for what is and isn't a component – that's up to you! In this article, we will show you a sensible way to break our app up into components.

React interactivity: Events and state

With our component plan worked out, it's now time to start updating our app from a completely static UI to one that actually allows us to interact and change things. In this article we'll do this, digging into events and state along the way.

React interactivity: Editing, filtering, conditional rendering

As we near the end of our React journey (for now at least), we'll add the finishing touches to the main areas of functionality in our Todo list app. This includes allowing you to edit existing tasks and filtering the list of tasks between all, completed, and incomplete tasks. We'll look at conditional UI rendering along the way.

Accessibility in React

In our final tutorial article, we'll focus on (pun intended) accessibility, including focus management in React, which can improve usability and reduce confusion for both keyboard-only and screen reader users.

React resources

Our final article provides you with a list of React resources that you can use to go further in your learning.

Other framework choicesEmber tutorials
Note:
Ember tutorials last tested in May 2020, with Ember/Ember CLI version 3.18.0.
If you need to check your code against our version, you can find a finished version of the sample Ember app code in the ember-todomvc-tutorial repository. For a running live version, see https://nullvoxpopuli.github.io/ember-todomvc-tutorial/ (this also includes a few additional features not covered in the tutorial).


Getting started with Ember

In our first Ember article we will look at how Ember works and what it's useful for, install the Ember toolchain locally, create a sample app, and then do some initial setup to get it ready for development.

Ember app structure and componentization

In this article we'll get right on with planning out the structure of our TodoMVC Ember app, adding in the HTML for it, and then breaking that HTML structure into components.

Ember interactivity: Events, classes and state

At this point we'll start adding some interactivity to our app, providing the ability to add and display new todo items. Along the way, we'll look at using events in Ember, creating component classes to contain JavaScript code to control interactive features, and setting up a service to keep track of the data state of our app.

Ember Interactivity: Footer functionality, conditional rendering

Now it's time to start tackling the footer functionality in our app. Here we'll get the todo counter to update to show the correct number of todos still to complete, and correctly apply styling to completed todos (i.e., where the checkbox has been checked). We'll also wire up our "Clear completed" button. Along the way, we'll learn about using conditional rendering in our templates.

Routing in Ember

In this article we learn about routing or URL-based filtering as it is sometimes referred to. We'll use it to provide a unique URL for each of the three todo views — "All", "Active", and "Completed".

Ember resources and troubleshooting

Our final Ember article provides you with a list of resources that you can use to go further in your learning, plus some useful troubleshooting and other information.

Vue tutorials
Note:
Vue tutorial last tested in January 2023, with Vue 3.2.45.
If you need to check your code against our version, you can find a finished version of the sample Vue app code in our todo-vue repository. For a running live version, see https://mdn.github.io/todo-vue/.


Getting started with Vue

Now let's introduce Vue, the third of our frameworks. In this article, we'll look at a little bit of Vue background, learn how to install it and create a new project, study the high-level structure of the whole project and an individual component, see how to run the project locally, and get it prepared to start building our example.

Creating our first Vue component

Now it's time to dive deeper into Vue, and create our own custom component — we'll start by creating a component to represent each item in the todo list. Along the way, we'll learn about a few important concepts such as calling components inside other components, passing data to them via props and saving data state.

Rendering a list of Vue components

At this point we've got a fully working component; we're now ready to add multiple ToDoItem components to our app. In this article we'll look at adding a set of todo item data to our App.vue component, which we'll then loop through and display inside ToDoItem components using the v-for directive.

Adding a new todo form: Vue events, methods, and models

We now have sample data in place and a loop that takes each bit of data and renders it inside a ToDoItem in our app. What we really need next is the ability to allow our users to enter their own todo items into the app, and for that, we'll need a text <input>, an event to fire when the data is submitted, a method to fire upon submission to add the data and rerender the list, and a model to control the data. This is what we'll cover in this article.

Styling Vue components with CSS

The time has finally come to make our app look a bit nicer. In this article, we'll explore the different ways of styling Vue components with CSS.

Using Vue computed properties

In this article we'll add a counter that displays the number of completed todo items, using a feature of Vue called computed properties. These work similarly to methods but only re-run when one of their dependencies changes.

Vue conditional rendering: editing existing todos

Now it is time to add one of the major parts of functionality that we're still missing — the ability to edit existing todo items. To do this, we will take advantage of Vue's conditional rendering capabilities — namely v-if and v-else — to allow us to toggle between the existing todo item view and an edit view where you can update todo item labels. We'll also look at adding functionality to delete todo items.

Vue refs and lifecycle methods for focus management

We are nearly done with Vue. The last bit of functionality to look at is focus management, or put another way, how we can improve our app's keyboard accessibility. We'll look at using Vue refs to handle this — an advanced feature that allows you to have direct access to the underlying DOM nodes below the virtual DOM, or direct access from one component to the internal DOM structure of a child component.

Vue resources

Now we'll round off our study of Vue by giving you a list of resources that you can use to go further in your learning, plus some other useful tips.

Svelte tutorials
Note:
Svelte tutorials last tested in August 2020, with Svelte 3.24.1.
If you need to check your code against our version, you can find a finished version of the sample Svelte app code as it should be after each article, in our mdn-svelte-tutorial repo. For a running live version, see our Svelte REPL at https://svelte.dev/repl/378dd79e0dfe4486a8f10823f3813190?version=3.23.2.


Getting started with Svelte

In this article we'll provide a quick introduction to the Svelte framework. We will see how Svelte works and what sets it apart from the rest of the frameworks and tools we've seen so far. Then we will learn how to set up our development environment, create a sample app, understand the structure of the project, and see how to run it locally and build it for production.

Starting our Svelte Todo list app

Now that we have a basic understanding of how things work in Svelte, we can start building our example app: a todo list. In this article we will first have a look at the desired functionality of our app, then we'll create a Todos.svelte component and put static markup and styles in place, leaving everything ready to start developing our To-Do list app features, which we'll go on to in subsequent articles.

Dynamic behavior in Svelte: working with variables and props

Now that we have our markup and styles ready we can start developing the required features for our Svelte To-Do list app. In this article we'll be using variables and props to make our app dynamic, allowing us to add and delete todos, mark them as complete, and filter them by status.

Componentizing our Svelte app

The central objective of this article is to look at how to break our app into manageable components and share information between them. We'll componentize our app, then add more functionality to allow users to update existing components.

Advanced Svelte: Reactivity, lifecycle, accessibility

In this article we will add the app's final features and further componentize our app. We will learn how to deal with reactivity issues related to updating objects and arrays. To avoid common pitfalls, we'll have to dig a little deeper into Svelte's reactivity system. We'll also look at solving some accessibility focus issues, and more besides.

Working with Svelte stores

In this article we will show another way to handle state management in Svelte — Stores. Stores are global data repositories that hold values. Components can subscribe to stores and receive notifications when their values change.

TypeScript support in Svelte

We will now learn how to use TypeScript in Svelte applications. First we'll learn what TypeScript is and what benefits it can bring us. Then we'll see how to configure our project to work with TypeScript files. Finally we will go over our app and see what modifications we have to make to fully take advantage of TypeScript features.

Deployment and next steps

In this final article we will look at how to deploy your application and get it online, and also share some of the resources that you should go on to, to continue your Svelte learning journey.

Angular tutorials
Note:
Angular tutorials last tested in April 2021, with Angular CLI (NG) 11.2.5.


Getting started with Angular

In this article we look at what Angular has to offer, install the prerequisites and set up a sample app, and look at Angular's basic architecture.

Beginning our Angular todo list app

At this point, we are ready to start creating our to-do list application using Angular. The finished application will display a list of to-do items and includes editing, deleting, and adding features. In this article you will get to know your application structure, and work up to displaying a basic list of to-do items.

Styling our Angular app

Now that we've got our basic application structure set up and started displaying something useful, let's switch gears and spend an article looking at how Angular handles styling of applications.

Creating an item component

Components provide a way for you to organize your application. This article walks you through creating a component to handle the individual items in the list, and adding check, edit, and delete functionality. The Angular event model is covered here.

Filtering our to-do items

Now let's move on to adding functionality to allow users to filter their to-do items, so they can view active, completed, or all items.

Building Angular applications and further resources

This final Angular article covers how to build an app ready for production, and provides further resources for you to continue your learning journey.

Which frameworks did we choose?We cover five frameworks in our tutorials — Angular, Ember, React/ReactDOM, Svelte, and Vue:

They are popular choices that will be around for a while — like with any software tool, it is good to stick with actively-developed choices that are likely to not be discontinued next week, and which will be desirable additions to your skill set when looking for a job.
They have strong communities and good documentation. It is very important to be able to get help with learning a complex subject, especially when you are just starting out.
We don't have the resources to cover all modern frameworks. That list would be very difficult to keep up-to-date anyway, as new ones appear all the time.
As a beginner, trying to choose what to focus on out of the huge number of choices available is a very real problem. Keeping the list short is therefore helpful.

We want to say this upfront — we've not chosen the frameworks we are focusing on because we think they are the best, or because we endorse them in any way. We just think they score highly on the above criteria.
 Overview: Core learning modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJavaScript GuideThe JavaScript Guide shows you how to use JavaScript and gives an overview of the language. If you need exhaustive information about a language feature, have a look at the JavaScript reference.
This Guide is divided into the following chapters.IntroductionOverview: Introduction

About this guide
About JavaScript
JavaScript and Java
ECMAScript
Tools
What's next
Grammar and typesOverview: Grammar and types

Basic syntax & comments
Declarations
Variable scope
Variable hoisting
Data structures and types
Literals
Control flow and error handlingOverview: Control flow and error handling

if...else
switch
try/catch/throw
Error objects
Loops and iterationOverview: Loops and iteration

for
while
do...while
continue
break
for...in
for...of
FunctionsOverview: Functions

Defining functions
Calling functions
Function scopes and closures
Arguments & parameters
Arrow functions
Expressions and operatorsOverview: Expressions and operators

Assignment & Comparisons
Arithmetic operators
Bitwise & logical operators
Conditional (ternary) operator
Numbers and stringsOverview: Numbers and strings

Numbers
Number object
Math object
Strings
String object
Template literals
Representing dates & timesOverview: Representing dates & times

Date object
Regular expressionsOverview: Regular expressions

Creating a regular expression
Writing a regular expression pattern

Assertions
Character classes
Groups and backreferences
Quantifiers


Indexed collectionsOverview: Indexed collectionsKeyed collectionsOverview: Keyed collections

Map
WeakMap
Set
WeakSet
Working with objectsOverview: Working with objects

Objects and properties
Creating objects
Defining methods
Getter and setter
Using classesOverview: Using classes

Declaring a class
Various class features
Extends and inheritance
Why classes?
PromisesOverview: Promises

Guarantees
Chaining
Error handling
Composition
Timing
Typed arraysOverview: Typed arraysIterators and generatorsOverview: Iterators and generators

Iterators
Iterables
Generators
InternationalizationOverview: Internationalization

Date and time formatting
Number formatting
Collation
Meta programmingOverview: Meta programming

Proxy
Handlers and traps
Revocable Proxy
Reflect
JavaScript modulesOverview: JavaScript modules

Exporting
Importing
Default exports
Renaming features
Aggregating modules
Dynamic module loading

 Next\n\nJavaScript GuideThe JavaScript Guide shows you how to use JavaScript and gives an overview of the language. If you need exhaustive information about a language feature, have a look at the JavaScript reference.
This Guide is divided into the following chapters.IntroductionOverview: Introduction

About this guide
About JavaScript
JavaScript and Java
ECMAScript
Tools
What's next
Grammar and typesOverview: Grammar and types

Basic syntax & comments
Declarations
Variable scope
Variable hoisting
Data structures and types
Literals
Control flow and error handlingOverview: Control flow and error handling

if...else
switch
try/catch/throw
Error objects
Loops and iterationOverview: Loops and iteration

for
while
do...while
continue
break
for...in
for...of
FunctionsOverview: Functions

Defining functions
Calling functions
Function scopes and closures
Arguments & parameters
Arrow functions
Expressions and operatorsOverview: Expressions and operators

Assignment & Comparisons
Arithmetic operators
Bitwise & logical operators
Conditional (ternary) operator
Numbers and stringsOverview: Numbers and strings

Numbers
Number object
Math object
Strings
String object
Template literals
Representing dates & timesOverview: Representing dates & times

Date object
Regular expressionsOverview: Regular expressions

Creating a regular expression
Writing a regular expression pattern

Assertions
Character classes
Groups and backreferences
Quantifiers


Indexed collectionsOverview: Indexed collectionsKeyed collectionsOverview: Keyed collections

Map
WeakMap
Set
WeakSet
Working with objectsOverview: Working with objects

Objects and properties
Creating objects
Defining methods
Getter and setter
Using classesOverview: Using classes

Declaring a class
Various class features
Extends and inheritance
Why classes?
PromisesOverview: Promises

Guarantees
Chaining
Error handling
Composition
Timing
Typed arraysOverview: Typed arraysIterators and generatorsOverview: Iterators and generators

Iterators
Iterables
Generators
InternationalizationOverview: Internationalization

Date and time formatting
Number formatting
Collation
Meta programmingOverview: Meta programming

Proxy
Handlers and traps
Revocable Proxy
Reflect
JavaScript modulesOverview: JavaScript modules

Exporting
Importing
Default exports
Renaming features
Aggregating modules
Dynamic module loading

 Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 4, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJavaScript GuideThe JavaScript Guide shows you how to use JavaScript and gives an overview of the language. If you need exhaustive information about a language feature, have a look at the JavaScript reference.
This Guide is divided into the following chapters.IntroductionOverview: Introduction

About this guide
About JavaScript
JavaScript and Java
ECMAScript
Tools
What's next
Grammar and typesOverview: Grammar and types

Basic syntax & comments
Declarations
Variable scope
Variable hoisting
Data structures and types
Literals
Control flow and error handlingOverview: Control flow and error handling

if...else
switch
try/catch/throw
Error objects
Loops and iterationOverview: Loops and iteration

for
while
do...while
continue
break
for...in
for...of
FunctionsOverview: Functions

Defining functions
Calling functions
Function scopes and closures
Arguments & parameters
Arrow functions
Expressions and operatorsOverview: Expressions and operators

Assignment & Comparisons
Arithmetic operators
Bitwise & logical operators
Conditional (ternary) operator
Numbers and stringsOverview: Numbers and strings

Numbers
Number object
Math object
Strings
String object
Template literals
Representing dates & timesOverview: Representing dates & times

Date object
Regular expressionsOverview: Regular expressions

Creating a regular expression
Writing a regular expression pattern

Assertions
Character classes
Groups and backreferences
Quantifiers


Indexed collectionsOverview: Indexed collectionsKeyed collectionsOverview: Keyed collections

Map
WeakMap
Set
WeakSet
Working with objectsOverview: Working with objects

Objects and properties
Creating objects
Defining methods
Getter and setter
Using classesOverview: Using classes

Declaring a class
Various class features
Extends and inheritance
Why classes?
PromisesOverview: Promises

Guarantees
Chaining
Error handling
Composition
Timing
Typed arraysOverview: Typed arraysIterators and generatorsOverview: Iterators and generators

Iterators
Iterables
Generators
InternationalizationOverview: Internationalization

Date and time formatting
Number formatting
Collation
Meta programmingOverview: Meta programming

Proxy
Handlers and traps
Revocable Proxy
Reflect
JavaScript modulesOverview: JavaScript modules

Exporting
Importing
Default exports
Renaming features
Aggregating modules
Dynamic module loading

 Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 4, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIntroduction 
 Previous  Next  
This chapter introduces JavaScript and discusses some of its fundamental concepts.What you should already knowThis guide assumes you have the following basic background:

A general understanding of the Internet and the World Wide Web (WWW).
Good working knowledge of HyperText Markup Language (HTML).
Some programming experience. If you are new to programming, try one of the tutorials linked on the main page about JavaScript.
Where to find JavaScript informationThe JavaScript documentation on MDN includes the following:

Dynamic scripting with JavaScript provides structured JavaScript guides for beginners and introduces basic concepts of programming and the Internet.
JavaScript Guide (this guide) provides an overview about the JavaScript language and its objects.
JavaScript Reference provides detailed reference material for JavaScript.
What is JavaScript?JavaScript is a cross-platform, object-oriented scripting language used to make webpages interactive (e.g., having complex animations, clickable buttons, popup menus, etc.). There are also more advanced server side versions of JavaScript such as Node.js, which allow you to add more functionality to a website than downloading files (such as realtime collaboration between multiple computers). Inside a host environment (for example, a web browser), JavaScript can be connected to the objects of its environment to provide programmatic control over them.
JavaScript contains a standard library of objects, such as Array, Map, and Math, and a core set of language elements such as operators, control structures, and statements. Core JavaScript can be extended for a variety of purposes by supplementing it with additional objects; for example:

Client-side JavaScript extends the core language by supplying objects to control a browser and its Document Object Model (DOM). For example, client-side extensions allow an application to place elements on an HTML form and respond to user events such as mouse clicks, form input, and page navigation.
Server-side JavaScript extends the core language by supplying objects relevant to running JavaScript on a server. For example, server-side extensions allow an application to communicate with a database, provide continuity of information from one invocation to another of the application, or perform file manipulations on a server.

This means that in the browser, JavaScript can change the way the webpage (DOM) looks. And, likewise, Node.js JavaScript on the server can respond to custom requests sent by code executed in the browser.JavaScript and JavaJavaScript and Java are similar in some ways but fundamentally different in some others. The JavaScript language resembles Java but does not have Java's static typing and strong type checking. JavaScript follows most Java expression syntax, naming conventions and basic control-flow constructs which was the reason why it was renamed from LiveScript to JavaScript.
In contrast to Java's compile-time system of classes built by declarations, JavaScript supports a runtime system based on a small number of data types representing numeric, Boolean, and string values. JavaScript has a prototype-based object model instead of the more common class-based object model. The prototype-based model provides dynamic inheritance; that is, what is inherited can vary for individual objects. JavaScript also supports functions without any special declarative requirements. Functions can be properties of objects, executing as loosely typed methods.
JavaScript is a very free-form language compared to Java. You do not have to declare all variables, classes, and methods. You do not have to be concerned with whether methods are public, private, or protected, and you do not have to implement interfaces. Variables, parameters, and function return types are not explicitly typed.
Java is a class-based programming language designed for fast execution and type safety. Type safety means, for instance, that you can't cast a Java integer into an object reference or access private memory by corrupting the Java bytecode. Java's class-based model means that programs consist exclusively of classes and their methods. Java's class inheritance and strong typing generally require tightly coupled object hierarchies. These requirements make Java programming more complex than JavaScript programming.
In contrast, JavaScript descends in spirit from a line of smaller, dynamically typed languages such as HyperTalk and dBase. These scripting languages offer programming tools to a much wider audience because of their easier syntax, specialized built-in functionality, and minimal requirements for object creation.



JavaScript
Java




Object-oriented. No distinction between types of objects. Inheritance is through the prototype mechanism, and properties and methods can be added to any object dynamically.
Class-based. Objects are divided into classes and instances with all inheritance through the class hierarchy. Classes and instances cannot have properties or methods added dynamically.


Variable data types are not declared (dynamic typing, loosely typed).
Variable data types must be declared (static typing, strongly typed).


Cannot automatically write to hard disk.
Can automatically write to hard disk.


JavaScript and the ECMAScript specificationJavaScript is standardized at Ecma International — the European association for standardizing information and communication systems (ECMA was formerly an acronym for the European Computer Manufacturers Association) to deliver a standardized, international programming language based on JavaScript. This standardized version of JavaScript, called ECMAScript, behaves the same way in all applications that support the standard. Companies can use the open standard language to develop their implementation of JavaScript. The ECMAScript standard is documented in the ECMA-262 specification.
The ECMA-262 standard is also approved by the ISO (International Organization for Standardization) as ISO-16262. You can also find the specification on the Ecma International website. The ECMAScript specification does not describe the Document Object Model (DOM), which is standardized by the World Wide Web Consortium (W3C) and/or WHATWG (Web Hypertext Application Technology Working Group). The DOM defines the way in which HTML document objects are exposed to your script. To get a better idea about the different technologies that are used when programming with JavaScript, consult the article JavaScript technologies overview.JavaScript documentation versus the ECMAScript specificationThe ECMAScript specification is a set of requirements for implementing ECMAScript. It is useful if you want to implement standards-compliant language features in your ECMAScript implementation or engine (such as SpiderMonkey in Firefox, or V8 in Chrome).
The ECMAScript document is not intended to help script programmers. Use the JavaScript documentation for information when writing scripts.
The ECMAScript specification uses terminology and syntax that may be unfamiliar to a JavaScript programmer. Although the description of the language may differ in ECMAScript, the language itself remains the same. JavaScript supports all functionality outlined in the ECMAScript specification.
The JavaScript documentation describes aspects of the language that are appropriate for a JavaScript programmer.Getting started with JavaScriptTo get started with JavaScript, all you need is a modern web browser. Recent versions of Firefox, Chrome, Microsoft Edge, and Safari all support the features discussed in this guide.
A very useful tool for exploring JavaScript is the JavaScript Console (sometimes called the Web Console, or just the console): this is a tool which enables you to enter JavaScript and run it in the current page.
The screenshots here show the Firefox Web Console, but all modern browsers ship with a console that works in a similar way.Opening the consoleThe exact instructions for opening the console vary from one browser to another:

Opening the console in Firefox
Opening the console in Chrome
Opening the console in Microsoft Edge
Entering and running JavaScriptThe console appears at the bottom of the browser window. Along the bottom of the console is an input line that you can use to enter JavaScript, and the output appears in the panel above:

The console works the exact same way as eval: the last expression entered is returned. For the sake of simplicity, it can be imagined that every time something is entered into the console, it is actually surrounded by console.log around eval, like so:
jsconsole.log(eval("3 + 5"));
Multi-line input in the consoleBy default, if you press Enter (or Return, depending on your keyboard) after entering a line of code, then the string you typed is executed. To enter multi-line input:

If the string you typed was incomplete (for example, you typed function foo() {) then the console will treat Enter as a line break, and let you type another line.
If you hold down Shift while pressing Enter, then the console will treat this as a line break, and let you type another line.
In Firefox only, you can activate multi-line input mode, in which you can enter multiple lines in a mini-editor, then run the whole thing when you are ready.

To get started with writing JavaScript, open the console, copy the following code, and paste it in at the prompt:
js(function () {
  "use strict";
  /* Start of your code */
  function greetMe(yourName) {
    alert(`Hello ${yourName}`);
  }

  greetMe("World");
  /* End of your code */
})();

Press Enter to watch it unfold in your browser!What's nextIn the following pages, this guide introduces you to the JavaScript syntax and language features, so that you will be able to write more complex applications.
But for now, remember to always include the (function(){"use strict"; before your code, and add })(); to the end of your code. The strict mode and IIFE articles explain what those do, but for now they can be thought of as doing the following:

Prevent semantics in JavaScript that trip up beginners.
Prevent code snippets executed in the console from interacting with one another (e.g., having something created in one console execution being used for a different console execution).

 Previous  Next\n\nIntroduction 
 Previous  Next  
This chapter introduces JavaScript and discusses some of its fundamental concepts.What you should already knowThis guide assumes you have the following basic background:

A general understanding of the Internet and the World Wide Web (WWW).
Good working knowledge of HyperText Markup Language (HTML).
Some programming experience. If you are new to programming, try one of the tutorials linked on the main page about JavaScript.
Where to find JavaScript informationThe JavaScript documentation on MDN includes the following:

Dynamic scripting with JavaScript provides structured JavaScript guides for beginners and introduces basic concepts of programming and the Internet.
JavaScript Guide (this guide) provides an overview about the JavaScript language and its objects.
JavaScript Reference provides detailed reference material for JavaScript.
What is JavaScript?JavaScript is a cross-platform, object-oriented scripting language used to make webpages interactive (e.g., having complex animations, clickable buttons, popup menus, etc.). There are also more advanced server side versions of JavaScript such as Node.js, which allow you to add more functionality to a website than downloading files (such as realtime collaboration between multiple computers). Inside a host environment (for example, a web browser), JavaScript can be connected to the objects of its environment to provide programmatic control over them.
JavaScript contains a standard library of objects, such as Array, Map, and Math, and a core set of language elements such as operators, control structures, and statements. Core JavaScript can be extended for a variety of purposes by supplementing it with additional objects; for example:

Client-side JavaScript extends the core language by supplying objects to control a browser and its Document Object Model (DOM). For example, client-side extensions allow an application to place elements on an HTML form and respond to user events such as mouse clicks, form input, and page navigation.
Server-side JavaScript extends the core language by supplying objects relevant to running JavaScript on a server. For example, server-side extensions allow an application to communicate with a database, provide continuity of information from one invocation to another of the application, or perform file manipulations on a server.

This means that in the browser, JavaScript can change the way the webpage (DOM) looks. And, likewise, Node.js JavaScript on the server can respond to custom requests sent by code executed in the browser.JavaScript and JavaJavaScript and Java are similar in some ways but fundamentally different in some others. The JavaScript language resembles Java but does not have Java's static typing and strong type checking. JavaScript follows most Java expression syntax, naming conventions and basic control-flow constructs which was the reason why it was renamed from LiveScript to JavaScript.
In contrast to Java's compile-time system of classes built by declarations, JavaScript supports a runtime system based on a small number of data types representing numeric, Boolean, and string values. JavaScript has a prototype-based object model instead of the more common class-based object model. The prototype-based model provides dynamic inheritance; that is, what is inherited can vary for individual objects. JavaScript also supports functions without any special declarative requirements. Functions can be properties of objects, executing as loosely typed methods.
JavaScript is a very free-form language compared to Java. You do not have to declare all variables, classes, and methods. You do not have to be concerned with whether methods are public, private, or protected, and you do not have to implement interfaces. Variables, parameters, and function return types are not explicitly typed.
Java is a class-based programming language designed for fast execution and type safety. Type safety means, for instance, that you can't cast a Java integer into an object reference or access private memory by corrupting the Java bytecode. Java's class-based model means that programs consist exclusively of classes and their methods. Java's class inheritance and strong typing generally require tightly coupled object hierarchies. These requirements make Java programming more complex than JavaScript programming.
In contrast, JavaScript descends in spirit from a line of smaller, dynamically typed languages such as HyperTalk and dBase. These scripting languages offer programming tools to a much wider audience because of their easier syntax, specialized built-in functionality, and minimal requirements for object creation.



JavaScript
Java




Object-oriented. No distinction between types of objects. Inheritance is through the prototype mechanism, and properties and methods can be added to any object dynamically.
Class-based. Objects are divided into classes and instances with all inheritance through the class hierarchy. Classes and instances cannot have properties or methods added dynamically.


Variable data types are not declared (dynamic typing, loosely typed).
Variable data types must be declared (static typing, strongly typed).


Cannot automatically write to hard disk.
Can automatically write to hard disk.


JavaScript and the ECMAScript specificationJavaScript is standardized at Ecma International — the European association for standardizing information and communication systems (ECMA was formerly an acronym for the European Computer Manufacturers Association) to deliver a standardized, international programming language based on JavaScript. This standardized version of JavaScript, called ECMAScript, behaves the same way in all applications that support the standard. Companies can use the open standard language to develop their implementation of JavaScript. The ECMAScript standard is documented in the ECMA-262 specification.
The ECMA-262 standard is also approved by the ISO (International Organization for Standardization) as ISO-16262. You can also find the specification on the Ecma International website. The ECMAScript specification does not describe the Document Object Model (DOM), which is standardized by the World Wide Web Consortium (W3C) and/or WHATWG (Web Hypertext Application Technology Working Group). The DOM defines the way in which HTML document objects are exposed to your script. To get a better idea about the different technologies that are used when programming with JavaScript, consult the article JavaScript technologies overview.JavaScript documentation versus the ECMAScript specificationThe ECMAScript specification is a set of requirements for implementing ECMAScript. It is useful if you want to implement standards-compliant language features in your ECMAScript implementation or engine (such as SpiderMonkey in Firefox, or V8 in Chrome).
The ECMAScript document is not intended to help script programmers. Use the JavaScript documentation for information when writing scripts.
The ECMAScript specification uses terminology and syntax that may be unfamiliar to a JavaScript programmer. Although the description of the language may differ in ECMAScript, the language itself remains the same. JavaScript supports all functionality outlined in the ECMAScript specification.
The JavaScript documentation describes aspects of the language that are appropriate for a JavaScript programmer.Getting started with JavaScriptTo get started with JavaScript, all you need is a modern web browser. Recent versions of Firefox, Chrome, Microsoft Edge, and Safari all support the features discussed in this guide.
A very useful tool for exploring JavaScript is the JavaScript Console (sometimes called the Web Console, or just the console): this is a tool which enables you to enter JavaScript and run it in the current page.
The screenshots here show the Firefox Web Console, but all modern browsers ship with a console that works in a similar way.Opening the consoleThe exact instructions for opening the console vary from one browser to another:

Opening the console in Firefox
Opening the console in Chrome
Opening the console in Microsoft Edge
Entering and running JavaScriptThe console appears at the bottom of the browser window. Along the bottom of the console is an input line that you can use to enter JavaScript, and the output appears in the panel above:

The console works the exact same way as eval: the last expression entered is returned. For the sake of simplicity, it can be imagined that every time something is entered into the console, it is actually surrounded by console.log around eval, like so:
jsconsole.log(eval("3 + 5"));
Multi-line input in the consoleBy default, if you press Enter (or Return, depending on your keyboard) after entering a line of code, then the string you typed is executed. To enter multi-line input:

If the string you typed was incomplete (for example, you typed function foo() {) then the console will treat Enter as a line break, and let you type another line.
If you hold down Shift while pressing Enter, then the console will treat this as a line break, and let you type another line.
In Firefox only, you can activate multi-line input mode, in which you can enter multiple lines in a mini-editor, then run the whole thing when you are ready.

To get started with writing JavaScript, open the console, copy the following code, and paste it in at the prompt:
js(function () {
  "use strict";
  /* Start of your code */
  function greetMe(yourName) {
    alert(`Hello ${yourName}`);
  }

  greetMe("World");
  /* End of your code */
})();

Press Enter to watch it unfold in your browser!What's nextIn the following pages, this guide introduces you to the JavaScript syntax and language features, so that you will be able to write more complex applications.
But for now, remember to always include the (function(){"use strict"; before your code, and add })(); to the end of your code. The strict mode and IIFE articles explain what those do, but for now they can be thought of as doing the following:

Prevent semantics in JavaScript that trip up beginners.
Prevent code snippets executed in the console from interacting with one another (e.g., having something created in one console execution being used for a different console execution).

 Previous  Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIntroduction 
 Previous  Next  
This chapter introduces JavaScript and discusses some of its fundamental concepts.What you should already knowThis guide assumes you have the following basic background:

A general understanding of the Internet and the World Wide Web (WWW).
Good working knowledge of HyperText Markup Language (HTML).
Some programming experience. If you are new to programming, try one of the tutorials linked on the main page about JavaScript.
Where to find JavaScript informationThe JavaScript documentation on MDN includes the following:

Dynamic scripting with JavaScript provides structured JavaScript guides for beginners and introduces basic concepts of programming and the Internet.
JavaScript Guide (this guide) provides an overview about the JavaScript language and its objects.
JavaScript Reference provides detailed reference material for JavaScript.
What is JavaScript?JavaScript is a cross-platform, object-oriented scripting language used to make webpages interactive (e.g., having complex animations, clickable buttons, popup menus, etc.). There are also more advanced server side versions of JavaScript such as Node.js, which allow you to add more functionality to a website than downloading files (such as realtime collaboration between multiple computers). Inside a host environment (for example, a web browser), JavaScript can be connected to the objects of its environment to provide programmatic control over them.
JavaScript contains a standard library of objects, such as Array, Map, and Math, and a core set of language elements such as operators, control structures, and statements. Core JavaScript can be extended for a variety of purposes by supplementing it with additional objects; for example:

Client-side JavaScript extends the core language by supplying objects to control a browser and its Document Object Model (DOM). For example, client-side extensions allow an application to place elements on an HTML form and respond to user events such as mouse clicks, form input, and page navigation.
Server-side JavaScript extends the core language by supplying objects relevant to running JavaScript on a server. For example, server-side extensions allow an application to communicate with a database, provide continuity of information from one invocation to another of the application, or perform file manipulations on a server.

This means that in the browser, JavaScript can change the way the webpage (DOM) looks. And, likewise, Node.js JavaScript on the server can respond to custom requests sent by code executed in the browser.JavaScript and JavaJavaScript and Java are similar in some ways but fundamentally different in some others. The JavaScript language resembles Java but does not have Java's static typing and strong type checking. JavaScript follows most Java expression syntax, naming conventions and basic control-flow constructs which was the reason why it was renamed from LiveScript to JavaScript.
In contrast to Java's compile-time system of classes built by declarations, JavaScript supports a runtime system based on a small number of data types representing numeric, Boolean, and string values. JavaScript has a prototype-based object model instead of the more common class-based object model. The prototype-based model provides dynamic inheritance; that is, what is inherited can vary for individual objects. JavaScript also supports functions without any special declarative requirements. Functions can be properties of objects, executing as loosely typed methods.
JavaScript is a very free-form language compared to Java. You do not have to declare all variables, classes, and methods. You do not have to be concerned with whether methods are public, private, or protected, and you do not have to implement interfaces. Variables, parameters, and function return types are not explicitly typed.
Java is a class-based programming language designed for fast execution and type safety. Type safety means, for instance, that you can't cast a Java integer into an object reference or access private memory by corrupting the Java bytecode. Java's class-based model means that programs consist exclusively of classes and their methods. Java's class inheritance and strong typing generally require tightly coupled object hierarchies. These requirements make Java programming more complex than JavaScript programming.
In contrast, JavaScript descends in spirit from a line of smaller, dynamically typed languages such as HyperTalk and dBase. These scripting languages offer programming tools to a much wider audience because of their easier syntax, specialized built-in functionality, and minimal requirements for object creation.



JavaScript
Java




Object-oriented. No distinction between types of objects. Inheritance is through the prototype mechanism, and properties and methods can be added to any object dynamically.
Class-based. Objects are divided into classes and instances with all inheritance through the class hierarchy. Classes and instances cannot have properties or methods added dynamically.


Variable data types are not declared (dynamic typing, loosely typed).
Variable data types must be declared (static typing, strongly typed).


Cannot automatically write to hard disk.
Can automatically write to hard disk.


JavaScript and the ECMAScript specificationJavaScript is standardized at Ecma International — the European association for standardizing information and communication systems (ECMA was formerly an acronym for the European Computer Manufacturers Association) to deliver a standardized, international programming language based on JavaScript. This standardized version of JavaScript, called ECMAScript, behaves the same way in all applications that support the standard. Companies can use the open standard language to develop their implementation of JavaScript. The ECMAScript standard is documented in the ECMA-262 specification.
The ECMA-262 standard is also approved by the ISO (International Organization for Standardization) as ISO-16262. You can also find the specification on the Ecma International website. The ECMAScript specification does not describe the Document Object Model (DOM), which is standardized by the World Wide Web Consortium (W3C) and/or WHATWG (Web Hypertext Application Technology Working Group). The DOM defines the way in which HTML document objects are exposed to your script. To get a better idea about the different technologies that are used when programming with JavaScript, consult the article JavaScript technologies overview.JavaScript documentation versus the ECMAScript specificationThe ECMAScript specification is a set of requirements for implementing ECMAScript. It is useful if you want to implement standards-compliant language features in your ECMAScript implementation or engine (such as SpiderMonkey in Firefox, or V8 in Chrome).
The ECMAScript document is not intended to help script programmers. Use the JavaScript documentation for information when writing scripts.
The ECMAScript specification uses terminology and syntax that may be unfamiliar to a JavaScript programmer. Although the description of the language may differ in ECMAScript, the language itself remains the same. JavaScript supports all functionality outlined in the ECMAScript specification.
The JavaScript documentation describes aspects of the language that are appropriate for a JavaScript programmer.Getting started with JavaScriptTo get started with JavaScript, all you need is a modern web browser. Recent versions of Firefox, Chrome, Microsoft Edge, and Safari all support the features discussed in this guide.
A very useful tool for exploring JavaScript is the JavaScript Console (sometimes called the Web Console, or just the console): this is a tool which enables you to enter JavaScript and run it in the current page.
The screenshots here show the Firefox Web Console, but all modern browsers ship with a console that works in a similar way.Opening the consoleThe exact instructions for opening the console vary from one browser to another:

Opening the console in Firefox
Opening the console in Chrome
Opening the console in Microsoft Edge
Entering and running JavaScriptThe console appears at the bottom of the browser window. Along the bottom of the console is an input line that you can use to enter JavaScript, and the output appears in the panel above:

The console works the exact same way as eval: the last expression entered is returned. For the sake of simplicity, it can be imagined that every time something is entered into the console, it is actually surrounded by console.log around eval, like so:
jsconsole.log(eval("3 + 5"));
Multi-line input in the consoleBy default, if you press Enter (or Return, depending on your keyboard) after entering a line of code, then the string you typed is executed. To enter multi-line input:

If the string you typed was incomplete (for example, you typed function foo() {) then the console will treat Enter as a line break, and let you type another line.
If you hold down Shift while pressing Enter, then the console will treat this as a line break, and let you type another line.
In Firefox only, you can activate multi-line input mode, in which you can enter multiple lines in a mini-editor, then run the whole thing when you are ready.

To get started with writing JavaScript, open the console, copy the following code, and paste it in at the prompt:
js(function () {
  "use strict";
  /* Start of your code */
  function greetMe(yourName) {
    alert(`Hello ${yourName}`);
  }

  greetMe("World");
  /* End of your code */
})();

Press Enter to watch it unfold in your browser!What's nextIn the following pages, this guide introduces you to the JavaScript syntax and language features, so that you will be able to write more complex applications.
But for now, remember to always include the (function(){"use strict"; before your code, and add })(); to the end of your code. The strict mode and IIFE articles explain what those do, but for now they can be thought of as doing the following:

Prevent semantics in JavaScript that trip up beginners.
Prevent code snippets executed in the console from interacting with one another (e.g., having something created in one console execution being used for a different console execution).

 Previous  Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nGrammar and types 
 Previous  Next  
This chapter discusses JavaScript's basic grammar, variable declarations, data types and literals.BasicsJavaScript borrows most of its syntax from Java, C, and C++, but it has also been influenced by Awk, Perl, and Python.
JavaScript is case-sensitive and uses the Unicode character set. For example, the word Früh (which means "early" in German) could be used as a variable name.
jsconst Früh = "foobar";

But, the variable früh is not the same as Früh because JavaScript is case sensitive.
In JavaScript, instructions are called statements and are separated by semicolons (;).
A semicolon is not necessary after a statement if it is written on its own line. But if more than one statement on a line is desired, then they must be separated by semicolons.

Note:
ECMAScript also has rules for automatic insertion of semicolons (ASI) to end statements. (For more information, see the detailed reference about JavaScript's lexical grammar.)

It is considered best practice, however, to always write a semicolon after a statement, even when it is not strictly needed. This practice reduces the chances of bugs getting into the code.
The source text of JavaScript script gets scanned from left to right, and is converted into a sequence of input elements which are tokens, control characters, line terminators, comments, or whitespace. (Spaces, tabs, and newline characters are considered whitespace.)CommentsThe syntax of comments is the same as in C++ and in many other languages:
js// a one line comment

/* this is a longer,
 * multi-line comment
 */

You can't nest block comments. This often happens when you accidentally include a */ sequence in your comment, which will terminate the comment.
js/* You can't, however, /* nest comments */ SyntaxError */

In this case, you need to break up the */ pattern. For example, by inserting a backslash:
js/* You can /* nest comments *\/ by escaping slashes */

Comments behave like whitespace, and are discarded during script execution.

Note:
You might also see a third type of comment syntax at the start of some JavaScript files, which looks something like this: #!/usr/bin/env node.
This is called hashbang comment syntax, and is a special comment used to specify the path to a particular JavaScript engine that should execute the script. See Hashbang comments for more details.
DeclarationsJavaScript has three kinds of variable declarations.

var

Declares a variable, optionally initializing it to a value.

let

Declares a block-scoped, local variable, optionally initializing it to a value.

const

Declares a block-scoped, read-only named constant.

VariablesYou use variables as symbolic names for values in your application. The names of variables, called identifiers, conform to certain rules.
A JavaScript identifier usually starts with a letter, underscore (_), or dollar sign ($). Subsequent characters can also be digits (0 – 9). Because JavaScript is case sensitive, letters include the characters A through Z (uppercase) as well as a through z (lowercase).
You can use most Unicode letters such as å and ü in identifiers. (For more details, see the lexical grammar reference.) You can also use Unicode escape sequences to represent characters in identifiers.
Some examples of legal names are Number_hits, temp99, $credit, and _name.Declaring variablesYou can declare a variable in two ways:

With the keyword var. For example, var x = 42. This syntax can be used to declare both local and global variables, depending on the execution context.
With the keyword const or let. For example, let y = 13. This syntax can be used to declare a block-scope local variable. (See Variable scope below.)

You can declare variables to unpack values using the destructuring syntax. For example, const { bar } = foo. This will create a variable named bar and assign to it the value corresponding to the key of the same name from our object foo.
Variables should always be declared before they are used. JavaScript used to allow assigning to undeclared variables, which creates an undeclared global variable. This is an error in strict mode and should be avoided altogether.Declaration and initializationIn a statement like let x = 42, the let x part is called a declaration, and the = 42 part is called an initializer. The declaration allows the variable to be accessed later in code without throwing a ReferenceError, while the initializer assigns a value to the variable. In var and let declarations, the initializer is optional. If a variable is declared without an initializer, it is assigned the value undefined.
jslet x;
console.log(x); // logs "undefined"

In essence, let x = 42 is equivalent to let x; x = 42.
const declarations always need an initializer, because they forbid any kind of assignment after declaration, and implicitly initializing it with undefined is likely a programmer mistake.
jsconst x; // SyntaxError: Missing initializer in const declaration
Variable scopeA variable may belong to one of the following scopes:

Global scope: The default scope for all code running in script mode.
Module scope: The scope for code running in module mode.
Function scope: The scope created with a function.

In addition, variables declared with let or const can belong to an additional scope:

Block scope: The scope created with a pair of curly braces (a block).

When you declare a variable outside of any function, it is called a global variable, because it is available to any other code in the current document. When you declare a variable within a function, it is called a local variable, because it is available only within that function.
let and const declarations can also be scoped to the block statement that they are declared in.
jsif (Math.random() > 0.5) {
  const y = 5;
}
console.log(y); // ReferenceError: y is not defined

However, variables created with var are not block-scoped, but only local to the function (or global scope) that the block resides within.
For example, the following code will log 5, because the scope of x is the global context (or the function context if the code is part of a function). The scope of x is not limited to the immediate if statement block.
jsif (true) {
  var x = 5;
}
console.log(x); // x is 5
Variable hoistingvar-declared variables are hoisted, meaning you can refer to the variable anywhere in its scope, even if its declaration isn't reached yet. You can see var declarations as being "lifted" to the top of its function or global scope. However, if you access a variable before it's declared, the value is always undefined, because only its declaration and default initialization (with undefined) is hoisted, but not its value assignment.
jsconsole.log(x === undefined); // true
var x = 3;

(function () {
  console.log(x); // undefined
  var x = "local value";
})();

The above examples will be interpreted the same as:
jsvar x;
console.log(x === undefined); // true
x = 3;

(function () {
  var x;
  console.log(x); // undefined
  x = "local value";
})();

Because of hoisting, all var statements in a function should be placed as near to the top of the function as possible. This best practice increases the clarity of the code.
Whether let and const are hoisted is a matter of definition debate. Referencing the variable in the block before the variable declaration always results in a ReferenceError, because the variable is in a "temporal dead zone" from the start of the block until the declaration is processed.
jsconsole.log(x); // ReferenceError
const x = 3;

console.log(y); // ReferenceError
let y = 3;

Unlike var declarations, which only hoist the declaration but not its value, function declarations are hoisted entirely — you can safely call the function anywhere in its scope. See the hoisting glossary entry for more discussion.Global variablesGlobal variables are in fact properties of the global object.
In web pages, the global object is window, so you can read and set global variables using the window.variable syntax. In all environments, the globalThis variable (which itself is a global variable) may be used to read and set global variables. This is to provide a consistent interface among various JavaScript runtimes.
Consequently, you can access global variables declared in one window or frame from another window or frame by specifying the window or frame name. For example, if a variable called phoneNumber is declared in a document, you can refer to this variable from an iframe as parent.phoneNumber.ConstantsYou can create a read-only, named constant with the const keyword. The syntax of a constant identifier is the same as any variable identifier: it must start with a letter, underscore, or dollar sign ($), and can contain alphabetic, numeric, or underscore characters.
jsconst PI = 3.14;

A constant cannot change value through assignment or be re-declared while the script is running. It must be initialized to a value. The scope rules for constants are the same as those for let block-scope variables.
You cannot declare a constant with the same name as a function or variable in the same scope. For example:
js// THIS WILL CAUSE AN ERROR
function f() {}
const f = 5;

// THIS WILL CAUSE AN ERROR TOO
function f() {
  const g = 5;
  var g;
}

However, const only prevents re-assignments, but doesn't prevent mutations. The properties of objects assigned to constants are not protected, so the following statement is executed without problems.
jsconst MY_OBJECT = { key: "value" };
MY_OBJECT.key = "otherValue";

Also, the contents of an array are not protected, so the following statement is executed without problems.
jsconst MY_ARRAY = ["HTML", "CSS"];
MY_ARRAY.push("JAVASCRIPT");
console.log(MY_ARRAY); // ['HTML', 'CSS', 'JAVASCRIPT'];
Data structures and typesData typesThe latest ECMAScript standard defines eight data types:


Seven data types that are primitives:

Boolean. true and false.
null. A special keyword denoting a null value. (Because JavaScript is case-sensitive, null is not the same as Null, NULL, or any other variant.)
undefined. A top-level property whose value is not defined.
Number. An integer or floating point number. For example: 42 or 3.14159.
BigInt. An integer with arbitrary precision. For example: 9007199254740992n.
String. A sequence of characters that represent a text value. For example: "Howdy".
Symbol. A data type whose instances are unique and immutable.



and Object


Although these data types are relatively few, they enable you to perform useful operations with your applications. Functions are the other fundamental elements of the language. While functions are technically a kind of object, you can think of objects as named containers for values, and functions as procedures that your script can perform.Data type conversionJavaScript is a dynamically typed language. This means you don't have to specify the data type of a variable when you declare it. It also means that data types are automatically converted as-needed during script execution.
So, for example, you could define a variable as follows:
jslet answer = 42;

And later, you could assign the same variable a string value, for example:
jsanswer = "Thanks for all the fish!";

Because JavaScript is dynamically typed, this assignment does not cause an error message.Numbers and the '+' operatorIn expressions involving numeric and string values with the + operator, JavaScript converts numeric values to strings. For example, consider the following statements:
jsx = "The answer is " + 42; // "The answer is 42"
y = 42 + " is the answer"; // "42 is the answer"
z = "37" + 7; // "377"

With all other operators, JavaScript does not convert numeric values to strings. For example:
js"37" - 7; // 30
"37" * 7; // 259
Converting strings to numbersIn the case that a value representing a number is in memory as a string, there are methods for conversion.

parseInt()
parseFloat()

parseInt only returns whole numbers, so its use is diminished for decimals.

Note:
Additionally, a best practice for parseInt is to always include the radix parameter. The radix parameter is used to specify which numerical system is to be used.

jsparseInt("101", 2); // 5

An alternative method of retrieving a number from a string is with the + (unary plus) operator:
js"1.1" + "1.1"; // '1.11.1'
(+"1.1") + (+"1.1"); // 2.2
// Note: the parentheses are added for clarity, not required.
LiteralsLiterals represent values in JavaScript. These are fixed values—not variables—that you literally provide in your script. This section describes the following types of literals:

Array literals
Boolean literals
Numeric literals
Object literals
RegExp literals
String literals
Array literalsAn array literal is a list of zero or more expressions, each of which represents an array element, enclosed in square brackets ([]). When you create an array using an array literal, it is initialized with the specified values as its elements, and its length is set to the number of arguments specified.
The following example creates the coffees array with three elements and a length of three:
jsconst coffees = ["French Roast", "Colombian", "Kona"];

An array literal creates a new array object every time the literal is evaluated. For example, an array defined with a literal in the global scope is created once when the script loads. However, if the array literal is inside a function, a new array is instantiated every time that function is called.

Note:
Array literals create Array objects. See Array and Indexed collections for details on Array objects.

Extra commas in array literals
If you put two commas in a row in an array literal, the array leaves an empty slot for the unspecified element. The following example creates the fish array:
jsconst fish = ["Lion", , "Angel"];

When you log this array, you will see:
jsconsole.log(fish);
// [ 'Lion', <1 empty item>, 'Angel' ]

Note that the second item is "empty", which is not exactly the same as the actual undefined value. When using array-traversing methods like Array.prototype.map, empty slots are skipped. However, index-accessing fish[1] still returns undefined.
If you include a trailing comma at the end of the list of elements, the comma is ignored.
In the following example, the length of the array is three. There is no myList[3] and myList[1] is empty. All other commas in the list indicate a new element.
jsconst myList = ["home", , "school"];

In the following example, the length of the array is four, and myList[0] and myList[2] are missing.
jsconst myList = [, "home", , "school"];

In the following example, the length of the array is four, and myList[1] and myList[3] are missing. Only the last comma is ignored.
jsconst myList = ["home", , "school", ,];


Note: Trailing commas help keep git diffs clean when you have a multi-line array, because appending an item to the end only adds one line, but does not modify the previous line.
diffconst myList = [
  "home",
  "school",
+ "hospital",
];


Understanding the behavior of extra commas is important to understanding JavaScript as a language.
However, when writing your own code, you should explicitly declare the missing elements as undefined, or at least insert a comment to highlight its absence. Doing this increases your code's clarity and maintainability.
jsconst myList = ["home", /* empty */, "school", /* empty */, ];
Boolean literalsThe Boolean type has two literal values: true and false.

Note:
Do not confuse the primitive Boolean values true and false with the true and false values of the Boolean object.
The Boolean object is a wrapper around the primitive Boolean data type. See Boolean for more information.
Numeric literalsJavaScript numeric literals include integer literals in different bases as well as floating-point literals in base-10.
Note that the language specification requires numeric literals to be unsigned. Nevertheless, code fragments like -123.4 are fine, being interpreted as a unary - operator applied to the numeric literal 123.4.
Integer literals
Integer and BigInt literals can be written in decimal (base 10), hexadecimal (base 16), octal (base 8) and binary (base 2).

A decimal integer literal is a sequence of digits without a leading 0 (zero).
A leading 0 (zero) on an integer literal, or a leading 0o (or 0O) indicates it is in octal. Octal integer literals can include only the digits 0 – 7.
A leading 0x (or 0X) indicates a hexadecimal integer literal. Hexadecimal integers can include digits (0 – 9) and the letters a – f and A – F. (The case of a character does not change its value. Therefore: 0xa = 0xA = 10 and 0xf = 0xF = 15.)
A leading 0b (or 0B) indicates a binary integer literal. Binary integer literals can only include the digits 0 and 1.
A trailing n suffix on an integer literal indicates a BigInt literal. The BigInt literal can use any of the above bases. Note that leading-zero octal syntax like 0123n is not allowed, but 0o123n is fine.

Some examples of integer literals are:
0, 117, 123456789123456789n             (decimal, base 10)
015, 0001, 0o777777777777n              (octal, base 8)
0x1123, 0x00111, 0x123456789ABCDEFn     (hexadecimal, "hex" or base 16)
0b11, 0b0011, 0b11101001010101010101n   (binary, base 2)

For more information, see Numeric literals in the Lexical grammar reference.
Floating-point literals
A floating-point literal can have the following parts:

An unsigned decimal integer,
A decimal point (.),
A fraction (another decimal number),
An exponent.

The exponent part is an e or E followed by an integer, which can be signed (preceded by + or -). A floating-point literal must have at least one digit, and either a decimal point or e (or E).
More succinctly, the syntax is:
[digits].[digits][(E|e)[(+|-)]digits]

For example:
js3.1415926
.123456789
3.1E+12
.1e-23
Object literalsAn object literal is a list of zero or more pairs of property names and associated values of an object, enclosed in curly braces ({}).

Warning:
Do not use an object literal at the beginning of a statement! This will lead to an error (or not behave as you expect), because the { will be interpreted as the beginning of a block.

The following is an example of an object literal. The first element of the car object defines a property, myCar, and assigns to it a new string, "Saturn"; the second element, the getCar property, is immediately assigned the result of invoking the function (carTypes("Honda")); the third element, the special property, uses an existing variable (sales).
jsconst sales = "Toyota";

function carTypes(name) {
  return name === "Honda" ? name : `Sorry, we don't sell ${name}.`;
}

const car = { myCar: "Saturn", getCar: carTypes("Honda"), special: sales };

console.log(car.myCar); // Saturn
console.log(car.getCar); // Honda
console.log(car.special); // Toyota

Additionally, you can use a numeric or string literal for the name of a property or nest an object inside another. The following example uses these options.
jsconst car = { manyCars: { a: "Saab", b: "Jeep" }, 7: "Mazda" };

console.log(car.manyCars.b); // Jeep
console.log(car[7]); // Mazda

Object property names can be any string, including the empty string. If the property name would not be a valid JavaScript identifier or number, it must be enclosed in quotes.
Property names that are not valid identifiers cannot be accessed as a dot (.) property.
jsconst unusualPropertyNames = {
  "": "An empty string",
  "!": "Bang!",
};
console.log(unusualPropertyNames.""); // SyntaxError: Unexpected string
console.log(unusualPropertyNames.!); // SyntaxError: Unexpected token !

Instead, they must be accessed with the bracket notation ([]).
jsconsole.log(unusualPropertyNames[""]); // An empty string
console.log(unusualPropertyNames["!"]); // Bang!

Enhanced Object literals
Object literals support a range of shorthand syntaxes that include setting the prototype at construction, shorthand for foo: foo assignments, defining methods, making super calls, and computing property names with expressions.
Together, these also bring object literals and class declarations closer together, and allow object-based design to benefit from some of the same conveniences.
jsconst obj = {
  // __proto__
  __proto__: theProtoObj,
  // Shorthand for 'handler: handler'
  handler,
  // Methods
  toString() {
    // Super calls
    return "d " + super.toString();
  },
  // Computed (dynamic) property names
  ["prop_" + (() => 42)()]: 42,
};
RegExp literalsA regex literal (which is defined in detail later) is a pattern enclosed between slashes. The following is an example of a regex literal.
jsconst re = /ab+c/;
String literalsA string literal is zero or more characters enclosed in double (") or single (') quotation marks. A string must be delimited by quotation marks of the same type (that is, either both single quotation marks, or both double quotation marks).
The following are examples of string literals:
js'foo'
"bar"
'1234'
'one line \n another line'
"Joyo's cat"

You should use string literals unless you specifically need to use a String object. See String for details on String objects.
You can call any of the String object's methods on a string literal value. JavaScript automatically converts the string literal to a temporary String object, calls the method, then discards the temporary String object. You can also use the length property with a string literal:
js// Will print the number of symbols in the string including whitespace.
console.log("Joyo's cat".length); // In this case, 10.

Template literals are also available. Template literals are enclosed by the back-tick (`) (grave accent) character instead of double or single quotes.
Template literals provide syntactic sugar for constructing strings. (This is similar to string interpolation features in Perl, Python, and more.)
js// Basic literal string creation
`In JavaScript '\n' is a line-feed.`

// Multiline strings
`In JavaScript, template strings can run
 over multiple lines, but double and single
 quoted strings cannot.`

// String interpolation
const name = 'Lev', time = 'today';
`Hello ${name}, how are you ${time}?`

Tagged templates are a compact syntax for specifying a template literal along with a call to a "tag" function for parsing it. A tagged template is just a more succinct and semantic way to invoke a function that processes a string and a set of relevant values. The name of the template tag function precedes the template literal — as in the following example, where the template tag function is named print. The print function will interpolate the arguments and serialize any objects or arrays that may come up, avoiding the pesky [object Object].
jsconst formatArg = (arg) => {
  if (Array.isArray(arg)) {
    // Print a bulleted list
    return arg.map((part) => `- ${part}`).join("\n");
  }
  if (arg.toString === Object.prototype.toString) {
    // This object will be serialized to "[object Object]".
    // Let's print something nicer.
    return JSON.stringify(arg);
  }
  return arg;
};

const print = (segments, ...args) => {
  // For any well-formed template literal, there will always be N args and
  // (N+1) string segments.
  let message = segments[0];
  segments.slice(1).forEach((segment, index) => {
    message += formatArg(args[index]) + segment;
  });
  console.log(message);
};

const todos = [
  "Learn JavaScript",
  "Learn Web APIs",
  "Set up my website",
  "Profit!",
];

const progress = { javascript: 20, html: 50, css: 10 };

print`I need to do:
${todos}
My current progress is: ${progress}
`;

// I need to do:
// - Learn JavaScript
// - Learn Web APIs
// - Set up my website
// - Profit!
// My current progress is: {"javascript":20,"html":50,"css":10}

Since tagged template literals are just sugar of function calls, you can re-write the above as an equivalent function call:
jsprint(["I need to do:\n", "\nMy current progress is: ", "\n"], todos, progress);

This may be reminiscent of the console.log-style interpolation:
jsconsole.log("I need to do:\n%o\nMy current progress is: %o\n", todos, progress);

You can see how the tagged template reads more naturally than a traditional "formatter" function, where the variables and the template itself have to be declared separately.
Using special characters in strings
In addition to ordinary characters, you can also include special characters in strings, as shown in the following example.
js"one line \n another line";

The following table lists the special characters that you can use in JavaScript strings.



Character
Meaning




\0
Null Byte


\b
Backspace


\f
Form Feed


\n
New Line


\r
Carriage Return


\t
Tab


\v
Vertical tab


\'
Apostrophe or single quote


\"
Double quote


\\
Backslash character


\XXX
The character with the Latin-1 encoding specified by up to three octal digits XXX between 0 and 377. For example, \251 is the octal sequence for the copyright symbol.


\xXX
The character with the Latin-1 encoding specified by the two hexadecimal digits XX between 00 and FF. For example, \xA9 is the hexadecimal sequence for the copyright symbol.


\uXXXX
The Unicode character specified by the four hexadecimal digits XXXX. For example, \u00A9 is the Unicode sequence for the copyright symbol. See Unicode escape sequences.


\u{XXXXX}
Unicode code point escapes. For example, \u{2F804} is the same as the Unicode escapes \uD87E\uDC04.



Escaping characters
For characters not listed in the table, a preceding backslash is ignored, but this usage is deprecated and should be avoided.
You can insert a quotation mark inside a string by preceding it with a backslash. This is known as escaping the quotation mark. For example:
jsconst quote = "He read \"The Cremation of Sam McGee\" by R.W. Service.";
console.log(quote);

The result of this would be:
He read "The Cremation of Sam McGee" by R.W. Service.

To include a literal backslash inside a string, you must escape the backslash character. For example, to assign the file path c:\temp to a string, use the following:
jsconst home = "c:\\temp";

You can also escape line breaks by preceding them with backslash. The backslash and line break are both removed from the value of the string.
jsconst str =
  "this string \
is broken \
across multiple \
lines.";
console.log(str); // this string is broken across multiple lines.
More informationThis chapter focuses on basic syntax for declarations and types. To learn more about JavaScript's language constructs, see also the following chapters in this guide:

Control flow and error handling guide
Loops and iteration
Functions
Expressions and operators guide

In the next chapter, we will have a look at control flow constructs and error handling.
 Previous  Next\n\nGrammar and types 
 Previous  Next  
This chapter discusses JavaScript's basic grammar, variable declarations, data types and literals.BasicsJavaScript borrows most of its syntax from Java, C, and C++, but it has also been influenced by Awk, Perl, and Python.
JavaScript is case-sensitive and uses the Unicode character set. For example, the word Früh (which means "early" in German) could be used as a variable name.
jsconst Früh = "foobar";

But, the variable früh is not the same as Früh because JavaScript is case sensitive.
In JavaScript, instructions are called statements and are separated by semicolons (;).
A semicolon is not necessary after a statement if it is written on its own line. But if more than one statement on a line is desired, then they must be separated by semicolons.

Note:
ECMAScript also has rules for automatic insertion of semicolons (ASI) to end statements. (For more information, see the detailed reference about JavaScript's lexical grammar.)

It is considered best practice, however, to always write a semicolon after a statement, even when it is not strictly needed. This practice reduces the chances of bugs getting into the code.
The source text of JavaScript script gets scanned from left to right, and is converted into a sequence of input elements which are tokens, control characters, line terminators, comments, or whitespace. (Spaces, tabs, and newline characters are considered whitespace.)CommentsThe syntax of comments is the same as in C++ and in many other languages:
js// a one line comment

/* this is a longer,
 * multi-line comment
 */

You can't nest block comments. This often happens when you accidentally include a */ sequence in your comment, which will terminate the comment.
js/* You can't, however, /* nest comments */ SyntaxError */

In this case, you need to break up the */ pattern. For example, by inserting a backslash:
js/* You can /* nest comments *\/ by escaping slashes */

Comments behave like whitespace, and are discarded during script execution.

Note:
You might also see a third type of comment syntax at the start of some JavaScript files, which looks something like this: #!/usr/bin/env node.
This is called hashbang comment syntax, and is a special comment used to specify the path to a particular JavaScript engine that should execute the script. See Hashbang comments for more details.
DeclarationsJavaScript has three kinds of variable declarations.

var

Declares a variable, optionally initializing it to a value.

let

Declares a block-scoped, local variable, optionally initializing it to a value.

const

Declares a block-scoped, read-only named constant.

VariablesYou use variables as symbolic names for values in your application. The names of variables, called identifiers, conform to certain rules.
A JavaScript identifier usually starts with a letter, underscore (_), or dollar sign ($). Subsequent characters can also be digits (0 – 9). Because JavaScript is case sensitive, letters include the characters A through Z (uppercase) as well as a through z (lowercase).
You can use most Unicode letters such as å and ü in identifiers. (For more details, see the lexical grammar reference.) You can also use Unicode escape sequences to represent characters in identifiers.
Some examples of legal names are Number_hits, temp99, $credit, and _name.Declaring variablesYou can declare a variable in two ways:

With the keyword var. For example, var x = 42. This syntax can be used to declare both local and global variables, depending on the execution context.
With the keyword const or let. For example, let y = 13. This syntax can be used to declare a block-scope local variable. (See Variable scope below.)

You can declare variables to unpack values using the destructuring syntax. For example, const { bar } = foo. This will create a variable named bar and assign to it the value corresponding to the key of the same name from our object foo.
Variables should always be declared before they are used. JavaScript used to allow assigning to undeclared variables, which creates an undeclared global variable. This is an error in strict mode and should be avoided altogether.Declaration and initializationIn a statement like let x = 42, the let x part is called a declaration, and the = 42 part is called an initializer. The declaration allows the variable to be accessed later in code without throwing a ReferenceError, while the initializer assigns a value to the variable. In var and let declarations, the initializer is optional. If a variable is declared without an initializer, it is assigned the value undefined.
jslet x;
console.log(x); // logs "undefined"

In essence, let x = 42 is equivalent to let x; x = 42.
const declarations always need an initializer, because they forbid any kind of assignment after declaration, and implicitly initializing it with undefined is likely a programmer mistake.
jsconst x; // SyntaxError: Missing initializer in const declaration
Variable scopeA variable may belong to one of the following scopes:

Global scope: The default scope for all code running in script mode.
Module scope: The scope for code running in module mode.
Function scope: The scope created with a function.

In addition, variables declared with let or const can belong to an additional scope:

Block scope: The scope created with a pair of curly braces (a block).

When you declare a variable outside of any function, it is called a global variable, because it is available to any other code in the current document. When you declare a variable within a function, it is called a local variable, because it is available only within that function.
let and const declarations can also be scoped to the block statement that they are declared in.
jsif (Math.random() > 0.5) {
  const y = 5;
}
console.log(y); // ReferenceError: y is not defined

However, variables created with var are not block-scoped, but only local to the function (or global scope) that the block resides within.
For example, the following code will log 5, because the scope of x is the global context (or the function context if the code is part of a function). The scope of x is not limited to the immediate if statement block.
jsif (true) {
  var x = 5;
}
console.log(x); // x is 5
Variable hoistingvar-declared variables are hoisted, meaning you can refer to the variable anywhere in its scope, even if its declaration isn't reached yet. You can see var declarations as being "lifted" to the top of its function or global scope. However, if you access a variable before it's declared, the value is always undefined, because only its declaration and default initialization (with undefined) is hoisted, but not its value assignment.
jsconsole.log(x === undefined); // true
var x = 3;

(function () {
  console.log(x); // undefined
  var x = "local value";
})();

The above examples will be interpreted the same as:
jsvar x;
console.log(x === undefined); // true
x = 3;

(function () {
  var x;
  console.log(x); // undefined
  x = "local value";
})();

Because of hoisting, all var statements in a function should be placed as near to the top of the function as possible. This best practice increases the clarity of the code.
Whether let and const are hoisted is a matter of definition debate. Referencing the variable in the block before the variable declaration always results in a ReferenceError, because the variable is in a "temporal dead zone" from the start of the block until the declaration is processed.
jsconsole.log(x); // ReferenceError
const x = 3;

console.log(y); // ReferenceError
let y = 3;

Unlike var declarations, which only hoist the declaration but not its value, function declarations are hoisted entirely — you can safely call the function anywhere in its scope. See the hoisting glossary entry for more discussion.Global variablesGlobal variables are in fact properties of the global object.
In web pages, the global object is window, so you can read and set global variables using the window.variable syntax. In all environments, the globalThis variable (which itself is a global variable) may be used to read and set global variables. This is to provide a consistent interface among various JavaScript runtimes.
Consequently, you can access global variables declared in one window or frame from another window or frame by specifying the window or frame name. For example, if a variable called phoneNumber is declared in a document, you can refer to this variable from an iframe as parent.phoneNumber.ConstantsYou can create a read-only, named constant with the const keyword. The syntax of a constant identifier is the same as any variable identifier: it must start with a letter, underscore, or dollar sign ($), and can contain alphabetic, numeric, or underscore characters.
jsconst PI = 3.14;

A constant cannot change value through assignment or be re-declared while the script is running. It must be initialized to a value. The scope rules for constants are the same as those for let block-scope variables.
You cannot declare a constant with the same name as a function or variable in the same scope. For example:
js// THIS WILL CAUSE AN ERROR
function f() {}
const f = 5;

// THIS WILL CAUSE AN ERROR TOO
function f() {
  const g = 5;
  var g;
}

However, const only prevents re-assignments, but doesn't prevent mutations. The properties of objects assigned to constants are not protected, so the following statement is executed without problems.
jsconst MY_OBJECT = { key: "value" };
MY_OBJECT.key = "otherValue";

Also, the contents of an array are not protected, so the following statement is executed without problems.
jsconst MY_ARRAY = ["HTML", "CSS"];
MY_ARRAY.push("JAVASCRIPT");
console.log(MY_ARRAY); // ['HTML', 'CSS', 'JAVASCRIPT'];
Data structures and typesData typesThe latest ECMAScript standard defines eight data types:


Seven data types that are primitives:

Boolean. true and false.
null. A special keyword denoting a null value. (Because JavaScript is case-sensitive, null is not the same as Null, NULL, or any other variant.)
undefined. A top-level property whose value is not defined.
Number. An integer or floating point number. For example: 42 or 3.14159.
BigInt. An integer with arbitrary precision. For example: 9007199254740992n.
String. A sequence of characters that represent a text value. For example: "Howdy".
Symbol. A data type whose instances are unique and immutable.



and Object


Although these data types are relatively few, they enable you to perform useful operations with your applications. Functions are the other fundamental elements of the language. While functions are technically a kind of object, you can think of objects as named containers for values, and functions as procedures that your script can perform.Data type conversionJavaScript is a dynamically typed language. This means you don't have to specify the data type of a variable when you declare it. It also means that data types are automatically converted as-needed during script execution.
So, for example, you could define a variable as follows:
jslet answer = 42;

And later, you could assign the same variable a string value, for example:
jsanswer = "Thanks for all the fish!";

Because JavaScript is dynamically typed, this assignment does not cause an error message.Numbers and the '+' operatorIn expressions involving numeric and string values with the + operator, JavaScript converts numeric values to strings. For example, consider the following statements:
jsx = "The answer is " + 42; // "The answer is 42"
y = 42 + " is the answer"; // "42 is the answer"
z = "37" + 7; // "377"

With all other operators, JavaScript does not convert numeric values to strings. For example:
js"37" - 7; // 30
"37" * 7; // 259
Converting strings to numbersIn the case that a value representing a number is in memory as a string, there are methods for conversion.

parseInt()
parseFloat()

parseInt only returns whole numbers, so its use is diminished for decimals.

Note:
Additionally, a best practice for parseInt is to always include the radix parameter. The radix parameter is used to specify which numerical system is to be used.

jsparseInt("101", 2); // 5

An alternative method of retrieving a number from a string is with the + (unary plus) operator:
js"1.1" + "1.1"; // '1.11.1'
(+"1.1") + (+"1.1"); // 2.2
// Note: the parentheses are added for clarity, not required.
LiteralsLiterals represent values in JavaScript. These are fixed values—not variables—that you literally provide in your script. This section describes the following types of literals:

Array literals
Boolean literals
Numeric literals
Object literals
RegExp literals
String literals
Array literalsAn array literal is a list of zero or more expressions, each of which represents an array element, enclosed in square brackets ([]). When you create an array using an array literal, it is initialized with the specified values as its elements, and its length is set to the number of arguments specified.
The following example creates the coffees array with three elements and a length of three:
jsconst coffees = ["French Roast", "Colombian", "Kona"];

An array literal creates a new array object every time the literal is evaluated. For example, an array defined with a literal in the global scope is created once when the script loads. However, if the array literal is inside a function, a new array is instantiated every time that function is called.

Note:
Array literals create Array objects. See Array and Indexed collections for details on Array objects.

Extra commas in array literals
If you put two commas in a row in an array literal, the array leaves an empty slot for the unspecified element. The following example creates the fish array:
jsconst fish = ["Lion", , "Angel"];

When you log this array, you will see:
jsconsole.log(fish);
// [ 'Lion', <1 empty item>, 'Angel' ]

Note that the second item is "empty", which is not exactly the same as the actual undefined value. When using array-traversing methods like Array.prototype.map, empty slots are skipped. However, index-accessing fish[1] still returns undefined.
If you include a trailing comma at the end of the list of elements, the comma is ignored.
In the following example, the length of the array is three. There is no myList[3] and myList[1] is empty. All other commas in the list indicate a new element.
jsconst myList = ["home", , "school"];

In the following example, the length of the array is four, and myList[0] and myList[2] are missing.
jsconst myList = [, "home", , "school"];

In the following example, the length of the array is four, and myList[1] and myList[3] are missing. Only the last comma is ignored.
jsconst myList = ["home", , "school", ,];


Note: Trailing commas help keep git diffs clean when you have a multi-line array, because appending an item to the end only adds one line, but does not modify the previous line.
diffconst myList = [
  "home",
  "school",
+ "hospital",
];


Understanding the behavior of extra commas is important to understanding JavaScript as a language.
However, when writing your own code, you should explicitly declare the missing elements as undefined, or at least insert a comment to highlight its absence. Doing this increases your code's clarity and maintainability.
jsconst myList = ["home", /* empty */, "school", /* empty */, ];
Boolean literalsThe Boolean type has two literal values: true and false.

Note:
Do not confuse the primitive Boolean values true and false with the true and false values of the Boolean object.
The Boolean object is a wrapper around the primitive Boolean data type. See Boolean for more information.
Numeric literalsJavaScript numeric literals include integer literals in different bases as well as floating-point literals in base-10.
Note that the language specification requires numeric literals to be unsigned. Nevertheless, code fragments like -123.4 are fine, being interpreted as a unary - operator applied to the numeric literal 123.4.
Integer literals
Integer and BigInt literals can be written in decimal (base 10), hexadecimal (base 16), octal (base 8) and binary (base 2).

A decimal integer literal is a sequence of digits without a leading 0 (zero).
A leading 0 (zero) on an integer literal, or a leading 0o (or 0O) indicates it is in octal. Octal integer literals can include only the digits 0 – 7.
A leading 0x (or 0X) indicates a hexadecimal integer literal. Hexadecimal integers can include digits (0 – 9) and the letters a – f and A – F. (The case of a character does not change its value. Therefore: 0xa = 0xA = 10 and 0xf = 0xF = 15.)
A leading 0b (or 0B) indicates a binary integer literal. Binary integer literals can only include the digits 0 and 1.
A trailing n suffix on an integer literal indicates a BigInt literal. The BigInt literal can use any of the above bases. Note that leading-zero octal syntax like 0123n is not allowed, but 0o123n is fine.

Some examples of integer literals are:
0, 117, 123456789123456789n             (decimal, base 10)
015, 0001, 0o777777777777n              (octal, base 8)
0x1123, 0x00111, 0x123456789ABCDEFn     (hexadecimal, "hex" or base 16)
0b11, 0b0011, 0b11101001010101010101n   (binary, base 2)

For more information, see Numeric literals in the Lexical grammar reference.
Floating-point literals
A floating-point literal can have the following parts:

An unsigned decimal integer,
A decimal point (.),
A fraction (another decimal number),
An exponent.

The exponent part is an e or E followed by an integer, which can be signed (preceded by + or -). A floating-point literal must have at least one digit, and either a decimal point or e (or E).
More succinctly, the syntax is:
[digits].[digits][(E|e)[(+|-)]digits]

For example:
js3.1415926
.123456789
3.1E+12
.1e-23
Object literalsAn object literal is a list of zero or more pairs of property names and associated values of an object, enclosed in curly braces ({}).

Warning:
Do not use an object literal at the beginning of a statement! This will lead to an error (or not behave as you expect), because the { will be interpreted as the beginning of a block.

The following is an example of an object literal. The first element of the car object defines a property, myCar, and assigns to it a new string, "Saturn"; the second element, the getCar property, is immediately assigned the result of invoking the function (carTypes("Honda")); the third element, the special property, uses an existing variable (sales).
jsconst sales = "Toyota";

function carTypes(name) {
  return name === "Honda" ? name : `Sorry, we don't sell ${name}.`;
}

const car = { myCar: "Saturn", getCar: carTypes("Honda"), special: sales };

console.log(car.myCar); // Saturn
console.log(car.getCar); // Honda
console.log(car.special); // Toyota

Additionally, you can use a numeric or string literal for the name of a property or nest an object inside another. The following example uses these options.
jsconst car = { manyCars: { a: "Saab", b: "Jeep" }, 7: "Mazda" };

console.log(car.manyCars.b); // Jeep
console.log(car[7]); // Mazda

Object property names can be any string, including the empty string. If the property name would not be a valid JavaScript identifier or number, it must be enclosed in quotes.
Property names that are not valid identifiers cannot be accessed as a dot (.) property.
jsconst unusualPropertyNames = {
  "": "An empty string",
  "!": "Bang!",
};
console.log(unusualPropertyNames.""); // SyntaxError: Unexpected string
console.log(unusualPropertyNames.!); // SyntaxError: Unexpected token !

Instead, they must be accessed with the bracket notation ([]).
jsconsole.log(unusualPropertyNames[""]); // An empty string
console.log(unusualPropertyNames["!"]); // Bang!

Enhanced Object literals
Object literals support a range of shorthand syntaxes that include setting the prototype at construction, shorthand for foo: foo assignments, defining methods, making super calls, and computing property names with expressions.
Together, these also bring object literals and class declarations closer together, and allow object-based design to benefit from some of the same conveniences.
jsconst obj = {
  // __proto__
  __proto__: theProtoObj,
  // Shorthand for 'handler: handler'
  handler,
  // Methods
  toString() {
    // Super calls
    return "d " + super.toString();
  },
  // Computed (dynamic) property names
  ["prop_" + (() => 42)()]: 42,
};
RegExp literalsA regex literal (which is defined in detail later) is a pattern enclosed between slashes. The following is an example of a regex literal.
jsconst re = /ab+c/;
String literalsA string literal is zero or more characters enclosed in double (") or single (') quotation marks. A string must be delimited by quotation marks of the same type (that is, either both single quotation marks, or both double quotation marks).
The following are examples of string literals:
js'foo'
"bar"
'1234'
'one line \n another line'
"Joyo's cat"

You should use string literals unless you specifically need to use a String object. See String for details on String objects.
You can call any of the String object's methods on a string literal value. JavaScript automatically converts the string literal to a temporary String object, calls the method, then discards the temporary String object. You can also use the length property with a string literal:
js// Will print the number of symbols in the string including whitespace.
console.log("Joyo's cat".length); // In this case, 10.

Template literals are also available. Template literals are enclosed by the back-tick (`) (grave accent) character instead of double or single quotes.
Template literals provide syntactic sugar for constructing strings. (This is similar to string interpolation features in Perl, Python, and more.)
js// Basic literal string creation
`In JavaScript '\n' is a line-feed.`

// Multiline strings
`In JavaScript, template strings can run
 over multiple lines, but double and single
 quoted strings cannot.`

// String interpolation
const name = 'Lev', time = 'today';
`Hello ${name}, how are you ${time}?`

Tagged templates are a compact syntax for specifying a template literal along with a call to a "tag" function for parsing it. A tagged template is just a more succinct and semantic way to invoke a function that processes a string and a set of relevant values. The name of the template tag function precedes the template literal — as in the following example, where the template tag function is named print. The print function will interpolate the arguments and serialize any objects or arrays that may come up, avoiding the pesky [object Object].
jsconst formatArg = (arg) => {
  if (Array.isArray(arg)) {
    // Print a bulleted list
    return arg.map((part) => `- ${part}`).join("\n");
  }
  if (arg.toString === Object.prototype.toString) {
    // This object will be serialized to "[object Object]".
    // Let's print something nicer.
    return JSON.stringify(arg);
  }
  return arg;
};

const print = (segments, ...args) => {
  // For any well-formed template literal, there will always be N args and
  // (N+1) string segments.
  let message = segments[0];
  segments.slice(1).forEach((segment, index) => {
    message += formatArg(args[index]) + segment;
  });
  console.log(message);
};

const todos = [
  "Learn JavaScript",
  "Learn Web APIs",
  "Set up my website",
  "Profit!",
];

const progress = { javascript: 20, html: 50, css: 10 };

print`I need to do:
${todos}
My current progress is: ${progress}
`;

// I need to do:
// - Learn JavaScript
// - Learn Web APIs
// - Set up my website
// - Profit!
// My current progress is: {"javascript":20,"html":50,"css":10}

Since tagged template literals are just sugar of function calls, you can re-write the above as an equivalent function call:
jsprint(["I need to do:\n", "\nMy current progress is: ", "\n"], todos, progress);

This may be reminiscent of the console.log-style interpolation:
jsconsole.log("I need to do:\n%o\nMy current progress is: %o\n", todos, progress);

You can see how the tagged template reads more naturally than a traditional "formatter" function, where the variables and the template itself have to be declared separately.
Using special characters in strings
In addition to ordinary characters, you can also include special characters in strings, as shown in the following example.
js"one line \n another line";

The following table lists the special characters that you can use in JavaScript strings.



Character
Meaning




\0
Null Byte


\b
Backspace


\f
Form Feed


\n
New Line


\r
Carriage Return


\t
Tab


\v
Vertical tab


\'
Apostrophe or single quote


\"
Double quote


\\
Backslash character


\XXX
The character with the Latin-1 encoding specified by up to three octal digits XXX between 0 and 377. For example, \251 is the octal sequence for the copyright symbol.


\xXX
The character with the Latin-1 encoding specified by the two hexadecimal digits XX between 00 and FF. For example, \xA9 is the hexadecimal sequence for the copyright symbol.


\uXXXX
The Unicode character specified by the four hexadecimal digits XXXX. For example, \u00A9 is the Unicode sequence for the copyright symbol. See Unicode escape sequences.


\u{XXXXX}
Unicode code point escapes. For example, \u{2F804} is the same as the Unicode escapes \uD87E\uDC04.



Escaping characters
For characters not listed in the table, a preceding backslash is ignored, but this usage is deprecated and should be avoided.
You can insert a quotation mark inside a string by preceding it with a backslash. This is known as escaping the quotation mark. For example:
jsconst quote = "He read \"The Cremation of Sam McGee\" by R.W. Service.";
console.log(quote);

The result of this would be:
He read "The Cremation of Sam McGee" by R.W. Service.

To include a literal backslash inside a string, you must escape the backslash character. For example, to assign the file path c:\temp to a string, use the following:
jsconst home = "c:\\temp";

You can also escape line breaks by preceding them with backslash. The backslash and line break are both removed from the value of the string.
jsconst str =
  "this string \
is broken \
across multiple \
lines.";
console.log(str); // this string is broken across multiple lines.
More informationThis chapter focuses on basic syntax for declarations and types. To learn more about JavaScript's language constructs, see also the following chapters in this guide:

Control flow and error handling guide
Loops and iteration
Functions
Expressions and operators guide

In the next chapter, we will have a look at control flow constructs and error handling.
 Previous  Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 7, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nGrammar and types 
 Previous  Next  
This chapter discusses JavaScript's basic grammar, variable declarations, data types and literals.BasicsJavaScript borrows most of its syntax from Java, C, and C++, but it has also been influenced by Awk, Perl, and Python.
JavaScript is case-sensitive and uses the Unicode character set. For example, the word Früh (which means "early" in German) could be used as a variable name.
jsconst Früh = "foobar";

But, the variable früh is not the same as Früh because JavaScript is case sensitive.
In JavaScript, instructions are called statements and are separated by semicolons (;).
A semicolon is not necessary after a statement if it is written on its own line. But if more than one statement on a line is desired, then they must be separated by semicolons.

Note:
ECMAScript also has rules for automatic insertion of semicolons (ASI) to end statements. (For more information, see the detailed reference about JavaScript's lexical grammar.)

It is considered best practice, however, to always write a semicolon after a statement, even when it is not strictly needed. This practice reduces the chances of bugs getting into the code.
The source text of JavaScript script gets scanned from left to right, and is converted into a sequence of input elements which are tokens, control characters, line terminators, comments, or whitespace. (Spaces, tabs, and newline characters are considered whitespace.)CommentsThe syntax of comments is the same as in C++ and in many other languages:
js// a one line comment

/* this is a longer,
 * multi-line comment
 */

You can't nest block comments. This often happens when you accidentally include a */ sequence in your comment, which will terminate the comment.
js/* You can't, however, /* nest comments */ SyntaxError */

In this case, you need to break up the */ pattern. For example, by inserting a backslash:
js/* You can /* nest comments *\/ by escaping slashes */

Comments behave like whitespace, and are discarded during script execution.

Note:
You might also see a third type of comment syntax at the start of some JavaScript files, which looks something like this: #!/usr/bin/env node.
This is called hashbang comment syntax, and is a special comment used to specify the path to a particular JavaScript engine that should execute the script. See Hashbang comments for more details.
DeclarationsJavaScript has three kinds of variable declarations.

var

Declares a variable, optionally initializing it to a value.

let

Declares a block-scoped, local variable, optionally initializing it to a value.

const

Declares a block-scoped, read-only named constant.

VariablesYou use variables as symbolic names for values in your application. The names of variables, called identifiers, conform to certain rules.
A JavaScript identifier usually starts with a letter, underscore (_), or dollar sign ($). Subsequent characters can also be digits (0 – 9). Because JavaScript is case sensitive, letters include the characters A through Z (uppercase) as well as a through z (lowercase).
You can use most Unicode letters such as å and ü in identifiers. (For more details, see the lexical grammar reference.) You can also use Unicode escape sequences to represent characters in identifiers.
Some examples of legal names are Number_hits, temp99, $credit, and _name.Declaring variablesYou can declare a variable in two ways:

With the keyword var. For example, var x = 42. This syntax can be used to declare both local and global variables, depending on the execution context.
With the keyword const or let. For example, let y = 13. This syntax can be used to declare a block-scope local variable. (See Variable scope below.)

You can declare variables to unpack values using the destructuring syntax. For example, const { bar } = foo. This will create a variable named bar and assign to it the value corresponding to the key of the same name from our object foo.
Variables should always be declared before they are used. JavaScript used to allow assigning to undeclared variables, which creates an undeclared global variable. This is an error in strict mode and should be avoided altogether.Declaration and initializationIn a statement like let x = 42, the let x part is called a declaration, and the = 42 part is called an initializer. The declaration allows the variable to be accessed later in code without throwing a ReferenceError, while the initializer assigns a value to the variable. In var and let declarations, the initializer is optional. If a variable is declared without an initializer, it is assigned the value undefined.
jslet x;
console.log(x); // logs "undefined"

In essence, let x = 42 is equivalent to let x; x = 42.
const declarations always need an initializer, because they forbid any kind of assignment after declaration, and implicitly initializing it with undefined is likely a programmer mistake.
jsconst x; // SyntaxError: Missing initializer in const declaration
Variable scopeA variable may belong to one of the following scopes:

Global scope: The default scope for all code running in script mode.
Module scope: The scope for code running in module mode.
Function scope: The scope created with a function.

In addition, variables declared with let or const can belong to an additional scope:

Block scope: The scope created with a pair of curly braces (a block).

When you declare a variable outside of any function, it is called a global variable, because it is available to any other code in the current document. When you declare a variable within a function, it is called a local variable, because it is available only within that function.
let and const declarations can also be scoped to the block statement that they are declared in.
jsif (Math.random() > 0.5) {
  const y = 5;
}
console.log(y); // ReferenceError: y is not defined

However, variables created with var are not block-scoped, but only local to the function (or global scope) that the block resides within.
For example, the following code will log 5, because the scope of x is the global context (or the function context if the code is part of a function). The scope of x is not limited to the immediate if statement block.
jsif (true) {
  var x = 5;
}
console.log(x); // x is 5
Variable hoistingvar-declared variables are hoisted, meaning you can refer to the variable anywhere in its scope, even if its declaration isn't reached yet. You can see var declarations as being "lifted" to the top of its function or global scope. However, if you access a variable before it's declared, the value is always undefined, because only its declaration and default initialization (with undefined) is hoisted, but not its value assignment.
jsconsole.log(x === undefined); // true
var x = 3;

(function () {
  console.log(x); // undefined
  var x = "local value";
})();

The above examples will be interpreted the same as:
jsvar x;
console.log(x === undefined); // true
x = 3;

(function () {
  var x;
  console.log(x); // undefined
  x = "local value";
})();

Because of hoisting, all var statements in a function should be placed as near to the top of the function as possible. This best practice increases the clarity of the code.
Whether let and const are hoisted is a matter of definition debate. Referencing the variable in the block before the variable declaration always results in a ReferenceError, because the variable is in a "temporal dead zone" from the start of the block until the declaration is processed.
jsconsole.log(x); // ReferenceError
const x = 3;

console.log(y); // ReferenceError
let y = 3;

Unlike var declarations, which only hoist the declaration but not its value, function declarations are hoisted entirely — you can safely call the function anywhere in its scope. See the hoisting glossary entry for more discussion.Global variablesGlobal variables are in fact properties of the global object.
In web pages, the global object is window, so you can read and set global variables using the window.variable syntax. In all environments, the globalThis variable (which itself is a global variable) may be used to read and set global variables. This is to provide a consistent interface among various JavaScript runtimes.
Consequently, you can access global variables declared in one window or frame from another window or frame by specifying the window or frame name. For example, if a variable called phoneNumber is declared in a document, you can refer to this variable from an iframe as parent.phoneNumber.ConstantsYou can create a read-only, named constant with the const keyword. The syntax of a constant identifier is the same as any variable identifier: it must start with a letter, underscore, or dollar sign ($), and can contain alphabetic, numeric, or underscore characters.
jsconst PI = 3.14;

A constant cannot change value through assignment or be re-declared while the script is running. It must be initialized to a value. The scope rules for constants are the same as those for let block-scope variables.
You cannot declare a constant with the same name as a function or variable in the same scope. For example:
js// THIS WILL CAUSE AN ERROR
function f() {}
const f = 5;

// THIS WILL CAUSE AN ERROR TOO
function f() {
  const g = 5;
  var g;
}

However, const only prevents re-assignments, but doesn't prevent mutations. The properties of objects assigned to constants are not protected, so the following statement is executed without problems.
jsconst MY_OBJECT = { key: "value" };
MY_OBJECT.key = "otherValue";

Also, the contents of an array are not protected, so the following statement is executed without problems.
jsconst MY_ARRAY = ["HTML", "CSS"];
MY_ARRAY.push("JAVASCRIPT");
console.log(MY_ARRAY); // ['HTML', 'CSS', 'JAVASCRIPT'];
Data structures and typesData typesThe latest ECMAScript standard defines eight data types:


Seven data types that are primitives:

Boolean. true and false.
null. A special keyword denoting a null value. (Because JavaScript is case-sensitive, null is not the same as Null, NULL, or any other variant.)
undefined. A top-level property whose value is not defined.
Number. An integer or floating point number. For example: 42 or 3.14159.
BigInt. An integer with arbitrary precision. For example: 9007199254740992n.
String. A sequence of characters that represent a text value. For example: "Howdy".
Symbol. A data type whose instances are unique and immutable.



and Object


Although these data types are relatively few, they enable you to perform useful operations with your applications. Functions are the other fundamental elements of the language. While functions are technically a kind of object, you can think of objects as named containers for values, and functions as procedures that your script can perform.Data type conversionJavaScript is a dynamically typed language. This means you don't have to specify the data type of a variable when you declare it. It also means that data types are automatically converted as-needed during script execution.
So, for example, you could define a variable as follows:
jslet answer = 42;

And later, you could assign the same variable a string value, for example:
jsanswer = "Thanks for all the fish!";

Because JavaScript is dynamically typed, this assignment does not cause an error message.Numbers and the '+' operatorIn expressions involving numeric and string values with the + operator, JavaScript converts numeric values to strings. For example, consider the following statements:
jsx = "The answer is " + 42; // "The answer is 42"
y = 42 + " is the answer"; // "42 is the answer"
z = "37" + 7; // "377"

With all other operators, JavaScript does not convert numeric values to strings. For example:
js"37" - 7; // 30
"37" * 7; // 259
Converting strings to numbersIn the case that a value representing a number is in memory as a string, there are methods for conversion.

parseInt()
parseFloat()

parseInt only returns whole numbers, so its use is diminished for decimals.

Note:
Additionally, a best practice for parseInt is to always include the radix parameter. The radix parameter is used to specify which numerical system is to be used.

jsparseInt("101", 2); // 5

An alternative method of retrieving a number from a string is with the + (unary plus) operator:
js"1.1" + "1.1"; // '1.11.1'
(+"1.1") + (+"1.1"); // 2.2
// Note: the parentheses are added for clarity, not required.
LiteralsLiterals represent values in JavaScript. These are fixed values—not variables—that you literally provide in your script. This section describes the following types of literals:

Array literals
Boolean literals
Numeric literals
Object literals
RegExp literals
String literals
Array literalsAn array literal is a list of zero or more expressions, each of which represents an array element, enclosed in square brackets ([]). When you create an array using an array literal, it is initialized with the specified values as its elements, and its length is set to the number of arguments specified.
The following example creates the coffees array with three elements and a length of three:
jsconst coffees = ["French Roast", "Colombian", "Kona"];

An array literal creates a new array object every time the literal is evaluated. For example, an array defined with a literal in the global scope is created once when the script loads. However, if the array literal is inside a function, a new array is instantiated every time that function is called.

Note:
Array literals create Array objects. See Array and Indexed collections for details on Array objects.

Extra commas in array literals
If you put two commas in a row in an array literal, the array leaves an empty slot for the unspecified element. The following example creates the fish array:
jsconst fish = ["Lion", , "Angel"];

When you log this array, you will see:
jsconsole.log(fish);
// [ 'Lion', <1 empty item>, 'Angel' ]

Note that the second item is "empty", which is not exactly the same as the actual undefined value. When using array-traversing methods like Array.prototype.map, empty slots are skipped. However, index-accessing fish[1] still returns undefined.
If you include a trailing comma at the end of the list of elements, the comma is ignored.
In the following example, the length of the array is three. There is no myList[3] and myList[1] is empty. All other commas in the list indicate a new element.
jsconst myList = ["home", , "school"];

In the following example, the length of the array is four, and myList[0] and myList[2] are missing.
jsconst myList = [, "home", , "school"];

In the following example, the length of the array is four, and myList[1] and myList[3] are missing. Only the last comma is ignored.
jsconst myList = ["home", , "school", ,];


Note: Trailing commas help keep git diffs clean when you have a multi-line array, because appending an item to the end only adds one line, but does not modify the previous line.
diffconst myList = [
  "home",
  "school",
+ "hospital",
];


Understanding the behavior of extra commas is important to understanding JavaScript as a language.
However, when writing your own code, you should explicitly declare the missing elements as undefined, or at least insert a comment to highlight its absence. Doing this increases your code's clarity and maintainability.
jsconst myList = ["home", /* empty */, "school", /* empty */, ];
Boolean literalsThe Boolean type has two literal values: true and false.

Note:
Do not confuse the primitive Boolean values true and false with the true and false values of the Boolean object.
The Boolean object is a wrapper around the primitive Boolean data type. See Boolean for more information.
Numeric literalsJavaScript numeric literals include integer literals in different bases as well as floating-point literals in base-10.
Note that the language specification requires numeric literals to be unsigned. Nevertheless, code fragments like -123.4 are fine, being interpreted as a unary - operator applied to the numeric literal 123.4.
Integer literals
Integer and BigInt literals can be written in decimal (base 10), hexadecimal (base 16), octal (base 8) and binary (base 2).

A decimal integer literal is a sequence of digits without a leading 0 (zero).
A leading 0 (zero) on an integer literal, or a leading 0o (or 0O) indicates it is in octal. Octal integer literals can include only the digits 0 – 7.
A leading 0x (or 0X) indicates a hexadecimal integer literal. Hexadecimal integers can include digits (0 – 9) and the letters a – f and A – F. (The case of a character does not change its value. Therefore: 0xa = 0xA = 10 and 0xf = 0xF = 15.)
A leading 0b (or 0B) indicates a binary integer literal. Binary integer literals can only include the digits 0 and 1.
A trailing n suffix on an integer literal indicates a BigInt literal. The BigInt literal can use any of the above bases. Note that leading-zero octal syntax like 0123n is not allowed, but 0o123n is fine.

Some examples of integer literals are:
0, 117, 123456789123456789n             (decimal, base 10)
015, 0001, 0o777777777777n              (octal, base 8)
0x1123, 0x00111, 0x123456789ABCDEFn     (hexadecimal, "hex" or base 16)
0b11, 0b0011, 0b11101001010101010101n   (binary, base 2)

For more information, see Numeric literals in the Lexical grammar reference.
Floating-point literals
A floating-point literal can have the following parts:

An unsigned decimal integer,
A decimal point (.),
A fraction (another decimal number),
An exponent.

The exponent part is an e or E followed by an integer, which can be signed (preceded by + or -). A floating-point literal must have at least one digit, and either a decimal point or e (or E).
More succinctly, the syntax is:
[digits].[digits][(E|e)[(+|-)]digits]

For example:
js3.1415926
.123456789
3.1E+12
.1e-23
Object literalsAn object literal is a list of zero or more pairs of property names and associated values of an object, enclosed in curly braces ({}).

Warning:
Do not use an object literal at the beginning of a statement! This will lead to an error (or not behave as you expect), because the { will be interpreted as the beginning of a block.

The following is an example of an object literal. The first element of the car object defines a property, myCar, and assigns to it a new string, "Saturn"; the second element, the getCar property, is immediately assigned the result of invoking the function (carTypes("Honda")); the third element, the special property, uses an existing variable (sales).
jsconst sales = "Toyota";

function carTypes(name) {
  return name === "Honda" ? name : `Sorry, we don't sell ${name}.`;
}

const car = { myCar: "Saturn", getCar: carTypes("Honda"), special: sales };

console.log(car.myCar); // Saturn
console.log(car.getCar); // Honda
console.log(car.special); // Toyota

Additionally, you can use a numeric or string literal for the name of a property or nest an object inside another. The following example uses these options.
jsconst car = { manyCars: { a: "Saab", b: "Jeep" }, 7: "Mazda" };

console.log(car.manyCars.b); // Jeep
console.log(car[7]); // Mazda

Object property names can be any string, including the empty string. If the property name would not be a valid JavaScript identifier or number, it must be enclosed in quotes.
Property names that are not valid identifiers cannot be accessed as a dot (.) property.
jsconst unusualPropertyNames = {
  "": "An empty string",
  "!": "Bang!",
};
console.log(unusualPropertyNames.""); // SyntaxError: Unexpected string
console.log(unusualPropertyNames.!); // SyntaxError: Unexpected token !

Instead, they must be accessed with the bracket notation ([]).
jsconsole.log(unusualPropertyNames[""]); // An empty string
console.log(unusualPropertyNames["!"]); // Bang!

Enhanced Object literals
Object literals support a range of shorthand syntaxes that include setting the prototype at construction, shorthand for foo: foo assignments, defining methods, making super calls, and computing property names with expressions.
Together, these also bring object literals and class declarations closer together, and allow object-based design to benefit from some of the same conveniences.
jsconst obj = {
  // __proto__
  __proto__: theProtoObj,
  // Shorthand for 'handler: handler'
  handler,
  // Methods
  toString() {
    // Super calls
    return "d " + super.toString();
  },
  // Computed (dynamic) property names
  ["prop_" + (() => 42)()]: 42,
};
RegExp literalsA regex literal (which is defined in detail later) is a pattern enclosed between slashes. The following is an example of a regex literal.
jsconst re = /ab+c/;
String literalsA string literal is zero or more characters enclosed in double (") or single (') quotation marks. A string must be delimited by quotation marks of the same type (that is, either both single quotation marks, or both double quotation marks).
The following are examples of string literals:
js'foo'
"bar"
'1234'
'one line \n another line'
"Joyo's cat"

You should use string literals unless you specifically need to use a String object. See String for details on String objects.
You can call any of the String object's methods on a string literal value. JavaScript automatically converts the string literal to a temporary String object, calls the method, then discards the temporary String object. You can also use the length property with a string literal:
js// Will print the number of symbols in the string including whitespace.
console.log("Joyo's cat".length); // In this case, 10.

Template literals are also available. Template literals are enclosed by the back-tick (`) (grave accent) character instead of double or single quotes.
Template literals provide syntactic sugar for constructing strings. (This is similar to string interpolation features in Perl, Python, and more.)
js// Basic literal string creation
`In JavaScript '\n' is a line-feed.`

// Multiline strings
`In JavaScript, template strings can run
 over multiple lines, but double and single
 quoted strings cannot.`

// String interpolation
const name = 'Lev', time = 'today';
`Hello ${name}, how are you ${time}?`

Tagged templates are a compact syntax for specifying a template literal along with a call to a "tag" function for parsing it. A tagged template is just a more succinct and semantic way to invoke a function that processes a string and a set of relevant values. The name of the template tag function precedes the template literal — as in the following example, where the template tag function is named print. The print function will interpolate the arguments and serialize any objects or arrays that may come up, avoiding the pesky [object Object].
jsconst formatArg = (arg) => {
  if (Array.isArray(arg)) {
    // Print a bulleted list
    return arg.map((part) => `- ${part}`).join("\n");
  }
  if (arg.toString === Object.prototype.toString) {
    // This object will be serialized to "[object Object]".
    // Let's print something nicer.
    return JSON.stringify(arg);
  }
  return arg;
};

const print = (segments, ...args) => {
  // For any well-formed template literal, there will always be N args and
  // (N+1) string segments.
  let message = segments[0];
  segments.slice(1).forEach((segment, index) => {
    message += formatArg(args[index]) + segment;
  });
  console.log(message);
};

const todos = [
  "Learn JavaScript",
  "Learn Web APIs",
  "Set up my website",
  "Profit!",
];

const progress = { javascript: 20, html: 50, css: 10 };

print`I need to do:
${todos}
My current progress is: ${progress}
`;

// I need to do:
// - Learn JavaScript
// - Learn Web APIs
// - Set up my website
// - Profit!
// My current progress is: {"javascript":20,"html":50,"css":10}

Since tagged template literals are just sugar of function calls, you can re-write the above as an equivalent function call:
jsprint(["I need to do:\n", "\nMy current progress is: ", "\n"], todos, progress);

This may be reminiscent of the console.log-style interpolation:
jsconsole.log("I need to do:\n%o\nMy current progress is: %o\n", todos, progress);

You can see how the tagged template reads more naturally than a traditional "formatter" function, where the variables and the template itself have to be declared separately.
Using special characters in strings
In addition to ordinary characters, you can also include special characters in strings, as shown in the following example.
js"one line \n another line";

The following table lists the special characters that you can use in JavaScript strings.



Character
Meaning




\0
Null Byte


\b
Backspace


\f
Form Feed


\n
New Line


\r
Carriage Return


\t
Tab


\v
Vertical tab


\'
Apostrophe or single quote


\"
Double quote


\\
Backslash character


\XXX
The character with the Latin-1 encoding specified by up to three octal digits XXX between 0 and 377. For example, \251 is the octal sequence for the copyright symbol.


\xXX
The character with the Latin-1 encoding specified by the two hexadecimal digits XX between 00 and FF. For example, \xA9 is the hexadecimal sequence for the copyright symbol.


\uXXXX
The Unicode character specified by the four hexadecimal digits XXXX. For example, \u00A9 is the Unicode sequence for the copyright symbol. See Unicode escape sequences.


\u{XXXXX}
Unicode code point escapes. For example, \u{2F804} is the same as the Unicode escapes \uD87E\uDC04.



Escaping characters
For characters not listed in the table, a preceding backslash is ignored, but this usage is deprecated and should be avoided.
You can insert a quotation mark inside a string by preceding it with a backslash. This is known as escaping the quotation mark. For example:
jsconst quote = "He read \"The Cremation of Sam McGee\" by R.W. Service.";
console.log(quote);

The result of this would be:
He read "The Cremation of Sam McGee" by R.W. Service.

To include a literal backslash inside a string, you must escape the backslash character. For example, to assign the file path c:\temp to a string, use the following:
jsconst home = "c:\\temp";

You can also escape line breaks by preceding them with backslash. The backslash and line break are both removed from the value of the string.
jsconst str =
  "this string \
is broken \
across multiple \
lines.";
console.log(str); // this string is broken across multiple lines.
More informationThis chapter focuses on basic syntax for declarations and types. To learn more about JavaScript's language constructs, see also the following chapters in this guide:

Control flow and error handling guide
Loops and iteration
Functions
Expressions and operators guide

In the next chapter, we will have a look at control flow constructs and error handling.
 Previous  Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 7, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nControl flow and error handling Previous  Next  
JavaScript supports a compact set of statements, specifically
control flow statements, that you can use to incorporate a great deal of interactivity
in your application. This chapter provides an overview of these statements.
The JavaScript reference
contains exhaustive details about the statements in this chapter. The semicolon
(;) character is used to separate statements in JavaScript code.
Any JavaScript expression is also a statement.
See Expressions and operators
for complete information about expressions.Block statementThe most basic statement is a block statement, which is used to group
statements. The block is delimited by a pair of curly braces:
js{
  statement1;
  statement2;
  // …
  statementN;
}
ExampleBlock statements are commonly used with control flow statements (if,
for, while).
jswhile (x < 10) {
  x++;
}

Here, { x++; } is the block statement.

Note: var-declared variables are not block-scoped, but are scoped to the containing function or script, and the effects of setting them persist beyond the block itself. For example:
jsvar x = 1;
{
  var x = 2;
}
console.log(x); // 2

This outputs 2 because the var x statement within the block is in the same scope as the var x statement before the block. (In C or Java, the equivalent code would have output 1.)
This scoping effect can be mitigated by using let or const.
Conditional statementsA conditional statement is a set of commands that executes if a specified condition is
true. JavaScript supports two conditional statements: if...else and
switch.if...else statementUse the if statement to execute a statement if a logical condition is
true. Use the optional else clause to execute a statement if
the condition is false.
An if statement looks like this:
jsif (condition) {
  statement1;
} else {
  statement2;
}

Here, the condition can be any expression that evaluates to
true or false. (See Boolean
for an explanation of what evaluates to true and false.)
If condition evaluates to true,
statement1 is executed. Otherwise,
statement2 is executed. statement1 and
statement2 can be any statement, including further nested
if statements.
You can also compound the statements using else if to have multiple
conditions tested in sequence, as follows:
jsif (condition1) {
  statement1;
} else if (condition2) {
  statement2;
} else if (conditionN) {
  statementN;
} else {
  statementLast;
}

In the case of multiple conditions, only the first logical condition which evaluates to
true will be executed. To execute multiple statements, group them within a
block statement ({ /* … */ }).
Best practice
In general, it's good practice to always use block statements—especially when
nesting if statements:
jsif (condition) {
  // Statements for when condition is true
  // …
} else {
  // Statements for when condition is false
  // …
}

In general it's good practice to not have an if...else with an assignment like x = y as a condition:
jsif (x = y) {
  // statements here
}

However, in the rare case you find yourself wanting to do something like that, the while documentation has a Using an assignment as a condition section with guidance on a general best-practice syntax you should know about and follow.
Falsy values
The following values evaluate to false (also known as Falsy values):

false
undefined
null
0
NaN
the empty string ("")

All other values—including all objects—evaluate to true when passed to a
conditional statement.

Note:
Do not confuse the primitive boolean values
true and false with the true and false values of the
Boolean object!
For example:
jsconst b = new Boolean(false);
if (b) {
  // this condition evaluates to true
}
if (b == true) {
  // this condition evaluates to false
}


Example
In the following example, the function checkData returns true
if the number of characters in a Text object is three. Otherwise, it
displays an alert and returns false.
jsfunction checkData() {
  if (document.form1.threeChar.value.length === 3) {
    return true;
  } else {
    alert(
      `Enter exactly three characters. ${document.form1.threeChar.value} is not valid.`,
    );
    return false;
  }
}
switch statementA switch statement allows a program to evaluate an expression and attempt
to match the expression's value to a case label. If a match is found, the
program executes the associated statement.
A switch statement looks like this:
jsswitch (expression) {
  case label1:
    statements1;
    break;
  case label2:
    statements2;
    break;
  // …
  default:
    statementsDefault;
}

JavaScript evaluates the above switch statement as follows:


The program first looks for a case clause with a label matching the
value of expression and then transfers control to that clause, executing the
associated statements.


If no matching label is found, the program looks for the optional
default clause:

If a default clause is found, the program transfers control to that
clause, executing the associated statements.
If no default clause is found, the program resumes execution at the
statement following the end of switch.
(By convention, the default clause is written as the last clause,
but it does not need to be so.)



break statements
The optional break statement associated with each case clause
ensures that the program breaks out of switch once the matched statement is
executed, and then continues execution at the statement following switch.
If break is omitted, the program continues execution inside the
switch statement (and will execute statements under the next case, and so on).
Example
In the following example, if fruitType evaluates to
"Bananas", the program matches the value with case "Bananas"
and executes the associated statement. When break is encountered, the
program exits the switch and continues execution from the statement
following switch. If break were omitted, the statement for
case "Cherries" would also be executed.
jsswitch (fruitType) {
  case "Oranges":
    console.log("Oranges are $0.59 a pound.");
    break;
  case "Apples":
    console.log("Apples are $0.32 a pound.");
    break;
  case "Bananas":
    console.log("Bananas are $0.48 a pound.");
    break;
  case "Cherries":
    console.log("Cherries are $3.00 a pound.");
    break;
  case "Mangoes":
    console.log("Mangoes are $0.56 a pound.");
    break;
  case "Papayas":
    console.log("Papayas are $2.79 a pound.");
    break;
  default:
    console.log(`Sorry, we are out of ${fruitType}.`);
}
console.log("Is there anything else you'd like?");
Exception handling statementsYou can throw exceptions using the throw statement and handle them using
the try...catch statements.

throw statement
try...catch statement
Exception typesJust about any object can be thrown in JavaScript. Nevertheless, not all thrown objects
are created equal. While it is common to throw numbers or strings as errors, it is
frequently more effective to use one of the exception types specifically created for
this purpose:

ECMAScript exceptions
DOMException
throw statementUse the throw statement to throw an exception. A throw
statement specifies the value to be thrown:
jsthrow expression;

You may throw any expression, not just expressions of a specific type. The following
code throws several exceptions of varying types:
jsthrow "Error2"; // String type
throw 42; // Number type
throw true; // Boolean type
throw {
  toString() {
    return "I'm an object!";
  },
};
try...catch statementThe try...catch statement marks a block of statements to try, and
specifies one or more responses should an exception be thrown. If an exception is
thrown, the try...catch statement catches it.
The try...catch statement consists of a try block, which
contains one or more statements, and a catch block, containing statements
that specify what to do if an exception is thrown in the try block.
In other words, you want the try block to succeed—but if it does not, you
want control to pass to the catch block. If any statement within the
try block (or in a function called from within the try block)
throws an exception, control immediately shifts to the catch
block. If no exception is thrown in the try block, the catch
block is skipped. The finally block executes after the try and
catch blocks execute but before the statements following the
try...catch statement.
The following example uses a try...catch statement. The example calls a
function that retrieves a month name from an array based on the value passed to the
function. If the value does not correspond to a month number
(1 – 12), an exception is thrown with the value
'InvalidMonthNo' and the statements in the catch block set the
monthName variable to 'unknown'.
jsfunction getMonthName(mo) {
  mo--; // Adjust month number for array index (so that 0 = Jan, 11 = Dec)
  const months = [
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
  ];
  if (months[mo]) {
    return months[mo];
  } else {
    throw new Error("InvalidMonthNo"); // throw keyword is used here
  }
}

try {
  // statements to try
  monthName = getMonthName(myMonth); // function could throw exception
} catch (e) {
  monthName = "unknown";
  logMyErrors(e); // pass exception object to error handler (i.e. your own function)
}

The catch block
You can use a catch block to handle all exceptions that may be generated
in the try block.
jscatch (exception) {
  statements
}

The catch block specifies an identifier (exception
in the preceding syntax) that holds the value specified by the throw
statement. You can use this identifier to get information about the exception that was
thrown.
JavaScript creates this identifier when the catch block is entered. The
identifier lasts only for the duration of the catch block. Once the
catch block finishes executing, the identifier no longer exists.
For example, the following code throws an exception. When the exception occurs, control
transfers to the catch block.
jstry {
  throw "myException"; // generates an exception
} catch (err) {
  // statements to handle any exceptions
  logMyErrors(err); // pass exception object to error handler
}


Note:
When logging errors to the console inside
a catch block, using console.error() rather than
console.log() is advised for debugging. It formats the message as an
error, and adds it to the list of error messages generated by the page.

The finally block
The finally block contains statements to be executed after the
try and catch blocks execute. Additionally, the
finally block executes before the code that follows the
try…catch…finally statement.
It is also important to note that the finally block will execute
whether or not an exception is thrown. If an exception is thrown, however, the
statements in the finally block execute even if no catch block
handles the exception that was thrown.
You can use the finally block to make your script fail gracefully when an
exception occurs. For example, you may need to release a resource that your script has
tied up.
The following example opens a file and then executes statements that use the file.
(Server-side JavaScript allows you to access files.) If an exception is thrown while the
file is open, the finally block closes the file before the script fails.
Using finally here ensures that the file is never left open, even
if an error occurs.
jsopenMyFile();
try {
  writeMyFile(theData); // This may throw an error
} catch (e) {
  handleError(e); // If an error occurred, handle it
} finally {
  closeMyFile(); // Always close the resource
}

If the finally block returns a value, this value becomes the return value
of the entire try…catch…finally production, regardless of any
return statements in the try and catch blocks:
jsfunction f() {
  try {
    console.log(0);
    throw "bogus";
  } catch (e) {
    console.log(1);
    // This return statement is suspended
    // until finally block has completed
    return true;
    console.log(2); // not reachable
  } finally {
    console.log(3);
    return false; // overwrites the previous "return"
    console.log(4); // not reachable
  }
  // "return false" is executed now
  console.log(5); // not reachable
}
console.log(f()); // 0, 1, 3, false

Overwriting of return values by the finally block also applies to
exceptions thrown or re-thrown inside of the catch block:
jsfunction f() {
  try {
    throw "bogus";
  } catch (e) {
    console.log('caught inner "bogus"');
    // This throw statement is suspended until
    // finally block has completed
    throw e;
  } finally {
    return false; // overwrites the previous "throw"
  }
  // "return false" is executed now
}

try {
  console.log(f());
} catch (e) {
  // this is never reached!
  // while f() executes, the `finally` block returns false,
  // which overwrites the `throw` inside the above `catch`
  console.log('caught outer "bogus"');
}

// Logs:
// caught inner "bogus"
// false

Nesting try...catch statements
You can nest one or more try...catch statements.
If an inner try block does not have a corresponding
catch block:

it must contain a finally block, and
the enclosing try...catch statement's catch block is
checked for a match.

For more information, see nested try-blocks
on the try...catch
reference page.Utilizing Error objectsDepending on the type of error, you may be able to use the name and
message properties to get a more refined message.
The name property provides the general class of Error (such
as DOMException or Error), while message
generally provides a more succinct message than one would get by converting the error
object to a string.
If you are throwing your own exceptions, in order to take advantage of these properties
(such as if your catch block doesn't discriminate between your own
exceptions and system ones), you can use the Error constructor.
For example:
jsfunction doSomethingErrorProne() {
  if (ourCodeMakesAMistake()) {
    throw new Error("The message");
  } else {
    doSomethingToGetAJavaScriptError();
  }
}

try {
  doSomethingErrorProne();
} catch (e) {
  // Now, we actually use `console.error()`
  console.error(e.name); // 'Error'
  console.error(e.message); // 'The message', or a JavaScript error message
}

 Previous  Next\n\nControl flow and error handling Previous  Next  
JavaScript supports a compact set of statements, specifically
control flow statements, that you can use to incorporate a great deal of interactivity
in your application. This chapter provides an overview of these statements.
The JavaScript reference
contains exhaustive details about the statements in this chapter. The semicolon
(;) character is used to separate statements in JavaScript code.
Any JavaScript expression is also a statement.
See Expressions and operators
for complete information about expressions.Block statementThe most basic statement is a block statement, which is used to group
statements. The block is delimited by a pair of curly braces:
js{
  statement1;
  statement2;
  // …
  statementN;
}
ExampleBlock statements are commonly used with control flow statements (if,
for, while).
jswhile (x < 10) {
  x++;
}

Here, { x++; } is the block statement.

Note: var-declared variables are not block-scoped, but are scoped to the containing function or script, and the effects of setting them persist beyond the block itself. For example:
jsvar x = 1;
{
  var x = 2;
}
console.log(x); // 2

This outputs 2 because the var x statement within the block is in the same scope as the var x statement before the block. (In C or Java, the equivalent code would have output 1.)
This scoping effect can be mitigated by using let or const.
Conditional statementsA conditional statement is a set of commands that executes if a specified condition is
true. JavaScript supports two conditional statements: if...else and
switch.if...else statementUse the if statement to execute a statement if a logical condition is
true. Use the optional else clause to execute a statement if
the condition is false.
An if statement looks like this:
jsif (condition) {
  statement1;
} else {
  statement2;
}

Here, the condition can be any expression that evaluates to
true or false. (See Boolean
for an explanation of what evaluates to true and false.)
If condition evaluates to true,
statement1 is executed. Otherwise,
statement2 is executed. statement1 and
statement2 can be any statement, including further nested
if statements.
You can also compound the statements using else if to have multiple
conditions tested in sequence, as follows:
jsif (condition1) {
  statement1;
} else if (condition2) {
  statement2;
} else if (conditionN) {
  statementN;
} else {
  statementLast;
}

In the case of multiple conditions, only the first logical condition which evaluates to
true will be executed. To execute multiple statements, group them within a
block statement ({ /* … */ }).
Best practice
In general, it's good practice to always use block statements—especially when
nesting if statements:
jsif (condition) {
  // Statements for when condition is true
  // …
} else {
  // Statements for when condition is false
  // …
}

In general it's good practice to not have an if...else with an assignment like x = y as a condition:
jsif (x = y) {
  // statements here
}

However, in the rare case you find yourself wanting to do something like that, the while documentation has a Using an assignment as a condition section with guidance on a general best-practice syntax you should know about and follow.
Falsy values
The following values evaluate to false (also known as Falsy values):

false
undefined
null
0
NaN
the empty string ("")

All other values—including all objects—evaluate to true when passed to a
conditional statement.

Note:
Do not confuse the primitive boolean values
true and false with the true and false values of the
Boolean object!
For example:
jsconst b = new Boolean(false);
if (b) {
  // this condition evaluates to true
}
if (b == true) {
  // this condition evaluates to false
}


Example
In the following example, the function checkData returns true
if the number of characters in a Text object is three. Otherwise, it
displays an alert and returns false.
jsfunction checkData() {
  if (document.form1.threeChar.value.length === 3) {
    return true;
  } else {
    alert(
      `Enter exactly three characters. ${document.form1.threeChar.value} is not valid.`,
    );
    return false;
  }
}
switch statementA switch statement allows a program to evaluate an expression and attempt
to match the expression's value to a case label. If a match is found, the
program executes the associated statement.
A switch statement looks like this:
jsswitch (expression) {
  case label1:
    statements1;
    break;
  case label2:
    statements2;
    break;
  // …
  default:
    statementsDefault;
}

JavaScript evaluates the above switch statement as follows:


The program first looks for a case clause with a label matching the
value of expression and then transfers control to that clause, executing the
associated statements.


If no matching label is found, the program looks for the optional
default clause:

If a default clause is found, the program transfers control to that
clause, executing the associated statements.
If no default clause is found, the program resumes execution at the
statement following the end of switch.
(By convention, the default clause is written as the last clause,
but it does not need to be so.)



break statements
The optional break statement associated with each case clause
ensures that the program breaks out of switch once the matched statement is
executed, and then continues execution at the statement following switch.
If break is omitted, the program continues execution inside the
switch statement (and will execute statements under the next case, and so on).
Example
In the following example, if fruitType evaluates to
"Bananas", the program matches the value with case "Bananas"
and executes the associated statement. When break is encountered, the
program exits the switch and continues execution from the statement
following switch. If break were omitted, the statement for
case "Cherries" would also be executed.
jsswitch (fruitType) {
  case "Oranges":
    console.log("Oranges are $0.59 a pound.");
    break;
  case "Apples":
    console.log("Apples are $0.32 a pound.");
    break;
  case "Bananas":
    console.log("Bananas are $0.48 a pound.");
    break;
  case "Cherries":
    console.log("Cherries are $3.00 a pound.");
    break;
  case "Mangoes":
    console.log("Mangoes are $0.56 a pound.");
    break;
  case "Papayas":
    console.log("Papayas are $2.79 a pound.");
    break;
  default:
    console.log(`Sorry, we are out of ${fruitType}.`);
}
console.log("Is there anything else you'd like?");
Exception handling statementsYou can throw exceptions using the throw statement and handle them using
the try...catch statements.

throw statement
try...catch statement
Exception typesJust about any object can be thrown in JavaScript. Nevertheless, not all thrown objects
are created equal. While it is common to throw numbers or strings as errors, it is
frequently more effective to use one of the exception types specifically created for
this purpose:

ECMAScript exceptions
DOMException
throw statementUse the throw statement to throw an exception. A throw
statement specifies the value to be thrown:
jsthrow expression;

You may throw any expression, not just expressions of a specific type. The following
code throws several exceptions of varying types:
jsthrow "Error2"; // String type
throw 42; // Number type
throw true; // Boolean type
throw {
  toString() {
    return "I'm an object!";
  },
};
try...catch statementThe try...catch statement marks a block of statements to try, and
specifies one or more responses should an exception be thrown. If an exception is
thrown, the try...catch statement catches it.
The try...catch statement consists of a try block, which
contains one or more statements, and a catch block, containing statements
that specify what to do if an exception is thrown in the try block.
In other words, you want the try block to succeed—but if it does not, you
want control to pass to the catch block. If any statement within the
try block (or in a function called from within the try block)
throws an exception, control immediately shifts to the catch
block. If no exception is thrown in the try block, the catch
block is skipped. The finally block executes after the try and
catch blocks execute but before the statements following the
try...catch statement.
The following example uses a try...catch statement. The example calls a
function that retrieves a month name from an array based on the value passed to the
function. If the value does not correspond to a month number
(1 – 12), an exception is thrown with the value
'InvalidMonthNo' and the statements in the catch block set the
monthName variable to 'unknown'.
jsfunction getMonthName(mo) {
  mo--; // Adjust month number for array index (so that 0 = Jan, 11 = Dec)
  const months = [
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
  ];
  if (months[mo]) {
    return months[mo];
  } else {
    throw new Error("InvalidMonthNo"); // throw keyword is used here
  }
}

try {
  // statements to try
  monthName = getMonthName(myMonth); // function could throw exception
} catch (e) {
  monthName = "unknown";
  logMyErrors(e); // pass exception object to error handler (i.e. your own function)
}

The catch block
You can use a catch block to handle all exceptions that may be generated
in the try block.
jscatch (exception) {
  statements
}

The catch block specifies an identifier (exception
in the preceding syntax) that holds the value specified by the throw
statement. You can use this identifier to get information about the exception that was
thrown.
JavaScript creates this identifier when the catch block is entered. The
identifier lasts only for the duration of the catch block. Once the
catch block finishes executing, the identifier no longer exists.
For example, the following code throws an exception. When the exception occurs, control
transfers to the catch block.
jstry {
  throw "myException"; // generates an exception
} catch (err) {
  // statements to handle any exceptions
  logMyErrors(err); // pass exception object to error handler
}


Note:
When logging errors to the console inside
a catch block, using console.error() rather than
console.log() is advised for debugging. It formats the message as an
error, and adds it to the list of error messages generated by the page.

The finally block
The finally block contains statements to be executed after the
try and catch blocks execute. Additionally, the
finally block executes before the code that follows the
try…catch…finally statement.
It is also important to note that the finally block will execute
whether or not an exception is thrown. If an exception is thrown, however, the
statements in the finally block execute even if no catch block
handles the exception that was thrown.
You can use the finally block to make your script fail gracefully when an
exception occurs. For example, you may need to release a resource that your script has
tied up.
The following example opens a file and then executes statements that use the file.
(Server-side JavaScript allows you to access files.) If an exception is thrown while the
file is open, the finally block closes the file before the script fails.
Using finally here ensures that the file is never left open, even
if an error occurs.
jsopenMyFile();
try {
  writeMyFile(theData); // This may throw an error
} catch (e) {
  handleError(e); // If an error occurred, handle it
} finally {
  closeMyFile(); // Always close the resource
}

If the finally block returns a value, this value becomes the return value
of the entire try…catch…finally production, regardless of any
return statements in the try and catch blocks:
jsfunction f() {
  try {
    console.log(0);
    throw "bogus";
  } catch (e) {
    console.log(1);
    // This return statement is suspended
    // until finally block has completed
    return true;
    console.log(2); // not reachable
  } finally {
    console.log(3);
    return false; // overwrites the previous "return"
    console.log(4); // not reachable
  }
  // "return false" is executed now
  console.log(5); // not reachable
}
console.log(f()); // 0, 1, 3, false

Overwriting of return values by the finally block also applies to
exceptions thrown or re-thrown inside of the catch block:
jsfunction f() {
  try {
    throw "bogus";
  } catch (e) {
    console.log('caught inner "bogus"');
    // This throw statement is suspended until
    // finally block has completed
    throw e;
  } finally {
    return false; // overwrites the previous "throw"
  }
  // "return false" is executed now
}

try {
  console.log(f());
} catch (e) {
  // this is never reached!
  // while f() executes, the `finally` block returns false,
  // which overwrites the `throw` inside the above `catch`
  console.log('caught outer "bogus"');
}

// Logs:
// caught inner "bogus"
// false

Nesting try...catch statements
You can nest one or more try...catch statements.
If an inner try block does not have a corresponding
catch block:

it must contain a finally block, and
the enclosing try...catch statement's catch block is
checked for a match.

For more information, see nested try-blocks
on the try...catch
reference page.Utilizing Error objectsDepending on the type of error, you may be able to use the name and
message properties to get a more refined message.
The name property provides the general class of Error (such
as DOMException or Error), while message
generally provides a more succinct message than one would get by converting the error
object to a string.
If you are throwing your own exceptions, in order to take advantage of these properties
(such as if your catch block doesn't discriminate between your own
exceptions and system ones), you can use the Error constructor.
For example:
jsfunction doSomethingErrorProne() {
  if (ourCodeMakesAMistake()) {
    throw new Error("The message");
  } else {
    doSomethingToGetAJavaScriptError();
  }
}

try {
  doSomethingErrorProne();
} catch (e) {
  // Now, we actually use `console.error()`
  console.error(e.name); // 'Error'
  console.error(e.message); // 'The message', or a JavaScript error message
}

 Previous  Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Nov 21, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nControl flow and error handling Previous  Next  
JavaScript supports a compact set of statements, specifically
control flow statements, that you can use to incorporate a great deal of interactivity
in your application. This chapter provides an overview of these statements.
The JavaScript reference
contains exhaustive details about the statements in this chapter. The semicolon
(;) character is used to separate statements in JavaScript code.
Any JavaScript expression is also a statement.
See Expressions and operators
for complete information about expressions.Block statementThe most basic statement is a block statement, which is used to group
statements. The block is delimited by a pair of curly braces:
js{
  statement1;
  statement2;
  // …
  statementN;
}
ExampleBlock statements are commonly used with control flow statements (if,
for, while).
jswhile (x < 10) {
  x++;
}

Here, { x++; } is the block statement.

Note: var-declared variables are not block-scoped, but are scoped to the containing function or script, and the effects of setting them persist beyond the block itself. For example:
jsvar x = 1;
{
  var x = 2;
}
console.log(x); // 2

This outputs 2 because the var x statement within the block is in the same scope as the var x statement before the block. (In C or Java, the equivalent code would have output 1.)
This scoping effect can be mitigated by using let or const.
Conditional statementsA conditional statement is a set of commands that executes if a specified condition is
true. JavaScript supports two conditional statements: if...else and
switch.if...else statementUse the if statement to execute a statement if a logical condition is
true. Use the optional else clause to execute a statement if
the condition is false.
An if statement looks like this:
jsif (condition) {
  statement1;
} else {
  statement2;
}

Here, the condition can be any expression that evaluates to
true or false. (See Boolean
for an explanation of what evaluates to true and false.)
If condition evaluates to true,
statement1 is executed. Otherwise,
statement2 is executed. statement1 and
statement2 can be any statement, including further nested
if statements.
You can also compound the statements using else if to have multiple
conditions tested in sequence, as follows:
jsif (condition1) {
  statement1;
} else if (condition2) {
  statement2;
} else if (conditionN) {
  statementN;
} else {
  statementLast;
}

In the case of multiple conditions, only the first logical condition which evaluates to
true will be executed. To execute multiple statements, group them within a
block statement ({ /* … */ }).
Best practice
In general, it's good practice to always use block statements—especially when
nesting if statements:
jsif (condition) {
  // Statements for when condition is true
  // …
} else {
  // Statements for when condition is false
  // …
}

In general it's good practice to not have an if...else with an assignment like x = y as a condition:
jsif (x = y) {
  // statements here
}

However, in the rare case you find yourself wanting to do something like that, the while documentation has a Using an assignment as a condition section with guidance on a general best-practice syntax you should know about and follow.
Falsy values
The following values evaluate to false (also known as Falsy values):

false
undefined
null
0
NaN
the empty string ("")

All other values—including all objects—evaluate to true when passed to a
conditional statement.

Note:
Do not confuse the primitive boolean values
true and false with the true and false values of the
Boolean object!
For example:
jsconst b = new Boolean(false);
if (b) {
  // this condition evaluates to true
}
if (b == true) {
  // this condition evaluates to false
}


Example
In the following example, the function checkData returns true
if the number of characters in a Text object is three. Otherwise, it
displays an alert and returns false.
jsfunction checkData() {
  if (document.form1.threeChar.value.length === 3) {
    return true;
  } else {
    alert(
      `Enter exactly three characters. ${document.form1.threeChar.value} is not valid.`,
    );
    return false;
  }
}
switch statementA switch statement allows a program to evaluate an expression and attempt
to match the expression's value to a case label. If a match is found, the
program executes the associated statement.
A switch statement looks like this:
jsswitch (expression) {
  case label1:
    statements1;
    break;
  case label2:
    statements2;
    break;
  // …
  default:
    statementsDefault;
}

JavaScript evaluates the above switch statement as follows:


The program first looks for a case clause with a label matching the
value of expression and then transfers control to that clause, executing the
associated statements.


If no matching label is found, the program looks for the optional
default clause:

If a default clause is found, the program transfers control to that
clause, executing the associated statements.
If no default clause is found, the program resumes execution at the
statement following the end of switch.
(By convention, the default clause is written as the last clause,
but it does not need to be so.)



break statements
The optional break statement associated with each case clause
ensures that the program breaks out of switch once the matched statement is
executed, and then continues execution at the statement following switch.
If break is omitted, the program continues execution inside the
switch statement (and will execute statements under the next case, and so on).
Example
In the following example, if fruitType evaluates to
"Bananas", the program matches the value with case "Bananas"
and executes the associated statement. When break is encountered, the
program exits the switch and continues execution from the statement
following switch. If break were omitted, the statement for
case "Cherries" would also be executed.
jsswitch (fruitType) {
  case "Oranges":
    console.log("Oranges are $0.59 a pound.");
    break;
  case "Apples":
    console.log("Apples are $0.32 a pound.");
    break;
  case "Bananas":
    console.log("Bananas are $0.48 a pound.");
    break;
  case "Cherries":
    console.log("Cherries are $3.00 a pound.");
    break;
  case "Mangoes":
    console.log("Mangoes are $0.56 a pound.");
    break;
  case "Papayas":
    console.log("Papayas are $2.79 a pound.");
    break;
  default:
    console.log(`Sorry, we are out of ${fruitType}.`);
}
console.log("Is there anything else you'd like?");
Exception handling statementsYou can throw exceptions using the throw statement and handle them using
the try...catch statements.

throw statement
try...catch statement
Exception typesJust about any object can be thrown in JavaScript. Nevertheless, not all thrown objects
are created equal. While it is common to throw numbers or strings as errors, it is
frequently more effective to use one of the exception types specifically created for
this purpose:

ECMAScript exceptions
DOMException
throw statementUse the throw statement to throw an exception. A throw
statement specifies the value to be thrown:
jsthrow expression;

You may throw any expression, not just expressions of a specific type. The following
code throws several exceptions of varying types:
jsthrow "Error2"; // String type
throw 42; // Number type
throw true; // Boolean type
throw {
  toString() {
    return "I'm an object!";
  },
};
try...catch statementThe try...catch statement marks a block of statements to try, and
specifies one or more responses should an exception be thrown. If an exception is
thrown, the try...catch statement catches it.
The try...catch statement consists of a try block, which
contains one or more statements, and a catch block, containing statements
that specify what to do if an exception is thrown in the try block.
In other words, you want the try block to succeed—but if it does not, you
want control to pass to the catch block. If any statement within the
try block (or in a function called from within the try block)
throws an exception, control immediately shifts to the catch
block. If no exception is thrown in the try block, the catch
block is skipped. The finally block executes after the try and
catch blocks execute but before the statements following the
try...catch statement.
The following example uses a try...catch statement. The example calls a
function that retrieves a month name from an array based on the value passed to the
function. If the value does not correspond to a month number
(1 – 12), an exception is thrown with the value
'InvalidMonthNo' and the statements in the catch block set the
monthName variable to 'unknown'.
jsfunction getMonthName(mo) {
  mo--; // Adjust month number for array index (so that 0 = Jan, 11 = Dec)
  const months = [
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
  ];
  if (months[mo]) {
    return months[mo];
  } else {
    throw new Error("InvalidMonthNo"); // throw keyword is used here
  }
}

try {
  // statements to try
  monthName = getMonthName(myMonth); // function could throw exception
} catch (e) {
  monthName = "unknown";
  logMyErrors(e); // pass exception object to error handler (i.e. your own function)
}

The catch block
You can use a catch block to handle all exceptions that may be generated
in the try block.
jscatch (exception) {
  statements
}

The catch block specifies an identifier (exception
in the preceding syntax) that holds the value specified by the throw
statement. You can use this identifier to get information about the exception that was
thrown.
JavaScript creates this identifier when the catch block is entered. The
identifier lasts only for the duration of the catch block. Once the
catch block finishes executing, the identifier no longer exists.
For example, the following code throws an exception. When the exception occurs, control
transfers to the catch block.
jstry {
  throw "myException"; // generates an exception
} catch (err) {
  // statements to handle any exceptions
  logMyErrors(err); // pass exception object to error handler
}


Note:
When logging errors to the console inside
a catch block, using console.error() rather than
console.log() is advised for debugging. It formats the message as an
error, and adds it to the list of error messages generated by the page.

The finally block
The finally block contains statements to be executed after the
try and catch blocks execute. Additionally, the
finally block executes before the code that follows the
try…catch…finally statement.
It is also important to note that the finally block will execute
whether or not an exception is thrown. If an exception is thrown, however, the
statements in the finally block execute even if no catch block
handles the exception that was thrown.
You can use the finally block to make your script fail gracefully when an
exception occurs. For example, you may need to release a resource that your script has
tied up.
The following example opens a file and then executes statements that use the file.
(Server-side JavaScript allows you to access files.) If an exception is thrown while the
file is open, the finally block closes the file before the script fails.
Using finally here ensures that the file is never left open, even
if an error occurs.
jsopenMyFile();
try {
  writeMyFile(theData); // This may throw an error
} catch (e) {
  handleError(e); // If an error occurred, handle it
} finally {
  closeMyFile(); // Always close the resource
}

If the finally block returns a value, this value becomes the return value
of the entire try…catch…finally production, regardless of any
return statements in the try and catch blocks:
jsfunction f() {
  try {
    console.log(0);
    throw "bogus";
  } catch (e) {
    console.log(1);
    // This return statement is suspended
    // until finally block has completed
    return true;
    console.log(2); // not reachable
  } finally {
    console.log(3);
    return false; // overwrites the previous "return"
    console.log(4); // not reachable
  }
  // "return false" is executed now
  console.log(5); // not reachable
}
console.log(f()); // 0, 1, 3, false

Overwriting of return values by the finally block also applies to
exceptions thrown or re-thrown inside of the catch block:
jsfunction f() {
  try {
    throw "bogus";
  } catch (e) {
    console.log('caught inner "bogus"');
    // This throw statement is suspended until
    // finally block has completed
    throw e;
  } finally {
    return false; // overwrites the previous "throw"
  }
  // "return false" is executed now
}

try {
  console.log(f());
} catch (e) {
  // this is never reached!
  // while f() executes, the `finally` block returns false,
  // which overwrites the `throw` inside the above `catch`
  console.log('caught outer "bogus"');
}

// Logs:
// caught inner "bogus"
// false

Nesting try...catch statements
You can nest one or more try...catch statements.
If an inner try block does not have a corresponding
catch block:

it must contain a finally block, and
the enclosing try...catch statement's catch block is
checked for a match.

For more information, see nested try-blocks
on the try...catch
reference page.Utilizing Error objectsDepending on the type of error, you may be able to use the name and
message properties to get a more refined message.
The name property provides the general class of Error (such
as DOMException or Error), while message
generally provides a more succinct message than one would get by converting the error
object to a string.
If you are throwing your own exceptions, in order to take advantage of these properties
(such as if your catch block doesn't discriminate between your own
exceptions and system ones), you can use the Error constructor.
For example:
jsfunction doSomethingErrorProne() {
  if (ourCodeMakesAMistake()) {
    throw new Error("The message");
  } else {
    doSomethingToGetAJavaScriptError();
  }
}

try {
  doSomethingErrorProne();
} catch (e) {
  // Now, we actually use `console.error()`
  console.error(e.name); // 'Error'
  console.error(e.message); // 'The message', or a JavaScript error message
}

 Previous  Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Nov 21, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nLoops and iteration Previous  Next  
Loops offer a quick and easy way to do something repeatedly. This
chapter of the JavaScript Guide
introduces the different iteration statements available to JavaScript.
You can think of a loop as a computerized version of the game where you tell someone to
take X steps in one direction, then Y steps in another. For example,
the idea "Go five steps to the east" could be expressed this way as a loop:
jsfor (let step = 0; step < 5; step++) {
  // Runs 5 times, with values of step 0 through 4.
  console.log("Walking east one step");
}

There are many different kinds of loops, but they all essentially do the same thing:
they repeat an action some number of times. (Note that it's possible that number could
be zero!)
The various loop mechanisms offer different ways to determine the start and end points
of the loop. There are various situations that are more easily served by one type of
loop over the others.
The statements for loops provided in JavaScript are:

for statement
do...while statement
while statement
labeled statement
break statement
continue statement
for...in statement
for...of statement
for statementA for loop repeats until a specified condition evaluates to false. The JavaScript for loop is similar to the Java and C for loop.
A for statement looks as follows:
jsfor (initialization; condition; afterthought)
  statement

When a for loop executes, the following occurs:

The initializing expression initialization, if any, is executed. This expression usually initializes one or more loop counters, but the syntax allows an expression of any degree of complexity. This expression can also declare variables.
The condition expression is evaluated. If the value of condition is true, the loop statements execute. Otherwise, the for loop terminates. (If the condition expression is omitted entirely, the condition is assumed to be true.)
The statement executes. To execute multiple statements, use a block statement ({ }) to group those statements.
If present, the update expression afterthought is executed.
Control returns to Step 2.
ExampleIn the example below, the function contains a for statement that counts
the number of selected options in a scrolling list (a <select>
element that allows multiple selections).
HTML
html<form name="selectForm">
  <label for="musicTypes"
    >Choose some music types, then click the button below:</label
  >
  <select id="musicTypes" name="musicTypes" multiple>
    <option selected>R&B</option>
    <option>Jazz</option>
    <option>Blues</option>
    <option>New Age</option>
    <option>Classical</option>
    <option>Opera</option>
  </select>
  <button id="btn" type="button">How many are selected?</button>
</form>

JavaScript
Here, the for statement declares the variable i and initializes it to 0. It checks that i is less than the number of options in the <select> element, performs the succeeding if statement, and increments i by 1 after each pass through the loop.
jsfunction countSelected(selectObject) {
  let numberSelected = 0;
  for (let i = 0; i < selectObject.options.length; i++) {
    if (selectObject.options[i].selected) {
      numberSelected++;
    }
  }
  return numberSelected;
}

const btn = document.getElementById("btn");

btn.addEventListener("click", () => {
  const musicTypes = document.selectForm.musicTypes;
  console.log(`You have selected ${countSelected(musicTypes)} option(s).`);
});
do...while statementThe do...while statement repeats until a
specified condition evaluates to false.
A do...while statement looks as follows:
jsdo
  statement
while (condition);

statement is always executed once before the condition is
checked. (To execute multiple statements, use a block statement ({ })
to group those statements.)
If condition is true, the statement executes again. At the
end of every execution, the condition is checked. When the condition is
false, execution stops, and control passes to the statement following
do...while.ExampleIn the following example, the do loop iterates at least once and
reiterates until i is no longer less than 5.
jslet i = 0;
do {
  i += 1;
  console.log(i);
} while (i < 5);
while statementA while statement executes its statements as long as a
specified condition evaluates to true. A while statement looks
as follows:
jswhile (condition)
  statement

If the condition becomes false,
statement within the loop stops executing and control passes to the
statement following the loop.
The condition test occurs before statement in the loop is
executed. If the condition returns true, statement is executed
and the condition is tested again. If the condition returns
false, execution stops, and control is passed to the statement following
while.
To execute multiple statements, use a block statement ({ }) to group
those statements.Example 1The following while loop iterates as long as n is
less than 3:
jslet n = 0;
let x = 0;
while (n < 3) {
  n++;
  x += n;
}

With each iteration, the loop increments n and adds that value to
x. Therefore, x and n take on the following
values:

After the first pass: n = 1 and x =
1
After the second pass: n = 2 and x =
3
After the third pass: n = 3 and x =
6

After completing the third pass, the condition n < 3 is no longer
true, so the loop terminates.Example 2Avoid infinite loops. Make sure the condition in a loop eventually becomes
false—otherwise, the loop will never terminate! The statements in the
following while loop execute forever because the condition never becomes
false:
js// Infinite loops are bad!
while (true) {
  console.log("Hello, world!");
}
labeled statementA label provides a statement with an identifier that
lets you refer to it elsewhere in your program. For example, you can use a label to
identify a loop, and then use the break or continue statements
to indicate whether a program should interrupt the loop or continue its execution.
The syntax of the labeled statement looks like the following:
jslabel:
  statement

The value of label may be any JavaScript identifier that is not a
reserved word. The statement that you identify with a label may be
any statement. For examples of using labeled statements, see the examples of break and continue below.break statementUse the break statement to terminate a loop,
switch, or in conjunction with a labeled statement.

When you use break without a label, it terminates the innermost
enclosing while, do-while, for, or
switch immediately and transfers control to the following statement.
When you use break with a label, it terminates the specified labeled
statement.

The syntax of the break statement looks like this:
jsbreak;
break label;


The first form of the syntax terminates the innermost enclosing loop or switch.
The second form of the syntax terminates the specified enclosing labeled statement.
Example 1The following example iterates through the elements in an array until it finds the
index of an element whose value is theValue:
jsfor (let i = 0; i < a.length; i++) {
  if (a[i] === theValue) {
    break;
  }
}
Example 2: Breaking to a labeljslet x = 0;
let z = 0;
labelCancelLoops: while (true) {
  console.log("Outer loops:", x);
  x += 1;
  z = 1;
  while (true) {
    console.log("Inner loops:", z);
    z += 1;
    if (z === 10 && x === 10) {
      break labelCancelLoops;
    } else if (z === 10) {
      break;
    }
  }
}
continue statementThe continue statement can be used to restart a
while, do-while, for, or label
statement.

When you use continue without a label, it terminates the current
iteration of the innermost enclosing while, do-while, or
for statement and continues execution of the loop with the next
iteration. In contrast to the break statement, continue does
not terminate the execution of the loop entirely. In a while loop, it
jumps back to the condition. In a for loop, it jumps to the
increment-expression.
When you use continue with a label, it applies to the looping statement
identified with that label.

The syntax of the continue statement looks like the following:
jscontinue;
continue label;
Example 1The following example shows a while loop with a continue
statement that executes when the value of i is 3. Thus,
n takes on the values 1, 3, 7, and
12.
jslet i = 0;
let n = 0;
while (i < 5) {
  i++;
  if (i === 3) {
    continue;
  }
  n += i;
  console.log(n);
}
// Logs:
// 1 3 7 12

If you comment out the continue;, the loop would run till the end and you would see 1,3,6,10,15.Example 2A statement labeled checkIandJ contains a statement labeled
checkJ. If continue is encountered, the program
terminates the current iteration of checkJ and begins the next
iteration. Each time continue is encountered, checkJ
reiterates until its condition returns false. When false is
returned, the remainder of the checkIandJ statement is completed,
and checkIandJ reiterates until its condition returns
false. When false is returned, the program continues at the
statement following checkIandJ.
If continue had a label of checkIandJ, the program
would continue at the top of the checkIandJ statement.
jslet i = 0;
let j = 10;
checkIandJ: while (i < 4) {
  console.log(i);
  i += 1;
  checkJ: while (j > 4) {
    console.log(j);
    j -= 1;
    if (j % 2 === 0) {
      continue checkJ;
    }
    console.log(j, "is odd.");
  }
  console.log("i =", i);
  console.log("j =", j);
}
for...in statementThe for...in statement iterates a specified
variable over all the enumerable properties of an object. For each distinct property,
JavaScript executes the specified statements. A for...in statement looks as
follows:
jsfor (variable in object)
  statement
ExampleThe following function takes as its argument an object and the object's name. It then
iterates over all the object's properties and returns a string that lists the property
names and their values.
jsfunction dumpProps(obj, objName) {
  let result = "";
  for (const i in obj) {
    result += `${objName}.${i} = ${obj[i]}<br>`;
  }
  result += "<hr>";
  return result;
}

For an object car with properties make and model, result would be:
car.make = Ford
car.model = Mustang
ArraysAlthough it may be tempting to use this as a way to iterate over Array
elements, the for...in statement will return the name of your user-defined
properties in addition to the numeric indexes.
Therefore, it is better to use a traditional for loop
with a numeric index when iterating over arrays, because the for...in
statement iterates over user-defined properties in addition to the array elements, if
you modify the Array object (such as adding custom properties or methods).for...of statementThe for...of statement creates a loop Iterating
over iterable objects (including
Array, Map, Set,
arguments object and so on), invoking a custom
iteration hook with statements to be executed for the value of each distinct property.
jsfor (variable of iterable)
  statement

The following example shows the difference between a for...of loop and a
for...in loop. While for...in iterates
over property names, for...of iterates over property values:
jsconst arr = [3, 5, 7];
arr.foo = "hello";

for (const i in arr) {
  console.log(i);
}
// "0" "1" "2" "foo"

for (const i of arr) {
  console.log(i);
}
// Logs: 3 5 7

The for...of and for...in statements can also be used with destructuring. For example, you can simultaneously loop over the keys and values of an object using Object.entries().
jsconst obj = { foo: 1, bar: 2 };

for (const [key, val] of Object.entries(obj)) {
  console.log(key, val);
}
// "foo" 1
// "bar" 2

 Previous  Next\n\nLoops and iteration Previous  Next  
Loops offer a quick and easy way to do something repeatedly. This
chapter of the JavaScript Guide
introduces the different iteration statements available to JavaScript.
You can think of a loop as a computerized version of the game where you tell someone to
take X steps in one direction, then Y steps in another. For example,
the idea "Go five steps to the east" could be expressed this way as a loop:
jsfor (let step = 0; step < 5; step++) {
  // Runs 5 times, with values of step 0 through 4.
  console.log("Walking east one step");
}

There are many different kinds of loops, but they all essentially do the same thing:
they repeat an action some number of times. (Note that it's possible that number could
be zero!)
The various loop mechanisms offer different ways to determine the start and end points
of the loop. There are various situations that are more easily served by one type of
loop over the others.
The statements for loops provided in JavaScript are:

for statement
do...while statement
while statement
labeled statement
break statement
continue statement
for...in statement
for...of statement
for statementA for loop repeats until a specified condition evaluates to false. The JavaScript for loop is similar to the Java and C for loop.
A for statement looks as follows:
jsfor (initialization; condition; afterthought)
  statement

When a for loop executes, the following occurs:

The initializing expression initialization, if any, is executed. This expression usually initializes one or more loop counters, but the syntax allows an expression of any degree of complexity. This expression can also declare variables.
The condition expression is evaluated. If the value of condition is true, the loop statements execute. Otherwise, the for loop terminates. (If the condition expression is omitted entirely, the condition is assumed to be true.)
The statement executes. To execute multiple statements, use a block statement ({ }) to group those statements.
If present, the update expression afterthought is executed.
Control returns to Step 2.
ExampleIn the example below, the function contains a for statement that counts
the number of selected options in a scrolling list (a <select>
element that allows multiple selections).
HTML
html<form name="selectForm">
  <label for="musicTypes"
    >Choose some music types, then click the button below:</label
  >
  <select id="musicTypes" name="musicTypes" multiple>
    <option selected>R&B</option>
    <option>Jazz</option>
    <option>Blues</option>
    <option>New Age</option>
    <option>Classical</option>
    <option>Opera</option>
  </select>
  <button id="btn" type="button">How many are selected?</button>
</form>

JavaScript
Here, the for statement declares the variable i and initializes it to 0. It checks that i is less than the number of options in the <select> element, performs the succeeding if statement, and increments i by 1 after each pass through the loop.
jsfunction countSelected(selectObject) {
  let numberSelected = 0;
  for (let i = 0; i < selectObject.options.length; i++) {
    if (selectObject.options[i].selected) {
      numberSelected++;
    }
  }
  return numberSelected;
}

const btn = document.getElementById("btn");

btn.addEventListener("click", () => {
  const musicTypes = document.selectForm.musicTypes;
  console.log(`You have selected ${countSelected(musicTypes)} option(s).`);
});
do...while statementThe do...while statement repeats until a
specified condition evaluates to false.
A do...while statement looks as follows:
jsdo
  statement
while (condition);

statement is always executed once before the condition is
checked. (To execute multiple statements, use a block statement ({ })
to group those statements.)
If condition is true, the statement executes again. At the
end of every execution, the condition is checked. When the condition is
false, execution stops, and control passes to the statement following
do...while.ExampleIn the following example, the do loop iterates at least once and
reiterates until i is no longer less than 5.
jslet i = 0;
do {
  i += 1;
  console.log(i);
} while (i < 5);
while statementA while statement executes its statements as long as a
specified condition evaluates to true. A while statement looks
as follows:
jswhile (condition)
  statement

If the condition becomes false,
statement within the loop stops executing and control passes to the
statement following the loop.
The condition test occurs before statement in the loop is
executed. If the condition returns true, statement is executed
and the condition is tested again. If the condition returns
false, execution stops, and control is passed to the statement following
while.
To execute multiple statements, use a block statement ({ }) to group
those statements.Example 1The following while loop iterates as long as n is
less than 3:
jslet n = 0;
let x = 0;
while (n < 3) {
  n++;
  x += n;
}

With each iteration, the loop increments n and adds that value to
x. Therefore, x and n take on the following
values:

After the first pass: n = 1 and x =
1
After the second pass: n = 2 and x =
3
After the third pass: n = 3 and x =
6

After completing the third pass, the condition n < 3 is no longer
true, so the loop terminates.Example 2Avoid infinite loops. Make sure the condition in a loop eventually becomes
false—otherwise, the loop will never terminate! The statements in the
following while loop execute forever because the condition never becomes
false:
js// Infinite loops are bad!
while (true) {
  console.log("Hello, world!");
}
labeled statementA label provides a statement with an identifier that
lets you refer to it elsewhere in your program. For example, you can use a label to
identify a loop, and then use the break or continue statements
to indicate whether a program should interrupt the loop or continue its execution.
The syntax of the labeled statement looks like the following:
jslabel:
  statement

The value of label may be any JavaScript identifier that is not a
reserved word. The statement that you identify with a label may be
any statement. For examples of using labeled statements, see the examples of break and continue below.break statementUse the break statement to terminate a loop,
switch, or in conjunction with a labeled statement.

When you use break without a label, it terminates the innermost
enclosing while, do-while, for, or
switch immediately and transfers control to the following statement.
When you use break with a label, it terminates the specified labeled
statement.

The syntax of the break statement looks like this:
jsbreak;
break label;


The first form of the syntax terminates the innermost enclosing loop or switch.
The second form of the syntax terminates the specified enclosing labeled statement.
Example 1The following example iterates through the elements in an array until it finds the
index of an element whose value is theValue:
jsfor (let i = 0; i < a.length; i++) {
  if (a[i] === theValue) {
    break;
  }
}
Example 2: Breaking to a labeljslet x = 0;
let z = 0;
labelCancelLoops: while (true) {
  console.log("Outer loops:", x);
  x += 1;
  z = 1;
  while (true) {
    console.log("Inner loops:", z);
    z += 1;
    if (z === 10 && x === 10) {
      break labelCancelLoops;
    } else if (z === 10) {
      break;
    }
  }
}
continue statementThe continue statement can be used to restart a
while, do-while, for, or label
statement.

When you use continue without a label, it terminates the current
iteration of the innermost enclosing while, do-while, or
for statement and continues execution of the loop with the next
iteration. In contrast to the break statement, continue does
not terminate the execution of the loop entirely. In a while loop, it
jumps back to the condition. In a for loop, it jumps to the
increment-expression.
When you use continue with a label, it applies to the looping statement
identified with that label.

The syntax of the continue statement looks like the following:
jscontinue;
continue label;
Example 1The following example shows a while loop with a continue
statement that executes when the value of i is 3. Thus,
n takes on the values 1, 3, 7, and
12.
jslet i = 0;
let n = 0;
while (i < 5) {
  i++;
  if (i === 3) {
    continue;
  }
  n += i;
  console.log(n);
}
// Logs:
// 1 3 7 12

If you comment out the continue;, the loop would run till the end and you would see 1,3,6,10,15.Example 2A statement labeled checkIandJ contains a statement labeled
checkJ. If continue is encountered, the program
terminates the current iteration of checkJ and begins the next
iteration. Each time continue is encountered, checkJ
reiterates until its condition returns false. When false is
returned, the remainder of the checkIandJ statement is completed,
and checkIandJ reiterates until its condition returns
false. When false is returned, the program continues at the
statement following checkIandJ.
If continue had a label of checkIandJ, the program
would continue at the top of the checkIandJ statement.
jslet i = 0;
let j = 10;
checkIandJ: while (i < 4) {
  console.log(i);
  i += 1;
  checkJ: while (j > 4) {
    console.log(j);
    j -= 1;
    if (j % 2 === 0) {
      continue checkJ;
    }
    console.log(j, "is odd.");
  }
  console.log("i =", i);
  console.log("j =", j);
}
for...in statementThe for...in statement iterates a specified
variable over all the enumerable properties of an object. For each distinct property,
JavaScript executes the specified statements. A for...in statement looks as
follows:
jsfor (variable in object)
  statement
ExampleThe following function takes as its argument an object and the object's name. It then
iterates over all the object's properties and returns a string that lists the property
names and their values.
jsfunction dumpProps(obj, objName) {
  let result = "";
  for (const i in obj) {
    result += `${objName}.${i} = ${obj[i]}<br>`;
  }
  result += "<hr>";
  return result;
}

For an object car with properties make and model, result would be:
car.make = Ford
car.model = Mustang
ArraysAlthough it may be tempting to use this as a way to iterate over Array
elements, the for...in statement will return the name of your user-defined
properties in addition to the numeric indexes.
Therefore, it is better to use a traditional for loop
with a numeric index when iterating over arrays, because the for...in
statement iterates over user-defined properties in addition to the array elements, if
you modify the Array object (such as adding custom properties or methods).for...of statementThe for...of statement creates a loop Iterating
over iterable objects (including
Array, Map, Set,
arguments object and so on), invoking a custom
iteration hook with statements to be executed for the value of each distinct property.
jsfor (variable of iterable)
  statement

The following example shows the difference between a for...of loop and a
for...in loop. While for...in iterates
over property names, for...of iterates over property values:
jsconst arr = [3, 5, 7];
arr.foo = "hello";

for (const i in arr) {
  console.log(i);
}
// "0" "1" "2" "foo"

for (const i of arr) {
  console.log(i);
}
// Logs: 3 5 7

The for...of and for...in statements can also be used with destructuring. For example, you can simultaneously loop over the keys and values of an object using Object.entries().
jsconst obj = { foo: 1, bar: 2 };

for (const [key, val] of Object.entries(obj)) {
  console.log(key, val);
}
// "foo" 1
// "bar" 2

 Previous  Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nLoops and iteration Previous  Next  
Loops offer a quick and easy way to do something repeatedly. This
chapter of the JavaScript Guide
introduces the different iteration statements available to JavaScript.
You can think of a loop as a computerized version of the game where you tell someone to
take X steps in one direction, then Y steps in another. For example,
the idea "Go five steps to the east" could be expressed this way as a loop:
jsfor (let step = 0; step < 5; step++) {
  // Runs 5 times, with values of step 0 through 4.
  console.log("Walking east one step");
}

There are many different kinds of loops, but they all essentially do the same thing:
they repeat an action some number of times. (Note that it's possible that number could
be zero!)
The various loop mechanisms offer different ways to determine the start and end points
of the loop. There are various situations that are more easily served by one type of
loop over the others.
The statements for loops provided in JavaScript are:

for statement
do...while statement
while statement
labeled statement
break statement
continue statement
for...in statement
for...of statement
for statementA for loop repeats until a specified condition evaluates to false. The JavaScript for loop is similar to the Java and C for loop.
A for statement looks as follows:
jsfor (initialization; condition; afterthought)
  statement

When a for loop executes, the following occurs:

The initializing expression initialization, if any, is executed. This expression usually initializes one or more loop counters, but the syntax allows an expression of any degree of complexity. This expression can also declare variables.
The condition expression is evaluated. If the value of condition is true, the loop statements execute. Otherwise, the for loop terminates. (If the condition expression is omitted entirely, the condition is assumed to be true.)
The statement executes. To execute multiple statements, use a block statement ({ }) to group those statements.
If present, the update expression afterthought is executed.
Control returns to Step 2.
ExampleIn the example below, the function contains a for statement that counts
the number of selected options in a scrolling list (a <select>
element that allows multiple selections).
HTML
html<form name="selectForm">
  <label for="musicTypes"
    >Choose some music types, then click the button below:</label
  >
  <select id="musicTypes" name="musicTypes" multiple>
    <option selected>R&B</option>
    <option>Jazz</option>
    <option>Blues</option>
    <option>New Age</option>
    <option>Classical</option>
    <option>Opera</option>
  </select>
  <button id="btn" type="button">How many are selected?</button>
</form>

JavaScript
Here, the for statement declares the variable i and initializes it to 0. It checks that i is less than the number of options in the <select> element, performs the succeeding if statement, and increments i by 1 after each pass through the loop.
jsfunction countSelected(selectObject) {
  let numberSelected = 0;
  for (let i = 0; i < selectObject.options.length; i++) {
    if (selectObject.options[i].selected) {
      numberSelected++;
    }
  }
  return numberSelected;
}

const btn = document.getElementById("btn");

btn.addEventListener("click", () => {
  const musicTypes = document.selectForm.musicTypes;
  console.log(`You have selected ${countSelected(musicTypes)} option(s).`);
});
do...while statementThe do...while statement repeats until a
specified condition evaluates to false.
A do...while statement looks as follows:
jsdo
  statement
while (condition);

statement is always executed once before the condition is
checked. (To execute multiple statements, use a block statement ({ })
to group those statements.)
If condition is true, the statement executes again. At the
end of every execution, the condition is checked. When the condition is
false, execution stops, and control passes to the statement following
do...while.ExampleIn the following example, the do loop iterates at least once and
reiterates until i is no longer less than 5.
jslet i = 0;
do {
  i += 1;
  console.log(i);
} while (i < 5);
while statementA while statement executes its statements as long as a
specified condition evaluates to true. A while statement looks
as follows:
jswhile (condition)
  statement

If the condition becomes false,
statement within the loop stops executing and control passes to the
statement following the loop.
The condition test occurs before statement in the loop is
executed. If the condition returns true, statement is executed
and the condition is tested again. If the condition returns
false, execution stops, and control is passed to the statement following
while.
To execute multiple statements, use a block statement ({ }) to group
those statements.Example 1The following while loop iterates as long as n is
less than 3:
jslet n = 0;
let x = 0;
while (n < 3) {
  n++;
  x += n;
}

With each iteration, the loop increments n and adds that value to
x. Therefore, x and n take on the following
values:

After the first pass: n = 1 and x =
1
After the second pass: n = 2 and x =
3
After the third pass: n = 3 and x =
6

After completing the third pass, the condition n < 3 is no longer
true, so the loop terminates.Example 2Avoid infinite loops. Make sure the condition in a loop eventually becomes
false—otherwise, the loop will never terminate! The statements in the
following while loop execute forever because the condition never becomes
false:
js// Infinite loops are bad!
while (true) {
  console.log("Hello, world!");
}
labeled statementA label provides a statement with an identifier that
lets you refer to it elsewhere in your program. For example, you can use a label to
identify a loop, and then use the break or continue statements
to indicate whether a program should interrupt the loop or continue its execution.
The syntax of the labeled statement looks like the following:
jslabel:
  statement

The value of label may be any JavaScript identifier that is not a
reserved word. The statement that you identify with a label may be
any statement. For examples of using labeled statements, see the examples of break and continue below.break statementUse the break statement to terminate a loop,
switch, or in conjunction with a labeled statement.

When you use break without a label, it terminates the innermost
enclosing while, do-while, for, or
switch immediately and transfers control to the following statement.
When you use break with a label, it terminates the specified labeled
statement.

The syntax of the break statement looks like this:
jsbreak;
break label;


The first form of the syntax terminates the innermost enclosing loop or switch.
The second form of the syntax terminates the specified enclosing labeled statement.
Example 1The following example iterates through the elements in an array until it finds the
index of an element whose value is theValue:
jsfor (let i = 0; i < a.length; i++) {
  if (a[i] === theValue) {
    break;
  }
}
Example 2: Breaking to a labeljslet x = 0;
let z = 0;
labelCancelLoops: while (true) {
  console.log("Outer loops:", x);
  x += 1;
  z = 1;
  while (true) {
    console.log("Inner loops:", z);
    z += 1;
    if (z === 10 && x === 10) {
      break labelCancelLoops;
    } else if (z === 10) {
      break;
    }
  }
}
continue statementThe continue statement can be used to restart a
while, do-while, for, or label
statement.

When you use continue without a label, it terminates the current
iteration of the innermost enclosing while, do-while, or
for statement and continues execution of the loop with the next
iteration. In contrast to the break statement, continue does
not terminate the execution of the loop entirely. In a while loop, it
jumps back to the condition. In a for loop, it jumps to the
increment-expression.
When you use continue with a label, it applies to the looping statement
identified with that label.

The syntax of the continue statement looks like the following:
jscontinue;
continue label;
Example 1The following example shows a while loop with a continue
statement that executes when the value of i is 3. Thus,
n takes on the values 1, 3, 7, and
12.
jslet i = 0;
let n = 0;
while (i < 5) {
  i++;
  if (i === 3) {
    continue;
  }
  n += i;
  console.log(n);
}
// Logs:
// 1 3 7 12

If you comment out the continue;, the loop would run till the end and you would see 1,3,6,10,15.Example 2A statement labeled checkIandJ contains a statement labeled
checkJ. If continue is encountered, the program
terminates the current iteration of checkJ and begins the next
iteration. Each time continue is encountered, checkJ
reiterates until its condition returns false. When false is
returned, the remainder of the checkIandJ statement is completed,
and checkIandJ reiterates until its condition returns
false. When false is returned, the program continues at the
statement following checkIandJ.
If continue had a label of checkIandJ, the program
would continue at the top of the checkIandJ statement.
jslet i = 0;
let j = 10;
checkIandJ: while (i < 4) {
  console.log(i);
  i += 1;
  checkJ: while (j > 4) {
    console.log(j);
    j -= 1;
    if (j % 2 === 0) {
      continue checkJ;
    }
    console.log(j, "is odd.");
  }
  console.log("i =", i);
  console.log("j =", j);
}
for...in statementThe for...in statement iterates a specified
variable over all the enumerable properties of an object. For each distinct property,
JavaScript executes the specified statements. A for...in statement looks as
follows:
jsfor (variable in object)
  statement
ExampleThe following function takes as its argument an object and the object's name. It then
iterates over all the object's properties and returns a string that lists the property
names and their values.
jsfunction dumpProps(obj, objName) {
  let result = "";
  for (const i in obj) {
    result += `${objName}.${i} = ${obj[i]}<br>`;
  }
  result += "<hr>";
  return result;
}

For an object car with properties make and model, result would be:
car.make = Ford
car.model = Mustang
ArraysAlthough it may be tempting to use this as a way to iterate over Array
elements, the for...in statement will return the name of your user-defined
properties in addition to the numeric indexes.
Therefore, it is better to use a traditional for loop
with a numeric index when iterating over arrays, because the for...in
statement iterates over user-defined properties in addition to the array elements, if
you modify the Array object (such as adding custom properties or methods).for...of statementThe for...of statement creates a loop Iterating
over iterable objects (including
Array, Map, Set,
arguments object and so on), invoking a custom
iteration hook with statements to be executed for the value of each distinct property.
jsfor (variable of iterable)
  statement

The following example shows the difference between a for...of loop and a
for...in loop. While for...in iterates
over property names, for...of iterates over property values:
jsconst arr = [3, 5, 7];
arr.foo = "hello";

for (const i in arr) {
  console.log(i);
}
// "0" "1" "2" "foo"

for (const i of arr) {
  console.log(i);
}
// Logs: 3 5 7

The for...of and for...in statements can also be used with destructuring. For example, you can simultaneously loop over the keys and values of an object using Object.entries().
jsconst obj = { foo: 1, bar: 2 };

for (const [key, val] of Object.entries(obj)) {
  console.log(key, val);
}
// "foo" 1
// "bar" 2

 Previous  Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nFunctions 
 Previous  Next  
Functions are one of the fundamental building blocks in JavaScript. A function in JavaScript is similar to a procedure—a set of statements that performs a task or calculates a value, but for a procedure to qualify as a function, it should take some input and return an output where there is some obvious relationship between the input and the output. To use a function, you must define it somewhere in the scope from which you wish to call it.
See also the exhaustive reference chapter about JavaScript functions to get to know the details.Defining functionsFunction declarationsA function definition (also called a function declaration, or function statement) consists of the function keyword, followed by:

The name of the function.
A list of parameters to the function, enclosed in parentheses and separated by commas.
The JavaScript statements that define the function, enclosed in curly braces, { /* … */ }.

For example, the following code defines a function named square:
jsfunction square(number) {
  return number * number;
}

The function square takes one parameter, called number. The function consists of one statement that says to return the parameter of the function (that is, number) multiplied by itself. The return statement specifies the value returned by the function, which is number * number.
Parameters are essentially passed to functions by value — so if the code within the body of a function assigns a completely new value to a parameter that was passed to the function, the change is not reflected globally or in the code which called that function.
When you pass an object as a parameter, if the function changes the object's properties, that change is visible outside the function, as shown in the following example:
jsfunction myFunc(theObject) {
  theObject.make = "Toyota";
}

const myCar = {
  make: "Honda",
  model: "Accord",
  year: 1998,
};

console.log(myCar.make); // "Honda"
myFunc(myCar);
console.log(myCar.make); // "Toyota"

When you pass an array as a parameter, if the function changes any of the array's values, that change is visible outside the function, as shown in the following example:
jsfunction myFunc(theArr) {
  theArr[0] = 30;
}

const arr = [45];

console.log(arr[0]); // 45
myFunc(arr);
console.log(arr[0]); // 30

Function declarations and expressions can be nested, which forms a scope chain. For example:
jsfunction addSquares(a, b) {
  function square(x) {
    return x * x;
  }
  return square(a) + square(b);
}

See function scopes and closures for more information.Function expressionsWhile the function declaration above is syntactically a statement, functions can also be created by a function expression.
Such a function can be anonymous; it does not have to have a name. For example, the function square could have been defined as:
jsconst square = function (number) {
  return number * number;
};

console.log(square(4)); // 16

However, a name can be provided with a function expression. Providing a name allows the function to refer to itself, and also makes it easier to identify the function in a debugger's stack traces:
jsconst factorial = function fac(n) {
  return n < 2 ? 1 : n * fac(n - 1);
};

console.log(factorial(3)); // 6

Function expressions are convenient when passing a function as an argument to another function. The following example defines a map function that should receive a function as first argument and an array as second argument. Then, it is called with a function defined by a function expression:
jsfunction map(f, a) {
  const result = new Array(a.length);
  for (let i = 0; i < a.length; i++) {
    result[i] = f(a[i]);
  }
  return result;
}

const numbers = [0, 1, 2, 5, 10];
const cubedNumbers = map(function (x) {
  return x * x * x;
}, numbers);
console.log(cubedNumbers); // [0, 1, 8, 125, 1000]

In JavaScript, a function can be defined based on a condition. For example, the following function definition defines myFunc only if num equals 0:
jslet myFunc;
if (num === 0) {
  myFunc = function (theObject) {
    theObject.make = "Toyota";
  };
}

In addition to defining functions as described here, you can also use the Function constructor to create functions from a string at runtime, much like eval().
A method is a function that is a property of an object. Read more about objects and methods in Working with objects.Calling functionsDefining a function does not execute it. Defining it names the function and specifies what to do when the function is called.
Calling the function actually performs the specified actions with the indicated parameters. For example, if you define the function square, you could call it as follows:
jssquare(5);

The preceding statement calls the function with an argument of 5. The function executes its statements and returns the value 25.
Functions must be in scope when they are called, but the function declaration can be hoisted (appear below the call in the code). The scope of a function declaration is the function in which it is declared (or the entire program, if it is declared at the top level).
The arguments of a function are not limited to strings and numbers. You can pass whole objects to a function. The showProps() function (defined in Working with objects) is an example of a function that takes an object as an argument.
A function can call itself. For example, here is a function that computes factorials recursively:
jsfunction factorial(n) {
  if (n === 0 || n === 1) {
    return 1;
  } else {
    return n * factorial(n - 1);
  }
}

You could then compute the factorials of 1 through 5 as follows:
jsconsole.log(factorial(1)); // 1
console.log(factorial(2)); // 2
console.log(factorial(3)); // 6
console.log(factorial(4)); // 24
console.log(factorial(5)); // 120

There are other ways to call functions. There are often cases where a function needs to be called dynamically, or the number of arguments to a function vary, or in which the context of the function call needs to be set to a specific object determined at runtime.
It turns out that functions are themselves objects — and in turn, these objects have methods. (See the Function object.) The call() and apply() methods can be used to achieve this goal.Function hoistingConsider the example below:
jsconsole.log(square(5)); // 25

function square(n) {
  return n * n;
}

This code runs without any error, despite the square() function being called before it's declared. This is because the JavaScript interpreter hoists the entire function declaration to the top of the current scope, so the code above is equivalent to:
js// All function declarations are effectively at the top of the scope
function square(n) {
  return n * n;
}

console.log(square(5)); // 25

Function hoisting only works with function declarations — not with function expressions. The following code will not work:
jsconsole.log(square(5)); // ReferenceError: Cannot access 'square' before initialization
const square = function (n) {
  return n * n;
};
RecursionA function can refer to and call itself. It can be referred to either by the function expression or declaration's name, or via any in-scope variable that refers to the function object. For example, consider the following function definition:
jsconst foo = function bar() {
  // statements go here
};

Within the function body, you can refer to the function itself either as bar or foo, and call itself using bar() or foo().
A function that calls itself is called a recursive function. In some ways, recursion is analogous to a loop. Both execute the same code multiple times, and both require a condition (to avoid an infinite loop, or rather, infinite recursion in this case).
For example, consider the following loop:
jslet x = 0;
// "x < 10" is the loop condition
while (x < 10) {
  // do stuff
  x++;
}

It can be converted into a recursive function declaration, followed by a call to that function:
jsfunction loop(x) {
  // "x >= 10" is the exit condition (equivalent to "!(x < 10)")
  if (x >= 10) {
    return;
  }
  // do stuff
  loop(x + 1); // the recursive call
}
loop(0);

However, some algorithms cannot be simple iterative loops. For example, getting all the nodes of a tree structure (such as the DOM) is easier via recursion:
jsfunction walkTree(node) {
  if (node === null) {
    return;
  }
  // do something with node
  for (let i = 0; i < node.childNodes.length; i++) {
    walkTree(node.childNodes[i]);
  }
}

Compared to the function loop, each recursive call itself makes many recursive calls here.
It is possible to convert any recursive algorithm to a non-recursive one, but the logic is often much more complex, and doing so requires the use of a stack.
In fact, recursion itself uses a stack: the function stack. The stack-like behavior can be seen in the following example:
jsfunction foo(i) {
  if (i < 0) {
    return;
  }
  console.log(`begin: ${i}`);
  foo(i - 1);
  console.log(`end: ${i}`);
}
foo(3);

// Logs:
// begin: 3
// begin: 2
// begin: 1
// begin: 0
// end: 0
// end: 1
// end: 2
// end: 3
Immediately Invoked Function Expressions (IIFE)An Immediately Invoked Function Expression (IIFE) is a code pattern that directly calls a function defined as an expression. It looks like this:
js(function () {
  // Do something
})();

const value = (function () {
  // Do something
  return someValue;
})();

Instead of saving the function in a variable, the function is immediately invoked. This is almost equivalent to just writing the function body, but there are a few unique benefits:

It creates an extra scope of variables, which helps to confine variables to the place where they are useful.
It is now an expression instead of a sequence of statements. This allows you to write complex computation logic when initializing variables.

For more information, see the IIFE glossary entry.Function scopes and closuresFunctions form a scope for variables—this means variables defined inside a function cannot be accessed from anywhere outside the function. The function scope inherits from all the upper scopes. For example, a function defined in the global scope can access all variables defined in the global scope. A function defined inside another function can also access all variables defined in its parent function, and any other variables to which the parent function has access. On the other hand, the parent function (and any other parent scope) does not have access to the variables and functions defined inside the inner function. This provides a sort of encapsulation for the variables in the inner function.
js// The following variables are defined in the global scope
const num1 = 20;
const num2 = 3;
const name = "Chamakh";

// This function is defined in the global scope
function multiply() {
  return num1 * num2;
}

console.log(multiply()); // 60

// A nested function example
function getScore() {
  const num1 = 2;
  const num2 = 3;

  function add() {
    return `${name} scored ${num1 + num2}`;
  }

  return add();
}

console.log(getScore()); // "Chamakh scored 5"
ClosuresWe also refer to the function body as a closure. A closure is any piece of source code (most commonly, a function) that refers to some variables, and the closure "remembers" these variables even when the scope in which these variables were declared has exited.
Closures are usually illustrated with nested functions to show that they remember variables beyond the lifetime of its parent scope; but in fact, nested functions are unnecessary. Technically speaking, all functions in JavaScript form closures—some just don't capture anything, and closures don't even have to be functions. The key ingredients for a useful closure are the following:

A parent scope that defines some variables or functions. It should have a clear lifetime, which means it should finish execution at some point. Any scope that's not the global scope satisfies this requirement; this includes blocks, functions, modules, and more.
An inner scope defined within the parent scope, which refers to some variables or functions defined in the parent scope.
The inner scope manages to survive beyond the lifetime of the parent scope. For example, it is saved to a variable that's defined outside the parent scope, or it's returned from the parent scope (if the parent scope is a function).
Then, when you call the function outside of the parent scope, you can still access the variables or functions that were defined in the parent scope, even though the parent scope has finished execution.

The following is a typical example of a closure:
js// The outer function defines a variable called "name"
const pet = function (name) {
  const getName = function () {
    // The inner function has access to the "name" variable of the outer function
    return name;
  };
  return getName; // Return the inner function, thereby exposing it to outer scopes
};
const myPet = pet("Vivie");

console.log(myPet()); // "Vivie"

It can be much more complex than the code above. An object containing methods for manipulating the inner variables of the outer function can be returned.
jsconst createPet = function (name) {
  let sex;

  const pet = {
    // setName(newName) is equivalent to setName: function (newName)
    // in this context
    setName(newName) {
      name = newName;
    },

    getName() {
      return name;
    },

    getSex() {
      return sex;
    },

    setSex(newSex) {
      if (
        typeof newSex === "string" &&
        (newSex.toLowerCase() === "male" || newSex.toLowerCase() === "female")
      ) {
        sex = newSex;
      }
    },
  };

  return pet;
};

const pet = createPet("Vivie");
console.log(pet.getName()); // Vivie

pet.setName("Oliver");
pet.setSex("male");
console.log(pet.getSex()); // male
console.log(pet.getName()); // Oliver

In the code above, the name variable of the outer function is accessible to the inner functions, and there is no other way to access the inner variables except through the inner functions. The inner variables of the inner functions act as safe stores for the outer arguments and variables. They hold "persistent" and "encapsulated" data for the inner functions to work with. The functions do not even have to be assigned to a variable, or have a name.
jsconst getCode = (function () {
  const apiCode = "0]Eal(eh&2"; // A code we do not want outsiders to be able to modify…

  return function () {
    return apiCode;
  };
})();

console.log(getCode()); // "0]Eal(eh&2"

In the code above, we use the IIFE pattern. Within this IIFE scope, two values exist: a variable apiCode and an unnamed function that gets returned and gets assigned to the variable getCode. apiCode is in the scope of the returned unnamed function but not in the scope of any other part of the program, so there is no way for reading the value of apiCode apart from via the getCode function.Multiply-nested functionsFunctions can be multiply-nested. For example:

A function (A) contains a function (B), which itself contains a function (C).
Both functions B and C form closures here. So, B can access A, and C can access B.
In addition, since C can access B which can access A, C can also access A.

Thus, the closures can contain multiple scopes; they recursively contain the scope of the functions containing it. This is called scope chaining. Consider the following example:
jsfunction A(x) {
  function B(y) {
    function C(z) {
      console.log(x + y + z);
    }
    C(3);
  }
  B(2);
}
A(1); // Logs 6 (which is 1 + 2 + 3)

In this example, C accesses B's y and A's x. This can be done because:

B forms a closure including A (i.e., B can access A's arguments and variables).
C forms a closure including B.
Because C's closure includes B and B's closure includes A, then C's closure also includes A. This means C can access both B and A's arguments and variables. In other words, C chains the scopes of B and A, in that order.

The reverse, however, is not true. A cannot access C, because A cannot access any argument or variable of B, which C is a variable of. Thus, C remains private to only B.Name conflictsWhen two arguments or variables in the scopes of a closure have the same name, there is a name conflict. More nested scopes take precedence. So, the innermost scope takes the highest precedence, while the outermost scope takes the lowest. This is the scope chain. The first on the chain is the innermost scope, and the last is the outermost scope. Consider the following:
jsfunction outside() {
  const x = 5;
  function inside(x) {
    return x * 2;
  }
  return inside;
}

console.log(outside()(10)); // 20 (instead of 10)

The name conflict happens at the statement return x * 2 and is between inside's parameter x and outside's variable x. The scope chain here is inside => outside => global object. Therefore, inside's x takes precedences over outside's x, and 20 (inside's x) is returned instead of 10 (outside's x).Using the arguments objectThe arguments of a function are maintained in an array-like object. Within a function, you can address the arguments passed to it as follows:
jsarguments[i];

where i is the ordinal number of the argument, starting at 0. So, the first argument passed to a function would be arguments[0]. The total number of arguments is indicated by arguments.length.
Using the arguments object, you can call a function with more arguments than it is formally declared to accept. This is often useful if you don't know in advance how many arguments will be passed to the function. You can use arguments.length to determine the number of arguments actually passed to the function, and then access each argument using the arguments object.
For example, consider a function that concatenates several strings. The only formal argument for the function is a string that specifies the characters that separate the items to concatenate. The function is defined as follows:
jsfunction myConcat(separator) {
  let result = ""; // initialize list
  // iterate through arguments
  for (let i = 1; i < arguments.length; i++) {
    result += arguments[i] + separator;
  }
  return result;
}

You can pass any number of arguments to this function, and it concatenates each argument into a string "list":
jsconsole.log(myConcat(", ", "red", "orange", "blue"));
// "red, orange, blue, "

console.log(myConcat("; ", "elephant", "giraffe", "lion", "cheetah"));
// "elephant; giraffe; lion; cheetah; "

console.log(myConcat(". ", "sage", "basil", "oregano", "pepper", "parsley"));
// "sage. basil. oregano. pepper. parsley. "


Note:
The arguments variable is "array-like", but not an array. It is array-like in that it has a numbered index and a length property. However, it does not possess all of the array-manipulation methods.

See the Function object in the JavaScript reference for more information.Function parametersThere are two special kinds of parameter syntax: default parameters and rest parameters.Default parametersIn JavaScript, parameters of functions default to undefined. However, in some situations it might be useful to set a different default value. This is exactly what default parameters do.
In the past, the general strategy for setting defaults was to test parameter values in the body of the function and assign a value if they are undefined.
In the following example, if no value is provided for b, its value would be undefined when evaluating a*b, and a call to multiply would normally have returned NaN. However, this is prevented by the second line in this example:
jsfunction multiply(a, b) {
  b = typeof b !== "undefined" ? b : 1;
  return a * b;
}

console.log(multiply(5)); // 5

With default parameters, a manual check in the function body is no longer necessary. You can put 1 as the default value for b in the function head:
jsfunction multiply(a, b = 1) {
  return a * b;
}

console.log(multiply(5)); // 5

For more details, see default parameters in the reference.Rest parametersThe rest parameter syntax allows us to represent an indefinite number of arguments as an array.
In the following example, the function multiply uses rest parameters to collect arguments from the second one to the end. The function then multiplies these by the first argument.
jsfunction multiply(multiplier, ...theArgs) {
  return theArgs.map((x) => multiplier * x);
}

const arr = multiply(2, 1, 2, 3);
console.log(arr); // [2, 4, 6]
Arrow functionsAn arrow function expression (also called a fat arrow to distinguish from a hypothetical -> syntax in future JavaScript) has a shorter syntax compared to function expressions and does not have its own this, arguments, super, or new.target. Arrow functions are always anonymous.
Two factors influenced the introduction of arrow functions: shorter functions and non-binding of this.Shorter functionsIn some functional patterns, shorter functions are welcome. Compare:
jsconst a = ["Hydrogen", "Helium", "Lithium", "Beryllium"];

const a2 = a.map(function (s) {
  return s.length;
});

console.log(a2); // [8, 6, 7, 9]

const a3 = a.map((s) => s.length);

console.log(a3); // [8, 6, 7, 9]
No separate thisUntil arrow functions, every new function defined its own this value (a new object in the case of a constructor, undefined in strict mode function calls, the base object if the function is called as an "object method", etc.). This proved to be less than ideal with an object-oriented style of programming.
jsfunction Person() {
  // The Person() constructor defines `this` as itself.
  this.age = 0;

  setInterval(function growUp() {
    // In nonstrict mode, the growUp() function defines `this`
    // as the global object, which is different from the `this`
    // defined by the Person() constructor.
    this.age++;
  }, 1000);
}

const p = new Person();

In ECMAScript 3/5, this issue was fixed by assigning the value in this to a variable that could be closed over.
jsfunction Person() {
  // Some choose `that` instead of `self`.
  // Choose one and be consistent.
  const self = this;
  self.age = 0;

  setInterval(function growUp() {
    // The callback refers to the `self` variable of which
    // the value is the expected object.
    self.age++;
  }, 1000);
}

Alternatively, a bound function could be created so that the proper this value would be passed to the growUp() function.
An arrow function does not have its own this; the this value of the enclosing execution context is used. Thus, in the following code, the this within the function that is passed to setInterval has the same value as this in the enclosing function:
jsfunction Person() {
  this.age = 0;

  setInterval(() => {
    this.age++; // `this` properly refers to the person object
  }, 1000);
}

const p = new Person();

 Previous  Next\n\nFunctions 
 Previous  Next  
Functions are one of the fundamental building blocks in JavaScript. A function in JavaScript is similar to a procedure—a set of statements that performs a task or calculates a value, but for a procedure to qualify as a function, it should take some input and return an output where there is some obvious relationship between the input and the output. To use a function, you must define it somewhere in the scope from which you wish to call it.
See also the exhaustive reference chapter about JavaScript functions to get to know the details.Defining functionsFunction declarationsA function definition (also called a function declaration, or function statement) consists of the function keyword, followed by:

The name of the function.
A list of parameters to the function, enclosed in parentheses and separated by commas.
The JavaScript statements that define the function, enclosed in curly braces, { /* … */ }.

For example, the following code defines a function named square:
jsfunction square(number) {
  return number * number;
}

The function square takes one parameter, called number. The function consists of one statement that says to return the parameter of the function (that is, number) multiplied by itself. The return statement specifies the value returned by the function, which is number * number.
Parameters are essentially passed to functions by value — so if the code within the body of a function assigns a completely new value to a parameter that was passed to the function, the change is not reflected globally or in the code which called that function.
When you pass an object as a parameter, if the function changes the object's properties, that change is visible outside the function, as shown in the following example:
jsfunction myFunc(theObject) {
  theObject.make = "Toyota";
}

const myCar = {
  make: "Honda",
  model: "Accord",
  year: 1998,
};

console.log(myCar.make); // "Honda"
myFunc(myCar);
console.log(myCar.make); // "Toyota"

When you pass an array as a parameter, if the function changes any of the array's values, that change is visible outside the function, as shown in the following example:
jsfunction myFunc(theArr) {
  theArr[0] = 30;
}

const arr = [45];

console.log(arr[0]); // 45
myFunc(arr);
console.log(arr[0]); // 30

Function declarations and expressions can be nested, which forms a scope chain. For example:
jsfunction addSquares(a, b) {
  function square(x) {
    return x * x;
  }
  return square(a) + square(b);
}

See function scopes and closures for more information.Function expressionsWhile the function declaration above is syntactically a statement, functions can also be created by a function expression.
Such a function can be anonymous; it does not have to have a name. For example, the function square could have been defined as:
jsconst square = function (number) {
  return number * number;
};

console.log(square(4)); // 16

However, a name can be provided with a function expression. Providing a name allows the function to refer to itself, and also makes it easier to identify the function in a debugger's stack traces:
jsconst factorial = function fac(n) {
  return n < 2 ? 1 : n * fac(n - 1);
};

console.log(factorial(3)); // 6

Function expressions are convenient when passing a function as an argument to another function. The following example defines a map function that should receive a function as first argument and an array as second argument. Then, it is called with a function defined by a function expression:
jsfunction map(f, a) {
  const result = new Array(a.length);
  for (let i = 0; i < a.length; i++) {
    result[i] = f(a[i]);
  }
  return result;
}

const numbers = [0, 1, 2, 5, 10];
const cubedNumbers = map(function (x) {
  return x * x * x;
}, numbers);
console.log(cubedNumbers); // [0, 1, 8, 125, 1000]

In JavaScript, a function can be defined based on a condition. For example, the following function definition defines myFunc only if num equals 0:
jslet myFunc;
if (num === 0) {
  myFunc = function (theObject) {
    theObject.make = "Toyota";
  };
}

In addition to defining functions as described here, you can also use the Function constructor to create functions from a string at runtime, much like eval().
A method is a function that is a property of an object. Read more about objects and methods in Working with objects.Calling functionsDefining a function does not execute it. Defining it names the function and specifies what to do when the function is called.
Calling the function actually performs the specified actions with the indicated parameters. For example, if you define the function square, you could call it as follows:
jssquare(5);

The preceding statement calls the function with an argument of 5. The function executes its statements and returns the value 25.
Functions must be in scope when they are called, but the function declaration can be hoisted (appear below the call in the code). The scope of a function declaration is the function in which it is declared (or the entire program, if it is declared at the top level).
The arguments of a function are not limited to strings and numbers. You can pass whole objects to a function. The showProps() function (defined in Working with objects) is an example of a function that takes an object as an argument.
A function can call itself. For example, here is a function that computes factorials recursively:
jsfunction factorial(n) {
  if (n === 0 || n === 1) {
    return 1;
  } else {
    return n * factorial(n - 1);
  }
}

You could then compute the factorials of 1 through 5 as follows:
jsconsole.log(factorial(1)); // 1
console.log(factorial(2)); // 2
console.log(factorial(3)); // 6
console.log(factorial(4)); // 24
console.log(factorial(5)); // 120

There are other ways to call functions. There are often cases where a function needs to be called dynamically, or the number of arguments to a function vary, or in which the context of the function call needs to be set to a specific object determined at runtime.
It turns out that functions are themselves objects — and in turn, these objects have methods. (See the Function object.) The call() and apply() methods can be used to achieve this goal.Function hoistingConsider the example below:
jsconsole.log(square(5)); // 25

function square(n) {
  return n * n;
}

This code runs without any error, despite the square() function being called before it's declared. This is because the JavaScript interpreter hoists the entire function declaration to the top of the current scope, so the code above is equivalent to:
js// All function declarations are effectively at the top of the scope
function square(n) {
  return n * n;
}

console.log(square(5)); // 25

Function hoisting only works with function declarations — not with function expressions. The following code will not work:
jsconsole.log(square(5)); // ReferenceError: Cannot access 'square' before initialization
const square = function (n) {
  return n * n;
};
RecursionA function can refer to and call itself. It can be referred to either by the function expression or declaration's name, or via any in-scope variable that refers to the function object. For example, consider the following function definition:
jsconst foo = function bar() {
  // statements go here
};

Within the function body, you can refer to the function itself either as bar or foo, and call itself using bar() or foo().
A function that calls itself is called a recursive function. In some ways, recursion is analogous to a loop. Both execute the same code multiple times, and both require a condition (to avoid an infinite loop, or rather, infinite recursion in this case).
For example, consider the following loop:
jslet x = 0;
// "x < 10" is the loop condition
while (x < 10) {
  // do stuff
  x++;
}

It can be converted into a recursive function declaration, followed by a call to that function:
jsfunction loop(x) {
  // "x >= 10" is the exit condition (equivalent to "!(x < 10)")
  if (x >= 10) {
    return;
  }
  // do stuff
  loop(x + 1); // the recursive call
}
loop(0);

However, some algorithms cannot be simple iterative loops. For example, getting all the nodes of a tree structure (such as the DOM) is easier via recursion:
jsfunction walkTree(node) {
  if (node === null) {
    return;
  }
  // do something with node
  for (let i = 0; i < node.childNodes.length; i++) {
    walkTree(node.childNodes[i]);
  }
}

Compared to the function loop, each recursive call itself makes many recursive calls here.
It is possible to convert any recursive algorithm to a non-recursive one, but the logic is often much more complex, and doing so requires the use of a stack.
In fact, recursion itself uses a stack: the function stack. The stack-like behavior can be seen in the following example:
jsfunction foo(i) {
  if (i < 0) {
    return;
  }
  console.log(`begin: ${i}`);
  foo(i - 1);
  console.log(`end: ${i}`);
}
foo(3);

// Logs:
// begin: 3
// begin: 2
// begin: 1
// begin: 0
// end: 0
// end: 1
// end: 2
// end: 3
Immediately Invoked Function Expressions (IIFE)An Immediately Invoked Function Expression (IIFE) is a code pattern that directly calls a function defined as an expression. It looks like this:
js(function () {
  // Do something
})();

const value = (function () {
  // Do something
  return someValue;
})();

Instead of saving the function in a variable, the function is immediately invoked. This is almost equivalent to just writing the function body, but there are a few unique benefits:

It creates an extra scope of variables, which helps to confine variables to the place where they are useful.
It is now an expression instead of a sequence of statements. This allows you to write complex computation logic when initializing variables.

For more information, see the IIFE glossary entry.Function scopes and closuresFunctions form a scope for variables—this means variables defined inside a function cannot be accessed from anywhere outside the function. The function scope inherits from all the upper scopes. For example, a function defined in the global scope can access all variables defined in the global scope. A function defined inside another function can also access all variables defined in its parent function, and any other variables to which the parent function has access. On the other hand, the parent function (and any other parent scope) does not have access to the variables and functions defined inside the inner function. This provides a sort of encapsulation for the variables in the inner function.
js// The following variables are defined in the global scope
const num1 = 20;
const num2 = 3;
const name = "Chamakh";

// This function is defined in the global scope
function multiply() {
  return num1 * num2;
}

console.log(multiply()); // 60

// A nested function example
function getScore() {
  const num1 = 2;
  const num2 = 3;

  function add() {
    return `${name} scored ${num1 + num2}`;
  }

  return add();
}

console.log(getScore()); // "Chamakh scored 5"
ClosuresWe also refer to the function body as a closure. A closure is any piece of source code (most commonly, a function) that refers to some variables, and the closure "remembers" these variables even when the scope in which these variables were declared has exited.
Closures are usually illustrated with nested functions to show that they remember variables beyond the lifetime of its parent scope; but in fact, nested functions are unnecessary. Technically speaking, all functions in JavaScript form closures—some just don't capture anything, and closures don't even have to be functions. The key ingredients for a useful closure are the following:

A parent scope that defines some variables or functions. It should have a clear lifetime, which means it should finish execution at some point. Any scope that's not the global scope satisfies this requirement; this includes blocks, functions, modules, and more.
An inner scope defined within the parent scope, which refers to some variables or functions defined in the parent scope.
The inner scope manages to survive beyond the lifetime of the parent scope. For example, it is saved to a variable that's defined outside the parent scope, or it's returned from the parent scope (if the parent scope is a function).
Then, when you call the function outside of the parent scope, you can still access the variables or functions that were defined in the parent scope, even though the parent scope has finished execution.

The following is a typical example of a closure:
js// The outer function defines a variable called "name"
const pet = function (name) {
  const getName = function () {
    // The inner function has access to the "name" variable of the outer function
    return name;
  };
  return getName; // Return the inner function, thereby exposing it to outer scopes
};
const myPet = pet("Vivie");

console.log(myPet()); // "Vivie"

It can be much more complex than the code above. An object containing methods for manipulating the inner variables of the outer function can be returned.
jsconst createPet = function (name) {
  let sex;

  const pet = {
    // setName(newName) is equivalent to setName: function (newName)
    // in this context
    setName(newName) {
      name = newName;
    },

    getName() {
      return name;
    },

    getSex() {
      return sex;
    },

    setSex(newSex) {
      if (
        typeof newSex === "string" &&
        (newSex.toLowerCase() === "male" || newSex.toLowerCase() === "female")
      ) {
        sex = newSex;
      }
    },
  };

  return pet;
};

const pet = createPet("Vivie");
console.log(pet.getName()); // Vivie

pet.setName("Oliver");
pet.setSex("male");
console.log(pet.getSex()); // male
console.log(pet.getName()); // Oliver

In the code above, the name variable of the outer function is accessible to the inner functions, and there is no other way to access the inner variables except through the inner functions. The inner variables of the inner functions act as safe stores for the outer arguments and variables. They hold "persistent" and "encapsulated" data for the inner functions to work with. The functions do not even have to be assigned to a variable, or have a name.
jsconst getCode = (function () {
  const apiCode = "0]Eal(eh&2"; // A code we do not want outsiders to be able to modify…

  return function () {
    return apiCode;
  };
})();

console.log(getCode()); // "0]Eal(eh&2"

In the code above, we use the IIFE pattern. Within this IIFE scope, two values exist: a variable apiCode and an unnamed function that gets returned and gets assigned to the variable getCode. apiCode is in the scope of the returned unnamed function but not in the scope of any other part of the program, so there is no way for reading the value of apiCode apart from via the getCode function.Multiply-nested functionsFunctions can be multiply-nested. For example:

A function (A) contains a function (B), which itself contains a function (C).
Both functions B and C form closures here. So, B can access A, and C can access B.
In addition, since C can access B which can access A, C can also access A.

Thus, the closures can contain multiple scopes; they recursively contain the scope of the functions containing it. This is called scope chaining. Consider the following example:
jsfunction A(x) {
  function B(y) {
    function C(z) {
      console.log(x + y + z);
    }
    C(3);
  }
  B(2);
}
A(1); // Logs 6 (which is 1 + 2 + 3)

In this example, C accesses B's y and A's x. This can be done because:

B forms a closure including A (i.e., B can access A's arguments and variables).
C forms a closure including B.
Because C's closure includes B and B's closure includes A, then C's closure also includes A. This means C can access both B and A's arguments and variables. In other words, C chains the scopes of B and A, in that order.

The reverse, however, is not true. A cannot access C, because A cannot access any argument or variable of B, which C is a variable of. Thus, C remains private to only B.Name conflictsWhen two arguments or variables in the scopes of a closure have the same name, there is a name conflict. More nested scopes take precedence. So, the innermost scope takes the highest precedence, while the outermost scope takes the lowest. This is the scope chain. The first on the chain is the innermost scope, and the last is the outermost scope. Consider the following:
jsfunction outside() {
  const x = 5;
  function inside(x) {
    return x * 2;
  }
  return inside;
}

console.log(outside()(10)); // 20 (instead of 10)

The name conflict happens at the statement return x * 2 and is between inside's parameter x and outside's variable x. The scope chain here is inside => outside => global object. Therefore, inside's x takes precedences over outside's x, and 20 (inside's x) is returned instead of 10 (outside's x).Using the arguments objectThe arguments of a function are maintained in an array-like object. Within a function, you can address the arguments passed to it as follows:
jsarguments[i];

where i is the ordinal number of the argument, starting at 0. So, the first argument passed to a function would be arguments[0]. The total number of arguments is indicated by arguments.length.
Using the arguments object, you can call a function with more arguments than it is formally declared to accept. This is often useful if you don't know in advance how many arguments will be passed to the function. You can use arguments.length to determine the number of arguments actually passed to the function, and then access each argument using the arguments object.
For example, consider a function that concatenates several strings. The only formal argument for the function is a string that specifies the characters that separate the items to concatenate. The function is defined as follows:
jsfunction myConcat(separator) {
  let result = ""; // initialize list
  // iterate through arguments
  for (let i = 1; i < arguments.length; i++) {
    result += arguments[i] + separator;
  }
  return result;
}

You can pass any number of arguments to this function, and it concatenates each argument into a string "list":
jsconsole.log(myConcat(", ", "red", "orange", "blue"));
// "red, orange, blue, "

console.log(myConcat("; ", "elephant", "giraffe", "lion", "cheetah"));
// "elephant; giraffe; lion; cheetah; "

console.log(myConcat(". ", "sage", "basil", "oregano", "pepper", "parsley"));
// "sage. basil. oregano. pepper. parsley. "


Note:
The arguments variable is "array-like", but not an array. It is array-like in that it has a numbered index and a length property. However, it does not possess all of the array-manipulation methods.

See the Function object in the JavaScript reference for more information.Function parametersThere are two special kinds of parameter syntax: default parameters and rest parameters.Default parametersIn JavaScript, parameters of functions default to undefined. However, in some situations it might be useful to set a different default value. This is exactly what default parameters do.
In the past, the general strategy for setting defaults was to test parameter values in the body of the function and assign a value if they are undefined.
In the following example, if no value is provided for b, its value would be undefined when evaluating a*b, and a call to multiply would normally have returned NaN. However, this is prevented by the second line in this example:
jsfunction multiply(a, b) {
  b = typeof b !== "undefined" ? b : 1;
  return a * b;
}

console.log(multiply(5)); // 5

With default parameters, a manual check in the function body is no longer necessary. You can put 1 as the default value for b in the function head:
jsfunction multiply(a, b = 1) {
  return a * b;
}

console.log(multiply(5)); // 5

For more details, see default parameters in the reference.Rest parametersThe rest parameter syntax allows us to represent an indefinite number of arguments as an array.
In the following example, the function multiply uses rest parameters to collect arguments from the second one to the end. The function then multiplies these by the first argument.
jsfunction multiply(multiplier, ...theArgs) {
  return theArgs.map((x) => multiplier * x);
}

const arr = multiply(2, 1, 2, 3);
console.log(arr); // [2, 4, 6]
Arrow functionsAn arrow function expression (also called a fat arrow to distinguish from a hypothetical -> syntax in future JavaScript) has a shorter syntax compared to function expressions and does not have its own this, arguments, super, or new.target. Arrow functions are always anonymous.
Two factors influenced the introduction of arrow functions: shorter functions and non-binding of this.Shorter functionsIn some functional patterns, shorter functions are welcome. Compare:
jsconst a = ["Hydrogen", "Helium", "Lithium", "Beryllium"];

const a2 = a.map(function (s) {
  return s.length;
});

console.log(a2); // [8, 6, 7, 9]

const a3 = a.map((s) => s.length);

console.log(a3); // [8, 6, 7, 9]
No separate thisUntil arrow functions, every new function defined its own this value (a new object in the case of a constructor, undefined in strict mode function calls, the base object if the function is called as an "object method", etc.). This proved to be less than ideal with an object-oriented style of programming.
jsfunction Person() {
  // The Person() constructor defines `this` as itself.
  this.age = 0;

  setInterval(function growUp() {
    // In nonstrict mode, the growUp() function defines `this`
    // as the global object, which is different from the `this`
    // defined by the Person() constructor.
    this.age++;
  }, 1000);
}

const p = new Person();

In ECMAScript 3/5, this issue was fixed by assigning the value in this to a variable that could be closed over.
jsfunction Person() {
  // Some choose `that` instead of `self`.
  // Choose one and be consistent.
  const self = this;
  self.age = 0;

  setInterval(function growUp() {
    // The callback refers to the `self` variable of which
    // the value is the expected object.
    self.age++;
  }, 1000);
}

Alternatively, a bound function could be created so that the proper this value would be passed to the growUp() function.
An arrow function does not have its own this; the this value of the enclosing execution context is used. Thus, in the following code, the this within the function that is passed to setInterval has the same value as this in the enclosing function:
jsfunction Person() {
  this.age = 0;

  setInterval(() => {
    this.age++; // `this` properly refers to the person object
  }, 1000);
}

const p = new Person();

 Previous  Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 22, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nFunctions 
 Previous  Next  
Functions are one of the fundamental building blocks in JavaScript. A function in JavaScript is similar to a procedure—a set of statements that performs a task or calculates a value, but for a procedure to qualify as a function, it should take some input and return an output where there is some obvious relationship between the input and the output. To use a function, you must define it somewhere in the scope from which you wish to call it.
See also the exhaustive reference chapter about JavaScript functions to get to know the details.Defining functionsFunction declarationsA function definition (also called a function declaration, or function statement) consists of the function keyword, followed by:

The name of the function.
A list of parameters to the function, enclosed in parentheses and separated by commas.
The JavaScript statements that define the function, enclosed in curly braces, { /* … */ }.

For example, the following code defines a function named square:
jsfunction square(number) {
  return number * number;
}

The function square takes one parameter, called number. The function consists of one statement that says to return the parameter of the function (that is, number) multiplied by itself. The return statement specifies the value returned by the function, which is number * number.
Parameters are essentially passed to functions by value — so if the code within the body of a function assigns a completely new value to a parameter that was passed to the function, the change is not reflected globally or in the code which called that function.
When you pass an object as a parameter, if the function changes the object's properties, that change is visible outside the function, as shown in the following example:
jsfunction myFunc(theObject) {
  theObject.make = "Toyota";
}

const myCar = {
  make: "Honda",
  model: "Accord",
  year: 1998,
};

console.log(myCar.make); // "Honda"
myFunc(myCar);
console.log(myCar.make); // "Toyota"

When you pass an array as a parameter, if the function changes any of the array's values, that change is visible outside the function, as shown in the following example:
jsfunction myFunc(theArr) {
  theArr[0] = 30;
}

const arr = [45];

console.log(arr[0]); // 45
myFunc(arr);
console.log(arr[0]); // 30

Function declarations and expressions can be nested, which forms a scope chain. For example:
jsfunction addSquares(a, b) {
  function square(x) {
    return x * x;
  }
  return square(a) + square(b);
}

See function scopes and closures for more information.Function expressionsWhile the function declaration above is syntactically a statement, functions can also be created by a function expression.
Such a function can be anonymous; it does not have to have a name. For example, the function square could have been defined as:
jsconst square = function (number) {
  return number * number;
};

console.log(square(4)); // 16

However, a name can be provided with a function expression. Providing a name allows the function to refer to itself, and also makes it easier to identify the function in a debugger's stack traces:
jsconst factorial = function fac(n) {
  return n < 2 ? 1 : n * fac(n - 1);
};

console.log(factorial(3)); // 6

Function expressions are convenient when passing a function as an argument to another function. The following example defines a map function that should receive a function as first argument and an array as second argument. Then, it is called with a function defined by a function expression:
jsfunction map(f, a) {
  const result = new Array(a.length);
  for (let i = 0; i < a.length; i++) {
    result[i] = f(a[i]);
  }
  return result;
}

const numbers = [0, 1, 2, 5, 10];
const cubedNumbers = map(function (x) {
  return x * x * x;
}, numbers);
console.log(cubedNumbers); // [0, 1, 8, 125, 1000]

In JavaScript, a function can be defined based on a condition. For example, the following function definition defines myFunc only if num equals 0:
jslet myFunc;
if (num === 0) {
  myFunc = function (theObject) {
    theObject.make = "Toyota";
  };
}

In addition to defining functions as described here, you can also use the Function constructor to create functions from a string at runtime, much like eval().
A method is a function that is a property of an object. Read more about objects and methods in Working with objects.Calling functionsDefining a function does not execute it. Defining it names the function and specifies what to do when the function is called.
Calling the function actually performs the specified actions with the indicated parameters. For example, if you define the function square, you could call it as follows:
jssquare(5);

The preceding statement calls the function with an argument of 5. The function executes its statements and returns the value 25.
Functions must be in scope when they are called, but the function declaration can be hoisted (appear below the call in the code). The scope of a function declaration is the function in which it is declared (or the entire program, if it is declared at the top level).
The arguments of a function are not limited to strings and numbers. You can pass whole objects to a function. The showProps() function (defined in Working with objects) is an example of a function that takes an object as an argument.
A function can call itself. For example, here is a function that computes factorials recursively:
jsfunction factorial(n) {
  if (n === 0 || n === 1) {
    return 1;
  } else {
    return n * factorial(n - 1);
  }
}

You could then compute the factorials of 1 through 5 as follows:
jsconsole.log(factorial(1)); // 1
console.log(factorial(2)); // 2
console.log(factorial(3)); // 6
console.log(factorial(4)); // 24
console.log(factorial(5)); // 120

There are other ways to call functions. There are often cases where a function needs to be called dynamically, or the number of arguments to a function vary, or in which the context of the function call needs to be set to a specific object determined at runtime.
It turns out that functions are themselves objects — and in turn, these objects have methods. (See the Function object.) The call() and apply() methods can be used to achieve this goal.Function hoistingConsider the example below:
jsconsole.log(square(5)); // 25

function square(n) {
  return n * n;
}

This code runs without any error, despite the square() function being called before it's declared. This is because the JavaScript interpreter hoists the entire function declaration to the top of the current scope, so the code above is equivalent to:
js// All function declarations are effectively at the top of the scope
function square(n) {
  return n * n;
}

console.log(square(5)); // 25

Function hoisting only works with function declarations — not with function expressions. The following code will not work:
jsconsole.log(square(5)); // ReferenceError: Cannot access 'square' before initialization
const square = function (n) {
  return n * n;
};
RecursionA function can refer to and call itself. It can be referred to either by the function expression or declaration's name, or via any in-scope variable that refers to the function object. For example, consider the following function definition:
jsconst foo = function bar() {
  // statements go here
};

Within the function body, you can refer to the function itself either as bar or foo, and call itself using bar() or foo().
A function that calls itself is called a recursive function. In some ways, recursion is analogous to a loop. Both execute the same code multiple times, and both require a condition (to avoid an infinite loop, or rather, infinite recursion in this case).
For example, consider the following loop:
jslet x = 0;
// "x < 10" is the loop condition
while (x < 10) {
  // do stuff
  x++;
}

It can be converted into a recursive function declaration, followed by a call to that function:
jsfunction loop(x) {
  // "x >= 10" is the exit condition (equivalent to "!(x < 10)")
  if (x >= 10) {
    return;
  }
  // do stuff
  loop(x + 1); // the recursive call
}
loop(0);

However, some algorithms cannot be simple iterative loops. For example, getting all the nodes of a tree structure (such as the DOM) is easier via recursion:
jsfunction walkTree(node) {
  if (node === null) {
    return;
  }
  // do something with node
  for (let i = 0; i < node.childNodes.length; i++) {
    walkTree(node.childNodes[i]);
  }
}

Compared to the function loop, each recursive call itself makes many recursive calls here.
It is possible to convert any recursive algorithm to a non-recursive one, but the logic is often much more complex, and doing so requires the use of a stack.
In fact, recursion itself uses a stack: the function stack. The stack-like behavior can be seen in the following example:
jsfunction foo(i) {
  if (i < 0) {
    return;
  }
  console.log(`begin: ${i}`);
  foo(i - 1);
  console.log(`end: ${i}`);
}
foo(3);

// Logs:
// begin: 3
// begin: 2
// begin: 1
// begin: 0
// end: 0
// end: 1
// end: 2
// end: 3
Immediately Invoked Function Expressions (IIFE)An Immediately Invoked Function Expression (IIFE) is a code pattern that directly calls a function defined as an expression. It looks like this:
js(function () {
  // Do something
})();

const value = (function () {
  // Do something
  return someValue;
})();

Instead of saving the function in a variable, the function is immediately invoked. This is almost equivalent to just writing the function body, but there are a few unique benefits:

It creates an extra scope of variables, which helps to confine variables to the place where they are useful.
It is now an expression instead of a sequence of statements. This allows you to write complex computation logic when initializing variables.

For more information, see the IIFE glossary entry.Function scopes and closuresFunctions form a scope for variables—this means variables defined inside a function cannot be accessed from anywhere outside the function. The function scope inherits from all the upper scopes. For example, a function defined in the global scope can access all variables defined in the global scope. A function defined inside another function can also access all variables defined in its parent function, and any other variables to which the parent function has access. On the other hand, the parent function (and any other parent scope) does not have access to the variables and functions defined inside the inner function. This provides a sort of encapsulation for the variables in the inner function.
js// The following variables are defined in the global scope
const num1 = 20;
const num2 = 3;
const name = "Chamakh";

// This function is defined in the global scope
function multiply() {
  return num1 * num2;
}

console.log(multiply()); // 60

// A nested function example
function getScore() {
  const num1 = 2;
  const num2 = 3;

  function add() {
    return `${name} scored ${num1 + num2}`;
  }

  return add();
}

console.log(getScore()); // "Chamakh scored 5"
ClosuresWe also refer to the function body as a closure. A closure is any piece of source code (most commonly, a function) that refers to some variables, and the closure "remembers" these variables even when the scope in which these variables were declared has exited.
Closures are usually illustrated with nested functions to show that they remember variables beyond the lifetime of its parent scope; but in fact, nested functions are unnecessary. Technically speaking, all functions in JavaScript form closures—some just don't capture anything, and closures don't even have to be functions. The key ingredients for a useful closure are the following:

A parent scope that defines some variables or functions. It should have a clear lifetime, which means it should finish execution at some point. Any scope that's not the global scope satisfies this requirement; this includes blocks, functions, modules, and more.
An inner scope defined within the parent scope, which refers to some variables or functions defined in the parent scope.
The inner scope manages to survive beyond the lifetime of the parent scope. For example, it is saved to a variable that's defined outside the parent scope, or it's returned from the parent scope (if the parent scope is a function).
Then, when you call the function outside of the parent scope, you can still access the variables or functions that were defined in the parent scope, even though the parent scope has finished execution.

The following is a typical example of a closure:
js// The outer function defines a variable called "name"
const pet = function (name) {
  const getName = function () {
    // The inner function has access to the "name" variable of the outer function
    return name;
  };
  return getName; // Return the inner function, thereby exposing it to outer scopes
};
const myPet = pet("Vivie");

console.log(myPet()); // "Vivie"

It can be much more complex than the code above. An object containing methods for manipulating the inner variables of the outer function can be returned.
jsconst createPet = function (name) {
  let sex;

  const pet = {
    // setName(newName) is equivalent to setName: function (newName)
    // in this context
    setName(newName) {
      name = newName;
    },

    getName() {
      return name;
    },

    getSex() {
      return sex;
    },

    setSex(newSex) {
      if (
        typeof newSex === "string" &&
        (newSex.toLowerCase() === "male" || newSex.toLowerCase() === "female")
      ) {
        sex = newSex;
      }
    },
  };

  return pet;
};

const pet = createPet("Vivie");
console.log(pet.getName()); // Vivie

pet.setName("Oliver");
pet.setSex("male");
console.log(pet.getSex()); // male
console.log(pet.getName()); // Oliver

In the code above, the name variable of the outer function is accessible to the inner functions, and there is no other way to access the inner variables except through the inner functions. The inner variables of the inner functions act as safe stores for the outer arguments and variables. They hold "persistent" and "encapsulated" data for the inner functions to work with. The functions do not even have to be assigned to a variable, or have a name.
jsconst getCode = (function () {
  const apiCode = "0]Eal(eh&2"; // A code we do not want outsiders to be able to modify…

  return function () {
    return apiCode;
  };
})();

console.log(getCode()); // "0]Eal(eh&2"

In the code above, we use the IIFE pattern. Within this IIFE scope, two values exist: a variable apiCode and an unnamed function that gets returned and gets assigned to the variable getCode. apiCode is in the scope of the returned unnamed function but not in the scope of any other part of the program, so there is no way for reading the value of apiCode apart from via the getCode function.Multiply-nested functionsFunctions can be multiply-nested. For example:

A function (A) contains a function (B), which itself contains a function (C).
Both functions B and C form closures here. So, B can access A, and C can access B.
In addition, since C can access B which can access A, C can also access A.

Thus, the closures can contain multiple scopes; they recursively contain the scope of the functions containing it. This is called scope chaining. Consider the following example:
jsfunction A(x) {
  function B(y) {
    function C(z) {
      console.log(x + y + z);
    }
    C(3);
  }
  B(2);
}
A(1); // Logs 6 (which is 1 + 2 + 3)

In this example, C accesses B's y and A's x. This can be done because:

B forms a closure including A (i.e., B can access A's arguments and variables).
C forms a closure including B.
Because C's closure includes B and B's closure includes A, then C's closure also includes A. This means C can access both B and A's arguments and variables. In other words, C chains the scopes of B and A, in that order.

The reverse, however, is not true. A cannot access C, because A cannot access any argument or variable of B, which C is a variable of. Thus, C remains private to only B.Name conflictsWhen two arguments or variables in the scopes of a closure have the same name, there is a name conflict. More nested scopes take precedence. So, the innermost scope takes the highest precedence, while the outermost scope takes the lowest. This is the scope chain. The first on the chain is the innermost scope, and the last is the outermost scope. Consider the following:
jsfunction outside() {
  const x = 5;
  function inside(x) {
    return x * 2;
  }
  return inside;
}

console.log(outside()(10)); // 20 (instead of 10)

The name conflict happens at the statement return x * 2 and is between inside's parameter x and outside's variable x. The scope chain here is inside => outside => global object. Therefore, inside's x takes precedences over outside's x, and 20 (inside's x) is returned instead of 10 (outside's x).Using the arguments objectThe arguments of a function are maintained in an array-like object. Within a function, you can address the arguments passed to it as follows:
jsarguments[i];

where i is the ordinal number of the argument, starting at 0. So, the first argument passed to a function would be arguments[0]. The total number of arguments is indicated by arguments.length.
Using the arguments object, you can call a function with more arguments than it is formally declared to accept. This is often useful if you don't know in advance how many arguments will be passed to the function. You can use arguments.length to determine the number of arguments actually passed to the function, and then access each argument using the arguments object.
For example, consider a function that concatenates several strings. The only formal argument for the function is a string that specifies the characters that separate the items to concatenate. The function is defined as follows:
jsfunction myConcat(separator) {
  let result = ""; // initialize list
  // iterate through arguments
  for (let i = 1; i < arguments.length; i++) {
    result += arguments[i] + separator;
  }
  return result;
}

You can pass any number of arguments to this function, and it concatenates each argument into a string "list":
jsconsole.log(myConcat(", ", "red", "orange", "blue"));
// "red, orange, blue, "

console.log(myConcat("; ", "elephant", "giraffe", "lion", "cheetah"));
// "elephant; giraffe; lion; cheetah; "

console.log(myConcat(". ", "sage", "basil", "oregano", "pepper", "parsley"));
// "sage. basil. oregano. pepper. parsley. "


Note:
The arguments variable is "array-like", but not an array. It is array-like in that it has a numbered index and a length property. However, it does not possess all of the array-manipulation methods.

See the Function object in the JavaScript reference for more information.Function parametersThere are two special kinds of parameter syntax: default parameters and rest parameters.Default parametersIn JavaScript, parameters of functions default to undefined. However, in some situations it might be useful to set a different default value. This is exactly what default parameters do.
In the past, the general strategy for setting defaults was to test parameter values in the body of the function and assign a value if they are undefined.
In the following example, if no value is provided for b, its value would be undefined when evaluating a*b, and a call to multiply would normally have returned NaN. However, this is prevented by the second line in this example:
jsfunction multiply(a, b) {
  b = typeof b !== "undefined" ? b : 1;
  return a * b;
}

console.log(multiply(5)); // 5

With default parameters, a manual check in the function body is no longer necessary. You can put 1 as the default value for b in the function head:
jsfunction multiply(a, b = 1) {
  return a * b;
}

console.log(multiply(5)); // 5

For more details, see default parameters in the reference.Rest parametersThe rest parameter syntax allows us to represent an indefinite number of arguments as an array.
In the following example, the function multiply uses rest parameters to collect arguments from the second one to the end. The function then multiplies these by the first argument.
jsfunction multiply(multiplier, ...theArgs) {
  return theArgs.map((x) => multiplier * x);
}

const arr = multiply(2, 1, 2, 3);
console.log(arr); // [2, 4, 6]
Arrow functionsAn arrow function expression (also called a fat arrow to distinguish from a hypothetical -> syntax in future JavaScript) has a shorter syntax compared to function expressions and does not have its own this, arguments, super, or new.target. Arrow functions are always anonymous.
Two factors influenced the introduction of arrow functions: shorter functions and non-binding of this.Shorter functionsIn some functional patterns, shorter functions are welcome. Compare:
jsconst a = ["Hydrogen", "Helium", "Lithium", "Beryllium"];

const a2 = a.map(function (s) {
  return s.length;
});

console.log(a2); // [8, 6, 7, 9]

const a3 = a.map((s) => s.length);

console.log(a3); // [8, 6, 7, 9]
No separate thisUntil arrow functions, every new function defined its own this value (a new object in the case of a constructor, undefined in strict mode function calls, the base object if the function is called as an "object method", etc.). This proved to be less than ideal with an object-oriented style of programming.
jsfunction Person() {
  // The Person() constructor defines `this` as itself.
  this.age = 0;

  setInterval(function growUp() {
    // In nonstrict mode, the growUp() function defines `this`
    // as the global object, which is different from the `this`
    // defined by the Person() constructor.
    this.age++;
  }, 1000);
}

const p = new Person();

In ECMAScript 3/5, this issue was fixed by assigning the value in this to a variable that could be closed over.
jsfunction Person() {
  // Some choose `that` instead of `self`.
  // Choose one and be consistent.
  const self = this;
  self.age = 0;

  setInterval(function growUp() {
    // The callback refers to the `self` variable of which
    // the value is the expected object.
    self.age++;
  }, 1000);
}

Alternatively, a bound function could be created so that the proper this value would be passed to the growUp() function.
An arrow function does not have its own this; the this value of the enclosing execution context is used. Thus, in the following code, the this within the function that is passed to setInterval has the same value as this in the enclosing function:
jsfunction Person() {
  this.age = 0;

  setInterval(() => {
    this.age++; // `this` properly refers to the person object
  }, 1000);
}

const p = new Person();

 Previous  Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 22, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nExpressions and operators 
 Previous  Next  
This chapter describes JavaScript's expressions and operators, including assignment, comparison, arithmetic, bitwise, logical, string, ternary and more.
At a high level, an expression is a valid unit of code that resolves to a value. There are two types of expressions: those that have side effects (such as assigning values) and those that purely evaluate.
The expression x = 7 is an example of the first type. This expression uses the = operator to assign the value seven to the variable x. The expression itself evaluates to 7.
The expression 3 + 4 is an example of the second type. This expression uses the + operator to add 3 and 4 together and produces a value, 7. However, if it's not eventually part of a bigger construct (for example, a variable declaration like const z = 3 + 4), its result will be immediately discarded — this is usually a programmer mistake because the evaluation doesn't produce any effects.
As the examples above also illustrate, all complex expressions are joined by operators, such as = and +. In this section, we will introduce the following operators:

Assignment operators
Comparison operators
Arithmetic operators
Bitwise operators
Logical operators
BigInt operators
String operators
Conditional (ternary) operator
Comma operator
Unary operators
Relational operators

These operators join operands either formed by higher-precedence operators or one of the basic expressions. A complete and detailed list of operators and expressions is also available in the reference.
The precedence of operators determines the order they are applied when evaluating an expression. For example:
jsconst x = 1 + 2 * 3;
const y = 2 * 3 + 1;

Despite * and + coming in different orders, both expressions would result in 7 because * has precedence over +, so the *-joined expression will always be evaluated first. You can override operator precedence by using parentheses (which creates a grouped expression — the basic expression). To see a complete table of operator precedence as well as various caveats, see the Operator Precedence Reference page.
JavaScript has both binary and unary operators, and one special ternary operator, the conditional operator.
A binary operator requires two operands, one before the operator and one after the operator:
operand1 operator operand2

For example, 3 + 4 or x * y. This form is called an infix binary operator, because the operator is placed between two operands. All binary operators in JavaScript are infix.
A unary operator requires a single operand, either before or after the operator:
operator operand
operand operator

For example, x++ or ++x. The operator operand form is called a prefix unary operator, and the operand operator form is called a postfix unary operator. ++ and -- are the only postfix operators in JavaScript — all other operators, like !, typeof, etc. are prefix.Assignment operatorsAn assignment operator assigns a value to its left operand based on the value of its right operand.
The simple assignment operator is equal (=), which assigns the value of its right operand to its left operand.
That is, x = f() is an assignment expression that assigns the value of f() to x.
There are also compound assignment operators that are shorthand for the operations listed in the following table:



Name
Shorthand operator
Meaning




Assignment
x = f()
x = f()


Addition assignment
x += f()
x = x + f()


Subtraction assignment
x -= f()
x = x - f()


Multiplication assignment
x *= f()
x = x * f()


Division assignment
x /= f()
x = x / f()


Remainder assignment
x %= f()
x = x % f()


Exponentiation assignment
x **= f()
x = x ** f()


Left shift assignment
x <<= f()
x = x << f()


Right shift assignment
x >>= f()
x = x >> f()


Unsigned right shift assignment
x >>>= f()
x = x >>> f()


Bitwise AND assignment
x &= f()
x = x & f()


Bitwise XOR assignment
x ^= f()
x = x ^ f()


Bitwise OR assignment
x |= f()
x = x | f()


Logical AND assignment
x &&= f()
x && (x = f())


Logical OR assignment
x ||= f()
x || (x = f())


Nullish coalescing assignment
x ??= f()
x ?? (x = f())


Assigning to propertiesIf an expression evaluates to an object, then the left-hand side of an assignment expression may make assignments to properties of that expression.
For example:
jsconst obj = {};

obj.x = 3;
console.log(obj.x); // Prints 3.
console.log(obj); // Prints { x: 3 }.

const key = "y";
obj[key] = 5;
console.log(obj[key]); // Prints 5.
console.log(obj); // Prints { x: 3, y: 5 }.

For more information about objects, read Working with Objects.
If an expression does not evaluate to an object, then assignments to properties of that expression do not assign:
jsconst val = 0;
val.x = 3;

console.log(val.x); // Prints undefined.
console.log(val); // Prints 0.

In strict mode, the code above throws, because one cannot assign properties to primitives.
It is an error to assign values to unmodifiable properties or to properties of an expression without properties (null or undefined).DestructuringFor more complex assignments, the destructuring syntax is a JavaScript expression that makes it possible to extract data from arrays or objects using a syntax that mirrors the construction of array and
object literals.
Without destructuring, it takes multiple statements to extract values from arrays and objects:
jsconst foo = ["one", "two", "three"];

const one = foo[0];
const two = foo[1];
const three = foo[2];

With destructuring, you can extract multiple values into distinct variables using a single statement:
jsconst [one, two, three] = foo;
Evaluation and nestingIn general, assignments are used within a variable declaration (i.e., with const, let, or var) or as standalone statements.
js// Declares a variable x and initializes it to the result of f().
// The result of the x = f() assignment expression is discarded.
let x = f();

x = g(); // Reassigns the variable x to the result of g().

However, like other expressions, assignment expressions like x = f() evaluate into a result value.
Although this result value is usually not used, it can then be used by another expression.
Chaining assignments or nesting assignments in other expressions can result in surprising behavior.
For this reason, some JavaScript style guides discourage chaining or nesting assignments.
Nevertheless, assignment chaining and nesting may occur sometimes, so it is important to be able to understand how they work.
By chaining or nesting an assignment expression, its result can itself be assigned to another variable.
It can be logged, it can be put inside an array literal or function call, and so on.
jslet x;
const y = (x = f()); // Or equivalently: const y = x = f();
console.log(y); // Logs the return value of the assignment x = f().

console.log(x = f()); // Logs the return value directly.

// An assignment expression can be nested in any place
// where expressions are generally allowed,
// such as array literals' elements or as function calls' arguments.
console.log([0, x = f(), 0]);
console.log(f(0, x = f(), 0));

The evaluation result matches the expression to the right of the = sign in the
"Meaning" column of the table above. That means that x = f() evaluates into
whatever f()'s result is, x += f() evaluates into the resulting sum x + f(),
x **= f() evaluates into the resulting power x ** f(), and so on.
In the case of logical assignments, x &&= f(),
x ||= f(), and x ??= f(), the return value is that of the
logical operation without the assignment, so x && f(),
x || f(), and x ?? f(), respectively.
When chaining these expressions without parentheses or other grouping operators
like array literals, the assignment expressions are grouped right to left
(they are right-associative), but they are evaluated left to right.
Note that, for all assignment operators other than = itself,
the resulting values are always based on the operands' values before
the operation.
For example, assume that the following functions f and g
and the variables x and y have been declared:
jsfunction f() {
  console.log("F!");
  return 2;
}
function g() {
  console.log("G!");
  return 3;
}
let x, y;

Consider these three examples:
jsy = x = f();
y = [f(), x = g()];
x[f()] = g();

Evaluation example 1
y = x = f() is equivalent to y = (x = f()),
because the assignment operator = is right-associative.
However, it evaluates from left to right:

The assignment expression y = x = f() starts to evaluate.

The y on this assignment's left-hand side evaluates
into a reference to the variable named y.
The assignment expression x = f() starts to evaluate.

The x on this assignment's left-hand side evaluates
into a reference to the variable named x.
The function call f() prints "F!" to the console and
then evaluates to the number 2.
That 2 result from f() is assigned to x.


The assignment expression x = f() has now finished evaluating;
its result is the new value of x, which is 2.
That 2 result in turn is also assigned to y.


The assignment expression y = x = f() has now finished evaluating;
its result is the new value of y – which happens to be 2.
x and y are assigned to 2,
and the console has printed "F!".

Evaluation example 2
y = [ f(), x = g() ] also evaluates from left to right:

The assignment expression y = [ f(), x = g() ] starts to evaluate.

The y on this assignment's left-hand evaluates
into a reference to the variable named y.
The inner array literal [ f(), x = g() ] starts to evaluate.

The function call f() prints "F!" to the console and
then evaluates to the number 2.
The assignment expression x = g() starts to evaluate.

The x on this assignment's left-hand side evaluates
into a reference to the variable named x.
The function call g() prints "G!" to the console and
then evaluates to the number 3.
That 3 result from g() is assigned to x.


The assignment expression x = g() has now finished evaluating;
its result is the new value of x, which is 3.
That 3 result becomes the next element
in the inner array literal (after the 2 from the f()).


The inner array literal [ f(), x = g() ]
has now finished evaluating;
its result is an array with two values: [ 2, 3 ].
That [ 2, 3 ] array is now assigned to y.


The assignment expression y = [ f(), x = g() ] has
now finished evaluating;
its result is the new value of y – which happens to be [ 2, 3 ].
x is now assigned to 3,
y is now assigned to [ 2, 3 ],
and the console has printed "F!" then "G!".

Evaluation example 3
x[f()] = g() also evaluates from left to right.
(This example assumes that x is already assigned to some object.
For more information about objects, read Working with Objects.)

The assignment expression x[f()] = g() starts to evaluate.

The x[f()] property access on this assignment's left-hand
starts to evaluate.

The x in this property access evaluates
into a reference to the variable named x.
Then the function call f() prints "F!" to the console and
then evaluates to the number 2.


The x[f()] property access on this assignment
has now finished evaluating;
its result is a variable property reference: x[2].
Then the function call g() prints "G!" to the console and
then evaluates to the number 3.
That 3 is now assigned to x[2].
(This step will succeed only if x is assigned to an object.)


The assignment expression x[f()] = g() has now finished evaluating;
its result is the new value of x[2] – which happens to be 3.
x[2] is now assigned to 3,
and the console has printed "F!" then "G!".
Avoid assignment chainsChaining assignments or nesting assignments in other expressions can
result in surprising behavior. For this reason,
chaining assignments in the same statement is discouraged.
In particular, putting a variable chain in a const, let, or var statement often does not work. Only the outermost/leftmost variable would get declared; other variables within the assignment chain are not declared by the const/let/var statement.
For example:
jsconst z = y = x = f();

This statement seemingly declares the variables x, y, and z.
However, it only actually declares the variable z.
y and x are either invalid references to nonexistent variables (in strict mode) or, worse, would implicitly create global variables for x and y in sloppy mode.Comparison operatorsA comparison operator compares its operands and returns a logical value based on whether the comparison is true.
The operands can be numerical, string, logical, or object values.
Strings are compared based on standard lexicographical ordering, using Unicode values.
In most cases, if the two operands are not of the same type, JavaScript attempts to convert them to an appropriate type for the comparison.
This behavior generally results in comparing the operands numerically.
The sole exceptions to type conversion within comparisons involve the === and !== operators, which perform strict equality and inequality comparisons.
These operators do not attempt to convert the operands to compatible types before checking equality.
The following table describes the comparison operators in terms of this sample code:
jsconst var1 = 3;
const var2 = 4;


  
    Comparison operators
  
  
    
      Operator
      Description
      Examples returning true
    
  
  
    
      
        Equal (==)
      
      Returns true if the operands are equal.
      
        3 == var1
        "3" == var1
        3 == '3'
      
    
    
      
        Not equal (!=)
      
      Returns true if the operands are not equal.
      
        var1 != 4var2 != "3"
      
    
    
      
        Strict equal (===)
      
      
        Returns true if the operands are equal and of the same
        type. See also Object.is and
        sameness in JS.
      
      3 === var1
    
    
      
        Strict not equal (!==)
      
      
        Returns true if the operands are of the same type but not equal, or are of different type.
      
      
        var1 !== "3"3 !== '3'
      
    
    
      
        Greater than (>)
      
      
        Returns true if the left operand is greater than the right operand.
      
      
        var2 > var1"12" > 2
      
    
    
      
        Greater than or equal
        (>=)
      
      
        Returns true if the left operand is greater than or equal to the right operand.
      
      
        var2 >= var1var1 >= 3
      
    
    
      
        Less than
        (<)
      
      
        Returns true if the left operand is less than the right operand.
      
      
        var1 < var2"2" < 12
      
    
    
      
        Less than or equal
        (<=)
      
      
        Returns true if the left operand is less than or equal to the right operand.
      
      
        var1 <= var2var2 <= 5
      
    
  


Note: => is not a comparison operator but rather is the notation
for Arrow functions.
Arithmetic operatorsAn arithmetic operator takes numerical values (either literals or variables) as their operands and returns a single numerical value.
The standard arithmetic operators are addition (+), subtraction (-), multiplication (*), and division (/).
These operators work as they do in most other programming languages when used with floating point numbers (in particular, note that division by zero produces Infinity). For example:
js1 / 2; // 0.5
1 / 2 === 1.0 / 2.0; // this is true

In addition to the standard arithmetic operations (+, -, *, /), JavaScript provides the arithmetic operators listed in the following table:

  
    Arithmetic operators
  
  
    
      Operator
      Description
      Example
    
  
  
    
      
        Remainder (%)
      
      
        Binary operator. Returns the integer remainder of dividing the two operands.
      
      12 % 5 returns 2.
    
    
      
        Increment (++)
      
      
        Unary operator. Adds one to its operand. If used as a prefix operator
        (++x), returns the value of its operand after adding one;
        if used as a postfix operator (x++), returns the value of
        its operand before adding one.
      
      
        If x is 3, then ++x sets x to 4
        and returns 4, whereas x++ returns 3 and, only then, sets x to 4.
      
    
    
      
        Decrement (--)
      
      
        Unary operator. Subtracts one from its operand.
        The return value is analogous to that for the increment operator.
      
      
        If x is 3, then --x sets x to 2
        and returns 2, whereas x-- returns 3 and, only then, sets x to 2.
      
    
    
      
        Unary negation (-)
      
      Unary operator. Returns the negation of its operand.
      If x is 3, then -x returns -3.
    
    
      
        Unary plus (+)
      
      
        Unary operator. Attempts to convert the operand to a number, if it is not already.
      
      
        +"3" returns 3.
        +true returns 1.
      
    
    
      
        Exponentiation operator (**)
      
      
        Calculates the base to the exponent power,
        that is, base^exponent
      
      
        2 ** 3 returns 8.10 ** -1
        returns 0.1.
      
    
  
Bitwise operatorsA bitwise operator treats their operands as a set of 32 bits (zeros and ones), rather
than as decimal, hexadecimal, or octal numbers. For example, the decimal number nine has
a binary representation of 1001. Bitwise operators perform their operations on such
binary representations, but they return standard JavaScript numerical values.
The following table summarizes JavaScript's bitwise operators.



Operator
Usage
Description




Bitwise AND
a & b
Returns a one in each bit position for which the corresponding bits of both operands are ones.


Bitwise OR
a | b
Returns a zero in each bit position for which the corresponding bits of both operands are zeros.


Bitwise XOR
a ^ b
Returns a zero in each bit position for which the corresponding bits are the same. [Returns a one in each bit position for which the corresponding bits are different.]


Bitwise NOT
~ a
Inverts the bits of its operand.


Left shift
a << b
Shifts a in binary representation b bits to the left, shifting in zeros from the right.


Sign-propagating right shift
a >> b
Shifts a in binary representation b bits to the right, discarding bits shifted off.


Zero-fill right shift
a >>> b
Shifts a in binary representation b bits to the right, discarding bits shifted off, and shifting in zeros from the left.


Bitwise logical operatorsConceptually, the bitwise logical operators work as follows:


The operands are converted to thirty-two-bit integers and expressed by a series of bits (zeros and ones).
Numbers with more than 32 bits get their most significant bits discarded.
For example, the following integer with more than 32 bits will be converted to a 32-bit integer:
Before: 1110 0110 1111 1010 0000 0000 0000 0110 0000 0000 0001
After:                 1010 0000 0000 0000 0110 0000 0000 0001



Each bit in the first operand is paired with the corresponding bit in the second operand: first bit to first bit, second bit to second bit, and so on.


The operator is applied to each pair of bits, and the result is constructed bitwise.


For example, the binary representation of nine is 1001, and the binary representation of fifteen is 1111.
So, when the bitwise operators are applied to these values, the results are as follows:



Expression
Result
Binary Description




15 & 9
9
1111 & 1001 = 1001


15 | 9
15
1111 | 1001 = 1111


15 ^ 9
6
1111 ^ 1001 = 0110


~15
-16
~ 0000 0000 … 0000 1111 = 1111 1111 … 1111 0000


~9
-10
~ 0000 0000 … 0000 1001 = 1111 1111 … 1111 0110



Note that all 32 bits are inverted using the Bitwise NOT operator, and that values with
the most significant (left-most) bit set to 1 represent negative numbers
(two's-complement representation). ~x evaluates to the same value that
-x - 1 evaluates to.Bitwise shift operatorsThe bitwise shift operators take two operands: the first is a quantity to be shifted, and the second specifies the number of bit positions by which the first operand is to be
shifted.
The direction of the shift operation is controlled by the operator used.
Shift operators convert their operands to thirty-two-bit integers and return a result of either type Number or BigInt: specifically, if the type
of the left operand is BigInt, they return BigInt;
otherwise, they return Number.
The shift operators are listed in the following table.

  
    Bitwise shift operators
  
  
    
      Operator
      Description
      Example
    
  
  
    
      
        Left shift(<<)
      
      
        This operator shifts the first operand the specified number of bits to
        the left. Excess bits shifted off to the left are discarded. Zero bits
        are shifted in from the right.
      
      
        9<<2 yields 36, because 1001 shifted 2 bits to
        the left becomes 100100, which is 36.
      
    
    
      
        Sign-propagating right shift (>>)
      
      
        This operator shifts the first operand the specified number of bits to
        the right. Excess bits shifted off to the right are discarded. Copies of
        the leftmost bit are shifted in from the left.
      
      
        9>>2 yields 2, because 1001 shifted 2 bits to the right
        becomes 10, which is 2. Likewise, -9>>2 yields -3, because the sign is preserved.
      
    
    
      
        Zero-fill right shift (>>>)
      
      
        This operator shifts the first operand the specified number of bits to
        the right. Excess bits shifted off to the right are discarded. Zero bits
        are shifted in from the left.
      
      
        19>>>2 yields 4, because 10011 shifted 2 bits to the right
        becomes 100, which is 4. For non-negative numbers, zero-fill right shift
        and sign-propagating right shift yield the same result.
      
    
  
Logical operatorsLogical operators are typically used with Boolean (logical) values; when they are, they return a Boolean value.
However, the &&, ||, and ?? operators actually return the value of one of the specified operands, so if these
operators are used with non-Boolean values, they may return a non-Boolean value. As such, they are more adequately called "value selection operators".
The logical operators are described in the following table.

  
    Logical operators
  
  
    
      Operator
      Usage
      Description
    
  
  
    
      
        Logical AND (&&)
      
      expr1 && expr2
      
        Returns expr1 if it can be converted to false;
        otherwise, returns expr2. Thus, when used with Boolean
        values, && returns true if both
        operands are true; otherwise, returns false.
      
    
    
      
        Logical OR (||)
      
      expr1 || expr2
      
        Returns expr1 if it can be converted to true;
        otherwise, returns expr2. Thus, when used with Boolean
        values, || returns true if either operand is
        true; if both are false, returns false.
      
    
    
      
        Nullish coalescing operator (??)
      
      expr1 ?? expr2
      
        Returns expr1 if it is neither null nor
        undefined; otherwise, returns expr2.
      
    
    
      
        Logical NOT (!)
      
      !expr
      
        Returns false if its single operand can be converted
        to true; otherwise, returns true.
      
    
  

Examples of expressions that can be converted to false are those that evaluate to null, 0, 0n, NaN, the empty string (""), or undefined.
The following code shows examples of the && (logical AND) operator.
jsconst a1 = true && true; // t && t returns true
const a2 = true && false; // t && f returns false
const a3 = false && true; // f && t returns false
const a4 = false && 3 === 4; // f && f returns false
const a5 = "Cat" && "Dog"; // t && t returns Dog
const a6 = false && "Cat"; // f && t returns false
const a7 = "Cat" && false; // t && f returns false

The following code shows examples of the || (logical OR) operator.
jsconst o1 = true || true; // t || t returns true
const o2 = false || true; // f || t returns true
const o3 = true || false; // t || f returns true
const o4 = false || 3 === 4; // f || f returns false
const o5 = "Cat" || "Dog"; // t || t returns Cat
const o6 = false || "Cat"; // f || t returns Cat
const o7 = "Cat" || false; // t || f returns Cat

The following code shows examples of the ?? (nullish coalescing) operator.
jsconst n1 = null ?? 1; // 1
const n2 = undefined ?? 2; // 2
const n3 = false ?? 3; // false
const n4 = 0 ?? 4; // 0

Note how ?? works like ||, but it only returns the second expression when the first one is "nullish", i.e., null or undefined. ?? is a better alternative than || for setting defaults for values that might be null or undefined, in particular when values like '' or 0 are valid values and the default should not apply.
The following code shows examples of the ! (logical NOT) operator.
jsconst n1 = !true; // !t returns false
const n2 = !false; // !f returns true
const n3 = !"Cat"; // !t returns false
Short-circuit evaluationAs logical expressions are evaluated left to right, they are tested for possible
"short-circuit" evaluation using the following rules:

falsy && anything is short-circuit evaluated to the falsy value.
truthy || anything is short-circuit evaluated to the truthy value.
nonNullish ?? anything is short-circuit evaluated to the non-nullish value.

The rules of logic guarantee that these evaluations are always correct. Note that the
anything part of the above expressions is not evaluated, so any side effects of
doing so do not take effect.BigInt operatorsMost operators that can be used between numbers can be used between BigInt values as well.
js// BigInt addition
const a = 1n + 2n; // 3n
// Division with BigInts round towards zero
const b = 1n / 2n; // 0n
// Bitwise operations with BigInts do not truncate either side
const c = 40000000000000000n >> 2n; // 10000000000000000n

One exception is unsigned right shift (>>>), which is not defined for BigInt values. This is because a BigInt does not have a fixed width, so technically it does not have a "highest bit".
jsconst d = 8n >>> 2n; // TypeError: BigInts have no unsigned right shift, use >> instead

BigInts and numbers are not mutually replaceable — you cannot mix them in calculations.
jsconst a = 1n + 2; // TypeError: Cannot mix BigInt and other types

This is because BigInt is neither a subset nor a superset of numbers. BigInts have higher precision than numbers when representing large integers, but cannot represent decimals, so implicit conversion on either side might lose precision. Use explicit conversion to signal whether you wish the operation to be a number operation or a BigInt one.
jsconst a = Number(1n) + 2; // 3
const b = 1n + BigInt(2); // 3n

You can compare BigInts with numbers.
jsconst a = 1n > 2; // false
const b = 3 > 2n; // true
String operatorsIn addition to the comparison operators, which can be used on string values, the concatenation operator (+) concatenates two string values together, returning another string that is the union of the two operand strings.
For example,
jsconsole.log("my " + "string"); // console logs the string "my string".

The shorthand assignment operator += can also be used to concatenate strings.
For example,
jslet myString = "alpha";
myString += "bet"; // evaluates to "alphabet" and assigns this value to myString.
Conditional (ternary) operatorThe conditional operator
is the only JavaScript operator that takes three operands.
The operator can have one of two values based on a condition.
The syntax is:
jscondition ? val1 : val2

If condition is true, the operator has the value of val1.
Otherwise it has the value of val2. You can use the conditional operator anywhere you would use a standard operator.
For example,
jsconst status = age >= 18 ? "adult" : "minor";

This statement assigns the value "adult" to the variable status if
age is eighteen or more. Otherwise, it assigns the value "minor" to
status.Comma operatorThe comma operator (,)
evaluates both of its operands and returns the value of the last operand.
This operator is primarily used inside a for loop, to allow multiple variables to be updated each time through the loop.
It is regarded bad style to use it elsewhere, when it is not necessary.
Often two separate statements can and should be used instead.
For example, if a is a 2-dimensional array with 10 elements on a side, the following code uses the comma operator to update two variables at once.
The code prints the values of the diagonal elements in the array:
jsconst x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
const a = [x, x, x, x, x];

for (let i = 0, j = 9; i <= j; i++, j--) {
  //                              ^
  console.log(`a[${i}][${j}]= ${a[i][j]}`);
}
Unary operatorsA unary operation is an operation with only one operand.deleteThe delete operator deletes an object's property.
The syntax is:
jsdelete object.property;
delete object[propertyKey];
delete objectName[index];

where object is the name of an object, property is an existing property, and propertyKey is a string or symbol referring to an existing property.
If the delete operator succeeds, it removes the property from the object.
Trying to access it afterwards will yield undefined.
The delete operator returns true if the operation is possible; it returns false if the operation is not possible.
jsdelete Math.PI; // returns false (cannot delete non-configurable properties)

const myObj = { h: 4 };
delete myObj.h; // returns true (can delete user-defined properties)

Deleting array elements
Since arrays are just objects, it's technically possible to delete elements from them.
This is, however, regarded as a bad practice — try to avoid it.
When you delete an array property, the array length is not affected and other elements are not re-indexed.
To achieve that behavior, it is much better to just overwrite the element with the value undefined.
To actually manipulate the array, use the various array methods such as splice.typeofThe typeof operator returns a string indicating the type of the unevaluated operand.
operand is the string, variable, keyword, or object for which the type is to be returned.
The parentheses are optional.
Suppose you define the following variables:
jsconst myFun = new Function("5 + 2");
const shape = "round";
const size = 1;
const foo = ["Apple", "Mango", "Orange"];
const today = new Date();

The typeof operator returns the following results for these variables:
jstypeof myFun; // returns "function"
typeof shape; // returns "string"
typeof size; // returns "number"
typeof foo; // returns "object"
typeof today; // returns "object"
typeof doesntExist; // returns "undefined"

For the keywords true and null, the typeof
operator returns the following results:
jstypeof true; // returns "boolean"
typeof null; // returns "object"

For a number or string, the typeof operator returns the following results:
jstypeof 62; // returns "number"
typeof "Hello world"; // returns "string"

For property values, the typeof operator returns the type of value the
property contains:
jstypeof document.lastModified; // returns "string"
typeof window.length; // returns "number"
typeof Math.LN2; // returns "number"

For methods and functions, the typeof operator returns results as follows:
jstypeof blur; // returns "function"
typeof eval; // returns "function"
typeof parseInt; // returns "function"
typeof shape.split; // returns "function"

For predefined objects, the typeof operator returns results as follows:
jstypeof Date; // returns "function"
typeof Function; // returns "function"
typeof Math; // returns "object"
typeof Option; // returns "function"
typeof String; // returns "function"
voidThe void operator specifies an expression to be evaluated without returning a value. expression is a JavaScript expression to evaluate.
The parentheses surrounding the expression are optional, but it is good style to use them to avoid precedence issues.Relational operatorsA relational operator compares its operands and returns a Boolean value based on whether the comparison is true.inThe in operator returns true if the specified property is in the specified object.
The syntax is:
jspropNameOrNumber in objectName

where propNameOrNumber is a string, numeric, or symbol expression representing a property name or array index, and objectName is the name of an object.
The following examples show some uses of the in operator.
js// Arrays
const trees = ["redwood", "bay", "cedar", "oak", "maple"];
0 in trees; // returns true
3 in trees; // returns true
6 in trees; // returns false
"bay" in trees; // returns false
// (you must specify the index number, not the value at that index)
"length" in trees; // returns true (length is an Array property)

// built-in objects
"PI" in Math; // returns true
const myString = new String("coral");
"length" in myString; // returns true

// Custom objects
const myCar = { make: "Honda", model: "Accord", year: 1998 };
"make" in myCar; // returns true
"model" in myCar; // returns true
instanceofThe instanceof operator returns true
if the specified object is of the specified object type. The syntax is:
jsobject instanceof objectType

where object is the object to test against objectType, and objectType is a constructor representing a type, such as Map or Array.
Use instanceof when you need to confirm the type of an object at runtime.
For example, when catching exceptions, you can branch to different exception-handling code depending on the type of exception thrown.
For example, the following code uses instanceof to determine whether obj is a Map object. Because obj is a Map object, the statements inside the if block execute.
jsconst obj = new Map();
if (obj instanceof Map) {
  // statements to execute
}
Basic expressionsAll operators eventually operate on one or more basic expressions. These basic expressions include identifiers and literals, but there are a few other kinds as well. They are briefly introduced below, and their semantics are described in detail in their respective reference sections.thisUse the this keyword to refer to the current object.
In general, this refers to the calling object in a method.
Use this either with the dot or the bracket notation:
jsthis["propertyName"];
this.propertyName;

Suppose a function called validate validates an object's value property, given the object and the high and low values:
jsfunction validate(obj, lowVal, highVal) {
  if (obj.value < lowVal || obj.value > highVal) {
    console.log("Invalid Value!");
  }
}

You could call validate in each form element's onChange event handler, using this to pass it to the form element, as in the following example:
html<p>Enter a number between 18 and 99:</p>
<input type="text" name="age" size="3" onChange="validate(this, 18, 99);" />
Grouping operatorThe grouping operator ( ) controls the precedence of evaluation in
expressions. For example, you can override multiplication and division first, then
addition and subtraction to evaluate addition first.
jsconst a = 1;
const b = 2;
const c = 3;

// default precedence
a + b * c     // 7
// evaluated by default like this
a + (b * c)   // 7

// now overriding precedence
// addition before multiplication
(a + b) * c   // 9

// which is equivalent to
a * c + b * c // 9
Property accessorThe property accessor syntax gets property values on objects, using either dot notation or bracket notation.
jsobject.property;
object["property"];

The working with objects guide goes into more details about object properties.Optional chainingThe optional chaining syntax (?.) performs the chained operation on an object if it is defined and non-null, and otherwise short-circuits the operation and returns undefined.
This allows you to operate on a value that may be null or undefined without causing a TypeError.
jsmaybeObject?.property;
maybeObject?.[property];
maybeFunction?.();
newYou can use the new operator to create an instance of a user-defined object type or of one of the built-in object types. Use new as follows:
jsconst objectName = new ObjectType(param1, param2, /* …, */ paramN);
superThe super keyword is used to call functions on an object's parent.
It is useful with classes to call the parent constructor, for example.
jssuper(args); // calls the parent constructor.
super.functionOnParent(args);

 Previous  Next\n\nExpressions and operators 
 Previous  Next  
This chapter describes JavaScript's expressions and operators, including assignment, comparison, arithmetic, bitwise, logical, string, ternary and more.
At a high level, an expression is a valid unit of code that resolves to a value. There are two types of expressions: those that have side effects (such as assigning values) and those that purely evaluate.
The expression x = 7 is an example of the first type. This expression uses the = operator to assign the value seven to the variable x. The expression itself evaluates to 7.
The expression 3 + 4 is an example of the second type. This expression uses the + operator to add 3 and 4 together and produces a value, 7. However, if it's not eventually part of a bigger construct (for example, a variable declaration like const z = 3 + 4), its result will be immediately discarded — this is usually a programmer mistake because the evaluation doesn't produce any effects.
As the examples above also illustrate, all complex expressions are joined by operators, such as = and +. In this section, we will introduce the following operators:

Assignment operators
Comparison operators
Arithmetic operators
Bitwise operators
Logical operators
BigInt operators
String operators
Conditional (ternary) operator
Comma operator
Unary operators
Relational operators

These operators join operands either formed by higher-precedence operators or one of the basic expressions. A complete and detailed list of operators and expressions is also available in the reference.
The precedence of operators determines the order they are applied when evaluating an expression. For example:
jsconst x = 1 + 2 * 3;
const y = 2 * 3 + 1;

Despite * and + coming in different orders, both expressions would result in 7 because * has precedence over +, so the *-joined expression will always be evaluated first. You can override operator precedence by using parentheses (which creates a grouped expression — the basic expression). To see a complete table of operator precedence as well as various caveats, see the Operator Precedence Reference page.
JavaScript has both binary and unary operators, and one special ternary operator, the conditional operator.
A binary operator requires two operands, one before the operator and one after the operator:
operand1 operator operand2

For example, 3 + 4 or x * y. This form is called an infix binary operator, because the operator is placed between two operands. All binary operators in JavaScript are infix.
A unary operator requires a single operand, either before or after the operator:
operator operand
operand operator

For example, x++ or ++x. The operator operand form is called a prefix unary operator, and the operand operator form is called a postfix unary operator. ++ and -- are the only postfix operators in JavaScript — all other operators, like !, typeof, etc. are prefix.Assignment operatorsAn assignment operator assigns a value to its left operand based on the value of its right operand.
The simple assignment operator is equal (=), which assigns the value of its right operand to its left operand.
That is, x = f() is an assignment expression that assigns the value of f() to x.
There are also compound assignment operators that are shorthand for the operations listed in the following table:



Name
Shorthand operator
Meaning




Assignment
x = f()
x = f()


Addition assignment
x += f()
x = x + f()


Subtraction assignment
x -= f()
x = x - f()


Multiplication assignment
x *= f()
x = x * f()


Division assignment
x /= f()
x = x / f()


Remainder assignment
x %= f()
x = x % f()


Exponentiation assignment
x **= f()
x = x ** f()


Left shift assignment
x <<= f()
x = x << f()


Right shift assignment
x >>= f()
x = x >> f()


Unsigned right shift assignment
x >>>= f()
x = x >>> f()


Bitwise AND assignment
x &= f()
x = x & f()


Bitwise XOR assignment
x ^= f()
x = x ^ f()


Bitwise OR assignment
x |= f()
x = x | f()


Logical AND assignment
x &&= f()
x && (x = f())


Logical OR assignment
x ||= f()
x || (x = f())


Nullish coalescing assignment
x ??= f()
x ?? (x = f())


Assigning to propertiesIf an expression evaluates to an object, then the left-hand side of an assignment expression may make assignments to properties of that expression.
For example:
jsconst obj = {};

obj.x = 3;
console.log(obj.x); // Prints 3.
console.log(obj); // Prints { x: 3 }.

const key = "y";
obj[key] = 5;
console.log(obj[key]); // Prints 5.
console.log(obj); // Prints { x: 3, y: 5 }.

For more information about objects, read Working with Objects.
If an expression does not evaluate to an object, then assignments to properties of that expression do not assign:
jsconst val = 0;
val.x = 3;

console.log(val.x); // Prints undefined.
console.log(val); // Prints 0.

In strict mode, the code above throws, because one cannot assign properties to primitives.
It is an error to assign values to unmodifiable properties or to properties of an expression without properties (null or undefined).DestructuringFor more complex assignments, the destructuring syntax is a JavaScript expression that makes it possible to extract data from arrays or objects using a syntax that mirrors the construction of array and
object literals.
Without destructuring, it takes multiple statements to extract values from arrays and objects:
jsconst foo = ["one", "two", "three"];

const one = foo[0];
const two = foo[1];
const three = foo[2];

With destructuring, you can extract multiple values into distinct variables using a single statement:
jsconst [one, two, three] = foo;
Evaluation and nestingIn general, assignments are used within a variable declaration (i.e., with const, let, or var) or as standalone statements.
js// Declares a variable x and initializes it to the result of f().
// The result of the x = f() assignment expression is discarded.
let x = f();

x = g(); // Reassigns the variable x to the result of g().

However, like other expressions, assignment expressions like x = f() evaluate into a result value.
Although this result value is usually not used, it can then be used by another expression.
Chaining assignments or nesting assignments in other expressions can result in surprising behavior.
For this reason, some JavaScript style guides discourage chaining or nesting assignments.
Nevertheless, assignment chaining and nesting may occur sometimes, so it is important to be able to understand how they work.
By chaining or nesting an assignment expression, its result can itself be assigned to another variable.
It can be logged, it can be put inside an array literal or function call, and so on.
jslet x;
const y = (x = f()); // Or equivalently: const y = x = f();
console.log(y); // Logs the return value of the assignment x = f().

console.log(x = f()); // Logs the return value directly.

// An assignment expression can be nested in any place
// where expressions are generally allowed,
// such as array literals' elements or as function calls' arguments.
console.log([0, x = f(), 0]);
console.log(f(0, x = f(), 0));

The evaluation result matches the expression to the right of the = sign in the
"Meaning" column of the table above. That means that x = f() evaluates into
whatever f()'s result is, x += f() evaluates into the resulting sum x + f(),
x **= f() evaluates into the resulting power x ** f(), and so on.
In the case of logical assignments, x &&= f(),
x ||= f(), and x ??= f(), the return value is that of the
logical operation without the assignment, so x && f(),
x || f(), and x ?? f(), respectively.
When chaining these expressions without parentheses or other grouping operators
like array literals, the assignment expressions are grouped right to left
(they are right-associative), but they are evaluated left to right.
Note that, for all assignment operators other than = itself,
the resulting values are always based on the operands' values before
the operation.
For example, assume that the following functions f and g
and the variables x and y have been declared:
jsfunction f() {
  console.log("F!");
  return 2;
}
function g() {
  console.log("G!");
  return 3;
}
let x, y;

Consider these three examples:
jsy = x = f();
y = [f(), x = g()];
x[f()] = g();

Evaluation example 1
y = x = f() is equivalent to y = (x = f()),
because the assignment operator = is right-associative.
However, it evaluates from left to right:

The assignment expression y = x = f() starts to evaluate.

The y on this assignment's left-hand side evaluates
into a reference to the variable named y.
The assignment expression x = f() starts to evaluate.

The x on this assignment's left-hand side evaluates
into a reference to the variable named x.
The function call f() prints "F!" to the console and
then evaluates to the number 2.
That 2 result from f() is assigned to x.


The assignment expression x = f() has now finished evaluating;
its result is the new value of x, which is 2.
That 2 result in turn is also assigned to y.


The assignment expression y = x = f() has now finished evaluating;
its result is the new value of y – which happens to be 2.
x and y are assigned to 2,
and the console has printed "F!".

Evaluation example 2
y = [ f(), x = g() ] also evaluates from left to right:

The assignment expression y = [ f(), x = g() ] starts to evaluate.

The y on this assignment's left-hand evaluates
into a reference to the variable named y.
The inner array literal [ f(), x = g() ] starts to evaluate.

The function call f() prints "F!" to the console and
then evaluates to the number 2.
The assignment expression x = g() starts to evaluate.

The x on this assignment's left-hand side evaluates
into a reference to the variable named x.
The function call g() prints "G!" to the console and
then evaluates to the number 3.
That 3 result from g() is assigned to x.


The assignment expression x = g() has now finished evaluating;
its result is the new value of x, which is 3.
That 3 result becomes the next element
in the inner array literal (after the 2 from the f()).


The inner array literal [ f(), x = g() ]
has now finished evaluating;
its result is an array with two values: [ 2, 3 ].
That [ 2, 3 ] array is now assigned to y.


The assignment expression y = [ f(), x = g() ] has
now finished evaluating;
its result is the new value of y – which happens to be [ 2, 3 ].
x is now assigned to 3,
y is now assigned to [ 2, 3 ],
and the console has printed "F!" then "G!".

Evaluation example 3
x[f()] = g() also evaluates from left to right.
(This example assumes that x is already assigned to some object.
For more information about objects, read Working with Objects.)

The assignment expression x[f()] = g() starts to evaluate.

The x[f()] property access on this assignment's left-hand
starts to evaluate.

The x in this property access evaluates
into a reference to the variable named x.
Then the function call f() prints "F!" to the console and
then evaluates to the number 2.


The x[f()] property access on this assignment
has now finished evaluating;
its result is a variable property reference: x[2].
Then the function call g() prints "G!" to the console and
then evaluates to the number 3.
That 3 is now assigned to x[2].
(This step will succeed only if x is assigned to an object.)


The assignment expression x[f()] = g() has now finished evaluating;
its result is the new value of x[2] – which happens to be 3.
x[2] is now assigned to 3,
and the console has printed "F!" then "G!".
Avoid assignment chainsChaining assignments or nesting assignments in other expressions can
result in surprising behavior. For this reason,
chaining assignments in the same statement is discouraged.
In particular, putting a variable chain in a const, let, or var statement often does not work. Only the outermost/leftmost variable would get declared; other variables within the assignment chain are not declared by the const/let/var statement.
For example:
jsconst z = y = x = f();

This statement seemingly declares the variables x, y, and z.
However, it only actually declares the variable z.
y and x are either invalid references to nonexistent variables (in strict mode) or, worse, would implicitly create global variables for x and y in sloppy mode.Comparison operatorsA comparison operator compares its operands and returns a logical value based on whether the comparison is true.
The operands can be numerical, string, logical, or object values.
Strings are compared based on standard lexicographical ordering, using Unicode values.
In most cases, if the two operands are not of the same type, JavaScript attempts to convert them to an appropriate type for the comparison.
This behavior generally results in comparing the operands numerically.
The sole exceptions to type conversion within comparisons involve the === and !== operators, which perform strict equality and inequality comparisons.
These operators do not attempt to convert the operands to compatible types before checking equality.
The following table describes the comparison operators in terms of this sample code:
jsconst var1 = 3;
const var2 = 4;


  
    Comparison operators
  
  
    
      Operator
      Description
      Examples returning true
    
  
  
    
      
        Equal (==)
      
      Returns true if the operands are equal.
      
        3 == var1
        "3" == var1
        3 == '3'
      
    
    
      
        Not equal (!=)
      
      Returns true if the operands are not equal.
      
        var1 != 4var2 != "3"
      
    
    
      
        Strict equal (===)
      
      
        Returns true if the operands are equal and of the same
        type. See also Object.is and
        sameness in JS.
      
      3 === var1
    
    
      
        Strict not equal (!==)
      
      
        Returns true if the operands are of the same type but not equal, or are of different type.
      
      
        var1 !== "3"3 !== '3'
      
    
    
      
        Greater than (>)
      
      
        Returns true if the left operand is greater than the right operand.
      
      
        var2 > var1"12" > 2
      
    
    
      
        Greater than or equal
        (>=)
      
      
        Returns true if the left operand is greater than or equal to the right operand.
      
      
        var2 >= var1var1 >= 3
      
    
    
      
        Less than
        (<)
      
      
        Returns true if the left operand is less than the right operand.
      
      
        var1 < var2"2" < 12
      
    
    
      
        Less than or equal
        (<=)
      
      
        Returns true if the left operand is less than or equal to the right operand.
      
      
        var1 <= var2var2 <= 5
      
    
  


Note: => is not a comparison operator but rather is the notation
for Arrow functions.
Arithmetic operatorsAn arithmetic operator takes numerical values (either literals or variables) as their operands and returns a single numerical value.
The standard arithmetic operators are addition (+), subtraction (-), multiplication (*), and division (/).
These operators work as they do in most other programming languages when used with floating point numbers (in particular, note that division by zero produces Infinity). For example:
js1 / 2; // 0.5
1 / 2 === 1.0 / 2.0; // this is true

In addition to the standard arithmetic operations (+, -, *, /), JavaScript provides the arithmetic operators listed in the following table:

  
    Arithmetic operators
  
  
    
      Operator
      Description
      Example
    
  
  
    
      
        Remainder (%)
      
      
        Binary operator. Returns the integer remainder of dividing the two operands.
      
      12 % 5 returns 2.
    
    
      
        Increment (++)
      
      
        Unary operator. Adds one to its operand. If used as a prefix operator
        (++x), returns the value of its operand after adding one;
        if used as a postfix operator (x++), returns the value of
        its operand before adding one.
      
      
        If x is 3, then ++x sets x to 4
        and returns 4, whereas x++ returns 3 and, only then, sets x to 4.
      
    
    
      
        Decrement (--)
      
      
        Unary operator. Subtracts one from its operand.
        The return value is analogous to that for the increment operator.
      
      
        If x is 3, then --x sets x to 2
        and returns 2, whereas x-- returns 3 and, only then, sets x to 2.
      
    
    
      
        Unary negation (-)
      
      Unary operator. Returns the negation of its operand.
      If x is 3, then -x returns -3.
    
    
      
        Unary plus (+)
      
      
        Unary operator. Attempts to convert the operand to a number, if it is not already.
      
      
        +"3" returns 3.
        +true returns 1.
      
    
    
      
        Exponentiation operator (**)
      
      
        Calculates the base to the exponent power,
        that is, base^exponent
      
      
        2 ** 3 returns 8.10 ** -1
        returns 0.1.
      
    
  
Bitwise operatorsA bitwise operator treats their operands as a set of 32 bits (zeros and ones), rather
than as decimal, hexadecimal, or octal numbers. For example, the decimal number nine has
a binary representation of 1001. Bitwise operators perform their operations on such
binary representations, but they return standard JavaScript numerical values.
The following table summarizes JavaScript's bitwise operators.



Operator
Usage
Description




Bitwise AND
a & b
Returns a one in each bit position for which the corresponding bits of both operands are ones.


Bitwise OR
a | b
Returns a zero in each bit position for which the corresponding bits of both operands are zeros.


Bitwise XOR
a ^ b
Returns a zero in each bit position for which the corresponding bits are the same. [Returns a one in each bit position for which the corresponding bits are different.]


Bitwise NOT
~ a
Inverts the bits of its operand.


Left shift
a << b
Shifts a in binary representation b bits to the left, shifting in zeros from the right.


Sign-propagating right shift
a >> b
Shifts a in binary representation b bits to the right, discarding bits shifted off.


Zero-fill right shift
a >>> b
Shifts a in binary representation b bits to the right, discarding bits shifted off, and shifting in zeros from the left.


Bitwise logical operatorsConceptually, the bitwise logical operators work as follows:


The operands are converted to thirty-two-bit integers and expressed by a series of bits (zeros and ones).
Numbers with more than 32 bits get their most significant bits discarded.
For example, the following integer with more than 32 bits will be converted to a 32-bit integer:
Before: 1110 0110 1111 1010 0000 0000 0000 0110 0000 0000 0001
After:                 1010 0000 0000 0000 0110 0000 0000 0001



Each bit in the first operand is paired with the corresponding bit in the second operand: first bit to first bit, second bit to second bit, and so on.


The operator is applied to each pair of bits, and the result is constructed bitwise.


For example, the binary representation of nine is 1001, and the binary representation of fifteen is 1111.
So, when the bitwise operators are applied to these values, the results are as follows:



Expression
Result
Binary Description




15 & 9
9
1111 & 1001 = 1001


15 | 9
15
1111 | 1001 = 1111


15 ^ 9
6
1111 ^ 1001 = 0110


~15
-16
~ 0000 0000 … 0000 1111 = 1111 1111 … 1111 0000


~9
-10
~ 0000 0000 … 0000 1001 = 1111 1111 … 1111 0110



Note that all 32 bits are inverted using the Bitwise NOT operator, and that values with
the most significant (left-most) bit set to 1 represent negative numbers
(two's-complement representation). ~x evaluates to the same value that
-x - 1 evaluates to.Bitwise shift operatorsThe bitwise shift operators take two operands: the first is a quantity to be shifted, and the second specifies the number of bit positions by which the first operand is to be
shifted.
The direction of the shift operation is controlled by the operator used.
Shift operators convert their operands to thirty-two-bit integers and return a result of either type Number or BigInt: specifically, if the type
of the left operand is BigInt, they return BigInt;
otherwise, they return Number.
The shift operators are listed in the following table.

  
    Bitwise shift operators
  
  
    
      Operator
      Description
      Example
    
  
  
    
      
        Left shift(<<)
      
      
        This operator shifts the first operand the specified number of bits to
        the left. Excess bits shifted off to the left are discarded. Zero bits
        are shifted in from the right.
      
      
        9<<2 yields 36, because 1001 shifted 2 bits to
        the left becomes 100100, which is 36.
      
    
    
      
        Sign-propagating right shift (>>)
      
      
        This operator shifts the first operand the specified number of bits to
        the right. Excess bits shifted off to the right are discarded. Copies of
        the leftmost bit are shifted in from the left.
      
      
        9>>2 yields 2, because 1001 shifted 2 bits to the right
        becomes 10, which is 2. Likewise, -9>>2 yields -3, because the sign is preserved.
      
    
    
      
        Zero-fill right shift (>>>)
      
      
        This operator shifts the first operand the specified number of bits to
        the right. Excess bits shifted off to the right are discarded. Zero bits
        are shifted in from the left.
      
      
        19>>>2 yields 4, because 10011 shifted 2 bits to the right
        becomes 100, which is 4. For non-negative numbers, zero-fill right shift
        and sign-propagating right shift yield the same result.
      
    
  
Logical operatorsLogical operators are typically used with Boolean (logical) values; when they are, they return a Boolean value.
However, the &&, ||, and ?? operators actually return the value of one of the specified operands, so if these
operators are used with non-Boolean values, they may return a non-Boolean value. As such, they are more adequately called "value selection operators".
The logical operators are described in the following table.

  
    Logical operators
  
  
    
      Operator
      Usage
      Description
    
  
  
    
      
        Logical AND (&&)
      
      expr1 && expr2
      
        Returns expr1 if it can be converted to false;
        otherwise, returns expr2. Thus, when used with Boolean
        values, && returns true if both
        operands are true; otherwise, returns false.
      
    
    
      
        Logical OR (||)
      
      expr1 || expr2
      
        Returns expr1 if it can be converted to true;
        otherwise, returns expr2. Thus, when used with Boolean
        values, || returns true if either operand is
        true; if both are false, returns false.
      
    
    
      
        Nullish coalescing operator (??)
      
      expr1 ?? expr2
      
        Returns expr1 if it is neither null nor
        undefined; otherwise, returns expr2.
      
    
    
      
        Logical NOT (!)
      
      !expr
      
        Returns false if its single operand can be converted
        to true; otherwise, returns true.
      
    
  

Examples of expressions that can be converted to false are those that evaluate to null, 0, 0n, NaN, the empty string (""), or undefined.
The following code shows examples of the && (logical AND) operator.
jsconst a1 = true && true; // t && t returns true
const a2 = true && false; // t && f returns false
const a3 = false && true; // f && t returns false
const a4 = false && 3 === 4; // f && f returns false
const a5 = "Cat" && "Dog"; // t && t returns Dog
const a6 = false && "Cat"; // f && t returns false
const a7 = "Cat" && false; // t && f returns false

The following code shows examples of the || (logical OR) operator.
jsconst o1 = true || true; // t || t returns true
const o2 = false || true; // f || t returns true
const o3 = true || false; // t || f returns true
const o4 = false || 3 === 4; // f || f returns false
const o5 = "Cat" || "Dog"; // t || t returns Cat
const o6 = false || "Cat"; // f || t returns Cat
const o7 = "Cat" || false; // t || f returns Cat

The following code shows examples of the ?? (nullish coalescing) operator.
jsconst n1 = null ?? 1; // 1
const n2 = undefined ?? 2; // 2
const n3 = false ?? 3; // false
const n4 = 0 ?? 4; // 0

Note how ?? works like ||, but it only returns the second expression when the first one is "nullish", i.e., null or undefined. ?? is a better alternative than || for setting defaults for values that might be null or undefined, in particular when values like '' or 0 are valid values and the default should not apply.
The following code shows examples of the ! (logical NOT) operator.
jsconst n1 = !true; // !t returns false
const n2 = !false; // !f returns true
const n3 = !"Cat"; // !t returns false
Short-circuit evaluationAs logical expressions are evaluated left to right, they are tested for possible
"short-circuit" evaluation using the following rules:

falsy && anything is short-circuit evaluated to the falsy value.
truthy || anything is short-circuit evaluated to the truthy value.
nonNullish ?? anything is short-circuit evaluated to the non-nullish value.

The rules of logic guarantee that these evaluations are always correct. Note that the
anything part of the above expressions is not evaluated, so any side effects of
doing so do not take effect.BigInt operatorsMost operators that can be used between numbers can be used between BigInt values as well.
js// BigInt addition
const a = 1n + 2n; // 3n
// Division with BigInts round towards zero
const b = 1n / 2n; // 0n
// Bitwise operations with BigInts do not truncate either side
const c = 40000000000000000n >> 2n; // 10000000000000000n

One exception is unsigned right shift (>>>), which is not defined for BigInt values. This is because a BigInt does not have a fixed width, so technically it does not have a "highest bit".
jsconst d = 8n >>> 2n; // TypeError: BigInts have no unsigned right shift, use >> instead

BigInts and numbers are not mutually replaceable — you cannot mix them in calculations.
jsconst a = 1n + 2; // TypeError: Cannot mix BigInt and other types

This is because BigInt is neither a subset nor a superset of numbers. BigInts have higher precision than numbers when representing large integers, but cannot represent decimals, so implicit conversion on either side might lose precision. Use explicit conversion to signal whether you wish the operation to be a number operation or a BigInt one.
jsconst a = Number(1n) + 2; // 3
const b = 1n + BigInt(2); // 3n

You can compare BigInts with numbers.
jsconst a = 1n > 2; // false
const b = 3 > 2n; // true
String operatorsIn addition to the comparison operators, which can be used on string values, the concatenation operator (+) concatenates two string values together, returning another string that is the union of the two operand strings.
For example,
jsconsole.log("my " + "string"); // console logs the string "my string".

The shorthand assignment operator += can also be used to concatenate strings.
For example,
jslet myString = "alpha";
myString += "bet"; // evaluates to "alphabet" and assigns this value to myString.
Conditional (ternary) operatorThe conditional operator
is the only JavaScript operator that takes three operands.
The operator can have one of two values based on a condition.
The syntax is:
jscondition ? val1 : val2

If condition is true, the operator has the value of val1.
Otherwise it has the value of val2. You can use the conditional operator anywhere you would use a standard operator.
For example,
jsconst status = age >= 18 ? "adult" : "minor";

This statement assigns the value "adult" to the variable status if
age is eighteen or more. Otherwise, it assigns the value "minor" to
status.Comma operatorThe comma operator (,)
evaluates both of its operands and returns the value of the last operand.
This operator is primarily used inside a for loop, to allow multiple variables to be updated each time through the loop.
It is regarded bad style to use it elsewhere, when it is not necessary.
Often two separate statements can and should be used instead.
For example, if a is a 2-dimensional array with 10 elements on a side, the following code uses the comma operator to update two variables at once.
The code prints the values of the diagonal elements in the array:
jsconst x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
const a = [x, x, x, x, x];

for (let i = 0, j = 9; i <= j; i++, j--) {
  //                              ^
  console.log(`a[${i}][${j}]= ${a[i][j]}`);
}
Unary operatorsA unary operation is an operation with only one operand.deleteThe delete operator deletes an object's property.
The syntax is:
jsdelete object.property;
delete object[propertyKey];
delete objectName[index];

where object is the name of an object, property is an existing property, and propertyKey is a string or symbol referring to an existing property.
If the delete operator succeeds, it removes the property from the object.
Trying to access it afterwards will yield undefined.
The delete operator returns true if the operation is possible; it returns false if the operation is not possible.
jsdelete Math.PI; // returns false (cannot delete non-configurable properties)

const myObj = { h: 4 };
delete myObj.h; // returns true (can delete user-defined properties)

Deleting array elements
Since arrays are just objects, it's technically possible to delete elements from them.
This is, however, regarded as a bad practice — try to avoid it.
When you delete an array property, the array length is not affected and other elements are not re-indexed.
To achieve that behavior, it is much better to just overwrite the element with the value undefined.
To actually manipulate the array, use the various array methods such as splice.typeofThe typeof operator returns a string indicating the type of the unevaluated operand.
operand is the string, variable, keyword, or object for which the type is to be returned.
The parentheses are optional.
Suppose you define the following variables:
jsconst myFun = new Function("5 + 2");
const shape = "round";
const size = 1;
const foo = ["Apple", "Mango", "Orange"];
const today = new Date();

The typeof operator returns the following results for these variables:
jstypeof myFun; // returns "function"
typeof shape; // returns "string"
typeof size; // returns "number"
typeof foo; // returns "object"
typeof today; // returns "object"
typeof doesntExist; // returns "undefined"

For the keywords true and null, the typeof
operator returns the following results:
jstypeof true; // returns "boolean"
typeof null; // returns "object"

For a number or string, the typeof operator returns the following results:
jstypeof 62; // returns "number"
typeof "Hello world"; // returns "string"

For property values, the typeof operator returns the type of value the
property contains:
jstypeof document.lastModified; // returns "string"
typeof window.length; // returns "number"
typeof Math.LN2; // returns "number"

For methods and functions, the typeof operator returns results as follows:
jstypeof blur; // returns "function"
typeof eval; // returns "function"
typeof parseInt; // returns "function"
typeof shape.split; // returns "function"

For predefined objects, the typeof operator returns results as follows:
jstypeof Date; // returns "function"
typeof Function; // returns "function"
typeof Math; // returns "object"
typeof Option; // returns "function"
typeof String; // returns "function"
voidThe void operator specifies an expression to be evaluated without returning a value. expression is a JavaScript expression to evaluate.
The parentheses surrounding the expression are optional, but it is good style to use them to avoid precedence issues.Relational operatorsA relational operator compares its operands and returns a Boolean value based on whether the comparison is true.inThe in operator returns true if the specified property is in the specified object.
The syntax is:
jspropNameOrNumber in objectName

where propNameOrNumber is a string, numeric, or symbol expression representing a property name or array index, and objectName is the name of an object.
The following examples show some uses of the in operator.
js// Arrays
const trees = ["redwood", "bay", "cedar", "oak", "maple"];
0 in trees; // returns true
3 in trees; // returns true
6 in trees; // returns false
"bay" in trees; // returns false
// (you must specify the index number, not the value at that index)
"length" in trees; // returns true (length is an Array property)

// built-in objects
"PI" in Math; // returns true
const myString = new String("coral");
"length" in myString; // returns true

// Custom objects
const myCar = { make: "Honda", model: "Accord", year: 1998 };
"make" in myCar; // returns true
"model" in myCar; // returns true
instanceofThe instanceof operator returns true
if the specified object is of the specified object type. The syntax is:
jsobject instanceof objectType

where object is the object to test against objectType, and objectType is a constructor representing a type, such as Map or Array.
Use instanceof when you need to confirm the type of an object at runtime.
For example, when catching exceptions, you can branch to different exception-handling code depending on the type of exception thrown.
For example, the following code uses instanceof to determine whether obj is a Map object. Because obj is a Map object, the statements inside the if block execute.
jsconst obj = new Map();
if (obj instanceof Map) {
  // statements to execute
}
Basic expressionsAll operators eventually operate on one or more basic expressions. These basic expressions include identifiers and literals, but there are a few other kinds as well. They are briefly introduced below, and their semantics are described in detail in their respective reference sections.thisUse the this keyword to refer to the current object.
In general, this refers to the calling object in a method.
Use this either with the dot or the bracket notation:
jsthis["propertyName"];
this.propertyName;

Suppose a function called validate validates an object's value property, given the object and the high and low values:
jsfunction validate(obj, lowVal, highVal) {
  if (obj.value < lowVal || obj.value > highVal) {
    console.log("Invalid Value!");
  }
}

You could call validate in each form element's onChange event handler, using this to pass it to the form element, as in the following example:
html<p>Enter a number between 18 and 99:</p>
<input type="text" name="age" size="3" onChange="validate(this, 18, 99);" />
Grouping operatorThe grouping operator ( ) controls the precedence of evaluation in
expressions. For example, you can override multiplication and division first, then
addition and subtraction to evaluate addition first.
jsconst a = 1;
const b = 2;
const c = 3;

// default precedence
a + b * c     // 7
// evaluated by default like this
a + (b * c)   // 7

// now overriding precedence
// addition before multiplication
(a + b) * c   // 9

// which is equivalent to
a * c + b * c // 9
Property accessorThe property accessor syntax gets property values on objects, using either dot notation or bracket notation.
jsobject.property;
object["property"];

The working with objects guide goes into more details about object properties.Optional chainingThe optional chaining syntax (?.) performs the chained operation on an object if it is defined and non-null, and otherwise short-circuits the operation and returns undefined.
This allows you to operate on a value that may be null or undefined without causing a TypeError.
jsmaybeObject?.property;
maybeObject?.[property];
maybeFunction?.();
newYou can use the new operator to create an instance of a user-defined object type or of one of the built-in object types. Use new as follows:
jsconst objectName = new ObjectType(param1, param2, /* …, */ paramN);
superThe super keyword is used to call functions on an object's parent.
It is useful with classes to call the parent constructor, for example.
jssuper(args); // calls the parent constructor.
super.functionOnParent(args);

 Previous  Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nExpressions and operators 
 Previous  Next  
This chapter describes JavaScript's expressions and operators, including assignment, comparison, arithmetic, bitwise, logical, string, ternary and more.
At a high level, an expression is a valid unit of code that resolves to a value. There are two types of expressions: those that have side effects (such as assigning values) and those that purely evaluate.
The expression x = 7 is an example of the first type. This expression uses the = operator to assign the value seven to the variable x. The expression itself evaluates to 7.
The expression 3 + 4 is an example of the second type. This expression uses the + operator to add 3 and 4 together and produces a value, 7. However, if it's not eventually part of a bigger construct (for example, a variable declaration like const z = 3 + 4), its result will be immediately discarded — this is usually a programmer mistake because the evaluation doesn't produce any effects.
As the examples above also illustrate, all complex expressions are joined by operators, such as = and +. In this section, we will introduce the following operators:

Assignment operators
Comparison operators
Arithmetic operators
Bitwise operators
Logical operators
BigInt operators
String operators
Conditional (ternary) operator
Comma operator
Unary operators
Relational operators

These operators join operands either formed by higher-precedence operators or one of the basic expressions. A complete and detailed list of operators and expressions is also available in the reference.
The precedence of operators determines the order they are applied when evaluating an expression. For example:
jsconst x = 1 + 2 * 3;
const y = 2 * 3 + 1;

Despite * and + coming in different orders, both expressions would result in 7 because * has precedence over +, so the *-joined expression will always be evaluated first. You can override operator precedence by using parentheses (which creates a grouped expression — the basic expression). To see a complete table of operator precedence as well as various caveats, see the Operator Precedence Reference page.
JavaScript has both binary and unary operators, and one special ternary operator, the conditional operator.
A binary operator requires two operands, one before the operator and one after the operator:
operand1 operator operand2

For example, 3 + 4 or x * y. This form is called an infix binary operator, because the operator is placed between two operands. All binary operators in JavaScript are infix.
A unary operator requires a single operand, either before or after the operator:
operator operand
operand operator

For example, x++ or ++x. The operator operand form is called a prefix unary operator, and the operand operator form is called a postfix unary operator. ++ and -- are the only postfix operators in JavaScript — all other operators, like !, typeof, etc. are prefix.Assignment operatorsAn assignment operator assigns a value to its left operand based on the value of its right operand.
The simple assignment operator is equal (=), which assigns the value of its right operand to its left operand.
That is, x = f() is an assignment expression that assigns the value of f() to x.
There are also compound assignment operators that are shorthand for the operations listed in the following table:



Name
Shorthand operator
Meaning




Assignment
x = f()
x = f()


Addition assignment
x += f()
x = x + f()


Subtraction assignment
x -= f()
x = x - f()


Multiplication assignment
x *= f()
x = x * f()


Division assignment
x /= f()
x = x / f()


Remainder assignment
x %= f()
x = x % f()


Exponentiation assignment
x **= f()
x = x ** f()


Left shift assignment
x <<= f()
x = x << f()


Right shift assignment
x >>= f()
x = x >> f()


Unsigned right shift assignment
x >>>= f()
x = x >>> f()


Bitwise AND assignment
x &= f()
x = x & f()


Bitwise XOR assignment
x ^= f()
x = x ^ f()


Bitwise OR assignment
x |= f()
x = x | f()


Logical AND assignment
x &&= f()
x && (x = f())


Logical OR assignment
x ||= f()
x || (x = f())


Nullish coalescing assignment
x ??= f()
x ?? (x = f())


Assigning to propertiesIf an expression evaluates to an object, then the left-hand side of an assignment expression may make assignments to properties of that expression.
For example:
jsconst obj = {};

obj.x = 3;
console.log(obj.x); // Prints 3.
console.log(obj); // Prints { x: 3 }.

const key = "y";
obj[key] = 5;
console.log(obj[key]); // Prints 5.
console.log(obj); // Prints { x: 3, y: 5 }.

For more information about objects, read Working with Objects.
If an expression does not evaluate to an object, then assignments to properties of that expression do not assign:
jsconst val = 0;
val.x = 3;

console.log(val.x); // Prints undefined.
console.log(val); // Prints 0.

In strict mode, the code above throws, because one cannot assign properties to primitives.
It is an error to assign values to unmodifiable properties or to properties of an expression without properties (null or undefined).DestructuringFor more complex assignments, the destructuring syntax is a JavaScript expression that makes it possible to extract data from arrays or objects using a syntax that mirrors the construction of array and
object literals.
Without destructuring, it takes multiple statements to extract values from arrays and objects:
jsconst foo = ["one", "two", "three"];

const one = foo[0];
const two = foo[1];
const three = foo[2];

With destructuring, you can extract multiple values into distinct variables using a single statement:
jsconst [one, two, three] = foo;
Evaluation and nestingIn general, assignments are used within a variable declaration (i.e., with const, let, or var) or as standalone statements.
js// Declares a variable x and initializes it to the result of f().
// The result of the x = f() assignment expression is discarded.
let x = f();

x = g(); // Reassigns the variable x to the result of g().

However, like other expressions, assignment expressions like x = f() evaluate into a result value.
Although this result value is usually not used, it can then be used by another expression.
Chaining assignments or nesting assignments in other expressions can result in surprising behavior.
For this reason, some JavaScript style guides discourage chaining or nesting assignments.
Nevertheless, assignment chaining and nesting may occur sometimes, so it is important to be able to understand how they work.
By chaining or nesting an assignment expression, its result can itself be assigned to another variable.
It can be logged, it can be put inside an array literal or function call, and so on.
jslet x;
const y = (x = f()); // Or equivalently: const y = x = f();
console.log(y); // Logs the return value of the assignment x = f().

console.log(x = f()); // Logs the return value directly.

// An assignment expression can be nested in any place
// where expressions are generally allowed,
// such as array literals' elements or as function calls' arguments.
console.log([0, x = f(), 0]);
console.log(f(0, x = f(), 0));

The evaluation result matches the expression to the right of the = sign in the
"Meaning" column of the table above. That means that x = f() evaluates into
whatever f()'s result is, x += f() evaluates into the resulting sum x + f(),
x **= f() evaluates into the resulting power x ** f(), and so on.
In the case of logical assignments, x &&= f(),
x ||= f(), and x ??= f(), the return value is that of the
logical operation without the assignment, so x && f(),
x || f(), and x ?? f(), respectively.
When chaining these expressions without parentheses or other grouping operators
like array literals, the assignment expressions are grouped right to left
(they are right-associative), but they are evaluated left to right.
Note that, for all assignment operators other than = itself,
the resulting values are always based on the operands' values before
the operation.
For example, assume that the following functions f and g
and the variables x and y have been declared:
jsfunction f() {
  console.log("F!");
  return 2;
}
function g() {
  console.log("G!");
  return 3;
}
let x, y;

Consider these three examples:
jsy = x = f();
y = [f(), x = g()];
x[f()] = g();

Evaluation example 1
y = x = f() is equivalent to y = (x = f()),
because the assignment operator = is right-associative.
However, it evaluates from left to right:

The assignment expression y = x = f() starts to evaluate.

The y on this assignment's left-hand side evaluates
into a reference to the variable named y.
The assignment expression x = f() starts to evaluate.

The x on this assignment's left-hand side evaluates
into a reference to the variable named x.
The function call f() prints "F!" to the console and
then evaluates to the number 2.
That 2 result from f() is assigned to x.


The assignment expression x = f() has now finished evaluating;
its result is the new value of x, which is 2.
That 2 result in turn is also assigned to y.


The assignment expression y = x = f() has now finished evaluating;
its result is the new value of y – which happens to be 2.
x and y are assigned to 2,
and the console has printed "F!".

Evaluation example 2
y = [ f(), x = g() ] also evaluates from left to right:

The assignment expression y = [ f(), x = g() ] starts to evaluate.

The y on this assignment's left-hand evaluates
into a reference to the variable named y.
The inner array literal [ f(), x = g() ] starts to evaluate.

The function call f() prints "F!" to the console and
then evaluates to the number 2.
The assignment expression x = g() starts to evaluate.

The x on this assignment's left-hand side evaluates
into a reference to the variable named x.
The function call g() prints "G!" to the console and
then evaluates to the number 3.
That 3 result from g() is assigned to x.


The assignment expression x = g() has now finished evaluating;
its result is the new value of x, which is 3.
That 3 result becomes the next element
in the inner array literal (after the 2 from the f()).


The inner array literal [ f(), x = g() ]
has now finished evaluating;
its result is an array with two values: [ 2, 3 ].
That [ 2, 3 ] array is now assigned to y.


The assignment expression y = [ f(), x = g() ] has
now finished evaluating;
its result is the new value of y – which happens to be [ 2, 3 ].
x is now assigned to 3,
y is now assigned to [ 2, 3 ],
and the console has printed "F!" then "G!".

Evaluation example 3
x[f()] = g() also evaluates from left to right.
(This example assumes that x is already assigned to some object.
For more information about objects, read Working with Objects.)

The assignment expression x[f()] = g() starts to evaluate.

The x[f()] property access on this assignment's left-hand
starts to evaluate.

The x in this property access evaluates
into a reference to the variable named x.
Then the function call f() prints "F!" to the console and
then evaluates to the number 2.


The x[f()] property access on this assignment
has now finished evaluating;
its result is a variable property reference: x[2].
Then the function call g() prints "G!" to the console and
then evaluates to the number 3.
That 3 is now assigned to x[2].
(This step will succeed only if x is assigned to an object.)


The assignment expression x[f()] = g() has now finished evaluating;
its result is the new value of x[2] – which happens to be 3.
x[2] is now assigned to 3,
and the console has printed "F!" then "G!".
Avoid assignment chainsChaining assignments or nesting assignments in other expressions can
result in surprising behavior. For this reason,
chaining assignments in the same statement is discouraged.
In particular, putting a variable chain in a const, let, or var statement often does not work. Only the outermost/leftmost variable would get declared; other variables within the assignment chain are not declared by the const/let/var statement.
For example:
jsconst z = y = x = f();

This statement seemingly declares the variables x, y, and z.
However, it only actually declares the variable z.
y and x are either invalid references to nonexistent variables (in strict mode) or, worse, would implicitly create global variables for x and y in sloppy mode.Comparison operatorsA comparison operator compares its operands and returns a logical value based on whether the comparison is true.
The operands can be numerical, string, logical, or object values.
Strings are compared based on standard lexicographical ordering, using Unicode values.
In most cases, if the two operands are not of the same type, JavaScript attempts to convert them to an appropriate type for the comparison.
This behavior generally results in comparing the operands numerically.
The sole exceptions to type conversion within comparisons involve the === and !== operators, which perform strict equality and inequality comparisons.
These operators do not attempt to convert the operands to compatible types before checking equality.
The following table describes the comparison operators in terms of this sample code:
jsconst var1 = 3;
const var2 = 4;


  
    Comparison operators
  
  
    
      Operator
      Description
      Examples returning true
    
  
  
    
      
        Equal (==)
      
      Returns true if the operands are equal.
      
        3 == var1
        "3" == var1
        3 == '3'
      
    
    
      
        Not equal (!=)
      
      Returns true if the operands are not equal.
      
        var1 != 4var2 != "3"
      
    
    
      
        Strict equal (===)
      
      
        Returns true if the operands are equal and of the same
        type. See also Object.is and
        sameness in JS.
      
      3 === var1
    
    
      
        Strict not equal (!==)
      
      
        Returns true if the operands are of the same type but not equal, or are of different type.
      
      
        var1 !== "3"3 !== '3'
      
    
    
      
        Greater than (>)
      
      
        Returns true if the left operand is greater than the right operand.
      
      
        var2 > var1"12" > 2
      
    
    
      
        Greater than or equal
        (>=)
      
      
        Returns true if the left operand is greater than or equal to the right operand.
      
      
        var2 >= var1var1 >= 3
      
    
    
      
        Less than
        (<)
      
      
        Returns true if the left operand is less than the right operand.
      
      
        var1 < var2"2" < 12
      
    
    
      
        Less than or equal
        (<=)
      
      
        Returns true if the left operand is less than or equal to the right operand.
      
      
        var1 <= var2var2 <= 5
      
    
  


Note: => is not a comparison operator but rather is the notation
for Arrow functions.
Arithmetic operatorsAn arithmetic operator takes numerical values (either literals or variables) as their operands and returns a single numerical value.
The standard arithmetic operators are addition (+), subtraction (-), multiplication (*), and division (/).
These operators work as they do in most other programming languages when used with floating point numbers (in particular, note that division by zero produces Infinity). For example:
js1 / 2; // 0.5
1 / 2 === 1.0 / 2.0; // this is true

In addition to the standard arithmetic operations (+, -, *, /), JavaScript provides the arithmetic operators listed in the following table:

  
    Arithmetic operators
  
  
    
      Operator
      Description
      Example
    
  
  
    
      
        Remainder (%)
      
      
        Binary operator. Returns the integer remainder of dividing the two operands.
      
      12 % 5 returns 2.
    
    
      
        Increment (++)
      
      
        Unary operator. Adds one to its operand. If used as a prefix operator
        (++x), returns the value of its operand after adding one;
        if used as a postfix operator (x++), returns the value of
        its operand before adding one.
      
      
        If x is 3, then ++x sets x to 4
        and returns 4, whereas x++ returns 3 and, only then, sets x to 4.
      
    
    
      
        Decrement (--)
      
      
        Unary operator. Subtracts one from its operand.
        The return value is analogous to that for the increment operator.
      
      
        If x is 3, then --x sets x to 2
        and returns 2, whereas x-- returns 3 and, only then, sets x to 2.
      
    
    
      
        Unary negation (-)
      
      Unary operator. Returns the negation of its operand.
      If x is 3, then -x returns -3.
    
    
      
        Unary plus (+)
      
      
        Unary operator. Attempts to convert the operand to a number, if it is not already.
      
      
        +"3" returns 3.
        +true returns 1.
      
    
    
      
        Exponentiation operator (**)
      
      
        Calculates the base to the exponent power,
        that is, base^exponent
      
      
        2 ** 3 returns 8.10 ** -1
        returns 0.1.
      
    
  
Bitwise operatorsA bitwise operator treats their operands as a set of 32 bits (zeros and ones), rather
than as decimal, hexadecimal, or octal numbers. For example, the decimal number nine has
a binary representation of 1001. Bitwise operators perform their operations on such
binary representations, but they return standard JavaScript numerical values.
The following table summarizes JavaScript's bitwise operators.



Operator
Usage
Description




Bitwise AND
a & b
Returns a one in each bit position for which the corresponding bits of both operands are ones.


Bitwise OR
a | b
Returns a zero in each bit position for which the corresponding bits of both operands are zeros.


Bitwise XOR
a ^ b
Returns a zero in each bit position for which the corresponding bits are the same. [Returns a one in each bit position for which the corresponding bits are different.]


Bitwise NOT
~ a
Inverts the bits of its operand.


Left shift
a << b
Shifts a in binary representation b bits to the left, shifting in zeros from the right.


Sign-propagating right shift
a >> b
Shifts a in binary representation b bits to the right, discarding bits shifted off.


Zero-fill right shift
a >>> b
Shifts a in binary representation b bits to the right, discarding bits shifted off, and shifting in zeros from the left.


Bitwise logical operatorsConceptually, the bitwise logical operators work as follows:


The operands are converted to thirty-two-bit integers and expressed by a series of bits (zeros and ones).
Numbers with more than 32 bits get their most significant bits discarded.
For example, the following integer with more than 32 bits will be converted to a 32-bit integer:
Before: 1110 0110 1111 1010 0000 0000 0000 0110 0000 0000 0001
After:                 1010 0000 0000 0000 0110 0000 0000 0001



Each bit in the first operand is paired with the corresponding bit in the second operand: first bit to first bit, second bit to second bit, and so on.


The operator is applied to each pair of bits, and the result is constructed bitwise.


For example, the binary representation of nine is 1001, and the binary representation of fifteen is 1111.
So, when the bitwise operators are applied to these values, the results are as follows:



Expression
Result
Binary Description




15 & 9
9
1111 & 1001 = 1001


15 | 9
15
1111 | 1001 = 1111


15 ^ 9
6
1111 ^ 1001 = 0110


~15
-16
~ 0000 0000 … 0000 1111 = 1111 1111 … 1111 0000


~9
-10
~ 0000 0000 … 0000 1001 = 1111 1111 … 1111 0110



Note that all 32 bits are inverted using the Bitwise NOT operator, and that values with
the most significant (left-most) bit set to 1 represent negative numbers
(two's-complement representation). ~x evaluates to the same value that
-x - 1 evaluates to.Bitwise shift operatorsThe bitwise shift operators take two operands: the first is a quantity to be shifted, and the second specifies the number of bit positions by which the first operand is to be
shifted.
The direction of the shift operation is controlled by the operator used.
Shift operators convert their operands to thirty-two-bit integers and return a result of either type Number or BigInt: specifically, if the type
of the left operand is BigInt, they return BigInt;
otherwise, they return Number.
The shift operators are listed in the following table.

  
    Bitwise shift operators
  
  
    
      Operator
      Description
      Example
    
  
  
    
      
        Left shift(<<)
      
      
        This operator shifts the first operand the specified number of bits to
        the left. Excess bits shifted off to the left are discarded. Zero bits
        are shifted in from the right.
      
      
        9<<2 yields 36, because 1001 shifted 2 bits to
        the left becomes 100100, which is 36.
      
    
    
      
        Sign-propagating right shift (>>)
      
      
        This operator shifts the first operand the specified number of bits to
        the right. Excess bits shifted off to the right are discarded. Copies of
        the leftmost bit are shifted in from the left.
      
      
        9>>2 yields 2, because 1001 shifted 2 bits to the right
        becomes 10, which is 2. Likewise, -9>>2 yields -3, because the sign is preserved.
      
    
    
      
        Zero-fill right shift (>>>)
      
      
        This operator shifts the first operand the specified number of bits to
        the right. Excess bits shifted off to the right are discarded. Zero bits
        are shifted in from the left.
      
      
        19>>>2 yields 4, because 10011 shifted 2 bits to the right
        becomes 100, which is 4. For non-negative numbers, zero-fill right shift
        and sign-propagating right shift yield the same result.
      
    
  
Logical operatorsLogical operators are typically used with Boolean (logical) values; when they are, they return a Boolean value.
However, the &&, ||, and ?? operators actually return the value of one of the specified operands, so if these
operators are used with non-Boolean values, they may return a non-Boolean value. As such, they are more adequately called "value selection operators".
The logical operators are described in the following table.

  
    Logical operators
  
  
    
      Operator
      Usage
      Description
    
  
  
    
      
        Logical AND (&&)
      
      expr1 && expr2
      
        Returns expr1 if it can be converted to false;
        otherwise, returns expr2. Thus, when used with Boolean
        values, && returns true if both
        operands are true; otherwise, returns false.
      
    
    
      
        Logical OR (||)
      
      expr1 || expr2
      
        Returns expr1 if it can be converted to true;
        otherwise, returns expr2. Thus, when used with Boolean
        values, || returns true if either operand is
        true; if both are false, returns false.
      
    
    
      
        Nullish coalescing operator (??)
      
      expr1 ?? expr2
      
        Returns expr1 if it is neither null nor
        undefined; otherwise, returns expr2.
      
    
    
      
        Logical NOT (!)
      
      !expr
      
        Returns false if its single operand can be converted
        to true; otherwise, returns true.
      
    
  

Examples of expressions that can be converted to false are those that evaluate to null, 0, 0n, NaN, the empty string (""), or undefined.
The following code shows examples of the && (logical AND) operator.
jsconst a1 = true && true; // t && t returns true
const a2 = true && false; // t && f returns false
const a3 = false && true; // f && t returns false
const a4 = false && 3 === 4; // f && f returns false
const a5 = "Cat" && "Dog"; // t && t returns Dog
const a6 = false && "Cat"; // f && t returns false
const a7 = "Cat" && false; // t && f returns false

The following code shows examples of the || (logical OR) operator.
jsconst o1 = true || true; // t || t returns true
const o2 = false || true; // f || t returns true
const o3 = true || false; // t || f returns true
const o4 = false || 3 === 4; // f || f returns false
const o5 = "Cat" || "Dog"; // t || t returns Cat
const o6 = false || "Cat"; // f || t returns Cat
const o7 = "Cat" || false; // t || f returns Cat

The following code shows examples of the ?? (nullish coalescing) operator.
jsconst n1 = null ?? 1; // 1
const n2 = undefined ?? 2; // 2
const n3 = false ?? 3; // false
const n4 = 0 ?? 4; // 0

Note how ?? works like ||, but it only returns the second expression when the first one is "nullish", i.e., null or undefined. ?? is a better alternative than || for setting defaults for values that might be null or undefined, in particular when values like '' or 0 are valid values and the default should not apply.
The following code shows examples of the ! (logical NOT) operator.
jsconst n1 = !true; // !t returns false
const n2 = !false; // !f returns true
const n3 = !"Cat"; // !t returns false
Short-circuit evaluationAs logical expressions are evaluated left to right, they are tested for possible
"short-circuit" evaluation using the following rules:

falsy && anything is short-circuit evaluated to the falsy value.
truthy || anything is short-circuit evaluated to the truthy value.
nonNullish ?? anything is short-circuit evaluated to the non-nullish value.

The rules of logic guarantee that these evaluations are always correct. Note that the
anything part of the above expressions is not evaluated, so any side effects of
doing so do not take effect.BigInt operatorsMost operators that can be used between numbers can be used between BigInt values as well.
js// BigInt addition
const a = 1n + 2n; // 3n
// Division with BigInts round towards zero
const b = 1n / 2n; // 0n
// Bitwise operations with BigInts do not truncate either side
const c = 40000000000000000n >> 2n; // 10000000000000000n

One exception is unsigned right shift (>>>), which is not defined for BigInt values. This is because a BigInt does not have a fixed width, so technically it does not have a "highest bit".
jsconst d = 8n >>> 2n; // TypeError: BigInts have no unsigned right shift, use >> instead

BigInts and numbers are not mutually replaceable — you cannot mix them in calculations.
jsconst a = 1n + 2; // TypeError: Cannot mix BigInt and other types

This is because BigInt is neither a subset nor a superset of numbers. BigInts have higher precision than numbers when representing large integers, but cannot represent decimals, so implicit conversion on either side might lose precision. Use explicit conversion to signal whether you wish the operation to be a number operation or a BigInt one.
jsconst a = Number(1n) + 2; // 3
const b = 1n + BigInt(2); // 3n

You can compare BigInts with numbers.
jsconst a = 1n > 2; // false
const b = 3 > 2n; // true
String operatorsIn addition to the comparison operators, which can be used on string values, the concatenation operator (+) concatenates two string values together, returning another string that is the union of the two operand strings.
For example,
jsconsole.log("my " + "string"); // console logs the string "my string".

The shorthand assignment operator += can also be used to concatenate strings.
For example,
jslet myString = "alpha";
myString += "bet"; // evaluates to "alphabet" and assigns this value to myString.
Conditional (ternary) operatorThe conditional operator
is the only JavaScript operator that takes three operands.
The operator can have one of two values based on a condition.
The syntax is:
jscondition ? val1 : val2

If condition is true, the operator has the value of val1.
Otherwise it has the value of val2. You can use the conditional operator anywhere you would use a standard operator.
For example,
jsconst status = age >= 18 ? "adult" : "minor";

This statement assigns the value "adult" to the variable status if
age is eighteen or more. Otherwise, it assigns the value "minor" to
status.Comma operatorThe comma operator (,)
evaluates both of its operands and returns the value of the last operand.
This operator is primarily used inside a for loop, to allow multiple variables to be updated each time through the loop.
It is regarded bad style to use it elsewhere, when it is not necessary.
Often two separate statements can and should be used instead.
For example, if a is a 2-dimensional array with 10 elements on a side, the following code uses the comma operator to update two variables at once.
The code prints the values of the diagonal elements in the array:
jsconst x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
const a = [x, x, x, x, x];

for (let i = 0, j = 9; i <= j; i++, j--) {
  //                              ^
  console.log(`a[${i}][${j}]= ${a[i][j]}`);
}
Unary operatorsA unary operation is an operation with only one operand.deleteThe delete operator deletes an object's property.
The syntax is:
jsdelete object.property;
delete object[propertyKey];
delete objectName[index];

where object is the name of an object, property is an existing property, and propertyKey is a string or symbol referring to an existing property.
If the delete operator succeeds, it removes the property from the object.
Trying to access it afterwards will yield undefined.
The delete operator returns true if the operation is possible; it returns false if the operation is not possible.
jsdelete Math.PI; // returns false (cannot delete non-configurable properties)

const myObj = { h: 4 };
delete myObj.h; // returns true (can delete user-defined properties)

Deleting array elements
Since arrays are just objects, it's technically possible to delete elements from them.
This is, however, regarded as a bad practice — try to avoid it.
When you delete an array property, the array length is not affected and other elements are not re-indexed.
To achieve that behavior, it is much better to just overwrite the element with the value undefined.
To actually manipulate the array, use the various array methods such as splice.typeofThe typeof operator returns a string indicating the type of the unevaluated operand.
operand is the string, variable, keyword, or object for which the type is to be returned.
The parentheses are optional.
Suppose you define the following variables:
jsconst myFun = new Function("5 + 2");
const shape = "round";
const size = 1;
const foo = ["Apple", "Mango", "Orange"];
const today = new Date();

The typeof operator returns the following results for these variables:
jstypeof myFun; // returns "function"
typeof shape; // returns "string"
typeof size; // returns "number"
typeof foo; // returns "object"
typeof today; // returns "object"
typeof doesntExist; // returns "undefined"

For the keywords true and null, the typeof
operator returns the following results:
jstypeof true; // returns "boolean"
typeof null; // returns "object"

For a number or string, the typeof operator returns the following results:
jstypeof 62; // returns "number"
typeof "Hello world"; // returns "string"

For property values, the typeof operator returns the type of value the
property contains:
jstypeof document.lastModified; // returns "string"
typeof window.length; // returns "number"
typeof Math.LN2; // returns "number"

For methods and functions, the typeof operator returns results as follows:
jstypeof blur; // returns "function"
typeof eval; // returns "function"
typeof parseInt; // returns "function"
typeof shape.split; // returns "function"

For predefined objects, the typeof operator returns results as follows:
jstypeof Date; // returns "function"
typeof Function; // returns "function"
typeof Math; // returns "object"
typeof Option; // returns "function"
typeof String; // returns "function"
voidThe void operator specifies an expression to be evaluated without returning a value. expression is a JavaScript expression to evaluate.
The parentheses surrounding the expression are optional, but it is good style to use them to avoid precedence issues.Relational operatorsA relational operator compares its operands and returns a Boolean value based on whether the comparison is true.inThe in operator returns true if the specified property is in the specified object.
The syntax is:
jspropNameOrNumber in objectName

where propNameOrNumber is a string, numeric, or symbol expression representing a property name or array index, and objectName is the name of an object.
The following examples show some uses of the in operator.
js// Arrays
const trees = ["redwood", "bay", "cedar", "oak", "maple"];
0 in trees; // returns true
3 in trees; // returns true
6 in trees; // returns false
"bay" in trees; // returns false
// (you must specify the index number, not the value at that index)
"length" in trees; // returns true (length is an Array property)

// built-in objects
"PI" in Math; // returns true
const myString = new String("coral");
"length" in myString; // returns true

// Custom objects
const myCar = { make: "Honda", model: "Accord", year: 1998 };
"make" in myCar; // returns true
"model" in myCar; // returns true
instanceofThe instanceof operator returns true
if the specified object is of the specified object type. The syntax is:
jsobject instanceof objectType

where object is the object to test against objectType, and objectType is a constructor representing a type, such as Map or Array.
Use instanceof when you need to confirm the type of an object at runtime.
For example, when catching exceptions, you can branch to different exception-handling code depending on the type of exception thrown.
For example, the following code uses instanceof to determine whether obj is a Map object. Because obj is a Map object, the statements inside the if block execute.
jsconst obj = new Map();
if (obj instanceof Map) {
  // statements to execute
}
Basic expressionsAll operators eventually operate on one or more basic expressions. These basic expressions include identifiers and literals, but there are a few other kinds as well. They are briefly introduced below, and their semantics are described in detail in their respective reference sections.thisUse the this keyword to refer to the current object.
In general, this refers to the calling object in a method.
Use this either with the dot or the bracket notation:
jsthis["propertyName"];
this.propertyName;

Suppose a function called validate validates an object's value property, given the object and the high and low values:
jsfunction validate(obj, lowVal, highVal) {
  if (obj.value < lowVal || obj.value > highVal) {
    console.log("Invalid Value!");
  }
}

You could call validate in each form element's onChange event handler, using this to pass it to the form element, as in the following example:
html<p>Enter a number between 18 and 99:</p>
<input type="text" name="age" size="3" onChange="validate(this, 18, 99);" />
Grouping operatorThe grouping operator ( ) controls the precedence of evaluation in
expressions. For example, you can override multiplication and division first, then
addition and subtraction to evaluate addition first.
jsconst a = 1;
const b = 2;
const c = 3;

// default precedence
a + b * c     // 7
// evaluated by default like this
a + (b * c)   // 7

// now overriding precedence
// addition before multiplication
(a + b) * c   // 9

// which is equivalent to
a * c + b * c // 9
Property accessorThe property accessor syntax gets property values on objects, using either dot notation or bracket notation.
jsobject.property;
object["property"];

The working with objects guide goes into more details about object properties.Optional chainingThe optional chaining syntax (?.) performs the chained operation on an object if it is defined and non-null, and otherwise short-circuits the operation and returns undefined.
This allows you to operate on a value that may be null or undefined without causing a TypeError.
jsmaybeObject?.property;
maybeObject?.[property];
maybeFunction?.();
newYou can use the new operator to create an instance of a user-defined object type or of one of the built-in object types. Use new as follows:
jsconst objectName = new ObjectType(param1, param2, /* …, */ paramN);
superThe super keyword is used to call functions on an object's parent.
It is useful with classes to call the parent constructor, for example.
jssuper(args); // calls the parent constructor.
super.functionOnParent(args);

 Previous  Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nNumbers and strings 
 Previous  Next  
This chapter introduces the two most fundamental data types in JavaScript: numbers and strings. We will introduce their underlying representations, and functions used to work with and perform calculations on them.NumbersIn JavaScript, numbers are implemented in double-precision 64-bit binary format IEEE 754 (i.e., a number between ±2^−1022 and ±2^+1023, or about ±10^−308 to ±10^+308, with a numeric precision of 53 bits). Integer values up to ±2^53 − 1 can be represented exactly.
In addition to being able to represent floating-point numbers, the number type has three symbolic values: Infinity, -Infinity, and NaN (not-a-number).
See also JavaScript data types and structures for context with other primitive types in JavaScript.
You can use four types of number literals: decimal, binary, octal, and hexadecimal.Decimal numbersjs1234567890
42

Decimal literals can start with a zero (0) followed by another decimal digit, but if all digits after the leading 0 are smaller than 8, the number is interpreted as an octal number. This is considered a legacy syntax, and number literals prefixed with 0, whether interpreted as octal or decimal, cause a syntax error in strict mode — so, use the 0o prefix instead.
js0888 // 888 parsed as decimal
0777 // parsed as octal, 511 in decimal
Binary numbersBinary number syntax uses a leading zero followed by a lowercase or uppercase Latin letter "B" (0b or 0B). If the digits after the 0b are not 0 or 1, the following SyntaxError is thrown: "Missing binary digits after 0b".
js0b10000000000000000000000000000000 // 2147483648
0b01111111100000000000000000000000 // 2139095040
0B00000000011111111111111111111111 // 8388607
Octal numbersThe standard syntax for octal numbers is to prefix them with 0o. For example:
js0O755 // 493
0o644 // 420

There's also a legacy syntax for octal numbers — by prefixing the octal number with a zero: 0644 === 420 and "\045" === "%". If the digits after the 0 are outside the range 0 through 7, the number will be interpreted as a decimal number.
jsconst n = 0755; // 493
const m = 0644; // 420

Strict mode forbids this octal syntax.Hexadecimal numbersHexadecimal number syntax uses a leading zero followed by a lowercase or uppercase Latin letter "X" (0x or 0X). If the digits after 0x are outside the range (0123456789ABCDEF), the following SyntaxError is thrown: "Identifier starts immediately after numeric literal".
js0xFFFFFFFFFFFFFFFFF // 295147905179352830000
0x123456789ABCDEF   // 81985529216486900
0XA                 // 10
Exponentiationjs0e-5   // 0
0e+5   // 0
5e1    // 50
175e-2 // 1.75
1e3    // 1000
1e-3   // 0.001
1E3    // 1000
Number objectThe built-in Number object has properties for numerical constants, such as maximum value, not-a-number, and infinity. You cannot change the values of these properties and you use them as follows:
jsconst biggestNum = Number.MAX_VALUE;
const smallestNum = Number.MIN_VALUE;
const infiniteNum = Number.POSITIVE_INFINITY;
const negInfiniteNum = Number.NEGATIVE_INFINITY;
const notANum = Number.NaN;

You always refer to a property of the predefined Number object as shown above, and not as a property of a Number object you create yourself.
The following table summarizes the Number object's properties.



Property
Description




Number.MAX_VALUE
The largest positive representable number (1.7976931348623157e+308)


Number.MIN_VALUE
The smallest positive representable number (5e-324)


Number.NaN
Special "not a number" value


Number.NEGATIVE_INFINITY
Special negative infinite value; returned on overflow


Number.POSITIVE_INFINITY
Special positive infinite value; returned on overflow


Number.EPSILON
Difference between 1 and the smallest value greater than 1 that can be represented as a Number (2.220446049250313e-16)


Number.MIN_SAFE_INTEGER
Minimum safe integer in JavaScript (−2^53 + 1, or −9007199254740991)


Number.MAX_SAFE_INTEGER
Maximum safe integer in JavaScript (+2^53 − 1, or +9007199254740991)






Method
Description




Number.parseFloat()
Parses a string argument and returns a floating point number. Same as the global parseFloat() function.


Number.parseInt()
Parses a string argument and returns an integer of the specified radix or base. Same as the global parseInt() function.


Number.isFinite()
Determines whether the passed value is a finite number.


Number.isInteger()
Determines whether the passed value is an integer.


Number.isNaN()
Determines whether the passed value is NaN. More robust version of the original global isNaN().


Number.isSafeInteger()
Determines whether the provided value is a number that is a safe integer.



The Number prototype provides methods for retrieving information from Number objects in various formats. The following table summarizes the methods of Number.prototype.



Method
Description




toExponential()
Returns a string representing the number in exponential notation.


toFixed()
Returns a string representing the number in fixed-point notation.


toPrecision()
Returns a string representing the number to a specified precision in fixed-point notation.


Math objectThe built-in Math object has properties and methods for mathematical constants and functions. For example, the Math object's PI property has the value of pi (3.141…), which you would use in an application as
jsMath.PI;

Similarly, standard mathematical functions are methods of Math. These include trigonometric, logarithmic, exponential, and other functions. For example, if you want to use the trigonometric function sine, you would write
jsMath.sin(1.56);

Note that all trigonometric methods of Math take arguments in radians.
The following table summarizes the Math object's methods.

  
    Methods of
    Math
  
  
    
      Method
      Description
    
  
  
    
      abs()
      Absolute value
    
    
      
        sin(),
        cos(),
        tan()
      
      Standard trigonometric functions; with the argument in radians.
    
    
      
        asin(),
        acos(),
        atan(),
        atan2()
      
      Inverse trigonometric functions; return values in radians.
    
    
      
        sinh(),
        cosh(),
        tanh()
      
      Hyperbolic functions; argument in hyperbolic angle.
    
    
      
        asinh(),
        acosh(),
        atanh()
      
      Inverse hyperbolic functions; return values in hyperbolic angle.
    
    
      
        
          pow(),
          exp(),
          expm1(),
          log(),
          log10(),
          log1p(),
          log2()
        
      
      Exponential and logarithmic functions.
    
    
      
        floor(),
        ceil()
      
      
        Returns the largest/smallest integer less/greater than or equal to an
        argument.
      
    
    
      
        min(),
        max()
      
      
        Returns the minimum or maximum (respectively) value of a comma separated
        list of numbers as arguments.
      
    
    
      random()
      Returns a random number between 0 and 1.
    
    
      
        round(),
        fround(),
        trunc(),
      
      Rounding and truncation functions.
    
    
      
        sqrt(),
        cbrt(),
        hypot()
      
      
        Square root, cube root, Square root of the sum of square arguments.
      
    
    
      sign()
      
        The sign of a number, indicating whether the number is positive,
        negative or zero.
      
    
    
      
        clz32(),imul()
      
      
        Number of leading zero bits in the 32-bit binary representation.The
        result of the C-like 32-bit multiplication of the two arguments.
      
    
  

Unlike many other objects, you never create a Math object of your own. You always use the built-in Math object.BigIntsOne shortcoming of number values is they only have 64 bits. In practice, due to using IEEE 754 encoding, they cannot represent any integer larger than Number.MAX_SAFE_INTEGER (which is 253 - 1) accurately. To solve the need of encoding binary data and to interoperate with other languages that offer wide integers like i64 (64-bit integers) and i128 (128-bit integers), JavaScript also offers another data type to represent arbitrarily large integers: BigInt.
A BigInt can be defined as an integer literal suffixed by n:
jsconst b1 = 123n;
// Can be arbitrarily large.
const b2 = -1234567890987654321n;

BigInts can also be constructed from number values or string values using the BigInt constructor.
jsconst b1 = BigInt(123);
// Using a string prevents loss of precision, since long number
// literals don't represent what they seem like.
const b2 = BigInt("-1234567890987654321");

Conceptually, a BigInt is just an arbitrarily long sequence of bits which encodes an integer. You can safely do any arithmetic operations without losing precision or over-/underflowing.
jsconst integer = 12 ** 34; // 4.9222352429520264e+36; only has limited precision
const bigint = 12n ** 34n; // 4922235242952026704037113243122008064n

Compared to numbers, BigInt values yield higher precision when representing large integers; however, they cannot represent floating-point numbers. For example, division would round to zero:
jsconst bigintDiv = 5n / 2n; // 2n, because there's no 2.5 in BigInt

Math functions cannot be used on BigInt values. There is an open proposal to overload certain Math functions like Math.max() to allow BigInt values.
Choosing between BigInt and number depends on your use-case and your input's range. The precision of numbers should be able to accommodate most day-to-day tasks already, and BigInts are most suitable for handling binary data.
Read more about what you can do with BigInt values in the Expressions and Operators section, or the BigInt reference.StringsJavaScript's String type is used to represent textual data. It is a set of "elements" of 16-bit unsigned integer values (UTF-16 code units). Each element in the String occupies a position in the String. The first element is at index 0, the next at index 1, and so on. The length of a String is the number of elements in it. You can create strings using string literals or string objects.String literalsYou can declare strings in source code using either single or double quotes:
js'foo'
"bar"

Within a string literal, most characters can be entered literally. The only exceptions are the backslash (\, which starts an escape sequence), the quote character being used to enclose the string, which terminates the string, and the newline character, which is a syntax error if not preceded by a backslash.
More advanced strings can be created using escape sequences:
Hexadecimal escape sequences
The number after \x is interpreted as a hexadecimal number.
js"\xA9" // "©"

Unicode escape sequences
The Unicode escape sequences require at least four hexadecimal digits following \u.
js"\u00A9" // "©"

Unicode code point escapes
With Unicode code point escapes, any character can be escaped using hexadecimal numbers so that it is possible to use Unicode code points up to 0x10FFFF. With the four-digit Unicode escapes it is often necessary to write the surrogate halves separately to achieve the same result.
See also String.fromCodePoint() or String.prototype.codePointAt().
js"\u{2F804}"

// the same with simple Unicode escapes
"\uD87E\uDC04"
String objectYou can call methods directly on a string value:
jsconsole.log("hello".toUpperCase()); // HELLO

The following methods are available on String values:

Query: get the character or character code at a particular string index. Methods include at(), charAt(), charCodeAt(), and codePointAt().
Search: get information about a substring that conforms to a pattern, or test if a particular substring exists. Methods include indexOf(), lastIndexOf(), startsWith(), endsWith(), includes(), match(), matchAll(), and search()
Composition: combine strings into a longer string. Methods include padStart(), padEnd(), concat(), and repeat().
Decomposition: break a string into smaller strings. Methods include split(), slice(), substring(), substr(), trim(), trimStart(), and trimEnd().
Transformation: return a new string based on the current string's content. Methods include toLowerCase(), toUpperCase(), toLocaleLowerCase(), toLocaleUpperCase(), normalize(), and toWellFormed().

When working with strings, there are two other objects that provide important functionality for string manipulation: RegExp and Intl. They are introduced in regular expressions and internationalization respectively.Template literalsTemplate literals are string literals allowing embedded expressions. You can use multi-line strings and string interpolation features with them.
Template literals are enclosed by backtick (grave accent) characters (`) instead of double or single quotes. Template literals can contain placeholders. These are indicated by the dollar sign and curly braces (${expression}).Multi-linesAny new line characters inserted in the source are part of the template literal. Using normal strings, you would have to use the following syntax in order to get multi-line strings:
jsconsole.log(
  "string text line 1\n\
string text line 2",
);
// "string text line 1
// string text line 2"

To get the same effect with multi-line strings, you can now write:
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"
Embedded expressionsIn order to embed expressions within normal strings, you would use the following syntax:
jsconst five = 5;
const ten = 10;
console.log(
  "Fifteen is " + (five + ten) + " and not " + (2 * five + ten) + ".",
);
// "Fifteen is 15 and not 20."

Now, with template literals, you are able to make use of the syntactic sugar making substitutions like this more readable:
jsconst five = 5;
const ten = 10;
console.log(`Fifteen is ${five + ten} and not ${2 * five + ten}.`);
// "Fifteen is 15 and not 20."

For more information, read about Template literals in the JavaScript reference.
 Previous  Next\n\nNumbers and strings 
 Previous  Next  
This chapter introduces the two most fundamental data types in JavaScript: numbers and strings. We will introduce their underlying representations, and functions used to work with and perform calculations on them.NumbersIn JavaScript, numbers are implemented in double-precision 64-bit binary format IEEE 754 (i.e., a number between ±2^−1022 and ±2^+1023, or about ±10^−308 to ±10^+308, with a numeric precision of 53 bits). Integer values up to ±2^53 − 1 can be represented exactly.
In addition to being able to represent floating-point numbers, the number type has three symbolic values: Infinity, -Infinity, and NaN (not-a-number).
See also JavaScript data types and structures for context with other primitive types in JavaScript.
You can use four types of number literals: decimal, binary, octal, and hexadecimal.Decimal numbersjs1234567890
42

Decimal literals can start with a zero (0) followed by another decimal digit, but if all digits after the leading 0 are smaller than 8, the number is interpreted as an octal number. This is considered a legacy syntax, and number literals prefixed with 0, whether interpreted as octal or decimal, cause a syntax error in strict mode — so, use the 0o prefix instead.
js0888 // 888 parsed as decimal
0777 // parsed as octal, 511 in decimal
Binary numbersBinary number syntax uses a leading zero followed by a lowercase or uppercase Latin letter "B" (0b or 0B). If the digits after the 0b are not 0 or 1, the following SyntaxError is thrown: "Missing binary digits after 0b".
js0b10000000000000000000000000000000 // 2147483648
0b01111111100000000000000000000000 // 2139095040
0B00000000011111111111111111111111 // 8388607
Octal numbersThe standard syntax for octal numbers is to prefix them with 0o. For example:
js0O755 // 493
0o644 // 420

There's also a legacy syntax for octal numbers — by prefixing the octal number with a zero: 0644 === 420 and "\045" === "%". If the digits after the 0 are outside the range 0 through 7, the number will be interpreted as a decimal number.
jsconst n = 0755; // 493
const m = 0644; // 420

Strict mode forbids this octal syntax.Hexadecimal numbersHexadecimal number syntax uses a leading zero followed by a lowercase or uppercase Latin letter "X" (0x or 0X). If the digits after 0x are outside the range (0123456789ABCDEF), the following SyntaxError is thrown: "Identifier starts immediately after numeric literal".
js0xFFFFFFFFFFFFFFFFF // 295147905179352830000
0x123456789ABCDEF   // 81985529216486900
0XA                 // 10
Exponentiationjs0e-5   // 0
0e+5   // 0
5e1    // 50
175e-2 // 1.75
1e3    // 1000
1e-3   // 0.001
1E3    // 1000
Number objectThe built-in Number object has properties for numerical constants, such as maximum value, not-a-number, and infinity. You cannot change the values of these properties and you use them as follows:
jsconst biggestNum = Number.MAX_VALUE;
const smallestNum = Number.MIN_VALUE;
const infiniteNum = Number.POSITIVE_INFINITY;
const negInfiniteNum = Number.NEGATIVE_INFINITY;
const notANum = Number.NaN;

You always refer to a property of the predefined Number object as shown above, and not as a property of a Number object you create yourself.
The following table summarizes the Number object's properties.



Property
Description




Number.MAX_VALUE
The largest positive representable number (1.7976931348623157e+308)


Number.MIN_VALUE
The smallest positive representable number (5e-324)


Number.NaN
Special "not a number" value


Number.NEGATIVE_INFINITY
Special negative infinite value; returned on overflow


Number.POSITIVE_INFINITY
Special positive infinite value; returned on overflow


Number.EPSILON
Difference between 1 and the smallest value greater than 1 that can be represented as a Number (2.220446049250313e-16)


Number.MIN_SAFE_INTEGER
Minimum safe integer in JavaScript (−2^53 + 1, or −9007199254740991)


Number.MAX_SAFE_INTEGER
Maximum safe integer in JavaScript (+2^53 − 1, or +9007199254740991)






Method
Description




Number.parseFloat()
Parses a string argument and returns a floating point number. Same as the global parseFloat() function.


Number.parseInt()
Parses a string argument and returns an integer of the specified radix or base. Same as the global parseInt() function.


Number.isFinite()
Determines whether the passed value is a finite number.


Number.isInteger()
Determines whether the passed value is an integer.


Number.isNaN()
Determines whether the passed value is NaN. More robust version of the original global isNaN().


Number.isSafeInteger()
Determines whether the provided value is a number that is a safe integer.



The Number prototype provides methods for retrieving information from Number objects in various formats. The following table summarizes the methods of Number.prototype.



Method
Description




toExponential()
Returns a string representing the number in exponential notation.


toFixed()
Returns a string representing the number in fixed-point notation.


toPrecision()
Returns a string representing the number to a specified precision in fixed-point notation.


Math objectThe built-in Math object has properties and methods for mathematical constants and functions. For example, the Math object's PI property has the value of pi (3.141…), which you would use in an application as
jsMath.PI;

Similarly, standard mathematical functions are methods of Math. These include trigonometric, logarithmic, exponential, and other functions. For example, if you want to use the trigonometric function sine, you would write
jsMath.sin(1.56);

Note that all trigonometric methods of Math take arguments in radians.
The following table summarizes the Math object's methods.

  
    Methods of
    Math
  
  
    
      Method
      Description
    
  
  
    
      abs()
      Absolute value
    
    
      
        sin(),
        cos(),
        tan()
      
      Standard trigonometric functions; with the argument in radians.
    
    
      
        asin(),
        acos(),
        atan(),
        atan2()
      
      Inverse trigonometric functions; return values in radians.
    
    
      
        sinh(),
        cosh(),
        tanh()
      
      Hyperbolic functions; argument in hyperbolic angle.
    
    
      
        asinh(),
        acosh(),
        atanh()
      
      Inverse hyperbolic functions; return values in hyperbolic angle.
    
    
      
        
          pow(),
          exp(),
          expm1(),
          log(),
          log10(),
          log1p(),
          log2()
        
      
      Exponential and logarithmic functions.
    
    
      
        floor(),
        ceil()
      
      
        Returns the largest/smallest integer less/greater than or equal to an
        argument.
      
    
    
      
        min(),
        max()
      
      
        Returns the minimum or maximum (respectively) value of a comma separated
        list of numbers as arguments.
      
    
    
      random()
      Returns a random number between 0 and 1.
    
    
      
        round(),
        fround(),
        trunc(),
      
      Rounding and truncation functions.
    
    
      
        sqrt(),
        cbrt(),
        hypot()
      
      
        Square root, cube root, Square root of the sum of square arguments.
      
    
    
      sign()
      
        The sign of a number, indicating whether the number is positive,
        negative or zero.
      
    
    
      
        clz32(),imul()
      
      
        Number of leading zero bits in the 32-bit binary representation.The
        result of the C-like 32-bit multiplication of the two arguments.
      
    
  

Unlike many other objects, you never create a Math object of your own. You always use the built-in Math object.BigIntsOne shortcoming of number values is they only have 64 bits. In practice, due to using IEEE 754 encoding, they cannot represent any integer larger than Number.MAX_SAFE_INTEGER (which is 253 - 1) accurately. To solve the need of encoding binary data and to interoperate with other languages that offer wide integers like i64 (64-bit integers) and i128 (128-bit integers), JavaScript also offers another data type to represent arbitrarily large integers: BigInt.
A BigInt can be defined as an integer literal suffixed by n:
jsconst b1 = 123n;
// Can be arbitrarily large.
const b2 = -1234567890987654321n;

BigInts can also be constructed from number values or string values using the BigInt constructor.
jsconst b1 = BigInt(123);
// Using a string prevents loss of precision, since long number
// literals don't represent what they seem like.
const b2 = BigInt("-1234567890987654321");

Conceptually, a BigInt is just an arbitrarily long sequence of bits which encodes an integer. You can safely do any arithmetic operations without losing precision or over-/underflowing.
jsconst integer = 12 ** 34; // 4.9222352429520264e+36; only has limited precision
const bigint = 12n ** 34n; // 4922235242952026704037113243122008064n

Compared to numbers, BigInt values yield higher precision when representing large integers; however, they cannot represent floating-point numbers. For example, division would round to zero:
jsconst bigintDiv = 5n / 2n; // 2n, because there's no 2.5 in BigInt

Math functions cannot be used on BigInt values. There is an open proposal to overload certain Math functions like Math.max() to allow BigInt values.
Choosing between BigInt and number depends on your use-case and your input's range. The precision of numbers should be able to accommodate most day-to-day tasks already, and BigInts are most suitable for handling binary data.
Read more about what you can do with BigInt values in the Expressions and Operators section, or the BigInt reference.StringsJavaScript's String type is used to represent textual data. It is a set of "elements" of 16-bit unsigned integer values (UTF-16 code units). Each element in the String occupies a position in the String. The first element is at index 0, the next at index 1, and so on. The length of a String is the number of elements in it. You can create strings using string literals or string objects.String literalsYou can declare strings in source code using either single or double quotes:
js'foo'
"bar"

Within a string literal, most characters can be entered literally. The only exceptions are the backslash (\, which starts an escape sequence), the quote character being used to enclose the string, which terminates the string, and the newline character, which is a syntax error if not preceded by a backslash.
More advanced strings can be created using escape sequences:
Hexadecimal escape sequences
The number after \x is interpreted as a hexadecimal number.
js"\xA9" // "©"

Unicode escape sequences
The Unicode escape sequences require at least four hexadecimal digits following \u.
js"\u00A9" // "©"

Unicode code point escapes
With Unicode code point escapes, any character can be escaped using hexadecimal numbers so that it is possible to use Unicode code points up to 0x10FFFF. With the four-digit Unicode escapes it is often necessary to write the surrogate halves separately to achieve the same result.
See also String.fromCodePoint() or String.prototype.codePointAt().
js"\u{2F804}"

// the same with simple Unicode escapes
"\uD87E\uDC04"
String objectYou can call methods directly on a string value:
jsconsole.log("hello".toUpperCase()); // HELLO

The following methods are available on String values:

Query: get the character or character code at a particular string index. Methods include at(), charAt(), charCodeAt(), and codePointAt().
Search: get information about a substring that conforms to a pattern, or test if a particular substring exists. Methods include indexOf(), lastIndexOf(), startsWith(), endsWith(), includes(), match(), matchAll(), and search()
Composition: combine strings into a longer string. Methods include padStart(), padEnd(), concat(), and repeat().
Decomposition: break a string into smaller strings. Methods include split(), slice(), substring(), substr(), trim(), trimStart(), and trimEnd().
Transformation: return a new string based on the current string's content. Methods include toLowerCase(), toUpperCase(), toLocaleLowerCase(), toLocaleUpperCase(), normalize(), and toWellFormed().

When working with strings, there are two other objects that provide important functionality for string manipulation: RegExp and Intl. They are introduced in regular expressions and internationalization respectively.Template literalsTemplate literals are string literals allowing embedded expressions. You can use multi-line strings and string interpolation features with them.
Template literals are enclosed by backtick (grave accent) characters (`) instead of double or single quotes. Template literals can contain placeholders. These are indicated by the dollar sign and curly braces (${expression}).Multi-linesAny new line characters inserted in the source are part of the template literal. Using normal strings, you would have to use the following syntax in order to get multi-line strings:
jsconsole.log(
  "string text line 1\n\
string text line 2",
);
// "string text line 1
// string text line 2"

To get the same effect with multi-line strings, you can now write:
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"
Embedded expressionsIn order to embed expressions within normal strings, you would use the following syntax:
jsconst five = 5;
const ten = 10;
console.log(
  "Fifteen is " + (five + ten) + " and not " + (2 * five + ten) + ".",
);
// "Fifteen is 15 and not 20."

Now, with template literals, you are able to make use of the syntactic sugar making substitutions like this more readable:
jsconst five = 5;
const ten = 10;
console.log(`Fifteen is ${five + ten} and not ${2 * five + ten}.`);
// "Fifteen is 15 and not 20."

For more information, read about Template literals in the JavaScript reference.
 Previous  Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nNumbers and strings 
 Previous  Next  
This chapter introduces the two most fundamental data types in JavaScript: numbers and strings. We will introduce their underlying representations, and functions used to work with and perform calculations on them.NumbersIn JavaScript, numbers are implemented in double-precision 64-bit binary format IEEE 754 (i.e., a number between ±2^−1022 and ±2^+1023, or about ±10^−308 to ±10^+308, with a numeric precision of 53 bits). Integer values up to ±2^53 − 1 can be represented exactly.
In addition to being able to represent floating-point numbers, the number type has three symbolic values: Infinity, -Infinity, and NaN (not-a-number).
See also JavaScript data types and structures for context with other primitive types in JavaScript.
You can use four types of number literals: decimal, binary, octal, and hexadecimal.Decimal numbersjs1234567890
42

Decimal literals can start with a zero (0) followed by another decimal digit, but if all digits after the leading 0 are smaller than 8, the number is interpreted as an octal number. This is considered a legacy syntax, and number literals prefixed with 0, whether interpreted as octal or decimal, cause a syntax error in strict mode — so, use the 0o prefix instead.
js0888 // 888 parsed as decimal
0777 // parsed as octal, 511 in decimal
Binary numbersBinary number syntax uses a leading zero followed by a lowercase or uppercase Latin letter "B" (0b or 0B). If the digits after the 0b are not 0 or 1, the following SyntaxError is thrown: "Missing binary digits after 0b".
js0b10000000000000000000000000000000 // 2147483648
0b01111111100000000000000000000000 // 2139095040
0B00000000011111111111111111111111 // 8388607
Octal numbersThe standard syntax for octal numbers is to prefix them with 0o. For example:
js0O755 // 493
0o644 // 420

There's also a legacy syntax for octal numbers — by prefixing the octal number with a zero: 0644 === 420 and "\045" === "%". If the digits after the 0 are outside the range 0 through 7, the number will be interpreted as a decimal number.
jsconst n = 0755; // 493
const m = 0644; // 420

Strict mode forbids this octal syntax.Hexadecimal numbersHexadecimal number syntax uses a leading zero followed by a lowercase or uppercase Latin letter "X" (0x or 0X). If the digits after 0x are outside the range (0123456789ABCDEF), the following SyntaxError is thrown: "Identifier starts immediately after numeric literal".
js0xFFFFFFFFFFFFFFFFF // 295147905179352830000
0x123456789ABCDEF   // 81985529216486900
0XA                 // 10
Exponentiationjs0e-5   // 0
0e+5   // 0
5e1    // 50
175e-2 // 1.75
1e3    // 1000
1e-3   // 0.001
1E3    // 1000
Number objectThe built-in Number object has properties for numerical constants, such as maximum value, not-a-number, and infinity. You cannot change the values of these properties and you use them as follows:
jsconst biggestNum = Number.MAX_VALUE;
const smallestNum = Number.MIN_VALUE;
const infiniteNum = Number.POSITIVE_INFINITY;
const negInfiniteNum = Number.NEGATIVE_INFINITY;
const notANum = Number.NaN;

You always refer to a property of the predefined Number object as shown above, and not as a property of a Number object you create yourself.
The following table summarizes the Number object's properties.



Property
Description




Number.MAX_VALUE
The largest positive representable number (1.7976931348623157e+308)


Number.MIN_VALUE
The smallest positive representable number (5e-324)


Number.NaN
Special "not a number" value


Number.NEGATIVE_INFINITY
Special negative infinite value; returned on overflow


Number.POSITIVE_INFINITY
Special positive infinite value; returned on overflow


Number.EPSILON
Difference between 1 and the smallest value greater than 1 that can be represented as a Number (2.220446049250313e-16)


Number.MIN_SAFE_INTEGER
Minimum safe integer in JavaScript (−2^53 + 1, or −9007199254740991)


Number.MAX_SAFE_INTEGER
Maximum safe integer in JavaScript (+2^53 − 1, or +9007199254740991)






Method
Description




Number.parseFloat()
Parses a string argument and returns a floating point number. Same as the global parseFloat() function.


Number.parseInt()
Parses a string argument and returns an integer of the specified radix or base. Same as the global parseInt() function.


Number.isFinite()
Determines whether the passed value is a finite number.


Number.isInteger()
Determines whether the passed value is an integer.


Number.isNaN()
Determines whether the passed value is NaN. More robust version of the original global isNaN().


Number.isSafeInteger()
Determines whether the provided value is a number that is a safe integer.



The Number prototype provides methods for retrieving information from Number objects in various formats. The following table summarizes the methods of Number.prototype.



Method
Description




toExponential()
Returns a string representing the number in exponential notation.


toFixed()
Returns a string representing the number in fixed-point notation.


toPrecision()
Returns a string representing the number to a specified precision in fixed-point notation.


Math objectThe built-in Math object has properties and methods for mathematical constants and functions. For example, the Math object's PI property has the value of pi (3.141…), which you would use in an application as
jsMath.PI;

Similarly, standard mathematical functions are methods of Math. These include trigonometric, logarithmic, exponential, and other functions. For example, if you want to use the trigonometric function sine, you would write
jsMath.sin(1.56);

Note that all trigonometric methods of Math take arguments in radians.
The following table summarizes the Math object's methods.

  
    Methods of
    Math
  
  
    
      Method
      Description
    
  
  
    
      abs()
      Absolute value
    
    
      
        sin(),
        cos(),
        tan()
      
      Standard trigonometric functions; with the argument in radians.
    
    
      
        asin(),
        acos(),
        atan(),
        atan2()
      
      Inverse trigonometric functions; return values in radians.
    
    
      
        sinh(),
        cosh(),
        tanh()
      
      Hyperbolic functions; argument in hyperbolic angle.
    
    
      
        asinh(),
        acosh(),
        atanh()
      
      Inverse hyperbolic functions; return values in hyperbolic angle.
    
    
      
        
          pow(),
          exp(),
          expm1(),
          log(),
          log10(),
          log1p(),
          log2()
        
      
      Exponential and logarithmic functions.
    
    
      
        floor(),
        ceil()
      
      
        Returns the largest/smallest integer less/greater than or equal to an
        argument.
      
    
    
      
        min(),
        max()
      
      
        Returns the minimum or maximum (respectively) value of a comma separated
        list of numbers as arguments.
      
    
    
      random()
      Returns a random number between 0 and 1.
    
    
      
        round(),
        fround(),
        trunc(),
      
      Rounding and truncation functions.
    
    
      
        sqrt(),
        cbrt(),
        hypot()
      
      
        Square root, cube root, Square root of the sum of square arguments.
      
    
    
      sign()
      
        The sign of a number, indicating whether the number is positive,
        negative or zero.
      
    
    
      
        clz32(),imul()
      
      
        Number of leading zero bits in the 32-bit binary representation.The
        result of the C-like 32-bit multiplication of the two arguments.
      
    
  

Unlike many other objects, you never create a Math object of your own. You always use the built-in Math object.BigIntsOne shortcoming of number values is they only have 64 bits. In practice, due to using IEEE 754 encoding, they cannot represent any integer larger than Number.MAX_SAFE_INTEGER (which is 253 - 1) accurately. To solve the need of encoding binary data and to interoperate with other languages that offer wide integers like i64 (64-bit integers) and i128 (128-bit integers), JavaScript also offers another data type to represent arbitrarily large integers: BigInt.
A BigInt can be defined as an integer literal suffixed by n:
jsconst b1 = 123n;
// Can be arbitrarily large.
const b2 = -1234567890987654321n;

BigInts can also be constructed from number values or string values using the BigInt constructor.
jsconst b1 = BigInt(123);
// Using a string prevents loss of precision, since long number
// literals don't represent what they seem like.
const b2 = BigInt("-1234567890987654321");

Conceptually, a BigInt is just an arbitrarily long sequence of bits which encodes an integer. You can safely do any arithmetic operations without losing precision or over-/underflowing.
jsconst integer = 12 ** 34; // 4.9222352429520264e+36; only has limited precision
const bigint = 12n ** 34n; // 4922235242952026704037113243122008064n

Compared to numbers, BigInt values yield higher precision when representing large integers; however, they cannot represent floating-point numbers. For example, division would round to zero:
jsconst bigintDiv = 5n / 2n; // 2n, because there's no 2.5 in BigInt

Math functions cannot be used on BigInt values. There is an open proposal to overload certain Math functions like Math.max() to allow BigInt values.
Choosing between BigInt and number depends on your use-case and your input's range. The precision of numbers should be able to accommodate most day-to-day tasks already, and BigInts are most suitable for handling binary data.
Read more about what you can do with BigInt values in the Expressions and Operators section, or the BigInt reference.StringsJavaScript's String type is used to represent textual data. It is a set of "elements" of 16-bit unsigned integer values (UTF-16 code units). Each element in the String occupies a position in the String. The first element is at index 0, the next at index 1, and so on. The length of a String is the number of elements in it. You can create strings using string literals or string objects.String literalsYou can declare strings in source code using either single or double quotes:
js'foo'
"bar"

Within a string literal, most characters can be entered literally. The only exceptions are the backslash (\, which starts an escape sequence), the quote character being used to enclose the string, which terminates the string, and the newline character, which is a syntax error if not preceded by a backslash.
More advanced strings can be created using escape sequences:
Hexadecimal escape sequences
The number after \x is interpreted as a hexadecimal number.
js"\xA9" // "©"

Unicode escape sequences
The Unicode escape sequences require at least four hexadecimal digits following \u.
js"\u00A9" // "©"

Unicode code point escapes
With Unicode code point escapes, any character can be escaped using hexadecimal numbers so that it is possible to use Unicode code points up to 0x10FFFF. With the four-digit Unicode escapes it is often necessary to write the surrogate halves separately to achieve the same result.
See also String.fromCodePoint() or String.prototype.codePointAt().
js"\u{2F804}"

// the same with simple Unicode escapes
"\uD87E\uDC04"
String objectYou can call methods directly on a string value:
jsconsole.log("hello".toUpperCase()); // HELLO

The following methods are available on String values:

Query: get the character or character code at a particular string index. Methods include at(), charAt(), charCodeAt(), and codePointAt().
Search: get information about a substring that conforms to a pattern, or test if a particular substring exists. Methods include indexOf(), lastIndexOf(), startsWith(), endsWith(), includes(), match(), matchAll(), and search()
Composition: combine strings into a longer string. Methods include padStart(), padEnd(), concat(), and repeat().
Decomposition: break a string into smaller strings. Methods include split(), slice(), substring(), substr(), trim(), trimStart(), and trimEnd().
Transformation: return a new string based on the current string's content. Methods include toLowerCase(), toUpperCase(), toLocaleLowerCase(), toLocaleUpperCase(), normalize(), and toWellFormed().

When working with strings, there are two other objects that provide important functionality for string manipulation: RegExp and Intl. They are introduced in regular expressions and internationalization respectively.Template literalsTemplate literals are string literals allowing embedded expressions. You can use multi-line strings and string interpolation features with them.
Template literals are enclosed by backtick (grave accent) characters (`) instead of double or single quotes. Template literals can contain placeholders. These are indicated by the dollar sign and curly braces (${expression}).Multi-linesAny new line characters inserted in the source are part of the template literal. Using normal strings, you would have to use the following syntax in order to get multi-line strings:
jsconsole.log(
  "string text line 1\n\
string text line 2",
);
// "string text line 1
// string text line 2"

To get the same effect with multi-line strings, you can now write:
jsconsole.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"
Embedded expressionsIn order to embed expressions within normal strings, you would use the following syntax:
jsconst five = 5;
const ten = 10;
console.log(
  "Fifteen is " + (five + ten) + " and not " + (2 * five + ten) + ".",
);
// "Fifteen is 15 and not 20."

Now, with template literals, you are able to make use of the syntactic sugar making substitutions like this more readable:
jsconst five = 5;
const ten = 10;
console.log(`Fifteen is ${five + ten} and not ${2 * five + ten}.`);
// "Fifteen is 15 and not 20."

For more information, read about Template literals in the JavaScript reference.
 Previous  Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nRepresenting dates & times 
 Previous  Next  

Note:
The Date object is now considered legacy and should be avoided in new code. We will update this page with modern alternatives soon.
Date objectJavaScript does not have a date data type. However, you can use the Date object and its methods to work with dates and times in your applications. The Date object has a large number of methods for setting, getting, and manipulating dates. It does not have any properties.
JavaScript handles dates similarly to Java. The two languages have many of the same date methods, and both languages store dates as the number of milliseconds since midnight at the beginning of January 1, 1970, UTC, with a Unix Timestamp being the number of seconds since the same instant. The instant at the midnight at the beginning of January 1, 1970, UTC is called the epoch.
The Date object range is -100,000,000 days to 100,000,000 days relative to the epoch.
To create a Date object:
jsconst dateObjectName = new Date([parameters]);

where dateObjectName is the name of the Date object being created; it can be a new object or a property of an existing object.
Calling Date without the new keyword returns a string representing the current date and time.
The parameters in the preceding syntax can be any of the following:

Nothing: creates today's date and time. For example, today = new Date();.
A string representing a date, in many different forms. The exact forms supported differ among engines, but the following form is always supported: YYYY-MM-DDTHH:mm:ss.sssZ. For example, xmas95 = new Date("1995-12-25"). If you omit hours, minutes, or seconds, the value will be set to zero.
A set of integer values for year, month, and day. For example, xmas95 = new Date(1995, 11, 25).
A set of integer values for year, month, day, hour, minute, and seconds. For example, xmas95 = new Date(1995, 11, 25, 9, 30, 0);.
Methods of the Date objectThe Date object methods for handling dates and times fall into these broad categories:

"set" methods, for setting date and time values in Date objects.
"get" methods, for getting date and time values from Date objects.
"to" methods, for returning string values from Date objects.
parse and UTC methods, for parsing Date strings.

With the "get" and "set" methods you can get and set seconds, minutes, hours, day of the month, day of the week, months, and years separately. There is a getDay method that returns the day of the week, but no corresponding setDay method, because the day of the week is set automatically. These methods use integers to represent these values as follows:

Seconds and minutes: 0 to 59
Hours: 0 to 23
Day: 0 (Sunday) to 6 (Saturday)
Date: 1 to 31 (day of the month)
Months: 0 (January) to 11 (December)
Year: years since 1900

For example, suppose you define the following date:
jsconst xmas95 = new Date("1995-12-25");

Then xmas95.getMonth() returns 11, and xmas95.getFullYear() returns 1995.
The getTime and setTime methods are useful for comparing dates. The getTime method returns the number of milliseconds since the epoch for a Date object.
For example, the following code displays the number of days left in the current year:
jsconst today = new Date();
const endYear = new Date(1995, 11, 31, 23, 59, 59, 999); // Set day and month
endYear.setFullYear(today.getFullYear()); // Set year to this year
const msPerDay = 24 * 60 * 60 * 1000; // Number of milliseconds per day
let daysLeft = (endYear.getTime() - today.getTime()) / msPerDay;
daysLeft = Math.round(daysLeft); // Returns days left in the year

This example creates a Date object named today that contains today's date. It then creates a Date object named endYear and sets the year to the current year. Then, using the number of milliseconds per day, it computes the number of days between today and endYear, using getTime and rounding to a whole number of days.
The parse method is useful for assigning values from date strings to existing Date objects. For example, the following code uses parse and setTime to assign a date value to the ipoDate object:
jsconst ipoDate = new Date();
ipoDate.setTime(Date.parse("Aug 9, 1995"));
ExampleIn the following example, the function JSClock() returns the time in the format of a digital clock.
jsfunction JSClock() {
  const time = new Date();
  const hour = time.getHours();
  const minute = time.getMinutes();
  const second = time.getSeconds();
  let temp = String(hour % 12);
  if (temp === "0") {
    temp = "12";
  }
  temp += (minute < 10 ? ":0" : ":") + minute;
  temp += (second < 10 ? ":0" : ":") + second;
  temp += hour >= 12 ? " P.M." : " A.M.";
  return temp;
}

The JSClock function first creates a new Date object called time; since no arguments are given, time is created with the current date and time. Then calls to the getHours, getMinutes, and getSeconds methods assign the value of the current hour, minute, and second to hour, minute, and second.
The following statements build a string value based on the time. The first statement creates a variable temp. Its value is hour % 12, which is hour in the 12-hour system. Then, if the hour is 0, it gets re-assigned to 12, so that midnights and noons are displayed as 12:00 instead of 0:00.
The next statement appends a minute value to temp. If the value of minute is less than 10, the conditional expression adds a string with a preceding zero; otherwise it adds a string with a demarcating colon. Then a statement appends a seconds value to temp in the same way.
Finally, a conditional expression appends "P.M." to temp if hour is 12 or greater; otherwise, it appends "A.M." to temp.
 Previous  Next\n\nRepresenting dates & times 
 Previous  Next  

Note:
The Date object is now considered legacy and should be avoided in new code. We will update this page with modern alternatives soon.
Date objectJavaScript does not have a date data type. However, you can use the Date object and its methods to work with dates and times in your applications. The Date object has a large number of methods for setting, getting, and manipulating dates. It does not have any properties.
JavaScript handles dates similarly to Java. The two languages have many of the same date methods, and both languages store dates as the number of milliseconds since midnight at the beginning of January 1, 1970, UTC, with a Unix Timestamp being the number of seconds since the same instant. The instant at the midnight at the beginning of January 1, 1970, UTC is called the epoch.
The Date object range is -100,000,000 days to 100,000,000 days relative to the epoch.
To create a Date object:
jsconst dateObjectName = new Date([parameters]);

where dateObjectName is the name of the Date object being created; it can be a new object or a property of an existing object.
Calling Date without the new keyword returns a string representing the current date and time.
The parameters in the preceding syntax can be any of the following:

Nothing: creates today's date and time. For example, today = new Date();.
A string representing a date, in many different forms. The exact forms supported differ among engines, but the following form is always supported: YYYY-MM-DDTHH:mm:ss.sssZ. For example, xmas95 = new Date("1995-12-25"). If you omit hours, minutes, or seconds, the value will be set to zero.
A set of integer values for year, month, and day. For example, xmas95 = new Date(1995, 11, 25).
A set of integer values for year, month, day, hour, minute, and seconds. For example, xmas95 = new Date(1995, 11, 25, 9, 30, 0);.
Methods of the Date objectThe Date object methods for handling dates and times fall into these broad categories:

"set" methods, for setting date and time values in Date objects.
"get" methods, for getting date and time values from Date objects.
"to" methods, for returning string values from Date objects.
parse and UTC methods, for parsing Date strings.

With the "get" and "set" methods you can get and set seconds, minutes, hours, day of the month, day of the week, months, and years separately. There is a getDay method that returns the day of the week, but no corresponding setDay method, because the day of the week is set automatically. These methods use integers to represent these values as follows:

Seconds and minutes: 0 to 59
Hours: 0 to 23
Day: 0 (Sunday) to 6 (Saturday)
Date: 1 to 31 (day of the month)
Months: 0 (January) to 11 (December)
Year: years since 1900

For example, suppose you define the following date:
jsconst xmas95 = new Date("1995-12-25");

Then xmas95.getMonth() returns 11, and xmas95.getFullYear() returns 1995.
The getTime and setTime methods are useful for comparing dates. The getTime method returns the number of milliseconds since the epoch for a Date object.
For example, the following code displays the number of days left in the current year:
jsconst today = new Date();
const endYear = new Date(1995, 11, 31, 23, 59, 59, 999); // Set day and month
endYear.setFullYear(today.getFullYear()); // Set year to this year
const msPerDay = 24 * 60 * 60 * 1000; // Number of milliseconds per day
let daysLeft = (endYear.getTime() - today.getTime()) / msPerDay;
daysLeft = Math.round(daysLeft); // Returns days left in the year

This example creates a Date object named today that contains today's date. It then creates a Date object named endYear and sets the year to the current year. Then, using the number of milliseconds per day, it computes the number of days between today and endYear, using getTime and rounding to a whole number of days.
The parse method is useful for assigning values from date strings to existing Date objects. For example, the following code uses parse and setTime to assign a date value to the ipoDate object:
jsconst ipoDate = new Date();
ipoDate.setTime(Date.parse("Aug 9, 1995"));
ExampleIn the following example, the function JSClock() returns the time in the format of a digital clock.
jsfunction JSClock() {
  const time = new Date();
  const hour = time.getHours();
  const minute = time.getMinutes();
  const second = time.getSeconds();
  let temp = String(hour % 12);
  if (temp === "0") {
    temp = "12";
  }
  temp += (minute < 10 ? ":0" : ":") + minute;
  temp += (second < 10 ? ":0" : ":") + second;
  temp += hour >= 12 ? " P.M." : " A.M.";
  return temp;
}

The JSClock function first creates a new Date object called time; since no arguments are given, time is created with the current date and time. Then calls to the getHours, getMinutes, and getSeconds methods assign the value of the current hour, minute, and second to hour, minute, and second.
The following statements build a string value based on the time. The first statement creates a variable temp. Its value is hour % 12, which is hour in the 12-hour system. Then, if the hour is 0, it gets re-assigned to 12, so that midnights and noons are displayed as 12:00 instead of 0:00.
The next statement appends a minute value to temp. If the value of minute is less than 10, the conditional expression adds a string with a preceding zero; otherwise it adds a string with a demarcating colon. Then a statement appends a seconds value to temp in the same way.
Finally, a conditional expression appends "P.M." to temp if hour is 12 or greater; otherwise, it appends "A.M." to temp.
 Previous  Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jan 20, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nRepresenting dates & times 
 Previous  Next  

Note:
The Date object is now considered legacy and should be avoided in new code. We will update this page with modern alternatives soon.
Date objectJavaScript does not have a date data type. However, you can use the Date object and its methods to work with dates and times in your applications. The Date object has a large number of methods for setting, getting, and manipulating dates. It does not have any properties.
JavaScript handles dates similarly to Java. The two languages have many of the same date methods, and both languages store dates as the number of milliseconds since midnight at the beginning of January 1, 1970, UTC, with a Unix Timestamp being the number of seconds since the same instant. The instant at the midnight at the beginning of January 1, 1970, UTC is called the epoch.
The Date object range is -100,000,000 days to 100,000,000 days relative to the epoch.
To create a Date object:
jsconst dateObjectName = new Date([parameters]);

where dateObjectName is the name of the Date object being created; it can be a new object or a property of an existing object.
Calling Date without the new keyword returns a string representing the current date and time.
The parameters in the preceding syntax can be any of the following:

Nothing: creates today's date and time. For example, today = new Date();.
A string representing a date, in many different forms. The exact forms supported differ among engines, but the following form is always supported: YYYY-MM-DDTHH:mm:ss.sssZ. For example, xmas95 = new Date("1995-12-25"). If you omit hours, minutes, or seconds, the value will be set to zero.
A set of integer values for year, month, and day. For example, xmas95 = new Date(1995, 11, 25).
A set of integer values for year, month, day, hour, minute, and seconds. For example, xmas95 = new Date(1995, 11, 25, 9, 30, 0);.
Methods of the Date objectThe Date object methods for handling dates and times fall into these broad categories:

"set" methods, for setting date and time values in Date objects.
"get" methods, for getting date and time values from Date objects.
"to" methods, for returning string values from Date objects.
parse and UTC methods, for parsing Date strings.

With the "get" and "set" methods you can get and set seconds, minutes, hours, day of the month, day of the week, months, and years separately. There is a getDay method that returns the day of the week, but no corresponding setDay method, because the day of the week is set automatically. These methods use integers to represent these values as follows:

Seconds and minutes: 0 to 59
Hours: 0 to 23
Day: 0 (Sunday) to 6 (Saturday)
Date: 1 to 31 (day of the month)
Months: 0 (January) to 11 (December)
Year: years since 1900

For example, suppose you define the following date:
jsconst xmas95 = new Date("1995-12-25");

Then xmas95.getMonth() returns 11, and xmas95.getFullYear() returns 1995.
The getTime and setTime methods are useful for comparing dates. The getTime method returns the number of milliseconds since the epoch for a Date object.
For example, the following code displays the number of days left in the current year:
jsconst today = new Date();
const endYear = new Date(1995, 11, 31, 23, 59, 59, 999); // Set day and month
endYear.setFullYear(today.getFullYear()); // Set year to this year
const msPerDay = 24 * 60 * 60 * 1000; // Number of milliseconds per day
let daysLeft = (endYear.getTime() - today.getTime()) / msPerDay;
daysLeft = Math.round(daysLeft); // Returns days left in the year

This example creates a Date object named today that contains today's date. It then creates a Date object named endYear and sets the year to the current year. Then, using the number of milliseconds per day, it computes the number of days between today and endYear, using getTime and rounding to a whole number of days.
The parse method is useful for assigning values from date strings to existing Date objects. For example, the following code uses parse and setTime to assign a date value to the ipoDate object:
jsconst ipoDate = new Date();
ipoDate.setTime(Date.parse("Aug 9, 1995"));
ExampleIn the following example, the function JSClock() returns the time in the format of a digital clock.
jsfunction JSClock() {
  const time = new Date();
  const hour = time.getHours();
  const minute = time.getMinutes();
  const second = time.getSeconds();
  let temp = String(hour % 12);
  if (temp === "0") {
    temp = "12";
  }
  temp += (minute < 10 ? ":0" : ":") + minute;
  temp += (second < 10 ? ":0" : ":") + second;
  temp += hour >= 12 ? " P.M." : " A.M.";
  return temp;
}

The JSClock function first creates a new Date object called time; since no arguments are given, time is created with the current date and time. Then calls to the getHours, getMinutes, and getSeconds methods assign the value of the current hour, minute, and second to hour, minute, and second.
The following statements build a string value based on the time. The first statement creates a variable temp. Its value is hour % 12, which is hour in the 12-hour system. Then, if the hour is 0, it gets re-assigned to 12, so that midnights and noons are displayed as 12:00 instead of 0:00.
The next statement appends a minute value to temp. If the value of minute is less than 10, the conditional expression adds a string with a preceding zero; otherwise it adds a string with a demarcating colon. Then a statement appends a seconds value to temp in the same way.
Finally, a conditional expression appends "P.M." to temp if hour is 12 or greater; otherwise, it appends "A.M." to temp.
 Previous  Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jan 20, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nRegular expressions 
 Previous  Next  
Regular expressions are patterns used to match character combinations in strings.
In JavaScript, regular expressions are also objects. These patterns are used with the exec() and test() methods of RegExp, and with the match(), matchAll(), replace(), replaceAll(), search(), and split() methods of String.
This chapter describes JavaScript regular expressions. It provides a brief overview of each syntax element. For a detailed explanation of each one's semantics, read the regular expressions reference.Creating a regular expressionYou construct a regular expression in one of two ways:


Using a regular expression literal, which consists of a pattern enclosed between slashes, as follows:
jsconst re = /ab+c/;

Regular expression literals provide compilation of the regular expression when the script is loaded.
If the regular expression remains constant, using this can improve performance.


Or calling the constructor function of the RegExp object, as follows:
jsconst re = new RegExp("ab+c");

Using the constructor function provides runtime compilation of the regular expression.
Use the constructor function when you know the regular expression pattern will be changing, or you don't know the pattern and are getting it from another source, such as user input.

Writing a regular expression patternA regular expression pattern is composed of simple characters, such as /abc/, or a combination of simple and special characters, such as /ab*c/ or /Chapter (\d+)\.\d*/.
The last example includes parentheses, which are used as a memory device.
The match made with this part of the pattern is remembered for later use, as described in Using groups.Using simple patternsSimple patterns are constructed of characters for which you want to find a direct match. For example, the pattern /abc/ matches character combinations in strings only when the exact sequence "abc" occurs (all characters together and in that order).
Such a match would succeed in the strings "Hi, do you know your abc's?" and "The latest airplane designs evolved from slabcraft.".
In both cases the match is with the substring "abc".
There is no match in the string "Grab crab" because while it contains the substring "ab c", it does not contain the exact substring "abc".Using special charactersWhen the search for a match requires something more than a direct match, such as finding one or more b's, or finding white space, you can include special characters in the pattern.
For example, to match a single "a" followed by zero or more "b"s followed by "c", you'd use the pattern /ab*c/: the * after "b" means "0 or more occurrences of the preceding item."
In the string "cbbabbbbcdebc", this pattern will match the substring "abbbbc".
The following pages provide lists of the different special characters that fit into each category, along with descriptions and examples.

Assertions guide

Assertions include boundaries, which indicate the beginnings and endings of lines and words, and other patterns indicating in some way that a match is possible (including look-ahead, look-behind, and conditional expressions).

Character classes guide

Distinguish different types of characters. For example, distinguishing between letters and digits.

Groups and backreferences guide

Groups group multiple patterns as a whole, and capturing groups provide extra submatch information when using a regular expression pattern to match against a string. Backreferences refer to a previously captured group in the same regular expression.

Quantifiers guide

Indicate numbers of characters or expressions to match.


If you want to look at all the special characters that can be used in regular expressions in a single table, see the following:

  
    Special characters in regular expressions.
  
  
    
      Characters / constructs
      Corresponding article
    
  
  
    
      
        [xyz], [^xyz], .,
        \d, \D, \w, \W,
         , \S, \t, \r,
        \n, \v, \f, [\b],
        \0, \cX, \xhh,
        \uhhhh, \u{hhhh},
        x|y
      
      
        
          Character classes
        
      
    
    
      
        ^, $, \b, \B,
        x(?=y), x(?!y), (?<=y)x,
        (?<!y)x
      
      
        
          Assertions
        
      
    
    
      
        (x), (?<Name>x), (?:x),
        \n, \k<Name>
      
      
        
          Groups and backreferences
        
      
    
    
      
        x*, x+, x?,
        x{n}, x{n,},
        x{n,m}
      
      
        
          Quantifiers
        
      
    
  


Note: A larger cheat sheet is also available (only aggregating parts of those individual articles).
EscapingIf you need to use any of the special characters literally (actually searching for a "*", for instance), you must escape it by putting a backslash in front of it.
For instance, to search for "a" followed by "*" followed by "b", you'd use /a\*b/ — the backslash "escapes" the "*", making it literal instead of special.
Similarly, if you're writing a regular expression literal and need to match a slash ("/"), you need to escape that (otherwise, it terminates the pattern).
For instance, to search for the string "/example/" followed by one or more alphabetic characters, you'd use /\/example\/[a-z]+/i—the backslashes before each slash make them literal.
To match a literal backslash, you need to escape the backslash.
For instance, to match the string "C:\" where "C" can be any letter, you'd use /[A-Z]:\\/ — the first backslash escapes the one after it, so the expression searches for a single literal backslash.
If using the RegExp constructor with a string literal, remember that the backslash is an escape in string literals, so to use it in the regular expression, you need to escape it at the string literal level.
/a\*b/ and new RegExp("a\\*b") create the same expression, which searches for "a" followed by a literal "*" followed by "b".
The RegExp.escape() function returns a new string where all special characters in regex syntax are escaped. This allows you to do new RegExp(RegExp.escape("a*b")) to create a regular expression that matches only the string "a*b".Using parenthesesParentheses around any part of the regular expression pattern causes that part of the matched substring to be remembered.
Once remembered, the substring can be recalled for other use. See Groups and backreferences for more details.Using regular expressions in JavaScriptRegular expressions are used with the RegExp methods test() and exec() and with the String methods match(), matchAll(), replace(), replaceAll(), search(), and split().



Method
Description




exec()
Executes a search for a match in a string. It returns an array of information or null on a mismatch.


test()
Tests for a match in a string. It returns true or false.


match()
Returns an array containing all of the matches, including capturing groups, or null if no match is found.


matchAll()
Returns an iterator containing all of the matches, including capturing groups.


search()
Tests for a match in a string. It returns the index of the match, or -1 if the search fails.


replace()
Executes a search for a match in a string, and replaces the matched substring with a replacement substring.


replaceAll()
Executes a search for all matches in a string, and replaces the matched substrings with a replacement substring.


split()
Uses a regular expression or a fixed string to break a string into an array of substrings.



When you want to know whether a pattern is found in a string, use the test() or search() methods; for more information (but slower execution) use the exec() or match() methods.
If you use exec() or match() and if the match succeeds, these methods return an array and update properties of the associated regular expression object and also of the predefined regular expression object, RegExp.
If the match fails, the exec() method returns null (which coerces to false).
In the following example, the script uses the exec() method to find a match in a string.
jsconst myRe = /d(b+)d/g;
const myArray = myRe.exec("cdbbdbsbz");

If you do not need to access the properties of the regular expression, an alternative way of creating myArray is with this script:
jsconst myArray = /d(b+)d/g.exec("cdbbdbsbz");
// similar to 'cdbbdbsbz'.match(/d(b+)d/g); however,
// 'cdbbdbsbz'.match(/d(b+)d/g) outputs [ "dbbd" ]
// while /d(b+)d/g.exec('cdbbdbsbz') outputs [ 'dbbd', 'bb', index: 1, input: 'cdbbdbsbz' ]

(See Using the global search flag with exec() for further info about the different behaviors.)
If you want to construct the regular expression from a string, yet another alternative is this script:
jsconst myRe = new RegExp("d(b+)d", "g");
const myArray = myRe.exec("cdbbdbsbz");

With these scripts, the match succeeds and returns the array and updates the properties shown in the following table.

  
    Results of regular expression execution.
  
  
    
      Object
      Property or index
      Description
      In this example
    
  
  
    
      myArray
      
      The matched string and all remembered substrings.
      ['dbbd', 'bb', index: 1, input: 'cdbbdbsbz']
    
    
      index
      The 0-based index of the match in the input string.
      1
    
    
      input
      The original string.
      'cdbbdbsbz'
    
    
      [0]
      The last matched characters.
      'dbbd'
    
    
      myRe
      lastIndex
      The index at which to start the next match.
        (This property is set only if the regular expression uses the g option, described in
        Advanced Searching With Flags.)
      
      5
    
    
      source
      
        The text of the pattern. Updated at the time that the regular expression is created, not executed.
      
      'd(b+)d'
    
  

As shown in the second form of this example, you can use a regular expression created with an object initializer without assigning it to a variable.
If you do, however, every occurrence is a new regular expression.
For this reason, if you use this form without assigning it to a variable, you cannot subsequently access the properties of that regular expression.
For example, assume you have this script:
jsconst myRe = /d(b+)d/g;
const myArray = myRe.exec("cdbbdbsbz");
console.log(`The value of lastIndex is ${myRe.lastIndex}`);

// "The value of lastIndex is 5"

However, if you have this script:
jsconst myArray = /d(b+)d/g.exec("cdbbdbsbz");
console.log(`The value of lastIndex is ${/d(b+)d/g.lastIndex}`);

// "The value of lastIndex is 0"

The occurrences of /d(b+)d/g in the two statements are different regular expression objects and hence have different values for their lastIndex property.
If you need to access the properties of a regular expression created with an object initializer, you should first assign it to a variable.Advanced searching with flagsRegular expressions have optional flags that allow for functionality like global searching and case-insensitive searching.
These flags can be used separately or together in any order, and are included as part of the regular expression.



Flag
Description
Corresponding property




d
Generate indices for substring matches.
hasIndices


g
Global search.
global


i
Case-insensitive search.
ignoreCase


m
Makes ^ and $ match the start and end of each line instead of those of the entire string.
multiline


s
Allows . to match newline characters.
dotAll


u
"Unicode"; treat a pattern as a sequence of Unicode code points.
unicode


v
An upgrade to the u mode with more Unicode features.
unicodeSets


y
Perform a "sticky" search that matches starting at the current position in the target string.
sticky



To include a flag with the regular expression, use this syntax:
jsconst re = /pattern/flags;

or
jsconst re = new RegExp("pattern", "flags");

Note that the flags are an integral part of a regular expression. They cannot be added or removed later.
For example, re = /\w+ /g creates a regular expression that looks for one or more characters followed by a space, and it looks for this combination throughout the string.
jsconst re = /\w+ /g;
const str = "fee fi fo fum";
const myArray = str.match(re);
console.log(myArray);

// ["fee ", "fi ", "fo "]

You could replace the line:
jsconst re = /\w+ /g;

with:
jsconst re = new RegExp("\\w+\ ", "g");

and get the same result.
The m flag is used to specify that a multiline input string should be treated as multiple lines.
If the m flag is used, ^ and $ match at the start or end of any line within the input string instead of the start or end of the entire string.
The i, m, and s flags can be enabled or disabled for specific parts of a regex using the modifier syntax.
Using the global search flag with exec()
RegExp.prototype.exec() method with the g flag returns each match and its position iteratively.
jsconst str = "fee fi fo fum";
const re = /\w+ /g;

console.log(re.exec(str)); // ["fee ", index: 0, input: "fee fi fo fum"]
console.log(re.exec(str)); // ["fi ", index: 4, input: "fee fi fo fum"]
console.log(re.exec(str)); // ["fo ", index: 7, input: "fee fi fo fum"]
console.log(re.exec(str)); // null

In contrast, String.prototype.match() method returns all matches at once, but without their position.
jsconsole.log(str.match(re)); // ["fee ", "fi ", "fo "]

Using unicode regular expressions
The u flag is used to create "unicode" regular expressions; that is, regular expressions which support matching against unicode text. An important feature that's enabled in unicode mode is Unicode property escapes. For example, the following regular expression might be used to match against an arbitrary unicode "word":
js/\p{L}*/u;

Unicode regular expressions have different execution behavior as well. RegExp.prototype.unicode contains more explanation about this.Examples
Note:
Several examples are also available in:

The reference pages for exec(), test(), match(), matchAll(), search(), replace(), split()
The guide articles: character classes, assertions, groups and backreferences, quantifiers

Using special characters to verify inputIn the following example, the user is expected to enter a phone number.
When the user presses the "Check" button, the script checks the validity of the number.
If the number is valid (matches the character sequence specified by the regular expression), the script shows a message thanking the user and confirming the number.
If the number is invalid, the script informs the user that the phone number is not valid.
The regular expression looks for:

the beginning of the line of data: ^
followed by three numeric characters \d{3} OR | a left parenthesis \(, followed by three digits \d{3}, followed by a close parenthesis \), in a non-capturing group (?:)
followed by one dash, forward slash, or decimal point in a capturing group ()
followed by three digits \d{3}
followed by the match remembered in the (first) captured group \1
followed by four digits \d{4}
followed by the end of the line of data: $

HTML
html<p>
  Enter your phone number (with area code) and then click "Check".
  <br />
  The expected format is like ###-###-####.
</p>
<form id="form">
  <input id="phone" />
  <button type="submit">Check</button>
</form>
<p id="output"></p>

JavaScript
jsconst form = document.querySelector("#form");
const input = document.querySelector("#phone");
const output = document.querySelector("#output");

const re = /^(?:\d{3}|\(\d{3}\))([-/.])\d{3}\1\d{4}$/;

function testInfo(phoneInput) {
  const ok = re.exec(phoneInput.value);

  output.textContent = ok
    ? `Thanks, your phone number is ${ok[0]}`
    : `${phoneInput.value} isn't a phone number with area code!`;
}

form.addEventListener("submit", (event) => {
  event.preventDefault();
  testInfo(input);
});

Result
Tools
RegExr

An online tool to learn, build, & test Regular Expressions.

Regex tester

An online regex builder/debugger

Regex interactive tutorial

An online interactive tutorials, Cheat sheet, & Playground.

Regex visualizer

An online visual regex tester.


 Previous  Next\n\nRegular expressions 
 Previous  Next  
Regular expressions are patterns used to match character combinations in strings.
In JavaScript, regular expressions are also objects. These patterns are used with the exec() and test() methods of RegExp, and with the match(), matchAll(), replace(), replaceAll(), search(), and split() methods of String.
This chapter describes JavaScript regular expressions. It provides a brief overview of each syntax element. For a detailed explanation of each one's semantics, read the regular expressions reference.Creating a regular expressionYou construct a regular expression in one of two ways:


Using a regular expression literal, which consists of a pattern enclosed between slashes, as follows:
jsconst re = /ab+c/;

Regular expression literals provide compilation of the regular expression when the script is loaded.
If the regular expression remains constant, using this can improve performance.


Or calling the constructor function of the RegExp object, as follows:
jsconst re = new RegExp("ab+c");

Using the constructor function provides runtime compilation of the regular expression.
Use the constructor function when you know the regular expression pattern will be changing, or you don't know the pattern and are getting it from another source, such as user input.

Writing a regular expression patternA regular expression pattern is composed of simple characters, such as /abc/, or a combination of simple and special characters, such as /ab*c/ or /Chapter (\d+)\.\d*/.
The last example includes parentheses, which are used as a memory device.
The match made with this part of the pattern is remembered for later use, as described in Using groups.Using simple patternsSimple patterns are constructed of characters for which you want to find a direct match. For example, the pattern /abc/ matches character combinations in strings only when the exact sequence "abc" occurs (all characters together and in that order).
Such a match would succeed in the strings "Hi, do you know your abc's?" and "The latest airplane designs evolved from slabcraft.".
In both cases the match is with the substring "abc".
There is no match in the string "Grab crab" because while it contains the substring "ab c", it does not contain the exact substring "abc".Using special charactersWhen the search for a match requires something more than a direct match, such as finding one or more b's, or finding white space, you can include special characters in the pattern.
For example, to match a single "a" followed by zero or more "b"s followed by "c", you'd use the pattern /ab*c/: the * after "b" means "0 or more occurrences of the preceding item."
In the string "cbbabbbbcdebc", this pattern will match the substring "abbbbc".
The following pages provide lists of the different special characters that fit into each category, along with descriptions and examples.

Assertions guide

Assertions include boundaries, which indicate the beginnings and endings of lines and words, and other patterns indicating in some way that a match is possible (including look-ahead, look-behind, and conditional expressions).

Character classes guide

Distinguish different types of characters. For example, distinguishing between letters and digits.

Groups and backreferences guide

Groups group multiple patterns as a whole, and capturing groups provide extra submatch information when using a regular expression pattern to match against a string. Backreferences refer to a previously captured group in the same regular expression.

Quantifiers guide

Indicate numbers of characters or expressions to match.


If you want to look at all the special characters that can be used in regular expressions in a single table, see the following:

  
    Special characters in regular expressions.
  
  
    
      Characters / constructs
      Corresponding article
    
  
  
    
      
        [xyz], [^xyz], .,
        \d, \D, \w, \W,
         , \S, \t, \r,
        \n, \v, \f, [\b],
        \0, \cX, \xhh,
        \uhhhh, \u{hhhh},
        x|y
      
      
        
          Character classes
        
      
    
    
      
        ^, $, \b, \B,
        x(?=y), x(?!y), (?<=y)x,
        (?<!y)x
      
      
        
          Assertions
        
      
    
    
      
        (x), (?<Name>x), (?:x),
        \n, \k<Name>
      
      
        
          Groups and backreferences
        
      
    
    
      
        x*, x+, x?,
        x{n}, x{n,},
        x{n,m}
      
      
        
          Quantifiers
        
      
    
  


Note: A larger cheat sheet is also available (only aggregating parts of those individual articles).
EscapingIf you need to use any of the special characters literally (actually searching for a "*", for instance), you must escape it by putting a backslash in front of it.
For instance, to search for "a" followed by "*" followed by "b", you'd use /a\*b/ — the backslash "escapes" the "*", making it literal instead of special.
Similarly, if you're writing a regular expression literal and need to match a slash ("/"), you need to escape that (otherwise, it terminates the pattern).
For instance, to search for the string "/example/" followed by one or more alphabetic characters, you'd use /\/example\/[a-z]+/i—the backslashes before each slash make them literal.
To match a literal backslash, you need to escape the backslash.
For instance, to match the string "C:\" where "C" can be any letter, you'd use /[A-Z]:\\/ — the first backslash escapes the one after it, so the expression searches for a single literal backslash.
If using the RegExp constructor with a string literal, remember that the backslash is an escape in string literals, so to use it in the regular expression, you need to escape it at the string literal level.
/a\*b/ and new RegExp("a\\*b") create the same expression, which searches for "a" followed by a literal "*" followed by "b".
The RegExp.escape() function returns a new string where all special characters in regex syntax are escaped. This allows you to do new RegExp(RegExp.escape("a*b")) to create a regular expression that matches only the string "a*b".Using parenthesesParentheses around any part of the regular expression pattern causes that part of the matched substring to be remembered.
Once remembered, the substring can be recalled for other use. See Groups and backreferences for more details.Using regular expressions in JavaScriptRegular expressions are used with the RegExp methods test() and exec() and with the String methods match(), matchAll(), replace(), replaceAll(), search(), and split().



Method
Description




exec()
Executes a search for a match in a string. It returns an array of information or null on a mismatch.


test()
Tests for a match in a string. It returns true or false.


match()
Returns an array containing all of the matches, including capturing groups, or null if no match is found.


matchAll()
Returns an iterator containing all of the matches, including capturing groups.


search()
Tests for a match in a string. It returns the index of the match, or -1 if the search fails.


replace()
Executes a search for a match in a string, and replaces the matched substring with a replacement substring.


replaceAll()
Executes a search for all matches in a string, and replaces the matched substrings with a replacement substring.


split()
Uses a regular expression or a fixed string to break a string into an array of substrings.



When you want to know whether a pattern is found in a string, use the test() or search() methods; for more information (but slower execution) use the exec() or match() methods.
If you use exec() or match() and if the match succeeds, these methods return an array and update properties of the associated regular expression object and also of the predefined regular expression object, RegExp.
If the match fails, the exec() method returns null (which coerces to false).
In the following example, the script uses the exec() method to find a match in a string.
jsconst myRe = /d(b+)d/g;
const myArray = myRe.exec("cdbbdbsbz");

If you do not need to access the properties of the regular expression, an alternative way of creating myArray is with this script:
jsconst myArray = /d(b+)d/g.exec("cdbbdbsbz");
// similar to 'cdbbdbsbz'.match(/d(b+)d/g); however,
// 'cdbbdbsbz'.match(/d(b+)d/g) outputs [ "dbbd" ]
// while /d(b+)d/g.exec('cdbbdbsbz') outputs [ 'dbbd', 'bb', index: 1, input: 'cdbbdbsbz' ]

(See Using the global search flag with exec() for further info about the different behaviors.)
If you want to construct the regular expression from a string, yet another alternative is this script:
jsconst myRe = new RegExp("d(b+)d", "g");
const myArray = myRe.exec("cdbbdbsbz");

With these scripts, the match succeeds and returns the array and updates the properties shown in the following table.

  
    Results of regular expression execution.
  
  
    
      Object
      Property or index
      Description
      In this example
    
  
  
    
      myArray
      
      The matched string and all remembered substrings.
      ['dbbd', 'bb', index: 1, input: 'cdbbdbsbz']
    
    
      index
      The 0-based index of the match in the input string.
      1
    
    
      input
      The original string.
      'cdbbdbsbz'
    
    
      [0]
      The last matched characters.
      'dbbd'
    
    
      myRe
      lastIndex
      The index at which to start the next match.
        (This property is set only if the regular expression uses the g option, described in
        Advanced Searching With Flags.)
      
      5
    
    
      source
      
        The text of the pattern. Updated at the time that the regular expression is created, not executed.
      
      'd(b+)d'
    
  

As shown in the second form of this example, you can use a regular expression created with an object initializer without assigning it to a variable.
If you do, however, every occurrence is a new regular expression.
For this reason, if you use this form without assigning it to a variable, you cannot subsequently access the properties of that regular expression.
For example, assume you have this script:
jsconst myRe = /d(b+)d/g;
const myArray = myRe.exec("cdbbdbsbz");
console.log(`The value of lastIndex is ${myRe.lastIndex}`);

// "The value of lastIndex is 5"

However, if you have this script:
jsconst myArray = /d(b+)d/g.exec("cdbbdbsbz");
console.log(`The value of lastIndex is ${/d(b+)d/g.lastIndex}`);

// "The value of lastIndex is 0"

The occurrences of /d(b+)d/g in the two statements are different regular expression objects and hence have different values for their lastIndex property.
If you need to access the properties of a regular expression created with an object initializer, you should first assign it to a variable.Advanced searching with flagsRegular expressions have optional flags that allow for functionality like global searching and case-insensitive searching.
These flags can be used separately or together in any order, and are included as part of the regular expression.



Flag
Description
Corresponding property




d
Generate indices for substring matches.
hasIndices


g
Global search.
global


i
Case-insensitive search.
ignoreCase


m
Makes ^ and $ match the start and end of each line instead of those of the entire string.
multiline


s
Allows . to match newline characters.
dotAll


u
"Unicode"; treat a pattern as a sequence of Unicode code points.
unicode


v
An upgrade to the u mode with more Unicode features.
unicodeSets


y
Perform a "sticky" search that matches starting at the current position in the target string.
sticky



To include a flag with the regular expression, use this syntax:
jsconst re = /pattern/flags;

or
jsconst re = new RegExp("pattern", "flags");

Note that the flags are an integral part of a regular expression. They cannot be added or removed later.
For example, re = /\w+ /g creates a regular expression that looks for one or more characters followed by a space, and it looks for this combination throughout the string.
jsconst re = /\w+ /g;
const str = "fee fi fo fum";
const myArray = str.match(re);
console.log(myArray);

// ["fee ", "fi ", "fo "]

You could replace the line:
jsconst re = /\w+ /g;

with:
jsconst re = new RegExp("\\w+\ ", "g");

and get the same result.
The m flag is used to specify that a multiline input string should be treated as multiple lines.
If the m flag is used, ^ and $ match at the start or end of any line within the input string instead of the start or end of the entire string.
The i, m, and s flags can be enabled or disabled for specific parts of a regex using the modifier syntax.
Using the global search flag with exec()
RegExp.prototype.exec() method with the g flag returns each match and its position iteratively.
jsconst str = "fee fi fo fum";
const re = /\w+ /g;

console.log(re.exec(str)); // ["fee ", index: 0, input: "fee fi fo fum"]
console.log(re.exec(str)); // ["fi ", index: 4, input: "fee fi fo fum"]
console.log(re.exec(str)); // ["fo ", index: 7, input: "fee fi fo fum"]
console.log(re.exec(str)); // null

In contrast, String.prototype.match() method returns all matches at once, but without their position.
jsconsole.log(str.match(re)); // ["fee ", "fi ", "fo "]

Using unicode regular expressions
The u flag is used to create "unicode" regular expressions; that is, regular expressions which support matching against unicode text. An important feature that's enabled in unicode mode is Unicode property escapes. For example, the following regular expression might be used to match against an arbitrary unicode "word":
js/\p{L}*/u;

Unicode regular expressions have different execution behavior as well. RegExp.prototype.unicode contains more explanation about this.Examples
Note:
Several examples are also available in:

The reference pages for exec(), test(), match(), matchAll(), search(), replace(), split()
The guide articles: character classes, assertions, groups and backreferences, quantifiers

Using special characters to verify inputIn the following example, the user is expected to enter a phone number.
When the user presses the "Check" button, the script checks the validity of the number.
If the number is valid (matches the character sequence specified by the regular expression), the script shows a message thanking the user and confirming the number.
If the number is invalid, the script informs the user that the phone number is not valid.
The regular expression looks for:

the beginning of the line of data: ^
followed by three numeric characters \d{3} OR | a left parenthesis \(, followed by three digits \d{3}, followed by a close parenthesis \), in a non-capturing group (?:)
followed by one dash, forward slash, or decimal point in a capturing group ()
followed by three digits \d{3}
followed by the match remembered in the (first) captured group \1
followed by four digits \d{4}
followed by the end of the line of data: $

HTML
html<p>
  Enter your phone number (with area code) and then click "Check".
  <br />
  The expected format is like ###-###-####.
</p>
<form id="form">
  <input id="phone" />
  <button type="submit">Check</button>
</form>
<p id="output"></p>

JavaScript
jsconst form = document.querySelector("#form");
const input = document.querySelector("#phone");
const output = document.querySelector("#output");

const re = /^(?:\d{3}|\(\d{3}\))([-/.])\d{3}\1\d{4}$/;

function testInfo(phoneInput) {
  const ok = re.exec(phoneInput.value);

  output.textContent = ok
    ? `Thanks, your phone number is ${ok[0]}`
    : `${phoneInput.value} isn't a phone number with area code!`;
}

form.addEventListener("submit", (event) => {
  event.preventDefault();
  testInfo(input);
});

Result
Tools
RegExr

An online tool to learn, build, & test Regular Expressions.

Regex tester

An online regex builder/debugger

Regex interactive tutorial

An online interactive tutorials, Cheat sheet, & Playground.

Regex visualizer

An online visual regex tester.


 Previous  Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jan 24, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nRegular expressions 
 Previous  Next  
Regular expressions are patterns used to match character combinations in strings.
In JavaScript, regular expressions are also objects. These patterns are used with the exec() and test() methods of RegExp, and with the match(), matchAll(), replace(), replaceAll(), search(), and split() methods of String.
This chapter describes JavaScript regular expressions. It provides a brief overview of each syntax element. For a detailed explanation of each one's semantics, read the regular expressions reference.Creating a regular expressionYou construct a regular expression in one of two ways:


Using a regular expression literal, which consists of a pattern enclosed between slashes, as follows:
jsconst re = /ab+c/;

Regular expression literals provide compilation of the regular expression when the script is loaded.
If the regular expression remains constant, using this can improve performance.


Or calling the constructor function of the RegExp object, as follows:
jsconst re = new RegExp("ab+c");

Using the constructor function provides runtime compilation of the regular expression.
Use the constructor function when you know the regular expression pattern will be changing, or you don't know the pattern and are getting it from another source, such as user input.

Writing a regular expression patternA regular expression pattern is composed of simple characters, such as /abc/, or a combination of simple and special characters, such as /ab*c/ or /Chapter (\d+)\.\d*/.
The last example includes parentheses, which are used as a memory device.
The match made with this part of the pattern is remembered for later use, as described in Using groups.Using simple patternsSimple patterns are constructed of characters for which you want to find a direct match. For example, the pattern /abc/ matches character combinations in strings only when the exact sequence "abc" occurs (all characters together and in that order).
Such a match would succeed in the strings "Hi, do you know your abc's?" and "The latest airplane designs evolved from slabcraft.".
In both cases the match is with the substring "abc".
There is no match in the string "Grab crab" because while it contains the substring "ab c", it does not contain the exact substring "abc".Using special charactersWhen the search for a match requires something more than a direct match, such as finding one or more b's, or finding white space, you can include special characters in the pattern.
For example, to match a single "a" followed by zero or more "b"s followed by "c", you'd use the pattern /ab*c/: the * after "b" means "0 or more occurrences of the preceding item."
In the string "cbbabbbbcdebc", this pattern will match the substring "abbbbc".
The following pages provide lists of the different special characters that fit into each category, along with descriptions and examples.

Assertions guide

Assertions include boundaries, which indicate the beginnings and endings of lines and words, and other patterns indicating in some way that a match is possible (including look-ahead, look-behind, and conditional expressions).

Character classes guide

Distinguish different types of characters. For example, distinguishing between letters and digits.

Groups and backreferences guide

Groups group multiple patterns as a whole, and capturing groups provide extra submatch information when using a regular expression pattern to match against a string. Backreferences refer to a previously captured group in the same regular expression.

Quantifiers guide

Indicate numbers of characters or expressions to match.


If you want to look at all the special characters that can be used in regular expressions in a single table, see the following:

  
    Special characters in regular expressions.
  
  
    
      Characters / constructs
      Corresponding article
    
  
  
    
      
        [xyz], [^xyz], .,
        \d, \D, \w, \W,
         , \S, \t, \r,
        \n, \v, \f, [\b],
        \0, \cX, \xhh,
        \uhhhh, \u{hhhh},
        x|y
      
      
        
          Character classes
        
      
    
    
      
        ^, $, \b, \B,
        x(?=y), x(?!y), (?<=y)x,
        (?<!y)x
      
      
        
          Assertions
        
      
    
    
      
        (x), (?<Name>x), (?:x),
        \n, \k<Name>
      
      
        
          Groups and backreferences
        
      
    
    
      
        x*, x+, x?,
        x{n}, x{n,},
        x{n,m}
      
      
        
          Quantifiers
        
      
    
  


Note: A larger cheat sheet is also available (only aggregating parts of those individual articles).
EscapingIf you need to use any of the special characters literally (actually searching for a "*", for instance), you must escape it by putting a backslash in front of it.
For instance, to search for "a" followed by "*" followed by "b", you'd use /a\*b/ — the backslash "escapes" the "*", making it literal instead of special.
Similarly, if you're writing a regular expression literal and need to match a slash ("/"), you need to escape that (otherwise, it terminates the pattern).
For instance, to search for the string "/example/" followed by one or more alphabetic characters, you'd use /\/example\/[a-z]+/i—the backslashes before each slash make them literal.
To match a literal backslash, you need to escape the backslash.
For instance, to match the string "C:\" where "C" can be any letter, you'd use /[A-Z]:\\/ — the first backslash escapes the one after it, so the expression searches for a single literal backslash.
If using the RegExp constructor with a string literal, remember that the backslash is an escape in string literals, so to use it in the regular expression, you need to escape it at the string literal level.
/a\*b/ and new RegExp("a\\*b") create the same expression, which searches for "a" followed by a literal "*" followed by "b".
The RegExp.escape() function returns a new string where all special characters in regex syntax are escaped. This allows you to do new RegExp(RegExp.escape("a*b")) to create a regular expression that matches only the string "a*b".Using parenthesesParentheses around any part of the regular expression pattern causes that part of the matched substring to be remembered.
Once remembered, the substring can be recalled for other use. See Groups and backreferences for more details.Using regular expressions in JavaScriptRegular expressions are used with the RegExp methods test() and exec() and with the String methods match(), matchAll(), replace(), replaceAll(), search(), and split().



Method
Description




exec()
Executes a search for a match in a string. It returns an array of information or null on a mismatch.


test()
Tests for a match in a string. It returns true or false.


match()
Returns an array containing all of the matches, including capturing groups, or null if no match is found.


matchAll()
Returns an iterator containing all of the matches, including capturing groups.


search()
Tests for a match in a string. It returns the index of the match, or -1 if the search fails.


replace()
Executes a search for a match in a string, and replaces the matched substring with a replacement substring.


replaceAll()
Executes a search for all matches in a string, and replaces the matched substrings with a replacement substring.


split()
Uses a regular expression or a fixed string to break a string into an array of substrings.



When you want to know whether a pattern is found in a string, use the test() or search() methods; for more information (but slower execution) use the exec() or match() methods.
If you use exec() or match() and if the match succeeds, these methods return an array and update properties of the associated regular expression object and also of the predefined regular expression object, RegExp.
If the match fails, the exec() method returns null (which coerces to false).
In the following example, the script uses the exec() method to find a match in a string.
jsconst myRe = /d(b+)d/g;
const myArray = myRe.exec("cdbbdbsbz");

If you do not need to access the properties of the regular expression, an alternative way of creating myArray is with this script:
jsconst myArray = /d(b+)d/g.exec("cdbbdbsbz");
// similar to 'cdbbdbsbz'.match(/d(b+)d/g); however,
// 'cdbbdbsbz'.match(/d(b+)d/g) outputs [ "dbbd" ]
// while /d(b+)d/g.exec('cdbbdbsbz') outputs [ 'dbbd', 'bb', index: 1, input: 'cdbbdbsbz' ]

(See Using the global search flag with exec() for further info about the different behaviors.)
If you want to construct the regular expression from a string, yet another alternative is this script:
jsconst myRe = new RegExp("d(b+)d", "g");
const myArray = myRe.exec("cdbbdbsbz");

With these scripts, the match succeeds and returns the array and updates the properties shown in the following table.

  
    Results of regular expression execution.
  
  
    
      Object
      Property or index
      Description
      In this example
    
  
  
    
      myArray
      
      The matched string and all remembered substrings.
      ['dbbd', 'bb', index: 1, input: 'cdbbdbsbz']
    
    
      index
      The 0-based index of the match in the input string.
      1
    
    
      input
      The original string.
      'cdbbdbsbz'
    
    
      [0]
      The last matched characters.
      'dbbd'
    
    
      myRe
      lastIndex
      The index at which to start the next match.
        (This property is set only if the regular expression uses the g option, described in
        Advanced Searching With Flags.)
      
      5
    
    
      source
      
        The text of the pattern. Updated at the time that the regular expression is created, not executed.
      
      'd(b+)d'
    
  

As shown in the second form of this example, you can use a regular expression created with an object initializer without assigning it to a variable.
If you do, however, every occurrence is a new regular expression.
For this reason, if you use this form without assigning it to a variable, you cannot subsequently access the properties of that regular expression.
For example, assume you have this script:
jsconst myRe = /d(b+)d/g;
const myArray = myRe.exec("cdbbdbsbz");
console.log(`The value of lastIndex is ${myRe.lastIndex}`);

// "The value of lastIndex is 5"

However, if you have this script:
jsconst myArray = /d(b+)d/g.exec("cdbbdbsbz");
console.log(`The value of lastIndex is ${/d(b+)d/g.lastIndex}`);

// "The value of lastIndex is 0"

The occurrences of /d(b+)d/g in the two statements are different regular expression objects and hence have different values for their lastIndex property.
If you need to access the properties of a regular expression created with an object initializer, you should first assign it to a variable.Advanced searching with flagsRegular expressions have optional flags that allow for functionality like global searching and case-insensitive searching.
These flags can be used separately or together in any order, and are included as part of the regular expression.



Flag
Description
Corresponding property




d
Generate indices for substring matches.
hasIndices


g
Global search.
global


i
Case-insensitive search.
ignoreCase


m
Makes ^ and $ match the start and end of each line instead of those of the entire string.
multiline


s
Allows . to match newline characters.
dotAll


u
"Unicode"; treat a pattern as a sequence of Unicode code points.
unicode


v
An upgrade to the u mode with more Unicode features.
unicodeSets


y
Perform a "sticky" search that matches starting at the current position in the target string.
sticky



To include a flag with the regular expression, use this syntax:
jsconst re = /pattern/flags;

or
jsconst re = new RegExp("pattern", "flags");

Note that the flags are an integral part of a regular expression. They cannot be added or removed later.
For example, re = /\w+ /g creates a regular expression that looks for one or more characters followed by a space, and it looks for this combination throughout the string.
jsconst re = /\w+ /g;
const str = "fee fi fo fum";
const myArray = str.match(re);
console.log(myArray);

// ["fee ", "fi ", "fo "]

You could replace the line:
jsconst re = /\w+ /g;

with:
jsconst re = new RegExp("\\w+\ ", "g");

and get the same result.
The m flag is used to specify that a multiline input string should be treated as multiple lines.
If the m flag is used, ^ and $ match at the start or end of any line within the input string instead of the start or end of the entire string.
The i, m, and s flags can be enabled or disabled for specific parts of a regex using the modifier syntax.
Using the global search flag with exec()
RegExp.prototype.exec() method with the g flag returns each match and its position iteratively.
jsconst str = "fee fi fo fum";
const re = /\w+ /g;

console.log(re.exec(str)); // ["fee ", index: 0, input: "fee fi fo fum"]
console.log(re.exec(str)); // ["fi ", index: 4, input: "fee fi fo fum"]
console.log(re.exec(str)); // ["fo ", index: 7, input: "fee fi fo fum"]
console.log(re.exec(str)); // null

In contrast, String.prototype.match() method returns all matches at once, but without their position.
jsconsole.log(str.match(re)); // ["fee ", "fi ", "fo "]

Using unicode regular expressions
The u flag is used to create "unicode" regular expressions; that is, regular expressions which support matching against unicode text. An important feature that's enabled in unicode mode is Unicode property escapes. For example, the following regular expression might be used to match against an arbitrary unicode "word":
js/\p{L}*/u;

Unicode regular expressions have different execution behavior as well. RegExp.prototype.unicode contains more explanation about this.Examples
Note:
Several examples are also available in:

The reference pages for exec(), test(), match(), matchAll(), search(), replace(), split()
The guide articles: character classes, assertions, groups and backreferences, quantifiers

Using special characters to verify inputIn the following example, the user is expected to enter a phone number.
When the user presses the "Check" button, the script checks the validity of the number.
If the number is valid (matches the character sequence specified by the regular expression), the script shows a message thanking the user and confirming the number.
If the number is invalid, the script informs the user that the phone number is not valid.
The regular expression looks for:

the beginning of the line of data: ^
followed by three numeric characters \d{3} OR | a left parenthesis \(, followed by three digits \d{3}, followed by a close parenthesis \), in a non-capturing group (?:)
followed by one dash, forward slash, or decimal point in a capturing group ()
followed by three digits \d{3}
followed by the match remembered in the (first) captured group \1
followed by four digits \d{4}
followed by the end of the line of data: $

HTML
html<p>
  Enter your phone number (with area code) and then click "Check".
  <br />
  The expected format is like ###-###-####.
</p>
<form id="form">
  <input id="phone" />
  <button type="submit">Check</button>
</form>
<p id="output"></p>

JavaScript
jsconst form = document.querySelector("#form");
const input = document.querySelector("#phone");
const output = document.querySelector("#output");

const re = /^(?:\d{3}|\(\d{3}\))([-/.])\d{3}\1\d{4}$/;

function testInfo(phoneInput) {
  const ok = re.exec(phoneInput.value);

  output.textContent = ok
    ? `Thanks, your phone number is ${ok[0]}`
    : `${phoneInput.value} isn't a phone number with area code!`;
}

form.addEventListener("submit", (event) => {
  event.preventDefault();
  testInfo(input);
});

Result
Tools
RegExr

An online tool to learn, build, & test Regular Expressions.

Regex tester

An online regex builder/debugger

Regex interactive tutorial

An online interactive tutorials, Cheat sheet, & Playground.

Regex visualizer

An online visual regex tester.


 Previous  Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jan 24, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIndexed collections 
 Previous  Next  
This chapter introduces collections of data which are ordered by an index value. This includes arrays and array-like constructs such as Array objects and TypedArray objects.
An array is an ordered list of values that you refer to with a name and an index.
For example, consider an array called emp, which contains employees' names indexed by their numerical employee number. So emp[0] would be employee number zero, emp[1] employee number one, and so on.
JavaScript does not have an explicit array data type. However, you can use the predefined Array object and its methods to work with arrays in your applications. The Array object has methods for manipulating arrays in various ways, such as joining, reversing, and sorting them. It has a property for determining the array length and other properties for use with regular expressions.
We will be focusing on arrays in this article, but many of the same concepts apply to typed arrays as well, since arrays and typed arrays share many similar methods. For more information on typed arrays, see the typed array guide.Creating an arrayThe following statements create equivalent arrays:
jsconst arr1 = new Array(element0, element1, /* …, */ elementN);
const arr2 = Array(element0, element1, /* …, */ elementN);
const arr3 = [element0, element1, /* …, */ elementN];

element0, element1, …, elementN is a list of values for the array's elements. When these values are specified, the array is initialized with them as the array's elements. The array's length property is set to the number of arguments.
The bracket syntax is called an "array literal" or "array initializer." It's shorter than other forms of array creation, and so is generally preferred. See Array literals for details.
To create an array with non-zero length, but without any items, either of the following can be used:
js// This...
const arr1 = new Array(arrayLength);

// ...results in the same array as this
const arr2 = Array(arrayLength);

// This has exactly the same effect
const arr3 = [];
arr3.length = arrayLength;


Note:
In the above code, arrayLength must be a Number. Otherwise, an array with a single element (the provided value) will be created. Calling arr.length will return arrayLength, but the array doesn't contain any elements. A for...in loop will not find any property on the array.

In addition to a newly defined variable as shown above, arrays can also be assigned as a property of a new or an existing object:
jsconst obj = {};
// …
obj.prop = [element0, element1, /* …, */ elementN];

// OR
const obj = { prop: [element0, element1, /* …, */ elementN] };

If you wish to initialize an array with a single element, and the element happens to be a Number, you must use the bracket syntax. When a single Number value is passed to the Array() constructor or function, it is interpreted as an arrayLength, not as a single element.
This creates an array with only one element: the number 42.
jsconst arr = [42];

This creates an array with no elements and arr.length set to 42.
jsconst arr = Array(42);

This is equivalent to:
jsconst arr = [];
arr.length = 42;

Calling Array(N) results in a RangeError, if N is a non-whole number whose fractional portion is non-zero. The following example illustrates this behavior.
jsconst arr = Array(9.3); // RangeError: Invalid array length

If your code needs to create arrays with single elements of an arbitrary data type, it is safer to use array literals. Alternatively, create an empty array first before adding the single element to it.
You can also use the Array.of static method to create arrays with single element.
jsconst arr = Array.of(9.3); // arr contains only one element 9.3
Referring to array elementsBecause elements are also properties, you can access them using property accessors. Suppose you define the following array:
jsconst myArray = ["Wind", "Rain", "Fire"];

You can refer to the first element of the array as myArray[0], the second element of the array as myArray[1], etc… The index of the elements begins with zero.

Note:
You can also use property accessors to access other properties of the array, like with an object.
jsconst arr = ["one", "two", "three"];
arr[2]; // three
arr["length"]; // 3

Populating an arrayYou can populate an array by assigning values to its elements. For example:
jsconst emp = [];
emp[0] = "Casey Jones";
emp[1] = "Phil Lesh";
emp[2] = "August West";


Note:
If you supply a non-integer value to the array operator in the code above, a property will be created in the object representing the array, instead of an array element.
jsconst arr = [];
arr[3.4] = "Oranges";
console.log(arr.length); // 0
console.log(Object.hasOwn(arr, 3.4)); // true


You can also populate an array when you create it:
jsconst myArray = new Array("Hello", myVar, 3.14159);
// OR
const myArray = ["Mango", "Apple", "Orange"];
Understanding lengthAt the implementation level, JavaScript's arrays actually store their elements as standard object properties, using the array index as the property name.
The length property is special. Its value is always a positive integer greater than the index of the last element if one exists. (In the example below, 'Dusty' is indexed at 30, so cats.length returns 30 + 1).
Remember, JavaScript Array indexes are 0-based: they start at 0, not 1. This means that the length property will be one more than the highest index stored in the array:
jsconst cats = [];
cats[30] = ["Dusty"];
console.log(cats.length); // 31

You can also assign to the length property.
Writing a value that is shorter than the number of stored items truncates the array. Writing 0 empties it entirely:
jsconst cats = ["Dusty", "Misty", "Twiggy"];
console.log(cats.length); // 3

cats.length = 2;
console.log(cats); // [ 'Dusty', 'Misty' ] - Twiggy has been removed

cats.length = 0;
console.log(cats); // []; the cats array is empty

cats.length = 3;
console.log(cats); // [ <3 empty items> ]
Iterating over arraysA common operation is to iterate over the values of an array, processing each one in some way, as follows:
jsconst colors = ["red", "green", "blue"];
for (let i = 0; i < colors.length; i++) {
  console.log(colors[i]);
}

If you know that none of the elements in your array evaluate to false in a boolean context—if your array consists only of DOM nodes, for example—you can use a more efficient idiom:
jsconst divs = document.getElementsByTagName("div");
for (let i = 0, div; (div = divs[i]); i++) {
  /* Process div in some way */
}

This avoids the overhead of checking the length of the array, and ensures that the div variable is reassigned to the current item each time around the loop for added convenience.
The forEach() method provides another way of iterating over an array:
jsconst colors = ["red", "green", "blue"];
colors.forEach((color) => console.log(color));
// red
// green
// blue

The function passed to forEach is executed once for every item in the array, with the array item passed as the argument to the function. Unassigned values are not iterated in a forEach loop.
Note that the elements of an array that are omitted when the array is defined are not listed when iterating by forEach, but are listed when undefined has been manually assigned to the element:
jsconst sparseArray = ["first", "second", , "fourth"];

sparseArray.forEach((element) => {
  console.log(element);
});
// Logs:
// first
// second
// fourth

if (sparseArray[2] === undefined) {
  console.log("sparseArray[2] is undefined"); // true
}

const nonsparseArray = ["first", "second", undefined, "fourth"];

nonsparseArray.forEach((element) => {
  console.log(element);
});
// Logs:
// first
// second
// undefined
// fourth

Since JavaScript array elements are saved as standard object properties, it is not advisable to iterate through JavaScript arrays using for...in loops, because normal elements and all enumerable properties will be listed.Array methodsThe Array object has the following methods:
The concat() method joins two or more arrays and returns a new array.
jslet myArray = ["1", "2", "3"];
myArray = myArray.concat("a", "b", "c");
// myArray is now ["1", "2", "3", "a", "b", "c"]

The join() method joins all elements of an array into a string.
jsconst myArray = ["Wind", "Rain", "Fire"];
const list = myArray.join(" - "); // list is "Wind - Rain - Fire"

The push() method adds one or more elements to the end of an array and returns the resulting length of the array.
jsconst myArray = ["1", "2"];
myArray.push("3"); // myArray is now ["1", "2", "3"]

The pop() method removes the last element from an array and returns that element.
jsconst myArray = ["1", "2", "3"];
const last = myArray.pop();
// myArray is now ["1", "2"], last = "3"

The shift() method removes the first element from an array and returns that element.
jsconst myArray = ["1", "2", "3"];
const first = myArray.shift();
// myArray is now ["2", "3"], first is "1"

The unshift() method adds one or more elements to the front of an array and returns the new length of the array.
jsconst myArray = ["1", "2", "3"];
myArray.unshift("4", "5");
// myArray becomes ["4", "5", "1", "2", "3"]

The slice() method extracts a section of an array and returns a new array.
jslet myArray = ["a", "b", "c", "d", "e"];
myArray = myArray.slice(1, 4); // [ "b", "c", "d"]
// starts at index 1 and extracts all elements
// until index 3

The at() method returns the element at the specified index in the array, or undefined if the index is out of range. It's notably used for negative indices that access elements from the end of the array.
jsconst myArray = ["a", "b", "c", "d", "e"];
myArray.at(-2); // "d", the second-last element of myArray

The splice() method removes elements from an array and (optionally) replaces them. It returns the items which were removed from the array.
jsconst myArray = ["1", "2", "3", "4", "5"];
myArray.splice(1, 3, "a", "b", "c", "d");
// myArray is now ["1", "a", "b", "c", "d", "5"]
// This code started at index one (or where the "2" was),
// removed 3 elements there, and then inserted all consecutive
// elements in its place.

The reverse() method transposes the elements of an array, in place: the first array element becomes the last and the last becomes the first. It returns a reference to the array.
jsconst myArray = ["1", "2", "3"];
myArray.reverse();
// transposes the array so that myArray = ["3", "2", "1"]

The flat() method returns a new array with all sub-array elements concatenated into it recursively up to the specified depth.
jslet myArray = [1, 2, [3, 4]];
myArray = myArray.flat();
// myArray is now [1, 2, 3, 4], since the [3, 4] subarray is flattened

The sort() method sorts the elements of an array in place, and returns a reference to the array.
jsconst myArray = ["Wind", "Rain", "Fire"];
myArray.sort();
// sorts the array so that myArray = ["Fire", "Rain", "Wind"]

sort() can also take a callback function to determine how array elements are compared. The callback function is called with two arguments, which are two values from the array. The function compares these two values and returns a positive number, negative number, or zero, indicating the order of the two values. For instance, the following will sort the array by the last letter of a string:
jsconst sortFn = (a, b) => {
  if (a[a.length - 1] < b[b.length - 1]) {
    return -1; // Negative number => a < b, a comes before b
  } else if (a[a.length - 1] > b[b.length - 1]) {
    return 1; // Positive number => a > b, a comes after b
  }
  return 0; // Zero => a = b, a and b keep their original order
};
myArray.sort(sortFn);
// sorts the array so that myArray = ["Wind","Fire","Rain"]


if a is less than b by the sorting system, return -1 (or any negative number)
if a is greater than b by the sorting system, return 1 (or any positive number)
if a and b are considered equivalent, return 0.

The indexOf() method searches the array for searchElement and returns the index of the first match.
jsconst a = ["a", "b", "a", "b", "a"];
console.log(a.indexOf("b")); // 1

// Now try again, starting from after the last match
console.log(a.indexOf("b", 2)); // 3
console.log(a.indexOf("z")); // -1, because 'z' was not found

The lastIndexOf() method works like indexOf, but starts at the end and searches backwards.
jsconst a = ["a", "b", "c", "d", "a", "b"];
console.log(a.lastIndexOf("b")); // 5

// Now try again, starting from before the last match
console.log(a.lastIndexOf("b", 4)); // 1
console.log(a.lastIndexOf("z")); // -1

The forEach() method executes callback on every array item and returns undefined.
jsconst a = ["a", "b", "c"];
a.forEach((element) => {
  console.log(element);
});
// Logs:
// a
// b
// c

The forEach method (and others below) that take a callback are known as iterative methods, because they iterate over the entire array in some fashion. Each one takes an optional second argument called thisArg. If provided, thisArg becomes the value of the this keyword inside the body of the callback function. If not provided, as with other cases where a function is invoked outside of an explicit object context, this will refer to the global object (window, globalThis, etc.) when the function is not strict, or undefined when the function is strict.

Note:
The sort() method introduced above is not an iterative method, because its callback function is only used for comparison and may not be called in any particular order based on element order. sort() does not accept the thisArg parameter either.

The map() method returns a new array of the return value from executing callback on every array item.
jsconst a1 = ["a", "b", "c"];
const a2 = a1.map((item) => item.toUpperCase());
console.log(a2); // ['A', 'B', 'C']

The flatMap() method runs map() followed by a flat() of depth 1.
jsconst a1 = ["a", "b", "c"];
const a2 = a1.flatMap((item) => [item.toUpperCase(), item.toLowerCase()]);
console.log(a2); // ['A', 'a', 'B', 'b', 'C', 'c']

The filter() method returns a new array containing the items for which callback returned true.
jsconst a1 = ["a", 10, "b", 20, "c", 30];
const a2 = a1.filter((item) => typeof item === "number");
console.log(a2); // [10, 20, 30]

The find() method returns the first item for which callback returned true.
jsconst a1 = ["a", 10, "b", 20, "c", 30];
const i = a1.find((item) => typeof item === "number");
console.log(i); // 10

The findLast() method returns the last item for which callback returned true.
jsconst a1 = ["a", 10, "b", 20, "c", 30];
const i = a1.findLast((item) => typeof item === "number");
console.log(i); // 30

The findIndex() method returns the index of the first item for which callback returned true.
jsconst a1 = ["a", 10, "b", 20, "c", 30];
const i = a1.findIndex((item) => typeof item === "number");
console.log(i); // 1

The findLastIndex() method returns the index of the last item for which callback returned true.
jsconst a1 = ["a", 10, "b", 20, "c", 30];
const i = a1.findLastIndex((item) => typeof item === "number");
console.log(i); // 5

The every() method returns true if callback returns true for every item in the array.
jsfunction isNumber(value) {
  return typeof value === "number";
}
const a1 = [1, 2, 3];
console.log(a1.every(isNumber)); // true
const a2 = [1, "2", 3];
console.log(a2.every(isNumber)); // false

The some() method returns true if callback returns true for at least one item in the array.
jsfunction isNumber(value) {
  return typeof value === "number";
}
const a1 = [1, 2, 3];
console.log(a1.some(isNumber)); // true
const a2 = [1, "2", 3];
console.log(a2.some(isNumber)); // true
const a3 = ["1", "2", "3"];
console.log(a3.some(isNumber)); // false

The reduce() method applies callback(accumulator, currentValue, currentIndex, array) for each value in the array for the purpose of reducing the list of items down to a single value. The reduce function returns the final value returned by callback function.
If initialValue is specified, then callback is called with initialValue as the first parameter value and the value of the first item in the array as the second parameter value.
If initialValue is not specified, then callback's first two parameter values will be the first and second elements of the array. On every subsequent call, the first parameter's value will be whatever callback returned on the previous call, and the second parameter's value will be the next value in the array.
If callback needs access to the index of the item being processed, or access to the entire array, they are available as optional parameters.
jsconst a = [10, 20, 30];
const total = a.reduce(
  (accumulator, currentValue) => accumulator + currentValue,
  0,
);
console.log(total); // 60

The reduceRight() method works like reduce(), but starts with the last element.
reduce and reduceRight are the least obvious of the iterative array methods. They should be used for algorithms that combine two values recursively in order to reduce a sequence down to a single value.Array transformationsYou can transform back and forth between arrays and other data structures.Grouping the elements of an arrayThe Object.groupBy() method can be used to group the elements of an array, using a test function that returns a string indicating the group of the current element.
Here we have an inventory array that contains "food" objects that have a name and a type.
jsconst inventory = [
  { name: "asparagus", type: "vegetables" },
  { name: "bananas", type: "fruit" },
  { name: "goat", type: "meat" },
  { name: "cherries", type: "fruit" },
  { name: "fish", type: "meat" },
];

To use Object.groupBy(), you supply a callback function that is called with the current element, and optionally the current index and array, and returns a string indicating the group of the element.
The code below uses an arrow function to return the type of each array element (this uses object destructuring syntax for function arguments to unpack the type element from the passed object). The result is an object that has properties named after the unique strings returned by the callback. Each property is assigned an array containing the elements in the group.
jsconst result = Object.groupBy(inventory, ({ type }) => type);
console.log(result);
// Logs
// {
//   vegetables: [{ name: 'asparagus', type: 'vegetables' }],
//   fruit: [
//     { name: 'bananas', type: 'fruit' },
//     { name: 'cherries', type: 'fruit' }
//   ],
//   meat: [
//     { name: 'goat', type: 'meat' },
//     { name: 'fish', type: 'meat' }
//   ]
// }

Note that the returned object references the same elements as the original array (not deep copies). Changing the internal structure of these elements will be reflected in both the original array and the returned object.
If you can't use a string as the key, for example, if the information to group is associated with an object that might change, then you can instead use Map.groupBy(). This is very similar to Object.groupBy() except that it groups the elements of the array into a Map that can use an arbitrary value (object or primitive) as a key.Sparse arraysArrays can contain "empty slots", which are not the same as slots filled with the value undefined. Empty slots can be created in one of the following ways:
js// Array constructor:
const a = Array(5); // [ <5 empty items> ]

// Consecutive commas in array literal:
const b = [1, 2, , , 5]; // [ 1, 2, <2 empty items>, 5 ]

// Directly setting a slot with index greater than array.length:
const c = [1, 2];
c[4] = 5; // [ 1, 2, <2 empty items>, 5 ]

// Elongating an array by directly setting .length:
const d = [1, 2];
d.length = 5; // [ 1, 2, <3 empty items> ]

// Deleting an element:
const e = [1, 2, 3, 4, 5];
delete e[2]; // [ 1, 2, <1 empty item>, 4, 5 ]

In some operations, empty slots behave as if they are filled with undefined.
jsconst arr = [1, 2, , , 5]; // Create a sparse array

// Indexed access
console.log(arr[2]); // undefined

// For...of
for (const i of arr) {
  console.log(i);
}
// Logs: 1 2 undefined undefined 5

// Spreading
const another = [...arr]; // "another" is [ 1, 2, undefined, undefined, 5 ]

But in others (most notably array iteration methods), empty slots are skipped.
jsconst mapped = arr.map((i) => i + 1); // [ 2, 3, <2 empty items>, 6 ]
arr.forEach((i) => console.log(i)); // 1 2 5
const filtered = arr.filter(() => true); // [ 1, 2, 5 ]
const hasFalsy = arr.some((k) => !k); // false

// Property enumeration
const keys = Object.keys(arr); // [ '0', '1', '4' ]
for (const key in arr) {
  console.log(key);
}
// Logs: '0' '1' '4'
// Spreading into an object uses property enumeration, not the array's iterator
const objectSpread = { ...arr }; // { '0': 1, '1': 2, '4': 5 }

For a complete list of how array methods behave with sparse arrays, see the Array reference page.Multi-dimensional arraysArrays can be nested, meaning that an array can contain another array as an element. Using this characteristic of JavaScript arrays, multi-dimensional arrays can be created.
The following code creates a two-dimensional array.
jsconst a = new Array(4);
for (let i = 0; i < 4; i++) {
  a[i] = new Array(4);
  for (let j = 0; j < 4; j++) {
    a[i][j] = `[${i}, ${j}]`;
  }
}

This example creates an array with the following rows:
Row 0: [0, 0] [0, 1] [0, 2] [0, 3]
Row 1: [1, 0] [1, 1] [1, 2] [1, 3]
Row 2: [2, 0] [2, 1] [2, 2] [2, 3]
Row 3: [3, 0] [3, 1] [3, 2] [3, 3]
Using arrays to store other propertiesArrays can also be used like objects, to store related information.
jsconst arr = [1, 2, 3];
arr.property = "value";
console.log(arr.property); // "value"

For example, when an array is the result of a match between a regular expression and a string, the array returns properties and elements that provide information about the match. An array is the return value of RegExp.prototype.exec(), String.prototype.match(), and String.prototype.split(). For information on using arrays with regular expressions, see Regular Expressions.Working with array-like objectsSome JavaScript objects, such as the NodeList returned by document.getElementsByTagName() or the arguments object made available within the body of a function, look and behave like arrays on the surface but do not share all of their methods. The arguments object provides a length attribute but does not implement array methods like forEach().
Array methods cannot be called directly on array-like objects.
jsfunction printArguments() {
  arguments.forEach((item) => {
    console.log(item);
  }); // TypeError: arguments.forEach is not a function
}

But you can call them indirectly using Function.prototype.call().
jsfunction printArguments() {
  Array.prototype.forEach.call(arguments, (item) => {
    console.log(item);
  });
}

Array prototype methods can be used on strings as well, since they provide sequential access to their characters in a similar way to arrays:
jsArray.prototype.forEach.call("a string", (chr) => {
  console.log(chr);
});

 Previous  Next\n\nIndexed collections 
 Previous  Next  
This chapter introduces collections of data which are ordered by an index value. This includes arrays and array-like constructs such as Array objects and TypedArray objects.
An array is an ordered list of values that you refer to with a name and an index.
For example, consider an array called emp, which contains employees' names indexed by their numerical employee number. So emp[0] would be employee number zero, emp[1] employee number one, and so on.
JavaScript does not have an explicit array data type. However, you can use the predefined Array object and its methods to work with arrays in your applications. The Array object has methods for manipulating arrays in various ways, such as joining, reversing, and sorting them. It has a property for determining the array length and other properties for use with regular expressions.
We will be focusing on arrays in this article, but many of the same concepts apply to typed arrays as well, since arrays and typed arrays share many similar methods. For more information on typed arrays, see the typed array guide.Creating an arrayThe following statements create equivalent arrays:
jsconst arr1 = new Array(element0, element1, /* …, */ elementN);
const arr2 = Array(element0, element1, /* …, */ elementN);
const arr3 = [element0, element1, /* …, */ elementN];

element0, element1, …, elementN is a list of values for the array's elements. When these values are specified, the array is initialized with them as the array's elements. The array's length property is set to the number of arguments.
The bracket syntax is called an "array literal" or "array initializer." It's shorter than other forms of array creation, and so is generally preferred. See Array literals for details.
To create an array with non-zero length, but without any items, either of the following can be used:
js// This...
const arr1 = new Array(arrayLength);

// ...results in the same array as this
const arr2 = Array(arrayLength);

// This has exactly the same effect
const arr3 = [];
arr3.length = arrayLength;


Note:
In the above code, arrayLength must be a Number. Otherwise, an array with a single element (the provided value) will be created. Calling arr.length will return arrayLength, but the array doesn't contain any elements. A for...in loop will not find any property on the array.

In addition to a newly defined variable as shown above, arrays can also be assigned as a property of a new or an existing object:
jsconst obj = {};
// …
obj.prop = [element0, element1, /* …, */ elementN];

// OR
const obj = { prop: [element0, element1, /* …, */ elementN] };

If you wish to initialize an array with a single element, and the element happens to be a Number, you must use the bracket syntax. When a single Number value is passed to the Array() constructor or function, it is interpreted as an arrayLength, not as a single element.
This creates an array with only one element: the number 42.
jsconst arr = [42];

This creates an array with no elements and arr.length set to 42.
jsconst arr = Array(42);

This is equivalent to:
jsconst arr = [];
arr.length = 42;

Calling Array(N) results in a RangeError, if N is a non-whole number whose fractional portion is non-zero. The following example illustrates this behavior.
jsconst arr = Array(9.3); // RangeError: Invalid array length

If your code needs to create arrays with single elements of an arbitrary data type, it is safer to use array literals. Alternatively, create an empty array first before adding the single element to it.
You can also use the Array.of static method to create arrays with single element.
jsconst arr = Array.of(9.3); // arr contains only one element 9.3
Referring to array elementsBecause elements are also properties, you can access them using property accessors. Suppose you define the following array:
jsconst myArray = ["Wind", "Rain", "Fire"];

You can refer to the first element of the array as myArray[0], the second element of the array as myArray[1], etc… The index of the elements begins with zero.

Note:
You can also use property accessors to access other properties of the array, like with an object.
jsconst arr = ["one", "two", "three"];
arr[2]; // three
arr["length"]; // 3

Populating an arrayYou can populate an array by assigning values to its elements. For example:
jsconst emp = [];
emp[0] = "Casey Jones";
emp[1] = "Phil Lesh";
emp[2] = "August West";


Note:
If you supply a non-integer value to the array operator in the code above, a property will be created in the object representing the array, instead of an array element.
jsconst arr = [];
arr[3.4] = "Oranges";
console.log(arr.length); // 0
console.log(Object.hasOwn(arr, 3.4)); // true


You can also populate an array when you create it:
jsconst myArray = new Array("Hello", myVar, 3.14159);
// OR
const myArray = ["Mango", "Apple", "Orange"];
Understanding lengthAt the implementation level, JavaScript's arrays actually store their elements as standard object properties, using the array index as the property name.
The length property is special. Its value is always a positive integer greater than the index of the last element if one exists. (In the example below, 'Dusty' is indexed at 30, so cats.length returns 30 + 1).
Remember, JavaScript Array indexes are 0-based: they start at 0, not 1. This means that the length property will be one more than the highest index stored in the array:
jsconst cats = [];
cats[30] = ["Dusty"];
console.log(cats.length); // 31

You can also assign to the length property.
Writing a value that is shorter than the number of stored items truncates the array. Writing 0 empties it entirely:
jsconst cats = ["Dusty", "Misty", "Twiggy"];
console.log(cats.length); // 3

cats.length = 2;
console.log(cats); // [ 'Dusty', 'Misty' ] - Twiggy has been removed

cats.length = 0;
console.log(cats); // []; the cats array is empty

cats.length = 3;
console.log(cats); // [ <3 empty items> ]
Iterating over arraysA common operation is to iterate over the values of an array, processing each one in some way, as follows:
jsconst colors = ["red", "green", "blue"];
for (let i = 0; i < colors.length; i++) {
  console.log(colors[i]);
}

If you know that none of the elements in your array evaluate to false in a boolean context—if your array consists only of DOM nodes, for example—you can use a more efficient idiom:
jsconst divs = document.getElementsByTagName("div");
for (let i = 0, div; (div = divs[i]); i++) {
  /* Process div in some way */
}

This avoids the overhead of checking the length of the array, and ensures that the div variable is reassigned to the current item each time around the loop for added convenience.
The forEach() method provides another way of iterating over an array:
jsconst colors = ["red", "green", "blue"];
colors.forEach((color) => console.log(color));
// red
// green
// blue

The function passed to forEach is executed once for every item in the array, with the array item passed as the argument to the function. Unassigned values are not iterated in a forEach loop.
Note that the elements of an array that are omitted when the array is defined are not listed when iterating by forEach, but are listed when undefined has been manually assigned to the element:
jsconst sparseArray = ["first", "second", , "fourth"];

sparseArray.forEach((element) => {
  console.log(element);
});
// Logs:
// first
// second
// fourth

if (sparseArray[2] === undefined) {
  console.log("sparseArray[2] is undefined"); // true
}

const nonsparseArray = ["first", "second", undefined, "fourth"];

nonsparseArray.forEach((element) => {
  console.log(element);
});
// Logs:
// first
// second
// undefined
// fourth

Since JavaScript array elements are saved as standard object properties, it is not advisable to iterate through JavaScript arrays using for...in loops, because normal elements and all enumerable properties will be listed.Array methodsThe Array object has the following methods:
The concat() method joins two or more arrays and returns a new array.
jslet myArray = ["1", "2", "3"];
myArray = myArray.concat("a", "b", "c");
// myArray is now ["1", "2", "3", "a", "b", "c"]

The join() method joins all elements of an array into a string.
jsconst myArray = ["Wind", "Rain", "Fire"];
const list = myArray.join(" - "); // list is "Wind - Rain - Fire"

The push() method adds one or more elements to the end of an array and returns the resulting length of the array.
jsconst myArray = ["1", "2"];
myArray.push("3"); // myArray is now ["1", "2", "3"]

The pop() method removes the last element from an array and returns that element.
jsconst myArray = ["1", "2", "3"];
const last = myArray.pop();
// myArray is now ["1", "2"], last = "3"

The shift() method removes the first element from an array and returns that element.
jsconst myArray = ["1", "2", "3"];
const first = myArray.shift();
// myArray is now ["2", "3"], first is "1"

The unshift() method adds one or more elements to the front of an array and returns the new length of the array.
jsconst myArray = ["1", "2", "3"];
myArray.unshift("4", "5");
// myArray becomes ["4", "5", "1", "2", "3"]

The slice() method extracts a section of an array and returns a new array.
jslet myArray = ["a", "b", "c", "d", "e"];
myArray = myArray.slice(1, 4); // [ "b", "c", "d"]
// starts at index 1 and extracts all elements
// until index 3

The at() method returns the element at the specified index in the array, or undefined if the index is out of range. It's notably used for negative indices that access elements from the end of the array.
jsconst myArray = ["a", "b", "c", "d", "e"];
myArray.at(-2); // "d", the second-last element of myArray

The splice() method removes elements from an array and (optionally) replaces them. It returns the items which were removed from the array.
jsconst myArray = ["1", "2", "3", "4", "5"];
myArray.splice(1, 3, "a", "b", "c", "d");
// myArray is now ["1", "a", "b", "c", "d", "5"]
// This code started at index one (or where the "2" was),
// removed 3 elements there, and then inserted all consecutive
// elements in its place.

The reverse() method transposes the elements of an array, in place: the first array element becomes the last and the last becomes the first. It returns a reference to the array.
jsconst myArray = ["1", "2", "3"];
myArray.reverse();
// transposes the array so that myArray = ["3", "2", "1"]

The flat() method returns a new array with all sub-array elements concatenated into it recursively up to the specified depth.
jslet myArray = [1, 2, [3, 4]];
myArray = myArray.flat();
// myArray is now [1, 2, 3, 4], since the [3, 4] subarray is flattened

The sort() method sorts the elements of an array in place, and returns a reference to the array.
jsconst myArray = ["Wind", "Rain", "Fire"];
myArray.sort();
// sorts the array so that myArray = ["Fire", "Rain", "Wind"]

sort() can also take a callback function to determine how array elements are compared. The callback function is called with two arguments, which are two values from the array. The function compares these two values and returns a positive number, negative number, or zero, indicating the order of the two values. For instance, the following will sort the array by the last letter of a string:
jsconst sortFn = (a, b) => {
  if (a[a.length - 1] < b[b.length - 1]) {
    return -1; // Negative number => a < b, a comes before b
  } else if (a[a.length - 1] > b[b.length - 1]) {
    return 1; // Positive number => a > b, a comes after b
  }
  return 0; // Zero => a = b, a and b keep their original order
};
myArray.sort(sortFn);
// sorts the array so that myArray = ["Wind","Fire","Rain"]


if a is less than b by the sorting system, return -1 (or any negative number)
if a is greater than b by the sorting system, return 1 (or any positive number)
if a and b are considered equivalent, return 0.

The indexOf() method searches the array for searchElement and returns the index of the first match.
jsconst a = ["a", "b", "a", "b", "a"];
console.log(a.indexOf("b")); // 1

// Now try again, starting from after the last match
console.log(a.indexOf("b", 2)); // 3
console.log(a.indexOf("z")); // -1, because 'z' was not found

The lastIndexOf() method works like indexOf, but starts at the end and searches backwards.
jsconst a = ["a", "b", "c", "d", "a", "b"];
console.log(a.lastIndexOf("b")); // 5

// Now try again, starting from before the last match
console.log(a.lastIndexOf("b", 4)); // 1
console.log(a.lastIndexOf("z")); // -1

The forEach() method executes callback on every array item and returns undefined.
jsconst a = ["a", "b", "c"];
a.forEach((element) => {
  console.log(element);
});
// Logs:
// a
// b
// c

The forEach method (and others below) that take a callback are known as iterative methods, because they iterate over the entire array in some fashion. Each one takes an optional second argument called thisArg. If provided, thisArg becomes the value of the this keyword inside the body of the callback function. If not provided, as with other cases where a function is invoked outside of an explicit object context, this will refer to the global object (window, globalThis, etc.) when the function is not strict, or undefined when the function is strict.

Note:
The sort() method introduced above is not an iterative method, because its callback function is only used for comparison and may not be called in any particular order based on element order. sort() does not accept the thisArg parameter either.

The map() method returns a new array of the return value from executing callback on every array item.
jsconst a1 = ["a", "b", "c"];
const a2 = a1.map((item) => item.toUpperCase());
console.log(a2); // ['A', 'B', 'C']

The flatMap() method runs map() followed by a flat() of depth 1.
jsconst a1 = ["a", "b", "c"];
const a2 = a1.flatMap((item) => [item.toUpperCase(), item.toLowerCase()]);
console.log(a2); // ['A', 'a', 'B', 'b', 'C', 'c']

The filter() method returns a new array containing the items for which callback returned true.
jsconst a1 = ["a", 10, "b", 20, "c", 30];
const a2 = a1.filter((item) => typeof item === "number");
console.log(a2); // [10, 20, 30]

The find() method returns the first item for which callback returned true.
jsconst a1 = ["a", 10, "b", 20, "c", 30];
const i = a1.find((item) => typeof item === "number");
console.log(i); // 10

The findLast() method returns the last item for which callback returned true.
jsconst a1 = ["a", 10, "b", 20, "c", 30];
const i = a1.findLast((item) => typeof item === "number");
console.log(i); // 30

The findIndex() method returns the index of the first item for which callback returned true.
jsconst a1 = ["a", 10, "b", 20, "c", 30];
const i = a1.findIndex((item) => typeof item === "number");
console.log(i); // 1

The findLastIndex() method returns the index of the last item for which callback returned true.
jsconst a1 = ["a", 10, "b", 20, "c", 30];
const i = a1.findLastIndex((item) => typeof item === "number");
console.log(i); // 5

The every() method returns true if callback returns true for every item in the array.
jsfunction isNumber(value) {
  return typeof value === "number";
}
const a1 = [1, 2, 3];
console.log(a1.every(isNumber)); // true
const a2 = [1, "2", 3];
console.log(a2.every(isNumber)); // false

The some() method returns true if callback returns true for at least one item in the array.
jsfunction isNumber(value) {
  return typeof value === "number";
}
const a1 = [1, 2, 3];
console.log(a1.some(isNumber)); // true
const a2 = [1, "2", 3];
console.log(a2.some(isNumber)); // true
const a3 = ["1", "2", "3"];
console.log(a3.some(isNumber)); // false

The reduce() method applies callback(accumulator, currentValue, currentIndex, array) for each value in the array for the purpose of reducing the list of items down to a single value. The reduce function returns the final value returned by callback function.
If initialValue is specified, then callback is called with initialValue as the first parameter value and the value of the first item in the array as the second parameter value.
If initialValue is not specified, then callback's first two parameter values will be the first and second elements of the array. On every subsequent call, the first parameter's value will be whatever callback returned on the previous call, and the second parameter's value will be the next value in the array.
If callback needs access to the index of the item being processed, or access to the entire array, they are available as optional parameters.
jsconst a = [10, 20, 30];
const total = a.reduce(
  (accumulator, currentValue) => accumulator + currentValue,
  0,
);
console.log(total); // 60

The reduceRight() method works like reduce(), but starts with the last element.
reduce and reduceRight are the least obvious of the iterative array methods. They should be used for algorithms that combine two values recursively in order to reduce a sequence down to a single value.Array transformationsYou can transform back and forth between arrays and other data structures.Grouping the elements of an arrayThe Object.groupBy() method can be used to group the elements of an array, using a test function that returns a string indicating the group of the current element.
Here we have an inventory array that contains "food" objects that have a name and a type.
jsconst inventory = [
  { name: "asparagus", type: "vegetables" },
  { name: "bananas", type: "fruit" },
  { name: "goat", type: "meat" },
  { name: "cherries", type: "fruit" },
  { name: "fish", type: "meat" },
];

To use Object.groupBy(), you supply a callback function that is called with the current element, and optionally the current index and array, and returns a string indicating the group of the element.
The code below uses an arrow function to return the type of each array element (this uses object destructuring syntax for function arguments to unpack the type element from the passed object). The result is an object that has properties named after the unique strings returned by the callback. Each property is assigned an array containing the elements in the group.
jsconst result = Object.groupBy(inventory, ({ type }) => type);
console.log(result);
// Logs
// {
//   vegetables: [{ name: 'asparagus', type: 'vegetables' }],
//   fruit: [
//     { name: 'bananas', type: 'fruit' },
//     { name: 'cherries', type: 'fruit' }
//   ],
//   meat: [
//     { name: 'goat', type: 'meat' },
//     { name: 'fish', type: 'meat' }
//   ]
// }

Note that the returned object references the same elements as the original array (not deep copies). Changing the internal structure of these elements will be reflected in both the original array and the returned object.
If you can't use a string as the key, for example, if the information to group is associated with an object that might change, then you can instead use Map.groupBy(). This is very similar to Object.groupBy() except that it groups the elements of the array into a Map that can use an arbitrary value (object or primitive) as a key.Sparse arraysArrays can contain "empty slots", which are not the same as slots filled with the value undefined. Empty slots can be created in one of the following ways:
js// Array constructor:
const a = Array(5); // [ <5 empty items> ]

// Consecutive commas in array literal:
const b = [1, 2, , , 5]; // [ 1, 2, <2 empty items>, 5 ]

// Directly setting a slot with index greater than array.length:
const c = [1, 2];
c[4] = 5; // [ 1, 2, <2 empty items>, 5 ]

// Elongating an array by directly setting .length:
const d = [1, 2];
d.length = 5; // [ 1, 2, <3 empty items> ]

// Deleting an element:
const e = [1, 2, 3, 4, 5];
delete e[2]; // [ 1, 2, <1 empty item>, 4, 5 ]

In some operations, empty slots behave as if they are filled with undefined.
jsconst arr = [1, 2, , , 5]; // Create a sparse array

// Indexed access
console.log(arr[2]); // undefined

// For...of
for (const i of arr) {
  console.log(i);
}
// Logs: 1 2 undefined undefined 5

// Spreading
const another = [...arr]; // "another" is [ 1, 2, undefined, undefined, 5 ]

But in others (most notably array iteration methods), empty slots are skipped.
jsconst mapped = arr.map((i) => i + 1); // [ 2, 3, <2 empty items>, 6 ]
arr.forEach((i) => console.log(i)); // 1 2 5
const filtered = arr.filter(() => true); // [ 1, 2, 5 ]
const hasFalsy = arr.some((k) => !k); // false

// Property enumeration
const keys = Object.keys(arr); // [ '0', '1', '4' ]
for (const key in arr) {
  console.log(key);
}
// Logs: '0' '1' '4'
// Spreading into an object uses property enumeration, not the array's iterator
const objectSpread = { ...arr }; // { '0': 1, '1': 2, '4': 5 }

For a complete list of how array methods behave with sparse arrays, see the Array reference page.Multi-dimensional arraysArrays can be nested, meaning that an array can contain another array as an element. Using this characteristic of JavaScript arrays, multi-dimensional arrays can be created.
The following code creates a two-dimensional array.
jsconst a = new Array(4);
for (let i = 0; i < 4; i++) {
  a[i] = new Array(4);
  for (let j = 0; j < 4; j++) {
    a[i][j] = `[${i}, ${j}]`;
  }
}

This example creates an array with the following rows:
Row 0: [0, 0] [0, 1] [0, 2] [0, 3]
Row 1: [1, 0] [1, 1] [1, 2] [1, 3]
Row 2: [2, 0] [2, 1] [2, 2] [2, 3]
Row 3: [3, 0] [3, 1] [3, 2] [3, 3]
Using arrays to store other propertiesArrays can also be used like objects, to store related information.
jsconst arr = [1, 2, 3];
arr.property = "value";
console.log(arr.property); // "value"

For example, when an array is the result of a match between a regular expression and a string, the array returns properties and elements that provide information about the match. An array is the return value of RegExp.prototype.exec(), String.prototype.match(), and String.prototype.split(). For information on using arrays with regular expressions, see Regular Expressions.Working with array-like objectsSome JavaScript objects, such as the NodeList returned by document.getElementsByTagName() or the arguments object made available within the body of a function, look and behave like arrays on the surface but do not share all of their methods. The arguments object provides a length attribute but does not implement array methods like forEach().
Array methods cannot be called directly on array-like objects.
jsfunction printArguments() {
  arguments.forEach((item) => {
    console.log(item);
  }); // TypeError: arguments.forEach is not a function
}

But you can call them indirectly using Function.prototype.call().
jsfunction printArguments() {
  Array.prototype.forEach.call(arguments, (item) => {
    console.log(item);
  });
}

Array prototype methods can be used on strings as well, since they provide sequential access to their characters in a similar way to arrays:
jsArray.prototype.forEach.call("a string", (chr) => {
  console.log(chr);
});

 Previous  Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 19, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIndexed collections 
 Previous  Next  
This chapter introduces collections of data which are ordered by an index value. This includes arrays and array-like constructs such as Array objects and TypedArray objects.
An array is an ordered list of values that you refer to with a name and an index.
For example, consider an array called emp, which contains employees' names indexed by their numerical employee number. So emp[0] would be employee number zero, emp[1] employee number one, and so on.
JavaScript does not have an explicit array data type. However, you can use the predefined Array object and its methods to work with arrays in your applications. The Array object has methods for manipulating arrays in various ways, such as joining, reversing, and sorting them. It has a property for determining the array length and other properties for use with regular expressions.
We will be focusing on arrays in this article, but many of the same concepts apply to typed arrays as well, since arrays and typed arrays share many similar methods. For more information on typed arrays, see the typed array guide.Creating an arrayThe following statements create equivalent arrays:
jsconst arr1 = new Array(element0, element1, /* …, */ elementN);
const arr2 = Array(element0, element1, /* …, */ elementN);
const arr3 = [element0, element1, /* …, */ elementN];

element0, element1, …, elementN is a list of values for the array's elements. When these values are specified, the array is initialized with them as the array's elements. The array's length property is set to the number of arguments.
The bracket syntax is called an "array literal" or "array initializer." It's shorter than other forms of array creation, and so is generally preferred. See Array literals for details.
To create an array with non-zero length, but without any items, either of the following can be used:
js// This...
const arr1 = new Array(arrayLength);

// ...results in the same array as this
const arr2 = Array(arrayLength);

// This has exactly the same effect
const arr3 = [];
arr3.length = arrayLength;


Note:
In the above code, arrayLength must be a Number. Otherwise, an array with a single element (the provided value) will be created. Calling arr.length will return arrayLength, but the array doesn't contain any elements. A for...in loop will not find any property on the array.

In addition to a newly defined variable as shown above, arrays can also be assigned as a property of a new or an existing object:
jsconst obj = {};
// …
obj.prop = [element0, element1, /* …, */ elementN];

// OR
const obj = { prop: [element0, element1, /* …, */ elementN] };

If you wish to initialize an array with a single element, and the element happens to be a Number, you must use the bracket syntax. When a single Number value is passed to the Array() constructor or function, it is interpreted as an arrayLength, not as a single element.
This creates an array with only one element: the number 42.
jsconst arr = [42];

This creates an array with no elements and arr.length set to 42.
jsconst arr = Array(42);

This is equivalent to:
jsconst arr = [];
arr.length = 42;

Calling Array(N) results in a RangeError, if N is a non-whole number whose fractional portion is non-zero. The following example illustrates this behavior.
jsconst arr = Array(9.3); // RangeError: Invalid array length

If your code needs to create arrays with single elements of an arbitrary data type, it is safer to use array literals. Alternatively, create an empty array first before adding the single element to it.
You can also use the Array.of static method to create arrays with single element.
jsconst arr = Array.of(9.3); // arr contains only one element 9.3
Referring to array elementsBecause elements are also properties, you can access them using property accessors. Suppose you define the following array:
jsconst myArray = ["Wind", "Rain", "Fire"];

You can refer to the first element of the array as myArray[0], the second element of the array as myArray[1], etc… The index of the elements begins with zero.

Note:
You can also use property accessors to access other properties of the array, like with an object.
jsconst arr = ["one", "two", "three"];
arr[2]; // three
arr["length"]; // 3

Populating an arrayYou can populate an array by assigning values to its elements. For example:
jsconst emp = [];
emp[0] = "Casey Jones";
emp[1] = "Phil Lesh";
emp[2] = "August West";


Note:
If you supply a non-integer value to the array operator in the code above, a property will be created in the object representing the array, instead of an array element.
jsconst arr = [];
arr[3.4] = "Oranges";
console.log(arr.length); // 0
console.log(Object.hasOwn(arr, 3.4)); // true


You can also populate an array when you create it:
jsconst myArray = new Array("Hello", myVar, 3.14159);
// OR
const myArray = ["Mango", "Apple", "Orange"];
Understanding lengthAt the implementation level, JavaScript's arrays actually store their elements as standard object properties, using the array index as the property name.
The length property is special. Its value is always a positive integer greater than the index of the last element if one exists. (In the example below, 'Dusty' is indexed at 30, so cats.length returns 30 + 1).
Remember, JavaScript Array indexes are 0-based: they start at 0, not 1. This means that the length property will be one more than the highest index stored in the array:
jsconst cats = [];
cats[30] = ["Dusty"];
console.log(cats.length); // 31

You can also assign to the length property.
Writing a value that is shorter than the number of stored items truncates the array. Writing 0 empties it entirely:
jsconst cats = ["Dusty", "Misty", "Twiggy"];
console.log(cats.length); // 3

cats.length = 2;
console.log(cats); // [ 'Dusty', 'Misty' ] - Twiggy has been removed

cats.length = 0;
console.log(cats); // []; the cats array is empty

cats.length = 3;
console.log(cats); // [ <3 empty items> ]
Iterating over arraysA common operation is to iterate over the values of an array, processing each one in some way, as follows:
jsconst colors = ["red", "green", "blue"];
for (let i = 0; i < colors.length; i++) {
  console.log(colors[i]);
}

If you know that none of the elements in your array evaluate to false in a boolean context—if your array consists only of DOM nodes, for example—you can use a more efficient idiom:
jsconst divs = document.getElementsByTagName("div");
for (let i = 0, div; (div = divs[i]); i++) {
  /* Process div in some way */
}

This avoids the overhead of checking the length of the array, and ensures that the div variable is reassigned to the current item each time around the loop for added convenience.
The forEach() method provides another way of iterating over an array:
jsconst colors = ["red", "green", "blue"];
colors.forEach((color) => console.log(color));
// red
// green
// blue

The function passed to forEach is executed once for every item in the array, with the array item passed as the argument to the function. Unassigned values are not iterated in a forEach loop.
Note that the elements of an array that are omitted when the array is defined are not listed when iterating by forEach, but are listed when undefined has been manually assigned to the element:
jsconst sparseArray = ["first", "second", , "fourth"];

sparseArray.forEach((element) => {
  console.log(element);
});
// Logs:
// first
// second
// fourth

if (sparseArray[2] === undefined) {
  console.log("sparseArray[2] is undefined"); // true
}

const nonsparseArray = ["first", "second", undefined, "fourth"];

nonsparseArray.forEach((element) => {
  console.log(element);
});
// Logs:
// first
// second
// undefined
// fourth

Since JavaScript array elements are saved as standard object properties, it is not advisable to iterate through JavaScript arrays using for...in loops, because normal elements and all enumerable properties will be listed.Array methodsThe Array object has the following methods:
The concat() method joins two or more arrays and returns a new array.
jslet myArray = ["1", "2", "3"];
myArray = myArray.concat("a", "b", "c");
// myArray is now ["1", "2", "3", "a", "b", "c"]

The join() method joins all elements of an array into a string.
jsconst myArray = ["Wind", "Rain", "Fire"];
const list = myArray.join(" - "); // list is "Wind - Rain - Fire"

The push() method adds one or more elements to the end of an array and returns the resulting length of the array.
jsconst myArray = ["1", "2"];
myArray.push("3"); // myArray is now ["1", "2", "3"]

The pop() method removes the last element from an array and returns that element.
jsconst myArray = ["1", "2", "3"];
const last = myArray.pop();
// myArray is now ["1", "2"], last = "3"

The shift() method removes the first element from an array and returns that element.
jsconst myArray = ["1", "2", "3"];
const first = myArray.shift();
// myArray is now ["2", "3"], first is "1"

The unshift() method adds one or more elements to the front of an array and returns the new length of the array.
jsconst myArray = ["1", "2", "3"];
myArray.unshift("4", "5");
// myArray becomes ["4", "5", "1", "2", "3"]

The slice() method extracts a section of an array and returns a new array.
jslet myArray = ["a", "b", "c", "d", "e"];
myArray = myArray.slice(1, 4); // [ "b", "c", "d"]
// starts at index 1 and extracts all elements
// until index 3

The at() method returns the element at the specified index in the array, or undefined if the index is out of range. It's notably used for negative indices that access elements from the end of the array.
jsconst myArray = ["a", "b", "c", "d", "e"];
myArray.at(-2); // "d", the second-last element of myArray

The splice() method removes elements from an array and (optionally) replaces them. It returns the items which were removed from the array.
jsconst myArray = ["1", "2", "3", "4", "5"];
myArray.splice(1, 3, "a", "b", "c", "d");
// myArray is now ["1", "a", "b", "c", "d", "5"]
// This code started at index one (or where the "2" was),
// removed 3 elements there, and then inserted all consecutive
// elements in its place.

The reverse() method transposes the elements of an array, in place: the first array element becomes the last and the last becomes the first. It returns a reference to the array.
jsconst myArray = ["1", "2", "3"];
myArray.reverse();
// transposes the array so that myArray = ["3", "2", "1"]

The flat() method returns a new array with all sub-array elements concatenated into it recursively up to the specified depth.
jslet myArray = [1, 2, [3, 4]];
myArray = myArray.flat();
// myArray is now [1, 2, 3, 4], since the [3, 4] subarray is flattened

The sort() method sorts the elements of an array in place, and returns a reference to the array.
jsconst myArray = ["Wind", "Rain", "Fire"];
myArray.sort();
// sorts the array so that myArray = ["Fire", "Rain", "Wind"]

sort() can also take a callback function to determine how array elements are compared. The callback function is called with two arguments, which are two values from the array. The function compares these two values and returns a positive number, negative number, or zero, indicating the order of the two values. For instance, the following will sort the array by the last letter of a string:
jsconst sortFn = (a, b) => {
  if (a[a.length - 1] < b[b.length - 1]) {
    return -1; // Negative number => a < b, a comes before b
  } else if (a[a.length - 1] > b[b.length - 1]) {
    return 1; // Positive number => a > b, a comes after b
  }
  return 0; // Zero => a = b, a and b keep their original order
};
myArray.sort(sortFn);
// sorts the array so that myArray = ["Wind","Fire","Rain"]


if a is less than b by the sorting system, return -1 (or any negative number)
if a is greater than b by the sorting system, return 1 (or any positive number)
if a and b are considered equivalent, return 0.

The indexOf() method searches the array for searchElement and returns the index of the first match.
jsconst a = ["a", "b", "a", "b", "a"];
console.log(a.indexOf("b")); // 1

// Now try again, starting from after the last match
console.log(a.indexOf("b", 2)); // 3
console.log(a.indexOf("z")); // -1, because 'z' was not found

The lastIndexOf() method works like indexOf, but starts at the end and searches backwards.
jsconst a = ["a", "b", "c", "d", "a", "b"];
console.log(a.lastIndexOf("b")); // 5

// Now try again, starting from before the last match
console.log(a.lastIndexOf("b", 4)); // 1
console.log(a.lastIndexOf("z")); // -1

The forEach() method executes callback on every array item and returns undefined.
jsconst a = ["a", "b", "c"];
a.forEach((element) => {
  console.log(element);
});
// Logs:
// a
// b
// c

The forEach method (and others below) that take a callback are known as iterative methods, because they iterate over the entire array in some fashion. Each one takes an optional second argument called thisArg. If provided, thisArg becomes the value of the this keyword inside the body of the callback function. If not provided, as with other cases where a function is invoked outside of an explicit object context, this will refer to the global object (window, globalThis, etc.) when the function is not strict, or undefined when the function is strict.

Note:
The sort() method introduced above is not an iterative method, because its callback function is only used for comparison and may not be called in any particular order based on element order. sort() does not accept the thisArg parameter either.

The map() method returns a new array of the return value from executing callback on every array item.
jsconst a1 = ["a", "b", "c"];
const a2 = a1.map((item) => item.toUpperCase());
console.log(a2); // ['A', 'B', 'C']

The flatMap() method runs map() followed by a flat() of depth 1.
jsconst a1 = ["a", "b", "c"];
const a2 = a1.flatMap((item) => [item.toUpperCase(), item.toLowerCase()]);
console.log(a2); // ['A', 'a', 'B', 'b', 'C', 'c']

The filter() method returns a new array containing the items for which callback returned true.
jsconst a1 = ["a", 10, "b", 20, "c", 30];
const a2 = a1.filter((item) => typeof item === "number");
console.log(a2); // [10, 20, 30]

The find() method returns the first item for which callback returned true.
jsconst a1 = ["a", 10, "b", 20, "c", 30];
const i = a1.find((item) => typeof item === "number");
console.log(i); // 10

The findLast() method returns the last item for which callback returned true.
jsconst a1 = ["a", 10, "b", 20, "c", 30];
const i = a1.findLast((item) => typeof item === "number");
console.log(i); // 30

The findIndex() method returns the index of the first item for which callback returned true.
jsconst a1 = ["a", 10, "b", 20, "c", 30];
const i = a1.findIndex((item) => typeof item === "number");
console.log(i); // 1

The findLastIndex() method returns the index of the last item for which callback returned true.
jsconst a1 = ["a", 10, "b", 20, "c", 30];
const i = a1.findLastIndex((item) => typeof item === "number");
console.log(i); // 5

The every() method returns true if callback returns true for every item in the array.
jsfunction isNumber(value) {
  return typeof value === "number";
}
const a1 = [1, 2, 3];
console.log(a1.every(isNumber)); // true
const a2 = [1, "2", 3];
console.log(a2.every(isNumber)); // false

The some() method returns true if callback returns true for at least one item in the array.
jsfunction isNumber(value) {
  return typeof value === "number";
}
const a1 = [1, 2, 3];
console.log(a1.some(isNumber)); // true
const a2 = [1, "2", 3];
console.log(a2.some(isNumber)); // true
const a3 = ["1", "2", "3"];
console.log(a3.some(isNumber)); // false

The reduce() method applies callback(accumulator, currentValue, currentIndex, array) for each value in the array for the purpose of reducing the list of items down to a single value. The reduce function returns the final value returned by callback function.
If initialValue is specified, then callback is called with initialValue as the first parameter value and the value of the first item in the array as the second parameter value.
If initialValue is not specified, then callback's first two parameter values will be the first and second elements of the array. On every subsequent call, the first parameter's value will be whatever callback returned on the previous call, and the second parameter's value will be the next value in the array.
If callback needs access to the index of the item being processed, or access to the entire array, they are available as optional parameters.
jsconst a = [10, 20, 30];
const total = a.reduce(
  (accumulator, currentValue) => accumulator + currentValue,
  0,
);
console.log(total); // 60

The reduceRight() method works like reduce(), but starts with the last element.
reduce and reduceRight are the least obvious of the iterative array methods. They should be used for algorithms that combine two values recursively in order to reduce a sequence down to a single value.Array transformationsYou can transform back and forth between arrays and other data structures.Grouping the elements of an arrayThe Object.groupBy() method can be used to group the elements of an array, using a test function that returns a string indicating the group of the current element.
Here we have an inventory array that contains "food" objects that have a name and a type.
jsconst inventory = [
  { name: "asparagus", type: "vegetables" },
  { name: "bananas", type: "fruit" },
  { name: "goat", type: "meat" },
  { name: "cherries", type: "fruit" },
  { name: "fish", type: "meat" },
];

To use Object.groupBy(), you supply a callback function that is called with the current element, and optionally the current index and array, and returns a string indicating the group of the element.
The code below uses an arrow function to return the type of each array element (this uses object destructuring syntax for function arguments to unpack the type element from the passed object). The result is an object that has properties named after the unique strings returned by the callback. Each property is assigned an array containing the elements in the group.
jsconst result = Object.groupBy(inventory, ({ type }) => type);
console.log(result);
// Logs
// {
//   vegetables: [{ name: 'asparagus', type: 'vegetables' }],
//   fruit: [
//     { name: 'bananas', type: 'fruit' },
//     { name: 'cherries', type: 'fruit' }
//   ],
//   meat: [
//     { name: 'goat', type: 'meat' },
//     { name: 'fish', type: 'meat' }
//   ]
// }

Note that the returned object references the same elements as the original array (not deep copies). Changing the internal structure of these elements will be reflected in both the original array and the returned object.
If you can't use a string as the key, for example, if the information to group is associated with an object that might change, then you can instead use Map.groupBy(). This is very similar to Object.groupBy() except that it groups the elements of the array into a Map that can use an arbitrary value (object or primitive) as a key.Sparse arraysArrays can contain "empty slots", which are not the same as slots filled with the value undefined. Empty slots can be created in one of the following ways:
js// Array constructor:
const a = Array(5); // [ <5 empty items> ]

// Consecutive commas in array literal:
const b = [1, 2, , , 5]; // [ 1, 2, <2 empty items>, 5 ]

// Directly setting a slot with index greater than array.length:
const c = [1, 2];
c[4] = 5; // [ 1, 2, <2 empty items>, 5 ]

// Elongating an array by directly setting .length:
const d = [1, 2];
d.length = 5; // [ 1, 2, <3 empty items> ]

// Deleting an element:
const e = [1, 2, 3, 4, 5];
delete e[2]; // [ 1, 2, <1 empty item>, 4, 5 ]

In some operations, empty slots behave as if they are filled with undefined.
jsconst arr = [1, 2, , , 5]; // Create a sparse array

// Indexed access
console.log(arr[2]); // undefined

// For...of
for (const i of arr) {
  console.log(i);
}
// Logs: 1 2 undefined undefined 5

// Spreading
const another = [...arr]; // "another" is [ 1, 2, undefined, undefined, 5 ]

But in others (most notably array iteration methods), empty slots are skipped.
jsconst mapped = arr.map((i) => i + 1); // [ 2, 3, <2 empty items>, 6 ]
arr.forEach((i) => console.log(i)); // 1 2 5
const filtered = arr.filter(() => true); // [ 1, 2, 5 ]
const hasFalsy = arr.some((k) => !k); // false

// Property enumeration
const keys = Object.keys(arr); // [ '0', '1', '4' ]
for (const key in arr) {
  console.log(key);
}
// Logs: '0' '1' '4'
// Spreading into an object uses property enumeration, not the array's iterator
const objectSpread = { ...arr }; // { '0': 1, '1': 2, '4': 5 }

For a complete list of how array methods behave with sparse arrays, see the Array reference page.Multi-dimensional arraysArrays can be nested, meaning that an array can contain another array as an element. Using this characteristic of JavaScript arrays, multi-dimensional arrays can be created.
The following code creates a two-dimensional array.
jsconst a = new Array(4);
for (let i = 0; i < 4; i++) {
  a[i] = new Array(4);
  for (let j = 0; j < 4; j++) {
    a[i][j] = `[${i}, ${j}]`;
  }
}

This example creates an array with the following rows:
Row 0: [0, 0] [0, 1] [0, 2] [0, 3]
Row 1: [1, 0] [1, 1] [1, 2] [1, 3]
Row 2: [2, 0] [2, 1] [2, 2] [2, 3]
Row 3: [3, 0] [3, 1] [3, 2] [3, 3]
Using arrays to store other propertiesArrays can also be used like objects, to store related information.
jsconst arr = [1, 2, 3];
arr.property = "value";
console.log(arr.property); // "value"

For example, when an array is the result of a match between a regular expression and a string, the array returns properties and elements that provide information about the match. An array is the return value of RegExp.prototype.exec(), String.prototype.match(), and String.prototype.split(). For information on using arrays with regular expressions, see Regular Expressions.Working with array-like objectsSome JavaScript objects, such as the NodeList returned by document.getElementsByTagName() or the arguments object made available within the body of a function, look and behave like arrays on the surface but do not share all of their methods. The arguments object provides a length attribute but does not implement array methods like forEach().
Array methods cannot be called directly on array-like objects.
jsfunction printArguments() {
  arguments.forEach((item) => {
    console.log(item);
  }); // TypeError: arguments.forEach is not a function
}

But you can call them indirectly using Function.prototype.call().
jsfunction printArguments() {
  Array.prototype.forEach.call(arguments, (item) => {
    console.log(item);
  });
}

Array prototype methods can be used on strings as well, since they provide sequential access to their characters in a similar way to arrays:
jsArray.prototype.forEach.call("a string", (chr) => {
  console.log(chr);
});

 Previous  Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 19, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nKeyed collections 
 Previous  Next  
This chapter introduces collections of data which are indexed by a key; Map and Set objects contain elements which are iterable in the order of insertion.MapsMap objectA Map object is a key/value map that can iterate its elements in insertion order.
The following code shows some basic operations with a Map. See also the Map reference page for more examples and the complete API. You can use a for...of loop to return an array of [key, value] for each iteration.
jsconst sayings = new Map();
sayings.set("dog", "woof");
sayings.set("cat", "meow");
sayings.set("elephant", "toot");
sayings.size; // 3
sayings.get("dog"); // woof
sayings.get("fox"); // undefined
sayings.has("bird"); // false
sayings.delete("dog");
sayings.has("dog"); // false

for (const [key, value] of sayings) {
  console.log(`${key} goes ${value}`);
}
// "cat goes meow"
// "elephant goes toot"

sayings.clear();
sayings.size; // 0
Object and Map comparedTraditionally, objects have been used to map strings to values. Objects allow you to set keys to values, retrieve those values, delete keys, and detect whether something is stored at a key. Map objects, however, have a few more advantages that make them better maps.

The keys of an Object are strings or symbols, whereas they can be of any value for a Map.
You can get the size of a Map easily, while you have to manually keep track of size for an Object.
The iteration of maps is in insertion order of the elements.
An Object has a prototype, so there are default keys in the map. (This can be bypassed using map = Object.create(null).)

These three tips can help you to decide whether to use a Map or an Object:

Use maps over objects when keys are unknown until run time, and when all keys are the same type and all values are the same type.
Use maps if there is a need to store primitive values as keys because object treats each key as a string whether it's a number value, boolean value or any other primitive value.
Use objects when there is logic that operates on individual elements.
WeakMap objectA WeakMap is a collection of key/value pairs whose keys must be objects or non-registered symbols, with values of any arbitrary JavaScript type, and which does not create strong references to its keys. That is, an object's presence as a key in a WeakMap does not prevent the object from being garbage collected. Once an object used as a key has been collected, its corresponding values in any WeakMap become candidates for garbage collection as well — as long as they aren't strongly referred to elsewhere. The only primitive type that can be used as a WeakMap key is symbol — more specifically, non-registered symbols — because non-registered symbols are guaranteed to be unique and cannot be re-created.
The WeakMap API is essentially the same as the Map API. However, a WeakMap doesn't allow observing the liveness of its keys, which is why it doesn't allow enumeration. So there is no method to obtain a list of the keys in a WeakMap. If there were, the list would depend on the state of garbage collection, introducing non-determinism.
For more information and example code, see also "Why WeakMap?" on the WeakMap reference page.
One use case of WeakMap objects is to store private data for an object, or to hide implementation details. The following example is from Nick Fitzgerald's blog post "Hiding Implementation Details with ECMAScript 6 WeakMaps". The private data and methods belong inside the object and are stored in the privates object, which is a WeakMap. Everything exposed on the instance and prototype is public; everything else is inaccessible from the outside world because privates is not exported from the module.
jsconst privates = new WeakMap();

function Public() {
  const me = {
    // Private data goes here
  };
  privates.set(this, me);
}

Public.prototype.method = function () {
  const me = privates.get(this);
  // Do stuff with private data in `me`
  // …
};

module.exports = Public;
SetsSet objectSet objects are collections of unique values. You can iterate its elements in insertion order. A value in a Set may only occur once; it is unique in the Set's collection.
The following code shows some basic operations with a Set. See also the Set reference page for more examples and the complete API.
jsconst mySet = new Set();
mySet.add(1);
mySet.add("some text");
mySet.add("foo");

mySet.has(1); // true
mySet.delete("foo");
mySet.size; // 2

for (const item of mySet) {
  console.log(item);
}
// 1
// "some text"
Converting between Array and SetYou can create an Array from a Set using Array.from or the spread syntax. Also, the Set constructor accepts an Array to convert in the other direction.

Note: Set objects store unique values—so any duplicate elements from an Array are deleted when converting!

jsArray.from(mySet);
[...mySet2];

mySet2 = new Set([1, 2, 3, 4]);
Array and Set comparedTraditionally, a set of elements has been stored in arrays in JavaScript in a lot of situations. The Set object, however, has some advantages:

Deleting Array elements by value (arr.splice(arr.indexOf(val), 1)) is very slow.
Set objects let you delete elements by their value. With an array, you would have to splice based on an element's index.
The value NaN cannot be found with indexOf in an array.
Set objects store unique values. You don't have to manually keep track of duplicates.
WeakSet objectWeakSet objects are collections of garbage-collectable values, including objects and non-registered symbols. A value in the WeakSet may only occur once. It is unique in the WeakSet's collection.
The main differences to the Set object are:

In contrast to Sets, WeakSets are collections of objects or symbols only, and not of arbitrary values of any type.
The WeakSet is weak: References to objects in the collection are held weakly. If there is no other reference to an object stored in the WeakSet, they can be garbage collected. That also means that there is no list of current objects stored in the collection.
WeakSets are not enumerable.

The use cases of WeakSet objects are limited. They will not leak memory, so it can be safe to use DOM elements as a key and mark them for tracking purposes, for example.Key and value equality of Map and SetBoth the key equality of Map objects and the value equality of Set objects are based on the SameValueZero algorithm:

Equality works like the identity comparison operator ===.
-0 and +0 are considered equal.
NaN is considered equal to itself (contrary to ===).

 Previous  Next\n\nKeyed collections 
 Previous  Next  
This chapter introduces collections of data which are indexed by a key; Map and Set objects contain elements which are iterable in the order of insertion.MapsMap objectA Map object is a key/value map that can iterate its elements in insertion order.
The following code shows some basic operations with a Map. See also the Map reference page for more examples and the complete API. You can use a for...of loop to return an array of [key, value] for each iteration.
jsconst sayings = new Map();
sayings.set("dog", "woof");
sayings.set("cat", "meow");
sayings.set("elephant", "toot");
sayings.size; // 3
sayings.get("dog"); // woof
sayings.get("fox"); // undefined
sayings.has("bird"); // false
sayings.delete("dog");
sayings.has("dog"); // false

for (const [key, value] of sayings) {
  console.log(`${key} goes ${value}`);
}
// "cat goes meow"
// "elephant goes toot"

sayings.clear();
sayings.size; // 0
Object and Map comparedTraditionally, objects have been used to map strings to values. Objects allow you to set keys to values, retrieve those values, delete keys, and detect whether something is stored at a key. Map objects, however, have a few more advantages that make them better maps.

The keys of an Object are strings or symbols, whereas they can be of any value for a Map.
You can get the size of a Map easily, while you have to manually keep track of size for an Object.
The iteration of maps is in insertion order of the elements.
An Object has a prototype, so there are default keys in the map. (This can be bypassed using map = Object.create(null).)

These three tips can help you to decide whether to use a Map or an Object:

Use maps over objects when keys are unknown until run time, and when all keys are the same type and all values are the same type.
Use maps if there is a need to store primitive values as keys because object treats each key as a string whether it's a number value, boolean value or any other primitive value.
Use objects when there is logic that operates on individual elements.
WeakMap objectA WeakMap is a collection of key/value pairs whose keys must be objects or non-registered symbols, with values of any arbitrary JavaScript type, and which does not create strong references to its keys. That is, an object's presence as a key in a WeakMap does not prevent the object from being garbage collected. Once an object used as a key has been collected, its corresponding values in any WeakMap become candidates for garbage collection as well — as long as they aren't strongly referred to elsewhere. The only primitive type that can be used as a WeakMap key is symbol — more specifically, non-registered symbols — because non-registered symbols are guaranteed to be unique and cannot be re-created.
The WeakMap API is essentially the same as the Map API. However, a WeakMap doesn't allow observing the liveness of its keys, which is why it doesn't allow enumeration. So there is no method to obtain a list of the keys in a WeakMap. If there were, the list would depend on the state of garbage collection, introducing non-determinism.
For more information and example code, see also "Why WeakMap?" on the WeakMap reference page.
One use case of WeakMap objects is to store private data for an object, or to hide implementation details. The following example is from Nick Fitzgerald's blog post "Hiding Implementation Details with ECMAScript 6 WeakMaps". The private data and methods belong inside the object and are stored in the privates object, which is a WeakMap. Everything exposed on the instance and prototype is public; everything else is inaccessible from the outside world because privates is not exported from the module.
jsconst privates = new WeakMap();

function Public() {
  const me = {
    // Private data goes here
  };
  privates.set(this, me);
}

Public.prototype.method = function () {
  const me = privates.get(this);
  // Do stuff with private data in `me`
  // …
};

module.exports = Public;
SetsSet objectSet objects are collections of unique values. You can iterate its elements in insertion order. A value in a Set may only occur once; it is unique in the Set's collection.
The following code shows some basic operations with a Set. See also the Set reference page for more examples and the complete API.
jsconst mySet = new Set();
mySet.add(1);
mySet.add("some text");
mySet.add("foo");

mySet.has(1); // true
mySet.delete("foo");
mySet.size; // 2

for (const item of mySet) {
  console.log(item);
}
// 1
// "some text"
Converting between Array and SetYou can create an Array from a Set using Array.from or the spread syntax. Also, the Set constructor accepts an Array to convert in the other direction.

Note: Set objects store unique values—so any duplicate elements from an Array are deleted when converting!

jsArray.from(mySet);
[...mySet2];

mySet2 = new Set([1, 2, 3, 4]);
Array and Set comparedTraditionally, a set of elements has been stored in arrays in JavaScript in a lot of situations. The Set object, however, has some advantages:

Deleting Array elements by value (arr.splice(arr.indexOf(val), 1)) is very slow.
Set objects let you delete elements by their value. With an array, you would have to splice based on an element's index.
The value NaN cannot be found with indexOf in an array.
Set objects store unique values. You don't have to manually keep track of duplicates.
WeakSet objectWeakSet objects are collections of garbage-collectable values, including objects and non-registered symbols. A value in the WeakSet may only occur once. It is unique in the WeakSet's collection.
The main differences to the Set object are:

In contrast to Sets, WeakSets are collections of objects or symbols only, and not of arbitrary values of any type.
The WeakSet is weak: References to objects in the collection are held weakly. If there is no other reference to an object stored in the WeakSet, they can be garbage collected. That also means that there is no list of current objects stored in the collection.
WeakSets are not enumerable.

The use cases of WeakSet objects are limited. They will not leak memory, so it can be safe to use DOM elements as a key and mark them for tracking purposes, for example.Key and value equality of Map and SetBoth the key equality of Map objects and the value equality of Set objects are based on the SameValueZero algorithm:

Equality works like the identity comparison operator ===.
-0 and +0 are considered equal.
NaN is considered equal to itself (contrary to ===).

 Previous  Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nKeyed collections 
 Previous  Next  
This chapter introduces collections of data which are indexed by a key; Map and Set objects contain elements which are iterable in the order of insertion.MapsMap objectA Map object is a key/value map that can iterate its elements in insertion order.
The following code shows some basic operations with a Map. See also the Map reference page for more examples and the complete API. You can use a for...of loop to return an array of [key, value] for each iteration.
jsconst sayings = new Map();
sayings.set("dog", "woof");
sayings.set("cat", "meow");
sayings.set("elephant", "toot");
sayings.size; // 3
sayings.get("dog"); // woof
sayings.get("fox"); // undefined
sayings.has("bird"); // false
sayings.delete("dog");
sayings.has("dog"); // false

for (const [key, value] of sayings) {
  console.log(`${key} goes ${value}`);
}
// "cat goes meow"
// "elephant goes toot"

sayings.clear();
sayings.size; // 0
Object and Map comparedTraditionally, objects have been used to map strings to values. Objects allow you to set keys to values, retrieve those values, delete keys, and detect whether something is stored at a key. Map objects, however, have a few more advantages that make them better maps.

The keys of an Object are strings or symbols, whereas they can be of any value for a Map.
You can get the size of a Map easily, while you have to manually keep track of size for an Object.
The iteration of maps is in insertion order of the elements.
An Object has a prototype, so there are default keys in the map. (This can be bypassed using map = Object.create(null).)

These three tips can help you to decide whether to use a Map or an Object:

Use maps over objects when keys are unknown until run time, and when all keys are the same type and all values are the same type.
Use maps if there is a need to store primitive values as keys because object treats each key as a string whether it's a number value, boolean value or any other primitive value.
Use objects when there is logic that operates on individual elements.
WeakMap objectA WeakMap is a collection of key/value pairs whose keys must be objects or non-registered symbols, with values of any arbitrary JavaScript type, and which does not create strong references to its keys. That is, an object's presence as a key in a WeakMap does not prevent the object from being garbage collected. Once an object used as a key has been collected, its corresponding values in any WeakMap become candidates for garbage collection as well — as long as they aren't strongly referred to elsewhere. The only primitive type that can be used as a WeakMap key is symbol — more specifically, non-registered symbols — because non-registered symbols are guaranteed to be unique and cannot be re-created.
The WeakMap API is essentially the same as the Map API. However, a WeakMap doesn't allow observing the liveness of its keys, which is why it doesn't allow enumeration. So there is no method to obtain a list of the keys in a WeakMap. If there were, the list would depend on the state of garbage collection, introducing non-determinism.
For more information and example code, see also "Why WeakMap?" on the WeakMap reference page.
One use case of WeakMap objects is to store private data for an object, or to hide implementation details. The following example is from Nick Fitzgerald's blog post "Hiding Implementation Details with ECMAScript 6 WeakMaps". The private data and methods belong inside the object and are stored in the privates object, which is a WeakMap. Everything exposed on the instance and prototype is public; everything else is inaccessible from the outside world because privates is not exported from the module.
jsconst privates = new WeakMap();

function Public() {
  const me = {
    // Private data goes here
  };
  privates.set(this, me);
}

Public.prototype.method = function () {
  const me = privates.get(this);
  // Do stuff with private data in `me`
  // …
};

module.exports = Public;
SetsSet objectSet objects are collections of unique values. You can iterate its elements in insertion order. A value in a Set may only occur once; it is unique in the Set's collection.
The following code shows some basic operations with a Set. See also the Set reference page for more examples and the complete API.
jsconst mySet = new Set();
mySet.add(1);
mySet.add("some text");
mySet.add("foo");

mySet.has(1); // true
mySet.delete("foo");
mySet.size; // 2

for (const item of mySet) {
  console.log(item);
}
// 1
// "some text"
Converting between Array and SetYou can create an Array from a Set using Array.from or the spread syntax. Also, the Set constructor accepts an Array to convert in the other direction.

Note: Set objects store unique values—so any duplicate elements from an Array are deleted when converting!

jsArray.from(mySet);
[...mySet2];

mySet2 = new Set([1, 2, 3, 4]);
Array and Set comparedTraditionally, a set of elements has been stored in arrays in JavaScript in a lot of situations. The Set object, however, has some advantages:

Deleting Array elements by value (arr.splice(arr.indexOf(val), 1)) is very slow.
Set objects let you delete elements by their value. With an array, you would have to splice based on an element's index.
The value NaN cannot be found with indexOf in an array.
Set objects store unique values. You don't have to manually keep track of duplicates.
WeakSet objectWeakSet objects are collections of garbage-collectable values, including objects and non-registered symbols. A value in the WeakSet may only occur once. It is unique in the WeakSet's collection.
The main differences to the Set object are:

In contrast to Sets, WeakSets are collections of objects or symbols only, and not of arbitrary values of any type.
The WeakSet is weak: References to objects in the collection are held weakly. If there is no other reference to an object stored in the WeakSet, they can be garbage collected. That also means that there is no list of current objects stored in the collection.
WeakSets are not enumerable.

The use cases of WeakSet objects are limited. They will not leak memory, so it can be safe to use DOM elements as a key and mark them for tracking purposes, for example.Key and value equality of Map and SetBoth the key equality of Map objects and the value equality of Set objects are based on the SameValueZero algorithm:

Equality works like the identity comparison operator ===.
-0 and +0 are considered equal.
NaN is considered equal to itself (contrary to ===).

 Previous  Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nWorking with objects 
 Previous  Next  
JavaScript is designed on an object-based paradigm. An object is a collection of properties, and a property is an association between a name (or key) and a value. A property's value can be a function, in which case the property is known as a method.
Objects in JavaScript, just as in many other programming languages, can be compared to objects in real life. In JavaScript, an object is a standalone entity, with properties and type. Compare it with a cup, for example. A cup is an object, with properties. A cup has a color, a design, weight, a material it is made of, etc. The same way, JavaScript objects can have properties, which define their characteristics.
In addition to objects that are predefined in the browser, you can define your own objects. This chapter describes how to use objects, properties, and methods, and how to create your own objects.Creating new objectsYou can create an object using an object initializer. Alternatively, you can first create a constructor function and then instantiate an object by invoking that function with the new operator.Using object initializersObject initializers are also called object literals. "Object initializer" is consistent with the terminology used by C++.
The syntax for an object using an object initializer is:
jsconst obj = {
  property1: value1, // property name may be an identifier
  2: value2, // or a number
  "property n": value3, // or a string
};

Each property name before colons is an identifier (either a name, a number, or a string literal), and each valueN is an expression whose value is assigned to the property name. The property name can also be an expression; computed keys need to be wrapped in square brackets. The object initializer reference contains a more detailed explanation of the syntax.
In this example, the newly created object is assigned to a variable obj — this is optional. If you do not need to refer to this object elsewhere, you do not need to assign it to a variable. (Note that you may need to wrap the object literal in parentheses if the object appears where a statement is expected, so as not to have the literal be confused with a block statement.)
Object initializers are expressions, and each object initializer results in a new object being created whenever the statement in which it appears is executed. Identical object initializers create distinct objects that do not compare to each other as equal.
The following statement creates an object and assigns it to the variable x if and only if the expression cond is true:
jslet x;
if (cond) {
  x = { greeting: "hi there" };
}

The following example creates myHonda with three properties. Note that the engine property is also an object with its own properties.
jsconst myHonda = {
  color: "red",
  wheels: 4,
  engine: { cylinders: 4, size: 2.2 },
};

Objects created with initializers are called plain objects, because they are instances of Object, but not any other object type. Some object types have special initializer syntaxes — for example, array initializers and regex literals.Using a constructor functionAlternatively, you can create an object with these two steps:

Define the object type by writing a constructor function. There is a strong convention, with good reason, to use a capital initial letter.
Create an instance of the object with new.

To define an object type, create a function for the object type that specifies its name, properties, and methods. For example, suppose you want to create an object type for cars. You want this type of object to be called Car, and you want it to have properties for make, model, and year. To do this, you would write the following function:
jsfunction Car(make, model, year) {
  this.make = make;
  this.model = model;
  this.year = year;
}

Notice the use of this to assign values to the object's properties based on the values passed to the function.
Now you can create an object called myCar as follows:
jsconst myCar = new Car("Eagle", "Talon TSi", 1993);

This statement creates myCar and assigns it the specified values for its properties. Then the value of myCar.make is the string "Eagle", myCar.model is the string "Talon TSi", myCar.year is the integer 1993, and so on. The order of arguments and parameters should be the same.
You can create any number of Car objects by calls to new. For example,
jsconst randCar = new Car("Nissan", "300ZX", 1992);
const kenCar = new Car("Mazda", "Miata", 1990);

An object can have a property that is itself another object. For example, suppose you define an object called Person as follows:
jsfunction Person(name, age, sex) {
  this.name = name;
  this.age = age;
  this.sex = sex;
}

and then instantiate two new Person objects as follows:
jsconst rand = new Person("Rand McKinnon", 33, "M");
const ken = new Person("Ken Jones", 39, "M");

Then, you can rewrite the definition of Car to include an owner property that takes a Person object, as follows:
jsfunction Car(make, model, year, owner) {
  this.make = make;
  this.model = model;
  this.year = year;
  this.owner = owner;
}

To instantiate the new objects, you then use the following:
jsconst car1 = new Car("Eagle", "Talon TSi", 1993, rand);
const car2 = new Car("Nissan", "300ZX", 1992, ken);

Notice that instead of passing a literal string or integer value when creating the new objects, the above statements pass the objects rand and ken as the arguments for the owners. Then if you want to find out the name of the owner of car2, you can access the following property:
jscar2.owner.name;

You can always add a property to a previously defined object. For example, the statement
jscar1.color = "black";

adds a property color to car1, and assigns it a value of "black". However, this does not affect any other objects. To add the new property to all objects of the same type, you have to add the property to the definition of the Car object type.
You can also use the class syntax instead of the function syntax to define a constructor function. For more information, see the class guide.Using the Object.create() methodObjects can also be created using the Object.create() method. This method can be very useful, because it allows you to choose the prototype object for the object you want to create, without having to define a constructor function.
js// Animal properties and method encapsulation
const Animal = {
  type: "Invertebrates", // Default value of properties
  displayType() {
    // Method which will display type of Animal
    console.log(this.type);
  },
};

// Create new animal type called animal1
const animal1 = Object.create(Animal);
animal1.displayType(); // Logs: Invertebrates

// Create new animal type called fish
const fish = Object.create(Animal);
fish.type = "Fishes";
fish.displayType(); // Logs: Fishes
Objects and propertiesA JavaScript object has properties associated with it. Object properties are basically the same as variables, except that they are associated with objects, not scopes. The properties of an object define the characteristics of the object.
For example, this example creates an object named myCar, with properties named make, model, and year, with their values set to "Ford", "Mustang", and 1969:
jsconst myCar = {
  make: "Ford",
  model: "Mustang",
  year: 1969,
};

Like JavaScript variables, property names are case sensitive. Property names can only be strings or Symbols — all keys are converted to strings unless they are Symbols. Array indices are, in fact, properties with string keys that contain integers.Accessing propertiesYou can access a property of an object by its property name. Property accessors come in two syntaxes: dot notation and bracket notation. For example, you could access the properties of the myCar object as follows:
js// Dot notation
myCar.make = "Ford";
myCar.model = "Mustang";
myCar.year = 1969;

// Bracket notation
myCar["make"] = "Ford";
myCar["model"] = "Mustang";
myCar["year"] = 1969;

An object property name can be any JavaScript string or symbol, including an empty string. However, you cannot use dot notation to access a property whose name is not a valid JavaScript identifier. For example, a property name that has a space or a hyphen, that starts with a number, or that is held inside a variable can only be accessed using the bracket notation. This notation is also very useful when property names are to be dynamically determined, i.e., not determinable until runtime. Examples are as follows:
jsconst myObj = {};
const str = "myString";
const rand = Math.random();
const anotherObj = {};

// Create additional properties on myObj
myObj.type = "Dot syntax for a key named type";
myObj["date created"] = "This key has a space";
myObj[str] = "This key is in variable str";
myObj[rand] = "A random number is the key here";
myObj[anotherObj] = "This key is object anotherObj";
myObj[""] = "This key is an empty string";

console.log(myObj);
// {
//   type: 'Dot syntax for a key named type',
//   'date created': 'This key has a space',
//   myString: 'This key is in variable str',
//   '0.6398914448618778': 'A random number is the key here',
//   '[object Object]': 'This key is object anotherObj',
//   '': 'This key is an empty string'
// }
console.log(myObj.myString); // 'This key is in variable str'

In the above code, the key anotherObj is an object, which is neither a string nor a symbol. When it is added to the myObj, JavaScript calls the toString() method of anotherObj, and use the resulting string as the new key.
You can also access properties with a string value stored in a variable. The variable must be passed in bracket notation. In the example above, the variable str held "myString" and it is "myString" that is the property name. Therefore, myObj.str will return as undefined.
jsstr = "myString";
myObj[str] = "This key is in variable str";

console.log(myObj.str); // undefined

console.log(myObj[str]); // 'This key is in variable str'
console.log(myObj.myString); // 'This key is in variable str'

This allows accessing any property as determined at runtime:
jslet propertyName = "make";
myCar[propertyName] = "Ford";

// access different properties by changing the contents of the variable
propertyName = "model";
myCar[propertyName] = "Mustang";

console.log(myCar); // { make: 'Ford', model: 'Mustang' }

However, beware of using square brackets to access properties whose names are given by external input. This may make your code susceptible to object injection attacks.
Nonexistent properties of an object have value undefined (and not null).
jsmyCar.nonexistentProperty; // undefined
Enumerating propertiesThere are three native ways to list/traverse object properties:

for...in loops. This method traverses all of the enumerable string properties of an object as well as its prototype chain.
Object.keys(). This method returns an array with only the enumerable own string property names ("keys") in the object myObj, but not those in the prototype chain.
Object.getOwnPropertyNames(). This method returns an array containing all the own string property names in the object myObj, regardless of if they are enumerable or not.

You can use the bracket notation with for...in to iterate over all the enumerable properties of an object. To illustrate how this works, the following function displays the properties of the object when you pass the object and the object's name as arguments to the function:
jsfunction showProps(obj, objName) {
  let result = "";
  for (const i in obj) {
    // Object.hasOwn() is used to exclude properties from the object's
    // prototype chain and only show "own properties"
    if (Object.hasOwn(obj, i)) {
      result += `${objName}.${i} = ${obj[i]}\n`;
    }
  }
  console.log(result);
}

The term "own property" refers to the properties of the object, but excluding those of the prototype chain. So, the function call showProps(myCar, 'myCar') would print the following:
myCar.make = Ford
myCar.model = Mustang
myCar.year = 1969

The above is equivalent to:
jsfunction showProps(obj, objName) {
  let result = "";
  Object.keys(obj).forEach((i) => {
    result += `${objName}.${i} = ${obj[i]}\n`;
  });
  console.log(result);
}

There is no native way to list inherited non-enumerable properties. However, this can be achieved with the following function:
jsfunction listAllProperties(myObj) {
  let objectToInspect = myObj;
  let result = [];

  while (objectToInspect !== null) {
    result = result.concat(Object.getOwnPropertyNames(objectToInspect));
    objectToInspect = Object.getPrototypeOf(objectToInspect);
  }

  return result;
}

For more information, see Enumerability and ownership of properties.Deleting propertiesYou can remove a non-inherited property using the delete operator. The following code shows how to remove a property.
js// Creates a new object, myObj, with two properties, a and b.
const myObj = new Object();
myObj.a = 5;
myObj.b = 12;

// Removes the a property, leaving myObj with only the b property.
delete myObj.a;
console.log("a" in myObj); // false
InheritanceAll objects in JavaScript inherit from at least one other object. The object being inherited from is known as the prototype, and the inherited properties can be found in the prototype object of the constructor. See Inheritance and the prototype chain for more information.Defining properties for all objects of one typeYou can add a property to all objects created through a certain constructor using the prototype property. This defines a property that is shared by all objects of the specified type, rather than by just one instance of the object. The following code adds a color property to all objects of type Car, and then reads the property's value from an instance car1.
jsCar.prototype.color = "red";
console.log(car1.color); // "red"
Defining methodsA method is a function associated with an object, or, put differently, a method is a property of an object that is a function. Methods are defined the way normal functions are defined, except that they have to be assigned as the property of an object. See also method definitions for more details. An example is:
jsobjectName.methodName = functionName;

const myObj = {
  myMethod: function (params) {
    // do something
  },

  // this works too!
  myOtherMethod(params) {
    // do something else
  },
};

where objectName is an existing object, methodName is the name you are assigning to the method, and functionName is the name of the function.
You can then call the method in the context of the object as follows:
jsobjectName.methodName(params);

Methods are typically defined on the prototype object of the constructor, so that all objects of the same type share the same method. For example, you can define a function that formats and displays the properties of the previously-defined Car objects.
jsCar.prototype.displayCar = function () {
  const result = `A Beautiful ${this.year} ${this.make} ${this.model}`;
  console.log(result);
};

Notice the use of this to refer to the object to which the method belongs. Then you can call the displayCar method for each of the objects as follows:
jscar1.displayCar();
car2.displayCar();
Using this for object referencesJavaScript has a special keyword, this, that you can use within a method to refer to the current object. For example, suppose you have 2 objects, Manager and Intern. Each object has its own name, age and job. In the function sayHi(), notice the use of this.name. When added to the 2 objects, the same function will print the message with the name of the respective object it's attached to.
jsconst Manager = {
  name: "Karina",
  age: 27,
  job: "Software Engineer",
};
const Intern = {
  name: "Tyrone",
  age: 21,
  job: "Software Engineer Intern",
};

function sayHi() {
  console.log(`Hello, my name is ${this.name}`);
}

// add sayHi function to both objects
Manager.sayHi = sayHi;
Intern.sayHi = sayHi;

Manager.sayHi(); // Hello, my name is Karina
Intern.sayHi(); // Hello, my name is Tyrone

this is a "hidden parameter" of a function call that's passed in by specifying the object before the function that was called. For example, in Manager.sayHi(), this is the Manager object, because Manager comes before the function sayHi(). If you access the same function from another object, this will change as well. If you use other methods to call the function, like Function.prototype.call() or Reflect.apply(), you can explicitly pass the value of this as an argument.Defining getters and settersA getter is a function associated with a property that gets the value of a specific property. A setter is a function associated with a property that sets the value of a specific property. Together, they can indirectly represent the value of a property.
Getters and setters can be either

defined within object initializers, or
added later to any existing object.

Within object initializers, getters and setters are defined like regular methods, but prefixed with the keywords get or set. The getter method must not expect a parameter, while the setter method expects exactly one parameter (the new value to set). For instance:
jsconst myObj = {
  a: 7,
  get b() {
    return this.a + 1;
  },
  set c(x) {
    this.a = x / 2;
  },
};

console.log(myObj.a); // 7
console.log(myObj.b); // 8, returned from the get b() method
myObj.c = 50; // Calls the set c(x) method
console.log(myObj.a); // 25

The myObj object's properties are:

myObj.a — a number
myObj.b — a getter that returns myObj.a plus 1
myObj.c — a setter that sets the value of myObj.a to half of the value myObj.c is being set to

Getters and setters can also be added to an object at any time after creation using the Object.defineProperties() method. This method's first parameter is the object on which you want to define the getter or setter. The second parameter is an object whose property names are the getter or setter names, and whose property values are objects for defining the getter or setter functions. Here's an example that defines the same getter and setter used in the previous example:
jsconst myObj = { a: 0 };

Object.defineProperties(myObj, {
  b: {
    get() {
      return this.a + 1;
    },
  },
  c: {
    set(x) {
      this.a = x / 2;
    },
  },
});

myObj.c = 10; // Runs the setter, which assigns 10 / 2 (5) to the 'a' property
console.log(myObj.b); // Runs the getter, which yields a + 1 or 6

Which of the two forms to choose depends on your programming style and task at hand. If you can change the definition of the original object, you will probably define getters and setters through the original initializer. This form is more compact and natural. However, if you need to add getters and setters later — maybe because you did not write the particular object — then the second form is the only possible form. The second form better represents the dynamic nature of JavaScript, but it can make the code hard to read and understand.Comparing objectsIn JavaScript, objects are a reference type. Two distinct objects are never equal, even if they have the same properties. Only comparing the same object reference with itself yields true.
js// Two variables, two distinct objects with the same properties
const fruit = { name: "apple" };
const anotherFruit = { name: "apple" };

fruit == anotherFruit; // return false
fruit === anotherFruit; // return false

js// Two variables, a single object
const fruit = { name: "apple" };
const anotherFruit = fruit; // Assign fruit object reference to anotherFruit

// Here fruit and anotherFruit are pointing to same object
fruit == anotherFruit; // return true
fruit === anotherFruit; // return true

fruit.name = "grape";
console.log(anotherFruit); // { name: "grape" }; not { name: "apple" }

For more information about comparison operators, see equality operators.See also
Inheritance and the prototype chain
Classes

 Previous  Next\n\nWorking with objects 
 Previous  Next  
JavaScript is designed on an object-based paradigm. An object is a collection of properties, and a property is an association between a name (or key) and a value. A property's value can be a function, in which case the property is known as a method.
Objects in JavaScript, just as in many other programming languages, can be compared to objects in real life. In JavaScript, an object is a standalone entity, with properties and type. Compare it with a cup, for example. A cup is an object, with properties. A cup has a color, a design, weight, a material it is made of, etc. The same way, JavaScript objects can have properties, which define their characteristics.
In addition to objects that are predefined in the browser, you can define your own objects. This chapter describes how to use objects, properties, and methods, and how to create your own objects.Creating new objectsYou can create an object using an object initializer. Alternatively, you can first create a constructor function and then instantiate an object by invoking that function with the new operator.Using object initializersObject initializers are also called object literals. "Object initializer" is consistent with the terminology used by C++.
The syntax for an object using an object initializer is:
jsconst obj = {
  property1: value1, // property name may be an identifier
  2: value2, // or a number
  "property n": value3, // or a string
};

Each property name before colons is an identifier (either a name, a number, or a string literal), and each valueN is an expression whose value is assigned to the property name. The property name can also be an expression; computed keys need to be wrapped in square brackets. The object initializer reference contains a more detailed explanation of the syntax.
In this example, the newly created object is assigned to a variable obj — this is optional. If you do not need to refer to this object elsewhere, you do not need to assign it to a variable. (Note that you may need to wrap the object literal in parentheses if the object appears where a statement is expected, so as not to have the literal be confused with a block statement.)
Object initializers are expressions, and each object initializer results in a new object being created whenever the statement in which it appears is executed. Identical object initializers create distinct objects that do not compare to each other as equal.
The following statement creates an object and assigns it to the variable x if and only if the expression cond is true:
jslet x;
if (cond) {
  x = { greeting: "hi there" };
}

The following example creates myHonda with three properties. Note that the engine property is also an object with its own properties.
jsconst myHonda = {
  color: "red",
  wheels: 4,
  engine: { cylinders: 4, size: 2.2 },
};

Objects created with initializers are called plain objects, because they are instances of Object, but not any other object type. Some object types have special initializer syntaxes — for example, array initializers and regex literals.Using a constructor functionAlternatively, you can create an object with these two steps:

Define the object type by writing a constructor function. There is a strong convention, with good reason, to use a capital initial letter.
Create an instance of the object with new.

To define an object type, create a function for the object type that specifies its name, properties, and methods. For example, suppose you want to create an object type for cars. You want this type of object to be called Car, and you want it to have properties for make, model, and year. To do this, you would write the following function:
jsfunction Car(make, model, year) {
  this.make = make;
  this.model = model;
  this.year = year;
}

Notice the use of this to assign values to the object's properties based on the values passed to the function.
Now you can create an object called myCar as follows:
jsconst myCar = new Car("Eagle", "Talon TSi", 1993);

This statement creates myCar and assigns it the specified values for its properties. Then the value of myCar.make is the string "Eagle", myCar.model is the string "Talon TSi", myCar.year is the integer 1993, and so on. The order of arguments and parameters should be the same.
You can create any number of Car objects by calls to new. For example,
jsconst randCar = new Car("Nissan", "300ZX", 1992);
const kenCar = new Car("Mazda", "Miata", 1990);

An object can have a property that is itself another object. For example, suppose you define an object called Person as follows:
jsfunction Person(name, age, sex) {
  this.name = name;
  this.age = age;
  this.sex = sex;
}

and then instantiate two new Person objects as follows:
jsconst rand = new Person("Rand McKinnon", 33, "M");
const ken = new Person("Ken Jones", 39, "M");

Then, you can rewrite the definition of Car to include an owner property that takes a Person object, as follows:
jsfunction Car(make, model, year, owner) {
  this.make = make;
  this.model = model;
  this.year = year;
  this.owner = owner;
}

To instantiate the new objects, you then use the following:
jsconst car1 = new Car("Eagle", "Talon TSi", 1993, rand);
const car2 = new Car("Nissan", "300ZX", 1992, ken);

Notice that instead of passing a literal string or integer value when creating the new objects, the above statements pass the objects rand and ken as the arguments for the owners. Then if you want to find out the name of the owner of car2, you can access the following property:
jscar2.owner.name;

You can always add a property to a previously defined object. For example, the statement
jscar1.color = "black";

adds a property color to car1, and assigns it a value of "black". However, this does not affect any other objects. To add the new property to all objects of the same type, you have to add the property to the definition of the Car object type.
You can also use the class syntax instead of the function syntax to define a constructor function. For more information, see the class guide.Using the Object.create() methodObjects can also be created using the Object.create() method. This method can be very useful, because it allows you to choose the prototype object for the object you want to create, without having to define a constructor function.
js// Animal properties and method encapsulation
const Animal = {
  type: "Invertebrates", // Default value of properties
  displayType() {
    // Method which will display type of Animal
    console.log(this.type);
  },
};

// Create new animal type called animal1
const animal1 = Object.create(Animal);
animal1.displayType(); // Logs: Invertebrates

// Create new animal type called fish
const fish = Object.create(Animal);
fish.type = "Fishes";
fish.displayType(); // Logs: Fishes
Objects and propertiesA JavaScript object has properties associated with it. Object properties are basically the same as variables, except that they are associated with objects, not scopes. The properties of an object define the characteristics of the object.
For example, this example creates an object named myCar, with properties named make, model, and year, with their values set to "Ford", "Mustang", and 1969:
jsconst myCar = {
  make: "Ford",
  model: "Mustang",
  year: 1969,
};

Like JavaScript variables, property names are case sensitive. Property names can only be strings or Symbols — all keys are converted to strings unless they are Symbols. Array indices are, in fact, properties with string keys that contain integers.Accessing propertiesYou can access a property of an object by its property name. Property accessors come in two syntaxes: dot notation and bracket notation. For example, you could access the properties of the myCar object as follows:
js// Dot notation
myCar.make = "Ford";
myCar.model = "Mustang";
myCar.year = 1969;

// Bracket notation
myCar["make"] = "Ford";
myCar["model"] = "Mustang";
myCar["year"] = 1969;

An object property name can be any JavaScript string or symbol, including an empty string. However, you cannot use dot notation to access a property whose name is not a valid JavaScript identifier. For example, a property name that has a space or a hyphen, that starts with a number, or that is held inside a variable can only be accessed using the bracket notation. This notation is also very useful when property names are to be dynamically determined, i.e., not determinable until runtime. Examples are as follows:
jsconst myObj = {};
const str = "myString";
const rand = Math.random();
const anotherObj = {};

// Create additional properties on myObj
myObj.type = "Dot syntax for a key named type";
myObj["date created"] = "This key has a space";
myObj[str] = "This key is in variable str";
myObj[rand] = "A random number is the key here";
myObj[anotherObj] = "This key is object anotherObj";
myObj[""] = "This key is an empty string";

console.log(myObj);
// {
//   type: 'Dot syntax for a key named type',
//   'date created': 'This key has a space',
//   myString: 'This key is in variable str',
//   '0.6398914448618778': 'A random number is the key here',
//   '[object Object]': 'This key is object anotherObj',
//   '': 'This key is an empty string'
// }
console.log(myObj.myString); // 'This key is in variable str'

In the above code, the key anotherObj is an object, which is neither a string nor a symbol. When it is added to the myObj, JavaScript calls the toString() method of anotherObj, and use the resulting string as the new key.
You can also access properties with a string value stored in a variable. The variable must be passed in bracket notation. In the example above, the variable str held "myString" and it is "myString" that is the property name. Therefore, myObj.str will return as undefined.
jsstr = "myString";
myObj[str] = "This key is in variable str";

console.log(myObj.str); // undefined

console.log(myObj[str]); // 'This key is in variable str'
console.log(myObj.myString); // 'This key is in variable str'

This allows accessing any property as determined at runtime:
jslet propertyName = "make";
myCar[propertyName] = "Ford";

// access different properties by changing the contents of the variable
propertyName = "model";
myCar[propertyName] = "Mustang";

console.log(myCar); // { make: 'Ford', model: 'Mustang' }

However, beware of using square brackets to access properties whose names are given by external input. This may make your code susceptible to object injection attacks.
Nonexistent properties of an object have value undefined (and not null).
jsmyCar.nonexistentProperty; // undefined
Enumerating propertiesThere are three native ways to list/traverse object properties:

for...in loops. This method traverses all of the enumerable string properties of an object as well as its prototype chain.
Object.keys(). This method returns an array with only the enumerable own string property names ("keys") in the object myObj, but not those in the prototype chain.
Object.getOwnPropertyNames(). This method returns an array containing all the own string property names in the object myObj, regardless of if they are enumerable or not.

You can use the bracket notation with for...in to iterate over all the enumerable properties of an object. To illustrate how this works, the following function displays the properties of the object when you pass the object and the object's name as arguments to the function:
jsfunction showProps(obj, objName) {
  let result = "";
  for (const i in obj) {
    // Object.hasOwn() is used to exclude properties from the object's
    // prototype chain and only show "own properties"
    if (Object.hasOwn(obj, i)) {
      result += `${objName}.${i} = ${obj[i]}\n`;
    }
  }
  console.log(result);
}

The term "own property" refers to the properties of the object, but excluding those of the prototype chain. So, the function call showProps(myCar, 'myCar') would print the following:
myCar.make = Ford
myCar.model = Mustang
myCar.year = 1969

The above is equivalent to:
jsfunction showProps(obj, objName) {
  let result = "";
  Object.keys(obj).forEach((i) => {
    result += `${objName}.${i} = ${obj[i]}\n`;
  });
  console.log(result);
}

There is no native way to list inherited non-enumerable properties. However, this can be achieved with the following function:
jsfunction listAllProperties(myObj) {
  let objectToInspect = myObj;
  let result = [];

  while (objectToInspect !== null) {
    result = result.concat(Object.getOwnPropertyNames(objectToInspect));
    objectToInspect = Object.getPrototypeOf(objectToInspect);
  }

  return result;
}

For more information, see Enumerability and ownership of properties.Deleting propertiesYou can remove a non-inherited property using the delete operator. The following code shows how to remove a property.
js// Creates a new object, myObj, with two properties, a and b.
const myObj = new Object();
myObj.a = 5;
myObj.b = 12;

// Removes the a property, leaving myObj with only the b property.
delete myObj.a;
console.log("a" in myObj); // false
InheritanceAll objects in JavaScript inherit from at least one other object. The object being inherited from is known as the prototype, and the inherited properties can be found in the prototype object of the constructor. See Inheritance and the prototype chain for more information.Defining properties for all objects of one typeYou can add a property to all objects created through a certain constructor using the prototype property. This defines a property that is shared by all objects of the specified type, rather than by just one instance of the object. The following code adds a color property to all objects of type Car, and then reads the property's value from an instance car1.
jsCar.prototype.color = "red";
console.log(car1.color); // "red"
Defining methodsA method is a function associated with an object, or, put differently, a method is a property of an object that is a function. Methods are defined the way normal functions are defined, except that they have to be assigned as the property of an object. See also method definitions for more details. An example is:
jsobjectName.methodName = functionName;

const myObj = {
  myMethod: function (params) {
    // do something
  },

  // this works too!
  myOtherMethod(params) {
    // do something else
  },
};

where objectName is an existing object, methodName is the name you are assigning to the method, and functionName is the name of the function.
You can then call the method in the context of the object as follows:
jsobjectName.methodName(params);

Methods are typically defined on the prototype object of the constructor, so that all objects of the same type share the same method. For example, you can define a function that formats and displays the properties of the previously-defined Car objects.
jsCar.prototype.displayCar = function () {
  const result = `A Beautiful ${this.year} ${this.make} ${this.model}`;
  console.log(result);
};

Notice the use of this to refer to the object to which the method belongs. Then you can call the displayCar method for each of the objects as follows:
jscar1.displayCar();
car2.displayCar();
Using this for object referencesJavaScript has a special keyword, this, that you can use within a method to refer to the current object. For example, suppose you have 2 objects, Manager and Intern. Each object has its own name, age and job. In the function sayHi(), notice the use of this.name. When added to the 2 objects, the same function will print the message with the name of the respective object it's attached to.
jsconst Manager = {
  name: "Karina",
  age: 27,
  job: "Software Engineer",
};
const Intern = {
  name: "Tyrone",
  age: 21,
  job: "Software Engineer Intern",
};

function sayHi() {
  console.log(`Hello, my name is ${this.name}`);
}

// add sayHi function to both objects
Manager.sayHi = sayHi;
Intern.sayHi = sayHi;

Manager.sayHi(); // Hello, my name is Karina
Intern.sayHi(); // Hello, my name is Tyrone

this is a "hidden parameter" of a function call that's passed in by specifying the object before the function that was called. For example, in Manager.sayHi(), this is the Manager object, because Manager comes before the function sayHi(). If you access the same function from another object, this will change as well. If you use other methods to call the function, like Function.prototype.call() or Reflect.apply(), you can explicitly pass the value of this as an argument.Defining getters and settersA getter is a function associated with a property that gets the value of a specific property. A setter is a function associated with a property that sets the value of a specific property. Together, they can indirectly represent the value of a property.
Getters and setters can be either

defined within object initializers, or
added later to any existing object.

Within object initializers, getters and setters are defined like regular methods, but prefixed with the keywords get or set. The getter method must not expect a parameter, while the setter method expects exactly one parameter (the new value to set). For instance:
jsconst myObj = {
  a: 7,
  get b() {
    return this.a + 1;
  },
  set c(x) {
    this.a = x / 2;
  },
};

console.log(myObj.a); // 7
console.log(myObj.b); // 8, returned from the get b() method
myObj.c = 50; // Calls the set c(x) method
console.log(myObj.a); // 25

The myObj object's properties are:

myObj.a — a number
myObj.b — a getter that returns myObj.a plus 1
myObj.c — a setter that sets the value of myObj.a to half of the value myObj.c is being set to

Getters and setters can also be added to an object at any time after creation using the Object.defineProperties() method. This method's first parameter is the object on which you want to define the getter or setter. The second parameter is an object whose property names are the getter or setter names, and whose property values are objects for defining the getter or setter functions. Here's an example that defines the same getter and setter used in the previous example:
jsconst myObj = { a: 0 };

Object.defineProperties(myObj, {
  b: {
    get() {
      return this.a + 1;
    },
  },
  c: {
    set(x) {
      this.a = x / 2;
    },
  },
});

myObj.c = 10; // Runs the setter, which assigns 10 / 2 (5) to the 'a' property
console.log(myObj.b); // Runs the getter, which yields a + 1 or 6

Which of the two forms to choose depends on your programming style and task at hand. If you can change the definition of the original object, you will probably define getters and setters through the original initializer. This form is more compact and natural. However, if you need to add getters and setters later — maybe because you did not write the particular object — then the second form is the only possible form. The second form better represents the dynamic nature of JavaScript, but it can make the code hard to read and understand.Comparing objectsIn JavaScript, objects are a reference type. Two distinct objects are never equal, even if they have the same properties. Only comparing the same object reference with itself yields true.
js// Two variables, two distinct objects with the same properties
const fruit = { name: "apple" };
const anotherFruit = { name: "apple" };

fruit == anotherFruit; // return false
fruit === anotherFruit; // return false

js// Two variables, a single object
const fruit = { name: "apple" };
const anotherFruit = fruit; // Assign fruit object reference to anotherFruit

// Here fruit and anotherFruit are pointing to same object
fruit == anotherFruit; // return true
fruit === anotherFruit; // return true

fruit.name = "grape";
console.log(anotherFruit); // { name: "grape" }; not { name: "apple" }

For more information about comparison operators, see equality operators.See also
Inheritance and the prototype chain
Classes

 Previous  Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWorking with objects 
 Previous  Next  
JavaScript is designed on an object-based paradigm. An object is a collection of properties, and a property is an association between a name (or key) and a value. A property's value can be a function, in which case the property is known as a method.
Objects in JavaScript, just as in many other programming languages, can be compared to objects in real life. In JavaScript, an object is a standalone entity, with properties and type. Compare it with a cup, for example. A cup is an object, with properties. A cup has a color, a design, weight, a material it is made of, etc. The same way, JavaScript objects can have properties, which define their characteristics.
In addition to objects that are predefined in the browser, you can define your own objects. This chapter describes how to use objects, properties, and methods, and how to create your own objects.Creating new objectsYou can create an object using an object initializer. Alternatively, you can first create a constructor function and then instantiate an object by invoking that function with the new operator.Using object initializersObject initializers are also called object literals. "Object initializer" is consistent with the terminology used by C++.
The syntax for an object using an object initializer is:
jsconst obj = {
  property1: value1, // property name may be an identifier
  2: value2, // or a number
  "property n": value3, // or a string
};

Each property name before colons is an identifier (either a name, a number, or a string literal), and each valueN is an expression whose value is assigned to the property name. The property name can also be an expression; computed keys need to be wrapped in square brackets. The object initializer reference contains a more detailed explanation of the syntax.
In this example, the newly created object is assigned to a variable obj — this is optional. If you do not need to refer to this object elsewhere, you do not need to assign it to a variable. (Note that you may need to wrap the object literal in parentheses if the object appears where a statement is expected, so as not to have the literal be confused with a block statement.)
Object initializers are expressions, and each object initializer results in a new object being created whenever the statement in which it appears is executed. Identical object initializers create distinct objects that do not compare to each other as equal.
The following statement creates an object and assigns it to the variable x if and only if the expression cond is true:
jslet x;
if (cond) {
  x = { greeting: "hi there" };
}

The following example creates myHonda with three properties. Note that the engine property is also an object with its own properties.
jsconst myHonda = {
  color: "red",
  wheels: 4,
  engine: { cylinders: 4, size: 2.2 },
};

Objects created with initializers are called plain objects, because they are instances of Object, but not any other object type. Some object types have special initializer syntaxes — for example, array initializers and regex literals.Using a constructor functionAlternatively, you can create an object with these two steps:

Define the object type by writing a constructor function. There is a strong convention, with good reason, to use a capital initial letter.
Create an instance of the object with new.

To define an object type, create a function for the object type that specifies its name, properties, and methods. For example, suppose you want to create an object type for cars. You want this type of object to be called Car, and you want it to have properties for make, model, and year. To do this, you would write the following function:
jsfunction Car(make, model, year) {
  this.make = make;
  this.model = model;
  this.year = year;
}

Notice the use of this to assign values to the object's properties based on the values passed to the function.
Now you can create an object called myCar as follows:
jsconst myCar = new Car("Eagle", "Talon TSi", 1993);

This statement creates myCar and assigns it the specified values for its properties. Then the value of myCar.make is the string "Eagle", myCar.model is the string "Talon TSi", myCar.year is the integer 1993, and so on. The order of arguments and parameters should be the same.
You can create any number of Car objects by calls to new. For example,
jsconst randCar = new Car("Nissan", "300ZX", 1992);
const kenCar = new Car("Mazda", "Miata", 1990);

An object can have a property that is itself another object. For example, suppose you define an object called Person as follows:
jsfunction Person(name, age, sex) {
  this.name = name;
  this.age = age;
  this.sex = sex;
}

and then instantiate two new Person objects as follows:
jsconst rand = new Person("Rand McKinnon", 33, "M");
const ken = new Person("Ken Jones", 39, "M");

Then, you can rewrite the definition of Car to include an owner property that takes a Person object, as follows:
jsfunction Car(make, model, year, owner) {
  this.make = make;
  this.model = model;
  this.year = year;
  this.owner = owner;
}

To instantiate the new objects, you then use the following:
jsconst car1 = new Car("Eagle", "Talon TSi", 1993, rand);
const car2 = new Car("Nissan", "300ZX", 1992, ken);

Notice that instead of passing a literal string or integer value when creating the new objects, the above statements pass the objects rand and ken as the arguments for the owners. Then if you want to find out the name of the owner of car2, you can access the following property:
jscar2.owner.name;

You can always add a property to a previously defined object. For example, the statement
jscar1.color = "black";

adds a property color to car1, and assigns it a value of "black". However, this does not affect any other objects. To add the new property to all objects of the same type, you have to add the property to the definition of the Car object type.
You can also use the class syntax instead of the function syntax to define a constructor function. For more information, see the class guide.Using the Object.create() methodObjects can also be created using the Object.create() method. This method can be very useful, because it allows you to choose the prototype object for the object you want to create, without having to define a constructor function.
js// Animal properties and method encapsulation
const Animal = {
  type: "Invertebrates", // Default value of properties
  displayType() {
    // Method which will display type of Animal
    console.log(this.type);
  },
};

// Create new animal type called animal1
const animal1 = Object.create(Animal);
animal1.displayType(); // Logs: Invertebrates

// Create new animal type called fish
const fish = Object.create(Animal);
fish.type = "Fishes";
fish.displayType(); // Logs: Fishes
Objects and propertiesA JavaScript object has properties associated with it. Object properties are basically the same as variables, except that they are associated with objects, not scopes. The properties of an object define the characteristics of the object.
For example, this example creates an object named myCar, with properties named make, model, and year, with their values set to "Ford", "Mustang", and 1969:
jsconst myCar = {
  make: "Ford",
  model: "Mustang",
  year: 1969,
};

Like JavaScript variables, property names are case sensitive. Property names can only be strings or Symbols — all keys are converted to strings unless they are Symbols. Array indices are, in fact, properties with string keys that contain integers.Accessing propertiesYou can access a property of an object by its property name. Property accessors come in two syntaxes: dot notation and bracket notation. For example, you could access the properties of the myCar object as follows:
js// Dot notation
myCar.make = "Ford";
myCar.model = "Mustang";
myCar.year = 1969;

// Bracket notation
myCar["make"] = "Ford";
myCar["model"] = "Mustang";
myCar["year"] = 1969;

An object property name can be any JavaScript string or symbol, including an empty string. However, you cannot use dot notation to access a property whose name is not a valid JavaScript identifier. For example, a property name that has a space or a hyphen, that starts with a number, or that is held inside a variable can only be accessed using the bracket notation. This notation is also very useful when property names are to be dynamically determined, i.e., not determinable until runtime. Examples are as follows:
jsconst myObj = {};
const str = "myString";
const rand = Math.random();
const anotherObj = {};

// Create additional properties on myObj
myObj.type = "Dot syntax for a key named type";
myObj["date created"] = "This key has a space";
myObj[str] = "This key is in variable str";
myObj[rand] = "A random number is the key here";
myObj[anotherObj] = "This key is object anotherObj";
myObj[""] = "This key is an empty string";

console.log(myObj);
// {
//   type: 'Dot syntax for a key named type',
//   'date created': 'This key has a space',
//   myString: 'This key is in variable str',
//   '0.6398914448618778': 'A random number is the key here',
//   '[object Object]': 'This key is object anotherObj',
//   '': 'This key is an empty string'
// }
console.log(myObj.myString); // 'This key is in variable str'

In the above code, the key anotherObj is an object, which is neither a string nor a symbol. When it is added to the myObj, JavaScript calls the toString() method of anotherObj, and use the resulting string as the new key.
You can also access properties with a string value stored in a variable. The variable must be passed in bracket notation. In the example above, the variable str held "myString" and it is "myString" that is the property name. Therefore, myObj.str will return as undefined.
jsstr = "myString";
myObj[str] = "This key is in variable str";

console.log(myObj.str); // undefined

console.log(myObj[str]); // 'This key is in variable str'
console.log(myObj.myString); // 'This key is in variable str'

This allows accessing any property as determined at runtime:
jslet propertyName = "make";
myCar[propertyName] = "Ford";

// access different properties by changing the contents of the variable
propertyName = "model";
myCar[propertyName] = "Mustang";

console.log(myCar); // { make: 'Ford', model: 'Mustang' }

However, beware of using square brackets to access properties whose names are given by external input. This may make your code susceptible to object injection attacks.
Nonexistent properties of an object have value undefined (and not null).
jsmyCar.nonexistentProperty; // undefined
Enumerating propertiesThere are three native ways to list/traverse object properties:

for...in loops. This method traverses all of the enumerable string properties of an object as well as its prototype chain.
Object.keys(). This method returns an array with only the enumerable own string property names ("keys") in the object myObj, but not those in the prototype chain.
Object.getOwnPropertyNames(). This method returns an array containing all the own string property names in the object myObj, regardless of if they are enumerable or not.

You can use the bracket notation with for...in to iterate over all the enumerable properties of an object. To illustrate how this works, the following function displays the properties of the object when you pass the object and the object's name as arguments to the function:
jsfunction showProps(obj, objName) {
  let result = "";
  for (const i in obj) {
    // Object.hasOwn() is used to exclude properties from the object's
    // prototype chain and only show "own properties"
    if (Object.hasOwn(obj, i)) {
      result += `${objName}.${i} = ${obj[i]}\n`;
    }
  }
  console.log(result);
}

The term "own property" refers to the properties of the object, but excluding those of the prototype chain. So, the function call showProps(myCar, 'myCar') would print the following:
myCar.make = Ford
myCar.model = Mustang
myCar.year = 1969

The above is equivalent to:
jsfunction showProps(obj, objName) {
  let result = "";
  Object.keys(obj).forEach((i) => {
    result += `${objName}.${i} = ${obj[i]}\n`;
  });
  console.log(result);
}

There is no native way to list inherited non-enumerable properties. However, this can be achieved with the following function:
jsfunction listAllProperties(myObj) {
  let objectToInspect = myObj;
  let result = [];

  while (objectToInspect !== null) {
    result = result.concat(Object.getOwnPropertyNames(objectToInspect));
    objectToInspect = Object.getPrototypeOf(objectToInspect);
  }

  return result;
}

For more information, see Enumerability and ownership of properties.Deleting propertiesYou can remove a non-inherited property using the delete operator. The following code shows how to remove a property.
js// Creates a new object, myObj, with two properties, a and b.
const myObj = new Object();
myObj.a = 5;
myObj.b = 12;

// Removes the a property, leaving myObj with only the b property.
delete myObj.a;
console.log("a" in myObj); // false
InheritanceAll objects in JavaScript inherit from at least one other object. The object being inherited from is known as the prototype, and the inherited properties can be found in the prototype object of the constructor. See Inheritance and the prototype chain for more information.Defining properties for all objects of one typeYou can add a property to all objects created through a certain constructor using the prototype property. This defines a property that is shared by all objects of the specified type, rather than by just one instance of the object. The following code adds a color property to all objects of type Car, and then reads the property's value from an instance car1.
jsCar.prototype.color = "red";
console.log(car1.color); // "red"
Defining methodsA method is a function associated with an object, or, put differently, a method is a property of an object that is a function. Methods are defined the way normal functions are defined, except that they have to be assigned as the property of an object. See also method definitions for more details. An example is:
jsobjectName.methodName = functionName;

const myObj = {
  myMethod: function (params) {
    // do something
  },

  // this works too!
  myOtherMethod(params) {
    // do something else
  },
};

where objectName is an existing object, methodName is the name you are assigning to the method, and functionName is the name of the function.
You can then call the method in the context of the object as follows:
jsobjectName.methodName(params);

Methods are typically defined on the prototype object of the constructor, so that all objects of the same type share the same method. For example, you can define a function that formats and displays the properties of the previously-defined Car objects.
jsCar.prototype.displayCar = function () {
  const result = `A Beautiful ${this.year} ${this.make} ${this.model}`;
  console.log(result);
};

Notice the use of this to refer to the object to which the method belongs. Then you can call the displayCar method for each of the objects as follows:
jscar1.displayCar();
car2.displayCar();
Using this for object referencesJavaScript has a special keyword, this, that you can use within a method to refer to the current object. For example, suppose you have 2 objects, Manager and Intern. Each object has its own name, age and job. In the function sayHi(), notice the use of this.name. When added to the 2 objects, the same function will print the message with the name of the respective object it's attached to.
jsconst Manager = {
  name: "Karina",
  age: 27,
  job: "Software Engineer",
};
const Intern = {
  name: "Tyrone",
  age: 21,
  job: "Software Engineer Intern",
};

function sayHi() {
  console.log(`Hello, my name is ${this.name}`);
}

// add sayHi function to both objects
Manager.sayHi = sayHi;
Intern.sayHi = sayHi;

Manager.sayHi(); // Hello, my name is Karina
Intern.sayHi(); // Hello, my name is Tyrone

this is a "hidden parameter" of a function call that's passed in by specifying the object before the function that was called. For example, in Manager.sayHi(), this is the Manager object, because Manager comes before the function sayHi(). If you access the same function from another object, this will change as well. If you use other methods to call the function, like Function.prototype.call() or Reflect.apply(), you can explicitly pass the value of this as an argument.Defining getters and settersA getter is a function associated with a property that gets the value of a specific property. A setter is a function associated with a property that sets the value of a specific property. Together, they can indirectly represent the value of a property.
Getters and setters can be either

defined within object initializers, or
added later to any existing object.

Within object initializers, getters and setters are defined like regular methods, but prefixed with the keywords get or set. The getter method must not expect a parameter, while the setter method expects exactly one parameter (the new value to set). For instance:
jsconst myObj = {
  a: 7,
  get b() {
    return this.a + 1;
  },
  set c(x) {
    this.a = x / 2;
  },
};

console.log(myObj.a); // 7
console.log(myObj.b); // 8, returned from the get b() method
myObj.c = 50; // Calls the set c(x) method
console.log(myObj.a); // 25

The myObj object's properties are:

myObj.a — a number
myObj.b — a getter that returns myObj.a plus 1
myObj.c — a setter that sets the value of myObj.a to half of the value myObj.c is being set to

Getters and setters can also be added to an object at any time after creation using the Object.defineProperties() method. This method's first parameter is the object on which you want to define the getter or setter. The second parameter is an object whose property names are the getter or setter names, and whose property values are objects for defining the getter or setter functions. Here's an example that defines the same getter and setter used in the previous example:
jsconst myObj = { a: 0 };

Object.defineProperties(myObj, {
  b: {
    get() {
      return this.a + 1;
    },
  },
  c: {
    set(x) {
      this.a = x / 2;
    },
  },
});

myObj.c = 10; // Runs the setter, which assigns 10 / 2 (5) to the 'a' property
console.log(myObj.b); // Runs the getter, which yields a + 1 or 6

Which of the two forms to choose depends on your programming style and task at hand. If you can change the definition of the original object, you will probably define getters and setters through the original initializer. This form is more compact and natural. However, if you need to add getters and setters later — maybe because you did not write the particular object — then the second form is the only possible form. The second form better represents the dynamic nature of JavaScript, but it can make the code hard to read and understand.Comparing objectsIn JavaScript, objects are a reference type. Two distinct objects are never equal, even if they have the same properties. Only comparing the same object reference with itself yields true.
js// Two variables, two distinct objects with the same properties
const fruit = { name: "apple" };
const anotherFruit = { name: "apple" };

fruit == anotherFruit; // return false
fruit === anotherFruit; // return false

js// Two variables, a single object
const fruit = { name: "apple" };
const anotherFruit = fruit; // Assign fruit object reference to anotherFruit

// Here fruit and anotherFruit are pointing to same object
fruit == anotherFruit; // return true
fruit === anotherFruit; // return true

fruit.name = "grape";
console.log(anotherFruit); // { name: "grape" }; not { name: "apple" }

For more information about comparison operators, see equality operators.See also
Inheritance and the prototype chain
Classes

 Previous  Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nUsing classes 
 Previous  Next  
JavaScript is a prototype-based language — an object's behaviors are specified by its own properties and its prototype's properties. However, with the addition of classes, the creation of hierarchies of objects and the inheritance of properties and their values are much more in line with other object-oriented languages such as Java. In this section, we will demonstrate how objects can be created from classes.
In many other languages, classes, or constructors, are clearly distinguished from objects, or instances. In JavaScript, classes are mainly an abstraction over the existing prototypical inheritance mechanism — all patterns are convertible to prototype-based inheritance. Classes themselves are normal JavaScript values as well, and have their own prototype chains. In fact, most plain JavaScript functions can be used as constructors — you use the new operator with a constructor function to create a new object.
We will be playing with the well-abstracted class model in this tutorial, and discuss what semantics classes offer. If you want to dive deep into the underlying prototype system, you can read the Inheritance and the prototype chain guide.
This chapter assumes that you are already somewhat familiar with JavaScript and that you have used ordinary objects.Overview of classesIf you have some hands-on experience with JavaScript, or have followed along with the guide, you probably have already used classes, even if you haven't created one. For example, this may seem familiar to you:
jsconst bigDay = new Date(2019, 6, 19);
console.log(bigDay.toLocaleDateString());
if (bigDay.getTime() < Date.now()) {
  console.log("Once upon a time...");
}

On the first line, we created an instance of the class Date, and called it bigDay. On the second line, we called a method toLocaleDateString() on the bigDay instance, which returns a string. Then, we compared two numbers: one returned from the getTime() method, the other directly called from the Date class itself, as Date.now().
Date is a built-in class of JavaScript. From this example, we can get some basic ideas of what classes do:

Classes create objects through the new operator.
Each object has some properties (data or method) added by the class.
The class stores some properties (data or method) itself, which are usually used to interact with instances.

These correspond to the three key features of classes:

Constructor;
Instance methods and instance fields;
Static methods and static fields.
Declaring a classClasses are usually created with class declarations.
jsclass MyClass {
  // class body...
}

Within a class body, there are a range of features available.
jsclass MyClass {
  // Constructor
  constructor() {
    // Constructor body
  }
  // Instance field
  myField = "foo";
  // Instance method
  myMethod() {
    // myMethod body
  }
  // Static field
  static myStaticField = "bar";
  // Static method
  static myStaticMethod() {
    // myStaticMethod body
  }
  // Static block
  static {
    // Static initialization code
  }
  // Fields, methods, static fields, and static methods all have
  // "private" forms
  #myPrivateField = "bar";
}

If you came from a pre-ES6 world, you may be more familiar with using functions as constructors. The pattern above would roughly translate to the following with function constructors:
jsfunction MyClass() {
  this.myField = "foo";
  // Constructor body
}
MyClass.myStaticField = "bar";
MyClass.myStaticMethod = function () {
  // myStaticMethod body
};
MyClass.prototype.myMethod = function () {
  // myMethod body
};

(function () {
  // Static initialization code
})();


Note:
Private fields and methods are new features in classes with no trivial equivalent in function constructors.
Constructing a classAfter a class has been declared, you can create instances of it using the new operator.
jsconst myInstance = new MyClass();
console.log(myInstance.myField); // 'foo'
myInstance.myMethod();

Typical function constructors can both be constructed with new and called without new. However, attempting to "call" a class without new will result in an error.
jsconst myInstance = MyClass(); // TypeError: Class constructor MyClass cannot be invoked without 'new'
Class declaration hoistingUnlike function declarations, class declarations are not hoisted (or, in some interpretations, hoisted but with the temporal dead zone restriction), which means you cannot use a class before it is declared.
jsnew MyClass(); // ReferenceError: Cannot access 'MyClass' before initialization

class MyClass {}

This behavior is similar to variables declared with let and const.Class expressionsSimilar to functions, class declarations also have their expression counterparts.
jsconst MyClass = class {
  // Class body...
};

Class expressions can have names as well. The expression's name is only visible to the class's body.
jsconst MyClass = class MyClassLongerName {
  // Class body. Here MyClass and MyClassLongerName point to the same class.
};
new MyClassLongerName(); // ReferenceError: MyClassLongerName is not defined
ConstructorPerhaps the most important job of a class is to act as a "factory" for objects. For example, when we use the Date constructor, we expect it to give a new object which represents the date data we passed in — which we can then manipulate with other methods the instance exposes. In classes, the instance creation is done by the constructor.
As an example, we would create a class called Color, which represents a specific color. Users create colors through passing in an RGB triplet.
jsclass Color {
  constructor(r, g, b) {
    // Assign the RGB values as a property of `this`.
    this.values = [r, g, b];
  }
}

Open your browser's devtools, paste the above code into the console, and then create an instance:
jsconst red = new Color(255, 0, 0);
console.log(red);

You should see some output like this:
Object { values: (3) […] }
  values: Array(3) [ 255, 0, 0 ]

You have successfully created a Color instance, and the instance has a values property, which is an array of the RGB values you passed in. That is pretty much equivalent to the following:
jsfunction createColor(r, g, b) {
  return {
    values: [r, g, b],
  };
}

The constructor's syntax is exactly the same as a normal function — which means you can use other syntaxes, like rest parameters:
jsclass Color {
  constructor(...values) {
    this.values = values;
  }
}

const red = new Color(255, 0, 0);
// Creates an instance with the same shape as above.

Each time you call new, a different instance is created.
jsconst red = new Color(255, 0, 0);
const anotherRed = new Color(255, 0, 0);
console.log(red === anotherRed); // false

Within a class constructor, the value of this points to the newly created instance. You can assign properties to it, or read existing properties (especially methods — which we will cover next).
The this value will be automatically returned as the result of new. You are advised to not return any value from the constructor — because if you return a non-primitive value, it will become the value of the new expression, and the value of this is dropped. (You can read more about what new does in its description.)
jsclass MyClass {
  constructor() {
    this.myField = "foo";
    return {};
  }
}

console.log(new MyClass().myField); // undefined
Instance methodsIf a class only has a constructor, it is not much different from a createX factory function which just creates plain objects. However, the power of classes is that they can be used as "templates" which automatically assign methods to instances.
For example, for Date instances, you can use a range of methods to get different information from a single date value, such as the year, month, day of the week, etc. You can also set those values through the setX counterparts like setFullYear.
For our own Color class, we can add a method called getRed which returns the red value of the color.
jsclass Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
  getRed() {
    return this.values[0];
  }
}

const red = new Color(255, 0, 0);
console.log(red.getRed()); // 255

Without methods, you may be tempted to define the function within the constructor:
jsclass Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
    this.getRed = function () {
      return this.values[0];
    };
  }
}

This also works. However, a problem is that this creates a new function every time a Color instance is created, even when they all do the same thing!
jsconsole.log(new Color().getRed === new Color().getRed); // false

In contrast, if you use a method, it will be shared between all instances. A function can be shared between all instances, but still have its behavior differ when different instances call it, because the value of this is different. If you are curious where this method is stored in — it's defined on the prototype of all instances, or Color.prototype, which is explained in more detail in Inheritance and the prototype chain.
Similarly, we can create a new method called setRed, which sets the red value of the color.
jsclass Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
  getRed() {
    return this.values[0];
  }
  setRed(value) {
    this.values[0] = value;
  }
}

const red = new Color(255, 0, 0);
red.setRed(0);
console.log(red.getRed()); // 0; of course, it should be called "black" at this stage!
Private fieldsYou might be wondering: why do we want to go to the trouble of using getRed and setRed methods, when we can directly access the values array on the instance?
jsclass Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
}

const red = new Color(255, 0, 0);
red.values[0] = 0;
console.log(red.values[0]); // 0

There is a philosophy in object-oriented programming called "encapsulation". This means you should not access the underlying implementation of an object, but instead use well-abstracted methods to interact with it. For example, if we suddenly decided to represent colors as HSL instead:
jsclass Color {
  constructor(r, g, b) {
    // values is now an HSL array!
    this.values = rgbToHSL([r, g, b]);
  }
  getRed() {
    return this.values[0];
  }
  setRed(value) {
    this.values[0] = value;
  }
}

const red = new Color(255, 0, 0);
console.log(red.values[0]); // 0; It's not 255 anymore, because the H value for pure red is 0

The user assumption that values means the RGB value suddenly collapses, and it may cause their logic to break. So, if you are an implementor of a class, you would want to hide the internal data structure of your instance from your user, both to keep the API clean and to prevent the user's code from breaking when you do some "harmless refactors". In classes, this is done through private fields.
A private field is an identifier prefixed with # (the hash symbol). The hash is an integral part of the field's name, which means a private property can never have name clash with a public property. In order to refer to a private field anywhere in the class, you must declare it in the class body (you can't create a private property on the fly). Apart from this, a private field is pretty much equivalent to a normal property.
jsclass Color {
  // Declare: every Color instance has a private field called #values.
  #values;
  constructor(r, g, b) {
    this.#values = [r, g, b];
  }
  getRed() {
    return this.#values[0];
  }
  setRed(value) {
    this.#values[0] = value;
  }
}

const red = new Color(255, 0, 0);
console.log(red.getRed()); // 255

Accessing private fields outside the class is an early syntax error. The language can guard against this because #privateField is a special syntax, so it can do some static analysis and find all usage of private fields before even evaluating the code.
jsconsole.log(red.#values); // SyntaxError: Private field '#values' must be declared in an enclosing class


Note:
Code run in the Chrome console can access private properties outside the class. This is a DevTools-only relaxation of the JavaScript syntax restriction.

Private fields in JavaScript are hard private: if the class does not implement methods that expose these private fields, there's absolutely no mechanism to retrieve them from outside the class. This means you are safe to do any refactors to your class's private fields, as long as the behavior of exposed methods stay the same.
After we've made the values field private, we can add some more logic in the getRed and setRed methods, instead of making them simple pass-through methods. For example, we can add a check in setRed to see if it's a valid R value:
jsclass Color {
  #values;
  constructor(r, g, b) {
    this.#values = [r, g, b];
  }
  getRed() {
    return this.#values[0];
  }
  setRed(value) {
    if (value < 0 || value > 255) {
      throw new RangeError("Invalid R value");
    }
    this.#values[0] = value;
  }
}

const red = new Color(255, 0, 0);
red.setRed(1000); // RangeError: Invalid R value

If we leave the values property exposed, our users can easily circumvent that check by assigning to values[0] directly, and create invalid colors. But with a well-encapsulated API, we can make our code more robust and prevent logic errors downstream.
A class method can read the private fields of other instances, as long as they belong to the same class.
jsclass Color {
  #values;
  constructor(r, g, b) {
    this.#values = [r, g, b];
  }
  redDifference(anotherColor) {
    // #values doesn't necessarily need to be accessed from this:
    // you can access private fields of other instances belonging
    // to the same class.
    return this.#values[0] - anotherColor.#values[0];
  }
}

const red = new Color(255, 0, 0);
const crimson = new Color(220, 20, 60);
red.redDifference(crimson); // 35

However, if anotherColor is not a Color instance, #values won't exist. (Even if another class has an identically named #values private field, it's not referring to the same thing and cannot be accessed here.) Accessing a nonexistent private property throws an error instead of returning undefined like normal properties do. If you don't know if a private field exists on an object and you wish to access it without using try/catch to handle the error, you can use the in operator.
jsclass Color {
  #values;
  constructor(r, g, b) {
    this.#values = [r, g, b];
  }
  redDifference(anotherColor) {
    if (!(#values in anotherColor)) {
      throw new TypeError("Color instance expected");
    }
    return this.#values[0] - anotherColor.#values[0];
  }
}


Note:
Keep in mind that the # is a special identifier syntax, and you can't use the field name as if it's a string. "#values" in anotherColor would look for a property name literally called "#values", instead of a private field.

There are some limitations in using private properties: the same name can't be declared twice in a single class, and they can't be deleted. Both lead to early syntax errors.
jsclass BadIdeas {
  #firstName;
  #firstName; // syntax error occurs here
  #lastName;
  constructor() {
    delete this.#lastName; // also a syntax error
  }
}

Methods, getters, and setters can be private as well. They're useful when you have something complex that the class needs to do internally but no other part of the code should be allowed to call.
For example, imagine creating HTML custom elements that should do something somewhat complicated when clicked/tapped/otherwise activated. Furthermore, the somewhat complicated things that happen when the element is clicked should be restricted to this class, because no other part of the JavaScript will (or should) ever access it.
jsclass Counter extends HTMLElement {
  #xValue = 0;
  constructor() {
    super();
    this.onclick = this.#clicked.bind(this);
  }
  get #x() {
    return this.#xValue;
  }
  set #x(value) {
    this.#xValue = value;
    window.requestAnimationFrame(this.#render.bind(this));
  }
  #clicked() {
    this.#x++;
  }
  #render() {
    this.textContent = this.#x.toString();
  }
  connectedCallback() {
    this.#render();
  }
}

customElements.define("num-counter", Counter);

In this case, pretty much every field and method is private to the class. Thus, it presents an interface to the rest of the code that's essentially just like a built-in HTML element. No other part of the program has the power to affect any of the internals of Counter.Accessor fieldscolor.getRed() and color.setRed() allow us to read and write to the red value of a color. If you come from languages like Java, you will be very familiar with this pattern. However, using methods to simply access a property is still somewhat unergonomic in JavaScript. Accessor fields allow us to manipulate something as if it is an "actual property".
jsclass Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
  get red() {
    return this.values[0];
  }
  set red(value) {
    this.values[0] = value;
  }
}

const red = new Color(255, 0, 0);
red.red = 0;
console.log(red.red); // 0

It looks as if the object has a property called red — but actually, no such property exists on the instance! There are only two methods, but they are prefixed with get and set, which allows them to be manipulated as if they were properties.
If a field only has a getter but no setter, it will be effectively read-only.
jsclass Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
  get red() {
    return this.values[0];
  }
}

const red = new Color(255, 0, 0);
red.red = 0;
console.log(red.red); // 255

In strict mode, the red.red = 0 line will throw a type error: "Cannot set property red of #<Color> which has only a getter". In non-strict mode, the assignment is silently ignored.Public fieldsPrivate fields also have their public counterparts, which allow every instance to have a property. Fields are usually designed to be independent of the constructor's parameters.
jsclass MyClass {
  luckyNumber = Math.random();
}
console.log(new MyClass().luckyNumber); // 0.5
console.log(new MyClass().luckyNumber); // 0.3

Public fields are almost equivalent to assigning a property to this. For example, the above example can also be converted to:
jsclass MyClass {
  constructor() {
    this.luckyNumber = Math.random();
  }
}
Static propertiesWith the Date example, we have also encountered the Date.now() method, which returns the current date. This method does not belong to any date instance — it belongs to the class itself. However, it's put on the Date class instead of being exposed as a global DateNow() function, because it's mostly useful when dealing with date instances.

Note:
Prefixing utility methods with what they deal with is called "namespacing" and is considered a good practice. For example, in addition to the older, unprefixed parseInt() method, JavaScript also later added the prefixed Number.parseInt() method to indicate that it's for dealing with numbers.

Static properties are a group of class features that are defined on the class itself, rather than on individual instances of the class. These features include:

Static methods
Static fields
Static getters and setters

Everything also has private counterparts. For example, for our Color class, we can create a static method that checks whether a given triplet is a valid RGB value:
jsclass Color {
  static isValid(r, g, b) {
    return r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255;
  }
}

Color.isValid(255, 0, 0); // true
Color.isValid(1000, 0, 0); // false

Static properties are very similar to their instance counterparts, except that:

They are all prefixed with static, and
They are not accessible from instances.

jsconsole.log(new Color(0, 0, 0).isValid); // undefined

There is also a special construct called a static initialization block, which is a block of code that runs when the class is first loaded.
jsclass MyClass {
  static {
    MyClass.myStaticProperty = "foo";
  }
}

console.log(MyClass.myStaticProperty); // 'foo'

Static initialization blocks are almost equivalent to immediately executing some code after a class has been declared. The only difference is that they have access to static private properties.Extends and inheritanceA key feature that classes bring about (in addition to ergonomic encapsulation with private fields) is inheritance, which means one object can "borrow" a large part of another object's behaviors, while overriding or enhancing certain parts with its own logic.
For example, suppose our Color class now needs to support transparency. We may be tempted to add a new field that indicates its transparency:
jsclass Color {
  #values;
  constructor(r, g, b, a = 1) {
    this.#values = [r, g, b, a];
  }
  get alpha() {
    return this.#values[3];
  }
  set alpha(value) {
    if (value < 0 || value > 1) {
      throw new RangeError("Alpha value must be between 0 and 1");
    }
    this.#values[3] = value;
  }
}

However, this means every instance — even the vast majority which aren't transparent (those with an alpha value of 1) — will have to have the extra alpha value, which is not very elegant. Plus, if the features keep growing, our Color class will become very bloated and hard to maintain.
Instead, in object-oriented programming, we would create a derived class. The derived class has access to all public properties of the parent class. In JavaScript, derived classes are declared with an extends clause, which indicates the class it extends from.
jsclass ColorWithAlpha extends Color {
  #alpha;
  constructor(r, g, b, a) {
    super(r, g, b);
    this.#alpha = a;
  }
  get alpha() {
    return this.#alpha;
  }
  set alpha(value) {
    if (value < 0 || value > 1) {
      throw new RangeError("Alpha value must be between 0 and 1");
    }
    this.#alpha = value;
  }
}

There are a few things that have immediately come to attention. First is that in the constructor, we are calling super(r, g, b). It is a language requirement to call super() before accessing this. The super() call calls the parent class's constructor to initialize this — here it's roughly equivalent to this = new Color(r, g, b). You can have code before super(), but you cannot access this before super() — the language prevents you from accessing the uninitialized this.
After the parent class is done with modifying this, the derived class can do its own logic. Here we added a private field called #alpha, and also provided a pair of getter/setters to interact with them.
A derived class inherits all methods from its parent. For example, although ColorWithAlpha doesn't declare a get red() accessor itself, you can still access red because this behavior is specified by the parent class:
jsconst color = new ColorWithAlpha(255, 0, 0, 0.5);
console.log(color.red); // 255

Derived classes can also override methods from the parent class. For example, all classes implicitly inherit the Object class, which defines some basic methods like toString(). However, the base toString() method is notoriously useless, because it prints [object Object] in most cases:
jsconsole.log(red.toString()); // [object Object]

Instead, our class can override it to print the color's RGB values:
jsclass Color {
  #values;
  // …
  toString() {
    return this.#values.join(", ");
  }
}

console.log(new Color(255, 0, 0).toString()); // '255, 0, 0'

Within derived classes, you can access the parent class's methods by using super. This allows you to build enhancement methods and avoid code duplication.
jsclass ColorWithAlpha extends Color {
  #alpha;
  // …
  toString() {
    // Call the parent class's toString() and build on the return value
    return `${super.toString()}, ${this.#alpha}`;
  }
}

console.log(new ColorWithAlpha(255, 0, 0, 0.5).toString()); // '255, 0, 0, 0.5'

When you use extends, the static methods inherit from each other as well, so you can also override or enhance them.
jsclass ColorWithAlpha extends Color {
  // ...
  static isValid(r, g, b, a) {
    // Call the parent class's isValid() and build on the return value
    return super.isValid(r, g, b) && a >= 0 && a <= 1;
  }
}

console.log(ColorWithAlpha.isValid(255, 0, 0, -1)); // false

Derived classes don't have access to the parent class's private fields — this is another key aspect to JavaScript private fields being "hard private". Private fields are scoped to the class body itself and do not grant access to any outside code.
jsclass ColorWithAlpha extends Color {
  log() {
    console.log(this.#values); // SyntaxError: Private field '#values' must be declared in an enclosing class
  }
}

A class can only extend from one class. This prevents problems in multiple inheritance like the diamond problem. However, due to the dynamic nature of JavaScript, it's still possible to achieve the effect of multiple inheritance through class composition and mixins.
Instances of derived classes are also instances of the base class.
jsconst color = new ColorWithAlpha(255, 0, 0, 0.5);
console.log(color instanceof Color); // true
console.log(color instanceof ColorWithAlpha); // true
Why classes?The guide has been pragmatic so far: we are focusing on how classes can be used, but there's one question unanswered: why would one use a class? The answer is: it depends.
Classes introduce a paradigm, or a way to organize your code. Classes are the foundations of object-oriented programming, which is built on concepts like inheritance and polymorphism (especially subtype polymorphism). However, many people are philosophically against certain OOP practices and don't use classes as a result.
For example, one thing that makes Date objects infamous is that they're mutable.
jsfunction incrementDay(date) {
  return date.setDate(date.getDate() + 1);
}
const date = new Date(); // 2019-06-19
const newDay = incrementDay(date);
console.log(newDay); // 2019-06-20
// The old date is modified as well!?
console.log(date); // 2019-06-20

Mutability and internal state are important aspects of object-oriented programming, but often make code hard to reason with — because any seemingly innocent operation may have unexpected side effects and change the behavior in other parts of the program.
In order to reuse code, we usually resort to extending classes, which can create big hierarchies of inheritance patterns.

However, it is often hard to describe inheritance cleanly when one class can only extend one other class. Often, we want the behavior of multiple classes. In Java, this is done through interfaces; in JavaScript, it can be done through mixins. But at the end of the day, it's still not very convenient.
On the brighter side, classes are a very powerful way to organize our code on a higher level. For example, without the Color class, we may need to create a dozen of utility functions:
jsfunction isRed(color) {
  return color.red === 255;
}
function isValidColor(color) {
  return (
    color.red >= 0 &&
    color.red <= 255 &&
    color.green >= 0 &&
    color.green <= 255 &&
    color.blue >= 0 &&
    color.blue <= 255
  );
}
// ...

But with classes, we can congregate them all under the Color namespace, which improves readability. In addition, the introduction of private fields allows us to hide certain data from downstream users, creating a clean API.
In general, you should consider using classes when you want to create objects that store their own internal data and expose a lot of behavior. Take built-in JavaScript classes as examples:

The Map and Set classes store a collection of elements and allow you to access them by key using get(), set(), has(), etc.
The Date class stores a date as a Unix timestamp (a number) and allows you to format, update, and read individual date components.
The Error class stores information about a particular exception, including the error message, stack trace, cause, etc. It's one of the few classes that come with a rich inheritance structure: there are multiple built-in classes like TypeError and ReferenceError that extend Error. In the case of errors, this inheritance allows refining the semantics of errors: each error class represents a specific type of error, which can be easily checked with instanceof.

JavaScript offers the mechanism to organize your code in a canonical object-oriented way, but whether and how to use it is entirely up to the programmer's discretion.
 Previous  Next\n\nUsing classes 
 Previous  Next  
JavaScript is a prototype-based language — an object's behaviors are specified by its own properties and its prototype's properties. However, with the addition of classes, the creation of hierarchies of objects and the inheritance of properties and their values are much more in line with other object-oriented languages such as Java. In this section, we will demonstrate how objects can be created from classes.
In many other languages, classes, or constructors, are clearly distinguished from objects, or instances. In JavaScript, classes are mainly an abstraction over the existing prototypical inheritance mechanism — all patterns are convertible to prototype-based inheritance. Classes themselves are normal JavaScript values as well, and have their own prototype chains. In fact, most plain JavaScript functions can be used as constructors — you use the new operator with a constructor function to create a new object.
We will be playing with the well-abstracted class model in this tutorial, and discuss what semantics classes offer. If you want to dive deep into the underlying prototype system, you can read the Inheritance and the prototype chain guide.
This chapter assumes that you are already somewhat familiar with JavaScript and that you have used ordinary objects.Overview of classesIf you have some hands-on experience with JavaScript, or have followed along with the guide, you probably have already used classes, even if you haven't created one. For example, this may seem familiar to you:
jsconst bigDay = new Date(2019, 6, 19);
console.log(bigDay.toLocaleDateString());
if (bigDay.getTime() < Date.now()) {
  console.log("Once upon a time...");
}

On the first line, we created an instance of the class Date, and called it bigDay. On the second line, we called a method toLocaleDateString() on the bigDay instance, which returns a string. Then, we compared two numbers: one returned from the getTime() method, the other directly called from the Date class itself, as Date.now().
Date is a built-in class of JavaScript. From this example, we can get some basic ideas of what classes do:

Classes create objects through the new operator.
Each object has some properties (data or method) added by the class.
The class stores some properties (data or method) itself, which are usually used to interact with instances.

These correspond to the three key features of classes:

Constructor;
Instance methods and instance fields;
Static methods and static fields.
Declaring a classClasses are usually created with class declarations.
jsclass MyClass {
  // class body...
}

Within a class body, there are a range of features available.
jsclass MyClass {
  // Constructor
  constructor() {
    // Constructor body
  }
  // Instance field
  myField = "foo";
  // Instance method
  myMethod() {
    // myMethod body
  }
  // Static field
  static myStaticField = "bar";
  // Static method
  static myStaticMethod() {
    // myStaticMethod body
  }
  // Static block
  static {
    // Static initialization code
  }
  // Fields, methods, static fields, and static methods all have
  // "private" forms
  #myPrivateField = "bar";
}

If you came from a pre-ES6 world, you may be more familiar with using functions as constructors. The pattern above would roughly translate to the following with function constructors:
jsfunction MyClass() {
  this.myField = "foo";
  // Constructor body
}
MyClass.myStaticField = "bar";
MyClass.myStaticMethod = function () {
  // myStaticMethod body
};
MyClass.prototype.myMethod = function () {
  // myMethod body
};

(function () {
  // Static initialization code
})();


Note:
Private fields and methods are new features in classes with no trivial equivalent in function constructors.
Constructing a classAfter a class has been declared, you can create instances of it using the new operator.
jsconst myInstance = new MyClass();
console.log(myInstance.myField); // 'foo'
myInstance.myMethod();

Typical function constructors can both be constructed with new and called without new. However, attempting to "call" a class without new will result in an error.
jsconst myInstance = MyClass(); // TypeError: Class constructor MyClass cannot be invoked without 'new'
Class declaration hoistingUnlike function declarations, class declarations are not hoisted (or, in some interpretations, hoisted but with the temporal dead zone restriction), which means you cannot use a class before it is declared.
jsnew MyClass(); // ReferenceError: Cannot access 'MyClass' before initialization

class MyClass {}

This behavior is similar to variables declared with let and const.Class expressionsSimilar to functions, class declarations also have their expression counterparts.
jsconst MyClass = class {
  // Class body...
};

Class expressions can have names as well. The expression's name is only visible to the class's body.
jsconst MyClass = class MyClassLongerName {
  // Class body. Here MyClass and MyClassLongerName point to the same class.
};
new MyClassLongerName(); // ReferenceError: MyClassLongerName is not defined
ConstructorPerhaps the most important job of a class is to act as a "factory" for objects. For example, when we use the Date constructor, we expect it to give a new object which represents the date data we passed in — which we can then manipulate with other methods the instance exposes. In classes, the instance creation is done by the constructor.
As an example, we would create a class called Color, which represents a specific color. Users create colors through passing in an RGB triplet.
jsclass Color {
  constructor(r, g, b) {
    // Assign the RGB values as a property of `this`.
    this.values = [r, g, b];
  }
}

Open your browser's devtools, paste the above code into the console, and then create an instance:
jsconst red = new Color(255, 0, 0);
console.log(red);

You should see some output like this:
Object { values: (3) […] }
  values: Array(3) [ 255, 0, 0 ]

You have successfully created a Color instance, and the instance has a values property, which is an array of the RGB values you passed in. That is pretty much equivalent to the following:
jsfunction createColor(r, g, b) {
  return {
    values: [r, g, b],
  };
}

The constructor's syntax is exactly the same as a normal function — which means you can use other syntaxes, like rest parameters:
jsclass Color {
  constructor(...values) {
    this.values = values;
  }
}

const red = new Color(255, 0, 0);
// Creates an instance with the same shape as above.

Each time you call new, a different instance is created.
jsconst red = new Color(255, 0, 0);
const anotherRed = new Color(255, 0, 0);
console.log(red === anotherRed); // false

Within a class constructor, the value of this points to the newly created instance. You can assign properties to it, or read existing properties (especially methods — which we will cover next).
The this value will be automatically returned as the result of new. You are advised to not return any value from the constructor — because if you return a non-primitive value, it will become the value of the new expression, and the value of this is dropped. (You can read more about what new does in its description.)
jsclass MyClass {
  constructor() {
    this.myField = "foo";
    return {};
  }
}

console.log(new MyClass().myField); // undefined
Instance methodsIf a class only has a constructor, it is not much different from a createX factory function which just creates plain objects. However, the power of classes is that they can be used as "templates" which automatically assign methods to instances.
For example, for Date instances, you can use a range of methods to get different information from a single date value, such as the year, month, day of the week, etc. You can also set those values through the setX counterparts like setFullYear.
For our own Color class, we can add a method called getRed which returns the red value of the color.
jsclass Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
  getRed() {
    return this.values[0];
  }
}

const red = new Color(255, 0, 0);
console.log(red.getRed()); // 255

Without methods, you may be tempted to define the function within the constructor:
jsclass Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
    this.getRed = function () {
      return this.values[0];
    };
  }
}

This also works. However, a problem is that this creates a new function every time a Color instance is created, even when they all do the same thing!
jsconsole.log(new Color().getRed === new Color().getRed); // false

In contrast, if you use a method, it will be shared between all instances. A function can be shared between all instances, but still have its behavior differ when different instances call it, because the value of this is different. If you are curious where this method is stored in — it's defined on the prototype of all instances, or Color.prototype, which is explained in more detail in Inheritance and the prototype chain.
Similarly, we can create a new method called setRed, which sets the red value of the color.
jsclass Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
  getRed() {
    return this.values[0];
  }
  setRed(value) {
    this.values[0] = value;
  }
}

const red = new Color(255, 0, 0);
red.setRed(0);
console.log(red.getRed()); // 0; of course, it should be called "black" at this stage!
Private fieldsYou might be wondering: why do we want to go to the trouble of using getRed and setRed methods, when we can directly access the values array on the instance?
jsclass Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
}

const red = new Color(255, 0, 0);
red.values[0] = 0;
console.log(red.values[0]); // 0

There is a philosophy in object-oriented programming called "encapsulation". This means you should not access the underlying implementation of an object, but instead use well-abstracted methods to interact with it. For example, if we suddenly decided to represent colors as HSL instead:
jsclass Color {
  constructor(r, g, b) {
    // values is now an HSL array!
    this.values = rgbToHSL([r, g, b]);
  }
  getRed() {
    return this.values[0];
  }
  setRed(value) {
    this.values[0] = value;
  }
}

const red = new Color(255, 0, 0);
console.log(red.values[0]); // 0; It's not 255 anymore, because the H value for pure red is 0

The user assumption that values means the RGB value suddenly collapses, and it may cause their logic to break. So, if you are an implementor of a class, you would want to hide the internal data structure of your instance from your user, both to keep the API clean and to prevent the user's code from breaking when you do some "harmless refactors". In classes, this is done through private fields.
A private field is an identifier prefixed with # (the hash symbol). The hash is an integral part of the field's name, which means a private property can never have name clash with a public property. In order to refer to a private field anywhere in the class, you must declare it in the class body (you can't create a private property on the fly). Apart from this, a private field is pretty much equivalent to a normal property.
jsclass Color {
  // Declare: every Color instance has a private field called #values.
  #values;
  constructor(r, g, b) {
    this.#values = [r, g, b];
  }
  getRed() {
    return this.#values[0];
  }
  setRed(value) {
    this.#values[0] = value;
  }
}

const red = new Color(255, 0, 0);
console.log(red.getRed()); // 255

Accessing private fields outside the class is an early syntax error. The language can guard against this because #privateField is a special syntax, so it can do some static analysis and find all usage of private fields before even evaluating the code.
jsconsole.log(red.#values); // SyntaxError: Private field '#values' must be declared in an enclosing class


Note:
Code run in the Chrome console can access private properties outside the class. This is a DevTools-only relaxation of the JavaScript syntax restriction.

Private fields in JavaScript are hard private: if the class does not implement methods that expose these private fields, there's absolutely no mechanism to retrieve them from outside the class. This means you are safe to do any refactors to your class's private fields, as long as the behavior of exposed methods stay the same.
After we've made the values field private, we can add some more logic in the getRed and setRed methods, instead of making them simple pass-through methods. For example, we can add a check in setRed to see if it's a valid R value:
jsclass Color {
  #values;
  constructor(r, g, b) {
    this.#values = [r, g, b];
  }
  getRed() {
    return this.#values[0];
  }
  setRed(value) {
    if (value < 0 || value > 255) {
      throw new RangeError("Invalid R value");
    }
    this.#values[0] = value;
  }
}

const red = new Color(255, 0, 0);
red.setRed(1000); // RangeError: Invalid R value

If we leave the values property exposed, our users can easily circumvent that check by assigning to values[0] directly, and create invalid colors. But with a well-encapsulated API, we can make our code more robust and prevent logic errors downstream.
A class method can read the private fields of other instances, as long as they belong to the same class.
jsclass Color {
  #values;
  constructor(r, g, b) {
    this.#values = [r, g, b];
  }
  redDifference(anotherColor) {
    // #values doesn't necessarily need to be accessed from this:
    // you can access private fields of other instances belonging
    // to the same class.
    return this.#values[0] - anotherColor.#values[0];
  }
}

const red = new Color(255, 0, 0);
const crimson = new Color(220, 20, 60);
red.redDifference(crimson); // 35

However, if anotherColor is not a Color instance, #values won't exist. (Even if another class has an identically named #values private field, it's not referring to the same thing and cannot be accessed here.) Accessing a nonexistent private property throws an error instead of returning undefined like normal properties do. If you don't know if a private field exists on an object and you wish to access it without using try/catch to handle the error, you can use the in operator.
jsclass Color {
  #values;
  constructor(r, g, b) {
    this.#values = [r, g, b];
  }
  redDifference(anotherColor) {
    if (!(#values in anotherColor)) {
      throw new TypeError("Color instance expected");
    }
    return this.#values[0] - anotherColor.#values[0];
  }
}


Note:
Keep in mind that the # is a special identifier syntax, and you can't use the field name as if it's a string. "#values" in anotherColor would look for a property name literally called "#values", instead of a private field.

There are some limitations in using private properties: the same name can't be declared twice in a single class, and they can't be deleted. Both lead to early syntax errors.
jsclass BadIdeas {
  #firstName;
  #firstName; // syntax error occurs here
  #lastName;
  constructor() {
    delete this.#lastName; // also a syntax error
  }
}

Methods, getters, and setters can be private as well. They're useful when you have something complex that the class needs to do internally but no other part of the code should be allowed to call.
For example, imagine creating HTML custom elements that should do something somewhat complicated when clicked/tapped/otherwise activated. Furthermore, the somewhat complicated things that happen when the element is clicked should be restricted to this class, because no other part of the JavaScript will (or should) ever access it.
jsclass Counter extends HTMLElement {
  #xValue = 0;
  constructor() {
    super();
    this.onclick = this.#clicked.bind(this);
  }
  get #x() {
    return this.#xValue;
  }
  set #x(value) {
    this.#xValue = value;
    window.requestAnimationFrame(this.#render.bind(this));
  }
  #clicked() {
    this.#x++;
  }
  #render() {
    this.textContent = this.#x.toString();
  }
  connectedCallback() {
    this.#render();
  }
}

customElements.define("num-counter", Counter);

In this case, pretty much every field and method is private to the class. Thus, it presents an interface to the rest of the code that's essentially just like a built-in HTML element. No other part of the program has the power to affect any of the internals of Counter.Accessor fieldscolor.getRed() and color.setRed() allow us to read and write to the red value of a color. If you come from languages like Java, you will be very familiar with this pattern. However, using methods to simply access a property is still somewhat unergonomic in JavaScript. Accessor fields allow us to manipulate something as if it is an "actual property".
jsclass Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
  get red() {
    return this.values[0];
  }
  set red(value) {
    this.values[0] = value;
  }
}

const red = new Color(255, 0, 0);
red.red = 0;
console.log(red.red); // 0

It looks as if the object has a property called red — but actually, no such property exists on the instance! There are only two methods, but they are prefixed with get and set, which allows them to be manipulated as if they were properties.
If a field only has a getter but no setter, it will be effectively read-only.
jsclass Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
  get red() {
    return this.values[0];
  }
}

const red = new Color(255, 0, 0);
red.red = 0;
console.log(red.red); // 255

In strict mode, the red.red = 0 line will throw a type error: "Cannot set property red of #<Color> which has only a getter". In non-strict mode, the assignment is silently ignored.Public fieldsPrivate fields also have their public counterparts, which allow every instance to have a property. Fields are usually designed to be independent of the constructor's parameters.
jsclass MyClass {
  luckyNumber = Math.random();
}
console.log(new MyClass().luckyNumber); // 0.5
console.log(new MyClass().luckyNumber); // 0.3

Public fields are almost equivalent to assigning a property to this. For example, the above example can also be converted to:
jsclass MyClass {
  constructor() {
    this.luckyNumber = Math.random();
  }
}
Static propertiesWith the Date example, we have also encountered the Date.now() method, which returns the current date. This method does not belong to any date instance — it belongs to the class itself. However, it's put on the Date class instead of being exposed as a global DateNow() function, because it's mostly useful when dealing with date instances.

Note:
Prefixing utility methods with what they deal with is called "namespacing" and is considered a good practice. For example, in addition to the older, unprefixed parseInt() method, JavaScript also later added the prefixed Number.parseInt() method to indicate that it's for dealing with numbers.

Static properties are a group of class features that are defined on the class itself, rather than on individual instances of the class. These features include:

Static methods
Static fields
Static getters and setters

Everything also has private counterparts. For example, for our Color class, we can create a static method that checks whether a given triplet is a valid RGB value:
jsclass Color {
  static isValid(r, g, b) {
    return r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255;
  }
}

Color.isValid(255, 0, 0); // true
Color.isValid(1000, 0, 0); // false

Static properties are very similar to their instance counterparts, except that:

They are all prefixed with static, and
They are not accessible from instances.

jsconsole.log(new Color(0, 0, 0).isValid); // undefined

There is also a special construct called a static initialization block, which is a block of code that runs when the class is first loaded.
jsclass MyClass {
  static {
    MyClass.myStaticProperty = "foo";
  }
}

console.log(MyClass.myStaticProperty); // 'foo'

Static initialization blocks are almost equivalent to immediately executing some code after a class has been declared. The only difference is that they have access to static private properties.Extends and inheritanceA key feature that classes bring about (in addition to ergonomic encapsulation with private fields) is inheritance, which means one object can "borrow" a large part of another object's behaviors, while overriding or enhancing certain parts with its own logic.
For example, suppose our Color class now needs to support transparency. We may be tempted to add a new field that indicates its transparency:
jsclass Color {
  #values;
  constructor(r, g, b, a = 1) {
    this.#values = [r, g, b, a];
  }
  get alpha() {
    return this.#values[3];
  }
  set alpha(value) {
    if (value < 0 || value > 1) {
      throw new RangeError("Alpha value must be between 0 and 1");
    }
    this.#values[3] = value;
  }
}

However, this means every instance — even the vast majority which aren't transparent (those with an alpha value of 1) — will have to have the extra alpha value, which is not very elegant. Plus, if the features keep growing, our Color class will become very bloated and hard to maintain.
Instead, in object-oriented programming, we would create a derived class. The derived class has access to all public properties of the parent class. In JavaScript, derived classes are declared with an extends clause, which indicates the class it extends from.
jsclass ColorWithAlpha extends Color {
  #alpha;
  constructor(r, g, b, a) {
    super(r, g, b);
    this.#alpha = a;
  }
  get alpha() {
    return this.#alpha;
  }
  set alpha(value) {
    if (value < 0 || value > 1) {
      throw new RangeError("Alpha value must be between 0 and 1");
    }
    this.#alpha = value;
  }
}

There are a few things that have immediately come to attention. First is that in the constructor, we are calling super(r, g, b). It is a language requirement to call super() before accessing this. The super() call calls the parent class's constructor to initialize this — here it's roughly equivalent to this = new Color(r, g, b). You can have code before super(), but you cannot access this before super() — the language prevents you from accessing the uninitialized this.
After the parent class is done with modifying this, the derived class can do its own logic. Here we added a private field called #alpha, and also provided a pair of getter/setters to interact with them.
A derived class inherits all methods from its parent. For example, although ColorWithAlpha doesn't declare a get red() accessor itself, you can still access red because this behavior is specified by the parent class:
jsconst color = new ColorWithAlpha(255, 0, 0, 0.5);
console.log(color.red); // 255

Derived classes can also override methods from the parent class. For example, all classes implicitly inherit the Object class, which defines some basic methods like toString(). However, the base toString() method is notoriously useless, because it prints [object Object] in most cases:
jsconsole.log(red.toString()); // [object Object]

Instead, our class can override it to print the color's RGB values:
jsclass Color {
  #values;
  // …
  toString() {
    return this.#values.join(", ");
  }
}

console.log(new Color(255, 0, 0).toString()); // '255, 0, 0'

Within derived classes, you can access the parent class's methods by using super. This allows you to build enhancement methods and avoid code duplication.
jsclass ColorWithAlpha extends Color {
  #alpha;
  // …
  toString() {
    // Call the parent class's toString() and build on the return value
    return `${super.toString()}, ${this.#alpha}`;
  }
}

console.log(new ColorWithAlpha(255, 0, 0, 0.5).toString()); // '255, 0, 0, 0.5'

When you use extends, the static methods inherit from each other as well, so you can also override or enhance them.
jsclass ColorWithAlpha extends Color {
  // ...
  static isValid(r, g, b, a) {
    // Call the parent class's isValid() and build on the return value
    return super.isValid(r, g, b) && a >= 0 && a <= 1;
  }
}

console.log(ColorWithAlpha.isValid(255, 0, 0, -1)); // false

Derived classes don't have access to the parent class's private fields — this is another key aspect to JavaScript private fields being "hard private". Private fields are scoped to the class body itself and do not grant access to any outside code.
jsclass ColorWithAlpha extends Color {
  log() {
    console.log(this.#values); // SyntaxError: Private field '#values' must be declared in an enclosing class
  }
}

A class can only extend from one class. This prevents problems in multiple inheritance like the diamond problem. However, due to the dynamic nature of JavaScript, it's still possible to achieve the effect of multiple inheritance through class composition and mixins.
Instances of derived classes are also instances of the base class.
jsconst color = new ColorWithAlpha(255, 0, 0, 0.5);
console.log(color instanceof Color); // true
console.log(color instanceof ColorWithAlpha); // true
Why classes?The guide has been pragmatic so far: we are focusing on how classes can be used, but there's one question unanswered: why would one use a class? The answer is: it depends.
Classes introduce a paradigm, or a way to organize your code. Classes are the foundations of object-oriented programming, which is built on concepts like inheritance and polymorphism (especially subtype polymorphism). However, many people are philosophically against certain OOP practices and don't use classes as a result.
For example, one thing that makes Date objects infamous is that they're mutable.
jsfunction incrementDay(date) {
  return date.setDate(date.getDate() + 1);
}
const date = new Date(); // 2019-06-19
const newDay = incrementDay(date);
console.log(newDay); // 2019-06-20
// The old date is modified as well!?
console.log(date); // 2019-06-20

Mutability and internal state are important aspects of object-oriented programming, but often make code hard to reason with — because any seemingly innocent operation may have unexpected side effects and change the behavior in other parts of the program.
In order to reuse code, we usually resort to extending classes, which can create big hierarchies of inheritance patterns.

However, it is often hard to describe inheritance cleanly when one class can only extend one other class. Often, we want the behavior of multiple classes. In Java, this is done through interfaces; in JavaScript, it can be done through mixins. But at the end of the day, it's still not very convenient.
On the brighter side, classes are a very powerful way to organize our code on a higher level. For example, without the Color class, we may need to create a dozen of utility functions:
jsfunction isRed(color) {
  return color.red === 255;
}
function isValidColor(color) {
  return (
    color.red >= 0 &&
    color.red <= 255 &&
    color.green >= 0 &&
    color.green <= 255 &&
    color.blue >= 0 &&
    color.blue <= 255
  );
}
// ...

But with classes, we can congregate them all under the Color namespace, which improves readability. In addition, the introduction of private fields allows us to hide certain data from downstream users, creating a clean API.
In general, you should consider using classes when you want to create objects that store their own internal data and expose a lot of behavior. Take built-in JavaScript classes as examples:

The Map and Set classes store a collection of elements and allow you to access them by key using get(), set(), has(), etc.
The Date class stores a date as a Unix timestamp (a number) and allows you to format, update, and read individual date components.
The Error class stores information about a particular exception, including the error message, stack trace, cause, etc. It's one of the few classes that come with a rich inheritance structure: there are multiple built-in classes like TypeError and ReferenceError that extend Error. In the case of errors, this inheritance allows refining the semantics of errors: each error class represents a specific type of error, which can be easily checked with instanceof.

JavaScript offers the mechanism to organize your code in a canonical object-oriented way, but whether and how to use it is entirely up to the programmer's discretion.
 Previous  Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nUsing classes 
 Previous  Next  
JavaScript is a prototype-based language — an object's behaviors are specified by its own properties and its prototype's properties. However, with the addition of classes, the creation of hierarchies of objects and the inheritance of properties and their values are much more in line with other object-oriented languages such as Java. In this section, we will demonstrate how objects can be created from classes.
In many other languages, classes, or constructors, are clearly distinguished from objects, or instances. In JavaScript, classes are mainly an abstraction over the existing prototypical inheritance mechanism — all patterns are convertible to prototype-based inheritance. Classes themselves are normal JavaScript values as well, and have their own prototype chains. In fact, most plain JavaScript functions can be used as constructors — you use the new operator with a constructor function to create a new object.
We will be playing with the well-abstracted class model in this tutorial, and discuss what semantics classes offer. If you want to dive deep into the underlying prototype system, you can read the Inheritance and the prototype chain guide.
This chapter assumes that you are already somewhat familiar with JavaScript and that you have used ordinary objects.Overview of classesIf you have some hands-on experience with JavaScript, or have followed along with the guide, you probably have already used classes, even if you haven't created one. For example, this may seem familiar to you:
jsconst bigDay = new Date(2019, 6, 19);
console.log(bigDay.toLocaleDateString());
if (bigDay.getTime() < Date.now()) {
  console.log("Once upon a time...");
}

On the first line, we created an instance of the class Date, and called it bigDay. On the second line, we called a method toLocaleDateString() on the bigDay instance, which returns a string. Then, we compared two numbers: one returned from the getTime() method, the other directly called from the Date class itself, as Date.now().
Date is a built-in class of JavaScript. From this example, we can get some basic ideas of what classes do:

Classes create objects through the new operator.
Each object has some properties (data or method) added by the class.
The class stores some properties (data or method) itself, which are usually used to interact with instances.

These correspond to the three key features of classes:

Constructor;
Instance methods and instance fields;
Static methods and static fields.
Declaring a classClasses are usually created with class declarations.
jsclass MyClass {
  // class body...
}

Within a class body, there are a range of features available.
jsclass MyClass {
  // Constructor
  constructor() {
    // Constructor body
  }
  // Instance field
  myField = "foo";
  // Instance method
  myMethod() {
    // myMethod body
  }
  // Static field
  static myStaticField = "bar";
  // Static method
  static myStaticMethod() {
    // myStaticMethod body
  }
  // Static block
  static {
    // Static initialization code
  }
  // Fields, methods, static fields, and static methods all have
  // "private" forms
  #myPrivateField = "bar";
}

If you came from a pre-ES6 world, you may be more familiar with using functions as constructors. The pattern above would roughly translate to the following with function constructors:
jsfunction MyClass() {
  this.myField = "foo";
  // Constructor body
}
MyClass.myStaticField = "bar";
MyClass.myStaticMethod = function () {
  // myStaticMethod body
};
MyClass.prototype.myMethod = function () {
  // myMethod body
};

(function () {
  // Static initialization code
})();


Note:
Private fields and methods are new features in classes with no trivial equivalent in function constructors.
Constructing a classAfter a class has been declared, you can create instances of it using the new operator.
jsconst myInstance = new MyClass();
console.log(myInstance.myField); // 'foo'
myInstance.myMethod();

Typical function constructors can both be constructed with new and called without new. However, attempting to "call" a class without new will result in an error.
jsconst myInstance = MyClass(); // TypeError: Class constructor MyClass cannot be invoked without 'new'
Class declaration hoistingUnlike function declarations, class declarations are not hoisted (or, in some interpretations, hoisted but with the temporal dead zone restriction), which means you cannot use a class before it is declared.
jsnew MyClass(); // ReferenceError: Cannot access 'MyClass' before initialization

class MyClass {}

This behavior is similar to variables declared with let and const.Class expressionsSimilar to functions, class declarations also have their expression counterparts.
jsconst MyClass = class {
  // Class body...
};

Class expressions can have names as well. The expression's name is only visible to the class's body.
jsconst MyClass = class MyClassLongerName {
  // Class body. Here MyClass and MyClassLongerName point to the same class.
};
new MyClassLongerName(); // ReferenceError: MyClassLongerName is not defined
ConstructorPerhaps the most important job of a class is to act as a "factory" for objects. For example, when we use the Date constructor, we expect it to give a new object which represents the date data we passed in — which we can then manipulate with other methods the instance exposes. In classes, the instance creation is done by the constructor.
As an example, we would create a class called Color, which represents a specific color. Users create colors through passing in an RGB triplet.
jsclass Color {
  constructor(r, g, b) {
    // Assign the RGB values as a property of `this`.
    this.values = [r, g, b];
  }
}

Open your browser's devtools, paste the above code into the console, and then create an instance:
jsconst red = new Color(255, 0, 0);
console.log(red);

You should see some output like this:
Object { values: (3) […] }
  values: Array(3) [ 255, 0, 0 ]

You have successfully created a Color instance, and the instance has a values property, which is an array of the RGB values you passed in. That is pretty much equivalent to the following:
jsfunction createColor(r, g, b) {
  return {
    values: [r, g, b],
  };
}

The constructor's syntax is exactly the same as a normal function — which means you can use other syntaxes, like rest parameters:
jsclass Color {
  constructor(...values) {
    this.values = values;
  }
}

const red = new Color(255, 0, 0);
// Creates an instance with the same shape as above.

Each time you call new, a different instance is created.
jsconst red = new Color(255, 0, 0);
const anotherRed = new Color(255, 0, 0);
console.log(red === anotherRed); // false

Within a class constructor, the value of this points to the newly created instance. You can assign properties to it, or read existing properties (especially methods — which we will cover next).
The this value will be automatically returned as the result of new. You are advised to not return any value from the constructor — because if you return a non-primitive value, it will become the value of the new expression, and the value of this is dropped. (You can read more about what new does in its description.)
jsclass MyClass {
  constructor() {
    this.myField = "foo";
    return {};
  }
}

console.log(new MyClass().myField); // undefined
Instance methodsIf a class only has a constructor, it is not much different from a createX factory function which just creates plain objects. However, the power of classes is that they can be used as "templates" which automatically assign methods to instances.
For example, for Date instances, you can use a range of methods to get different information from a single date value, such as the year, month, day of the week, etc. You can also set those values through the setX counterparts like setFullYear.
For our own Color class, we can add a method called getRed which returns the red value of the color.
jsclass Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
  getRed() {
    return this.values[0];
  }
}

const red = new Color(255, 0, 0);
console.log(red.getRed()); // 255

Without methods, you may be tempted to define the function within the constructor:
jsclass Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
    this.getRed = function () {
      return this.values[0];
    };
  }
}

This also works. However, a problem is that this creates a new function every time a Color instance is created, even when they all do the same thing!
jsconsole.log(new Color().getRed === new Color().getRed); // false

In contrast, if you use a method, it will be shared between all instances. A function can be shared between all instances, but still have its behavior differ when different instances call it, because the value of this is different. If you are curious where this method is stored in — it's defined on the prototype of all instances, or Color.prototype, which is explained in more detail in Inheritance and the prototype chain.
Similarly, we can create a new method called setRed, which sets the red value of the color.
jsclass Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
  getRed() {
    return this.values[0];
  }
  setRed(value) {
    this.values[0] = value;
  }
}

const red = new Color(255, 0, 0);
red.setRed(0);
console.log(red.getRed()); // 0; of course, it should be called "black" at this stage!
Private fieldsYou might be wondering: why do we want to go to the trouble of using getRed and setRed methods, when we can directly access the values array on the instance?
jsclass Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
}

const red = new Color(255, 0, 0);
red.values[0] = 0;
console.log(red.values[0]); // 0

There is a philosophy in object-oriented programming called "encapsulation". This means you should not access the underlying implementation of an object, but instead use well-abstracted methods to interact with it. For example, if we suddenly decided to represent colors as HSL instead:
jsclass Color {
  constructor(r, g, b) {
    // values is now an HSL array!
    this.values = rgbToHSL([r, g, b]);
  }
  getRed() {
    return this.values[0];
  }
  setRed(value) {
    this.values[0] = value;
  }
}

const red = new Color(255, 0, 0);
console.log(red.values[0]); // 0; It's not 255 anymore, because the H value for pure red is 0

The user assumption that values means the RGB value suddenly collapses, and it may cause their logic to break. So, if you are an implementor of a class, you would want to hide the internal data structure of your instance from your user, both to keep the API clean and to prevent the user's code from breaking when you do some "harmless refactors". In classes, this is done through private fields.
A private field is an identifier prefixed with # (the hash symbol). The hash is an integral part of the field's name, which means a private property can never have name clash with a public property. In order to refer to a private field anywhere in the class, you must declare it in the class body (you can't create a private property on the fly). Apart from this, a private field is pretty much equivalent to a normal property.
jsclass Color {
  // Declare: every Color instance has a private field called #values.
  #values;
  constructor(r, g, b) {
    this.#values = [r, g, b];
  }
  getRed() {
    return this.#values[0];
  }
  setRed(value) {
    this.#values[0] = value;
  }
}

const red = new Color(255, 0, 0);
console.log(red.getRed()); // 255

Accessing private fields outside the class is an early syntax error. The language can guard against this because #privateField is a special syntax, so it can do some static analysis and find all usage of private fields before even evaluating the code.
jsconsole.log(red.#values); // SyntaxError: Private field '#values' must be declared in an enclosing class


Note:
Code run in the Chrome console can access private properties outside the class. This is a DevTools-only relaxation of the JavaScript syntax restriction.

Private fields in JavaScript are hard private: if the class does not implement methods that expose these private fields, there's absolutely no mechanism to retrieve them from outside the class. This means you are safe to do any refactors to your class's private fields, as long as the behavior of exposed methods stay the same.
After we've made the values field private, we can add some more logic in the getRed and setRed methods, instead of making them simple pass-through methods. For example, we can add a check in setRed to see if it's a valid R value:
jsclass Color {
  #values;
  constructor(r, g, b) {
    this.#values = [r, g, b];
  }
  getRed() {
    return this.#values[0];
  }
  setRed(value) {
    if (value < 0 || value > 255) {
      throw new RangeError("Invalid R value");
    }
    this.#values[0] = value;
  }
}

const red = new Color(255, 0, 0);
red.setRed(1000); // RangeError: Invalid R value

If we leave the values property exposed, our users can easily circumvent that check by assigning to values[0] directly, and create invalid colors. But with a well-encapsulated API, we can make our code more robust and prevent logic errors downstream.
A class method can read the private fields of other instances, as long as they belong to the same class.
jsclass Color {
  #values;
  constructor(r, g, b) {
    this.#values = [r, g, b];
  }
  redDifference(anotherColor) {
    // #values doesn't necessarily need to be accessed from this:
    // you can access private fields of other instances belonging
    // to the same class.
    return this.#values[0] - anotherColor.#values[0];
  }
}

const red = new Color(255, 0, 0);
const crimson = new Color(220, 20, 60);
red.redDifference(crimson); // 35

However, if anotherColor is not a Color instance, #values won't exist. (Even if another class has an identically named #values private field, it's not referring to the same thing and cannot be accessed here.) Accessing a nonexistent private property throws an error instead of returning undefined like normal properties do. If you don't know if a private field exists on an object and you wish to access it without using try/catch to handle the error, you can use the in operator.
jsclass Color {
  #values;
  constructor(r, g, b) {
    this.#values = [r, g, b];
  }
  redDifference(anotherColor) {
    if (!(#values in anotherColor)) {
      throw new TypeError("Color instance expected");
    }
    return this.#values[0] - anotherColor.#values[0];
  }
}


Note:
Keep in mind that the # is a special identifier syntax, and you can't use the field name as if it's a string. "#values" in anotherColor would look for a property name literally called "#values", instead of a private field.

There are some limitations in using private properties: the same name can't be declared twice in a single class, and they can't be deleted. Both lead to early syntax errors.
jsclass BadIdeas {
  #firstName;
  #firstName; // syntax error occurs here
  #lastName;
  constructor() {
    delete this.#lastName; // also a syntax error
  }
}

Methods, getters, and setters can be private as well. They're useful when you have something complex that the class needs to do internally but no other part of the code should be allowed to call.
For example, imagine creating HTML custom elements that should do something somewhat complicated when clicked/tapped/otherwise activated. Furthermore, the somewhat complicated things that happen when the element is clicked should be restricted to this class, because no other part of the JavaScript will (or should) ever access it.
jsclass Counter extends HTMLElement {
  #xValue = 0;
  constructor() {
    super();
    this.onclick = this.#clicked.bind(this);
  }
  get #x() {
    return this.#xValue;
  }
  set #x(value) {
    this.#xValue = value;
    window.requestAnimationFrame(this.#render.bind(this));
  }
  #clicked() {
    this.#x++;
  }
  #render() {
    this.textContent = this.#x.toString();
  }
  connectedCallback() {
    this.#render();
  }
}

customElements.define("num-counter", Counter);

In this case, pretty much every field and method is private to the class. Thus, it presents an interface to the rest of the code that's essentially just like a built-in HTML element. No other part of the program has the power to affect any of the internals of Counter.Accessor fieldscolor.getRed() and color.setRed() allow us to read and write to the red value of a color. If you come from languages like Java, you will be very familiar with this pattern. However, using methods to simply access a property is still somewhat unergonomic in JavaScript. Accessor fields allow us to manipulate something as if it is an "actual property".
jsclass Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
  get red() {
    return this.values[0];
  }
  set red(value) {
    this.values[0] = value;
  }
}

const red = new Color(255, 0, 0);
red.red = 0;
console.log(red.red); // 0

It looks as if the object has a property called red — but actually, no such property exists on the instance! There are only two methods, but they are prefixed with get and set, which allows them to be manipulated as if they were properties.
If a field only has a getter but no setter, it will be effectively read-only.
jsclass Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
  get red() {
    return this.values[0];
  }
}

const red = new Color(255, 0, 0);
red.red = 0;
console.log(red.red); // 255

In strict mode, the red.red = 0 line will throw a type error: "Cannot set property red of #<Color> which has only a getter". In non-strict mode, the assignment is silently ignored.Public fieldsPrivate fields also have their public counterparts, which allow every instance to have a property. Fields are usually designed to be independent of the constructor's parameters.
jsclass MyClass {
  luckyNumber = Math.random();
}
console.log(new MyClass().luckyNumber); // 0.5
console.log(new MyClass().luckyNumber); // 0.3

Public fields are almost equivalent to assigning a property to this. For example, the above example can also be converted to:
jsclass MyClass {
  constructor() {
    this.luckyNumber = Math.random();
  }
}
Static propertiesWith the Date example, we have also encountered the Date.now() method, which returns the current date. This method does not belong to any date instance — it belongs to the class itself. However, it's put on the Date class instead of being exposed as a global DateNow() function, because it's mostly useful when dealing with date instances.

Note:
Prefixing utility methods with what they deal with is called "namespacing" and is considered a good practice. For example, in addition to the older, unprefixed parseInt() method, JavaScript also later added the prefixed Number.parseInt() method to indicate that it's for dealing with numbers.

Static properties are a group of class features that are defined on the class itself, rather than on individual instances of the class. These features include:

Static methods
Static fields
Static getters and setters

Everything also has private counterparts. For example, for our Color class, we can create a static method that checks whether a given triplet is a valid RGB value:
jsclass Color {
  static isValid(r, g, b) {
    return r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255;
  }
}

Color.isValid(255, 0, 0); // true
Color.isValid(1000, 0, 0); // false

Static properties are very similar to their instance counterparts, except that:

They are all prefixed with static, and
They are not accessible from instances.

jsconsole.log(new Color(0, 0, 0).isValid); // undefined

There is also a special construct called a static initialization block, which is a block of code that runs when the class is first loaded.
jsclass MyClass {
  static {
    MyClass.myStaticProperty = "foo";
  }
}

console.log(MyClass.myStaticProperty); // 'foo'

Static initialization blocks are almost equivalent to immediately executing some code after a class has been declared. The only difference is that they have access to static private properties.Extends and inheritanceA key feature that classes bring about (in addition to ergonomic encapsulation with private fields) is inheritance, which means one object can "borrow" a large part of another object's behaviors, while overriding or enhancing certain parts with its own logic.
For example, suppose our Color class now needs to support transparency. We may be tempted to add a new field that indicates its transparency:
jsclass Color {
  #values;
  constructor(r, g, b, a = 1) {
    this.#values = [r, g, b, a];
  }
  get alpha() {
    return this.#values[3];
  }
  set alpha(value) {
    if (value < 0 || value > 1) {
      throw new RangeError("Alpha value must be between 0 and 1");
    }
    this.#values[3] = value;
  }
}

However, this means every instance — even the vast majority which aren't transparent (those with an alpha value of 1) — will have to have the extra alpha value, which is not very elegant. Plus, if the features keep growing, our Color class will become very bloated and hard to maintain.
Instead, in object-oriented programming, we would create a derived class. The derived class has access to all public properties of the parent class. In JavaScript, derived classes are declared with an extends clause, which indicates the class it extends from.
jsclass ColorWithAlpha extends Color {
  #alpha;
  constructor(r, g, b, a) {
    super(r, g, b);
    this.#alpha = a;
  }
  get alpha() {
    return this.#alpha;
  }
  set alpha(value) {
    if (value < 0 || value > 1) {
      throw new RangeError("Alpha value must be between 0 and 1");
    }
    this.#alpha = value;
  }
}

There are a few things that have immediately come to attention. First is that in the constructor, we are calling super(r, g, b). It is a language requirement to call super() before accessing this. The super() call calls the parent class's constructor to initialize this — here it's roughly equivalent to this = new Color(r, g, b). You can have code before super(), but you cannot access this before super() — the language prevents you from accessing the uninitialized this.
After the parent class is done with modifying this, the derived class can do its own logic. Here we added a private field called #alpha, and also provided a pair of getter/setters to interact with them.
A derived class inherits all methods from its parent. For example, although ColorWithAlpha doesn't declare a get red() accessor itself, you can still access red because this behavior is specified by the parent class:
jsconst color = new ColorWithAlpha(255, 0, 0, 0.5);
console.log(color.red); // 255

Derived classes can also override methods from the parent class. For example, all classes implicitly inherit the Object class, which defines some basic methods like toString(). However, the base toString() method is notoriously useless, because it prints [object Object] in most cases:
jsconsole.log(red.toString()); // [object Object]

Instead, our class can override it to print the color's RGB values:
jsclass Color {
  #values;
  // …
  toString() {
    return this.#values.join(", ");
  }
}

console.log(new Color(255, 0, 0).toString()); // '255, 0, 0'

Within derived classes, you can access the parent class's methods by using super. This allows you to build enhancement methods and avoid code duplication.
jsclass ColorWithAlpha extends Color {
  #alpha;
  // …
  toString() {
    // Call the parent class's toString() and build on the return value
    return `${super.toString()}, ${this.#alpha}`;
  }
}

console.log(new ColorWithAlpha(255, 0, 0, 0.5).toString()); // '255, 0, 0, 0.5'

When you use extends, the static methods inherit from each other as well, so you can also override or enhance them.
jsclass ColorWithAlpha extends Color {
  // ...
  static isValid(r, g, b, a) {
    // Call the parent class's isValid() and build on the return value
    return super.isValid(r, g, b) && a >= 0 && a <= 1;
  }
}

console.log(ColorWithAlpha.isValid(255, 0, 0, -1)); // false

Derived classes don't have access to the parent class's private fields — this is another key aspect to JavaScript private fields being "hard private". Private fields are scoped to the class body itself and do not grant access to any outside code.
jsclass ColorWithAlpha extends Color {
  log() {
    console.log(this.#values); // SyntaxError: Private field '#values' must be declared in an enclosing class
  }
}

A class can only extend from one class. This prevents problems in multiple inheritance like the diamond problem. However, due to the dynamic nature of JavaScript, it's still possible to achieve the effect of multiple inheritance through class composition and mixins.
Instances of derived classes are also instances of the base class.
jsconst color = new ColorWithAlpha(255, 0, 0, 0.5);
console.log(color instanceof Color); // true
console.log(color instanceof ColorWithAlpha); // true
Why classes?The guide has been pragmatic so far: we are focusing on how classes can be used, but there's one question unanswered: why would one use a class? The answer is: it depends.
Classes introduce a paradigm, or a way to organize your code. Classes are the foundations of object-oriented programming, which is built on concepts like inheritance and polymorphism (especially subtype polymorphism). However, many people are philosophically against certain OOP practices and don't use classes as a result.
For example, one thing that makes Date objects infamous is that they're mutable.
jsfunction incrementDay(date) {
  return date.setDate(date.getDate() + 1);
}
const date = new Date(); // 2019-06-19
const newDay = incrementDay(date);
console.log(newDay); // 2019-06-20
// The old date is modified as well!?
console.log(date); // 2019-06-20

Mutability and internal state are important aspects of object-oriented programming, but often make code hard to reason with — because any seemingly innocent operation may have unexpected side effects and change the behavior in other parts of the program.
In order to reuse code, we usually resort to extending classes, which can create big hierarchies of inheritance patterns.

However, it is often hard to describe inheritance cleanly when one class can only extend one other class. Often, we want the behavior of multiple classes. In Java, this is done through interfaces; in JavaScript, it can be done through mixins. But at the end of the day, it's still not very convenient.
On the brighter side, classes are a very powerful way to organize our code on a higher level. For example, without the Color class, we may need to create a dozen of utility functions:
jsfunction isRed(color) {
  return color.red === 255;
}
function isValidColor(color) {
  return (
    color.red >= 0 &&
    color.red <= 255 &&
    color.green >= 0 &&
    color.green <= 255 &&
    color.blue >= 0 &&
    color.blue <= 255
  );
}
// ...

But with classes, we can congregate them all under the Color namespace, which improves readability. In addition, the introduction of private fields allows us to hide certain data from downstream users, creating a clean API.
In general, you should consider using classes when you want to create objects that store their own internal data and expose a lot of behavior. Take built-in JavaScript classes as examples:

The Map and Set classes store a collection of elements and allow you to access them by key using get(), set(), has(), etc.
The Date class stores a date as a Unix timestamp (a number) and allows you to format, update, and read individual date components.
The Error class stores information about a particular exception, including the error message, stack trace, cause, etc. It's one of the few classes that come with a rich inheritance structure: there are multiple built-in classes like TypeError and ReferenceError that extend Error. In the case of errors, this inheritance allows refining the semantics of errors: each error class represents a specific type of error, which can be easily checked with instanceof.

JavaScript offers the mechanism to organize your code in a canonical object-oriented way, but whether and how to use it is entirely up to the programmer's discretion.
 Previous  Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nUsing promises Previous  Next  
A Promise is an object representing the eventual completion or failure of an asynchronous operation. Since most people are consumers of already-created promises, this guide will explain consumption of returned promises before explaining how to create them.
Essentially, a promise is a returned object to which you attach callbacks, instead of passing callbacks into a function. Imagine a function, createAudioFileAsync(), which asynchronously generates a sound file given a configuration record and two callback functions: one called if the audio file is successfully created, and the other called if an error occurs.
Here's some code that uses createAudioFileAsync():
jsfunction successCallback(result) {
  console.log(`Audio file ready at URL: ${result}`);
}

function failureCallback(error) {
  console.error(`Error generating audio file: ${error}`);
}

createAudioFileAsync(audioSettings, successCallback, failureCallback);

If createAudioFileAsync() were rewritten to return a promise, you would attach your callbacks to it instead:
jscreateAudioFileAsync(audioSettings).then(successCallback, failureCallback);

This convention has several advantages. We will explore each one.ChainingA common need is to execute two or more asynchronous operations back to back, where each subsequent operation starts when the previous operation succeeds, with the result from the previous step. In the old days, doing several asynchronous operations in a row would lead to the classic callback hell:
jsdoSomething(function (result) {
  doSomethingElse(result, function (newResult) {
    doThirdThing(newResult, function (finalResult) {
      console.log(`Got the final result: ${finalResult}`);
    }, failureCallback);
  }, failureCallback);
}, failureCallback);

With promises, we accomplish this by creating a promise chain. The API design of promises makes this great, because callbacks are attached to the returned promise object, instead of being passed into a function.
Here's the magic: the then() function returns a new promise, different from the original:
jsconst promise = doSomething();
const promise2 = promise.then(successCallback, failureCallback);

This second promise (promise2) represents the completion not just of doSomething(), but also of the successCallback or failureCallback you passed in — which can be other asynchronous functions returning a promise. When that's the case, any callbacks added to promise2 get queued behind the promise returned by either successCallback or failureCallback.

Note:
If you want a working example to play with, you can use the following template to create any function returning a promise:
jsfunction doSomething() {
  return new Promise((resolve) => {
    setTimeout(() => {
      // Other things to do before completion of the promise
      console.log("Did something");
      // The fulfillment value of the promise
      resolve("https://example.com/");
    }, 200);
  });
}

The implementation is discussed in the Creating a Promise around an old callback API section below.

With this pattern, you can create longer chains of processing, where each promise represents the completion of one asynchronous step in the chain. In addition, the arguments to then are optional, and catch(failureCallback) is short for then(null, failureCallback) — so if your error handling code is the same for all steps, you can attach it to the end of the chain:
jsdoSomething()
  .then(function (result) {
    return doSomethingElse(result);
  })
  .then(function (newResult) {
    return doThirdThing(newResult);
  })
  .then(function (finalResult) {
    console.log(`Got the final result: ${finalResult}`);
  })
  .catch(failureCallback);

You might see this expressed with arrow functions instead:
jsdoSomething()
  .then((result) => doSomethingElse(result))
  .then((newResult) => doThirdThing(newResult))
  .then((finalResult) => {
    console.log(`Got the final result: ${finalResult}`);
  })
  .catch(failureCallback);


Note:
Arrow function expressions can have an implicit return; so, () => x is short for () => { return x; }.

doSomethingElse and doThirdThing can return any value — if they return promises, that promise is first waited until it settles, and the next callback receives the fulfillment value, not the promise itself. It is important to always return promises from then callbacks, even if the promise always resolves to undefined. If the previous handler started a promise but did not return it, there's no way to track its settlement anymore, and the promise is said to be "floating".
jsdoSomething()
  .then((url) => {
    // Missing `return` keyword in front of fetch(url).
    fetch(url);
  })
  .then((result) => {
    // result is undefined, because nothing is returned from the previous
    // handler. There's no way to know the return value of the fetch()
    // call anymore, or whether it succeeded at all.
  });

By returning the result of the fetch call (which is a promise), we can both track its completion and receive its value when it completes.
jsdoSomething()
  .then((url) => {
    // `return` keyword added
    return fetch(url);
  })
  .then((result) => {
    // result is a Response object
  });

Floating promises could be worse if you have race conditions — if the promise from the last handler is not returned, the next then handler will be called early, and any value it reads may be incomplete.
jsconst listOfIngredients = [];

doSomething()
  .then((url) => {
    // Missing `return` keyword in front of fetch(url).
    fetch(url)
      .then((res) => res.json())
      .then((data) => {
        listOfIngredients.push(data);
      });
  })
  .then(() => {
    console.log(listOfIngredients);
    // listOfIngredients will always be [], because the fetch request hasn't completed yet.
  });

Therefore, as a rule of thumb, whenever your operation encounters a promise, return it and defer its handling to the next then handler.
jsconst listOfIngredients = [];

doSomething()
  .then((url) => {
    // `return` keyword now included in front of fetch call.
    return fetch(url)
      .then((res) => res.json())
      .then((data) => {
        listOfIngredients.push(data);
      });
  })
  .then(() => {
    console.log(listOfIngredients);
    // listOfIngredients will now contain data from fetch call.
  });

Even better, you can flatten the nested chain into a single chain, which is simpler and makes error handling easier. The details are discussed in the Nesting section below.
jsdoSomething()
  .then((url) => fetch(url))
  .then((res) => res.json())
  .then((data) => {
    listOfIngredients.push(data);
  })
  .then(() => {
    console.log(listOfIngredients);
  });

Using async/await can help you write code that's more intuitive and resembles synchronous code. Below is the same example using async/await:
jsasync function logIngredients() {
  const url = await doSomething();
  const res = await fetch(url);
  const data = await res.json();
  listOfIngredients.push(data);
  console.log(listOfIngredients);
}

Note how the code looks exactly like synchronous code, except for the await keywords in front of promises. One of the only tradeoffs is that it may be easy to forget the await keyword, which can only be fixed when there's a type mismatch (e.g., trying to use a promise as a value).
async/await builds on promises — for example, doSomething() is the same function as before, so there's minimal refactoring needed to change from promises to async/await. You can read more about the async/await syntax in the async functions and await references.

Note: async/await has the same concurrency semantics as normal promise chains. await within one async function does not stop the entire program, only the parts that depend on its value, so other async jobs can still run while the await is pending.
Error handlingYou might recall seeing failureCallback three times in the pyramid of doom earlier, compared to only once at the end of the promise chain:
jsdoSomething()
  .then((result) => doSomethingElse(result))
  .then((newResult) => doThirdThing(newResult))
  .then((finalResult) => console.log(`Got the final result: ${finalResult}`))
  .catch(failureCallback);

If there's an exception, the browser will look down the chain for .catch() handlers or onRejected. This is very much modeled after how synchronous code works:
jstry {
  const result = syncDoSomething();
  const newResult = syncDoSomethingElse(result);
  const finalResult = syncDoThirdThing(newResult);
  console.log(`Got the final result: ${finalResult}`);
} catch (error) {
  failureCallback(error);
}

This symmetry with asynchronous code culminates in the async/await syntax:
jsasync function foo() {
  try {
    const result = await doSomething();
    const newResult = await doSomethingElse(result);
    const finalResult = await doThirdThing(newResult);
    console.log(`Got the final result: ${finalResult}`);
  } catch (error) {
    failureCallback(error);
  }
}

Promises solve a fundamental flaw with the callback pyramid of doom, by catching all errors, even thrown exceptions and programming errors. This is essential for functional composition of asynchronous operations. All errors are now handled by the catch() method at the end of the chain, and you should almost never need to use try/catch without using async/await.NestingIn the examples above involving listOfIngredients, the first one has one promise chain nested in the return value of another then() handler, while the second one uses an entirely flat chain. Simple promise chains are best kept flat without nesting, as nesting can be a result of careless composition.
Nesting is a control structure to limit the scope of catch statements. Specifically, a nested catch only catches failures in its scope and below, not errors higher up in the chain outside the nested scope. When used correctly, this gives greater precision in error recovery:
jsdoSomethingCritical()
  .then((result) =>
    doSomethingOptional(result)
      .then((optionalResult) => doSomethingExtraNice(optionalResult))
      .catch((e) => {}),
  ) // Ignore if optional stuff fails; proceed.
  .then(() => moreCriticalStuff())
  .catch((e) => console.error(`Critical failure: ${e.message}`));

Note that the optional steps here are nested — with the nesting caused not by the indentation, but by the placement of the outer ( and ) parentheses around the steps.
The inner error-silencing catch handler only catches failures from doSomethingOptional() and doSomethingExtraNice(), after which the code resumes with moreCriticalStuff(). Importantly, if doSomethingCritical() fails, its error is caught by the final (outer) catch only, and does not get swallowed by the inner catch handler.
In async/await, this code looks like:
jsasync function main() {
  try {
    const result = await doSomethingCritical();
    try {
      const optionalResult = await doSomethingOptional(result);
      await doSomethingExtraNice(optionalResult);
    } catch (e) {
      // Ignore failures in optional steps and proceed.
    }
    await moreCriticalStuff();
  } catch (e) {
    console.error(`Critical failure: ${e.message}`);
  }
}


Note:
If you don't have sophisticated error handling, you very likely don't need nested then handlers. Instead, use a flat chain and put the error handling logic at the end.
Chaining after a catchIt's possible to chain after a failure, i.e., a catch, which is useful to accomplish new actions even after an action failed in the chain. Read the following example:
jsdoSomething()
  .then(() => {
    throw new Error("Something failed");

    console.log("Do this");
  })
  .catch(() => {
    console.error("Do that");
  })
  .then(() => {
    console.log("Do this, no matter what happened before");
  });

This will output the following text:
Initial
Do that
Do this, no matter what happened before


Note:
The text "Do this" is not displayed because the "Something failed" error caused a rejection.

In async/await, this code looks like:
jsasync function main() {
  try {
    await doSomething();
    throw new Error("Something failed");
    console.log("Do this");
  } catch (e) {
    console.error("Do that");
  }
  console.log("Do this, no matter what happened before");
}
Promise rejection eventsIf a promise rejection event is not handled by any handler, it bubbles to the top of the call stack, and the host needs to surface it. On the web, whenever a promise is rejected, one of two events is sent to the global scope (generally, this is either the window or, if being used in a web worker, it's the Worker or other worker-based interface). The two events are:

unhandledrejection

Sent when a promise is rejected but there is no rejection handler available.

rejectionhandled

Sent when a handler is attached to a rejected promise that has already caused an unhandledrejection event.


In both cases, the event (of type PromiseRejectionEvent) has as members a promise property indicating the promise that was rejected, and a reason property that provides the reason given for the promise to be rejected.
These make it possible to offer fallback error handling for promises, as well as to help debug issues with your promise management. These handlers are global per context, so all errors will go to the same event handlers, regardless of source.
In Node.js, handling promise rejection is slightly different. You capture unhandled rejections by adding a handler for the Node.js unhandledRejection event (notice the difference in capitalization of the name), like this:
jsprocess.on("unhandledRejection", (reason, promise) => {
  // Add code here to examine the "promise" and "reason" values
});

For Node.js, to prevent the error from being logged to the console (the default action that would otherwise occur), adding that process.on() listener is all that's necessary; there's no need for an equivalent of the browser runtime's preventDefault() method.
However, if you add that process.on listener but don't also have code within it to handle rejected promises, they will just be dropped on the floor and silently ignored. So ideally, you should add code within that listener to examine each rejected promise and make sure it was not caused by an actual code bug.CompositionThere are four composition tools for running asynchronous operations concurrently: Promise.all(), Promise.allSettled(), Promise.any(), and Promise.race().
We can start operations at the same time and wait for them all to finish like this:
jsPromise.all([func1(), func2(), func3()]).then(([result1, result2, result3]) => {
  // use result1, result2 and result3
});

If one of the promises in the array rejects, Promise.all() immediately rejects the returned promise and aborts the other operations. This may cause unexpected state or behavior. Promise.allSettled() is another composition tool that ensures all operations are complete before resolving.
These methods all run promises concurrently — a sequence of promises are started simultaneously and do not wait for each other. Sequential composition is possible using some clever JavaScript:
js[func1, func2, func3]
  .reduce((p, f) => p.then(f), Promise.resolve())
  .then((result3) => {
    /* use result3 */
  });

In this example, we reduce an array of asynchronous functions down to a promise chain. The code above is equivalent to:
jsPromise.resolve()
  .then(func1)
  .then(func2)
  .then(func3)
  .then((result3) => {
    /* use result3 */
  });

This can be made into a reusable compose function, which is common in functional programming:
jsconst applyAsync = (acc, val) => acc.then(val);
const composeAsync =
  (...funcs) =>
  (x) =>
    funcs.reduce(applyAsync, Promise.resolve(x));

The composeAsync() function accepts any number of functions as arguments and returns a new function that accepts an initial value to be passed through the composition pipeline:
jsconst transformData = composeAsync(func1, func2, func3);
const result3 = transformData(data);

Sequential composition can also be done more succinctly with async/await:
jslet result;
for (const f of [func1, func2, func3]) {
  result = await f(result);
}
/* use last result (i.e. result3) */

However, before you compose promises sequentially, consider if it's really necessary — it's always better to run promises concurrently so that they don't unnecessarily block each other unless one promise's execution depends on another's result.CancellationPromise itself has no first-class protocol for cancellation, but you may be able to directly cancel the underlying asynchronous operation, typically using AbortController.Creating a Promise around an old callback APIA Promise can be created from scratch using its constructor. This should be needed only to wrap old APIs.
In an ideal world, all asynchronous functions would already return promises. Unfortunately, some APIs still expect success and/or failure callbacks to be passed in the old way. The most obvious example is the setTimeout() function:
jssetTimeout(() => saySomething("10 seconds passed"), 10 * 1000);

Mixing old-style callbacks and promises is problematic. If saySomething() fails or contains a programming error, nothing catches it. This is intrinsic to the design of setTimeout().
Luckily we can wrap setTimeout() in a promise. The best practice is to wrap the callback-accepting functions at the lowest possible level, and then never call them directly again:
jsconst wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

wait(10 * 1000)
  .then(() => saySomething("10 seconds"))
  .catch(failureCallback);

The promise constructor takes an executor function that lets us resolve or reject a promise manually. Since setTimeout() doesn't really fail, we left out reject in this case. For more information on how the executor function works, see the Promise() reference.TimingLastly, we will look into the more technical details, about when the registered callbacks get called.GuaranteesIn the callback-based API, when and how the callback gets called depends on the API implementor. For example, the callback may be called synchronously or asynchronously:
jsfunction doSomething(callback) {
  if (Math.random() > 0.5) {
    callback();
  } else {
    setTimeout(() => callback(), 1000);
  }
}

The above design is strongly discouraged because it leads to the so-called "state of Zalgo". In the context of designing asynchronous APIs, this means a callback is called synchronously in some cases but asynchronously in other cases, creating ambiguity for the caller. For further background, see the article Designing APIs for Asynchrony, where the term was first formally presented. This API design makes side effects hard to analyze:
jslet value = 1;
doSomething(() => {
  value = 2;
});
console.log(value); // 1 or 2?

On the other hand, promises are a form of inversion of control — the API implementor does not control when the callback gets called. Instead, the job of maintaining the callback queue and deciding when to call the callbacks is delegated to the promise implementation, and both the API user and API developer automatically gets strong semantic guarantees, including:

Callbacks added with then() will never be invoked before the completion of the current run of the JavaScript event loop.
These callbacks will be invoked even if they were added after the success or failure of the asynchronous operation that the promise represents.
Multiple callbacks may be added by calling then() several times. They will be invoked one after another, in the order in which they were inserted.

To avoid surprises, functions passed to then() will never be called synchronously, even with an already-resolved promise:
jsPromise.resolve().then(() => console.log(2));
console.log(1);
// Logs: 1, 2

Instead of running immediately, the passed-in function is put on a microtask queue, which means it runs later (only after the function which created it exits, and when the JavaScript execution stack is empty), just before control is returned to the event loop; i.e., pretty soon:
jsconst wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

wait(0).then(() => console.log(4));
Promise.resolve()
  .then(() => console.log(2))
  .then(() => console.log(3));
console.log(1); // 1, 2, 3, 4
Task queues vs. microtasksPromise callbacks are handled as a microtask whereas setTimeout() callbacks are handled as task queues.
jsconst promise = new Promise((resolve, reject) => {
  console.log("Promise callback");
  resolve();
}).then((result) => {
  console.log("Promise callback (.then)");
});

setTimeout(() => {
  console.log("event-loop cycle: Promise (fulfilled)", promise);
}, 0);

console.log("Promise (pending)", promise);

The code above will output:
Promise callback
Promise (pending) Promise {<pending>}
Promise callback (.then)
event-loop cycle: Promise (fulfilled) Promise {<fulfilled>}

For more details, refer to Tasks vs. microtasks.When promises and tasks collideIf you run into situations in which you have promises and tasks (such as events or callbacks) which are firing in unpredictable orders, it's possible you may benefit from using a microtask to check status or balance out your promises when promises are created conditionally.
If you think microtasks may help solve this problem, see the microtask guide to learn more about how to use queueMicrotask() to enqueue a function as a microtask.See also
Promise
async function
await
Promises/A+ specification
We have a problem with promises on pouchdb.com (2015)

 Previous  Next\n\nUsing promises Previous  Next  
A Promise is an object representing the eventual completion or failure of an asynchronous operation. Since most people are consumers of already-created promises, this guide will explain consumption of returned promises before explaining how to create them.
Essentially, a promise is a returned object to which you attach callbacks, instead of passing callbacks into a function. Imagine a function, createAudioFileAsync(), which asynchronously generates a sound file given a configuration record and two callback functions: one called if the audio file is successfully created, and the other called if an error occurs.
Here's some code that uses createAudioFileAsync():
jsfunction successCallback(result) {
  console.log(`Audio file ready at URL: ${result}`);
}

function failureCallback(error) {
  console.error(`Error generating audio file: ${error}`);
}

createAudioFileAsync(audioSettings, successCallback, failureCallback);

If createAudioFileAsync() were rewritten to return a promise, you would attach your callbacks to it instead:
jscreateAudioFileAsync(audioSettings).then(successCallback, failureCallback);

This convention has several advantages. We will explore each one.ChainingA common need is to execute two or more asynchronous operations back to back, where each subsequent operation starts when the previous operation succeeds, with the result from the previous step. In the old days, doing several asynchronous operations in a row would lead to the classic callback hell:
jsdoSomething(function (result) {
  doSomethingElse(result, function (newResult) {
    doThirdThing(newResult, function (finalResult) {
      console.log(`Got the final result: ${finalResult}`);
    }, failureCallback);
  }, failureCallback);
}, failureCallback);

With promises, we accomplish this by creating a promise chain. The API design of promises makes this great, because callbacks are attached to the returned promise object, instead of being passed into a function.
Here's the magic: the then() function returns a new promise, different from the original:
jsconst promise = doSomething();
const promise2 = promise.then(successCallback, failureCallback);

This second promise (promise2) represents the completion not just of doSomething(), but also of the successCallback or failureCallback you passed in — which can be other asynchronous functions returning a promise. When that's the case, any callbacks added to promise2 get queued behind the promise returned by either successCallback or failureCallback.

Note:
If you want a working example to play with, you can use the following template to create any function returning a promise:
jsfunction doSomething() {
  return new Promise((resolve) => {
    setTimeout(() => {
      // Other things to do before completion of the promise
      console.log("Did something");
      // The fulfillment value of the promise
      resolve("https://example.com/");
    }, 200);
  });
}

The implementation is discussed in the Creating a Promise around an old callback API section below.

With this pattern, you can create longer chains of processing, where each promise represents the completion of one asynchronous step in the chain. In addition, the arguments to then are optional, and catch(failureCallback) is short for then(null, failureCallback) — so if your error handling code is the same for all steps, you can attach it to the end of the chain:
jsdoSomething()
  .then(function (result) {
    return doSomethingElse(result);
  })
  .then(function (newResult) {
    return doThirdThing(newResult);
  })
  .then(function (finalResult) {
    console.log(`Got the final result: ${finalResult}`);
  })
  .catch(failureCallback);

You might see this expressed with arrow functions instead:
jsdoSomething()
  .then((result) => doSomethingElse(result))
  .then((newResult) => doThirdThing(newResult))
  .then((finalResult) => {
    console.log(`Got the final result: ${finalResult}`);
  })
  .catch(failureCallback);


Note:
Arrow function expressions can have an implicit return; so, () => x is short for () => { return x; }.

doSomethingElse and doThirdThing can return any value — if they return promises, that promise is first waited until it settles, and the next callback receives the fulfillment value, not the promise itself. It is important to always return promises from then callbacks, even if the promise always resolves to undefined. If the previous handler started a promise but did not return it, there's no way to track its settlement anymore, and the promise is said to be "floating".
jsdoSomething()
  .then((url) => {
    // Missing `return` keyword in front of fetch(url).
    fetch(url);
  })
  .then((result) => {
    // result is undefined, because nothing is returned from the previous
    // handler. There's no way to know the return value of the fetch()
    // call anymore, or whether it succeeded at all.
  });

By returning the result of the fetch call (which is a promise), we can both track its completion and receive its value when it completes.
jsdoSomething()
  .then((url) => {
    // `return` keyword added
    return fetch(url);
  })
  .then((result) => {
    // result is a Response object
  });

Floating promises could be worse if you have race conditions — if the promise from the last handler is not returned, the next then handler will be called early, and any value it reads may be incomplete.
jsconst listOfIngredients = [];

doSomething()
  .then((url) => {
    // Missing `return` keyword in front of fetch(url).
    fetch(url)
      .then((res) => res.json())
      .then((data) => {
        listOfIngredients.push(data);
      });
  })
  .then(() => {
    console.log(listOfIngredients);
    // listOfIngredients will always be [], because the fetch request hasn't completed yet.
  });

Therefore, as a rule of thumb, whenever your operation encounters a promise, return it and defer its handling to the next then handler.
jsconst listOfIngredients = [];

doSomething()
  .then((url) => {
    // `return` keyword now included in front of fetch call.
    return fetch(url)
      .then((res) => res.json())
      .then((data) => {
        listOfIngredients.push(data);
      });
  })
  .then(() => {
    console.log(listOfIngredients);
    // listOfIngredients will now contain data from fetch call.
  });

Even better, you can flatten the nested chain into a single chain, which is simpler and makes error handling easier. The details are discussed in the Nesting section below.
jsdoSomething()
  .then((url) => fetch(url))
  .then((res) => res.json())
  .then((data) => {
    listOfIngredients.push(data);
  })
  .then(() => {
    console.log(listOfIngredients);
  });

Using async/await can help you write code that's more intuitive and resembles synchronous code. Below is the same example using async/await:
jsasync function logIngredients() {
  const url = await doSomething();
  const res = await fetch(url);
  const data = await res.json();
  listOfIngredients.push(data);
  console.log(listOfIngredients);
}

Note how the code looks exactly like synchronous code, except for the await keywords in front of promises. One of the only tradeoffs is that it may be easy to forget the await keyword, which can only be fixed when there's a type mismatch (e.g., trying to use a promise as a value).
async/await builds on promises — for example, doSomething() is the same function as before, so there's minimal refactoring needed to change from promises to async/await. You can read more about the async/await syntax in the async functions and await references.

Note: async/await has the same concurrency semantics as normal promise chains. await within one async function does not stop the entire program, only the parts that depend on its value, so other async jobs can still run while the await is pending.
Error handlingYou might recall seeing failureCallback three times in the pyramid of doom earlier, compared to only once at the end of the promise chain:
jsdoSomething()
  .then((result) => doSomethingElse(result))
  .then((newResult) => doThirdThing(newResult))
  .then((finalResult) => console.log(`Got the final result: ${finalResult}`))
  .catch(failureCallback);

If there's an exception, the browser will look down the chain for .catch() handlers or onRejected. This is very much modeled after how synchronous code works:
jstry {
  const result = syncDoSomething();
  const newResult = syncDoSomethingElse(result);
  const finalResult = syncDoThirdThing(newResult);
  console.log(`Got the final result: ${finalResult}`);
} catch (error) {
  failureCallback(error);
}

This symmetry with asynchronous code culminates in the async/await syntax:
jsasync function foo() {
  try {
    const result = await doSomething();
    const newResult = await doSomethingElse(result);
    const finalResult = await doThirdThing(newResult);
    console.log(`Got the final result: ${finalResult}`);
  } catch (error) {
    failureCallback(error);
  }
}

Promises solve a fundamental flaw with the callback pyramid of doom, by catching all errors, even thrown exceptions and programming errors. This is essential for functional composition of asynchronous operations. All errors are now handled by the catch() method at the end of the chain, and you should almost never need to use try/catch without using async/await.NestingIn the examples above involving listOfIngredients, the first one has one promise chain nested in the return value of another then() handler, while the second one uses an entirely flat chain. Simple promise chains are best kept flat without nesting, as nesting can be a result of careless composition.
Nesting is a control structure to limit the scope of catch statements. Specifically, a nested catch only catches failures in its scope and below, not errors higher up in the chain outside the nested scope. When used correctly, this gives greater precision in error recovery:
jsdoSomethingCritical()
  .then((result) =>
    doSomethingOptional(result)
      .then((optionalResult) => doSomethingExtraNice(optionalResult))
      .catch((e) => {}),
  ) // Ignore if optional stuff fails; proceed.
  .then(() => moreCriticalStuff())
  .catch((e) => console.error(`Critical failure: ${e.message}`));

Note that the optional steps here are nested — with the nesting caused not by the indentation, but by the placement of the outer ( and ) parentheses around the steps.
The inner error-silencing catch handler only catches failures from doSomethingOptional() and doSomethingExtraNice(), after which the code resumes with moreCriticalStuff(). Importantly, if doSomethingCritical() fails, its error is caught by the final (outer) catch only, and does not get swallowed by the inner catch handler.
In async/await, this code looks like:
jsasync function main() {
  try {
    const result = await doSomethingCritical();
    try {
      const optionalResult = await doSomethingOptional(result);
      await doSomethingExtraNice(optionalResult);
    } catch (e) {
      // Ignore failures in optional steps and proceed.
    }
    await moreCriticalStuff();
  } catch (e) {
    console.error(`Critical failure: ${e.message}`);
  }
}


Note:
If you don't have sophisticated error handling, you very likely don't need nested then handlers. Instead, use a flat chain and put the error handling logic at the end.
Chaining after a catchIt's possible to chain after a failure, i.e., a catch, which is useful to accomplish new actions even after an action failed in the chain. Read the following example:
jsdoSomething()
  .then(() => {
    throw new Error("Something failed");

    console.log("Do this");
  })
  .catch(() => {
    console.error("Do that");
  })
  .then(() => {
    console.log("Do this, no matter what happened before");
  });

This will output the following text:
Initial
Do that
Do this, no matter what happened before


Note:
The text "Do this" is not displayed because the "Something failed" error caused a rejection.

In async/await, this code looks like:
jsasync function main() {
  try {
    await doSomething();
    throw new Error("Something failed");
    console.log("Do this");
  } catch (e) {
    console.error("Do that");
  }
  console.log("Do this, no matter what happened before");
}
Promise rejection eventsIf a promise rejection event is not handled by any handler, it bubbles to the top of the call stack, and the host needs to surface it. On the web, whenever a promise is rejected, one of two events is sent to the global scope (generally, this is either the window or, if being used in a web worker, it's the Worker or other worker-based interface). The two events are:

unhandledrejection

Sent when a promise is rejected but there is no rejection handler available.

rejectionhandled

Sent when a handler is attached to a rejected promise that has already caused an unhandledrejection event.


In both cases, the event (of type PromiseRejectionEvent) has as members a promise property indicating the promise that was rejected, and a reason property that provides the reason given for the promise to be rejected.
These make it possible to offer fallback error handling for promises, as well as to help debug issues with your promise management. These handlers are global per context, so all errors will go to the same event handlers, regardless of source.
In Node.js, handling promise rejection is slightly different. You capture unhandled rejections by adding a handler for the Node.js unhandledRejection event (notice the difference in capitalization of the name), like this:
jsprocess.on("unhandledRejection", (reason, promise) => {
  // Add code here to examine the "promise" and "reason" values
});

For Node.js, to prevent the error from being logged to the console (the default action that would otherwise occur), adding that process.on() listener is all that's necessary; there's no need for an equivalent of the browser runtime's preventDefault() method.
However, if you add that process.on listener but don't also have code within it to handle rejected promises, they will just be dropped on the floor and silently ignored. So ideally, you should add code within that listener to examine each rejected promise and make sure it was not caused by an actual code bug.CompositionThere are four composition tools for running asynchronous operations concurrently: Promise.all(), Promise.allSettled(), Promise.any(), and Promise.race().
We can start operations at the same time and wait for them all to finish like this:
jsPromise.all([func1(), func2(), func3()]).then(([result1, result2, result3]) => {
  // use result1, result2 and result3
});

If one of the promises in the array rejects, Promise.all() immediately rejects the returned promise and aborts the other operations. This may cause unexpected state or behavior. Promise.allSettled() is another composition tool that ensures all operations are complete before resolving.
These methods all run promises concurrently — a sequence of promises are started simultaneously and do not wait for each other. Sequential composition is possible using some clever JavaScript:
js[func1, func2, func3]
  .reduce((p, f) => p.then(f), Promise.resolve())
  .then((result3) => {
    /* use result3 */
  });

In this example, we reduce an array of asynchronous functions down to a promise chain. The code above is equivalent to:
jsPromise.resolve()
  .then(func1)
  .then(func2)
  .then(func3)
  .then((result3) => {
    /* use result3 */
  });

This can be made into a reusable compose function, which is common in functional programming:
jsconst applyAsync = (acc, val) => acc.then(val);
const composeAsync =
  (...funcs) =>
  (x) =>
    funcs.reduce(applyAsync, Promise.resolve(x));

The composeAsync() function accepts any number of functions as arguments and returns a new function that accepts an initial value to be passed through the composition pipeline:
jsconst transformData = composeAsync(func1, func2, func3);
const result3 = transformData(data);

Sequential composition can also be done more succinctly with async/await:
jslet result;
for (const f of [func1, func2, func3]) {
  result = await f(result);
}
/* use last result (i.e. result3) */

However, before you compose promises sequentially, consider if it's really necessary — it's always better to run promises concurrently so that they don't unnecessarily block each other unless one promise's execution depends on another's result.CancellationPromise itself has no first-class protocol for cancellation, but you may be able to directly cancel the underlying asynchronous operation, typically using AbortController.Creating a Promise around an old callback APIA Promise can be created from scratch using its constructor. This should be needed only to wrap old APIs.
In an ideal world, all asynchronous functions would already return promises. Unfortunately, some APIs still expect success and/or failure callbacks to be passed in the old way. The most obvious example is the setTimeout() function:
jssetTimeout(() => saySomething("10 seconds passed"), 10 * 1000);

Mixing old-style callbacks and promises is problematic. If saySomething() fails or contains a programming error, nothing catches it. This is intrinsic to the design of setTimeout().
Luckily we can wrap setTimeout() in a promise. The best practice is to wrap the callback-accepting functions at the lowest possible level, and then never call them directly again:
jsconst wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

wait(10 * 1000)
  .then(() => saySomething("10 seconds"))
  .catch(failureCallback);

The promise constructor takes an executor function that lets us resolve or reject a promise manually. Since setTimeout() doesn't really fail, we left out reject in this case. For more information on how the executor function works, see the Promise() reference.TimingLastly, we will look into the more technical details, about when the registered callbacks get called.GuaranteesIn the callback-based API, when and how the callback gets called depends on the API implementor. For example, the callback may be called synchronously or asynchronously:
jsfunction doSomething(callback) {
  if (Math.random() > 0.5) {
    callback();
  } else {
    setTimeout(() => callback(), 1000);
  }
}

The above design is strongly discouraged because it leads to the so-called "state of Zalgo". In the context of designing asynchronous APIs, this means a callback is called synchronously in some cases but asynchronously in other cases, creating ambiguity for the caller. For further background, see the article Designing APIs for Asynchrony, where the term was first formally presented. This API design makes side effects hard to analyze:
jslet value = 1;
doSomething(() => {
  value = 2;
});
console.log(value); // 1 or 2?

On the other hand, promises are a form of inversion of control — the API implementor does not control when the callback gets called. Instead, the job of maintaining the callback queue and deciding when to call the callbacks is delegated to the promise implementation, and both the API user and API developer automatically gets strong semantic guarantees, including:

Callbacks added with then() will never be invoked before the completion of the current run of the JavaScript event loop.
These callbacks will be invoked even if they were added after the success or failure of the asynchronous operation that the promise represents.
Multiple callbacks may be added by calling then() several times. They will be invoked one after another, in the order in which they were inserted.

To avoid surprises, functions passed to then() will never be called synchronously, even with an already-resolved promise:
jsPromise.resolve().then(() => console.log(2));
console.log(1);
// Logs: 1, 2

Instead of running immediately, the passed-in function is put on a microtask queue, which means it runs later (only after the function which created it exits, and when the JavaScript execution stack is empty), just before control is returned to the event loop; i.e., pretty soon:
jsconst wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

wait(0).then(() => console.log(4));
Promise.resolve()
  .then(() => console.log(2))
  .then(() => console.log(3));
console.log(1); // 1, 2, 3, 4
Task queues vs. microtasksPromise callbacks are handled as a microtask whereas setTimeout() callbacks are handled as task queues.
jsconst promise = new Promise((resolve, reject) => {
  console.log("Promise callback");
  resolve();
}).then((result) => {
  console.log("Promise callback (.then)");
});

setTimeout(() => {
  console.log("event-loop cycle: Promise (fulfilled)", promise);
}, 0);

console.log("Promise (pending)", promise);

The code above will output:
Promise callback
Promise (pending) Promise {<pending>}
Promise callback (.then)
event-loop cycle: Promise (fulfilled) Promise {<fulfilled>}

For more details, refer to Tasks vs. microtasks.When promises and tasks collideIf you run into situations in which you have promises and tasks (such as events or callbacks) which are firing in unpredictable orders, it's possible you may benefit from using a microtask to check status or balance out your promises when promises are created conditionally.
If you think microtasks may help solve this problem, see the microtask guide to learn more about how to use queueMicrotask() to enqueue a function as a microtask.See also
Promise
async function
await
Promises/A+ specification
We have a problem with promises on pouchdb.com (2015)

 Previous  Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nUsing promises Previous  Next  
A Promise is an object representing the eventual completion or failure of an asynchronous operation. Since most people are consumers of already-created promises, this guide will explain consumption of returned promises before explaining how to create them.
Essentially, a promise is a returned object to which you attach callbacks, instead of passing callbacks into a function. Imagine a function, createAudioFileAsync(), which asynchronously generates a sound file given a configuration record and two callback functions: one called if the audio file is successfully created, and the other called if an error occurs.
Here's some code that uses createAudioFileAsync():
jsfunction successCallback(result) {
  console.log(`Audio file ready at URL: ${result}`);
}

function failureCallback(error) {
  console.error(`Error generating audio file: ${error}`);
}

createAudioFileAsync(audioSettings, successCallback, failureCallback);

If createAudioFileAsync() were rewritten to return a promise, you would attach your callbacks to it instead:
jscreateAudioFileAsync(audioSettings).then(successCallback, failureCallback);

This convention has several advantages. We will explore each one.ChainingA common need is to execute two or more asynchronous operations back to back, where each subsequent operation starts when the previous operation succeeds, with the result from the previous step. In the old days, doing several asynchronous operations in a row would lead to the classic callback hell:
jsdoSomething(function (result) {
  doSomethingElse(result, function (newResult) {
    doThirdThing(newResult, function (finalResult) {
      console.log(`Got the final result: ${finalResult}`);
    }, failureCallback);
  }, failureCallback);
}, failureCallback);

With promises, we accomplish this by creating a promise chain. The API design of promises makes this great, because callbacks are attached to the returned promise object, instead of being passed into a function.
Here's the magic: the then() function returns a new promise, different from the original:
jsconst promise = doSomething();
const promise2 = promise.then(successCallback, failureCallback);

This second promise (promise2) represents the completion not just of doSomething(), but also of the successCallback or failureCallback you passed in — which can be other asynchronous functions returning a promise. When that's the case, any callbacks added to promise2 get queued behind the promise returned by either successCallback or failureCallback.

Note:
If you want a working example to play with, you can use the following template to create any function returning a promise:
jsfunction doSomething() {
  return new Promise((resolve) => {
    setTimeout(() => {
      // Other things to do before completion of the promise
      console.log("Did something");
      // The fulfillment value of the promise
      resolve("https://example.com/");
    }, 200);
  });
}

The implementation is discussed in the Creating a Promise around an old callback API section below.

With this pattern, you can create longer chains of processing, where each promise represents the completion of one asynchronous step in the chain. In addition, the arguments to then are optional, and catch(failureCallback) is short for then(null, failureCallback) — so if your error handling code is the same for all steps, you can attach it to the end of the chain:
jsdoSomething()
  .then(function (result) {
    return doSomethingElse(result);
  })
  .then(function (newResult) {
    return doThirdThing(newResult);
  })
  .then(function (finalResult) {
    console.log(`Got the final result: ${finalResult}`);
  })
  .catch(failureCallback);

You might see this expressed with arrow functions instead:
jsdoSomething()
  .then((result) => doSomethingElse(result))
  .then((newResult) => doThirdThing(newResult))
  .then((finalResult) => {
    console.log(`Got the final result: ${finalResult}`);
  })
  .catch(failureCallback);


Note:
Arrow function expressions can have an implicit return; so, () => x is short for () => { return x; }.

doSomethingElse and doThirdThing can return any value — if they return promises, that promise is first waited until it settles, and the next callback receives the fulfillment value, not the promise itself. It is important to always return promises from then callbacks, even if the promise always resolves to undefined. If the previous handler started a promise but did not return it, there's no way to track its settlement anymore, and the promise is said to be "floating".
jsdoSomething()
  .then((url) => {
    // Missing `return` keyword in front of fetch(url).
    fetch(url);
  })
  .then((result) => {
    // result is undefined, because nothing is returned from the previous
    // handler. There's no way to know the return value of the fetch()
    // call anymore, or whether it succeeded at all.
  });

By returning the result of the fetch call (which is a promise), we can both track its completion and receive its value when it completes.
jsdoSomething()
  .then((url) => {
    // `return` keyword added
    return fetch(url);
  })
  .then((result) => {
    // result is a Response object
  });

Floating promises could be worse if you have race conditions — if the promise from the last handler is not returned, the next then handler will be called early, and any value it reads may be incomplete.
jsconst listOfIngredients = [];

doSomething()
  .then((url) => {
    // Missing `return` keyword in front of fetch(url).
    fetch(url)
      .then((res) => res.json())
      .then((data) => {
        listOfIngredients.push(data);
      });
  })
  .then(() => {
    console.log(listOfIngredients);
    // listOfIngredients will always be [], because the fetch request hasn't completed yet.
  });

Therefore, as a rule of thumb, whenever your operation encounters a promise, return it and defer its handling to the next then handler.
jsconst listOfIngredients = [];

doSomething()
  .then((url) => {
    // `return` keyword now included in front of fetch call.
    return fetch(url)
      .then((res) => res.json())
      .then((data) => {
        listOfIngredients.push(data);
      });
  })
  .then(() => {
    console.log(listOfIngredients);
    // listOfIngredients will now contain data from fetch call.
  });

Even better, you can flatten the nested chain into a single chain, which is simpler and makes error handling easier. The details are discussed in the Nesting section below.
jsdoSomething()
  .then((url) => fetch(url))
  .then((res) => res.json())
  .then((data) => {
    listOfIngredients.push(data);
  })
  .then(() => {
    console.log(listOfIngredients);
  });

Using async/await can help you write code that's more intuitive and resembles synchronous code. Below is the same example using async/await:
jsasync function logIngredients() {
  const url = await doSomething();
  const res = await fetch(url);
  const data = await res.json();
  listOfIngredients.push(data);
  console.log(listOfIngredients);
}

Note how the code looks exactly like synchronous code, except for the await keywords in front of promises. One of the only tradeoffs is that it may be easy to forget the await keyword, which can only be fixed when there's a type mismatch (e.g., trying to use a promise as a value).
async/await builds on promises — for example, doSomething() is the same function as before, so there's minimal refactoring needed to change from promises to async/await. You can read more about the async/await syntax in the async functions and await references.

Note: async/await has the same concurrency semantics as normal promise chains. await within one async function does not stop the entire program, only the parts that depend on its value, so other async jobs can still run while the await is pending.
Error handlingYou might recall seeing failureCallback three times in the pyramid of doom earlier, compared to only once at the end of the promise chain:
jsdoSomething()
  .then((result) => doSomethingElse(result))
  .then((newResult) => doThirdThing(newResult))
  .then((finalResult) => console.log(`Got the final result: ${finalResult}`))
  .catch(failureCallback);

If there's an exception, the browser will look down the chain for .catch() handlers or onRejected. This is very much modeled after how synchronous code works:
jstry {
  const result = syncDoSomething();
  const newResult = syncDoSomethingElse(result);
  const finalResult = syncDoThirdThing(newResult);
  console.log(`Got the final result: ${finalResult}`);
} catch (error) {
  failureCallback(error);
}

This symmetry with asynchronous code culminates in the async/await syntax:
jsasync function foo() {
  try {
    const result = await doSomething();
    const newResult = await doSomethingElse(result);
    const finalResult = await doThirdThing(newResult);
    console.log(`Got the final result: ${finalResult}`);
  } catch (error) {
    failureCallback(error);
  }
}

Promises solve a fundamental flaw with the callback pyramid of doom, by catching all errors, even thrown exceptions and programming errors. This is essential for functional composition of asynchronous operations. All errors are now handled by the catch() method at the end of the chain, and you should almost never need to use try/catch without using async/await.NestingIn the examples above involving listOfIngredients, the first one has one promise chain nested in the return value of another then() handler, while the second one uses an entirely flat chain. Simple promise chains are best kept flat without nesting, as nesting can be a result of careless composition.
Nesting is a control structure to limit the scope of catch statements. Specifically, a nested catch only catches failures in its scope and below, not errors higher up in the chain outside the nested scope. When used correctly, this gives greater precision in error recovery:
jsdoSomethingCritical()
  .then((result) =>
    doSomethingOptional(result)
      .then((optionalResult) => doSomethingExtraNice(optionalResult))
      .catch((e) => {}),
  ) // Ignore if optional stuff fails; proceed.
  .then(() => moreCriticalStuff())
  .catch((e) => console.error(`Critical failure: ${e.message}`));

Note that the optional steps here are nested — with the nesting caused not by the indentation, but by the placement of the outer ( and ) parentheses around the steps.
The inner error-silencing catch handler only catches failures from doSomethingOptional() and doSomethingExtraNice(), after which the code resumes with moreCriticalStuff(). Importantly, if doSomethingCritical() fails, its error is caught by the final (outer) catch only, and does not get swallowed by the inner catch handler.
In async/await, this code looks like:
jsasync function main() {
  try {
    const result = await doSomethingCritical();
    try {
      const optionalResult = await doSomethingOptional(result);
      await doSomethingExtraNice(optionalResult);
    } catch (e) {
      // Ignore failures in optional steps and proceed.
    }
    await moreCriticalStuff();
  } catch (e) {
    console.error(`Critical failure: ${e.message}`);
  }
}


Note:
If you don't have sophisticated error handling, you very likely don't need nested then handlers. Instead, use a flat chain and put the error handling logic at the end.
Chaining after a catchIt's possible to chain after a failure, i.e., a catch, which is useful to accomplish new actions even after an action failed in the chain. Read the following example:
jsdoSomething()
  .then(() => {
    throw new Error("Something failed");

    console.log("Do this");
  })
  .catch(() => {
    console.error("Do that");
  })
  .then(() => {
    console.log("Do this, no matter what happened before");
  });

This will output the following text:
Initial
Do that
Do this, no matter what happened before


Note:
The text "Do this" is not displayed because the "Something failed" error caused a rejection.

In async/await, this code looks like:
jsasync function main() {
  try {
    await doSomething();
    throw new Error("Something failed");
    console.log("Do this");
  } catch (e) {
    console.error("Do that");
  }
  console.log("Do this, no matter what happened before");
}
Promise rejection eventsIf a promise rejection event is not handled by any handler, it bubbles to the top of the call stack, and the host needs to surface it. On the web, whenever a promise is rejected, one of two events is sent to the global scope (generally, this is either the window or, if being used in a web worker, it's the Worker or other worker-based interface). The two events are:

unhandledrejection

Sent when a promise is rejected but there is no rejection handler available.

rejectionhandled

Sent when a handler is attached to a rejected promise that has already caused an unhandledrejection event.


In both cases, the event (of type PromiseRejectionEvent) has as members a promise property indicating the promise that was rejected, and a reason property that provides the reason given for the promise to be rejected.
These make it possible to offer fallback error handling for promises, as well as to help debug issues with your promise management. These handlers are global per context, so all errors will go to the same event handlers, regardless of source.
In Node.js, handling promise rejection is slightly different. You capture unhandled rejections by adding a handler for the Node.js unhandledRejection event (notice the difference in capitalization of the name), like this:
jsprocess.on("unhandledRejection", (reason, promise) => {
  // Add code here to examine the "promise" and "reason" values
});

For Node.js, to prevent the error from being logged to the console (the default action that would otherwise occur), adding that process.on() listener is all that's necessary; there's no need for an equivalent of the browser runtime's preventDefault() method.
However, if you add that process.on listener but don't also have code within it to handle rejected promises, they will just be dropped on the floor and silently ignored. So ideally, you should add code within that listener to examine each rejected promise and make sure it was not caused by an actual code bug.CompositionThere are four composition tools for running asynchronous operations concurrently: Promise.all(), Promise.allSettled(), Promise.any(), and Promise.race().
We can start operations at the same time and wait for them all to finish like this:
jsPromise.all([func1(), func2(), func3()]).then(([result1, result2, result3]) => {
  // use result1, result2 and result3
});

If one of the promises in the array rejects, Promise.all() immediately rejects the returned promise and aborts the other operations. This may cause unexpected state or behavior. Promise.allSettled() is another composition tool that ensures all operations are complete before resolving.
These methods all run promises concurrently — a sequence of promises are started simultaneously and do not wait for each other. Sequential composition is possible using some clever JavaScript:
js[func1, func2, func3]
  .reduce((p, f) => p.then(f), Promise.resolve())
  .then((result3) => {
    /* use result3 */
  });

In this example, we reduce an array of asynchronous functions down to a promise chain. The code above is equivalent to:
jsPromise.resolve()
  .then(func1)
  .then(func2)
  .then(func3)
  .then((result3) => {
    /* use result3 */
  });

This can be made into a reusable compose function, which is common in functional programming:
jsconst applyAsync = (acc, val) => acc.then(val);
const composeAsync =
  (...funcs) =>
  (x) =>
    funcs.reduce(applyAsync, Promise.resolve(x));

The composeAsync() function accepts any number of functions as arguments and returns a new function that accepts an initial value to be passed through the composition pipeline:
jsconst transformData = composeAsync(func1, func2, func3);
const result3 = transformData(data);

Sequential composition can also be done more succinctly with async/await:
jslet result;
for (const f of [func1, func2, func3]) {
  result = await f(result);
}
/* use last result (i.e. result3) */

However, before you compose promises sequentially, consider if it's really necessary — it's always better to run promises concurrently so that they don't unnecessarily block each other unless one promise's execution depends on another's result.CancellationPromise itself has no first-class protocol for cancellation, but you may be able to directly cancel the underlying asynchronous operation, typically using AbortController.Creating a Promise around an old callback APIA Promise can be created from scratch using its constructor. This should be needed only to wrap old APIs.
In an ideal world, all asynchronous functions would already return promises. Unfortunately, some APIs still expect success and/or failure callbacks to be passed in the old way. The most obvious example is the setTimeout() function:
jssetTimeout(() => saySomething("10 seconds passed"), 10 * 1000);

Mixing old-style callbacks and promises is problematic. If saySomething() fails or contains a programming error, nothing catches it. This is intrinsic to the design of setTimeout().
Luckily we can wrap setTimeout() in a promise. The best practice is to wrap the callback-accepting functions at the lowest possible level, and then never call them directly again:
jsconst wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

wait(10 * 1000)
  .then(() => saySomething("10 seconds"))
  .catch(failureCallback);

The promise constructor takes an executor function that lets us resolve or reject a promise manually. Since setTimeout() doesn't really fail, we left out reject in this case. For more information on how the executor function works, see the Promise() reference.TimingLastly, we will look into the more technical details, about when the registered callbacks get called.GuaranteesIn the callback-based API, when and how the callback gets called depends on the API implementor. For example, the callback may be called synchronously or asynchronously:
jsfunction doSomething(callback) {
  if (Math.random() > 0.5) {
    callback();
  } else {
    setTimeout(() => callback(), 1000);
  }
}

The above design is strongly discouraged because it leads to the so-called "state of Zalgo". In the context of designing asynchronous APIs, this means a callback is called synchronously in some cases but asynchronously in other cases, creating ambiguity for the caller. For further background, see the article Designing APIs for Asynchrony, where the term was first formally presented. This API design makes side effects hard to analyze:
jslet value = 1;
doSomething(() => {
  value = 2;
});
console.log(value); // 1 or 2?

On the other hand, promises are a form of inversion of control — the API implementor does not control when the callback gets called. Instead, the job of maintaining the callback queue and deciding when to call the callbacks is delegated to the promise implementation, and both the API user and API developer automatically gets strong semantic guarantees, including:

Callbacks added with then() will never be invoked before the completion of the current run of the JavaScript event loop.
These callbacks will be invoked even if they were added after the success or failure of the asynchronous operation that the promise represents.
Multiple callbacks may be added by calling then() several times. They will be invoked one after another, in the order in which they were inserted.

To avoid surprises, functions passed to then() will never be called synchronously, even with an already-resolved promise:
jsPromise.resolve().then(() => console.log(2));
console.log(1);
// Logs: 1, 2

Instead of running immediately, the passed-in function is put on a microtask queue, which means it runs later (only after the function which created it exits, and when the JavaScript execution stack is empty), just before control is returned to the event loop; i.e., pretty soon:
jsconst wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

wait(0).then(() => console.log(4));
Promise.resolve()
  .then(() => console.log(2))
  .then(() => console.log(3));
console.log(1); // 1, 2, 3, 4
Task queues vs. microtasksPromise callbacks are handled as a microtask whereas setTimeout() callbacks are handled as task queues.
jsconst promise = new Promise((resolve, reject) => {
  console.log("Promise callback");
  resolve();
}).then((result) => {
  console.log("Promise callback (.then)");
});

setTimeout(() => {
  console.log("event-loop cycle: Promise (fulfilled)", promise);
}, 0);

console.log("Promise (pending)", promise);

The code above will output:
Promise callback
Promise (pending) Promise {<pending>}
Promise callback (.then)
event-loop cycle: Promise (fulfilled) Promise {<fulfilled>}

For more details, refer to Tasks vs. microtasks.When promises and tasks collideIf you run into situations in which you have promises and tasks (such as events or callbacks) which are firing in unpredictable orders, it's possible you may benefit from using a microtask to check status or balance out your promises when promises are created conditionally.
If you think microtasks may help solve this problem, see the microtask guide to learn more about how to use queueMicrotask() to enqueue a function as a microtask.See also
Promise
async function
await
Promises/A+ specification
We have a problem with promises on pouchdb.com (2015)

 Previous  Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJavaScript typed arrays 
 Previous  Next  
JavaScript typed arrays are array-like objects that provide a mechanism for reading and writing raw binary data in memory buffers.
Typed arrays are not intended to replace arrays for any kind of functionality. Instead, they provide developers with a familiar interface for manipulating binary data. This is useful when interacting with platform features, such as audio and video manipulation, access to raw data using WebSockets, and so forth. Each entry in a JavaScript typed array is a raw binary value in one of a number of supported formats, from 8-bit integers to 64-bit floating-point numbers.
Typed array objects share many of the same methods as arrays with similar semantics. However, typed arrays are not to be confused with normal arrays, as calling Array.isArray() on a typed array returns false. Moreover, not all methods available for normal arrays are supported by typed arrays (e.g., push and pop).
To achieve maximum flexibility and efficiency, JavaScript typed arrays split the implementation into buffers and views. A buffer is an object representing a chunk of data; it has no format to speak of, and offers no mechanism for accessing its contents. In order to access the memory contained in a buffer, you need to use a view. A view provides a context — that is, a data type, starting offset, and number of elements.
BuffersThere are two types of buffers: ArrayBuffer and SharedArrayBuffer. Both are low-level representations of a memory span. They have "array" in their names, but they don't have much to do with arrays — you cannot read or write to them directly. Instead, buffers are generic objects that just contain raw data. In order to access the memory represented by a buffer, you need to use a view.
Buffers support the following actions:

Allocate: As soon as a new buffer is created, a new memory span is allocated and initialized to 0.
Copy: Using the slice() method, you can efficiently copy a portion of the memory without creating views to manually copy each byte.
Transfer: Using the transfer() and transferToFixedLength() methods, you can transfer ownership of the memory span to a new buffer object. This is useful when transferring data between different execution contexts without copying. After the transfer, the original buffer is no longer usable. A SharedArrayBuffer cannot be transferred (as the buffer is already shared by all execution contexts).
Resize: Using the resize() method, you can resize the memory span (either claim more memory space, as long as it doesn't pass the pre-set maxByteLength limit, or release some memory space). SharedArrayBuffer can only be grown but not shrunk.

The difference between ArrayBuffer and SharedArrayBuffer is that the former is always owned by a single execution context at a time. If you pass an ArrayBuffer to a different execution context, it is transferred and the original ArrayBuffer becomes unusable. This ensures that only one execution context can access the memory at a time. A SharedArrayBuffer is not transferred when passed to a different execution context, so it can be accessed by multiple execution contexts at the same time. This may introduce race conditions when multiple threads access the same memory span, so operations such as Atomics methods become useful.ViewsThere are currently two main kinds of views: typed array views and DataView. Typed arrays provide utility methods that allow you to conveniently transform binary data. DataView is more low-level and allows granular control of how data is accessed. The ways to read and write data using the two views are very different.
Both kinds of views cause ArrayBuffer.isView() to return true. They both have the following properties:

buffer

The underlying buffer that the view references.

byteOffset

The offset, in bytes, of the view from the start of its buffer.

byteLength

The length, in bytes, of the view.


Both constructors accept the above three as separate arguments, although typed array constructors accept length as the number of elements rather than the number of bytes.Typed array viewsTyped array views have self-descriptive names and provide views for all the usual numeric types like Int8, Uint32, Float64 and so forth. There is one special typed array view, Uint8ClampedArray, which clamps the values between 0 and 255. This is useful for Canvas data processing, for example.



Type
Value Range
Size in bytes
Web IDL type




Int8Array
-128 to 127
1
byte


Uint8Array
0 to 255
1
octet


Uint8ClampedArray
0 to 255
1
octet


Int16Array
-32768 to 32767
2
short


Uint16Array
0 to 65535
2
unsigned short


Int32Array
-2147483648 to 2147483647
4
long


Uint32Array
0 to 4294967295
4
unsigned long


Float16Array
-65504 to 65504
2
N/A


Float32Array
-3.4e38 to 3.4e38
4
unrestricted float


Float64Array
-1.8e308 to 1.8e308
8
unrestricted double


BigInt64Array
-263 to 263 - 1
8
bigint


BigUint64Array
0 to 264 - 1
8
bigint



All typed array views have the same methods and properties, as defined by the TypedArray class. They only differ in the underlying data type and the size in bytes. This is discussed in more detail in Value encoding and normalization.
Typed arrays are, in principle, fixed-length, so array methods that may change the length of an array are not available. This includes pop, push, shift, splice, and unshift. In addition, flat is unavailable because there are no nested typed arrays, and related methods including concat and flatMap do not have great use cases so are unavailable. As splice is unavailable, so too is toSpliced. All other array methods are shared between Array and TypedArray.
On the other hand, TypedArray has the extra set and subarray methods that optimize working with multiple typed arrays that view the same buffer. The set() method allows setting multiple typed array indices at once, using data from another array or typed array. If the two typed arrays share the same underlying buffer, the operation may be more efficient as it's a fast memory move. The subarray() method creates a new typed array view that references the same buffer as the original typed array, but with a narrower span.
There's no way to directly change the length of a typed array without changing the underlying buffer. However, when the typed array views a resizable buffer and does not have a fixed byteLength, it is length-tracking, and will automatically resize to fit the underlying buffer as the resizable buffer is resized. See Behavior when viewing a resizable buffer for details.
Similar to regular arrays, you can access typed array elements using bracket notation. The corresponding bytes in the underlying buffer are retrieved and interpreted as a number. Any property access using a number (or the string representation of a number, since numbers are always converted to strings when accessing properties) will be proxied by the typed array — they never interact with the object itself. This means, for example:

Out-of-bounds index access always returns undefined, without actually accessing the property on the object.
Any attempt to write to such an out-of-bounds property has no effect: it does not throw an error but doesn't change the buffer or typed array either.
Typed array indices appear to be configurable and writable, but any attempt to change their attributes will fail.

jsconst uint8 = new Uint8Array([1, 2, 3]);
console.log(uint8[0]); // 1

// For illustrative purposes only. Not for production code.
uint8[-1] = 0;
uint8[2.5] = 0;
uint8[NaN] = 0;
console.log(Object.keys(uint8)); // ["0", "1", "2"]
console.log(uint8[NaN]); // undefined

// Non-numeric access still works
uint8[true] = 0;
console.log(uint8[true]); // 0

Object.freeze(uint8); // TypeError: Cannot freeze array buffer views with elements
DataViewThe DataView is a low-level interface that provides a getter/setter API to read and write arbitrary data to the buffer. This is useful when dealing with different types of data, for example. Typed array views are in the native byte-order (see Endianness) of your platform. With a DataView, the byte-order can be controlled. By default, it's big-endian—the bytes are ordered from most significant to least significant. This can be reversed, with the bytes ordered from least significant to most significant (little-endian), using getter/setter methods.
DataView does not require alignment; multi-byte read and write can be started at any specified offset. The setter methods work the same way.
The following example uses a DataView to get the binary representation of any number:
jsfunction toBinary(
  x,
  { type = "Float64", littleEndian = false, separator = " ", radix = 16 } = {},
) {
  const bytesNeeded = globalThis[`${type}Array`].BYTES_PER_ELEMENT;
  const dv = new DataView(new ArrayBuffer(bytesNeeded));
  dv[`set${type}`](0, x, littleEndian);
  const bytes = Array.from({ length: bytesNeeded }, (_, i) =>
    dv
      .getUint8(i)
      .toString(radix)
      .padStart(8 / Math.log2(radix), "0"),
  );
  return bytes.join(separator);
}

console.log(toBinary(1.1)); // 3f f1 99 99 99 99 99 9a
console.log(toBinary(1.1, { littleEndian: true })); // 9a 99 99 99 99 99 f1 3f
console.log(toBinary(20, { type: "Int8", radix: 2 })); // 00010100
Web APIs using typed arraysThese are some examples of APIs that make use of typed arrays; there are others, and more are being added all the time.

FileReader.prototype.readAsArrayBuffer()

The FileReader.prototype.readAsArrayBuffer() method starts reading the contents of the specified Blob or File.

fetch()

The body option to fetch() can be a typed array or ArrayBuffer, enabling you to send these objects as the payload of a POST request.

ImageData.data

Is a Uint8ClampedArray representing a one-dimensional array containing the data in the RGBA order, with integer values between 0 and 255 inclusive.

ExamplesUsing views with buffersFirst of all, we will need to create a buffer, here with a fixed length of 16-bytes:
jsconst buffer = new ArrayBuffer(16);

At this point, we have a chunk of memory whose bytes are all pre-initialized to 0. There's not a lot we can do with it, though. For example, we can confirm that the buffer is the right size:
jsif (buffer.byteLength === 16) {
  console.log("Yes, it's 16 bytes.");
} else {
  console.log("Oh no, it's the wrong size!");
}

Before we can really work with this buffer, we need to create a view. Let's create a view that treats the data in the buffer as an array of 32-bit signed integers:
jsconst int32View = new Int32Array(buffer);

Now we can access the fields in the array just like a normal array:
jsfor (let i = 0; i < int32View.length; i++) {
  int32View[i] = i * 2;
}

This fills out the 4 entries in the array (4 entries at 4 bytes each makes 16 total bytes) with the values 0, 2, 4, and 6.Multiple views on the same dataThings start to get really interesting when you consider that you can create multiple views onto the same data. For example, given the code above, we can continue like this:
jsconst int16View = new Int16Array(buffer);

for (let i = 0; i < int16View.length; i++) {
  console.log(`Entry ${i}: ${int16View[i]}`);
}

Here we create a 16-bit integer view that shares the same buffer as the existing 32-bit view and we output all the values in the buffer as 16-bit integers. Now we get the output 0, 0, 2, 0, 4, 0, 6, 0 (assuming little-endian encoding):
Int16Array  |   0  |  0   |   2  |  0   |   4  |  0   |   6  |  0   |
Int32Array  |      0      |      2      |      4      |      6      |
ArrayBuffer | 00 00 00 00 | 02 00 00 00 | 04 00 00 00 | 06 00 00 00 |

You can go a step farther, though. Consider this:
jsint16View[0] = 32;
console.log(`Entry 0 in the 32-bit array is now ${int32View[0]}`);

The output from this is "Entry 0 in the 32-bit array is now 32".
In other words, the two arrays are indeed viewed on the same data buffer, treating it as different formats.
Int16Array  |  32  |  0   |   2  |  0   |   4  |  0   |   6  |  0   |
Int32Array  |     32      |      2      |      4      |      6      |
ArrayBuffer | 20 00 00 00 | 02 00 00 00 | 04 00 00 00 | 06 00 00 00 |

You can do this with any view type, although if you set an integer and then read it as a floating-point number, you will probably get a strange result because the bits are interpreted differently.
jsconst float32View = new Float32Array(buffer);
console.log(float32View[0]); // 4.484155085839415e-44
Reading text from a bufferBuffers don't always represent numbers. For example, reading a file can give you a text data buffer. You can read this data out of the buffer using a typed array.
The following reads UTF-8 text using the TextDecoder web API:
jsconst buffer = new ArrayBuffer(8);
const uint8 = new Uint8Array(buffer);
// Data manually written here, but pretend it was already in the buffer
uint8.set([228, 189, 160, 229, 165, 189]);
const text = new TextDecoder().decode(uint8);
console.log(text); // "你好"

The following reads UTF-16 text using the String.fromCharCode() method:
jsconst buffer = new ArrayBuffer(8);
const uint16 = new Uint16Array(buffer);
// Data manually written here, but pretend it was already in the buffer
uint16.set([0x4f60, 0x597d]);
const text = String.fromCharCode(...uint16);
console.log(text); // "你好"
Working with complex data structuresBy combining a single buffer with multiple views of different types, starting at different offsets into the buffer, you can interact with data objects containing multiple data types. This lets you, for example, interact with complex data structures from WebGL or data files.
Consider this C structure:
cppstruct someStruct {
  unsigned long id;
  char username[16];
  float amountDue;
};

You can access a buffer containing data in this format like this:
jsconst buffer = new ArrayBuffer(24);

// ... read the data into the buffer ...

const idView = new Uint32Array(buffer, 0, 1);
const usernameView = new Uint8Array(buffer, 4, 16);
const amountDueView = new Float32Array(buffer, 20, 1);

Then you can access, for example, the amount due with amountDueView[0].

Note:
The data structure alignment in a C structure is platform-dependent. Take precautions and considerations for these padding differences.
Conversion to normal arraysAfter processing a typed array, it is sometimes useful to convert it back to a normal array in order to benefit from the Array prototype. This can be done using Array.from():
jsconst typedArray = new Uint8Array([1, 2, 3, 4]);
const normalArray = Array.from(typedArray);

as well as the spread syntax:
jsconst typedArray = new Uint8Array([1, 2, 3, 4]);
const normalArray = [...typedArray];
See also
Faster Canvas Pixel Manipulation with Typed Arrays on hacks.mozilla.org (2011)
Typed arrays - Binary data in the browser on web.dev (2012)
Endianness
ArrayBuffer
DataView
TypedArray
SharedArrayBuffer

 Previous  Next\n\nJavaScript typed arrays 
 Previous  Next  
JavaScript typed arrays are array-like objects that provide a mechanism for reading and writing raw binary data in memory buffers.
Typed arrays are not intended to replace arrays for any kind of functionality. Instead, they provide developers with a familiar interface for manipulating binary data. This is useful when interacting with platform features, such as audio and video manipulation, access to raw data using WebSockets, and so forth. Each entry in a JavaScript typed array is a raw binary value in one of a number of supported formats, from 8-bit integers to 64-bit floating-point numbers.
Typed array objects share many of the same methods as arrays with similar semantics. However, typed arrays are not to be confused with normal arrays, as calling Array.isArray() on a typed array returns false. Moreover, not all methods available for normal arrays are supported by typed arrays (e.g., push and pop).
To achieve maximum flexibility and efficiency, JavaScript typed arrays split the implementation into buffers and views. A buffer is an object representing a chunk of data; it has no format to speak of, and offers no mechanism for accessing its contents. In order to access the memory contained in a buffer, you need to use a view. A view provides a context — that is, a data type, starting offset, and number of elements.
BuffersThere are two types of buffers: ArrayBuffer and SharedArrayBuffer. Both are low-level representations of a memory span. They have "array" in their names, but they don't have much to do with arrays — you cannot read or write to them directly. Instead, buffers are generic objects that just contain raw data. In order to access the memory represented by a buffer, you need to use a view.
Buffers support the following actions:

Allocate: As soon as a new buffer is created, a new memory span is allocated and initialized to 0.
Copy: Using the slice() method, you can efficiently copy a portion of the memory without creating views to manually copy each byte.
Transfer: Using the transfer() and transferToFixedLength() methods, you can transfer ownership of the memory span to a new buffer object. This is useful when transferring data between different execution contexts without copying. After the transfer, the original buffer is no longer usable. A SharedArrayBuffer cannot be transferred (as the buffer is already shared by all execution contexts).
Resize: Using the resize() method, you can resize the memory span (either claim more memory space, as long as it doesn't pass the pre-set maxByteLength limit, or release some memory space). SharedArrayBuffer can only be grown but not shrunk.

The difference between ArrayBuffer and SharedArrayBuffer is that the former is always owned by a single execution context at a time. If you pass an ArrayBuffer to a different execution context, it is transferred and the original ArrayBuffer becomes unusable. This ensures that only one execution context can access the memory at a time. A SharedArrayBuffer is not transferred when passed to a different execution context, so it can be accessed by multiple execution contexts at the same time. This may introduce race conditions when multiple threads access the same memory span, so operations such as Atomics methods become useful.ViewsThere are currently two main kinds of views: typed array views and DataView. Typed arrays provide utility methods that allow you to conveniently transform binary data. DataView is more low-level and allows granular control of how data is accessed. The ways to read and write data using the two views are very different.
Both kinds of views cause ArrayBuffer.isView() to return true. They both have the following properties:

buffer

The underlying buffer that the view references.

byteOffset

The offset, in bytes, of the view from the start of its buffer.

byteLength

The length, in bytes, of the view.


Both constructors accept the above three as separate arguments, although typed array constructors accept length as the number of elements rather than the number of bytes.Typed array viewsTyped array views have self-descriptive names and provide views for all the usual numeric types like Int8, Uint32, Float64 and so forth. There is one special typed array view, Uint8ClampedArray, which clamps the values between 0 and 255. This is useful for Canvas data processing, for example.



Type
Value Range
Size in bytes
Web IDL type




Int8Array
-128 to 127
1
byte


Uint8Array
0 to 255
1
octet


Uint8ClampedArray
0 to 255
1
octet


Int16Array
-32768 to 32767
2
short


Uint16Array
0 to 65535
2
unsigned short


Int32Array
-2147483648 to 2147483647
4
long


Uint32Array
0 to 4294967295
4
unsigned long


Float16Array
-65504 to 65504
2
N/A


Float32Array
-3.4e38 to 3.4e38
4
unrestricted float


Float64Array
-1.8e308 to 1.8e308
8
unrestricted double


BigInt64Array
-263 to 263 - 1
8
bigint


BigUint64Array
0 to 264 - 1
8
bigint



All typed array views have the same methods and properties, as defined by the TypedArray class. They only differ in the underlying data type and the size in bytes. This is discussed in more detail in Value encoding and normalization.
Typed arrays are, in principle, fixed-length, so array methods that may change the length of an array are not available. This includes pop, push, shift, splice, and unshift. In addition, flat is unavailable because there are no nested typed arrays, and related methods including concat and flatMap do not have great use cases so are unavailable. As splice is unavailable, so too is toSpliced. All other array methods are shared between Array and TypedArray.
On the other hand, TypedArray has the extra set and subarray methods that optimize working with multiple typed arrays that view the same buffer. The set() method allows setting multiple typed array indices at once, using data from another array or typed array. If the two typed arrays share the same underlying buffer, the operation may be more efficient as it's a fast memory move. The subarray() method creates a new typed array view that references the same buffer as the original typed array, but with a narrower span.
There's no way to directly change the length of a typed array without changing the underlying buffer. However, when the typed array views a resizable buffer and does not have a fixed byteLength, it is length-tracking, and will automatically resize to fit the underlying buffer as the resizable buffer is resized. See Behavior when viewing a resizable buffer for details.
Similar to regular arrays, you can access typed array elements using bracket notation. The corresponding bytes in the underlying buffer are retrieved and interpreted as a number. Any property access using a number (or the string representation of a number, since numbers are always converted to strings when accessing properties) will be proxied by the typed array — they never interact with the object itself. This means, for example:

Out-of-bounds index access always returns undefined, without actually accessing the property on the object.
Any attempt to write to such an out-of-bounds property has no effect: it does not throw an error but doesn't change the buffer or typed array either.
Typed array indices appear to be configurable and writable, but any attempt to change their attributes will fail.

jsconst uint8 = new Uint8Array([1, 2, 3]);
console.log(uint8[0]); // 1

// For illustrative purposes only. Not for production code.
uint8[-1] = 0;
uint8[2.5] = 0;
uint8[NaN] = 0;
console.log(Object.keys(uint8)); // ["0", "1", "2"]
console.log(uint8[NaN]); // undefined

// Non-numeric access still works
uint8[true] = 0;
console.log(uint8[true]); // 0

Object.freeze(uint8); // TypeError: Cannot freeze array buffer views with elements
DataViewThe DataView is a low-level interface that provides a getter/setter API to read and write arbitrary data to the buffer. This is useful when dealing with different types of data, for example. Typed array views are in the native byte-order (see Endianness) of your platform. With a DataView, the byte-order can be controlled. By default, it's big-endian—the bytes are ordered from most significant to least significant. This can be reversed, with the bytes ordered from least significant to most significant (little-endian), using getter/setter methods.
DataView does not require alignment; multi-byte read and write can be started at any specified offset. The setter methods work the same way.
The following example uses a DataView to get the binary representation of any number:
jsfunction toBinary(
  x,
  { type = "Float64", littleEndian = false, separator = " ", radix = 16 } = {},
) {
  const bytesNeeded = globalThis[`${type}Array`].BYTES_PER_ELEMENT;
  const dv = new DataView(new ArrayBuffer(bytesNeeded));
  dv[`set${type}`](0, x, littleEndian);
  const bytes = Array.from({ length: bytesNeeded }, (_, i) =>
    dv
      .getUint8(i)
      .toString(radix)
      .padStart(8 / Math.log2(radix), "0"),
  );
  return bytes.join(separator);
}

console.log(toBinary(1.1)); // 3f f1 99 99 99 99 99 9a
console.log(toBinary(1.1, { littleEndian: true })); // 9a 99 99 99 99 99 f1 3f
console.log(toBinary(20, { type: "Int8", radix: 2 })); // 00010100
Web APIs using typed arraysThese are some examples of APIs that make use of typed arrays; there are others, and more are being added all the time.

FileReader.prototype.readAsArrayBuffer()

The FileReader.prototype.readAsArrayBuffer() method starts reading the contents of the specified Blob or File.

fetch()

The body option to fetch() can be a typed array or ArrayBuffer, enabling you to send these objects as the payload of a POST request.

ImageData.data

Is a Uint8ClampedArray representing a one-dimensional array containing the data in the RGBA order, with integer values between 0 and 255 inclusive.

ExamplesUsing views with buffersFirst of all, we will need to create a buffer, here with a fixed length of 16-bytes:
jsconst buffer = new ArrayBuffer(16);

At this point, we have a chunk of memory whose bytes are all pre-initialized to 0. There's not a lot we can do with it, though. For example, we can confirm that the buffer is the right size:
jsif (buffer.byteLength === 16) {
  console.log("Yes, it's 16 bytes.");
} else {
  console.log("Oh no, it's the wrong size!");
}

Before we can really work with this buffer, we need to create a view. Let's create a view that treats the data in the buffer as an array of 32-bit signed integers:
jsconst int32View = new Int32Array(buffer);

Now we can access the fields in the array just like a normal array:
jsfor (let i = 0; i < int32View.length; i++) {
  int32View[i] = i * 2;
}

This fills out the 4 entries in the array (4 entries at 4 bytes each makes 16 total bytes) with the values 0, 2, 4, and 6.Multiple views on the same dataThings start to get really interesting when you consider that you can create multiple views onto the same data. For example, given the code above, we can continue like this:
jsconst int16View = new Int16Array(buffer);

for (let i = 0; i < int16View.length; i++) {
  console.log(`Entry ${i}: ${int16View[i]}`);
}

Here we create a 16-bit integer view that shares the same buffer as the existing 32-bit view and we output all the values in the buffer as 16-bit integers. Now we get the output 0, 0, 2, 0, 4, 0, 6, 0 (assuming little-endian encoding):
Int16Array  |   0  |  0   |   2  |  0   |   4  |  0   |   6  |  0   |
Int32Array  |      0      |      2      |      4      |      6      |
ArrayBuffer | 00 00 00 00 | 02 00 00 00 | 04 00 00 00 | 06 00 00 00 |

You can go a step farther, though. Consider this:
jsint16View[0] = 32;
console.log(`Entry 0 in the 32-bit array is now ${int32View[0]}`);

The output from this is "Entry 0 in the 32-bit array is now 32".
In other words, the two arrays are indeed viewed on the same data buffer, treating it as different formats.
Int16Array  |  32  |  0   |   2  |  0   |   4  |  0   |   6  |  0   |
Int32Array  |     32      |      2      |      4      |      6      |
ArrayBuffer | 20 00 00 00 | 02 00 00 00 | 04 00 00 00 | 06 00 00 00 |

You can do this with any view type, although if you set an integer and then read it as a floating-point number, you will probably get a strange result because the bits are interpreted differently.
jsconst float32View = new Float32Array(buffer);
console.log(float32View[0]); // 4.484155085839415e-44
Reading text from a bufferBuffers don't always represent numbers. For example, reading a file can give you a text data buffer. You can read this data out of the buffer using a typed array.
The following reads UTF-8 text using the TextDecoder web API:
jsconst buffer = new ArrayBuffer(8);
const uint8 = new Uint8Array(buffer);
// Data manually written here, but pretend it was already in the buffer
uint8.set([228, 189, 160, 229, 165, 189]);
const text = new TextDecoder().decode(uint8);
console.log(text); // "你好"

The following reads UTF-16 text using the String.fromCharCode() method:
jsconst buffer = new ArrayBuffer(8);
const uint16 = new Uint16Array(buffer);
// Data manually written here, but pretend it was already in the buffer
uint16.set([0x4f60, 0x597d]);
const text = String.fromCharCode(...uint16);
console.log(text); // "你好"
Working with complex data structuresBy combining a single buffer with multiple views of different types, starting at different offsets into the buffer, you can interact with data objects containing multiple data types. This lets you, for example, interact with complex data structures from WebGL or data files.
Consider this C structure:
cppstruct someStruct {
  unsigned long id;
  char username[16];
  float amountDue;
};

You can access a buffer containing data in this format like this:
jsconst buffer = new ArrayBuffer(24);

// ... read the data into the buffer ...

const idView = new Uint32Array(buffer, 0, 1);
const usernameView = new Uint8Array(buffer, 4, 16);
const amountDueView = new Float32Array(buffer, 20, 1);

Then you can access, for example, the amount due with amountDueView[0].

Note:
The data structure alignment in a C structure is platform-dependent. Take precautions and considerations for these padding differences.
Conversion to normal arraysAfter processing a typed array, it is sometimes useful to convert it back to a normal array in order to benefit from the Array prototype. This can be done using Array.from():
jsconst typedArray = new Uint8Array([1, 2, 3, 4]);
const normalArray = Array.from(typedArray);

as well as the spread syntax:
jsconst typedArray = new Uint8Array([1, 2, 3, 4]);
const normalArray = [...typedArray];
See also
Faster Canvas Pixel Manipulation with Typed Arrays on hacks.mozilla.org (2011)
Typed arrays - Binary data in the browser on web.dev (2012)
Endianness
ArrayBuffer
DataView
TypedArray
SharedArrayBuffer

 Previous  Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJavaScript typed arrays 
 Previous  Next  
JavaScript typed arrays are array-like objects that provide a mechanism for reading and writing raw binary data in memory buffers.
Typed arrays are not intended to replace arrays for any kind of functionality. Instead, they provide developers with a familiar interface for manipulating binary data. This is useful when interacting with platform features, such as audio and video manipulation, access to raw data using WebSockets, and so forth. Each entry in a JavaScript typed array is a raw binary value in one of a number of supported formats, from 8-bit integers to 64-bit floating-point numbers.
Typed array objects share many of the same methods as arrays with similar semantics. However, typed arrays are not to be confused with normal arrays, as calling Array.isArray() on a typed array returns false. Moreover, not all methods available for normal arrays are supported by typed arrays (e.g., push and pop).
To achieve maximum flexibility and efficiency, JavaScript typed arrays split the implementation into buffers and views. A buffer is an object representing a chunk of data; it has no format to speak of, and offers no mechanism for accessing its contents. In order to access the memory contained in a buffer, you need to use a view. A view provides a context — that is, a data type, starting offset, and number of elements.
BuffersThere are two types of buffers: ArrayBuffer and SharedArrayBuffer. Both are low-level representations of a memory span. They have "array" in their names, but they don't have much to do with arrays — you cannot read or write to them directly. Instead, buffers are generic objects that just contain raw data. In order to access the memory represented by a buffer, you need to use a view.
Buffers support the following actions:

Allocate: As soon as a new buffer is created, a new memory span is allocated and initialized to 0.
Copy: Using the slice() method, you can efficiently copy a portion of the memory without creating views to manually copy each byte.
Transfer: Using the transfer() and transferToFixedLength() methods, you can transfer ownership of the memory span to a new buffer object. This is useful when transferring data between different execution contexts without copying. After the transfer, the original buffer is no longer usable. A SharedArrayBuffer cannot be transferred (as the buffer is already shared by all execution contexts).
Resize: Using the resize() method, you can resize the memory span (either claim more memory space, as long as it doesn't pass the pre-set maxByteLength limit, or release some memory space). SharedArrayBuffer can only be grown but not shrunk.

The difference between ArrayBuffer and SharedArrayBuffer is that the former is always owned by a single execution context at a time. If you pass an ArrayBuffer to a different execution context, it is transferred and the original ArrayBuffer becomes unusable. This ensures that only one execution context can access the memory at a time. A SharedArrayBuffer is not transferred when passed to a different execution context, so it can be accessed by multiple execution contexts at the same time. This may introduce race conditions when multiple threads access the same memory span, so operations such as Atomics methods become useful.ViewsThere are currently two main kinds of views: typed array views and DataView. Typed arrays provide utility methods that allow you to conveniently transform binary data. DataView is more low-level and allows granular control of how data is accessed. The ways to read and write data using the two views are very different.
Both kinds of views cause ArrayBuffer.isView() to return true. They both have the following properties:

buffer

The underlying buffer that the view references.

byteOffset

The offset, in bytes, of the view from the start of its buffer.

byteLength

The length, in bytes, of the view.


Both constructors accept the above three as separate arguments, although typed array constructors accept length as the number of elements rather than the number of bytes.Typed array viewsTyped array views have self-descriptive names and provide views for all the usual numeric types like Int8, Uint32, Float64 and so forth. There is one special typed array view, Uint8ClampedArray, which clamps the values between 0 and 255. This is useful for Canvas data processing, for example.



Type
Value Range
Size in bytes
Web IDL type




Int8Array
-128 to 127
1
byte


Uint8Array
0 to 255
1
octet


Uint8ClampedArray
0 to 255
1
octet


Int16Array
-32768 to 32767
2
short


Uint16Array
0 to 65535
2
unsigned short


Int32Array
-2147483648 to 2147483647
4
long


Uint32Array
0 to 4294967295
4
unsigned long


Float16Array
-65504 to 65504
2
N/A


Float32Array
-3.4e38 to 3.4e38
4
unrestricted float


Float64Array
-1.8e308 to 1.8e308
8
unrestricted double


BigInt64Array
-263 to 263 - 1
8
bigint


BigUint64Array
0 to 264 - 1
8
bigint



All typed array views have the same methods and properties, as defined by the TypedArray class. They only differ in the underlying data type and the size in bytes. This is discussed in more detail in Value encoding and normalization.
Typed arrays are, in principle, fixed-length, so array methods that may change the length of an array are not available. This includes pop, push, shift, splice, and unshift. In addition, flat is unavailable because there are no nested typed arrays, and related methods including concat and flatMap do not have great use cases so are unavailable. As splice is unavailable, so too is toSpliced. All other array methods are shared between Array and TypedArray.
On the other hand, TypedArray has the extra set and subarray methods that optimize working with multiple typed arrays that view the same buffer. The set() method allows setting multiple typed array indices at once, using data from another array or typed array. If the two typed arrays share the same underlying buffer, the operation may be more efficient as it's a fast memory move. The subarray() method creates a new typed array view that references the same buffer as the original typed array, but with a narrower span.
There's no way to directly change the length of a typed array without changing the underlying buffer. However, when the typed array views a resizable buffer and does not have a fixed byteLength, it is length-tracking, and will automatically resize to fit the underlying buffer as the resizable buffer is resized. See Behavior when viewing a resizable buffer for details.
Similar to regular arrays, you can access typed array elements using bracket notation. The corresponding bytes in the underlying buffer are retrieved and interpreted as a number. Any property access using a number (or the string representation of a number, since numbers are always converted to strings when accessing properties) will be proxied by the typed array — they never interact with the object itself. This means, for example:

Out-of-bounds index access always returns undefined, without actually accessing the property on the object.
Any attempt to write to such an out-of-bounds property has no effect: it does not throw an error but doesn't change the buffer or typed array either.
Typed array indices appear to be configurable and writable, but any attempt to change their attributes will fail.

jsconst uint8 = new Uint8Array([1, 2, 3]);
console.log(uint8[0]); // 1

// For illustrative purposes only. Not for production code.
uint8[-1] = 0;
uint8[2.5] = 0;
uint8[NaN] = 0;
console.log(Object.keys(uint8)); // ["0", "1", "2"]
console.log(uint8[NaN]); // undefined

// Non-numeric access still works
uint8[true] = 0;
console.log(uint8[true]); // 0

Object.freeze(uint8); // TypeError: Cannot freeze array buffer views with elements
DataViewThe DataView is a low-level interface that provides a getter/setter API to read and write arbitrary data to the buffer. This is useful when dealing with different types of data, for example. Typed array views are in the native byte-order (see Endianness) of your platform. With a DataView, the byte-order can be controlled. By default, it's big-endian—the bytes are ordered from most significant to least significant. This can be reversed, with the bytes ordered from least significant to most significant (little-endian), using getter/setter methods.
DataView does not require alignment; multi-byte read and write can be started at any specified offset. The setter methods work the same way.
The following example uses a DataView to get the binary representation of any number:
jsfunction toBinary(
  x,
  { type = "Float64", littleEndian = false, separator = " ", radix = 16 } = {},
) {
  const bytesNeeded = globalThis[`${type}Array`].BYTES_PER_ELEMENT;
  const dv = new DataView(new ArrayBuffer(bytesNeeded));
  dv[`set${type}`](0, x, littleEndian);
  const bytes = Array.from({ length: bytesNeeded }, (_, i) =>
    dv
      .getUint8(i)
      .toString(radix)
      .padStart(8 / Math.log2(radix), "0"),
  );
  return bytes.join(separator);
}

console.log(toBinary(1.1)); // 3f f1 99 99 99 99 99 9a
console.log(toBinary(1.1, { littleEndian: true })); // 9a 99 99 99 99 99 f1 3f
console.log(toBinary(20, { type: "Int8", radix: 2 })); // 00010100
Web APIs using typed arraysThese are some examples of APIs that make use of typed arrays; there are others, and more are being added all the time.

FileReader.prototype.readAsArrayBuffer()

The FileReader.prototype.readAsArrayBuffer() method starts reading the contents of the specified Blob or File.

fetch()

The body option to fetch() can be a typed array or ArrayBuffer, enabling you to send these objects as the payload of a POST request.

ImageData.data

Is a Uint8ClampedArray representing a one-dimensional array containing the data in the RGBA order, with integer values between 0 and 255 inclusive.

ExamplesUsing views with buffersFirst of all, we will need to create a buffer, here with a fixed length of 16-bytes:
jsconst buffer = new ArrayBuffer(16);

At this point, we have a chunk of memory whose bytes are all pre-initialized to 0. There's not a lot we can do with it, though. For example, we can confirm that the buffer is the right size:
jsif (buffer.byteLength === 16) {
  console.log("Yes, it's 16 bytes.");
} else {
  console.log("Oh no, it's the wrong size!");
}

Before we can really work with this buffer, we need to create a view. Let's create a view that treats the data in the buffer as an array of 32-bit signed integers:
jsconst int32View = new Int32Array(buffer);

Now we can access the fields in the array just like a normal array:
jsfor (let i = 0; i < int32View.length; i++) {
  int32View[i] = i * 2;
}

This fills out the 4 entries in the array (4 entries at 4 bytes each makes 16 total bytes) with the values 0, 2, 4, and 6.Multiple views on the same dataThings start to get really interesting when you consider that you can create multiple views onto the same data. For example, given the code above, we can continue like this:
jsconst int16View = new Int16Array(buffer);

for (let i = 0; i < int16View.length; i++) {
  console.log(`Entry ${i}: ${int16View[i]}`);
}

Here we create a 16-bit integer view that shares the same buffer as the existing 32-bit view and we output all the values in the buffer as 16-bit integers. Now we get the output 0, 0, 2, 0, 4, 0, 6, 0 (assuming little-endian encoding):
Int16Array  |   0  |  0   |   2  |  0   |   4  |  0   |   6  |  0   |
Int32Array  |      0      |      2      |      4      |      6      |
ArrayBuffer | 00 00 00 00 | 02 00 00 00 | 04 00 00 00 | 06 00 00 00 |

You can go a step farther, though. Consider this:
jsint16View[0] = 32;
console.log(`Entry 0 in the 32-bit array is now ${int32View[0]}`);

The output from this is "Entry 0 in the 32-bit array is now 32".
In other words, the two arrays are indeed viewed on the same data buffer, treating it as different formats.
Int16Array  |  32  |  0   |   2  |  0   |   4  |  0   |   6  |  0   |
Int32Array  |     32      |      2      |      4      |      6      |
ArrayBuffer | 20 00 00 00 | 02 00 00 00 | 04 00 00 00 | 06 00 00 00 |

You can do this with any view type, although if you set an integer and then read it as a floating-point number, you will probably get a strange result because the bits are interpreted differently.
jsconst float32View = new Float32Array(buffer);
console.log(float32View[0]); // 4.484155085839415e-44
Reading text from a bufferBuffers don't always represent numbers. For example, reading a file can give you a text data buffer. You can read this data out of the buffer using a typed array.
The following reads UTF-8 text using the TextDecoder web API:
jsconst buffer = new ArrayBuffer(8);
const uint8 = new Uint8Array(buffer);
// Data manually written here, but pretend it was already in the buffer
uint8.set([228, 189, 160, 229, 165, 189]);
const text = new TextDecoder().decode(uint8);
console.log(text); // "你好"

The following reads UTF-16 text using the String.fromCharCode() method:
jsconst buffer = new ArrayBuffer(8);
const uint16 = new Uint16Array(buffer);
// Data manually written here, but pretend it was already in the buffer
uint16.set([0x4f60, 0x597d]);
const text = String.fromCharCode(...uint16);
console.log(text); // "你好"
Working with complex data structuresBy combining a single buffer with multiple views of different types, starting at different offsets into the buffer, you can interact with data objects containing multiple data types. This lets you, for example, interact with complex data structures from WebGL or data files.
Consider this C structure:
cppstruct someStruct {
  unsigned long id;
  char username[16];
  float amountDue;
};

You can access a buffer containing data in this format like this:
jsconst buffer = new ArrayBuffer(24);

// ... read the data into the buffer ...

const idView = new Uint32Array(buffer, 0, 1);
const usernameView = new Uint8Array(buffer, 4, 16);
const amountDueView = new Float32Array(buffer, 20, 1);

Then you can access, for example, the amount due with amountDueView[0].

Note:
The data structure alignment in a C structure is platform-dependent. Take precautions and considerations for these padding differences.
Conversion to normal arraysAfter processing a typed array, it is sometimes useful to convert it back to a normal array in order to benefit from the Array prototype. This can be done using Array.from():
jsconst typedArray = new Uint8Array([1, 2, 3, 4]);
const normalArray = Array.from(typedArray);

as well as the spread syntax:
jsconst typedArray = new Uint8Array([1, 2, 3, 4]);
const normalArray = [...typedArray];
See also
Faster Canvas Pixel Manipulation with Typed Arrays on hacks.mozilla.org (2011)
Typed arrays - Binary data in the browser on web.dev (2012)
Endianness
ArrayBuffer
DataView
TypedArray
SharedArrayBuffer

 Previous  Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIterators and generators 
 Previous  Next  
Iterators and Generators bring the concept of iteration directly into the core language and provide a mechanism for customizing the behavior of for...of loops.
For details, see also:

Iteration protocols
for...of
function* and Generator
yield and yield*
IteratorsIn JavaScript an iterator is an object which defines a sequence and potentially a return value upon its termination.
Specifically, an iterator is any object which implements the Iterator protocol by having a next() method that returns an object with two properties:

value

The next value in the iteration sequence.

done

This is true if the last value in the sequence has already been consumed. If value is present alongside done, it is the iterator's return value.


Once created, an iterator object can be iterated explicitly by repeatedly calling next(). Iterating over an iterator is said to consume the iterator, because it is generally only possible to do once. After a terminating value has been yielded additional calls to next() should continue to return {done: true}.
The most common iterator in JavaScript is the Array iterator, which returns each value in the associated array in sequence.
While it is easy to imagine that all iterators could be expressed as arrays, this is not true. Arrays must be allocated in their entirety, but iterators are consumed only as necessary. Because of this, iterators can express sequences of unlimited size, such as the range of integers between 0 and Infinity.
Here is an example which can do just that. It allows creation of a range iterator which defines a sequence of integers from start (inclusive) to end (exclusive) spaced step apart. Its final return value is the size of the sequence it created, tracked by the variable iterationCount.
jsfunction makeRangeIterator(start = 0, end = Infinity, step = 1) {
  let nextIndex = start;
  let iterationCount = 0;

  const rangeIterator = {
    next() {
      let result;
      if (nextIndex < end) {
        result = { value: nextIndex, done: false };
        nextIndex += step;
        iterationCount++;
        return result;
      }
      return { value: iterationCount, done: true };
    },
  };
  return rangeIterator;
}

Using the iterator then looks like this:
jsconst iter = makeRangeIterator(1, 10, 2);

let result = iter.next();
while (!result.done) {
  console.log(result.value); // 1 3 5 7 9
  result = iter.next();
}

console.log("Iterated over sequence of size:", result.value); // [5 numbers returned, that took interval in between: 0 to 10]


Note:
It is not possible to know reflectively whether a particular object is an iterator. If you need to do this, use Iterables.
Generator functionsWhile custom iterators are a useful tool, their creation requires careful programming due to the need to explicitly maintain their internal state. Generator functions provide a powerful alternative: they allow you to define an iterative algorithm by writing a single function whose execution is not continuous. Generator functions are written using the function* syntax.
When called, generator functions do not initially execute their code. Instead, they return a special type of iterator, called a Generator. When a value is consumed by calling the generator's next method, the Generator function executes until it encounters the yield keyword.
The function can be called as many times as desired, and returns a new Generator each time. Each Generator may only be iterated once.
We can now adapt the example from above. The behavior of this code is identical, but the implementation is much easier to write and read.
jsfunction* makeRangeIterator(start = 0, end = Infinity, step = 1) {
  let iterationCount = 0;
  for (let i = start; i < end; i += step) {
    iterationCount++;
    yield i;
  }
  return iterationCount;
}
IterablesAn object is iterable if it defines its iteration behavior, such as what values are looped over in a for...of construct. Some built-in types, such as Array or Map, have a default iteration behavior, while other types (such as Object) do not.
In order to be iterable, an object must implement the [Symbol.iterator]() method. This means that the object (or one of the objects up its prototype chain) must have a property with a Symbol.iterator key.
It may be possible to iterate over an iterable more than once, or only once. It is up to the programmer to know which is the case.
Iterables which can iterate only once (such as Generators) customarily return this from their [Symbol.iterator]() method, whereas iterables which can be iterated many times must return a new iterator on each invocation of [Symbol.iterator]().
jsfunction* makeIterator() {
  yield 1;
  yield 2;
}

const iter = makeIterator();

for (const itItem of iter) {
  console.log(itItem);
}

console.log(iter[Symbol.iterator]() === iter); // true

// This example show us generator(iterator) is iterable object,
// which has the [Symbol.iterator]() method return the `iter` (itself),
// and consequently, the it object can iterate only _once_.

// If we change the [Symbol.iterator]() method of `iter` to a function/generator
// which returns a new iterator/generator object, `iter`
// can iterate many times

iter[Symbol.iterator] = function* () {
  yield 2;
  yield 1;
};
User-defined iterablesYou can make your own iterables like this:
jsconst myIterable = {
  *[Symbol.iterator]() {
    yield 1;
    yield 2;
    yield 3;
  },
};

User-defined iterables can be used in for...of loops or the spread syntax as usual.
jsfor (const value of myIterable) {
  console.log(value);
}
// 1
// 2
// 3

[...myIterable]; // [1, 2, 3]
Built-in iterablesString, Array, TypedArray, Map and Set are all built-in iterables, because their prototype objects all have a Symbol.iterator method.Syntaxes expecting iterablesSome statements and expressions expect iterables. For example: the for...of loops, spread syntax, yield*, and destructuring syntax.
jsfor (const value of ["a", "b", "c"]) {
  console.log(value);
}
// "a"
// "b"
// "c"

[..."abc"];
// ["a", "b", "c"]

function* gen() {
  yield* ["a", "b", "c"];
}

gen().next();
// { value: "a", done: false }

[a, b, c] = new Set(["a", "b", "c"]);
a;
// "a"
Advanced generatorsGenerators compute their yielded values on demand, which allows them to efficiently represent sequences that are expensive to compute (or even infinite sequences, as demonstrated above).
The next() method also accepts a value, which can be used to modify the internal state of the generator. A value passed to next() will be received by yield.

Note:
A value passed to the first invocation of next() is always ignored.

Here is the fibonacci generator using next(x) to restart the sequence:
jsfunction* fibonacci() {
  let current = 0;
  let next = 1;
  while (true) {
    const reset = yield current;
    [current, next] = [next, next + current];
    if (reset) {
      current = 0;
      next = 1;
    }
  }
}

const sequence = fibonacci();
console.log(sequence.next().value); // 0
console.log(sequence.next().value); // 1
console.log(sequence.next().value); // 1
console.log(sequence.next().value); // 2
console.log(sequence.next().value); // 3
console.log(sequence.next().value); // 5
console.log(sequence.next().value); // 8
console.log(sequence.next(true).value); // 0
console.log(sequence.next().value); // 1
console.log(sequence.next().value); // 1
console.log(sequence.next().value); // 2

You can force a generator to throw an exception by calling its throw() method and passing the exception value it should throw. This exception will be thrown from the current suspended context of the generator, as if the yield that is currently suspended were instead a throw value statement.
If the exception is not caught from within the generator, it will propagate up through the call to throw(), and subsequent calls to next() will result in the done property being true.
Generators have a return() method that returns the given value and finishes the generator itself.
 Previous  Next\n\nIterators and generators 
 Previous  Next  
Iterators and Generators bring the concept of iteration directly into the core language and provide a mechanism for customizing the behavior of for...of loops.
For details, see also:

Iteration protocols
for...of
function* and Generator
yield and yield*
IteratorsIn JavaScript an iterator is an object which defines a sequence and potentially a return value upon its termination.
Specifically, an iterator is any object which implements the Iterator protocol by having a next() method that returns an object with two properties:

value

The next value in the iteration sequence.

done

This is true if the last value in the sequence has already been consumed. If value is present alongside done, it is the iterator's return value.


Once created, an iterator object can be iterated explicitly by repeatedly calling next(). Iterating over an iterator is said to consume the iterator, because it is generally only possible to do once. After a terminating value has been yielded additional calls to next() should continue to return {done: true}.
The most common iterator in JavaScript is the Array iterator, which returns each value in the associated array in sequence.
While it is easy to imagine that all iterators could be expressed as arrays, this is not true. Arrays must be allocated in their entirety, but iterators are consumed only as necessary. Because of this, iterators can express sequences of unlimited size, such as the range of integers between 0 and Infinity.
Here is an example which can do just that. It allows creation of a range iterator which defines a sequence of integers from start (inclusive) to end (exclusive) spaced step apart. Its final return value is the size of the sequence it created, tracked by the variable iterationCount.
jsfunction makeRangeIterator(start = 0, end = Infinity, step = 1) {
  let nextIndex = start;
  let iterationCount = 0;

  const rangeIterator = {
    next() {
      let result;
      if (nextIndex < end) {
        result = { value: nextIndex, done: false };
        nextIndex += step;
        iterationCount++;
        return result;
      }
      return { value: iterationCount, done: true };
    },
  };
  return rangeIterator;
}

Using the iterator then looks like this:
jsconst iter = makeRangeIterator(1, 10, 2);

let result = iter.next();
while (!result.done) {
  console.log(result.value); // 1 3 5 7 9
  result = iter.next();
}

console.log("Iterated over sequence of size:", result.value); // [5 numbers returned, that took interval in between: 0 to 10]


Note:
It is not possible to know reflectively whether a particular object is an iterator. If you need to do this, use Iterables.
Generator functionsWhile custom iterators are a useful tool, their creation requires careful programming due to the need to explicitly maintain their internal state. Generator functions provide a powerful alternative: they allow you to define an iterative algorithm by writing a single function whose execution is not continuous. Generator functions are written using the function* syntax.
When called, generator functions do not initially execute their code. Instead, they return a special type of iterator, called a Generator. When a value is consumed by calling the generator's next method, the Generator function executes until it encounters the yield keyword.
The function can be called as many times as desired, and returns a new Generator each time. Each Generator may only be iterated once.
We can now adapt the example from above. The behavior of this code is identical, but the implementation is much easier to write and read.
jsfunction* makeRangeIterator(start = 0, end = Infinity, step = 1) {
  let iterationCount = 0;
  for (let i = start; i < end; i += step) {
    iterationCount++;
    yield i;
  }
  return iterationCount;
}
IterablesAn object is iterable if it defines its iteration behavior, such as what values are looped over in a for...of construct. Some built-in types, such as Array or Map, have a default iteration behavior, while other types (such as Object) do not.
In order to be iterable, an object must implement the [Symbol.iterator]() method. This means that the object (or one of the objects up its prototype chain) must have a property with a Symbol.iterator key.
It may be possible to iterate over an iterable more than once, or only once. It is up to the programmer to know which is the case.
Iterables which can iterate only once (such as Generators) customarily return this from their [Symbol.iterator]() method, whereas iterables which can be iterated many times must return a new iterator on each invocation of [Symbol.iterator]().
jsfunction* makeIterator() {
  yield 1;
  yield 2;
}

const iter = makeIterator();

for (const itItem of iter) {
  console.log(itItem);
}

console.log(iter[Symbol.iterator]() === iter); // true

// This example show us generator(iterator) is iterable object,
// which has the [Symbol.iterator]() method return the `iter` (itself),
// and consequently, the it object can iterate only _once_.

// If we change the [Symbol.iterator]() method of `iter` to a function/generator
// which returns a new iterator/generator object, `iter`
// can iterate many times

iter[Symbol.iterator] = function* () {
  yield 2;
  yield 1;
};
User-defined iterablesYou can make your own iterables like this:
jsconst myIterable = {
  *[Symbol.iterator]() {
    yield 1;
    yield 2;
    yield 3;
  },
};

User-defined iterables can be used in for...of loops or the spread syntax as usual.
jsfor (const value of myIterable) {
  console.log(value);
}
// 1
// 2
// 3

[...myIterable]; // [1, 2, 3]
Built-in iterablesString, Array, TypedArray, Map and Set are all built-in iterables, because their prototype objects all have a Symbol.iterator method.Syntaxes expecting iterablesSome statements and expressions expect iterables. For example: the for...of loops, spread syntax, yield*, and destructuring syntax.
jsfor (const value of ["a", "b", "c"]) {
  console.log(value);
}
// "a"
// "b"
// "c"

[..."abc"];
// ["a", "b", "c"]

function* gen() {
  yield* ["a", "b", "c"];
}

gen().next();
// { value: "a", done: false }

[a, b, c] = new Set(["a", "b", "c"]);
a;
// "a"
Advanced generatorsGenerators compute their yielded values on demand, which allows them to efficiently represent sequences that are expensive to compute (or even infinite sequences, as demonstrated above).
The next() method also accepts a value, which can be used to modify the internal state of the generator. A value passed to next() will be received by yield.

Note:
A value passed to the first invocation of next() is always ignored.

Here is the fibonacci generator using next(x) to restart the sequence:
jsfunction* fibonacci() {
  let current = 0;
  let next = 1;
  while (true) {
    const reset = yield current;
    [current, next] = [next, next + current];
    if (reset) {
      current = 0;
      next = 1;
    }
  }
}

const sequence = fibonacci();
console.log(sequence.next().value); // 0
console.log(sequence.next().value); // 1
console.log(sequence.next().value); // 1
console.log(sequence.next().value); // 2
console.log(sequence.next().value); // 3
console.log(sequence.next().value); // 5
console.log(sequence.next().value); // 8
console.log(sequence.next(true).value); // 0
console.log(sequence.next().value); // 1
console.log(sequence.next().value); // 1
console.log(sequence.next().value); // 2

You can force a generator to throw an exception by calling its throw() method and passing the exception value it should throw. This exception will be thrown from the current suspended context of the generator, as if the yield that is currently suspended were instead a throw value statement.
If the exception is not caught from within the generator, it will propagate up through the call to throw(), and subsequent calls to next() will result in the done property being true.
Generators have a return() method that returns the given value and finishes the generator itself.
 Previous  Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 7, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIterators and generators 
 Previous  Next  
Iterators and Generators bring the concept of iteration directly into the core language and provide a mechanism for customizing the behavior of for...of loops.
For details, see also:

Iteration protocols
for...of
function* and Generator
yield and yield*
IteratorsIn JavaScript an iterator is an object which defines a sequence and potentially a return value upon its termination.
Specifically, an iterator is any object which implements the Iterator protocol by having a next() method that returns an object with two properties:

value

The next value in the iteration sequence.

done

This is true if the last value in the sequence has already been consumed. If value is present alongside done, it is the iterator's return value.


Once created, an iterator object can be iterated explicitly by repeatedly calling next(). Iterating over an iterator is said to consume the iterator, because it is generally only possible to do once. After a terminating value has been yielded additional calls to next() should continue to return {done: true}.
The most common iterator in JavaScript is the Array iterator, which returns each value in the associated array in sequence.
While it is easy to imagine that all iterators could be expressed as arrays, this is not true. Arrays must be allocated in their entirety, but iterators are consumed only as necessary. Because of this, iterators can express sequences of unlimited size, such as the range of integers between 0 and Infinity.
Here is an example which can do just that. It allows creation of a range iterator which defines a sequence of integers from start (inclusive) to end (exclusive) spaced step apart. Its final return value is the size of the sequence it created, tracked by the variable iterationCount.
jsfunction makeRangeIterator(start = 0, end = Infinity, step = 1) {
  let nextIndex = start;
  let iterationCount = 0;

  const rangeIterator = {
    next() {
      let result;
      if (nextIndex < end) {
        result = { value: nextIndex, done: false };
        nextIndex += step;
        iterationCount++;
        return result;
      }
      return { value: iterationCount, done: true };
    },
  };
  return rangeIterator;
}

Using the iterator then looks like this:
jsconst iter = makeRangeIterator(1, 10, 2);

let result = iter.next();
while (!result.done) {
  console.log(result.value); // 1 3 5 7 9
  result = iter.next();
}

console.log("Iterated over sequence of size:", result.value); // [5 numbers returned, that took interval in between: 0 to 10]


Note:
It is not possible to know reflectively whether a particular object is an iterator. If you need to do this, use Iterables.
Generator functionsWhile custom iterators are a useful tool, their creation requires careful programming due to the need to explicitly maintain their internal state. Generator functions provide a powerful alternative: they allow you to define an iterative algorithm by writing a single function whose execution is not continuous. Generator functions are written using the function* syntax.
When called, generator functions do not initially execute their code. Instead, they return a special type of iterator, called a Generator. When a value is consumed by calling the generator's next method, the Generator function executes until it encounters the yield keyword.
The function can be called as many times as desired, and returns a new Generator each time. Each Generator may only be iterated once.
We can now adapt the example from above. The behavior of this code is identical, but the implementation is much easier to write and read.
jsfunction* makeRangeIterator(start = 0, end = Infinity, step = 1) {
  let iterationCount = 0;
  for (let i = start; i < end; i += step) {
    iterationCount++;
    yield i;
  }
  return iterationCount;
}
IterablesAn object is iterable if it defines its iteration behavior, such as what values are looped over in a for...of construct. Some built-in types, such as Array or Map, have a default iteration behavior, while other types (such as Object) do not.
In order to be iterable, an object must implement the [Symbol.iterator]() method. This means that the object (or one of the objects up its prototype chain) must have a property with a Symbol.iterator key.
It may be possible to iterate over an iterable more than once, or only once. It is up to the programmer to know which is the case.
Iterables which can iterate only once (such as Generators) customarily return this from their [Symbol.iterator]() method, whereas iterables which can be iterated many times must return a new iterator on each invocation of [Symbol.iterator]().
jsfunction* makeIterator() {
  yield 1;
  yield 2;
}

const iter = makeIterator();

for (const itItem of iter) {
  console.log(itItem);
}

console.log(iter[Symbol.iterator]() === iter); // true

// This example show us generator(iterator) is iterable object,
// which has the [Symbol.iterator]() method return the `iter` (itself),
// and consequently, the it object can iterate only _once_.

// If we change the [Symbol.iterator]() method of `iter` to a function/generator
// which returns a new iterator/generator object, `iter`
// can iterate many times

iter[Symbol.iterator] = function* () {
  yield 2;
  yield 1;
};
User-defined iterablesYou can make your own iterables like this:
jsconst myIterable = {
  *[Symbol.iterator]() {
    yield 1;
    yield 2;
    yield 3;
  },
};

User-defined iterables can be used in for...of loops or the spread syntax as usual.
jsfor (const value of myIterable) {
  console.log(value);
}
// 1
// 2
// 3

[...myIterable]; // [1, 2, 3]
Built-in iterablesString, Array, TypedArray, Map and Set are all built-in iterables, because their prototype objects all have a Symbol.iterator method.Syntaxes expecting iterablesSome statements and expressions expect iterables. For example: the for...of loops, spread syntax, yield*, and destructuring syntax.
jsfor (const value of ["a", "b", "c"]) {
  console.log(value);
}
// "a"
// "b"
// "c"

[..."abc"];
// ["a", "b", "c"]

function* gen() {
  yield* ["a", "b", "c"];
}

gen().next();
// { value: "a", done: false }

[a, b, c] = new Set(["a", "b", "c"]);
a;
// "a"
Advanced generatorsGenerators compute their yielded values on demand, which allows them to efficiently represent sequences that are expensive to compute (or even infinite sequences, as demonstrated above).
The next() method also accepts a value, which can be used to modify the internal state of the generator. A value passed to next() will be received by yield.

Note:
A value passed to the first invocation of next() is always ignored.

Here is the fibonacci generator using next(x) to restart the sequence:
jsfunction* fibonacci() {
  let current = 0;
  let next = 1;
  while (true) {
    const reset = yield current;
    [current, next] = [next, next + current];
    if (reset) {
      current = 0;
      next = 1;
    }
  }
}

const sequence = fibonacci();
console.log(sequence.next().value); // 0
console.log(sequence.next().value); // 1
console.log(sequence.next().value); // 1
console.log(sequence.next().value); // 2
console.log(sequence.next().value); // 3
console.log(sequence.next().value); // 5
console.log(sequence.next().value); // 8
console.log(sequence.next(true).value); // 0
console.log(sequence.next().value); // 1
console.log(sequence.next().value); // 1
console.log(sequence.next().value); // 2

You can force a generator to throw an exception by calling its throw() method and passing the exception value it should throw. This exception will be thrown from the current suspended context of the generator, as if the yield that is currently suspended were instead a throw value statement.
If the exception is not caught from within the generator, it will propagate up through the call to throw(), and subsequent calls to next() will result in the done property being true.
Generators have a return() method that returns the given value and finishes the generator itself.
 Previous  Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 7, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nInternationalization 
 Previous  Next  
The Intl object is the namespace for the ECMAScript Internationalization API, which provides a wide range of locale- and culture-sensitive data and operations.OverviewThe Intl object is very use-case driven. It provides a separate object for each use case that requires locale-specific logic. Currently, it provides the following functionalities:

Getting information about a locale using Intl.Locale.
Formatting data using Intl.DateTimeFormat, Intl.DurationFormat, Intl.ListFormat, Intl.NumberFormat, and Intl.RelativeTimeFormat.
Collation (i.e., comparing strings for sorting or searching) using Intl.Collator.
Selecting plural forms using Intl.PluralRules.
Segmenting text into units such as words, sentences, or graphemes using Intl.Segmenter.
Getting the displayed name for currencies, languages, scripts, regions, and time zones using Intl.DisplayNames.

Most Intl APIs share a similar design (Intl.Locale is the only exception). You start by constructing an instance with the desired locale and options. This defines a set of rules for the desired operation (formatting, collation, segmentation, etc.). Then, when you call the method on the instance, such as format(), compare(), or segment(), the object applies the specified rule to the passed data.
js// 1. Construct a formatter object, specifying the locale and formatting options:
const price = new Intl.NumberFormat("en-US", {
  style: "currency",
  currency: "USD",
});

// 2. Use the `format` method of the formatter object to format a number:
console.log(price.format(5.259)); // $5.26

The general signature of the constructor is:
jsnew Intl.SomeObject(locales, options)


locales Optional

A string with a BCP 47 language tag or an Intl.Locale instance, or an array of such locale identifiers. The runtime's default locale is used when undefined is passed or when none of the specified locale identifiers is supported. For the general form and interpretation of the locales argument, see the parameter description on the Intl main page.

options Optional

An object containing properties that customize specific aspects of the operation, which is key to understanding how to use each Intl object.

Locale informationLocales underlie all behaviors of Intl. A locale is a set of conventions, represented in the Intl API by the Intl.Locale object. All Intl constructors that accept language tags also accept Intl.Locale objects.
Each locale is primarily defined by three things: a language, a script, and a region. When connected together by - in that order, they form a BCP 47 language tag.

The language is the most important part of the locale and is mandatory. When given a single language, like en or fr, there are algorithms to infer the rest of the information (see Intl.Locale.prototype.maximize()).
However, you often want to specify the region as well, because conventions can differ drastically between regions that speak the same language. For example, the date format in the US is MM/DD/YYYY, whereas in the UK it is DD/MM/YYYY, so specifying en-US or en-GB is important.
You can also specify a script. The script is the writing system, or the characters used to transcribe the language. In practice, the script is often unnecessary, because the language used in a certain region is only written in one script. However, there are exceptions such as the Serbian language, which can be written in both the Latin and Cyrillic scripts (sr-Latn and sr-Cyrl), or the Chinese language, which can be written in both the Simplified and Traditional scripts (zh-Hans and zh-Hant).

js// These two are equivalent when passed to other Intl APIs
const locale1 = new Intl.Locale("en-US");
const locale2 = new Intl.Locale("en-Latn-US");

console.log(locale1.language, locale1.script, locale1.region); // "en", undefined, "US"
console.log(locale2.language, locale2.script, locale2.region); // "en", "Latn", "US"

A locale also contains a set of conventions used by that particular culture:

Use casePropertyDescriptionExtension subtag


Date/time formatting
calendar
Used to group days into years, months, and weeks, and to assign names to them. For example, the gregory date "2022-01-01" becomes "28 Tevet 5782" in the hebrew calendar.
ca


hourCycle
Decides if times are displayed in 12-hour or 24-hour format, and whether the smallest hour number is 0 or 1.
hc


Number formatting, including dates, times, durations, etc.
numberingSystem
Transforms numbers into a locale-specific notation. The regular 0123456789 system is called latn (Latin). Often, each script has a numbering system that is just a digit-by-digit translation, but some scripts have more than one numbering system, some may not typically write numbers in that script (for example, Chinese has its own hanidec numbering system, but most texts use the standard latn system), and others may require special conversion algorithms (for example, Roman numerals — roman).
nu


Collation
collation
Defines the generic collation algorithm. For example, if you use the German phonebk collation, then "ä" is treated as "ae", and will be sorted between "ad" and "af".
co


caseFirst
Decides whether uppercase or lowercase letters should be sorted first, or if casing is ignored.
kf


numeric
Decides whether numbers are sorted as numbers or as strings. For example, if true, "10" will be sorted after "2".
kn



You can explicitly specify these properties when constructing the Intl.Locale or passing language tags to other Intl constructors. There are two ways to do this — append them to the language tag or specify them as options.

To append them to the language tag, you first append the string -u (meaning "Unicode extension"), then the extension subtag as given above, then the value.
To specify them as options, you just add the property name as given above, together with its value, to the options object.

Using Intl.DateTimeFormat as an example, both of the following lines create a formatter that formats dates in the Hebrew calendar:
jsconst df1 = new Intl.DateTimeFormat("en-US-u-ca-hebrew");
const df2 = new Intl.DateTimeFormat("en-US", { calendar: "hebrew" });

Unrecognized properties are ignored, so you can use the same syntax as above with Intl.NumberFormat, but it won't do anything different than just passing en-US, because number formatting doesn't use the calendar property.
It is tricky to get the default values of these locale conventions. new Intl.Locale("en-US").calendar returns undefined, because the Locale object only contains the information you passed to it. The default calendar is theoretically dependent on what API you are using the calendar with, so to get the default calendar of en-US as used by Intl.DateTimeFormat, you can use its resolvedOptions() method. The same goes for other properties.
jsconst locale = new Intl.Locale("en-US");
console.log(locale.calendar); // undefined; it's not provided
console.log(new Intl.DateTimeFormat(locale).resolvedOptions().calendar); // "gregory"

Intl.Locale objects do two things simultaneously: they represent a parsed BCP 47 language tag (as demonstrated above), and they provide information about that locale. All of its properties, like calendar, are extracted from the input only, without querying any data source about default values. On the other hand, it has a group of methods for querying real-world information about the locale. For example, the getCalendars(), getHourCycles(), getNumberingSystems(), and getCollations() methods complement the calendar, hourCycle, numberingSystem, and collation properties, and each returns an array of preferred values for that property.
jsconst locale = new Intl.Locale("ar-EG");
console.log(locale.getCalendars()); // ['gregory', 'coptic', 'islamic', 'islamic-civil', 'islamic-tbla']

Intl.Locale instances also contain other methods that expose useful information, such as getTextInfo(), getTimeZones(), and getWeekInfo().Figuring out the localeA shared concern for internationalization is: how do I know what locale to use?
The most obvious answer is "what the user prefers." Browsers expose the user's language preferences through the navigator.languages property. This is an array of language identifiers that can be directly passed to the formatter constructor—more on this later. The user can configure this list in their browser settings. You can also pass an empty array or undefined, which both cause the browser's default locale to be used.
jsconst numberFormatter = new Intl.NumberFormat(navigator.languages);
console.log(numberFormatter.format(1234567.89));

const numberFormatter2 = new Intl.NumberFormat([]);

However, this may not always provide the most desirable result. Strings formatted by Intl formatters represent a tiny fraction of text displayed on your site; most localized content is provided by you, the site developer. For example, suppose your site is only offered in two languages: English and French. If a Japanese user visits your site and expects to use your site in English, they will be baffled when they see the English text interleaved with numbers and dates in Japanese!
Usually, you don't want to use the browser's default language. Rather, you want to use the same language that the rest of your site is offered in. Suppose your site has a language switcher that stores the user's choice somewhere — you could directly use that.
js// Suppose this can be changed by some site-wide control
const userSettings = {
  locale: "en-US",
  colorMode: "dark",
};
const numberFormatter = new Intl.NumberFormat(userSettings.locale);
console.log(numberFormatter.format(1234567.89));

If your site has a backend that dynamically selects the language based on the user's Accept-Language header and sends back different HTML based on that, you could also use the HTML element's HTMLElement.lang property: new Intl.NumberFormat(document.documentElement.lang).
If your site is only offered in one language, you could also hardcode the locale in your code: new Intl.NumberFormat("en-US").
As previously mentioned, you can also pass an array of locales to the constructor, representing a list of fallback choices. The first example using navigator.languages is an example of this: if the first user-configured locale is not supported for the particular operation, the next one is tried, and so on, until we find a requested locale for which the runtime has data. You can do this manually as well. In the example below, we specify a list of locales in decreasing order of specificity which all represent languages likely to be understood by a Hong Kong Chinese speaker, so the formatter picks the most specific one that it supports.
jsconst numberFormatter = new Intl.NumberFormat([
  "yue-Hant",
  "zh-Hant-HK",
  "zh-Hant",
  "zh",
]);

There is no API for listing all supported locales, but there are a few methods for handling the locale list:

Intl.getCanonicalLocales(): This function takes a list of locale identifiers and returns a list of canonicalized locale identifiers. This is useful for understanding the canonicalization process for each Intl constructor.
The supportedLocalesOf() static method on each Intl object (like Intl.DateTimeFormat.supportedLocalesOf()): This method takes the same arguments as the constructor (locales and options) and returns a subset of the given locale tags that match the given data. This is useful for understanding which locales are supported by the runtime for a particular operation, for example, to show a language switcher containing only the supported languages.
Understanding the return valueThe second shared concern for all objects is "what does the method return?" This is a hard question to answer beyond the structure or type of the returned value because there's no normative specification saying what exactly should be returned. Most of the time, the result of a method is consistent. However, the output may vary between implementations, even within the same locale — output variations are by design and allowed by the specification. It may also not be what you expect. For example, the string returned by format() may use non-breaking spaces or be surrounded by bidirectional control characters. You should not compare the results of any Intl method to hardcoded constants; they should only be displayed to users.
Of course, this answer seems unsatisfactory, because most developers do wish to control what the output looks like—at least, you don't want your user to be confused by nonsensical output. Here are some guidelines if you do want to conduct testing, whether automated or manual:

Test all locales that your user may use. This is easier if you have a fixed set of supported locales (for example via a language switcher). If you are using whatever the user prefers, you may pick a few common ones for your users, but bear in mind that what the user sees could vary. You can usually mock user preference via the test runner's configuration or mocking the Intl constructors.
Test on multiple JavaScript engines. The Intl API is directly implemented by the JavaScript engine, so for example you should expect Node.js and Chrome (which both use V8) to have the same output, while Firefox (which uses SpiderMonkey) may have a different output. Although all engines likely use the CLDR data, they usually postprocess it in different ways. Some browser build settings (for reducing the install size, for example) may also affect what locales and options are supported.
Don't assume the output. This means you shouldn't write the output by hand, such as expect(result).toBe("foo"). Instead, use snapshot testing or copy the string value from the output of a test run.
Formatting dataA major use case of Intl is to output locale-specific texts representing structured data. This is similar to translation software, but instead of letting you translate arbitrary text, it takes data such as dates, numbers, and lists, and formats them according to locale-specific rules.
The Intl.DateTimeFormat, Intl.DurationFormat, Intl.ListFormat, Intl.NumberFormat, and Intl.RelativeTimeFormat objects each format one kind of data. Each instance provides two methods:

format(): Takes a piece of data and returns a string using the formatting rule as determined by the locale and options.
formatToParts(): Takes the same data and returns the same string, but broken down into parts, each part being an object with a type and a value. This is useful for more advanced use cases, such as interleaving the formatted text with other texts.

For example, here's a typical use of the Intl.NumberFormat object:
js// 1. Construct a formatter object, specifying the locale and formatting options:
const price = new Intl.NumberFormat("en-US", {
  style: "currency",
  currency: "USD",
});

// 2. Use the `format` method of the formatter object to format a number:
console.log(price.format(5.259)); // $5.26

// Or, use the `formatToParts` method to get the formatted number
// broken down into parts:
console.table(price.formatToParts(5.259));
// |   | type       | value |
// | 0 | "currency" | "$"   |
// | 1 | "integer"  | "5"   |
// | 2 | "decimal"  | "."   |
// | 3 | "fraction" | "26"  |

You don't always have to construct a formatter object in order to format strings. For casual use, you can also directly call the toLocaleString() method on the data, passing the locale and options as arguments. The toLocaleString() method is implemented by Temporal.PlainDate.prototype.toLocaleString(), Temporal.Duration.prototype.toLocaleString(), Number.prototype.toLocaleString(), and so on. Read the documentation for the data you are formatting to see if it supports toLocaleString(), and what formatter options it corresponds to.
jsconsole.log(
  (5.259).toLocaleString("en-US", {
    style: "currency",
    currency: "USD",
  }),
); // $5.26

Note that toLocaleString() is potentially less efficient than using a formatter object, because every time toLocaleString is called, it has to perform a search in a big database of localization strings. When the method is called many times with the same arguments, it is better to create a formatter object and use its format() method, because a formatter object remembers the arguments passed to it and may decide to cache a slice of the database, so future format calls can search for localization strings within a more constrained context.Date and time formattingIntl.DateTimeFormat formats dates and times, as well as ranges of dates and times. The DateTimeFormat object takes date/time inputs in one of the following forms: Date, Temporal.PlainDateTime, Temporal.PlainTime, Temporal.PlainDate, Temporal.PlainYearMonth, or Temporal.PlainMonthDay.

Note:
You can't pass a Temporal.ZonedDateTime object directly, because the time zone is already fixed in the object. You should use Temporal.ZonedDateTime.prototype.toLocaleString() or convert it to a Temporal.PlainDateTime object first.

Common use cases of localized date and time formatting are as follows:

Output the same date and time in another calendar system, such as the Islamic, Hebrew, or Chinese calendar.
Output the same real-world time (instant) but in another time zone.
Selectively output certain components of the date and time, such as only the year and month, and the specific representation of them (such as "Thursday" or "Thu").
Output the date according to locale-specific conventions, such as MM/DD/YYYY as in the U.S., DD/MM/YYYY as in the U.K., or YYYY/MM/DD as in Japan.
Output the time according to locale-specific conventions, such as 12-hour or 24-hour clock.

To decide what the formatted string looks like, you first choose the calendar (which affects the year, month, week, and day calculation) and time zone (which affects the exact time as well as possibly the date). This is done using the aforementioned calendar option (or the -ca- extension key in the locale identifier), and the timeZone option.

Date objects represent a unique instant in the user's time zone and in the ISO 8601 calendar (as reported by methods like Date.prototype.getHours() and Date.prototype.getMonth()). They are converted to the given calendar and timeZone by preserving the instant, so the date and time components may change.
The various Temporal objects already have a calendar built-in, so the calendar option must be consistent with the calendar of the object—unless the date's calendar is "iso8601", in which case it is converted to the requested calendar. These objects don't have a time zone, so they are directly displayed in the given timeZone without conversion.

Here we demonstrate how the combination of calendar and timeZone configurations result in different representations of the same instant.
js// Assume that the local time zone is UTC
const targetDate = new Date(2022, 0, 1); // 2022-01-01 midnight in the local time zone
const results = [];

for (const calendar of ["gregory", "hebrew"]) {
  for (const timeZone of ["America/New_York", "Asia/Tokyo"]) {
    const df = new Intl.DateTimeFormat("en-US", {
      calendar,
      timeZone,
      // More on these later
      dateStyle: "full",
      timeStyle: "full",
    });
    results.push({ calendar, timeZone, output: df.format(targetDate) });
  }
}

console.table(results);

The output looks like this:



calendar
timeZone
output




'gregory'
'America/New_York'
'Friday, December 31, 2021 at 7:00:00 PM Eastern Standard Time'


'gregory'
'Asia/Tokyo'
'Saturday, January 1, 2022 at 9:00:00 AM Japan Standard Time'


'hebrew'
'America/New_York'
'Friday, 27 Tevet 5782 at 7:00:00 PM Eastern Standard Time'


'hebrew'
'Asia/Tokyo'
'Saturday, 28 Tevet 5782 at 9:00:00 AM Japan Standard Time'



A date/time is comprised of the following components: weekday, era, year, month, day, dayPeriod, hour, minute, second, fractionalSecondDigits, and timeZoneName. Your next decision is what components to include in the output, and what forms they should take. You have two choices:

You can manually configure each component, using options with the same name as the component. Only the components you specify will be included in the output, with the specified form.
You can use the shortcuts dateStyle and timeStyle, which are predefined sets of components. They expand to a set of component options depending on the locale.

You should pick one of these two methods, because they are mutually exclusive. Using both methods simultaneously will result in an error.
Underlyingly, after requesting a combination of components, the DateTimeFormat object looks for a "template" that matches the requested components, so it only needs to fill in the values one by one. Not every combination of components has a predefined template. DateTimeFormat has a formatMatcher option that decides how to negotiate, by making components longer or shorter than requested, or by omitting or adding components. It gets quite technical, so you should read the Intl.DateTimeFormat() reference to better understand how it handles this.
Here, we demonstrate a few common ways to format the components:
jsconst df1 = new Intl.DateTimeFormat("en-US", {
  // Include all components (usually)
  dateStyle: "full",
  timeStyle: "full",
});

const df2 = new Intl.DateTimeFormat("en-US", {
  // Display the calendar date
  era: "short",
  year: "numeric",
  month: "long",
  day: "numeric",
});

const df3 = new Intl.DateTimeFormat("en-US", {
  // Display a time like on a digital clock
  hour: "2-digit",
  minute: "2-digit",
  second: "2-digit",
  timeZoneName: "shortOffset",
});

const targetDate = new Date(2022, 0, 1, 12, 34, 56); // 2022-01-01 12:34:56 in the local time zone
console.log(df1.format(targetDate));
// Saturday, January 1, 2022 at 12:34:56 PM Coordinated Universal Time
// January 1, 2022 AD
// 12:34:56 PM GMT

There are other customization options. For example, you can use the hourCycle option to display the time in 12-hour or 24-hour and show midnight/noon as 12:00 or 0:00. You can also use the numberingSystem option to display any numbers in another numbering system.
Apart from format(), there's a second important method, formatRange(), which formats a range of dates or times. It takes two date-times of the same type, formats each one, joins them with a range separator (like the en-dash), and deduplicates the common parts.
jsconst springBreak = {
  start: new Date(2023, 2, 10),
  end: new Date(2023, 2, 26),
};

const df = new Intl.DateTimeFormat("en-US", { dateStyle: "long" });
console.log(df.formatRange(springBreak.start, springBreak.end));
// March 10 – 26, 2023
Number formattingNumber formatting is done with the Intl.NumberFormat object. The NumberFormat object accepts inputs in the form of numbers, strings, or BigInt values. Passing a string or BigInt instead of a number allows you to format numbers that are too large or too small to be represented precisely as a JavaScript number.
Common use cases of localized number formatting are as follows:

Output the number in another numbering system (script), such as Chinese, Arabic, or Roman.
Output the number with locale-specific conventions, such as the decimal symbol ("." in English, but "," in many European cultures), or digit grouping (3 digits in English, but may be 4 or 2 in other cultures, and may use ",", " ", or ".").
Output the number with exponential notation such as "3.7 million" or "2 thousand".
Output the number as a currency, applying specific currency symbols and rounding rules. For example, monetary values less than one cent in the U.S. or less than one yen in Japan may not be meaningful to display.
Output the number as a percentage, applying locale-specific conversion and formatting rules.
Output the number with units, such as "meters" or "liters", with translated unit names.

To decide what the formatted string looks like, you first choose the numbering system (which affects the characters used for the digits). The purpose of a numbering system is already discussed in locale information. Another option you need to decide is the style, which sets the context for what the number represents, and potentially affects other options' default values. It is one of "decimal", "percent", "currency", or "unit". If you want to format currencies, then you also need to provide the currency option. If you want to format units, then you also need to provide the unit option.
jsconst results = [];
for (const options of [
  { style: "decimal" }, // Format the number as a dimensionless decimal
  { style: "percent" }, // Format the number as a percentage; it is multiplied by 100
  { style: "currency", currency: "USD" }, // Format the number as a US dollar amount
  { style: "unit", unit: "meter" }, // Format the number as a length in meters
]) {
  const nf = new Intl.NumberFormat("en-US", options);
  results.push({ style: options.style, output: nf.format(1234567.89) });
}
console.table(results);

The output looks like:



style
output




'decimal'
'1,234,567.89'


'percent'
'123,456,789%'


'currency'
'$1,234,567.89'


'unit'
'1,234,567.89 m'



The next group of options all specify what the numeric part should look like. First, you may want to represent extremely large values in a more readable way. You can set the notation option to "scientific" or "engineering", which both use the 1.23e+6 notation. The difference is that the latter uses multiples of 3 for the exponent, keeping the mantissa (the part before the e symbol) between 1 and 1000, while the former can use any integer for the exponent, keeping the mantissa between 1 and 10. You can also set notation to "compact" to use a more human-readable notation.
jsconst results = [];
for (const options of [
  { notation: "scientific" },
  { notation: "engineering" },
  { notation: "compact", compactDisplay: "short" }, // "short" is default
  { notation: "compact", compactDisplay: "long" },
]) {
  const nf = new Intl.NumberFormat("en-US", options);
  results.push({
    notation: options.compactDisplay
      ? `${options.notation}-${options.compactDisplay}`
      : options.notation,
    output: nf.format(12000),
  });
}
console.table(results);

The output looks like:



notation
output




'scientific'
'1.2E4'


'engineering'
'12E3'


'compact-short'
'12K'


'compact-long'
'12 thousand'



Then, you may want to round the number (if you specified notation, then just the mantissa part), so you don't display a number that's too long. These are the digit options, which include:

minimumIntegerDigits
minimumFractionDigits
maximumFractionDigits
minimumSignificantDigits
maximumSignificantDigits
roundingPriority
roundingIncrement
roundingMode

The exact interaction of these options is quite complex and not worth covering here. You should read the digit options reference for more detail. Nevertheless, the general idea is straightforward: we first find the number of decimal places we want to keep, then we round excess decimal places off, either rounding down or up, depending on the value of the last digit.
jsconst results = [];
for (const options of [
  { minimumFractionDigits: 4, maximumFractionDigits: 4 },
  { minimumSignificantDigits: 4, maximumSignificantDigits: 4 },
  { minimumFractionDigits: 0, maximumFractionDigits: 0, roundingMode: "floor" },
  {
    minimumFractionDigits: 0,
    maximumFractionDigits: 0,
    roundingMode: "floor",
    roundingIncrement: 10,
  },
]) {
  const nf = new Intl.NumberFormat("en-US", options);
  results.push({
    options,
    output: nf.format(1234.56789),
  });
}
console.table(results);

The output looks like this:



options
output




{ minimumFractionDigits: 4, maximumFractionDigits: 4 }
'1,234.5679'


{ minimumSignificantDigits: 4, maximumSignificantDigits: 4 }
'1,235'


{ minimumFractionDigits: 0, maximumFractionDigits: 0, roundingMode: "floor" }
'1,234'


{ minimumFractionDigits: 0, maximumFractionDigits: 0, roundingMode: "floor", roundingIncrement: 10 }
'1,230'



There are other customization options. For example, you can use the useGrouping and signDisplay options to customize whether and how to show the group separators (like "," in "1,234,567.89") and the sign. However, note that the characters used for the group separator, decimal point, and sign are locale-specific, so you can't customize them directly.
Apart from format(), there's a second important method, formatRange(), which formats a range of numbers. It takes two number representations, formats each one, joins them with a range separator (like the en-dash), and potentially deduplicates the common parts.
jsconst heightRange = {
  min: 1.63,
  max: 1.95,
};

const nf = new Intl.NumberFormat("en-US", { style: "unit", unit: "meter" });
console.log(nf.formatRange(heightRange.min, heightRange.max));
// 1.63–1.95 m
List formattingYou may already have written code that does this:
jsconst fruits = ["apple", "banana", "cherry"];
console.log(`I like ${fruits.join(", ")}.`);
// I like apple, banana, cherry.

This code is not internationalized. In some languages, the list separator is not a comma. In most languages (including English), you need a conjunction before the last item. But even just adding an "and" manually doesn't make it correct among all English speakers, because there's the debate of Oxford commas in English: "apple, banana, and cherry" vs. "apple, banana and cherry".
The Intl.ListFormat object solves this problem. It takes an array of strings and joins them in a locale-specific way such that the result represents a conjunction (and), disjunction (or), or a list of units.
jsconst fruits = ["apple", "banana", "cherry"];
const lf = new Intl.ListFormat("en-US", { style: "long", type: "conjunction" });
console.log(`I like ${lf.format(fruits)}.`);
// I like apple, banana, and cherry.

const lf = new Intl.ListFormat("en-US", { style: "long", type: "disjunction" });
console.log(`I can give you ${lf.format(fruits)}.`);
// I can give you apple, banana, or cherry.

Check Intl.ListFormat() for more examples and options.Relative time formattingIntl.RelativeTimeFormat formats a time difference. The RelativeTimeFormat object takes relative times in the form of two arguments: a number (with any sign) and a time unit, such as "day", "hour", or "minute".
It does several things at once:

It localizes and pluralizes the time unit, such as "1 day" vs. "2 days", like in number formatting.
It chooses the appropriate phrase for past and future times, such as "in 1 day" vs. "1 day ago".
It may select a special phrase for some time units, such as "1 day ago" vs. "yesterday".

jsconst rtf = new Intl.RelativeTimeFormat("en-US", { numeric: "auto" });
console.log(rtf.format(1, "day")); // tomorrow
console.log(rtf.format(2, "day")); // in 2 days
console.log(rtf.format(-1, "hour")); // 1 hour ago

Check Intl.RelativeTimeFormat() for more examples and options.Duration formattingIntl.DurationFormat provides duration formatting, such as "3 hours, 4 minutes, 5 seconds". It is not a primitive operation with its own formatter: it uses Intl.NumberFormat and Intl.ListFormat internally to format each duration component, then joins them with a list separator. The DurationFormat object takes durations in the form of a Temporal.Duration object, or a plain object with the same properties.
Apart from customizing the numbering system, the duration formatting options decides whether or not to show each component, and how long they should be.
jsconsole.log(
  new Intl.DurationFormat("en-US", {
    style: "long",
  }).format({ hours: 3, minutes: 4, seconds: 5 }),
);
// 3 hours, 4 minutes, and 5 seconds

Check Intl.DurationFormat() for more examples and options.CollationThe Intl.Collator object is useful for comparing and sorting strings. It takes two strings and returns a number indicating their relative order, in the same way as the compareFn argument of the Array.prototype.sort method.
There are many reasons why you should not use JavaScript operators like === or > to compare user-facing strings:

Irrelevant orthographic variants: For example, in English, "naïve" and "naive" are just alternative spellings of the same word and should be treated as equal.
Ignoring case: Often, you want to ignore case when comparing strings. For example, "apple" and "Apple" should be treated as equal.
Unicode code point order doesn't make sense: Comparison operators like > compare by Unicode code point order, which is not the same as the order of characters in a dictionary. For example, "ï" comes after "z" in code point order, but you would want it to be ordered next to "i" in a dictionary.
Unicode normalization: The same character may have multiple representations in Unicode. For example, "ñ" can be represented as a single character or as "n" followed by a combining tilde. (See String.prototype.normalize().) These should be treated as equal.
Number comparison: Numbers in strings should be compared as numbers, not as strings. For example, you would want "test-10" to come after "test-2".

There are two distinct use cases for collation: sorting and searching. Sorting is when you have a list of strings and you want to order them according to some rule. Searching is when you have a list of strings and you want to find a string that matches a query. When searching, you should only pay attention to whether the comparison result is zero (equal) or not, not the sign of the result.
There are many different ways to sort, even within the same locale. For example, there are two different sort orders in German, phonebook and dictionary. Phonebook sort emphasizes sound — as if "ä", "ö", and so on were expanded to "ae", "oe", and so on before sorting.
jsconst names = ["Hochberg", "Hönigswald", "Holzman"];

const germanPhonebook = new Intl.Collator("de-DE-u-co-phonebk");

// as if sorting ["Hochberg", "Hoenigswald", "Holzman"]:
console.log(names.sort(germanPhonebook.compare));
// ['Hochberg', 'Hönigswald', 'Holzman']

Some German words conjugate with extra umlauts, so in dictionaries it's sensible to order ignoring umlauts (except when ordering words differing only by umlauts: schon before schön).
jsconst germanDictionary = new Intl.Collator("de-DE-u-co-dict");

// as if sorting ["Hochberg", "Honigswald", "Holzman"]:
console.log(names.sort(germanDictionary.compare).join(", "));
// "Hochberg, Holzman, Hönigswald"
Plural rulesThe Intl.PluralRules object is useful for selecting the correct plural form of a word. It doesn't automatically pluralize words for you (for example, you can't pass it "apple" and expect "apples" back), but it tells you which plural form to use based on a number. You may already be doing this:
jsfunction formatMessage(n) {
  return `You have ${n} ${n === 1 ? "apple" : "apples"}.`;
}

But this is hard to generalize across languages, especially those with many plural forms. You can see Intl.PluralRules for a general introduction to plural rules. Here, we just demonstrate a few common use cases.
jsconst prCard = new Intl.PluralRules("en-US");
const prOrd = new Intl.PluralRules("en-US", { type: "ordinal" });

const englishOrdinalSuffixes = {
  one: "st",
  two: "nd",
  few: "rd",
  other: "th",
};

const catPlural = {
  one: "cat",
  other: "cats",
};

function formatMessage(n1, n2) {
  return `The ${n1}${englishOrdinalSuffixes[prOrd.select(n1)]} U.S. president had ${n2} ${catPlural[prCard.select(n2)]}.`;
}

console.log(formatMessage(42, 1)); // The 42nd U.S. president had 1 cat.
console.log(formatMessage(45, 0)); // The 45th U.S. president had 0 cats.
SegmentationThe Intl.Segmenter object is useful for breaking a string into segments. Without Intl, you are already able to split a string by UTF-16 code units and Unicode code points:
jsconst str = "🇺🇸🇨🇳🇷🇺🇬🇧🇫🇷";
console.log(str.split(""));
// Array(20) ['\uD83C', '\uDDFA', '\uD83C', ...]
console.log([...str]);
// Array(10) ['🇺', '🇸', '🇨', '🇳', '🇷', '🇺', '🇬', '🇧', '🇫', '🇷']

But as you can see, Unicode code points are not the same as what human users perceive as discrete characters. This often happens with emojis, where a single emoji can be represented by multiple code points. When the user interacts with text, a grapheme is the smallest unit of text they can manipulate, such as delete or select. The Segmenter object enables grapheme-level segmentation, which is useful for counting characters, measuring text width, and so on. It takes a string and returns an iterable segments object, each element of which has a segment property representing the text of the segment.
jsconst segmenter = new Intl.Segmenter("en-US", { granularity: "grapheme" });
console.log([...segmenter.segment("🇺🇸🇨🇳🇷🇺🇬🇧🇫🇷")].map((s) => s.segment));
// ['🇺🇸', '🇨🇳', '🇷🇺', '🇬🇧', '🇫🇷']

The segmenter can also do higher-level segmentation, including word-level and sentence-level splitting. These use cases are necessarily language-specific. For example, the following is a very poor implementation of word-counting:
jsconst wordCount = (str) => str.split(/ +/).length;
console.log(wordCount("Hello, world!")); // 2

There are several problems with this: not all languages use spaces to separate words, not all spaces are word-separating, and not all words are separated by spaces. To solve this, use Segmenter with granularity: "word". The result is the input string, split into segments of words and non-words. If you are counting words, you should filter out the non-words by checking each segment's isWordLike property.
jsconst segmenter = new Intl.Segmenter("en-US", { granularity: "word" });
const str = "It can even split non-space-separated words";
console.table([...segmenter.segment(str)]);
// ┌─────────────┬───────┬────────────┐
// │ segment     │ index │ isWordLike │
// ├─────────────┼───────┼────────────┤
// │ 'It'        │ 0     │ true       │
// │ ' '         │ 2     │ false      │
// │ 'can'       │ 3     │ true       │
// │ ' '         │ 6     │ false      │
// │ 'even'      │ 7     │ true       │
// │ ' '         │ 11    │ false      │
// │ 'split'     │ 12    │ true       │
// │ ' '         │ 17    │ false      │
// │ 'non'       │ 18    │ true       │
// │ '-'         │ 21    │ false      │
// │ 'space'     │ 22    │ true       │
// │ '-'         │ 27    │ false      │
// │ 'separated' │ 28    │ true       │
// │ ' '         │ 37    │ false      │
// │ 'words'     │ 38    │ true       │
// └─────────────┴───────┴────────────┘

console.log(
  [...segmenter.segment(str)].filter((s) => s.isWordLike).map((s) => s.segment),
);
// ['It', 'can', 'even', 'split', 'non', 'space', 'separated', 'words']

Word segmentation works for character-based languages too. For example, in Chinese, several characters can represent a single word, but there's no space between them. The segmenter implements the same behavior as the browser's built-in word segmentation, triggered by double-clicking a word.
jsconst segmenter = new Intl.Segmenter("zh-Hans", { granularity: "word" });
console.log([...segmenter.segment("我是这篇文档的作者")].map((s) => s.segment));
// ['我是', '这', '篇', '文', '档', '的', '作者']

Sentence segmentation is similarly complex. For example, in English, there are many punctuation marks that could mark the end of a sentence (".", "!", "?", and so on).
jsconst segmenter = new Intl.Segmenter("en-US", { granularity: "sentence" });
console.log(
  [...segmenter.segment("I ate a sandwich. Then I went to bed.")].map(
    (s) => s.segment,
  ),
);
// ['I ate a sandwich. ', 'Then I went to bed.']

Note that the segmenter doesn't remove any characters. It just splits the string into segments, each of which is a sentence. You can then remove the punctuation marks if you want. Also, the current implementation of the segmenter doesn't support sentence segmentation suppressions (preventing sentence breaks after periods like "Mr." or "Approx."), but there's ongoing work to support this.Display namesAfter introducing so many options and behaviors, you may wonder how to present them to the user. Intl comes with two useful APIs for building user interfaces: Intl.supportedValuesOf() and Intl.DisplayNames.
The Intl.supportedValuesOf() function returns an array of supported values for a given option. For example, you can use it to populate a dropdown list of supported calendars, from which users can select to display dates.
jsconst supportedCal = Intl.supportedValuesOf("calendar");
console.log(supportedCal);
// ['buddhist', 'chinese', 'coptic', 'dangi', ...]

But often, these identifiers are not user-friendly. For example, you may want to show the calendars in the user's language, or unabbreviate them. The Intl.DisplayNames object is useful for this. It's like a formatter, but it's not template-based. Instead, it is a direct mapping from language-agnostic identifiers to localized names. It supports formatting languages, regions, scripts (the three subfields of a BCP 47 tag), currency, calendar, and date-time fields.
Try the demo below:
html<select id="lang"></select>
<select id="calendar"></select>
<output id="output"></output>

output {
  display: block;
  margin: 1em;
  font-size: x-large;
}

rt {
  font-weight: bold;
}

ruby {
  border-bottom: 1px dotted;
  ruby-position: under;
  ruby-align: center;
}

jsconst langSelect = document.getElementById("lang");
const calSelect = document.getElementById("calendar");
const fieldset = document.querySelector("fieldset");
const output = document.getElementById("output");

// A few examples
const langs = [
  "en-US",
  "zh-Hans-CN",
  "ja-JP",
  "ar-EG",
  "ru-RU",
  "es-ES",
  "fr-FR",
  "de-DE",
  "hi-IN",
  "pt-BR",
  "bn-BD",
  "he-IL",
];
const calendars = Intl.supportedValuesOf("calendar");

for (const lang of langs) {
  const option = document.createElement("option");
  option.value = lang;
  option.textContent = new Intl.DisplayNames(lang, { type: "language" }).of(
    lang,
  );
  langSelect.appendChild(option);
}

function renderCalSelect() {
  const lang = langSelect.value;
  calSelect.innerHTML = "";
  const dn = new Intl.DisplayNames(lang, { type: "calendar" });
  const preferredCalendars = new Intl.Locale(lang).getCalendars?.() ?? [
    "gregory",
  ];
  for (const cal of [
    ...preferredCalendars,
    ...calendars.filter((c) => !preferredCalendars.includes(c)),
  ]) {
    const option = document.createElement("option");
    option.value = cal;
    option.textContent = dn.of(cal);
    calSelect.appendChild(option);
  }
}

function renderFieldInputs() {
  const lang = langSelect.value;
  fieldset.querySelectorAll("label").forEach((label) => label.remove());
  const dn = new Intl.DisplayNames(lang, { type: "dateTimeField" });
  for (const field of fields) {
    const label = document.createElement("label");
    label.textContent = dn.of(field);
    const input = document.createElement("input");
    input.type = "checkbox";
    input.value = field;
    label.appendChild(input);
    fieldset.appendChild(label);
  }
}

function renderTime() {
  const lang = langSelect.value;
  const cal = calSelect.value;
  const df = new Intl.DateTimeFormat(lang, {
    calendar: cal,
    dateStyle: "full",
    timeStyle: "full",
  });
  const now = new Date();
  const dn = new Intl.DisplayNames(lang, { type: "dateTimeField" });
  output.innerHTML = "";
  for (const component of df.formatToParts(now)) {
    const text = document.createElement("span");
    text.textContent = component.value;
    if (
      ![
        "era",
        "year",
        "quarter",
        "month",
        "weekOfYear",
        "weekday",
        "day",
        "dayPeriod",
        "hour",
        "minute",
        "second",
        "timeZoneName",
      ].includes(component.type)
    ) {
      output.appendChild(text);
      continue;
    }
    const title = dn.of(component.type);
    const field = document.createElement("ruby");
    field.appendChild(text);
    const rt = document.createElement("rt");
    rt.textContent = title;
    field.appendChild(rt);
    output.appendChild(field);
  }
}

renderCalSelect();
renderTime();
langSelect.addEventListener("change", renderCalSelect);
langSelect.addEventListener("change", renderTime);
calSelect.addEventListener("change", renderTime);
setInterval(renderTime, 500);


 Previous  Next\n\nInternationalization 
 Previous  Next  
The Intl object is the namespace for the ECMAScript Internationalization API, which provides a wide range of locale- and culture-sensitive data and operations.OverviewThe Intl object is very use-case driven. It provides a separate object for each use case that requires locale-specific logic. Currently, it provides the following functionalities:

Getting information about a locale using Intl.Locale.
Formatting data using Intl.DateTimeFormat, Intl.DurationFormat, Intl.ListFormat, Intl.NumberFormat, and Intl.RelativeTimeFormat.
Collation (i.e., comparing strings for sorting or searching) using Intl.Collator.
Selecting plural forms using Intl.PluralRules.
Segmenting text into units such as words, sentences, or graphemes using Intl.Segmenter.
Getting the displayed name for currencies, languages, scripts, regions, and time zones using Intl.DisplayNames.

Most Intl APIs share a similar design (Intl.Locale is the only exception). You start by constructing an instance with the desired locale and options. This defines a set of rules for the desired operation (formatting, collation, segmentation, etc.). Then, when you call the method on the instance, such as format(), compare(), or segment(), the object applies the specified rule to the passed data.
js// 1. Construct a formatter object, specifying the locale and formatting options:
const price = new Intl.NumberFormat("en-US", {
  style: "currency",
  currency: "USD",
});

// 2. Use the `format` method of the formatter object to format a number:
console.log(price.format(5.259)); // $5.26

The general signature of the constructor is:
jsnew Intl.SomeObject(locales, options)


locales Optional

A string with a BCP 47 language tag or an Intl.Locale instance, or an array of such locale identifiers. The runtime's default locale is used when undefined is passed or when none of the specified locale identifiers is supported. For the general form and interpretation of the locales argument, see the parameter description on the Intl main page.

options Optional

An object containing properties that customize specific aspects of the operation, which is key to understanding how to use each Intl object.

Locale informationLocales underlie all behaviors of Intl. A locale is a set of conventions, represented in the Intl API by the Intl.Locale object. All Intl constructors that accept language tags also accept Intl.Locale objects.
Each locale is primarily defined by three things: a language, a script, and a region. When connected together by - in that order, they form a BCP 47 language tag.

The language is the most important part of the locale and is mandatory. When given a single language, like en or fr, there are algorithms to infer the rest of the information (see Intl.Locale.prototype.maximize()).
However, you often want to specify the region as well, because conventions can differ drastically between regions that speak the same language. For example, the date format in the US is MM/DD/YYYY, whereas in the UK it is DD/MM/YYYY, so specifying en-US or en-GB is important.
You can also specify a script. The script is the writing system, or the characters used to transcribe the language. In practice, the script is often unnecessary, because the language used in a certain region is only written in one script. However, there are exceptions such as the Serbian language, which can be written in both the Latin and Cyrillic scripts (sr-Latn and sr-Cyrl), or the Chinese language, which can be written in both the Simplified and Traditional scripts (zh-Hans and zh-Hant).

js// These two are equivalent when passed to other Intl APIs
const locale1 = new Intl.Locale("en-US");
const locale2 = new Intl.Locale("en-Latn-US");

console.log(locale1.language, locale1.script, locale1.region); // "en", undefined, "US"
console.log(locale2.language, locale2.script, locale2.region); // "en", "Latn", "US"

A locale also contains a set of conventions used by that particular culture:

Use casePropertyDescriptionExtension subtag


Date/time formatting
calendar
Used to group days into years, months, and weeks, and to assign names to them. For example, the gregory date "2022-01-01" becomes "28 Tevet 5782" in the hebrew calendar.
ca


hourCycle
Decides if times are displayed in 12-hour or 24-hour format, and whether the smallest hour number is 0 or 1.
hc


Number formatting, including dates, times, durations, etc.
numberingSystem
Transforms numbers into a locale-specific notation. The regular 0123456789 system is called latn (Latin). Often, each script has a numbering system that is just a digit-by-digit translation, but some scripts have more than one numbering system, some may not typically write numbers in that script (for example, Chinese has its own hanidec numbering system, but most texts use the standard latn system), and others may require special conversion algorithms (for example, Roman numerals — roman).
nu


Collation
collation
Defines the generic collation algorithm. For example, if you use the German phonebk collation, then "ä" is treated as "ae", and will be sorted between "ad" and "af".
co


caseFirst
Decides whether uppercase or lowercase letters should be sorted first, or if casing is ignored.
kf


numeric
Decides whether numbers are sorted as numbers or as strings. For example, if true, "10" will be sorted after "2".
kn



You can explicitly specify these properties when constructing the Intl.Locale or passing language tags to other Intl constructors. There are two ways to do this — append them to the language tag or specify them as options.

To append them to the language tag, you first append the string -u (meaning "Unicode extension"), then the extension subtag as given above, then the value.
To specify them as options, you just add the property name as given above, together with its value, to the options object.

Using Intl.DateTimeFormat as an example, both of the following lines create a formatter that formats dates in the Hebrew calendar:
jsconst df1 = new Intl.DateTimeFormat("en-US-u-ca-hebrew");
const df2 = new Intl.DateTimeFormat("en-US", { calendar: "hebrew" });

Unrecognized properties are ignored, so you can use the same syntax as above with Intl.NumberFormat, but it won't do anything different than just passing en-US, because number formatting doesn't use the calendar property.
It is tricky to get the default values of these locale conventions. new Intl.Locale("en-US").calendar returns undefined, because the Locale object only contains the information you passed to it. The default calendar is theoretically dependent on what API you are using the calendar with, so to get the default calendar of en-US as used by Intl.DateTimeFormat, you can use its resolvedOptions() method. The same goes for other properties.
jsconst locale = new Intl.Locale("en-US");
console.log(locale.calendar); // undefined; it's not provided
console.log(new Intl.DateTimeFormat(locale).resolvedOptions().calendar); // "gregory"

Intl.Locale objects do two things simultaneously: they represent a parsed BCP 47 language tag (as demonstrated above), and they provide information about that locale. All of its properties, like calendar, are extracted from the input only, without querying any data source about default values. On the other hand, it has a group of methods for querying real-world information about the locale. For example, the getCalendars(), getHourCycles(), getNumberingSystems(), and getCollations() methods complement the calendar, hourCycle, numberingSystem, and collation properties, and each returns an array of preferred values for that property.
jsconst locale = new Intl.Locale("ar-EG");
console.log(locale.getCalendars()); // ['gregory', 'coptic', 'islamic', 'islamic-civil', 'islamic-tbla']

Intl.Locale instances also contain other methods that expose useful information, such as getTextInfo(), getTimeZones(), and getWeekInfo().Figuring out the localeA shared concern for internationalization is: how do I know what locale to use?
The most obvious answer is "what the user prefers." Browsers expose the user's language preferences through the navigator.languages property. This is an array of language identifiers that can be directly passed to the formatter constructor—more on this later. The user can configure this list in their browser settings. You can also pass an empty array or undefined, which both cause the browser's default locale to be used.
jsconst numberFormatter = new Intl.NumberFormat(navigator.languages);
console.log(numberFormatter.format(1234567.89));

const numberFormatter2 = new Intl.NumberFormat([]);

However, this may not always provide the most desirable result. Strings formatted by Intl formatters represent a tiny fraction of text displayed on your site; most localized content is provided by you, the site developer. For example, suppose your site is only offered in two languages: English and French. If a Japanese user visits your site and expects to use your site in English, they will be baffled when they see the English text interleaved with numbers and dates in Japanese!
Usually, you don't want to use the browser's default language. Rather, you want to use the same language that the rest of your site is offered in. Suppose your site has a language switcher that stores the user's choice somewhere — you could directly use that.
js// Suppose this can be changed by some site-wide control
const userSettings = {
  locale: "en-US",
  colorMode: "dark",
};
const numberFormatter = new Intl.NumberFormat(userSettings.locale);
console.log(numberFormatter.format(1234567.89));

If your site has a backend that dynamically selects the language based on the user's Accept-Language header and sends back different HTML based on that, you could also use the HTML element's HTMLElement.lang property: new Intl.NumberFormat(document.documentElement.lang).
If your site is only offered in one language, you could also hardcode the locale in your code: new Intl.NumberFormat("en-US").
As previously mentioned, you can also pass an array of locales to the constructor, representing a list of fallback choices. The first example using navigator.languages is an example of this: if the first user-configured locale is not supported for the particular operation, the next one is tried, and so on, until we find a requested locale for which the runtime has data. You can do this manually as well. In the example below, we specify a list of locales in decreasing order of specificity which all represent languages likely to be understood by a Hong Kong Chinese speaker, so the formatter picks the most specific one that it supports.
jsconst numberFormatter = new Intl.NumberFormat([
  "yue-Hant",
  "zh-Hant-HK",
  "zh-Hant",
  "zh",
]);

There is no API for listing all supported locales, but there are a few methods for handling the locale list:

Intl.getCanonicalLocales(): This function takes a list of locale identifiers and returns a list of canonicalized locale identifiers. This is useful for understanding the canonicalization process for each Intl constructor.
The supportedLocalesOf() static method on each Intl object (like Intl.DateTimeFormat.supportedLocalesOf()): This method takes the same arguments as the constructor (locales and options) and returns a subset of the given locale tags that match the given data. This is useful for understanding which locales are supported by the runtime for a particular operation, for example, to show a language switcher containing only the supported languages.
Understanding the return valueThe second shared concern for all objects is "what does the method return?" This is a hard question to answer beyond the structure or type of the returned value because there's no normative specification saying what exactly should be returned. Most of the time, the result of a method is consistent. However, the output may vary between implementations, even within the same locale — output variations are by design and allowed by the specification. It may also not be what you expect. For example, the string returned by format() may use non-breaking spaces or be surrounded by bidirectional control characters. You should not compare the results of any Intl method to hardcoded constants; they should only be displayed to users.
Of course, this answer seems unsatisfactory, because most developers do wish to control what the output looks like—at least, you don't want your user to be confused by nonsensical output. Here are some guidelines if you do want to conduct testing, whether automated or manual:

Test all locales that your user may use. This is easier if you have a fixed set of supported locales (for example via a language switcher). If you are using whatever the user prefers, you may pick a few common ones for your users, but bear in mind that what the user sees could vary. You can usually mock user preference via the test runner's configuration or mocking the Intl constructors.
Test on multiple JavaScript engines. The Intl API is directly implemented by the JavaScript engine, so for example you should expect Node.js and Chrome (which both use V8) to have the same output, while Firefox (which uses SpiderMonkey) may have a different output. Although all engines likely use the CLDR data, they usually postprocess it in different ways. Some browser build settings (for reducing the install size, for example) may also affect what locales and options are supported.
Don't assume the output. This means you shouldn't write the output by hand, such as expect(result).toBe("foo"). Instead, use snapshot testing or copy the string value from the output of a test run.
Formatting dataA major use case of Intl is to output locale-specific texts representing structured data. This is similar to translation software, but instead of letting you translate arbitrary text, it takes data such as dates, numbers, and lists, and formats them according to locale-specific rules.
The Intl.DateTimeFormat, Intl.DurationFormat, Intl.ListFormat, Intl.NumberFormat, and Intl.RelativeTimeFormat objects each format one kind of data. Each instance provides two methods:

format(): Takes a piece of data and returns a string using the formatting rule as determined by the locale and options.
formatToParts(): Takes the same data and returns the same string, but broken down into parts, each part being an object with a type and a value. This is useful for more advanced use cases, such as interleaving the formatted text with other texts.

For example, here's a typical use of the Intl.NumberFormat object:
js// 1. Construct a formatter object, specifying the locale and formatting options:
const price = new Intl.NumberFormat("en-US", {
  style: "currency",
  currency: "USD",
});

// 2. Use the `format` method of the formatter object to format a number:
console.log(price.format(5.259)); // $5.26

// Or, use the `formatToParts` method to get the formatted number
// broken down into parts:
console.table(price.formatToParts(5.259));
// |   | type       | value |
// | 0 | "currency" | "$"   |
// | 1 | "integer"  | "5"   |
// | 2 | "decimal"  | "."   |
// | 3 | "fraction" | "26"  |

You don't always have to construct a formatter object in order to format strings. For casual use, you can also directly call the toLocaleString() method on the data, passing the locale and options as arguments. The toLocaleString() method is implemented by Temporal.PlainDate.prototype.toLocaleString(), Temporal.Duration.prototype.toLocaleString(), Number.prototype.toLocaleString(), and so on. Read the documentation for the data you are formatting to see if it supports toLocaleString(), and what formatter options it corresponds to.
jsconsole.log(
  (5.259).toLocaleString("en-US", {
    style: "currency",
    currency: "USD",
  }),
); // $5.26

Note that toLocaleString() is potentially less efficient than using a formatter object, because every time toLocaleString is called, it has to perform a search in a big database of localization strings. When the method is called many times with the same arguments, it is better to create a formatter object and use its format() method, because a formatter object remembers the arguments passed to it and may decide to cache a slice of the database, so future format calls can search for localization strings within a more constrained context.Date and time formattingIntl.DateTimeFormat formats dates and times, as well as ranges of dates and times. The DateTimeFormat object takes date/time inputs in one of the following forms: Date, Temporal.PlainDateTime, Temporal.PlainTime, Temporal.PlainDate, Temporal.PlainYearMonth, or Temporal.PlainMonthDay.

Note:
You can't pass a Temporal.ZonedDateTime object directly, because the time zone is already fixed in the object. You should use Temporal.ZonedDateTime.prototype.toLocaleString() or convert it to a Temporal.PlainDateTime object first.

Common use cases of localized date and time formatting are as follows:

Output the same date and time in another calendar system, such as the Islamic, Hebrew, or Chinese calendar.
Output the same real-world time (instant) but in another time zone.
Selectively output certain components of the date and time, such as only the year and month, and the specific representation of them (such as "Thursday" or "Thu").
Output the date according to locale-specific conventions, such as MM/DD/YYYY as in the U.S., DD/MM/YYYY as in the U.K., or YYYY/MM/DD as in Japan.
Output the time according to locale-specific conventions, such as 12-hour or 24-hour clock.

To decide what the formatted string looks like, you first choose the calendar (which affects the year, month, week, and day calculation) and time zone (which affects the exact time as well as possibly the date). This is done using the aforementioned calendar option (or the -ca- extension key in the locale identifier), and the timeZone option.

Date objects represent a unique instant in the user's time zone and in the ISO 8601 calendar (as reported by methods like Date.prototype.getHours() and Date.prototype.getMonth()). They are converted to the given calendar and timeZone by preserving the instant, so the date and time components may change.
The various Temporal objects already have a calendar built-in, so the calendar option must be consistent with the calendar of the object—unless the date's calendar is "iso8601", in which case it is converted to the requested calendar. These objects don't have a time zone, so they are directly displayed in the given timeZone without conversion.

Here we demonstrate how the combination of calendar and timeZone configurations result in different representations of the same instant.
js// Assume that the local time zone is UTC
const targetDate = new Date(2022, 0, 1); // 2022-01-01 midnight in the local time zone
const results = [];

for (const calendar of ["gregory", "hebrew"]) {
  for (const timeZone of ["America/New_York", "Asia/Tokyo"]) {
    const df = new Intl.DateTimeFormat("en-US", {
      calendar,
      timeZone,
      // More on these later
      dateStyle: "full",
      timeStyle: "full",
    });
    results.push({ calendar, timeZone, output: df.format(targetDate) });
  }
}

console.table(results);

The output looks like this:



calendar
timeZone
output




'gregory'
'America/New_York'
'Friday, December 31, 2021 at 7:00:00 PM Eastern Standard Time'


'gregory'
'Asia/Tokyo'
'Saturday, January 1, 2022 at 9:00:00 AM Japan Standard Time'


'hebrew'
'America/New_York'
'Friday, 27 Tevet 5782 at 7:00:00 PM Eastern Standard Time'


'hebrew'
'Asia/Tokyo'
'Saturday, 28 Tevet 5782 at 9:00:00 AM Japan Standard Time'



A date/time is comprised of the following components: weekday, era, year, month, day, dayPeriod, hour, minute, second, fractionalSecondDigits, and timeZoneName. Your next decision is what components to include in the output, and what forms they should take. You have two choices:

You can manually configure each component, using options with the same name as the component. Only the components you specify will be included in the output, with the specified form.
You can use the shortcuts dateStyle and timeStyle, which are predefined sets of components. They expand to a set of component options depending on the locale.

You should pick one of these two methods, because they are mutually exclusive. Using both methods simultaneously will result in an error.
Underlyingly, after requesting a combination of components, the DateTimeFormat object looks for a "template" that matches the requested components, so it only needs to fill in the values one by one. Not every combination of components has a predefined template. DateTimeFormat has a formatMatcher option that decides how to negotiate, by making components longer or shorter than requested, or by omitting or adding components. It gets quite technical, so you should read the Intl.DateTimeFormat() reference to better understand how it handles this.
Here, we demonstrate a few common ways to format the components:
jsconst df1 = new Intl.DateTimeFormat("en-US", {
  // Include all components (usually)
  dateStyle: "full",
  timeStyle: "full",
});

const df2 = new Intl.DateTimeFormat("en-US", {
  // Display the calendar date
  era: "short",
  year: "numeric",
  month: "long",
  day: "numeric",
});

const df3 = new Intl.DateTimeFormat("en-US", {
  // Display a time like on a digital clock
  hour: "2-digit",
  minute: "2-digit",
  second: "2-digit",
  timeZoneName: "shortOffset",
});

const targetDate = new Date(2022, 0, 1, 12, 34, 56); // 2022-01-01 12:34:56 in the local time zone
console.log(df1.format(targetDate));
// Saturday, January 1, 2022 at 12:34:56 PM Coordinated Universal Time
// January 1, 2022 AD
// 12:34:56 PM GMT

There are other customization options. For example, you can use the hourCycle option to display the time in 12-hour or 24-hour and show midnight/noon as 12:00 or 0:00. You can also use the numberingSystem option to display any numbers in another numbering system.
Apart from format(), there's a second important method, formatRange(), which formats a range of dates or times. It takes two date-times of the same type, formats each one, joins them with a range separator (like the en-dash), and deduplicates the common parts.
jsconst springBreak = {
  start: new Date(2023, 2, 10),
  end: new Date(2023, 2, 26),
};

const df = new Intl.DateTimeFormat("en-US", { dateStyle: "long" });
console.log(df.formatRange(springBreak.start, springBreak.end));
// March 10 – 26, 2023
Number formattingNumber formatting is done with the Intl.NumberFormat object. The NumberFormat object accepts inputs in the form of numbers, strings, or BigInt values. Passing a string or BigInt instead of a number allows you to format numbers that are too large or too small to be represented precisely as a JavaScript number.
Common use cases of localized number formatting are as follows:

Output the number in another numbering system (script), such as Chinese, Arabic, or Roman.
Output the number with locale-specific conventions, such as the decimal symbol ("." in English, but "," in many European cultures), or digit grouping (3 digits in English, but may be 4 or 2 in other cultures, and may use ",", " ", or ".").
Output the number with exponential notation such as "3.7 million" or "2 thousand".
Output the number as a currency, applying specific currency symbols and rounding rules. For example, monetary values less than one cent in the U.S. or less than one yen in Japan may not be meaningful to display.
Output the number as a percentage, applying locale-specific conversion and formatting rules.
Output the number with units, such as "meters" or "liters", with translated unit names.

To decide what the formatted string looks like, you first choose the numbering system (which affects the characters used for the digits). The purpose of a numbering system is already discussed in locale information. Another option you need to decide is the style, which sets the context for what the number represents, and potentially affects other options' default values. It is one of "decimal", "percent", "currency", or "unit". If you want to format currencies, then you also need to provide the currency option. If you want to format units, then you also need to provide the unit option.
jsconst results = [];
for (const options of [
  { style: "decimal" }, // Format the number as a dimensionless decimal
  { style: "percent" }, // Format the number as a percentage; it is multiplied by 100
  { style: "currency", currency: "USD" }, // Format the number as a US dollar amount
  { style: "unit", unit: "meter" }, // Format the number as a length in meters
]) {
  const nf = new Intl.NumberFormat("en-US", options);
  results.push({ style: options.style, output: nf.format(1234567.89) });
}
console.table(results);

The output looks like:



style
output




'decimal'
'1,234,567.89'


'percent'
'123,456,789%'


'currency'
'$1,234,567.89'


'unit'
'1,234,567.89 m'



The next group of options all specify what the numeric part should look like. First, you may want to represent extremely large values in a more readable way. You can set the notation option to "scientific" or "engineering", which both use the 1.23e+6 notation. The difference is that the latter uses multiples of 3 for the exponent, keeping the mantissa (the part before the e symbol) between 1 and 1000, while the former can use any integer for the exponent, keeping the mantissa between 1 and 10. You can also set notation to "compact" to use a more human-readable notation.
jsconst results = [];
for (const options of [
  { notation: "scientific" },
  { notation: "engineering" },
  { notation: "compact", compactDisplay: "short" }, // "short" is default
  { notation: "compact", compactDisplay: "long" },
]) {
  const nf = new Intl.NumberFormat("en-US", options);
  results.push({
    notation: options.compactDisplay
      ? `${options.notation}-${options.compactDisplay}`
      : options.notation,
    output: nf.format(12000),
  });
}
console.table(results);

The output looks like:



notation
output




'scientific'
'1.2E4'


'engineering'
'12E3'


'compact-short'
'12K'


'compact-long'
'12 thousand'



Then, you may want to round the number (if you specified notation, then just the mantissa part), so you don't display a number that's too long. These are the digit options, which include:

minimumIntegerDigits
minimumFractionDigits
maximumFractionDigits
minimumSignificantDigits
maximumSignificantDigits
roundingPriority
roundingIncrement
roundingMode

The exact interaction of these options is quite complex and not worth covering here. You should read the digit options reference for more detail. Nevertheless, the general idea is straightforward: we first find the number of decimal places we want to keep, then we round excess decimal places off, either rounding down or up, depending on the value of the last digit.
jsconst results = [];
for (const options of [
  { minimumFractionDigits: 4, maximumFractionDigits: 4 },
  { minimumSignificantDigits: 4, maximumSignificantDigits: 4 },
  { minimumFractionDigits: 0, maximumFractionDigits: 0, roundingMode: "floor" },
  {
    minimumFractionDigits: 0,
    maximumFractionDigits: 0,
    roundingMode: "floor",
    roundingIncrement: 10,
  },
]) {
  const nf = new Intl.NumberFormat("en-US", options);
  results.push({
    options,
    output: nf.format(1234.56789),
  });
}
console.table(results);

The output looks like this:



options
output




{ minimumFractionDigits: 4, maximumFractionDigits: 4 }
'1,234.5679'


{ minimumSignificantDigits: 4, maximumSignificantDigits: 4 }
'1,235'


{ minimumFractionDigits: 0, maximumFractionDigits: 0, roundingMode: "floor" }
'1,234'


{ minimumFractionDigits: 0, maximumFractionDigits: 0, roundingMode: "floor", roundingIncrement: 10 }
'1,230'



There are other customization options. For example, you can use the useGrouping and signDisplay options to customize whether and how to show the group separators (like "," in "1,234,567.89") and the sign. However, note that the characters used for the group separator, decimal point, and sign are locale-specific, so you can't customize them directly.
Apart from format(), there's a second important method, formatRange(), which formats a range of numbers. It takes two number representations, formats each one, joins them with a range separator (like the en-dash), and potentially deduplicates the common parts.
jsconst heightRange = {
  min: 1.63,
  max: 1.95,
};

const nf = new Intl.NumberFormat("en-US", { style: "unit", unit: "meter" });
console.log(nf.formatRange(heightRange.min, heightRange.max));
// 1.63–1.95 m
List formattingYou may already have written code that does this:
jsconst fruits = ["apple", "banana", "cherry"];
console.log(`I like ${fruits.join(", ")}.`);
// I like apple, banana, cherry.

This code is not internationalized. In some languages, the list separator is not a comma. In most languages (including English), you need a conjunction before the last item. But even just adding an "and" manually doesn't make it correct among all English speakers, because there's the debate of Oxford commas in English: "apple, banana, and cherry" vs. "apple, banana and cherry".
The Intl.ListFormat object solves this problem. It takes an array of strings and joins them in a locale-specific way such that the result represents a conjunction (and), disjunction (or), or a list of units.
jsconst fruits = ["apple", "banana", "cherry"];
const lf = new Intl.ListFormat("en-US", { style: "long", type: "conjunction" });
console.log(`I like ${lf.format(fruits)}.`);
// I like apple, banana, and cherry.

const lf = new Intl.ListFormat("en-US", { style: "long", type: "disjunction" });
console.log(`I can give you ${lf.format(fruits)}.`);
// I can give you apple, banana, or cherry.

Check Intl.ListFormat() for more examples and options.Relative time formattingIntl.RelativeTimeFormat formats a time difference. The RelativeTimeFormat object takes relative times in the form of two arguments: a number (with any sign) and a time unit, such as "day", "hour", or "minute".
It does several things at once:

It localizes and pluralizes the time unit, such as "1 day" vs. "2 days", like in number formatting.
It chooses the appropriate phrase for past and future times, such as "in 1 day" vs. "1 day ago".
It may select a special phrase for some time units, such as "1 day ago" vs. "yesterday".

jsconst rtf = new Intl.RelativeTimeFormat("en-US", { numeric: "auto" });
console.log(rtf.format(1, "day")); // tomorrow
console.log(rtf.format(2, "day")); // in 2 days
console.log(rtf.format(-1, "hour")); // 1 hour ago

Check Intl.RelativeTimeFormat() for more examples and options.Duration formattingIntl.DurationFormat provides duration formatting, such as "3 hours, 4 minutes, 5 seconds". It is not a primitive operation with its own formatter: it uses Intl.NumberFormat and Intl.ListFormat internally to format each duration component, then joins them with a list separator. The DurationFormat object takes durations in the form of a Temporal.Duration object, or a plain object with the same properties.
Apart from customizing the numbering system, the duration formatting options decides whether or not to show each component, and how long they should be.
jsconsole.log(
  new Intl.DurationFormat("en-US", {
    style: "long",
  }).format({ hours: 3, minutes: 4, seconds: 5 }),
);
// 3 hours, 4 minutes, and 5 seconds

Check Intl.DurationFormat() for more examples and options.CollationThe Intl.Collator object is useful for comparing and sorting strings. It takes two strings and returns a number indicating their relative order, in the same way as the compareFn argument of the Array.prototype.sort method.
There are many reasons why you should not use JavaScript operators like === or > to compare user-facing strings:

Irrelevant orthographic variants: For example, in English, "naïve" and "naive" are just alternative spellings of the same word and should be treated as equal.
Ignoring case: Often, you want to ignore case when comparing strings. For example, "apple" and "Apple" should be treated as equal.
Unicode code point order doesn't make sense: Comparison operators like > compare by Unicode code point order, which is not the same as the order of characters in a dictionary. For example, "ï" comes after "z" in code point order, but you would want it to be ordered next to "i" in a dictionary.
Unicode normalization: The same character may have multiple representations in Unicode. For example, "ñ" can be represented as a single character or as "n" followed by a combining tilde. (See String.prototype.normalize().) These should be treated as equal.
Number comparison: Numbers in strings should be compared as numbers, not as strings. For example, you would want "test-10" to come after "test-2".

There are two distinct use cases for collation: sorting and searching. Sorting is when you have a list of strings and you want to order them according to some rule. Searching is when you have a list of strings and you want to find a string that matches a query. When searching, you should only pay attention to whether the comparison result is zero (equal) or not, not the sign of the result.
There are many different ways to sort, even within the same locale. For example, there are two different sort orders in German, phonebook and dictionary. Phonebook sort emphasizes sound — as if "ä", "ö", and so on were expanded to "ae", "oe", and so on before sorting.
jsconst names = ["Hochberg", "Hönigswald", "Holzman"];

const germanPhonebook = new Intl.Collator("de-DE-u-co-phonebk");

// as if sorting ["Hochberg", "Hoenigswald", "Holzman"]:
console.log(names.sort(germanPhonebook.compare));
// ['Hochberg', 'Hönigswald', 'Holzman']

Some German words conjugate with extra umlauts, so in dictionaries it's sensible to order ignoring umlauts (except when ordering words differing only by umlauts: schon before schön).
jsconst germanDictionary = new Intl.Collator("de-DE-u-co-dict");

// as if sorting ["Hochberg", "Honigswald", "Holzman"]:
console.log(names.sort(germanDictionary.compare).join(", "));
// "Hochberg, Holzman, Hönigswald"
Plural rulesThe Intl.PluralRules object is useful for selecting the correct plural form of a word. It doesn't automatically pluralize words for you (for example, you can't pass it "apple" and expect "apples" back), but it tells you which plural form to use based on a number. You may already be doing this:
jsfunction formatMessage(n) {
  return `You have ${n} ${n === 1 ? "apple" : "apples"}.`;
}

But this is hard to generalize across languages, especially those with many plural forms. You can see Intl.PluralRules for a general introduction to plural rules. Here, we just demonstrate a few common use cases.
jsconst prCard = new Intl.PluralRules("en-US");
const prOrd = new Intl.PluralRules("en-US", { type: "ordinal" });

const englishOrdinalSuffixes = {
  one: "st",
  two: "nd",
  few: "rd",
  other: "th",
};

const catPlural = {
  one: "cat",
  other: "cats",
};

function formatMessage(n1, n2) {
  return `The ${n1}${englishOrdinalSuffixes[prOrd.select(n1)]} U.S. president had ${n2} ${catPlural[prCard.select(n2)]}.`;
}

console.log(formatMessage(42, 1)); // The 42nd U.S. president had 1 cat.
console.log(formatMessage(45, 0)); // The 45th U.S. president had 0 cats.
SegmentationThe Intl.Segmenter object is useful for breaking a string into segments. Without Intl, you are already able to split a string by UTF-16 code units and Unicode code points:
jsconst str = "🇺🇸🇨🇳🇷🇺🇬🇧🇫🇷";
console.log(str.split(""));
// Array(20) ['\uD83C', '\uDDFA', '\uD83C', ...]
console.log([...str]);
// Array(10) ['🇺', '🇸', '🇨', '🇳', '🇷', '🇺', '🇬', '🇧', '🇫', '🇷']

But as you can see, Unicode code points are not the same as what human users perceive as discrete characters. This often happens with emojis, where a single emoji can be represented by multiple code points. When the user interacts with text, a grapheme is the smallest unit of text they can manipulate, such as delete or select. The Segmenter object enables grapheme-level segmentation, which is useful for counting characters, measuring text width, and so on. It takes a string and returns an iterable segments object, each element of which has a segment property representing the text of the segment.
jsconst segmenter = new Intl.Segmenter("en-US", { granularity: "grapheme" });
console.log([...segmenter.segment("🇺🇸🇨🇳🇷🇺🇬🇧🇫🇷")].map((s) => s.segment));
// ['🇺🇸', '🇨🇳', '🇷🇺', '🇬🇧', '🇫🇷']

The segmenter can also do higher-level segmentation, including word-level and sentence-level splitting. These use cases are necessarily language-specific. For example, the following is a very poor implementation of word-counting:
jsconst wordCount = (str) => str.split(/ +/).length;
console.log(wordCount("Hello, world!")); // 2

There are several problems with this: not all languages use spaces to separate words, not all spaces are word-separating, and not all words are separated by spaces. To solve this, use Segmenter with granularity: "word". The result is the input string, split into segments of words and non-words. If you are counting words, you should filter out the non-words by checking each segment's isWordLike property.
jsconst segmenter = new Intl.Segmenter("en-US", { granularity: "word" });
const str = "It can even split non-space-separated words";
console.table([...segmenter.segment(str)]);
// ┌─────────────┬───────┬────────────┐
// │ segment     │ index │ isWordLike │
// ├─────────────┼───────┼────────────┤
// │ 'It'        │ 0     │ true       │
// │ ' '         │ 2     │ false      │
// │ 'can'       │ 3     │ true       │
// │ ' '         │ 6     │ false      │
// │ 'even'      │ 7     │ true       │
// │ ' '         │ 11    │ false      │
// │ 'split'     │ 12    │ true       │
// │ ' '         │ 17    │ false      │
// │ 'non'       │ 18    │ true       │
// │ '-'         │ 21    │ false      │
// │ 'space'     │ 22    │ true       │
// │ '-'         │ 27    │ false      │
// │ 'separated' │ 28    │ true       │
// │ ' '         │ 37    │ false      │
// │ 'words'     │ 38    │ true       │
// └─────────────┴───────┴────────────┘

console.log(
  [...segmenter.segment(str)].filter((s) => s.isWordLike).map((s) => s.segment),
);
// ['It', 'can', 'even', 'split', 'non', 'space', 'separated', 'words']

Word segmentation works for character-based languages too. For example, in Chinese, several characters can represent a single word, but there's no space between them. The segmenter implements the same behavior as the browser's built-in word segmentation, triggered by double-clicking a word.
jsconst segmenter = new Intl.Segmenter("zh-Hans", { granularity: "word" });
console.log([...segmenter.segment("我是这篇文档的作者")].map((s) => s.segment));
// ['我是', '这', '篇', '文', '档', '的', '作者']

Sentence segmentation is similarly complex. For example, in English, there are many punctuation marks that could mark the end of a sentence (".", "!", "?", and so on).
jsconst segmenter = new Intl.Segmenter("en-US", { granularity: "sentence" });
console.log(
  [...segmenter.segment("I ate a sandwich. Then I went to bed.")].map(
    (s) => s.segment,
  ),
);
// ['I ate a sandwich. ', 'Then I went to bed.']

Note that the segmenter doesn't remove any characters. It just splits the string into segments, each of which is a sentence. You can then remove the punctuation marks if you want. Also, the current implementation of the segmenter doesn't support sentence segmentation suppressions (preventing sentence breaks after periods like "Mr." or "Approx."), but there's ongoing work to support this.Display namesAfter introducing so many options and behaviors, you may wonder how to present them to the user. Intl comes with two useful APIs for building user interfaces: Intl.supportedValuesOf() and Intl.DisplayNames.
The Intl.supportedValuesOf() function returns an array of supported values for a given option. For example, you can use it to populate a dropdown list of supported calendars, from which users can select to display dates.
jsconst supportedCal = Intl.supportedValuesOf("calendar");
console.log(supportedCal);
// ['buddhist', 'chinese', 'coptic', 'dangi', ...]

But often, these identifiers are not user-friendly. For example, you may want to show the calendars in the user's language, or unabbreviate them. The Intl.DisplayNames object is useful for this. It's like a formatter, but it's not template-based. Instead, it is a direct mapping from language-agnostic identifiers to localized names. It supports formatting languages, regions, scripts (the three subfields of a BCP 47 tag), currency, calendar, and date-time fields.
Try the demo below:
html<select id="lang"></select>
<select id="calendar"></select>
<output id="output"></output>

output {
  display: block;
  margin: 1em;
  font-size: x-large;
}

rt {
  font-weight: bold;
}

ruby {
  border-bottom: 1px dotted;
  ruby-position: under;
  ruby-align: center;
}

jsconst langSelect = document.getElementById("lang");
const calSelect = document.getElementById("calendar");
const fieldset = document.querySelector("fieldset");
const output = document.getElementById("output");

// A few examples
const langs = [
  "en-US",
  "zh-Hans-CN",
  "ja-JP",
  "ar-EG",
  "ru-RU",
  "es-ES",
  "fr-FR",
  "de-DE",
  "hi-IN",
  "pt-BR",
  "bn-BD",
  "he-IL",
];
const calendars = Intl.supportedValuesOf("calendar");

for (const lang of langs) {
  const option = document.createElement("option");
  option.value = lang;
  option.textContent = new Intl.DisplayNames(lang, { type: "language" }).of(
    lang,
  );
  langSelect.appendChild(option);
}

function renderCalSelect() {
  const lang = langSelect.value;
  calSelect.innerHTML = "";
  const dn = new Intl.DisplayNames(lang, { type: "calendar" });
  const preferredCalendars = new Intl.Locale(lang).getCalendars?.() ?? [
    "gregory",
  ];
  for (const cal of [
    ...preferredCalendars,
    ...calendars.filter((c) => !preferredCalendars.includes(c)),
  ]) {
    const option = document.createElement("option");
    option.value = cal;
    option.textContent = dn.of(cal);
    calSelect.appendChild(option);
  }
}

function renderFieldInputs() {
  const lang = langSelect.value;
  fieldset.querySelectorAll("label").forEach((label) => label.remove());
  const dn = new Intl.DisplayNames(lang, { type: "dateTimeField" });
  for (const field of fields) {
    const label = document.createElement("label");
    label.textContent = dn.of(field);
    const input = document.createElement("input");
    input.type = "checkbox";
    input.value = field;
    label.appendChild(input);
    fieldset.appendChild(label);
  }
}

function renderTime() {
  const lang = langSelect.value;
  const cal = calSelect.value;
  const df = new Intl.DateTimeFormat(lang, {
    calendar: cal,
    dateStyle: "full",
    timeStyle: "full",
  });
  const now = new Date();
  const dn = new Intl.DisplayNames(lang, { type: "dateTimeField" });
  output.innerHTML = "";
  for (const component of df.formatToParts(now)) {
    const text = document.createElement("span");
    text.textContent = component.value;
    if (
      ![
        "era",
        "year",
        "quarter",
        "month",
        "weekOfYear",
        "weekday",
        "day",
        "dayPeriod",
        "hour",
        "minute",
        "second",
        "timeZoneName",
      ].includes(component.type)
    ) {
      output.appendChild(text);
      continue;
    }
    const title = dn.of(component.type);
    const field = document.createElement("ruby");
    field.appendChild(text);
    const rt = document.createElement("rt");
    rt.textContent = title;
    field.appendChild(rt);
    output.appendChild(field);
  }
}

renderCalSelect();
renderTime();
langSelect.addEventListener("change", renderCalSelect);
langSelect.addEventListener("change", renderTime);
calSelect.addEventListener("change", renderTime);
setInterval(renderTime, 500);


 Previous  Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 26, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nInternationalization 
 Previous  Next  
The Intl object is the namespace for the ECMAScript Internationalization API, which provides a wide range of locale- and culture-sensitive data and operations.OverviewThe Intl object is very use-case driven. It provides a separate object for each use case that requires locale-specific logic. Currently, it provides the following functionalities:

Getting information about a locale using Intl.Locale.
Formatting data using Intl.DateTimeFormat, Intl.DurationFormat, Intl.ListFormat, Intl.NumberFormat, and Intl.RelativeTimeFormat.
Collation (i.e., comparing strings for sorting or searching) using Intl.Collator.
Selecting plural forms using Intl.PluralRules.
Segmenting text into units such as words, sentences, or graphemes using Intl.Segmenter.
Getting the displayed name for currencies, languages, scripts, regions, and time zones using Intl.DisplayNames.

Most Intl APIs share a similar design (Intl.Locale is the only exception). You start by constructing an instance with the desired locale and options. This defines a set of rules for the desired operation (formatting, collation, segmentation, etc.). Then, when you call the method on the instance, such as format(), compare(), or segment(), the object applies the specified rule to the passed data.
js// 1. Construct a formatter object, specifying the locale and formatting options:
const price = new Intl.NumberFormat("en-US", {
  style: "currency",
  currency: "USD",
});

// 2. Use the `format` method of the formatter object to format a number:
console.log(price.format(5.259)); // $5.26

The general signature of the constructor is:
jsnew Intl.SomeObject(locales, options)


locales Optional

A string with a BCP 47 language tag or an Intl.Locale instance, or an array of such locale identifiers. The runtime's default locale is used when undefined is passed or when none of the specified locale identifiers is supported. For the general form and interpretation of the locales argument, see the parameter description on the Intl main page.

options Optional

An object containing properties that customize specific aspects of the operation, which is key to understanding how to use each Intl object.

Locale informationLocales underlie all behaviors of Intl. A locale is a set of conventions, represented in the Intl API by the Intl.Locale object. All Intl constructors that accept language tags also accept Intl.Locale objects.
Each locale is primarily defined by three things: a language, a script, and a region. When connected together by - in that order, they form a BCP 47 language tag.

The language is the most important part of the locale and is mandatory. When given a single language, like en or fr, there are algorithms to infer the rest of the information (see Intl.Locale.prototype.maximize()).
However, you often want to specify the region as well, because conventions can differ drastically between regions that speak the same language. For example, the date format in the US is MM/DD/YYYY, whereas in the UK it is DD/MM/YYYY, so specifying en-US or en-GB is important.
You can also specify a script. The script is the writing system, or the characters used to transcribe the language. In practice, the script is often unnecessary, because the language used in a certain region is only written in one script. However, there are exceptions such as the Serbian language, which can be written in both the Latin and Cyrillic scripts (sr-Latn and sr-Cyrl), or the Chinese language, which can be written in both the Simplified and Traditional scripts (zh-Hans and zh-Hant).

js// These two are equivalent when passed to other Intl APIs
const locale1 = new Intl.Locale("en-US");
const locale2 = new Intl.Locale("en-Latn-US");

console.log(locale1.language, locale1.script, locale1.region); // "en", undefined, "US"
console.log(locale2.language, locale2.script, locale2.region); // "en", "Latn", "US"

A locale also contains a set of conventions used by that particular culture:

Use casePropertyDescriptionExtension subtag


Date/time formatting
calendar
Used to group days into years, months, and weeks, and to assign names to them. For example, the gregory date "2022-01-01" becomes "28 Tevet 5782" in the hebrew calendar.
ca


hourCycle
Decides if times are displayed in 12-hour or 24-hour format, and whether the smallest hour number is 0 or 1.
hc


Number formatting, including dates, times, durations, etc.
numberingSystem
Transforms numbers into a locale-specific notation. The regular 0123456789 system is called latn (Latin). Often, each script has a numbering system that is just a digit-by-digit translation, but some scripts have more than one numbering system, some may not typically write numbers in that script (for example, Chinese has its own hanidec numbering system, but most texts use the standard latn system), and others may require special conversion algorithms (for example, Roman numerals — roman).
nu


Collation
collation
Defines the generic collation algorithm. For example, if you use the German phonebk collation, then "ä" is treated as "ae", and will be sorted between "ad" and "af".
co


caseFirst
Decides whether uppercase or lowercase letters should be sorted first, or if casing is ignored.
kf


numeric
Decides whether numbers are sorted as numbers or as strings. For example, if true, "10" will be sorted after "2".
kn



You can explicitly specify these properties when constructing the Intl.Locale or passing language tags to other Intl constructors. There are two ways to do this — append them to the language tag or specify them as options.

To append them to the language tag, you first append the string -u (meaning "Unicode extension"), then the extension subtag as given above, then the value.
To specify them as options, you just add the property name as given above, together with its value, to the options object.

Using Intl.DateTimeFormat as an example, both of the following lines create a formatter that formats dates in the Hebrew calendar:
jsconst df1 = new Intl.DateTimeFormat("en-US-u-ca-hebrew");
const df2 = new Intl.DateTimeFormat("en-US", { calendar: "hebrew" });

Unrecognized properties are ignored, so you can use the same syntax as above with Intl.NumberFormat, but it won't do anything different than just passing en-US, because number formatting doesn't use the calendar property.
It is tricky to get the default values of these locale conventions. new Intl.Locale("en-US").calendar returns undefined, because the Locale object only contains the information you passed to it. The default calendar is theoretically dependent on what API you are using the calendar with, so to get the default calendar of en-US as used by Intl.DateTimeFormat, you can use its resolvedOptions() method. The same goes for other properties.
jsconst locale = new Intl.Locale("en-US");
console.log(locale.calendar); // undefined; it's not provided
console.log(new Intl.DateTimeFormat(locale).resolvedOptions().calendar); // "gregory"

Intl.Locale objects do two things simultaneously: they represent a parsed BCP 47 language tag (as demonstrated above), and they provide information about that locale. All of its properties, like calendar, are extracted from the input only, without querying any data source about default values. On the other hand, it has a group of methods for querying real-world information about the locale. For example, the getCalendars(), getHourCycles(), getNumberingSystems(), and getCollations() methods complement the calendar, hourCycle, numberingSystem, and collation properties, and each returns an array of preferred values for that property.
jsconst locale = new Intl.Locale("ar-EG");
console.log(locale.getCalendars()); // ['gregory', 'coptic', 'islamic', 'islamic-civil', 'islamic-tbla']

Intl.Locale instances also contain other methods that expose useful information, such as getTextInfo(), getTimeZones(), and getWeekInfo().Figuring out the localeA shared concern for internationalization is: how do I know what locale to use?
The most obvious answer is "what the user prefers." Browsers expose the user's language preferences through the navigator.languages property. This is an array of language identifiers that can be directly passed to the formatter constructor—more on this later. The user can configure this list in their browser settings. You can also pass an empty array or undefined, which both cause the browser's default locale to be used.
jsconst numberFormatter = new Intl.NumberFormat(navigator.languages);
console.log(numberFormatter.format(1234567.89));

const numberFormatter2 = new Intl.NumberFormat([]);

However, this may not always provide the most desirable result. Strings formatted by Intl formatters represent a tiny fraction of text displayed on your site; most localized content is provided by you, the site developer. For example, suppose your site is only offered in two languages: English and French. If a Japanese user visits your site and expects to use your site in English, they will be baffled when they see the English text interleaved with numbers and dates in Japanese!
Usually, you don't want to use the browser's default language. Rather, you want to use the same language that the rest of your site is offered in. Suppose your site has a language switcher that stores the user's choice somewhere — you could directly use that.
js// Suppose this can be changed by some site-wide control
const userSettings = {
  locale: "en-US",
  colorMode: "dark",
};
const numberFormatter = new Intl.NumberFormat(userSettings.locale);
console.log(numberFormatter.format(1234567.89));

If your site has a backend that dynamically selects the language based on the user's Accept-Language header and sends back different HTML based on that, you could also use the HTML element's HTMLElement.lang property: new Intl.NumberFormat(document.documentElement.lang).
If your site is only offered in one language, you could also hardcode the locale in your code: new Intl.NumberFormat("en-US").
As previously mentioned, you can also pass an array of locales to the constructor, representing a list of fallback choices. The first example using navigator.languages is an example of this: if the first user-configured locale is not supported for the particular operation, the next one is tried, and so on, until we find a requested locale for which the runtime has data. You can do this manually as well. In the example below, we specify a list of locales in decreasing order of specificity which all represent languages likely to be understood by a Hong Kong Chinese speaker, so the formatter picks the most specific one that it supports.
jsconst numberFormatter = new Intl.NumberFormat([
  "yue-Hant",
  "zh-Hant-HK",
  "zh-Hant",
  "zh",
]);

There is no API for listing all supported locales, but there are a few methods for handling the locale list:

Intl.getCanonicalLocales(): This function takes a list of locale identifiers and returns a list of canonicalized locale identifiers. This is useful for understanding the canonicalization process for each Intl constructor.
The supportedLocalesOf() static method on each Intl object (like Intl.DateTimeFormat.supportedLocalesOf()): This method takes the same arguments as the constructor (locales and options) and returns a subset of the given locale tags that match the given data. This is useful for understanding which locales are supported by the runtime for a particular operation, for example, to show a language switcher containing only the supported languages.
Understanding the return valueThe second shared concern for all objects is "what does the method return?" This is a hard question to answer beyond the structure or type of the returned value because there's no normative specification saying what exactly should be returned. Most of the time, the result of a method is consistent. However, the output may vary between implementations, even within the same locale — output variations are by design and allowed by the specification. It may also not be what you expect. For example, the string returned by format() may use non-breaking spaces or be surrounded by bidirectional control characters. You should not compare the results of any Intl method to hardcoded constants; they should only be displayed to users.
Of course, this answer seems unsatisfactory, because most developers do wish to control what the output looks like—at least, you don't want your user to be confused by nonsensical output. Here are some guidelines if you do want to conduct testing, whether automated or manual:

Test all locales that your user may use. This is easier if you have a fixed set of supported locales (for example via a language switcher). If you are using whatever the user prefers, you may pick a few common ones for your users, but bear in mind that what the user sees could vary. You can usually mock user preference via the test runner's configuration or mocking the Intl constructors.
Test on multiple JavaScript engines. The Intl API is directly implemented by the JavaScript engine, so for example you should expect Node.js and Chrome (which both use V8) to have the same output, while Firefox (which uses SpiderMonkey) may have a different output. Although all engines likely use the CLDR data, they usually postprocess it in different ways. Some browser build settings (for reducing the install size, for example) may also affect what locales and options are supported.
Don't assume the output. This means you shouldn't write the output by hand, such as expect(result).toBe("foo"). Instead, use snapshot testing or copy the string value from the output of a test run.
Formatting dataA major use case of Intl is to output locale-specific texts representing structured data. This is similar to translation software, but instead of letting you translate arbitrary text, it takes data such as dates, numbers, and lists, and formats them according to locale-specific rules.
The Intl.DateTimeFormat, Intl.DurationFormat, Intl.ListFormat, Intl.NumberFormat, and Intl.RelativeTimeFormat objects each format one kind of data. Each instance provides two methods:

format(): Takes a piece of data and returns a string using the formatting rule as determined by the locale and options.
formatToParts(): Takes the same data and returns the same string, but broken down into parts, each part being an object with a type and a value. This is useful for more advanced use cases, such as interleaving the formatted text with other texts.

For example, here's a typical use of the Intl.NumberFormat object:
js// 1. Construct a formatter object, specifying the locale and formatting options:
const price = new Intl.NumberFormat("en-US", {
  style: "currency",
  currency: "USD",
});

// 2. Use the `format` method of the formatter object to format a number:
console.log(price.format(5.259)); // $5.26

// Or, use the `formatToParts` method to get the formatted number
// broken down into parts:
console.table(price.formatToParts(5.259));
// |   | type       | value |
// | 0 | "currency" | "$"   |
// | 1 | "integer"  | "5"   |
// | 2 | "decimal"  | "."   |
// | 3 | "fraction" | "26"  |

You don't always have to construct a formatter object in order to format strings. For casual use, you can also directly call the toLocaleString() method on the data, passing the locale and options as arguments. The toLocaleString() method is implemented by Temporal.PlainDate.prototype.toLocaleString(), Temporal.Duration.prototype.toLocaleString(), Number.prototype.toLocaleString(), and so on. Read the documentation for the data you are formatting to see if it supports toLocaleString(), and what formatter options it corresponds to.
jsconsole.log(
  (5.259).toLocaleString("en-US", {
    style: "currency",
    currency: "USD",
  }),
); // $5.26

Note that toLocaleString() is potentially less efficient than using a formatter object, because every time toLocaleString is called, it has to perform a search in a big database of localization strings. When the method is called many times with the same arguments, it is better to create a formatter object and use its format() method, because a formatter object remembers the arguments passed to it and may decide to cache a slice of the database, so future format calls can search for localization strings within a more constrained context.Date and time formattingIntl.DateTimeFormat formats dates and times, as well as ranges of dates and times. The DateTimeFormat object takes date/time inputs in one of the following forms: Date, Temporal.PlainDateTime, Temporal.PlainTime, Temporal.PlainDate, Temporal.PlainYearMonth, or Temporal.PlainMonthDay.

Note:
You can't pass a Temporal.ZonedDateTime object directly, because the time zone is already fixed in the object. You should use Temporal.ZonedDateTime.prototype.toLocaleString() or convert it to a Temporal.PlainDateTime object first.

Common use cases of localized date and time formatting are as follows:

Output the same date and time in another calendar system, such as the Islamic, Hebrew, or Chinese calendar.
Output the same real-world time (instant) but in another time zone.
Selectively output certain components of the date and time, such as only the year and month, and the specific representation of them (such as "Thursday" or "Thu").
Output the date according to locale-specific conventions, such as MM/DD/YYYY as in the U.S., DD/MM/YYYY as in the U.K., or YYYY/MM/DD as in Japan.
Output the time according to locale-specific conventions, such as 12-hour or 24-hour clock.

To decide what the formatted string looks like, you first choose the calendar (which affects the year, month, week, and day calculation) and time zone (which affects the exact time as well as possibly the date). This is done using the aforementioned calendar option (or the -ca- extension key in the locale identifier), and the timeZone option.

Date objects represent a unique instant in the user's time zone and in the ISO 8601 calendar (as reported by methods like Date.prototype.getHours() and Date.prototype.getMonth()). They are converted to the given calendar and timeZone by preserving the instant, so the date and time components may change.
The various Temporal objects already have a calendar built-in, so the calendar option must be consistent with the calendar of the object—unless the date's calendar is "iso8601", in which case it is converted to the requested calendar. These objects don't have a time zone, so they are directly displayed in the given timeZone without conversion.

Here we demonstrate how the combination of calendar and timeZone configurations result in different representations of the same instant.
js// Assume that the local time zone is UTC
const targetDate = new Date(2022, 0, 1); // 2022-01-01 midnight in the local time zone
const results = [];

for (const calendar of ["gregory", "hebrew"]) {
  for (const timeZone of ["America/New_York", "Asia/Tokyo"]) {
    const df = new Intl.DateTimeFormat("en-US", {
      calendar,
      timeZone,
      // More on these later
      dateStyle: "full",
      timeStyle: "full",
    });
    results.push({ calendar, timeZone, output: df.format(targetDate) });
  }
}

console.table(results);

The output looks like this:



calendar
timeZone
output




'gregory'
'America/New_York'
'Friday, December 31, 2021 at 7:00:00 PM Eastern Standard Time'


'gregory'
'Asia/Tokyo'
'Saturday, January 1, 2022 at 9:00:00 AM Japan Standard Time'


'hebrew'
'America/New_York'
'Friday, 27 Tevet 5782 at 7:00:00 PM Eastern Standard Time'


'hebrew'
'Asia/Tokyo'
'Saturday, 28 Tevet 5782 at 9:00:00 AM Japan Standard Time'



A date/time is comprised of the following components: weekday, era, year, month, day, dayPeriod, hour, minute, second, fractionalSecondDigits, and timeZoneName. Your next decision is what components to include in the output, and what forms they should take. You have two choices:

You can manually configure each component, using options with the same name as the component. Only the components you specify will be included in the output, with the specified form.
You can use the shortcuts dateStyle and timeStyle, which are predefined sets of components. They expand to a set of component options depending on the locale.

You should pick one of these two methods, because they are mutually exclusive. Using both methods simultaneously will result in an error.
Underlyingly, after requesting a combination of components, the DateTimeFormat object looks for a "template" that matches the requested components, so it only needs to fill in the values one by one. Not every combination of components has a predefined template. DateTimeFormat has a formatMatcher option that decides how to negotiate, by making components longer or shorter than requested, or by omitting or adding components. It gets quite technical, so you should read the Intl.DateTimeFormat() reference to better understand how it handles this.
Here, we demonstrate a few common ways to format the components:
jsconst df1 = new Intl.DateTimeFormat("en-US", {
  // Include all components (usually)
  dateStyle: "full",
  timeStyle: "full",
});

const df2 = new Intl.DateTimeFormat("en-US", {
  // Display the calendar date
  era: "short",
  year: "numeric",
  month: "long",
  day: "numeric",
});

const df3 = new Intl.DateTimeFormat("en-US", {
  // Display a time like on a digital clock
  hour: "2-digit",
  minute: "2-digit",
  second: "2-digit",
  timeZoneName: "shortOffset",
});

const targetDate = new Date(2022, 0, 1, 12, 34, 56); // 2022-01-01 12:34:56 in the local time zone
console.log(df1.format(targetDate));
// Saturday, January 1, 2022 at 12:34:56 PM Coordinated Universal Time
// January 1, 2022 AD
// 12:34:56 PM GMT

There are other customization options. For example, you can use the hourCycle option to display the time in 12-hour or 24-hour and show midnight/noon as 12:00 or 0:00. You can also use the numberingSystem option to display any numbers in another numbering system.
Apart from format(), there's a second important method, formatRange(), which formats a range of dates or times. It takes two date-times of the same type, formats each one, joins them with a range separator (like the en-dash), and deduplicates the common parts.
jsconst springBreak = {
  start: new Date(2023, 2, 10),
  end: new Date(2023, 2, 26),
};

const df = new Intl.DateTimeFormat("en-US", { dateStyle: "long" });
console.log(df.formatRange(springBreak.start, springBreak.end));
// March 10 – 26, 2023
Number formattingNumber formatting is done with the Intl.NumberFormat object. The NumberFormat object accepts inputs in the form of numbers, strings, or BigInt values. Passing a string or BigInt instead of a number allows you to format numbers that are too large or too small to be represented precisely as a JavaScript number.
Common use cases of localized number formatting are as follows:

Output the number in another numbering system (script), such as Chinese, Arabic, or Roman.
Output the number with locale-specific conventions, such as the decimal symbol ("." in English, but "," in many European cultures), or digit grouping (3 digits in English, but may be 4 or 2 in other cultures, and may use ",", " ", or ".").
Output the number with exponential notation such as "3.7 million" or "2 thousand".
Output the number as a currency, applying specific currency symbols and rounding rules. For example, monetary values less than one cent in the U.S. or less than one yen in Japan may not be meaningful to display.
Output the number as a percentage, applying locale-specific conversion and formatting rules.
Output the number with units, such as "meters" or "liters", with translated unit names.

To decide what the formatted string looks like, you first choose the numbering system (which affects the characters used for the digits). The purpose of a numbering system is already discussed in locale information. Another option you need to decide is the style, which sets the context for what the number represents, and potentially affects other options' default values. It is one of "decimal", "percent", "currency", or "unit". If you want to format currencies, then you also need to provide the currency option. If you want to format units, then you also need to provide the unit option.
jsconst results = [];
for (const options of [
  { style: "decimal" }, // Format the number as a dimensionless decimal
  { style: "percent" }, // Format the number as a percentage; it is multiplied by 100
  { style: "currency", currency: "USD" }, // Format the number as a US dollar amount
  { style: "unit", unit: "meter" }, // Format the number as a length in meters
]) {
  const nf = new Intl.NumberFormat("en-US", options);
  results.push({ style: options.style, output: nf.format(1234567.89) });
}
console.table(results);

The output looks like:



style
output




'decimal'
'1,234,567.89'


'percent'
'123,456,789%'


'currency'
'$1,234,567.89'


'unit'
'1,234,567.89 m'



The next group of options all specify what the numeric part should look like. First, you may want to represent extremely large values in a more readable way. You can set the notation option to "scientific" or "engineering", which both use the 1.23e+6 notation. The difference is that the latter uses multiples of 3 for the exponent, keeping the mantissa (the part before the e symbol) between 1 and 1000, while the former can use any integer for the exponent, keeping the mantissa between 1 and 10. You can also set notation to "compact" to use a more human-readable notation.
jsconst results = [];
for (const options of [
  { notation: "scientific" },
  { notation: "engineering" },
  { notation: "compact", compactDisplay: "short" }, // "short" is default
  { notation: "compact", compactDisplay: "long" },
]) {
  const nf = new Intl.NumberFormat("en-US", options);
  results.push({
    notation: options.compactDisplay
      ? `${options.notation}-${options.compactDisplay}`
      : options.notation,
    output: nf.format(12000),
  });
}
console.table(results);

The output looks like:



notation
output




'scientific'
'1.2E4'


'engineering'
'12E3'


'compact-short'
'12K'


'compact-long'
'12 thousand'



Then, you may want to round the number (if you specified notation, then just the mantissa part), so you don't display a number that's too long. These are the digit options, which include:

minimumIntegerDigits
minimumFractionDigits
maximumFractionDigits
minimumSignificantDigits
maximumSignificantDigits
roundingPriority
roundingIncrement
roundingMode

The exact interaction of these options is quite complex and not worth covering here. You should read the digit options reference for more detail. Nevertheless, the general idea is straightforward: we first find the number of decimal places we want to keep, then we round excess decimal places off, either rounding down or up, depending on the value of the last digit.
jsconst results = [];
for (const options of [
  { minimumFractionDigits: 4, maximumFractionDigits: 4 },
  { minimumSignificantDigits: 4, maximumSignificantDigits: 4 },
  { minimumFractionDigits: 0, maximumFractionDigits: 0, roundingMode: "floor" },
  {
    minimumFractionDigits: 0,
    maximumFractionDigits: 0,
    roundingMode: "floor",
    roundingIncrement: 10,
  },
]) {
  const nf = new Intl.NumberFormat("en-US", options);
  results.push({
    options,
    output: nf.format(1234.56789),
  });
}
console.table(results);

The output looks like this:



options
output




{ minimumFractionDigits: 4, maximumFractionDigits: 4 }
'1,234.5679'


{ minimumSignificantDigits: 4, maximumSignificantDigits: 4 }
'1,235'


{ minimumFractionDigits: 0, maximumFractionDigits: 0, roundingMode: "floor" }
'1,234'


{ minimumFractionDigits: 0, maximumFractionDigits: 0, roundingMode: "floor", roundingIncrement: 10 }
'1,230'



There are other customization options. For example, you can use the useGrouping and signDisplay options to customize whether and how to show the group separators (like "," in "1,234,567.89") and the sign. However, note that the characters used for the group separator, decimal point, and sign are locale-specific, so you can't customize them directly.
Apart from format(), there's a second important method, formatRange(), which formats a range of numbers. It takes two number representations, formats each one, joins them with a range separator (like the en-dash), and potentially deduplicates the common parts.
jsconst heightRange = {
  min: 1.63,
  max: 1.95,
};

const nf = new Intl.NumberFormat("en-US", { style: "unit", unit: "meter" });
console.log(nf.formatRange(heightRange.min, heightRange.max));
// 1.63–1.95 m
List formattingYou may already have written code that does this:
jsconst fruits = ["apple", "banana", "cherry"];
console.log(`I like ${fruits.join(", ")}.`);
// I like apple, banana, cherry.

This code is not internationalized. In some languages, the list separator is not a comma. In most languages (including English), you need a conjunction before the last item. But even just adding an "and" manually doesn't make it correct among all English speakers, because there's the debate of Oxford commas in English: "apple, banana, and cherry" vs. "apple, banana and cherry".
The Intl.ListFormat object solves this problem. It takes an array of strings and joins them in a locale-specific way such that the result represents a conjunction (and), disjunction (or), or a list of units.
jsconst fruits = ["apple", "banana", "cherry"];
const lf = new Intl.ListFormat("en-US", { style: "long", type: "conjunction" });
console.log(`I like ${lf.format(fruits)}.`);
// I like apple, banana, and cherry.

const lf = new Intl.ListFormat("en-US", { style: "long", type: "disjunction" });
console.log(`I can give you ${lf.format(fruits)}.`);
// I can give you apple, banana, or cherry.

Check Intl.ListFormat() for more examples and options.Relative time formattingIntl.RelativeTimeFormat formats a time difference. The RelativeTimeFormat object takes relative times in the form of two arguments: a number (with any sign) and a time unit, such as "day", "hour", or "minute".
It does several things at once:

It localizes and pluralizes the time unit, such as "1 day" vs. "2 days", like in number formatting.
It chooses the appropriate phrase for past and future times, such as "in 1 day" vs. "1 day ago".
It may select a special phrase for some time units, such as "1 day ago" vs. "yesterday".

jsconst rtf = new Intl.RelativeTimeFormat("en-US", { numeric: "auto" });
console.log(rtf.format(1, "day")); // tomorrow
console.log(rtf.format(2, "day")); // in 2 days
console.log(rtf.format(-1, "hour")); // 1 hour ago

Check Intl.RelativeTimeFormat() for more examples and options.Duration formattingIntl.DurationFormat provides duration formatting, such as "3 hours, 4 minutes, 5 seconds". It is not a primitive operation with its own formatter: it uses Intl.NumberFormat and Intl.ListFormat internally to format each duration component, then joins them with a list separator. The DurationFormat object takes durations in the form of a Temporal.Duration object, or a plain object with the same properties.
Apart from customizing the numbering system, the duration formatting options decides whether or not to show each component, and how long they should be.
jsconsole.log(
  new Intl.DurationFormat("en-US", {
    style: "long",
  }).format({ hours: 3, minutes: 4, seconds: 5 }),
);
// 3 hours, 4 minutes, and 5 seconds

Check Intl.DurationFormat() for more examples and options.CollationThe Intl.Collator object is useful for comparing and sorting strings. It takes two strings and returns a number indicating their relative order, in the same way as the compareFn argument of the Array.prototype.sort method.
There are many reasons why you should not use JavaScript operators like === or > to compare user-facing strings:

Irrelevant orthographic variants: For example, in English, "naïve" and "naive" are just alternative spellings of the same word and should be treated as equal.
Ignoring case: Often, you want to ignore case when comparing strings. For example, "apple" and "Apple" should be treated as equal.
Unicode code point order doesn't make sense: Comparison operators like > compare by Unicode code point order, which is not the same as the order of characters in a dictionary. For example, "ï" comes after "z" in code point order, but you would want it to be ordered next to "i" in a dictionary.
Unicode normalization: The same character may have multiple representations in Unicode. For example, "ñ" can be represented as a single character or as "n" followed by a combining tilde. (See String.prototype.normalize().) These should be treated as equal.
Number comparison: Numbers in strings should be compared as numbers, not as strings. For example, you would want "test-10" to come after "test-2".

There are two distinct use cases for collation: sorting and searching. Sorting is when you have a list of strings and you want to order them according to some rule. Searching is when you have a list of strings and you want to find a string that matches a query. When searching, you should only pay attention to whether the comparison result is zero (equal) or not, not the sign of the result.
There are many different ways to sort, even within the same locale. For example, there are two different sort orders in German, phonebook and dictionary. Phonebook sort emphasizes sound — as if "ä", "ö", and so on were expanded to "ae", "oe", and so on before sorting.
jsconst names = ["Hochberg", "Hönigswald", "Holzman"];

const germanPhonebook = new Intl.Collator("de-DE-u-co-phonebk");

// as if sorting ["Hochberg", "Hoenigswald", "Holzman"]:
console.log(names.sort(germanPhonebook.compare));
// ['Hochberg', 'Hönigswald', 'Holzman']

Some German words conjugate with extra umlauts, so in dictionaries it's sensible to order ignoring umlauts (except when ordering words differing only by umlauts: schon before schön).
jsconst germanDictionary = new Intl.Collator("de-DE-u-co-dict");

// as if sorting ["Hochberg", "Honigswald", "Holzman"]:
console.log(names.sort(germanDictionary.compare).join(", "));
// "Hochberg, Holzman, Hönigswald"
Plural rulesThe Intl.PluralRules object is useful for selecting the correct plural form of a word. It doesn't automatically pluralize words for you (for example, you can't pass it "apple" and expect "apples" back), but it tells you which plural form to use based on a number. You may already be doing this:
jsfunction formatMessage(n) {
  return `You have ${n} ${n === 1 ? "apple" : "apples"}.`;
}

But this is hard to generalize across languages, especially those with many plural forms. You can see Intl.PluralRules for a general introduction to plural rules. Here, we just demonstrate a few common use cases.
jsconst prCard = new Intl.PluralRules("en-US");
const prOrd = new Intl.PluralRules("en-US", { type: "ordinal" });

const englishOrdinalSuffixes = {
  one: "st",
  two: "nd",
  few: "rd",
  other: "th",
};

const catPlural = {
  one: "cat",
  other: "cats",
};

function formatMessage(n1, n2) {
  return `The ${n1}${englishOrdinalSuffixes[prOrd.select(n1)]} U.S. president had ${n2} ${catPlural[prCard.select(n2)]}.`;
}

console.log(formatMessage(42, 1)); // The 42nd U.S. president had 1 cat.
console.log(formatMessage(45, 0)); // The 45th U.S. president had 0 cats.
SegmentationThe Intl.Segmenter object is useful for breaking a string into segments. Without Intl, you are already able to split a string by UTF-16 code units and Unicode code points:
jsconst str = "🇺🇸🇨🇳🇷🇺🇬🇧🇫🇷";
console.log(str.split(""));
// Array(20) ['\uD83C', '\uDDFA', '\uD83C', ...]
console.log([...str]);
// Array(10) ['🇺', '🇸', '🇨', '🇳', '🇷', '🇺', '🇬', '🇧', '🇫', '🇷']

But as you can see, Unicode code points are not the same as what human users perceive as discrete characters. This often happens with emojis, where a single emoji can be represented by multiple code points. When the user interacts with text, a grapheme is the smallest unit of text they can manipulate, such as delete or select. The Segmenter object enables grapheme-level segmentation, which is useful for counting characters, measuring text width, and so on. It takes a string and returns an iterable segments object, each element of which has a segment property representing the text of the segment.
jsconst segmenter = new Intl.Segmenter("en-US", { granularity: "grapheme" });
console.log([...segmenter.segment("🇺🇸🇨🇳🇷🇺🇬🇧🇫🇷")].map((s) => s.segment));
// ['🇺🇸', '🇨🇳', '🇷🇺', '🇬🇧', '🇫🇷']

The segmenter can also do higher-level segmentation, including word-level and sentence-level splitting. These use cases are necessarily language-specific. For example, the following is a very poor implementation of word-counting:
jsconst wordCount = (str) => str.split(/ +/).length;
console.log(wordCount("Hello, world!")); // 2

There are several problems with this: not all languages use spaces to separate words, not all spaces are word-separating, and not all words are separated by spaces. To solve this, use Segmenter with granularity: "word". The result is the input string, split into segments of words and non-words. If you are counting words, you should filter out the non-words by checking each segment's isWordLike property.
jsconst segmenter = new Intl.Segmenter("en-US", { granularity: "word" });
const str = "It can even split non-space-separated words";
console.table([...segmenter.segment(str)]);
// ┌─────────────┬───────┬────────────┐
// │ segment     │ index │ isWordLike │
// ├─────────────┼───────┼────────────┤
// │ 'It'        │ 0     │ true       │
// │ ' '         │ 2     │ false      │
// │ 'can'       │ 3     │ true       │
// │ ' '         │ 6     │ false      │
// │ 'even'      │ 7     │ true       │
// │ ' '         │ 11    │ false      │
// │ 'split'     │ 12    │ true       │
// │ ' '         │ 17    │ false      │
// │ 'non'       │ 18    │ true       │
// │ '-'         │ 21    │ false      │
// │ 'space'     │ 22    │ true       │
// │ '-'         │ 27    │ false      │
// │ 'separated' │ 28    │ true       │
// │ ' '         │ 37    │ false      │
// │ 'words'     │ 38    │ true       │
// └─────────────┴───────┴────────────┘

console.log(
  [...segmenter.segment(str)].filter((s) => s.isWordLike).map((s) => s.segment),
);
// ['It', 'can', 'even', 'split', 'non', 'space', 'separated', 'words']

Word segmentation works for character-based languages too. For example, in Chinese, several characters can represent a single word, but there's no space between them. The segmenter implements the same behavior as the browser's built-in word segmentation, triggered by double-clicking a word.
jsconst segmenter = new Intl.Segmenter("zh-Hans", { granularity: "word" });
console.log([...segmenter.segment("我是这篇文档的作者")].map((s) => s.segment));
// ['我是', '这', '篇', '文', '档', '的', '作者']

Sentence segmentation is similarly complex. For example, in English, there are many punctuation marks that could mark the end of a sentence (".", "!", "?", and so on).
jsconst segmenter = new Intl.Segmenter("en-US", { granularity: "sentence" });
console.log(
  [...segmenter.segment("I ate a sandwich. Then I went to bed.")].map(
    (s) => s.segment,
  ),
);
// ['I ate a sandwich. ', 'Then I went to bed.']

Note that the segmenter doesn't remove any characters. It just splits the string into segments, each of which is a sentence. You can then remove the punctuation marks if you want. Also, the current implementation of the segmenter doesn't support sentence segmentation suppressions (preventing sentence breaks after periods like "Mr." or "Approx."), but there's ongoing work to support this.Display namesAfter introducing so many options and behaviors, you may wonder how to present them to the user. Intl comes with two useful APIs for building user interfaces: Intl.supportedValuesOf() and Intl.DisplayNames.
The Intl.supportedValuesOf() function returns an array of supported values for a given option. For example, you can use it to populate a dropdown list of supported calendars, from which users can select to display dates.
jsconst supportedCal = Intl.supportedValuesOf("calendar");
console.log(supportedCal);
// ['buddhist', 'chinese', 'coptic', 'dangi', ...]

But often, these identifiers are not user-friendly. For example, you may want to show the calendars in the user's language, or unabbreviate them. The Intl.DisplayNames object is useful for this. It's like a formatter, but it's not template-based. Instead, it is a direct mapping from language-agnostic identifiers to localized names. It supports formatting languages, regions, scripts (the three subfields of a BCP 47 tag), currency, calendar, and date-time fields.
Try the demo below:
html<select id="lang"></select>
<select id="calendar"></select>
<output id="output"></output>

output {
  display: block;
  margin: 1em;
  font-size: x-large;
}

rt {
  font-weight: bold;
}

ruby {
  border-bottom: 1px dotted;
  ruby-position: under;
  ruby-align: center;
}

jsconst langSelect = document.getElementById("lang");
const calSelect = document.getElementById("calendar");
const fieldset = document.querySelector("fieldset");
const output = document.getElementById("output");

// A few examples
const langs = [
  "en-US",
  "zh-Hans-CN",
  "ja-JP",
  "ar-EG",
  "ru-RU",
  "es-ES",
  "fr-FR",
  "de-DE",
  "hi-IN",
  "pt-BR",
  "bn-BD",
  "he-IL",
];
const calendars = Intl.supportedValuesOf("calendar");

for (const lang of langs) {
  const option = document.createElement("option");
  option.value = lang;
  option.textContent = new Intl.DisplayNames(lang, { type: "language" }).of(
    lang,
  );
  langSelect.appendChild(option);
}

function renderCalSelect() {
  const lang = langSelect.value;
  calSelect.innerHTML = "";
  const dn = new Intl.DisplayNames(lang, { type: "calendar" });
  const preferredCalendars = new Intl.Locale(lang).getCalendars?.() ?? [
    "gregory",
  ];
  for (const cal of [
    ...preferredCalendars,
    ...calendars.filter((c) => !preferredCalendars.includes(c)),
  ]) {
    const option = document.createElement("option");
    option.value = cal;
    option.textContent = dn.of(cal);
    calSelect.appendChild(option);
  }
}

function renderFieldInputs() {
  const lang = langSelect.value;
  fieldset.querySelectorAll("label").forEach((label) => label.remove());
  const dn = new Intl.DisplayNames(lang, { type: "dateTimeField" });
  for (const field of fields) {
    const label = document.createElement("label");
    label.textContent = dn.of(field);
    const input = document.createElement("input");
    input.type = "checkbox";
    input.value = field;
    label.appendChild(input);
    fieldset.appendChild(label);
  }
}

function renderTime() {
  const lang = langSelect.value;
  const cal = calSelect.value;
  const df = new Intl.DateTimeFormat(lang, {
    calendar: cal,
    dateStyle: "full",
    timeStyle: "full",
  });
  const now = new Date();
  const dn = new Intl.DisplayNames(lang, { type: "dateTimeField" });
  output.innerHTML = "";
  for (const component of df.formatToParts(now)) {
    const text = document.createElement("span");
    text.textContent = component.value;
    if (
      ![
        "era",
        "year",
        "quarter",
        "month",
        "weekOfYear",
        "weekday",
        "day",
        "dayPeriod",
        "hour",
        "minute",
        "second",
        "timeZoneName",
      ].includes(component.type)
    ) {
      output.appendChild(text);
      continue;
    }
    const title = dn.of(component.type);
    const field = document.createElement("ruby");
    field.appendChild(text);
    const rt = document.createElement("rt");
    rt.textContent = title;
    field.appendChild(rt);
    output.appendChild(field);
  }
}

renderCalSelect();
renderTime();
langSelect.addEventListener("change", renderCalSelect);
langSelect.addEventListener("change", renderTime);
calSelect.addEventListener("change", renderTime);
setInterval(renderTime, 500);


 Previous  Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 26, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nMeta programming Previous  Next  
The Proxy and Reflect objects allow you to intercept and define custom behavior for fundamental language operations (e.g., property lookup, assignment, enumeration, function invocation, etc.). With the help of these two objects you are able to program at the meta level of JavaScript.ProxiesProxy objects allow you to intercept certain operations and to implement custom behaviors.
For example, getting a property on an object:
jsconst handler = {
  get(target, name) {
    return name in target ? target[name] : 42;
  },
};

const p = new Proxy({}, handler);
p.a = 1;
console.log(p.a, p.b); // 1, 42

The Proxy object defines a target (an empty object here) and a handler object, in which a get trap is implemented. Here, an object that is proxied will not return undefined when getting undefined properties, but will instead return the number 42.
Additional examples are available on the Proxy reference page.TerminologyThe following terms are used when talking about the functionality of proxies.

handler

Placeholder object which contains traps.

traps

The methods that provide property access. (This is analogous to the concept of traps in operating systems.)

target

Object which the proxy virtualizes. It is often used as storage backend for the proxy. Invariants (semantics that remain unchanged) regarding object non-extensibility or non-configurable properties are verified against the target.

invariants

Semantics that remain unchanged when implementing custom operations are called invariants. If you violate the invariants of a handler, a TypeError will be thrown.

Handlers and trapsThe following table summarizes the available traps available to Proxy objects. See the reference pages for detailed explanations and examples.

  
    
      Handler / trap
      Interceptions
    
  
  
    
      
        handler.getPrototypeOf()
      
      
        Object.getPrototypeOf()Reflect.getPrototypeOf()__proto__Object.prototype.isPrototypeOf()instanceof
      
    
    
      
        handler.setPrototypeOf()
      
      
        Object.setPrototypeOf()Reflect.setPrototypeOf()
      
    
    
      
        handler.isExtensible()
      
      
        Object.isExtensible()Reflect.isExtensible()
      
    
    
      
        handler.preventExtensions()
      
      
        Object.preventExtensions()Reflect.preventExtensions()
      
    
    
      
        handler.getOwnPropertyDescriptor()
      
      
        Object.getOwnPropertyDescriptor()Reflect.getOwnPropertyDescriptor()
      
    
    
      
        handler.defineProperty()
      
      
        Object.defineProperty()Reflect.defineProperty()
      
    
    
      
        handler.has()
      
      
        
          Property query
          foo in proxy
          Inherited property query
          
            foo in Object.create(proxy)Reflect.has()
          
        
      
    
    
      
        handler.get()
      
      
        
          Property access
          
            proxy[foo]proxy.bar
          
          Inherited property access
          
            
            Object.create(proxy)[foo]Reflect.get()
          
        
      
    
    
      
        handler.set()
      
      
        
          Property assignment
          
            proxy[foo] = barproxy.foo = bar
          
          Inherited property assignment
          
            Object.create(proxy)[foo] = barReflect.set()
          
            
        
      
    
    
      
        handler.deleteProperty()
      
      
        
          Property deletion
          
            delete proxy[foo]delete proxy.fooReflect.deleteProperty()
          
        
      
    
    
      
        handler.ownKeys()
      
      
        Object.getOwnPropertyNames()Object.getOwnPropertySymbols()Object.keys()Reflect.ownKeys()
      
    
    
      
        handler.apply()
      
      
        proxy(..args)Function.prototype.apply() and
        Function.prototype.call()Reflect.apply()
      
    
    
      
        handler.construct()
      
      
        new proxy(...args)Reflect.construct()
      
    
  
Revocable ProxyThe Proxy.revocable() method is used to create a revocable Proxy object. This means that the proxy can be revoked via the function revoke and switches the proxy off.
Afterwards, any operation on the proxy leads to a TypeError.
jsconst revocable = Proxy.revocable(
  {},
  {
    get(target, name) {
      return `[[${name}]]`;
    },
  },
);
const proxy = revocable.proxy;
console.log(proxy.foo); // "[[foo]]"

revocable.revoke();

console.log(proxy.foo); // TypeError: Cannot perform 'get' on a proxy that has been revoked
proxy.foo = 1; // TypeError: Cannot perform 'set' on a proxy that has been revoked
delete proxy.foo; // TypeError: Cannot perform 'deleteProperty' on a proxy that has been revoked
console.log(typeof proxy); // "object", typeof doesn't trigger any trap
ReflectionReflect is a built-in object that provides methods for interceptable JavaScript operations. The methods are the same as those of the proxy handler's.
Reflect is not a function object.
Reflect helps with forwarding default operations from the handler to the target.
With Reflect.has() for example, you get the in operator as a function:
jsReflect.has(Object, "assign"); // true
A better apply() functionBefore Reflect, you typically use the Function.prototype.apply() method to call a function with a given this value and arguments provided as an array (or an array-like object).
jsFunction.prototype.apply.call(Math.floor, undefined, [1.75]);

With Reflect.apply this becomes less verbose and easier to understand:
jsReflect.apply(Math.floor, undefined, [1.75]);
// 1

Reflect.apply(String.fromCharCode, undefined, [104, 101, 108, 108, 111]);
// "hello"

Reflect.apply(RegExp.prototype.exec, /ab/, ["confabulation"]).index;
// 4

Reflect.apply("".charAt, "ponies", [3]);
// "i"
Checking if property definition has been successfulWith Object.defineProperty, which returns an object if successful, or throws a TypeError otherwise, you would use a try...catch block to catch any error that occurred while defining a property. Because Reflect.defineProperty() returns a Boolean success status, you can just use an if...else block here:
jsif (Reflect.defineProperty(target, property, attributes)) {
  // success
} else {
  // failure
}

 Previous  Next\n\nMeta programming Previous  Next  
The Proxy and Reflect objects allow you to intercept and define custom behavior for fundamental language operations (e.g., property lookup, assignment, enumeration, function invocation, etc.). With the help of these two objects you are able to program at the meta level of JavaScript.ProxiesProxy objects allow you to intercept certain operations and to implement custom behaviors.
For example, getting a property on an object:
jsconst handler = {
  get(target, name) {
    return name in target ? target[name] : 42;
  },
};

const p = new Proxy({}, handler);
p.a = 1;
console.log(p.a, p.b); // 1, 42

The Proxy object defines a target (an empty object here) and a handler object, in which a get trap is implemented. Here, an object that is proxied will not return undefined when getting undefined properties, but will instead return the number 42.
Additional examples are available on the Proxy reference page.TerminologyThe following terms are used when talking about the functionality of proxies.

handler

Placeholder object which contains traps.

traps

The methods that provide property access. (This is analogous to the concept of traps in operating systems.)

target

Object which the proxy virtualizes. It is often used as storage backend for the proxy. Invariants (semantics that remain unchanged) regarding object non-extensibility or non-configurable properties are verified against the target.

invariants

Semantics that remain unchanged when implementing custom operations are called invariants. If you violate the invariants of a handler, a TypeError will be thrown.

Handlers and trapsThe following table summarizes the available traps available to Proxy objects. See the reference pages for detailed explanations and examples.

  
    
      Handler / trap
      Interceptions
    
  
  
    
      
        handler.getPrototypeOf()
      
      
        Object.getPrototypeOf()Reflect.getPrototypeOf()__proto__Object.prototype.isPrototypeOf()instanceof
      
    
    
      
        handler.setPrototypeOf()
      
      
        Object.setPrototypeOf()Reflect.setPrototypeOf()
      
    
    
      
        handler.isExtensible()
      
      
        Object.isExtensible()Reflect.isExtensible()
      
    
    
      
        handler.preventExtensions()
      
      
        Object.preventExtensions()Reflect.preventExtensions()
      
    
    
      
        handler.getOwnPropertyDescriptor()
      
      
        Object.getOwnPropertyDescriptor()Reflect.getOwnPropertyDescriptor()
      
    
    
      
        handler.defineProperty()
      
      
        Object.defineProperty()Reflect.defineProperty()
      
    
    
      
        handler.has()
      
      
        
          Property query
          foo in proxy
          Inherited property query
          
            foo in Object.create(proxy)Reflect.has()
          
        
      
    
    
      
        handler.get()
      
      
        
          Property access
          
            proxy[foo]proxy.bar
          
          Inherited property access
          
            
            Object.create(proxy)[foo]Reflect.get()
          
        
      
    
    
      
        handler.set()
      
      
        
          Property assignment
          
            proxy[foo] = barproxy.foo = bar
          
          Inherited property assignment
          
            Object.create(proxy)[foo] = barReflect.set()
          
            
        
      
    
    
      
        handler.deleteProperty()
      
      
        
          Property deletion
          
            delete proxy[foo]delete proxy.fooReflect.deleteProperty()
          
        
      
    
    
      
        handler.ownKeys()
      
      
        Object.getOwnPropertyNames()Object.getOwnPropertySymbols()Object.keys()Reflect.ownKeys()
      
    
    
      
        handler.apply()
      
      
        proxy(..args)Function.prototype.apply() and
        Function.prototype.call()Reflect.apply()
      
    
    
      
        handler.construct()
      
      
        new proxy(...args)Reflect.construct()
      
    
  
Revocable ProxyThe Proxy.revocable() method is used to create a revocable Proxy object. This means that the proxy can be revoked via the function revoke and switches the proxy off.
Afterwards, any operation on the proxy leads to a TypeError.
jsconst revocable = Proxy.revocable(
  {},
  {
    get(target, name) {
      return `[[${name}]]`;
    },
  },
);
const proxy = revocable.proxy;
console.log(proxy.foo); // "[[foo]]"

revocable.revoke();

console.log(proxy.foo); // TypeError: Cannot perform 'get' on a proxy that has been revoked
proxy.foo = 1; // TypeError: Cannot perform 'set' on a proxy that has been revoked
delete proxy.foo; // TypeError: Cannot perform 'deleteProperty' on a proxy that has been revoked
console.log(typeof proxy); // "object", typeof doesn't trigger any trap
ReflectionReflect is a built-in object that provides methods for interceptable JavaScript operations. The methods are the same as those of the proxy handler's.
Reflect is not a function object.
Reflect helps with forwarding default operations from the handler to the target.
With Reflect.has() for example, you get the in operator as a function:
jsReflect.has(Object, "assign"); // true
A better apply() functionBefore Reflect, you typically use the Function.prototype.apply() method to call a function with a given this value and arguments provided as an array (or an array-like object).
jsFunction.prototype.apply.call(Math.floor, undefined, [1.75]);

With Reflect.apply this becomes less verbose and easier to understand:
jsReflect.apply(Math.floor, undefined, [1.75]);
// 1

Reflect.apply(String.fromCharCode, undefined, [104, 101, 108, 108, 111]);
// "hello"

Reflect.apply(RegExp.prototype.exec, /ab/, ["confabulation"]).index;
// 4

Reflect.apply("".charAt, "ponies", [3]);
// "i"
Checking if property definition has been successfulWith Object.defineProperty, which returns an object if successful, or throws a TypeError otherwise, you would use a try...catch block to catch any error that occurred while defining a property. Because Reflect.defineProperty() returns a Boolean success status, you can just use an if...else block here:
jsif (Reflect.defineProperty(target, property, attributes)) {
  // success
} else {
  // failure
}

 Previous  Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nMeta programming Previous  Next  
The Proxy and Reflect objects allow you to intercept and define custom behavior for fundamental language operations (e.g., property lookup, assignment, enumeration, function invocation, etc.). With the help of these two objects you are able to program at the meta level of JavaScript.ProxiesProxy objects allow you to intercept certain operations and to implement custom behaviors.
For example, getting a property on an object:
jsconst handler = {
  get(target, name) {
    return name in target ? target[name] : 42;
  },
};

const p = new Proxy({}, handler);
p.a = 1;
console.log(p.a, p.b); // 1, 42

The Proxy object defines a target (an empty object here) and a handler object, in which a get trap is implemented. Here, an object that is proxied will not return undefined when getting undefined properties, but will instead return the number 42.
Additional examples are available on the Proxy reference page.TerminologyThe following terms are used when talking about the functionality of proxies.

handler

Placeholder object which contains traps.

traps

The methods that provide property access. (This is analogous to the concept of traps in operating systems.)

target

Object which the proxy virtualizes. It is often used as storage backend for the proxy. Invariants (semantics that remain unchanged) regarding object non-extensibility or non-configurable properties are verified against the target.

invariants

Semantics that remain unchanged when implementing custom operations are called invariants. If you violate the invariants of a handler, a TypeError will be thrown.

Handlers and trapsThe following table summarizes the available traps available to Proxy objects. See the reference pages for detailed explanations and examples.

  
    
      Handler / trap
      Interceptions
    
  
  
    
      
        handler.getPrototypeOf()
      
      
        Object.getPrototypeOf()Reflect.getPrototypeOf()__proto__Object.prototype.isPrototypeOf()instanceof
      
    
    
      
        handler.setPrototypeOf()
      
      
        Object.setPrototypeOf()Reflect.setPrototypeOf()
      
    
    
      
        handler.isExtensible()
      
      
        Object.isExtensible()Reflect.isExtensible()
      
    
    
      
        handler.preventExtensions()
      
      
        Object.preventExtensions()Reflect.preventExtensions()
      
    
    
      
        handler.getOwnPropertyDescriptor()
      
      
        Object.getOwnPropertyDescriptor()Reflect.getOwnPropertyDescriptor()
      
    
    
      
        handler.defineProperty()
      
      
        Object.defineProperty()Reflect.defineProperty()
      
    
    
      
        handler.has()
      
      
        
          Property query
          foo in proxy
          Inherited property query
          
            foo in Object.create(proxy)Reflect.has()
          
        
      
    
    
      
        handler.get()
      
      
        
          Property access
          
            proxy[foo]proxy.bar
          
          Inherited property access
          
            
            Object.create(proxy)[foo]Reflect.get()
          
        
      
    
    
      
        handler.set()
      
      
        
          Property assignment
          
            proxy[foo] = barproxy.foo = bar
          
          Inherited property assignment
          
            Object.create(proxy)[foo] = barReflect.set()
          
            
        
      
    
    
      
        handler.deleteProperty()
      
      
        
          Property deletion
          
            delete proxy[foo]delete proxy.fooReflect.deleteProperty()
          
        
      
    
    
      
        handler.ownKeys()
      
      
        Object.getOwnPropertyNames()Object.getOwnPropertySymbols()Object.keys()Reflect.ownKeys()
      
    
    
      
        handler.apply()
      
      
        proxy(..args)Function.prototype.apply() and
        Function.prototype.call()Reflect.apply()
      
    
    
      
        handler.construct()
      
      
        new proxy(...args)Reflect.construct()
      
    
  
Revocable ProxyThe Proxy.revocable() method is used to create a revocable Proxy object. This means that the proxy can be revoked via the function revoke and switches the proxy off.
Afterwards, any operation on the proxy leads to a TypeError.
jsconst revocable = Proxy.revocable(
  {},
  {
    get(target, name) {
      return `[[${name}]]`;
    },
  },
);
const proxy = revocable.proxy;
console.log(proxy.foo); // "[[foo]]"

revocable.revoke();

console.log(proxy.foo); // TypeError: Cannot perform 'get' on a proxy that has been revoked
proxy.foo = 1; // TypeError: Cannot perform 'set' on a proxy that has been revoked
delete proxy.foo; // TypeError: Cannot perform 'deleteProperty' on a proxy that has been revoked
console.log(typeof proxy); // "object", typeof doesn't trigger any trap
ReflectionReflect is a built-in object that provides methods for interceptable JavaScript operations. The methods are the same as those of the proxy handler's.
Reflect is not a function object.
Reflect helps with forwarding default operations from the handler to the target.
With Reflect.has() for example, you get the in operator as a function:
jsReflect.has(Object, "assign"); // true
A better apply() functionBefore Reflect, you typically use the Function.prototype.apply() method to call a function with a given this value and arguments provided as an array (or an array-like object).
jsFunction.prototype.apply.call(Math.floor, undefined, [1.75]);

With Reflect.apply this becomes less verbose and easier to understand:
jsReflect.apply(Math.floor, undefined, [1.75]);
// 1

Reflect.apply(String.fromCharCode, undefined, [104, 101, 108, 108, 111]);
// "hello"

Reflect.apply(RegExp.prototype.exec, /ab/, ["confabulation"]).index;
// 4

Reflect.apply("".charAt, "ponies", [3]);
// "i"
Checking if property definition has been successfulWith Object.defineProperty, which returns an object if successful, or throws a TypeError otherwise, you would use a try...catch block to catch any error that occurred while defining a property. Because Reflect.defineProperty() returns a Boolean success status, you can just use an if...else block here:
jsif (Reflect.defineProperty(target, property, attributes)) {
  // success
} else {
  // failure
}

 Previous  Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJavaScript modules Previous 
This guide gives you all you need to get started with JavaScript module syntax.A background on modulesJavaScript programs started off pretty small — most of its usage in the early days was to do isolated scripting tasks, providing a bit of interactivity to your web pages where needed, so large scripts were generally not needed. Fast forward a few years and we now have complete applications being run in browsers with a lot of JavaScript, as well as JavaScript being used in other contexts (Node.js, for example).
Complex projects necessitate a mechanism for splitting JavaScript programs into separate modules that can be imported when needed. Node.js has had this ability for a long time, and there are a number of JavaScript libraries and frameworks that enable module usage (for example, other CommonJS and AMD-based module systems like RequireJS, webpack, and Babel).
All modern browsers support module features natively without needing transpilation. It can only be a good thing — browsers can optimize loading of modules, making it more efficient than having to use a library and do all of that extra client-side processing and extra round trips. It does not obsolete bundlers like webpack, though — bundlers still do a good job at partitioning code into reasonably sized chunks, and are able to do other optimizations like minification, dead code elimination, and tree-shaking.Introducing an exampleTo demonstrate usage of modules, we've created a set of examples that you can find on GitHub. These examples demonstrate a set of modules that create a <canvas> element on a webpage, and then draw (and report information about) different shapes on the canvas.
These are fairly trivial, but have been kept deliberately simple to demonstrate modules clearly.

Note:
If you want to download the examples and run them locally, you'll need to run them through a local web server.
Basic example structureIn our first example (see basic-modules) we have a file structure as follows:
index.html
main.js
modules/
    canvas.js
    square.js


Note:
All of the examples in this guide have basically the same structure; the above should start getting pretty familiar.

The modules directory's two modules are described below:


canvas.js — contains functions related to setting up the canvas:

create() — creates a canvas with a specified width and height inside a wrapper <div> with a specified ID, which is itself appended inside a specified parent element. Returns an object containing the canvas's 2D context and the wrapper's ID.
createReportList() — creates an unordered list appended inside a specified wrapper element, which can be used to output report data into. Returns the list's ID.



square.js — contains:

name — a constant containing the string 'square'.
draw() — draws a square on a specified canvas, with a specified size, position, and color. Returns an object containing the square's size, position, and color.
reportArea() — writes a square's area to a specific report list, given its length.
reportPerimeter() — writes a square's perimeter to a specific report list, given its length.


Aside — .mjs versus .jsThroughout this article, we've used .js extensions for our module files, but in other resources you may see the .mjs extension used instead. V8's documentation recommends this, for example. The reasons given are:

It is good for clarity, i.e., it makes it clear which files are modules, and which are regular JavaScript.
It ensures that your module files are parsed as a module by runtimes such as Node.js, and build tools such as Babel.

However, we decided to keep using .js, at least for the moment. To get modules to work correctly in a browser, you need to make sure that your server is serving them with a Content-Type header that contains a JavaScript MIME type such as text/javascript. If you don't, you'll get a strict MIME type checking error along the lines of "The server responded with a non-JavaScript MIME type" and the browser won't run your JavaScript. Most servers already set the correct type for .js files, but not yet for .mjs files. Servers that already serve .mjs files correctly include GitHub Pages and http-server for Node.js.
This is OK if you are using such an environment already, or if you aren't but you know what you are doing and have access (i.e., you can configure your server to set the correct Content-Type for .mjs files). It could however cause confusion if you don't control the server you are serving files from, or are publishing files for public use, as we are here.
For learning and portability purposes, we decided to keep to .js.
If you really value the clarity of using .mjs for modules versus using .js for "normal" JavaScript files, but don't want to run into the problem described above, you could always use .mjs during development and convert them to .js during your build step.
It is also worth noting that:

Some tools may never support .mjs.
The <script type="module"> attribute is used to denote when a module is being pointed to, as you'll see below.
Exporting module featuresThe first thing you do to get access to module features is export them. This is done using the export statement.
The easiest way to use it is to place it in front of any items you want exported out of the module, for example:
jsexport const name = "square";

export function draw(ctx, length, x, y, color) {
  ctx.fillStyle = color;
  ctx.fillRect(x, y, length, length);

  return { length, x, y, color };
}

You can export functions, var, let, const, and — as we'll see later — classes. They need to be top-level items: for example, you can't use export inside a function.
A more convenient way of exporting all the items you want to export is to use a single export statement at the end of your module file, followed by a comma-separated list of the features you want to export wrapped in curly braces. For example:
jsexport { name, draw, reportArea, reportPerimeter };
Importing features into your scriptOnce you've exported some features out of your module, you need to import them into your script to be able to use them. The simplest way to do this is as follows:
jsimport { name, draw, reportArea, reportPerimeter } from "./modules/square.js";

You use the import statement, followed by a comma-separated list of the features you want to import wrapped in curly braces, followed by the keyword from, followed by the module specifier.
The module specifier provides a string that the JavaScript environment can resolve to a path to the module file.
In a browser, this could be a path relative to the site root, which for our basic-modules example would be /js-examples/module-examples/basic-modules.
However, here we are instead using the dot (.) syntax to mean "the current location", followed by the relative path to the file we are trying to find. This is much better than writing out the entire absolute path each time, as relative paths are shorter and make the URL portable — the example will still work if you move it to a different location in the site hierarchy.
So for example:
bash/js-examples/module-examples/basic-modules/modules/square.js

becomes
bash./modules/square.js

You can see such lines in action in main.js.

Note:
In some module systems, you can use a module specifier like modules/square that isn't a relative or absolute path, and that doesn't have a file extension.
This kind of specifier can be used in a browser environment if you first define an import map.

Once you've imported the features into your script, you can use them just like they were defined inside the same file. The following is found in main.js, below the import lines:
jsconst myCanvas = create("myCanvas", document.body, 480, 320);
const reportList = createReportList(myCanvas.id);

const square1 = draw(myCanvas.ctx, 50, 50, 100, "blue");
reportArea(square1.length, reportList);
reportPerimeter(square1.length, reportList);


Note:
The imported values are read-only views of the features that were exported. Similar to const variables, you cannot re-assign the variable that was imported, but you can still modify properties of object values. The value can only be re-assigned by the module exporting it. See the import reference for an example.
Importing modules using import mapsAbove we saw how a browser can import a module using a module specifier that is either an absolute URL, or a relative URL that is resolved using the base URL of the document:
jsimport { name as squareName, draw } from "./shapes/square.js";
import { name as circleName } from "https://example.com/shapes/circle.js";

Import maps allow developers to instead specify almost any text they want in the module specifier when importing a module; the map provides a corresponding value that will replace the text when the module URL is resolved.
For example, the imports key in the import map below defines a "module specifier map" JSON object where the property names can be used as module specifiers, and the corresponding values will be substituted when the browser resolves the module URL.
The values must be absolute or relative URLs.
Relative URLs are resolved to absolute URL addresses using the base URL of the document containing the import map.
html<script type="importmap">
  {
    "imports": {
      "shapes": "./shapes/square.js",
      "shapes/square": "./modules/shapes/square.js",
      "https://example.com/shapes/square.js": "./shapes/square.js",
      "https://example.com/shapes/": "/shapes/square/",
      "../shapes/square": "./shapes/square.js"
    }
  }
</script>

The import map is defined using a JSON object inside a <script> element with the type attribute set to importmap.
Note that an import map only applies to the document — the specification does not cover how to apply an import map in a worker or worklet context. 
With this map you can now use the property names above as module specifiers.
If there is no trailing forward slash on the module specifier key then the whole module specifier key is matched and substituted.
For example, below we match bare module names, and remap a URL to another path.
js// Bare module names as module specifiers
import { name as squareNameOne } from "shapes";
import { name as squareNameTwo } from "shapes/square";

// Remap a URL to another URL
import { name as squareNameThree } from "https://example.com/shapes/square.js";

If the module specifier has a trailing forward slash then the value must have one as well, and the key is matched as a "path prefix".
This allows remapping of whole classes of URLs.
js// Remap a URL as a prefix ( https://example.com/shapes/)
import { name as squareNameFour } from "https://example.com/shapes/moduleshapes/square.js";

It is possible for multiple keys in an import map to be valid matches for a module specifier.
For example, a module specifier of shapes/circle/ could match the module specifier keys shapes/ and shapes/circle/.
In this case the browser will select the most specific (longest) matching module specifier key.
Import maps allow modules to be imported using bare module names (as in Node.js), and can also simulate importing modules from packages, both with and without file extensions.
While not shown above, they also allow particular versions of a library to be imported, based on the path of the script that is importing the module.
Generally they let developers write more ergonomic import code, and make it easier to manage the different versions and dependencies of modules used by a site.
This can reduce the effort required to use the same JavaScript libraries in both browser and server.
The following sections expand on the various features outlined above.Feature detectionYou can check support for import maps using the HTMLScriptElement.supports() static method (which is itself broadly supported):
jsif (HTMLScriptElement.supports?.("importmap")) {
  console.log("Browser supports import maps.");
}
Importing modules as bare namesIn some JavaScript environments, such as Node.js, you can use bare names for the module specifier.
This works because the environment can resolve module names to a standard location in the file system.
For example, you might use the following syntax to import the "square" module.
jsimport { name, draw, reportArea, reportPerimeter } from "square";

To use bare names on a browser you need an import map, which provides the information needed by the browser to resolve module specifiers to URLs (JavaScript will throw a TypeError if it attempts to import a module specifier that can't be resolved to a module location).
Below you can see a map that defines a square module specifier key, which in this case maps to a relative address value.
html<script type="importmap">
  {
    "imports": {
      "square": "./shapes/square.js"
    }
  }
</script>

With this map we can now use a bare name when we import the module:
jsimport { name as squareName, draw } from "square";
Remapping module pathsModule specifier map entries, where both the specifier key and its associated value have a trailing forward slash (/), can be used as a path-prefix.
This allows the remapping of a whole set of import URLs from one location to another.
It can also be used to emulate working with "packages and modules", such as you might see in the Node ecosystem.

Note:
The trailing / indicates that the module specifier key can be substituted as part of a module specifier.
If this is not present, the browser will only match (and substitute) the whole module specifier key.

Packages of modules
The following JSON import map definition maps lodash as a bare name, and the module specifier prefix lodash/ to the path /node_modules/lodash-es/ (resolved to the document base URL):
json{
  "imports": {
    "lodash": "/node_modules/lodash-es/lodash.js",
    "lodash/": "/node_modules/lodash-es/"
  }
}

With this mapping you can import both the whole "package", using the bare name, and modules within it (using the path mapping):
jsimport _ from "lodash";
import fp from "lodash/fp.js";

It is possible to import fp above without the .js file extension, but you would need to create a bare module specifier key for that file, such as lodash/fp, rather than using the path.
This may be reasonable for just one module, but scales poorly if you wish to import many modules.
General URL remapping
A module specifier key doesn't have to be path — it can also be an absolute URL (or a URL-like relative path like ./, ../, /).
This may be useful if you want to remap a module that has absolute paths to a resource with your own local resources.
json{
  "imports": {
    "https://www.unpkg.com/moment/": "/node_modules/moment/"
  }
}
Scoped modules for version managementEcosystems like Node use package managers such as npm to manage modules and their dependencies.
The package manager ensures that each module is separated from other modules and their dependencies.
As a result, while a complex application might include the same module multiple times with several different versions in different parts of the module graph, users do not need to think about this complexity.

Note:
You can also achieve version management using relative paths, but this is subpar because, among other things, this forces a particular structure on your project, and prevents you from using bare module names.

Import maps similarly allow you to have multiple versions of dependencies in your application and refer to them using the same module specifier.
You implement this with the scopes key, which allows you to provide module specifier maps that will be used depending on the path of the script performing the import.
The example below demonstrates this.
json{
  "imports": {
    "cool-module": "/node_modules/cool-module/index.js"
  },
  "scopes": {
    "/node_modules/dependency/": {
      "cool-module": "/node_modules/some/other/location/cool-module/index.js"
    }
  }
}

With this mapping, if a script with an URL that contains /node_modules/dependency/ imports cool-module, the version in /node_modules/some/other/location/cool-module/index.js will be used.
The map in imports is used as a fallback if there is no matching scope in the scoped map, or the matching scopes don't contain a matching specifier. For example, if cool-module is imported from a script with a non-matching scope path, then the module specifier map in imports will be used instead, mapping to the version in /node_modules/cool-module/index.js.
Note that the path used to select a scope does not affect how the address is resolved.
The value in the mapped path does not have to match the scopes path, and relative paths are still resolved to the base URL of the script that contains the import map.
Just as for module specifier maps, you can have many scope keys, and these may contain overlapping paths.
If multiple scopes match the referrer URL, then the most specific scope path is checked first (the longest scope key) for a matching specifier.
The browsers will fall back to the next most specific matching scoped path if there is no matching specifier, and so on.
If there is no matching specifier in any of the matching scopes, the browser checks for a match in the module specifier map in the imports key.Improve caching by mapping away hashed filenamesScript files used by websites often have hashed filenames to simplify caching.
The downside of this approach is that if a module changes, any modules that import it using its hashed filename will also need to be updated/regenerated.
This potentially results in a cascade of updates, which is wasteful of network resources.
Import maps provide a convenient solution to this problem.
Rather than depending on specific hashed filenames, applications and scripts instead depend on an un-hashed version of the module name (address).
An import map like the one below then provides a mapping to the actual script file.
json{
  "imports": {
    "main_script": "/node/srcs/application-fg7744e1b.js",
    "dependency_script": "/node/srcs/dependency-3qn7e4b1q.js"
  }
}

If dependency_script changes, then its hash contained in the file name changes as well. In this case, we only need to update the import map to reflect the changed name of the module.
We don't have to update the source of any JavaScript code that depends on it, because the specifier in the import statement does not change.Loading non-JavaScript resourcesOne exciting feature that a unified module architecture brings is the ability to load non-JavaScript resources as modules. For example, you can import JSON as a JavaScript object, or import CSS as a CSSStyleSheet object.
You must explicitly declare what kind of resource you are importing. By default, the browser assumes that the resource is JavaScript, and will throw an error if the resolved resource is something else. To import JSON, CSS, or other types of resource, use the import attributes syntax:
jsimport colors from "./colors.json" with { type: "json" };
import styles from "./styles.css" with { type: "css" };

Browsers will also perform validation on the module type, and fail if, for example, ./data.json does not resolve to a JSON file. This ensures that you don't accidentally execute code when you just intend to import data. Once imported successfully, you can now use the imported value as a normal JavaScript object or CSSStyleSheet object.
jsconsole.log(colors.map((color) => color.value));
document.adoptedStyleSheets = [styles];
Applying the module to your HTMLNow we just need to apply the main.js module to our HTML page. This is very similar to how we apply a regular script to a page, with a few notable differences.
First of all, you need to include type="module" in the <script> element, to declare this script as a module. To import the main.js script, we use this:
html<script type="module" src="main.js"></script>

You can also embed the module's script directly into the HTML file by placing the JavaScript code within the body of the <script> element:
html<script type="module">
  /* JavaScript module code here */
</script>

You can only use import and export statements inside modules, not regular scripts. An error will be thrown if your <script> element doesn't have the type="module" attribute and attempts to import other modules. For example:
html<script>
  import _ from "lodash"; // SyntaxError: import declarations may only appear at top level of a module
  // ...
</script>
<script src="a-module-using-import-statements.js"></script>
<!-- SyntaxError: import declarations may only appear at top level of a module -->

You should generally define all your modules in separate files. Modules declared inline in HTML can only import other modules, but anything they export will not be accessible by other modules (because they don't have a URL).

Note:
Modules and their dependencies can be preloaded by specifying them in <link> elements with rel="modulepreload".
This can significantly reduce load time when the modules are used.
Other differences between modules and classic scripts
You need to pay attention to local testing — if you try to load the HTML file locally (i.e., with a file:// URL), you'll run into CORS errors due to JavaScript module security requirements. You need to do your testing through a server.
Also, note that you might get different behavior from sections of script defined inside modules as opposed to in classic scripts. This is because modules use strict mode automatically.
There is no need to use the defer attribute (see <script> attributes) when loading a module script; modules are deferred automatically.
Modules are only executed once, even if they have been referenced in multiple <script> tags.
Last but not least, let's make this clear — module features are imported into the scope of a single script — they aren't available in the global scope. Therefore, you will only be able to access imported features in the script they are imported into, and you won't be able to access them from the JavaScript console, for example. You'll still get syntax errors shown in the DevTools, but you'll not be able to use some of the debugging techniques you might have expected to use.

Module-defined variables are scoped to the module unless explicitly attached to the global object. On the other hand, globally-defined variables are available within the module. For example, given the following code:
html<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8" />
    <title></title>
    <link rel="stylesheet" href="" />
  </head>
  <body>
    <div id="main"></div>
    <script>
      // A var statement creates a global variable.
      var text = "Hello";
    </script>
    <script type="module" src="./render.js"></script>
  </body>
</html>

js/* render.js */
document.getElementById("main").innerText = text;

The page would still render Hello, because the global variables text and document are available in the module. (Also note from this example that a module doesn't necessarily need an import/export statement — the only thing needed is for the entry point to have type="module".)Default exports versus named exportsThe functionality we've exported so far has been comprised of named exports — each item (be it a function, const, etc.) has been referred to by its name upon export, and that name has been used to refer to it on import as well.
There is also a type of export called the default export — this is designed to make it easy to have a default function provided by a module, and also helps JavaScript modules to interoperate with existing CommonJS and AMD module systems (as explained nicely in ES6 In Depth: Modules by Jason Orendorff; search for "Default exports").
Let's look at an example as we explain how it works. In our basic-modules square.js you can find a function called randomSquare() that creates a square with a random color, size, and position. We want to export this as our default, so at the bottom of the file we write this:
jsexport default randomSquare;

Note the lack of curly braces.
We could instead prepend export default onto the function and define it as an anonymous function, like this:
jsexport default function (ctx) {
  // …
}

Over in our main.js file, we import the default function using this line:
jsimport randomSquare from "./modules/square.js";

Again, note the lack of curly braces. This is because there is only one default export allowed per module, and we know that randomSquare is it. The above line is basically shorthand for:
jsimport { default as randomSquare } from "./modules/square.js";


Note:
The as syntax for renaming exported items is explained below in the Renaming imports and exports section.
Avoiding naming conflictsSo far, our canvas shape drawing modules seem to be working OK. But what happens if we try to add a module that deals with drawing another shape, like a circle or triangle? These shapes would probably have associated functions like draw(), reportArea(), etc. too; if we tried to import different functions of the same name into the same top-level module file, we'd end up with conflicts and errors.
Fortunately there are a number of ways to get around this. We'll look at these in the following sections.Renaming imports and exportsInside your import and export statement's curly braces, you can use the keyword as along with a new feature name, to change the identifying name you will use for a feature inside the top-level module.
So for example, both of the following would do the same job, albeit in a slightly different way:
js// inside module.js
export { function1 as newFunctionName, function2 as anotherNewFunctionName };

// inside main.js
import { newFunctionName, anotherNewFunctionName } from "./modules/module.js";

js// inside module.js
export { function1, function2 };

// inside main.js
import {
  function1 as newFunctionName,
  function2 as anotherNewFunctionName,
} from "./modules/module.js";

Let's look at a real example. In our renaming directory you'll see the same module system as in the previous example, except that we've added circle.js and triangle.js modules to draw and report on circles and triangles.
Inside each of these modules, we've got features with the same names being exported, and therefore each has the same export statement at the bottom:
jsexport { name, draw, reportArea, reportPerimeter };

When importing these into main.js, if we tried to use
jsimport { name, draw, reportArea, reportPerimeter } from "./modules/square.js";
import { name, draw, reportArea, reportPerimeter } from "./modules/circle.js";
import { name, draw, reportArea, reportPerimeter } from "./modules/triangle.js";

The browser would throw an error such as "SyntaxError: redeclaration of import name" (Firefox).
Instead we need to rename the imports so that they are unique:
jsimport {
  name as squareName,
  draw as drawSquare,
  reportArea as reportSquareArea,
  reportPerimeter as reportSquarePerimeter,
} from "./modules/square.js";

import {
  name as circleName,
  draw as drawCircle,
  reportArea as reportCircleArea,
  reportPerimeter as reportCirclePerimeter,
} from "./modules/circle.js";

import {
  name as triangleName,
  draw as drawTriangle,
  reportArea as reportTriangleArea,
  reportPerimeter as reportTrianglePerimeter,
} from "./modules/triangle.js";

Note that you could solve the problem in the module files instead, e.g.
js// in square.js
export {
  name as squareName,
  draw as drawSquare,
  reportArea as reportSquareArea,
  reportPerimeter as reportSquarePerimeter,
};

js// in main.js
import {
  squareName,
  drawSquare,
  reportSquareArea,
  reportSquarePerimeter,
} from "./modules/square.js";

And it would work just the same. What style you use is up to you, however it arguably makes more sense to leave your module code alone, and make the changes in the imports. This especially makes sense when you are importing from third party modules that you don't have any control over.Creating a module objectThe above method works OK, but it's a little messy and long-winded. An even better solution is to import each module's features inside a module object. The following syntax form does that:
jsimport * as Module from "./modules/module.js";

This grabs all the exports available inside module.js, and makes them available as members of an object Module, effectively giving it its own namespace. So for example:
jsModule.function1();
Module.function2();

Again, let's look at a real example. If you go to our module-objects directory, you'll see the same example again, but rewritten to take advantage of this new syntax. In the modules, the exports are all in the following simple form:
jsexport { name, draw, reportArea, reportPerimeter };

The imports on the other hand look like this:
jsimport * as Canvas from "./modules/canvas.js";

import * as Square from "./modules/square.js";
import * as Circle from "./modules/circle.js";
import * as Triangle from "./modules/triangle.js";

In each case, you can now access the module's imports underneath the specified object name, for example:
jsconst square1 = Square.draw(myCanvas.ctx, 50, 50, 100, "blue");
Square.reportArea(square1.length, reportList);
Square.reportPerimeter(square1.length, reportList);

So you can now write the code just the same as before (as long as you include the object names where needed), and the imports are much neater.Modules and classesAs we hinted at earlier, you can also export and import classes; this is another option for avoiding conflicts in your code, and is especially useful if you've already got your module code written in an object-oriented style.
You can see an example of our shape drawing module rewritten with ES classes in our classes directory. As an example, the square.js file now contains all its functionality in a single class:
jsclass Square {
  constructor(ctx, listId, length, x, y, color) {
    // …
  }

  draw() {
    // …
  }

  // …
}

which we then export:
jsexport { Square };

Over in main.js, we import it like this:
jsimport { Square } from "./modules/square.js";

And then use the class to draw our square:
jsconst square1 = new Square(myCanvas.ctx, myCanvas.listId, 50, 50, 100, "blue");
square1.draw();
square1.reportArea();
square1.reportPerimeter();
Aggregating modulesThere will be times where you'll want to aggregate modules together. You might have multiple levels of dependencies, where you want to simplify things, combining several submodules into one parent module. This is possible using export syntax of the following forms in the parent module:
jsexport * from "x.js";
export { name } from "x.js";

For an example, see our module-aggregation directory. In this example (based on our earlier classes example) we've got an extra module called shapes.js, which aggregates all the functionality from circle.js, square.js, and triangle.js together. We've also moved our submodules inside a subdirectory inside the modules directory called shapes. So the module structure in this example is:
modules/
  canvas.js
  shapes.js
  shapes/
    circle.js
    square.js
    triangle.js

In each of the submodules, the export is of the same form, e.g.
jsexport { Square };

Next up comes the aggregation part. Inside shapes.js, we include the following lines:
jsexport { Square } from "./shapes/square.js";
export { Triangle } from "./shapes/triangle.js";
export { Circle } from "./shapes/circle.js";

These grab the exports from the individual submodules and effectively make them available from the shapes.js module.

Note:
The exports referenced in shapes.js basically get redirected through the file and don't really exist there, so you won't be able to write any useful related code inside the same file.

So now in the main.js file, we can get access to all three module classes by replacing
jsimport { Square } from "./modules/square.js";
import { Circle } from "./modules/circle.js";
import { Triangle } from "./modules/triangle.js";

with the following single line:
jsimport { Square, Circle, Triangle } from "./modules/shapes.js";
Dynamic module loadingA recent addition to JavaScript modules functionality is dynamic module loading. This allows you to dynamically load modules only when they are needed, rather than having to load everything up front. This has some obvious performance advantages; let's read on and see how it works.
This new functionality allows you to call import() as a function, passing it the path to the module as a parameter. It returns a Promise, which fulfills with a module object (see Creating a module object) giving you access to that object's exports. For example:
jsimport("./modules/myModule.js").then((module) => {
  // Do something with the module.
});


Note:
Dynamic import is permitted in the browser main thread, and in shared and dedicated workers.
However import() will throw if called in a service worker or worklet.


Let's look at an example. In the dynamic-module-imports directory we've got another example based on our classes example. This time however we are not drawing anything on the canvas when the example loads. Instead, we include three buttons — "Circle", "Square", and "Triangle" — that, when pressed, dynamically load the required module and then use it to draw the associated shape.
In this example we've only made changes to our index.html and main.js files — the module exports remain the same as before.
Over in main.js we've grabbed a reference to each button using a document.querySelector() call, for example:
jsconst squareBtn = document.querySelector(".square");

We then attach an event listener to each button so that when pressed, the relevant module is dynamically loaded and used to draw the shape:
jssquareBtn.addEventListener("click", () => {
  import("./modules/square.js").then((Module) => {
    const square1 = new Module.Square(
      myCanvas.ctx,
      myCanvas.listId,
      50,
      50,
      100,
      "blue",
    );
    square1.draw();
    square1.reportArea();
    square1.reportPerimeter();
  });
});

Note that, because the promise fulfillment returns a module object, the class is then made a subfeature of the object, hence we now need to access the constructor with Module. prepended to it, e.g., Module.Square( /* … */ ).
Another advantage of dynamic imports is that they are always available, even in script environments. Therefore, if you have an existing <script> tag in your HTML that doesn't have type="module", you can still reuse code distributed as modules by dynamically importing it.
html<script>
  import("./modules/square.js").then((module) => {
    // Do something with the module.
  });
  // Other code that operates on the global scope and is not
  // ready to be refactored into modules yet.
  var btn = document.querySelector(".square");
</script>
Top level awaitTop level await is a feature available within modules. This means the await keyword can be used. It allows modules to act as big asynchronous functions meaning code can be evaluated before use in parent modules, but without blocking sibling modules from loading.
Let's take a look at an example. You can find all the files and code described in this section within the top-level-await directory, which extends from the previous examples.
Firstly we'll declare our color palette in a separate colors.json file:
json{
  "yellow": "#F4D03F",
  "green": "#52BE80",
  "blue": "#5499C7",
  "red": "#CD6155",
  "orange": "#F39C12"
}

Then we'll create a module called getColors.js which uses a fetch request to load the colors.json file and return the data as an object.
js// fetch request
const colors = fetch("../data/colors.json").then((response) => response.json());

export default await colors;

Notice the last export line here.
We're using the keyword await before specifying the constant colors to export. This means any other modules which include this one will wait until colors has been downloaded and parsed before using it.
Let's include this module in our main.js file:
jsimport colors from "./modules/getColors.js";
import { Canvas } from "./modules/canvas.js";

const circleBtn = document.querySelector(".circle");

// …

We'll use colors instead of the previously used strings when calling our shape functions:
jsconst square1 = new Module.Square(
  myCanvas.ctx,
  myCanvas.listId,
  50,
  50,
  100,
  colors.blue,
);

const circle1 = new Module.Circle(
  myCanvas.ctx,
  myCanvas.listId,
  75,
  200,
  100,
  colors.green,
);

const triangle1 = new Module.Triangle(
  myCanvas.ctx,
  myCanvas.listId,
  100,
  75,
  190,
  colors.yellow,
);

This is useful because the code within main.js won't execute until the code in getColors.js has run. However it won't block other modules being loaded. For instance our canvas.js module will continue to load while colors is being fetched.Import declarations are hoistedImport declarations are hoisted. In this case, it means that the imported values are available in the module's code even before the place that declares them, and that the imported module's side effects are produced before the rest of the module's code starts running.
So for example, in main.js, importing Canvas in the middle of the code would still work:
js// …
const myCanvas = new Canvas("myCanvas", document.body, 480, 320);
myCanvas.create();
import { Canvas } from "./modules/canvas.js";
myCanvas.createReportList();
// …

Still, it is considered good practice to put all your imports at the top of the code, which makes it easier to analyze dependencies.Cyclic importsModules can import other modules, and those modules can import other modules, and so on. This forms a directed graph called the "dependency graph". In an ideal world, this graph is acyclic. In this case, the graph can be evaluated using a depth-first traversal.
However, cycles are often inevitable. Cyclic import arises if module a imports module b, but b directly or indirectly depends on a. For example:
js// -- a.js --
import { b } from "./b.js";

// -- b.js --
import { a } from "./a.js";

// Cycle:
// a.js ───> b.js
//  ^         │
//  └─────────┘

Cyclic imports don't always fail. The imported variable's value is only retrieved when the variable is actually used (hence allowing live bindings), and only if the variable remains uninitialized at that time will a ReferenceError be thrown.
js// -- a.js --
import { b } from "./b.js";

setTimeout(() => {
  console.log(b); // 1
}, 10);

export const a = 2;

// -- b.js --
import { a } from "./a.js";

setTimeout(() => {
  console.log(a); // 2
}, 10);

export const b = 1;

In this example, both a and b are used asynchronously. Therefore, at the time the module is evaluated, neither b nor a is actually read, so the rest of the code is executed as normal, and the two export declarations produce the values of a and b. Then, after the timeout, both a and b are available, so the two console.log statements also execute as normal.
If you change the code to use a synchronously, the module evaluation fails:
js// -- a.js (entry module) --
import { b } from "./b.js";

export const a = 2;

// -- b.js --
import { a } from "./a.js";

console.log(a); // ReferenceError: Cannot access 'a' before initialization
export const b = 1;

This is because when JavaScript evaluates a.js, it needs to first evaluate b.js, the dependency of a.js. However, b.js uses a, which is not yet available.
On the other hand, if you change the code to use b synchronously but a asynchronously, the module evaluation succeeds:
js// -- a.js (entry module) --
import { b } from "./b.js";

console.log(b); // 1
export const a = 2;

// -- b.js --
import { a } from "./a.js";

setTimeout(() => {
  console.log(a); // 2
}, 10);
export const b = 1;

This is because the evaluation of b.js completes normally, so the value of b is available when a.js is evaluated.
You should usually avoid cyclic imports in your project, because they make your code more error-prone. Some common cycle-elimination techniques are:

Merge the two modules into one.
Move the shared code into a third module.
Move some code from one module to the other.

However, cyclic imports can also occur if the libraries depend on each other, which is harder to fix.Authoring "isomorphic" modulesThe introduction of modules encourages the JavaScript ecosystem to distribute and reuse code in a modular fashion. However, that doesn't necessarily mean a piece of JavaScript code can run in every environment. Suppose you discovered a module that generates SHA hashes of your user's password. Can you use it in the browser front end? Can you use it on your Node.js server? The answer is: it depends.
Modules still have access to global variables, as demonstrated previously. If the module references globals like window, it can run in the browser, but will throw an error in your Node.js server, because window is not available there. Similarly, if the code requires access to process to be functional, it can only be used in Node.js.
In order to maximize the reusability of a module, it is often advised to make the code "isomorphic" — that is, exhibits the same behavior in every runtime. This is commonly achieved in three ways:


Separate your modules into "core" and "binding". For the "core", focus on pure JavaScript logic like computing the hash, without any DOM, network, filesystem access, and expose utility functions. For the "binding" part, you can read from and write to the global context. For example, the "browser binding" may choose to read the value from an input box, while the "Node binding" may read it from process.env, but values read from either place will be piped to the same core function and handled in the same way. The core can be imported in every environment and used in the same way, while only the binding, which is usually lightweight, needs to be platform-specific.


Detect whether a particular global exists before using it. For example, if you test that typeof window === "undefined", you know that you are probably in a Node.js environment, and should not read DOM.
js// myModule.js
let password;
if (typeof process !== "undefined") {
  // We are running in Node.js; read it from `process.env`
  password = process.env.PASSWORD;
} else if (typeof window !== "undefined") {
  // We are running in the browser; read it from the input box
  password = document.getElementById("password").value;
}

This is preferable if the two branches actually end up with the same behavior ("isomorphic"). If it's impossible to provide the same functionality, or if doing so involves loading significant amounts of code while a large part remains unused, better use different "bindings" instead.


Use a polyfill to provide a fallback for missing features. For example, if you want to use the fetch function, which is only supported in Node.js since v18, you can use a similar API, like the one provided by node-fetch. You can do so conditionally through dynamic imports:
js// myModule.js
if (typeof fetch === "undefined") {
  // We are running in Node.js; use node-fetch
  globalThis.fetch = (await import("node-fetch")).default;
}
// …

The globalThis variable is a global object that is available in every environment and is useful if you want to read or create global variables within modules.


These practices are not unique to modules. Still, with the trend of code reusability and modularization, you are encouraged to make your code cross-platform so that it can be enjoyed by as many people as possible. Runtimes like Node.js are also actively implementing web APIs where possible to improve interoperability with the web.TroubleshootingHere are a few tips that may help you if you are having trouble getting your modules to work. Feel free to add to the list if you discover more!

We mentioned this before, but to reiterate: .mjs files need to be loaded with a MIME-type of text/javascript (or another JavaScript-compatible MIME-type, but text/javascript is recommended), otherwise you'll get a strict MIME type checking error like "The server responded with a non-JavaScript MIME type".
If you try to load the HTML file locally (i.e., with a file:// URL), you'll run into CORS errors due to JavaScript module security requirements. You need to do your testing through a server. GitHub pages is ideal as it also serves .mjs files with the correct MIME type.
Because .mjs is a non-standard file extension, some operating systems might not recognize it, or try to replace it with something else. For example, we found that macOS was silently adding on .js to the end of .mjs files and then automatically hiding the file extension. So all of our files were actually coming out as x.mjs.js. Once we turned off automatically hiding file extensions, and trained it to accept .mjs, it was OK.
See also
JavaScript modules on v8.dev (2018)
ES modules: A cartoon deep-dive on hacks.mozilla.org (2018)
ES6 in Depth: Modules on hacks.mozilla.org (2015)
Exploring JS, Ch.16: Modules by Dr. Axel Rauschmayer

 Previous\n\nJavaScript modules Previous 
This guide gives you all you need to get started with JavaScript module syntax.A background on modulesJavaScript programs started off pretty small — most of its usage in the early days was to do isolated scripting tasks, providing a bit of interactivity to your web pages where needed, so large scripts were generally not needed. Fast forward a few years and we now have complete applications being run in browsers with a lot of JavaScript, as well as JavaScript being used in other contexts (Node.js, for example).
Complex projects necessitate a mechanism for splitting JavaScript programs into separate modules that can be imported when needed. Node.js has had this ability for a long time, and there are a number of JavaScript libraries and frameworks that enable module usage (for example, other CommonJS and AMD-based module systems like RequireJS, webpack, and Babel).
All modern browsers support module features natively without needing transpilation. It can only be a good thing — browsers can optimize loading of modules, making it more efficient than having to use a library and do all of that extra client-side processing and extra round trips. It does not obsolete bundlers like webpack, though — bundlers still do a good job at partitioning code into reasonably sized chunks, and are able to do other optimizations like minification, dead code elimination, and tree-shaking.Introducing an exampleTo demonstrate usage of modules, we've created a set of examples that you can find on GitHub. These examples demonstrate a set of modules that create a <canvas> element on a webpage, and then draw (and report information about) different shapes on the canvas.
These are fairly trivial, but have been kept deliberately simple to demonstrate modules clearly.

Note:
If you want to download the examples and run them locally, you'll need to run them through a local web server.
Basic example structureIn our first example (see basic-modules) we have a file structure as follows:
index.html
main.js
modules/
    canvas.js
    square.js


Note:
All of the examples in this guide have basically the same structure; the above should start getting pretty familiar.

The modules directory's two modules are described below:


canvas.js — contains functions related to setting up the canvas:

create() — creates a canvas with a specified width and height inside a wrapper <div> with a specified ID, which is itself appended inside a specified parent element. Returns an object containing the canvas's 2D context and the wrapper's ID.
createReportList() — creates an unordered list appended inside a specified wrapper element, which can be used to output report data into. Returns the list's ID.



square.js — contains:

name — a constant containing the string 'square'.
draw() — draws a square on a specified canvas, with a specified size, position, and color. Returns an object containing the square's size, position, and color.
reportArea() — writes a square's area to a specific report list, given its length.
reportPerimeter() — writes a square's perimeter to a specific report list, given its length.


Aside — .mjs versus .jsThroughout this article, we've used .js extensions for our module files, but in other resources you may see the .mjs extension used instead. V8's documentation recommends this, for example. The reasons given are:

It is good for clarity, i.e., it makes it clear which files are modules, and which are regular JavaScript.
It ensures that your module files are parsed as a module by runtimes such as Node.js, and build tools such as Babel.

However, we decided to keep using .js, at least for the moment. To get modules to work correctly in a browser, you need to make sure that your server is serving them with a Content-Type header that contains a JavaScript MIME type such as text/javascript. If you don't, you'll get a strict MIME type checking error along the lines of "The server responded with a non-JavaScript MIME type" and the browser won't run your JavaScript. Most servers already set the correct type for .js files, but not yet for .mjs files. Servers that already serve .mjs files correctly include GitHub Pages and http-server for Node.js.
This is OK if you are using such an environment already, or if you aren't but you know what you are doing and have access (i.e., you can configure your server to set the correct Content-Type for .mjs files). It could however cause confusion if you don't control the server you are serving files from, or are publishing files for public use, as we are here.
For learning and portability purposes, we decided to keep to .js.
If you really value the clarity of using .mjs for modules versus using .js for "normal" JavaScript files, but don't want to run into the problem described above, you could always use .mjs during development and convert them to .js during your build step.
It is also worth noting that:

Some tools may never support .mjs.
The <script type="module"> attribute is used to denote when a module is being pointed to, as you'll see below.
Exporting module featuresThe first thing you do to get access to module features is export them. This is done using the export statement.
The easiest way to use it is to place it in front of any items you want exported out of the module, for example:
jsexport const name = "square";

export function draw(ctx, length, x, y, color) {
  ctx.fillStyle = color;
  ctx.fillRect(x, y, length, length);

  return { length, x, y, color };
}

You can export functions, var, let, const, and — as we'll see later — classes. They need to be top-level items: for example, you can't use export inside a function.
A more convenient way of exporting all the items you want to export is to use a single export statement at the end of your module file, followed by a comma-separated list of the features you want to export wrapped in curly braces. For example:
jsexport { name, draw, reportArea, reportPerimeter };
Importing features into your scriptOnce you've exported some features out of your module, you need to import them into your script to be able to use them. The simplest way to do this is as follows:
jsimport { name, draw, reportArea, reportPerimeter } from "./modules/square.js";

You use the import statement, followed by a comma-separated list of the features you want to import wrapped in curly braces, followed by the keyword from, followed by the module specifier.
The module specifier provides a string that the JavaScript environment can resolve to a path to the module file.
In a browser, this could be a path relative to the site root, which for our basic-modules example would be /js-examples/module-examples/basic-modules.
However, here we are instead using the dot (.) syntax to mean "the current location", followed by the relative path to the file we are trying to find. This is much better than writing out the entire absolute path each time, as relative paths are shorter and make the URL portable — the example will still work if you move it to a different location in the site hierarchy.
So for example:
bash/js-examples/module-examples/basic-modules/modules/square.js

becomes
bash./modules/square.js

You can see such lines in action in main.js.

Note:
In some module systems, you can use a module specifier like modules/square that isn't a relative or absolute path, and that doesn't have a file extension.
This kind of specifier can be used in a browser environment if you first define an import map.

Once you've imported the features into your script, you can use them just like they were defined inside the same file. The following is found in main.js, below the import lines:
jsconst myCanvas = create("myCanvas", document.body, 480, 320);
const reportList = createReportList(myCanvas.id);

const square1 = draw(myCanvas.ctx, 50, 50, 100, "blue");
reportArea(square1.length, reportList);
reportPerimeter(square1.length, reportList);


Note:
The imported values are read-only views of the features that were exported. Similar to const variables, you cannot re-assign the variable that was imported, but you can still modify properties of object values. The value can only be re-assigned by the module exporting it. See the import reference for an example.
Importing modules using import mapsAbove we saw how a browser can import a module using a module specifier that is either an absolute URL, or a relative URL that is resolved using the base URL of the document:
jsimport { name as squareName, draw } from "./shapes/square.js";
import { name as circleName } from "https://example.com/shapes/circle.js";

Import maps allow developers to instead specify almost any text they want in the module specifier when importing a module; the map provides a corresponding value that will replace the text when the module URL is resolved.
For example, the imports key in the import map below defines a "module specifier map" JSON object where the property names can be used as module specifiers, and the corresponding values will be substituted when the browser resolves the module URL.
The values must be absolute or relative URLs.
Relative URLs are resolved to absolute URL addresses using the base URL of the document containing the import map.
html<script type="importmap">
  {
    "imports": {
      "shapes": "./shapes/square.js",
      "shapes/square": "./modules/shapes/square.js",
      "https://example.com/shapes/square.js": "./shapes/square.js",
      "https://example.com/shapes/": "/shapes/square/",
      "../shapes/square": "./shapes/square.js"
    }
  }
</script>

The import map is defined using a JSON object inside a <script> element with the type attribute set to importmap.
Note that an import map only applies to the document — the specification does not cover how to apply an import map in a worker or worklet context. 
With this map you can now use the property names above as module specifiers.
If there is no trailing forward slash on the module specifier key then the whole module specifier key is matched and substituted.
For example, below we match bare module names, and remap a URL to another path.
js// Bare module names as module specifiers
import { name as squareNameOne } from "shapes";
import { name as squareNameTwo } from "shapes/square";

// Remap a URL to another URL
import { name as squareNameThree } from "https://example.com/shapes/square.js";

If the module specifier has a trailing forward slash then the value must have one as well, and the key is matched as a "path prefix".
This allows remapping of whole classes of URLs.
js// Remap a URL as a prefix ( https://example.com/shapes/)
import { name as squareNameFour } from "https://example.com/shapes/moduleshapes/square.js";

It is possible for multiple keys in an import map to be valid matches for a module specifier.
For example, a module specifier of shapes/circle/ could match the module specifier keys shapes/ and shapes/circle/.
In this case the browser will select the most specific (longest) matching module specifier key.
Import maps allow modules to be imported using bare module names (as in Node.js), and can also simulate importing modules from packages, both with and without file extensions.
While not shown above, they also allow particular versions of a library to be imported, based on the path of the script that is importing the module.
Generally they let developers write more ergonomic import code, and make it easier to manage the different versions and dependencies of modules used by a site.
This can reduce the effort required to use the same JavaScript libraries in both browser and server.
The following sections expand on the various features outlined above.Feature detectionYou can check support for import maps using the HTMLScriptElement.supports() static method (which is itself broadly supported):
jsif (HTMLScriptElement.supports?.("importmap")) {
  console.log("Browser supports import maps.");
}
Importing modules as bare namesIn some JavaScript environments, such as Node.js, you can use bare names for the module specifier.
This works because the environment can resolve module names to a standard location in the file system.
For example, you might use the following syntax to import the "square" module.
jsimport { name, draw, reportArea, reportPerimeter } from "square";

To use bare names on a browser you need an import map, which provides the information needed by the browser to resolve module specifiers to URLs (JavaScript will throw a TypeError if it attempts to import a module specifier that can't be resolved to a module location).
Below you can see a map that defines a square module specifier key, which in this case maps to a relative address value.
html<script type="importmap">
  {
    "imports": {
      "square": "./shapes/square.js"
    }
  }
</script>

With this map we can now use a bare name when we import the module:
jsimport { name as squareName, draw } from "square";
Remapping module pathsModule specifier map entries, where both the specifier key and its associated value have a trailing forward slash (/), can be used as a path-prefix.
This allows the remapping of a whole set of import URLs from one location to another.
It can also be used to emulate working with "packages and modules", such as you might see in the Node ecosystem.

Note:
The trailing / indicates that the module specifier key can be substituted as part of a module specifier.
If this is not present, the browser will only match (and substitute) the whole module specifier key.

Packages of modules
The following JSON import map definition maps lodash as a bare name, and the module specifier prefix lodash/ to the path /node_modules/lodash-es/ (resolved to the document base URL):
json{
  "imports": {
    "lodash": "/node_modules/lodash-es/lodash.js",
    "lodash/": "/node_modules/lodash-es/"
  }
}

With this mapping you can import both the whole "package", using the bare name, and modules within it (using the path mapping):
jsimport _ from "lodash";
import fp from "lodash/fp.js";

It is possible to import fp above without the .js file extension, but you would need to create a bare module specifier key for that file, such as lodash/fp, rather than using the path.
This may be reasonable for just one module, but scales poorly if you wish to import many modules.
General URL remapping
A module specifier key doesn't have to be path — it can also be an absolute URL (or a URL-like relative path like ./, ../, /).
This may be useful if you want to remap a module that has absolute paths to a resource with your own local resources.
json{
  "imports": {
    "https://www.unpkg.com/moment/": "/node_modules/moment/"
  }
}
Scoped modules for version managementEcosystems like Node use package managers such as npm to manage modules and their dependencies.
The package manager ensures that each module is separated from other modules and their dependencies.
As a result, while a complex application might include the same module multiple times with several different versions in different parts of the module graph, users do not need to think about this complexity.

Note:
You can also achieve version management using relative paths, but this is subpar because, among other things, this forces a particular structure on your project, and prevents you from using bare module names.

Import maps similarly allow you to have multiple versions of dependencies in your application and refer to them using the same module specifier.
You implement this with the scopes key, which allows you to provide module specifier maps that will be used depending on the path of the script performing the import.
The example below demonstrates this.
json{
  "imports": {
    "cool-module": "/node_modules/cool-module/index.js"
  },
  "scopes": {
    "/node_modules/dependency/": {
      "cool-module": "/node_modules/some/other/location/cool-module/index.js"
    }
  }
}

With this mapping, if a script with an URL that contains /node_modules/dependency/ imports cool-module, the version in /node_modules/some/other/location/cool-module/index.js will be used.
The map in imports is used as a fallback if there is no matching scope in the scoped map, or the matching scopes don't contain a matching specifier. For example, if cool-module is imported from a script with a non-matching scope path, then the module specifier map in imports will be used instead, mapping to the version in /node_modules/cool-module/index.js.
Note that the path used to select a scope does not affect how the address is resolved.
The value in the mapped path does not have to match the scopes path, and relative paths are still resolved to the base URL of the script that contains the import map.
Just as for module specifier maps, you can have many scope keys, and these may contain overlapping paths.
If multiple scopes match the referrer URL, then the most specific scope path is checked first (the longest scope key) for a matching specifier.
The browsers will fall back to the next most specific matching scoped path if there is no matching specifier, and so on.
If there is no matching specifier in any of the matching scopes, the browser checks for a match in the module specifier map in the imports key.Improve caching by mapping away hashed filenamesScript files used by websites often have hashed filenames to simplify caching.
The downside of this approach is that if a module changes, any modules that import it using its hashed filename will also need to be updated/regenerated.
This potentially results in a cascade of updates, which is wasteful of network resources.
Import maps provide a convenient solution to this problem.
Rather than depending on specific hashed filenames, applications and scripts instead depend on an un-hashed version of the module name (address).
An import map like the one below then provides a mapping to the actual script file.
json{
  "imports": {
    "main_script": "/node/srcs/application-fg7744e1b.js",
    "dependency_script": "/node/srcs/dependency-3qn7e4b1q.js"
  }
}

If dependency_script changes, then its hash contained in the file name changes as well. In this case, we only need to update the import map to reflect the changed name of the module.
We don't have to update the source of any JavaScript code that depends on it, because the specifier in the import statement does not change.Loading non-JavaScript resourcesOne exciting feature that a unified module architecture brings is the ability to load non-JavaScript resources as modules. For example, you can import JSON as a JavaScript object, or import CSS as a CSSStyleSheet object.
You must explicitly declare what kind of resource you are importing. By default, the browser assumes that the resource is JavaScript, and will throw an error if the resolved resource is something else. To import JSON, CSS, or other types of resource, use the import attributes syntax:
jsimport colors from "./colors.json" with { type: "json" };
import styles from "./styles.css" with { type: "css" };

Browsers will also perform validation on the module type, and fail if, for example, ./data.json does not resolve to a JSON file. This ensures that you don't accidentally execute code when you just intend to import data. Once imported successfully, you can now use the imported value as a normal JavaScript object or CSSStyleSheet object.
jsconsole.log(colors.map((color) => color.value));
document.adoptedStyleSheets = [styles];
Applying the module to your HTMLNow we just need to apply the main.js module to our HTML page. This is very similar to how we apply a regular script to a page, with a few notable differences.
First of all, you need to include type="module" in the <script> element, to declare this script as a module. To import the main.js script, we use this:
html<script type="module" src="main.js"></script>

You can also embed the module's script directly into the HTML file by placing the JavaScript code within the body of the <script> element:
html<script type="module">
  /* JavaScript module code here */
</script>

You can only use import and export statements inside modules, not regular scripts. An error will be thrown if your <script> element doesn't have the type="module" attribute and attempts to import other modules. For example:
html<script>
  import _ from "lodash"; // SyntaxError: import declarations may only appear at top level of a module
  // ...
</script>
<script src="a-module-using-import-statements.js"></script>
<!-- SyntaxError: import declarations may only appear at top level of a module -->

You should generally define all your modules in separate files. Modules declared inline in HTML can only import other modules, but anything they export will not be accessible by other modules (because they don't have a URL).

Note:
Modules and their dependencies can be preloaded by specifying them in <link> elements with rel="modulepreload".
This can significantly reduce load time when the modules are used.
Other differences between modules and classic scripts
You need to pay attention to local testing — if you try to load the HTML file locally (i.e., with a file:// URL), you'll run into CORS errors due to JavaScript module security requirements. You need to do your testing through a server.
Also, note that you might get different behavior from sections of script defined inside modules as opposed to in classic scripts. This is because modules use strict mode automatically.
There is no need to use the defer attribute (see <script> attributes) when loading a module script; modules are deferred automatically.
Modules are only executed once, even if they have been referenced in multiple <script> tags.
Last but not least, let's make this clear — module features are imported into the scope of a single script — they aren't available in the global scope. Therefore, you will only be able to access imported features in the script they are imported into, and you won't be able to access them from the JavaScript console, for example. You'll still get syntax errors shown in the DevTools, but you'll not be able to use some of the debugging techniques you might have expected to use.

Module-defined variables are scoped to the module unless explicitly attached to the global object. On the other hand, globally-defined variables are available within the module. For example, given the following code:
html<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8" />
    <title></title>
    <link rel="stylesheet" href="" />
  </head>
  <body>
    <div id="main"></div>
    <script>
      // A var statement creates a global variable.
      var text = "Hello";
    </script>
    <script type="module" src="./render.js"></script>
  </body>
</html>

js/* render.js */
document.getElementById("main").innerText = text;

The page would still render Hello, because the global variables text and document are available in the module. (Also note from this example that a module doesn't necessarily need an import/export statement — the only thing needed is for the entry point to have type="module".)Default exports versus named exportsThe functionality we've exported so far has been comprised of named exports — each item (be it a function, const, etc.) has been referred to by its name upon export, and that name has been used to refer to it on import as well.
There is also a type of export called the default export — this is designed to make it easy to have a default function provided by a module, and also helps JavaScript modules to interoperate with existing CommonJS and AMD module systems (as explained nicely in ES6 In Depth: Modules by Jason Orendorff; search for "Default exports").
Let's look at an example as we explain how it works. In our basic-modules square.js you can find a function called randomSquare() that creates a square with a random color, size, and position. We want to export this as our default, so at the bottom of the file we write this:
jsexport default randomSquare;

Note the lack of curly braces.
We could instead prepend export default onto the function and define it as an anonymous function, like this:
jsexport default function (ctx) {
  // …
}

Over in our main.js file, we import the default function using this line:
jsimport randomSquare from "./modules/square.js";

Again, note the lack of curly braces. This is because there is only one default export allowed per module, and we know that randomSquare is it. The above line is basically shorthand for:
jsimport { default as randomSquare } from "./modules/square.js";


Note:
The as syntax for renaming exported items is explained below in the Renaming imports and exports section.
Avoiding naming conflictsSo far, our canvas shape drawing modules seem to be working OK. But what happens if we try to add a module that deals with drawing another shape, like a circle or triangle? These shapes would probably have associated functions like draw(), reportArea(), etc. too; if we tried to import different functions of the same name into the same top-level module file, we'd end up with conflicts and errors.
Fortunately there are a number of ways to get around this. We'll look at these in the following sections.Renaming imports and exportsInside your import and export statement's curly braces, you can use the keyword as along with a new feature name, to change the identifying name you will use for a feature inside the top-level module.
So for example, both of the following would do the same job, albeit in a slightly different way:
js// inside module.js
export { function1 as newFunctionName, function2 as anotherNewFunctionName };

// inside main.js
import { newFunctionName, anotherNewFunctionName } from "./modules/module.js";

js// inside module.js
export { function1, function2 };

// inside main.js
import {
  function1 as newFunctionName,
  function2 as anotherNewFunctionName,
} from "./modules/module.js";

Let's look at a real example. In our renaming directory you'll see the same module system as in the previous example, except that we've added circle.js and triangle.js modules to draw and report on circles and triangles.
Inside each of these modules, we've got features with the same names being exported, and therefore each has the same export statement at the bottom:
jsexport { name, draw, reportArea, reportPerimeter };

When importing these into main.js, if we tried to use
jsimport { name, draw, reportArea, reportPerimeter } from "./modules/square.js";
import { name, draw, reportArea, reportPerimeter } from "./modules/circle.js";
import { name, draw, reportArea, reportPerimeter } from "./modules/triangle.js";

The browser would throw an error such as "SyntaxError: redeclaration of import name" (Firefox).
Instead we need to rename the imports so that they are unique:
jsimport {
  name as squareName,
  draw as drawSquare,
  reportArea as reportSquareArea,
  reportPerimeter as reportSquarePerimeter,
} from "./modules/square.js";

import {
  name as circleName,
  draw as drawCircle,
  reportArea as reportCircleArea,
  reportPerimeter as reportCirclePerimeter,
} from "./modules/circle.js";

import {
  name as triangleName,
  draw as drawTriangle,
  reportArea as reportTriangleArea,
  reportPerimeter as reportTrianglePerimeter,
} from "./modules/triangle.js";

Note that you could solve the problem in the module files instead, e.g.
js// in square.js
export {
  name as squareName,
  draw as drawSquare,
  reportArea as reportSquareArea,
  reportPerimeter as reportSquarePerimeter,
};

js// in main.js
import {
  squareName,
  drawSquare,
  reportSquareArea,
  reportSquarePerimeter,
} from "./modules/square.js";

And it would work just the same. What style you use is up to you, however it arguably makes more sense to leave your module code alone, and make the changes in the imports. This especially makes sense when you are importing from third party modules that you don't have any control over.Creating a module objectThe above method works OK, but it's a little messy and long-winded. An even better solution is to import each module's features inside a module object. The following syntax form does that:
jsimport * as Module from "./modules/module.js";

This grabs all the exports available inside module.js, and makes them available as members of an object Module, effectively giving it its own namespace. So for example:
jsModule.function1();
Module.function2();

Again, let's look at a real example. If you go to our module-objects directory, you'll see the same example again, but rewritten to take advantage of this new syntax. In the modules, the exports are all in the following simple form:
jsexport { name, draw, reportArea, reportPerimeter };

The imports on the other hand look like this:
jsimport * as Canvas from "./modules/canvas.js";

import * as Square from "./modules/square.js";
import * as Circle from "./modules/circle.js";
import * as Triangle from "./modules/triangle.js";

In each case, you can now access the module's imports underneath the specified object name, for example:
jsconst square1 = Square.draw(myCanvas.ctx, 50, 50, 100, "blue");
Square.reportArea(square1.length, reportList);
Square.reportPerimeter(square1.length, reportList);

So you can now write the code just the same as before (as long as you include the object names where needed), and the imports are much neater.Modules and classesAs we hinted at earlier, you can also export and import classes; this is another option for avoiding conflicts in your code, and is especially useful if you've already got your module code written in an object-oriented style.
You can see an example of our shape drawing module rewritten with ES classes in our classes directory. As an example, the square.js file now contains all its functionality in a single class:
jsclass Square {
  constructor(ctx, listId, length, x, y, color) {
    // …
  }

  draw() {
    // …
  }

  // …
}

which we then export:
jsexport { Square };

Over in main.js, we import it like this:
jsimport { Square } from "./modules/square.js";

And then use the class to draw our square:
jsconst square1 = new Square(myCanvas.ctx, myCanvas.listId, 50, 50, 100, "blue");
square1.draw();
square1.reportArea();
square1.reportPerimeter();
Aggregating modulesThere will be times where you'll want to aggregate modules together. You might have multiple levels of dependencies, where you want to simplify things, combining several submodules into one parent module. This is possible using export syntax of the following forms in the parent module:
jsexport * from "x.js";
export { name } from "x.js";

For an example, see our module-aggregation directory. In this example (based on our earlier classes example) we've got an extra module called shapes.js, which aggregates all the functionality from circle.js, square.js, and triangle.js together. We've also moved our submodules inside a subdirectory inside the modules directory called shapes. So the module structure in this example is:
modules/
  canvas.js
  shapes.js
  shapes/
    circle.js
    square.js
    triangle.js

In each of the submodules, the export is of the same form, e.g.
jsexport { Square };

Next up comes the aggregation part. Inside shapes.js, we include the following lines:
jsexport { Square } from "./shapes/square.js";
export { Triangle } from "./shapes/triangle.js";
export { Circle } from "./shapes/circle.js";

These grab the exports from the individual submodules and effectively make them available from the shapes.js module.

Note:
The exports referenced in shapes.js basically get redirected through the file and don't really exist there, so you won't be able to write any useful related code inside the same file.

So now in the main.js file, we can get access to all three module classes by replacing
jsimport { Square } from "./modules/square.js";
import { Circle } from "./modules/circle.js";
import { Triangle } from "./modules/triangle.js";

with the following single line:
jsimport { Square, Circle, Triangle } from "./modules/shapes.js";
Dynamic module loadingA recent addition to JavaScript modules functionality is dynamic module loading. This allows you to dynamically load modules only when they are needed, rather than having to load everything up front. This has some obvious performance advantages; let's read on and see how it works.
This new functionality allows you to call import() as a function, passing it the path to the module as a parameter. It returns a Promise, which fulfills with a module object (see Creating a module object) giving you access to that object's exports. For example:
jsimport("./modules/myModule.js").then((module) => {
  // Do something with the module.
});


Note:
Dynamic import is permitted in the browser main thread, and in shared and dedicated workers.
However import() will throw if called in a service worker or worklet.


Let's look at an example. In the dynamic-module-imports directory we've got another example based on our classes example. This time however we are not drawing anything on the canvas when the example loads. Instead, we include three buttons — "Circle", "Square", and "Triangle" — that, when pressed, dynamically load the required module and then use it to draw the associated shape.
In this example we've only made changes to our index.html and main.js files — the module exports remain the same as before.
Over in main.js we've grabbed a reference to each button using a document.querySelector() call, for example:
jsconst squareBtn = document.querySelector(".square");

We then attach an event listener to each button so that when pressed, the relevant module is dynamically loaded and used to draw the shape:
jssquareBtn.addEventListener("click", () => {
  import("./modules/square.js").then((Module) => {
    const square1 = new Module.Square(
      myCanvas.ctx,
      myCanvas.listId,
      50,
      50,
      100,
      "blue",
    );
    square1.draw();
    square1.reportArea();
    square1.reportPerimeter();
  });
});

Note that, because the promise fulfillment returns a module object, the class is then made a subfeature of the object, hence we now need to access the constructor with Module. prepended to it, e.g., Module.Square( /* … */ ).
Another advantage of dynamic imports is that they are always available, even in script environments. Therefore, if you have an existing <script> tag in your HTML that doesn't have type="module", you can still reuse code distributed as modules by dynamically importing it.
html<script>
  import("./modules/square.js").then((module) => {
    // Do something with the module.
  });
  // Other code that operates on the global scope and is not
  // ready to be refactored into modules yet.
  var btn = document.querySelector(".square");
</script>
Top level awaitTop level await is a feature available within modules. This means the await keyword can be used. It allows modules to act as big asynchronous functions meaning code can be evaluated before use in parent modules, but without blocking sibling modules from loading.
Let's take a look at an example. You can find all the files and code described in this section within the top-level-await directory, which extends from the previous examples.
Firstly we'll declare our color palette in a separate colors.json file:
json{
  "yellow": "#F4D03F",
  "green": "#52BE80",
  "blue": "#5499C7",
  "red": "#CD6155",
  "orange": "#F39C12"
}

Then we'll create a module called getColors.js which uses a fetch request to load the colors.json file and return the data as an object.
js// fetch request
const colors = fetch("../data/colors.json").then((response) => response.json());

export default await colors;

Notice the last export line here.
We're using the keyword await before specifying the constant colors to export. This means any other modules which include this one will wait until colors has been downloaded and parsed before using it.
Let's include this module in our main.js file:
jsimport colors from "./modules/getColors.js";
import { Canvas } from "./modules/canvas.js";

const circleBtn = document.querySelector(".circle");

// …

We'll use colors instead of the previously used strings when calling our shape functions:
jsconst square1 = new Module.Square(
  myCanvas.ctx,
  myCanvas.listId,
  50,
  50,
  100,
  colors.blue,
);

const circle1 = new Module.Circle(
  myCanvas.ctx,
  myCanvas.listId,
  75,
  200,
  100,
  colors.green,
);

const triangle1 = new Module.Triangle(
  myCanvas.ctx,
  myCanvas.listId,
  100,
  75,
  190,
  colors.yellow,
);

This is useful because the code within main.js won't execute until the code in getColors.js has run. However it won't block other modules being loaded. For instance our canvas.js module will continue to load while colors is being fetched.Import declarations are hoistedImport declarations are hoisted. In this case, it means that the imported values are available in the module's code even before the place that declares them, and that the imported module's side effects are produced before the rest of the module's code starts running.
So for example, in main.js, importing Canvas in the middle of the code would still work:
js// …
const myCanvas = new Canvas("myCanvas", document.body, 480, 320);
myCanvas.create();
import { Canvas } from "./modules/canvas.js";
myCanvas.createReportList();
// …

Still, it is considered good practice to put all your imports at the top of the code, which makes it easier to analyze dependencies.Cyclic importsModules can import other modules, and those modules can import other modules, and so on. This forms a directed graph called the "dependency graph". In an ideal world, this graph is acyclic. In this case, the graph can be evaluated using a depth-first traversal.
However, cycles are often inevitable. Cyclic import arises if module a imports module b, but b directly or indirectly depends on a. For example:
js// -- a.js --
import { b } from "./b.js";

// -- b.js --
import { a } from "./a.js";

// Cycle:
// a.js ───> b.js
//  ^         │
//  └─────────┘

Cyclic imports don't always fail. The imported variable's value is only retrieved when the variable is actually used (hence allowing live bindings), and only if the variable remains uninitialized at that time will a ReferenceError be thrown.
js// -- a.js --
import { b } from "./b.js";

setTimeout(() => {
  console.log(b); // 1
}, 10);

export const a = 2;

// -- b.js --
import { a } from "./a.js";

setTimeout(() => {
  console.log(a); // 2
}, 10);

export const b = 1;

In this example, both a and b are used asynchronously. Therefore, at the time the module is evaluated, neither b nor a is actually read, so the rest of the code is executed as normal, and the two export declarations produce the values of a and b. Then, after the timeout, both a and b are available, so the two console.log statements also execute as normal.
If you change the code to use a synchronously, the module evaluation fails:
js// -- a.js (entry module) --
import { b } from "./b.js";

export const a = 2;

// -- b.js --
import { a } from "./a.js";

console.log(a); // ReferenceError: Cannot access 'a' before initialization
export const b = 1;

This is because when JavaScript evaluates a.js, it needs to first evaluate b.js, the dependency of a.js. However, b.js uses a, which is not yet available.
On the other hand, if you change the code to use b synchronously but a asynchronously, the module evaluation succeeds:
js// -- a.js (entry module) --
import { b } from "./b.js";

console.log(b); // 1
export const a = 2;

// -- b.js --
import { a } from "./a.js";

setTimeout(() => {
  console.log(a); // 2
}, 10);
export const b = 1;

This is because the evaluation of b.js completes normally, so the value of b is available when a.js is evaluated.
You should usually avoid cyclic imports in your project, because they make your code more error-prone. Some common cycle-elimination techniques are:

Merge the two modules into one.
Move the shared code into a third module.
Move some code from one module to the other.

However, cyclic imports can also occur if the libraries depend on each other, which is harder to fix.Authoring "isomorphic" modulesThe introduction of modules encourages the JavaScript ecosystem to distribute and reuse code in a modular fashion. However, that doesn't necessarily mean a piece of JavaScript code can run in every environment. Suppose you discovered a module that generates SHA hashes of your user's password. Can you use it in the browser front end? Can you use it on your Node.js server? The answer is: it depends.
Modules still have access to global variables, as demonstrated previously. If the module references globals like window, it can run in the browser, but will throw an error in your Node.js server, because window is not available there. Similarly, if the code requires access to process to be functional, it can only be used in Node.js.
In order to maximize the reusability of a module, it is often advised to make the code "isomorphic" — that is, exhibits the same behavior in every runtime. This is commonly achieved in three ways:


Separate your modules into "core" and "binding". For the "core", focus on pure JavaScript logic like computing the hash, without any DOM, network, filesystem access, and expose utility functions. For the "binding" part, you can read from and write to the global context. For example, the "browser binding" may choose to read the value from an input box, while the "Node binding" may read it from process.env, but values read from either place will be piped to the same core function and handled in the same way. The core can be imported in every environment and used in the same way, while only the binding, which is usually lightweight, needs to be platform-specific.


Detect whether a particular global exists before using it. For example, if you test that typeof window === "undefined", you know that you are probably in a Node.js environment, and should not read DOM.
js// myModule.js
let password;
if (typeof process !== "undefined") {
  // We are running in Node.js; read it from `process.env`
  password = process.env.PASSWORD;
} else if (typeof window !== "undefined") {
  // We are running in the browser; read it from the input box
  password = document.getElementById("password").value;
}

This is preferable if the two branches actually end up with the same behavior ("isomorphic"). If it's impossible to provide the same functionality, or if doing so involves loading significant amounts of code while a large part remains unused, better use different "bindings" instead.


Use a polyfill to provide a fallback for missing features. For example, if you want to use the fetch function, which is only supported in Node.js since v18, you can use a similar API, like the one provided by node-fetch. You can do so conditionally through dynamic imports:
js// myModule.js
if (typeof fetch === "undefined") {
  // We are running in Node.js; use node-fetch
  globalThis.fetch = (await import("node-fetch")).default;
}
// …

The globalThis variable is a global object that is available in every environment and is useful if you want to read or create global variables within modules.


These practices are not unique to modules. Still, with the trend of code reusability and modularization, you are encouraged to make your code cross-platform so that it can be enjoyed by as many people as possible. Runtimes like Node.js are also actively implementing web APIs where possible to improve interoperability with the web.TroubleshootingHere are a few tips that may help you if you are having trouble getting your modules to work. Feel free to add to the list if you discover more!

We mentioned this before, but to reiterate: .mjs files need to be loaded with a MIME-type of text/javascript (or another JavaScript-compatible MIME-type, but text/javascript is recommended), otherwise you'll get a strict MIME type checking error like "The server responded with a non-JavaScript MIME type".
If you try to load the HTML file locally (i.e., with a file:// URL), you'll run into CORS errors due to JavaScript module security requirements. You need to do your testing through a server. GitHub pages is ideal as it also serves .mjs files with the correct MIME type.
Because .mjs is a non-standard file extension, some operating systems might not recognize it, or try to replace it with something else. For example, we found that macOS was silently adding on .js to the end of .mjs files and then automatically hiding the file extension. So all of our files were actually coming out as x.mjs.js. Once we turned off automatically hiding file extensions, and trained it to accept .mjs, it was OK.
See also
JavaScript modules on v8.dev (2018)
ES modules: A cartoon deep-dive on hacks.mozilla.org (2018)
ES6 in Depth: Modules on hacks.mozilla.org (2015)
Exploring JS, Ch.16: Modules by Dr. Axel Rauschmayer

 Previous Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJavaScript modules Previous 
This guide gives you all you need to get started with JavaScript module syntax.A background on modulesJavaScript programs started off pretty small — most of its usage in the early days was to do isolated scripting tasks, providing a bit of interactivity to your web pages where needed, so large scripts were generally not needed. Fast forward a few years and we now have complete applications being run in browsers with a lot of JavaScript, as well as JavaScript being used in other contexts (Node.js, for example).
Complex projects necessitate a mechanism for splitting JavaScript programs into separate modules that can be imported when needed. Node.js has had this ability for a long time, and there are a number of JavaScript libraries and frameworks that enable module usage (for example, other CommonJS and AMD-based module systems like RequireJS, webpack, and Babel).
All modern browsers support module features natively without needing transpilation. It can only be a good thing — browsers can optimize loading of modules, making it more efficient than having to use a library and do all of that extra client-side processing and extra round trips. It does not obsolete bundlers like webpack, though — bundlers still do a good job at partitioning code into reasonably sized chunks, and are able to do other optimizations like minification, dead code elimination, and tree-shaking.Introducing an exampleTo demonstrate usage of modules, we've created a set of examples that you can find on GitHub. These examples demonstrate a set of modules that create a <canvas> element on a webpage, and then draw (and report information about) different shapes on the canvas.
These are fairly trivial, but have been kept deliberately simple to demonstrate modules clearly.

Note:
If you want to download the examples and run them locally, you'll need to run them through a local web server.
Basic example structureIn our first example (see basic-modules) we have a file structure as follows:
index.html
main.js
modules/
    canvas.js
    square.js


Note:
All of the examples in this guide have basically the same structure; the above should start getting pretty familiar.

The modules directory's two modules are described below:


canvas.js — contains functions related to setting up the canvas:

create() — creates a canvas with a specified width and height inside a wrapper <div> with a specified ID, which is itself appended inside a specified parent element. Returns an object containing the canvas's 2D context and the wrapper's ID.
createReportList() — creates an unordered list appended inside a specified wrapper element, which can be used to output report data into. Returns the list's ID.



square.js — contains:

name — a constant containing the string 'square'.
draw() — draws a square on a specified canvas, with a specified size, position, and color. Returns an object containing the square's size, position, and color.
reportArea() — writes a square's area to a specific report list, given its length.
reportPerimeter() — writes a square's perimeter to a specific report list, given its length.


Aside — .mjs versus .jsThroughout this article, we've used .js extensions for our module files, but in other resources you may see the .mjs extension used instead. V8's documentation recommends this, for example. The reasons given are:

It is good for clarity, i.e., it makes it clear which files are modules, and which are regular JavaScript.
It ensures that your module files are parsed as a module by runtimes such as Node.js, and build tools such as Babel.

However, we decided to keep using .js, at least for the moment. To get modules to work correctly in a browser, you need to make sure that your server is serving them with a Content-Type header that contains a JavaScript MIME type such as text/javascript. If you don't, you'll get a strict MIME type checking error along the lines of "The server responded with a non-JavaScript MIME type" and the browser won't run your JavaScript. Most servers already set the correct type for .js files, but not yet for .mjs files. Servers that already serve .mjs files correctly include GitHub Pages and http-server for Node.js.
This is OK if you are using such an environment already, or if you aren't but you know what you are doing and have access (i.e., you can configure your server to set the correct Content-Type for .mjs files). It could however cause confusion if you don't control the server you are serving files from, or are publishing files for public use, as we are here.
For learning and portability purposes, we decided to keep to .js.
If you really value the clarity of using .mjs for modules versus using .js for "normal" JavaScript files, but don't want to run into the problem described above, you could always use .mjs during development and convert them to .js during your build step.
It is also worth noting that:

Some tools may never support .mjs.
The <script type="module"> attribute is used to denote when a module is being pointed to, as you'll see below.
Exporting module featuresThe first thing you do to get access to module features is export them. This is done using the export statement.
The easiest way to use it is to place it in front of any items you want exported out of the module, for example:
jsexport const name = "square";

export function draw(ctx, length, x, y, color) {
  ctx.fillStyle = color;
  ctx.fillRect(x, y, length, length);

  return { length, x, y, color };
}

You can export functions, var, let, const, and — as we'll see later — classes. They need to be top-level items: for example, you can't use export inside a function.
A more convenient way of exporting all the items you want to export is to use a single export statement at the end of your module file, followed by a comma-separated list of the features you want to export wrapped in curly braces. For example:
jsexport { name, draw, reportArea, reportPerimeter };
Importing features into your scriptOnce you've exported some features out of your module, you need to import them into your script to be able to use them. The simplest way to do this is as follows:
jsimport { name, draw, reportArea, reportPerimeter } from "./modules/square.js";

You use the import statement, followed by a comma-separated list of the features you want to import wrapped in curly braces, followed by the keyword from, followed by the module specifier.
The module specifier provides a string that the JavaScript environment can resolve to a path to the module file.
In a browser, this could be a path relative to the site root, which for our basic-modules example would be /js-examples/module-examples/basic-modules.
However, here we are instead using the dot (.) syntax to mean "the current location", followed by the relative path to the file we are trying to find. This is much better than writing out the entire absolute path each time, as relative paths are shorter and make the URL portable — the example will still work if you move it to a different location in the site hierarchy.
So for example:
bash/js-examples/module-examples/basic-modules/modules/square.js

becomes
bash./modules/square.js

You can see such lines in action in main.js.

Note:
In some module systems, you can use a module specifier like modules/square that isn't a relative or absolute path, and that doesn't have a file extension.
This kind of specifier can be used in a browser environment if you first define an import map.

Once you've imported the features into your script, you can use them just like they were defined inside the same file. The following is found in main.js, below the import lines:
jsconst myCanvas = create("myCanvas", document.body, 480, 320);
const reportList = createReportList(myCanvas.id);

const square1 = draw(myCanvas.ctx, 50, 50, 100, "blue");
reportArea(square1.length, reportList);
reportPerimeter(square1.length, reportList);


Note:
The imported values are read-only views of the features that were exported. Similar to const variables, you cannot re-assign the variable that was imported, but you can still modify properties of object values. The value can only be re-assigned by the module exporting it. See the import reference for an example.
Importing modules using import mapsAbove we saw how a browser can import a module using a module specifier that is either an absolute URL, or a relative URL that is resolved using the base URL of the document:
jsimport { name as squareName, draw } from "./shapes/square.js";
import { name as circleName } from "https://example.com/shapes/circle.js";

Import maps allow developers to instead specify almost any text they want in the module specifier when importing a module; the map provides a corresponding value that will replace the text when the module URL is resolved.
For example, the imports key in the import map below defines a "module specifier map" JSON object where the property names can be used as module specifiers, and the corresponding values will be substituted when the browser resolves the module URL.
The values must be absolute or relative URLs.
Relative URLs are resolved to absolute URL addresses using the base URL of the document containing the import map.
html<script type="importmap">
  {
    "imports": {
      "shapes": "./shapes/square.js",
      "shapes/square": "./modules/shapes/square.js",
      "https://example.com/shapes/square.js": "./shapes/square.js",
      "https://example.com/shapes/": "/shapes/square/",
      "../shapes/square": "./shapes/square.js"
    }
  }
</script>

The import map is defined using a JSON object inside a <script> element with the type attribute set to importmap.
Note that an import map only applies to the document — the specification does not cover how to apply an import map in a worker or worklet context. 
With this map you can now use the property names above as module specifiers.
If there is no trailing forward slash on the module specifier key then the whole module specifier key is matched and substituted.
For example, below we match bare module names, and remap a URL to another path.
js// Bare module names as module specifiers
import { name as squareNameOne } from "shapes";
import { name as squareNameTwo } from "shapes/square";

// Remap a URL to another URL
import { name as squareNameThree } from "https://example.com/shapes/square.js";

If the module specifier has a trailing forward slash then the value must have one as well, and the key is matched as a "path prefix".
This allows remapping of whole classes of URLs.
js// Remap a URL as a prefix ( https://example.com/shapes/)
import { name as squareNameFour } from "https://example.com/shapes/moduleshapes/square.js";

It is possible for multiple keys in an import map to be valid matches for a module specifier.
For example, a module specifier of shapes/circle/ could match the module specifier keys shapes/ and shapes/circle/.
In this case the browser will select the most specific (longest) matching module specifier key.
Import maps allow modules to be imported using bare module names (as in Node.js), and can also simulate importing modules from packages, both with and without file extensions.
While not shown above, they also allow particular versions of a library to be imported, based on the path of the script that is importing the module.
Generally they let developers write more ergonomic import code, and make it easier to manage the different versions and dependencies of modules used by a site.
This can reduce the effort required to use the same JavaScript libraries in both browser and server.
The following sections expand on the various features outlined above.Feature detectionYou can check support for import maps using the HTMLScriptElement.supports() static method (which is itself broadly supported):
jsif (HTMLScriptElement.supports?.("importmap")) {
  console.log("Browser supports import maps.");
}
Importing modules as bare namesIn some JavaScript environments, such as Node.js, you can use bare names for the module specifier.
This works because the environment can resolve module names to a standard location in the file system.
For example, you might use the following syntax to import the "square" module.
jsimport { name, draw, reportArea, reportPerimeter } from "square";

To use bare names on a browser you need an import map, which provides the information needed by the browser to resolve module specifiers to URLs (JavaScript will throw a TypeError if it attempts to import a module specifier that can't be resolved to a module location).
Below you can see a map that defines a square module specifier key, which in this case maps to a relative address value.
html<script type="importmap">
  {
    "imports": {
      "square": "./shapes/square.js"
    }
  }
</script>

With this map we can now use a bare name when we import the module:
jsimport { name as squareName, draw } from "square";
Remapping module pathsModule specifier map entries, where both the specifier key and its associated value have a trailing forward slash (/), can be used as a path-prefix.
This allows the remapping of a whole set of import URLs from one location to another.
It can also be used to emulate working with "packages and modules", such as you might see in the Node ecosystem.

Note:
The trailing / indicates that the module specifier key can be substituted as part of a module specifier.
If this is not present, the browser will only match (and substitute) the whole module specifier key.

Packages of modules
The following JSON import map definition maps lodash as a bare name, and the module specifier prefix lodash/ to the path /node_modules/lodash-es/ (resolved to the document base URL):
json{
  "imports": {
    "lodash": "/node_modules/lodash-es/lodash.js",
    "lodash/": "/node_modules/lodash-es/"
  }
}

With this mapping you can import both the whole "package", using the bare name, and modules within it (using the path mapping):
jsimport _ from "lodash";
import fp from "lodash/fp.js";

It is possible to import fp above without the .js file extension, but you would need to create a bare module specifier key for that file, such as lodash/fp, rather than using the path.
This may be reasonable for just one module, but scales poorly if you wish to import many modules.
General URL remapping
A module specifier key doesn't have to be path — it can also be an absolute URL (or a URL-like relative path like ./, ../, /).
This may be useful if you want to remap a module that has absolute paths to a resource with your own local resources.
json{
  "imports": {
    "https://www.unpkg.com/moment/": "/node_modules/moment/"
  }
}
Scoped modules for version managementEcosystems like Node use package managers such as npm to manage modules and their dependencies.
The package manager ensures that each module is separated from other modules and their dependencies.
As a result, while a complex application might include the same module multiple times with several different versions in different parts of the module graph, users do not need to think about this complexity.

Note:
You can also achieve version management using relative paths, but this is subpar because, among other things, this forces a particular structure on your project, and prevents you from using bare module names.

Import maps similarly allow you to have multiple versions of dependencies in your application and refer to them using the same module specifier.
You implement this with the scopes key, which allows you to provide module specifier maps that will be used depending on the path of the script performing the import.
The example below demonstrates this.
json{
  "imports": {
    "cool-module": "/node_modules/cool-module/index.js"
  },
  "scopes": {
    "/node_modules/dependency/": {
      "cool-module": "/node_modules/some/other/location/cool-module/index.js"
    }
  }
}

With this mapping, if a script with an URL that contains /node_modules/dependency/ imports cool-module, the version in /node_modules/some/other/location/cool-module/index.js will be used.
The map in imports is used as a fallback if there is no matching scope in the scoped map, or the matching scopes don't contain a matching specifier. For example, if cool-module is imported from a script with a non-matching scope path, then the module specifier map in imports will be used instead, mapping to the version in /node_modules/cool-module/index.js.
Note that the path used to select a scope does not affect how the address is resolved.
The value in the mapped path does not have to match the scopes path, and relative paths are still resolved to the base URL of the script that contains the import map.
Just as for module specifier maps, you can have many scope keys, and these may contain overlapping paths.
If multiple scopes match the referrer URL, then the most specific scope path is checked first (the longest scope key) for a matching specifier.
The browsers will fall back to the next most specific matching scoped path if there is no matching specifier, and so on.
If there is no matching specifier in any of the matching scopes, the browser checks for a match in the module specifier map in the imports key.Improve caching by mapping away hashed filenamesScript files used by websites often have hashed filenames to simplify caching.
The downside of this approach is that if a module changes, any modules that import it using its hashed filename will also need to be updated/regenerated.
This potentially results in a cascade of updates, which is wasteful of network resources.
Import maps provide a convenient solution to this problem.
Rather than depending on specific hashed filenames, applications and scripts instead depend on an un-hashed version of the module name (address).
An import map like the one below then provides a mapping to the actual script file.
json{
  "imports": {
    "main_script": "/node/srcs/application-fg7744e1b.js",
    "dependency_script": "/node/srcs/dependency-3qn7e4b1q.js"
  }
}

If dependency_script changes, then its hash contained in the file name changes as well. In this case, we only need to update the import map to reflect the changed name of the module.
We don't have to update the source of any JavaScript code that depends on it, because the specifier in the import statement does not change.Loading non-JavaScript resourcesOne exciting feature that a unified module architecture brings is the ability to load non-JavaScript resources as modules. For example, you can import JSON as a JavaScript object, or import CSS as a CSSStyleSheet object.
You must explicitly declare what kind of resource you are importing. By default, the browser assumes that the resource is JavaScript, and will throw an error if the resolved resource is something else. To import JSON, CSS, or other types of resource, use the import attributes syntax:
jsimport colors from "./colors.json" with { type: "json" };
import styles from "./styles.css" with { type: "css" };

Browsers will also perform validation on the module type, and fail if, for example, ./data.json does not resolve to a JSON file. This ensures that you don't accidentally execute code when you just intend to import data. Once imported successfully, you can now use the imported value as a normal JavaScript object or CSSStyleSheet object.
jsconsole.log(colors.map((color) => color.value));
document.adoptedStyleSheets = [styles];
Applying the module to your HTMLNow we just need to apply the main.js module to our HTML page. This is very similar to how we apply a regular script to a page, with a few notable differences.
First of all, you need to include type="module" in the <script> element, to declare this script as a module. To import the main.js script, we use this:
html<script type="module" src="main.js"></script>

You can also embed the module's script directly into the HTML file by placing the JavaScript code within the body of the <script> element:
html<script type="module">
  /* JavaScript module code here */
</script>

You can only use import and export statements inside modules, not regular scripts. An error will be thrown if your <script> element doesn't have the type="module" attribute and attempts to import other modules. For example:
html<script>
  import _ from "lodash"; // SyntaxError: import declarations may only appear at top level of a module
  // ...
</script>
<script src="a-module-using-import-statements.js"></script>
<!-- SyntaxError: import declarations may only appear at top level of a module -->

You should generally define all your modules in separate files. Modules declared inline in HTML can only import other modules, but anything they export will not be accessible by other modules (because they don't have a URL).

Note:
Modules and their dependencies can be preloaded by specifying them in <link> elements with rel="modulepreload".
This can significantly reduce load time when the modules are used.
Other differences between modules and classic scripts
You need to pay attention to local testing — if you try to load the HTML file locally (i.e., with a file:// URL), you'll run into CORS errors due to JavaScript module security requirements. You need to do your testing through a server.
Also, note that you might get different behavior from sections of script defined inside modules as opposed to in classic scripts. This is because modules use strict mode automatically.
There is no need to use the defer attribute (see <script> attributes) when loading a module script; modules are deferred automatically.
Modules are only executed once, even if they have been referenced in multiple <script> tags.
Last but not least, let's make this clear — module features are imported into the scope of a single script — they aren't available in the global scope. Therefore, you will only be able to access imported features in the script they are imported into, and you won't be able to access them from the JavaScript console, for example. You'll still get syntax errors shown in the DevTools, but you'll not be able to use some of the debugging techniques you might have expected to use.

Module-defined variables are scoped to the module unless explicitly attached to the global object. On the other hand, globally-defined variables are available within the module. For example, given the following code:
html<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8" />
    <title></title>
    <link rel="stylesheet" href="" />
  </head>
  <body>
    <div id="main"></div>
    <script>
      // A var statement creates a global variable.
      var text = "Hello";
    </script>
    <script type="module" src="./render.js"></script>
  </body>
</html>

js/* render.js */
document.getElementById("main").innerText = text;

The page would still render Hello, because the global variables text and document are available in the module. (Also note from this example that a module doesn't necessarily need an import/export statement — the only thing needed is for the entry point to have type="module".)Default exports versus named exportsThe functionality we've exported so far has been comprised of named exports — each item (be it a function, const, etc.) has been referred to by its name upon export, and that name has been used to refer to it on import as well.
There is also a type of export called the default export — this is designed to make it easy to have a default function provided by a module, and also helps JavaScript modules to interoperate with existing CommonJS and AMD module systems (as explained nicely in ES6 In Depth: Modules by Jason Orendorff; search for "Default exports").
Let's look at an example as we explain how it works. In our basic-modules square.js you can find a function called randomSquare() that creates a square with a random color, size, and position. We want to export this as our default, so at the bottom of the file we write this:
jsexport default randomSquare;

Note the lack of curly braces.
We could instead prepend export default onto the function and define it as an anonymous function, like this:
jsexport default function (ctx) {
  // …
}

Over in our main.js file, we import the default function using this line:
jsimport randomSquare from "./modules/square.js";

Again, note the lack of curly braces. This is because there is only one default export allowed per module, and we know that randomSquare is it. The above line is basically shorthand for:
jsimport { default as randomSquare } from "./modules/square.js";


Note:
The as syntax for renaming exported items is explained below in the Renaming imports and exports section.
Avoiding naming conflictsSo far, our canvas shape drawing modules seem to be working OK. But what happens if we try to add a module that deals with drawing another shape, like a circle or triangle? These shapes would probably have associated functions like draw(), reportArea(), etc. too; if we tried to import different functions of the same name into the same top-level module file, we'd end up with conflicts and errors.
Fortunately there are a number of ways to get around this. We'll look at these in the following sections.Renaming imports and exportsInside your import and export statement's curly braces, you can use the keyword as along with a new feature name, to change the identifying name you will use for a feature inside the top-level module.
So for example, both of the following would do the same job, albeit in a slightly different way:
js// inside module.js
export { function1 as newFunctionName, function2 as anotherNewFunctionName };

// inside main.js
import { newFunctionName, anotherNewFunctionName } from "./modules/module.js";

js// inside module.js
export { function1, function2 };

// inside main.js
import {
  function1 as newFunctionName,
  function2 as anotherNewFunctionName,
} from "./modules/module.js";

Let's look at a real example. In our renaming directory you'll see the same module system as in the previous example, except that we've added circle.js and triangle.js modules to draw and report on circles and triangles.
Inside each of these modules, we've got features with the same names being exported, and therefore each has the same export statement at the bottom:
jsexport { name, draw, reportArea, reportPerimeter };

When importing these into main.js, if we tried to use
jsimport { name, draw, reportArea, reportPerimeter } from "./modules/square.js";
import { name, draw, reportArea, reportPerimeter } from "./modules/circle.js";
import { name, draw, reportArea, reportPerimeter } from "./modules/triangle.js";

The browser would throw an error such as "SyntaxError: redeclaration of import name" (Firefox).
Instead we need to rename the imports so that they are unique:
jsimport {
  name as squareName,
  draw as drawSquare,
  reportArea as reportSquareArea,
  reportPerimeter as reportSquarePerimeter,
} from "./modules/square.js";

import {
  name as circleName,
  draw as drawCircle,
  reportArea as reportCircleArea,
  reportPerimeter as reportCirclePerimeter,
} from "./modules/circle.js";

import {
  name as triangleName,
  draw as drawTriangle,
  reportArea as reportTriangleArea,
  reportPerimeter as reportTrianglePerimeter,
} from "./modules/triangle.js";

Note that you could solve the problem in the module files instead, e.g.
js// in square.js
export {
  name as squareName,
  draw as drawSquare,
  reportArea as reportSquareArea,
  reportPerimeter as reportSquarePerimeter,
};

js// in main.js
import {
  squareName,
  drawSquare,
  reportSquareArea,
  reportSquarePerimeter,
} from "./modules/square.js";

And it would work just the same. What style you use is up to you, however it arguably makes more sense to leave your module code alone, and make the changes in the imports. This especially makes sense when you are importing from third party modules that you don't have any control over.Creating a module objectThe above method works OK, but it's a little messy and long-winded. An even better solution is to import each module's features inside a module object. The following syntax form does that:
jsimport * as Module from "./modules/module.js";

This grabs all the exports available inside module.js, and makes them available as members of an object Module, effectively giving it its own namespace. So for example:
jsModule.function1();
Module.function2();

Again, let's look at a real example. If you go to our module-objects directory, you'll see the same example again, but rewritten to take advantage of this new syntax. In the modules, the exports are all in the following simple form:
jsexport { name, draw, reportArea, reportPerimeter };

The imports on the other hand look like this:
jsimport * as Canvas from "./modules/canvas.js";

import * as Square from "./modules/square.js";
import * as Circle from "./modules/circle.js";
import * as Triangle from "./modules/triangle.js";

In each case, you can now access the module's imports underneath the specified object name, for example:
jsconst square1 = Square.draw(myCanvas.ctx, 50, 50, 100, "blue");
Square.reportArea(square1.length, reportList);
Square.reportPerimeter(square1.length, reportList);

So you can now write the code just the same as before (as long as you include the object names where needed), and the imports are much neater.Modules and classesAs we hinted at earlier, you can also export and import classes; this is another option for avoiding conflicts in your code, and is especially useful if you've already got your module code written in an object-oriented style.
You can see an example of our shape drawing module rewritten with ES classes in our classes directory. As an example, the square.js file now contains all its functionality in a single class:
jsclass Square {
  constructor(ctx, listId, length, x, y, color) {
    // …
  }

  draw() {
    // …
  }

  // …
}

which we then export:
jsexport { Square };

Over in main.js, we import it like this:
jsimport { Square } from "./modules/square.js";

And then use the class to draw our square:
jsconst square1 = new Square(myCanvas.ctx, myCanvas.listId, 50, 50, 100, "blue");
square1.draw();
square1.reportArea();
square1.reportPerimeter();
Aggregating modulesThere will be times where you'll want to aggregate modules together. You might have multiple levels of dependencies, where you want to simplify things, combining several submodules into one parent module. This is possible using export syntax of the following forms in the parent module:
jsexport * from "x.js";
export { name } from "x.js";

For an example, see our module-aggregation directory. In this example (based on our earlier classes example) we've got an extra module called shapes.js, which aggregates all the functionality from circle.js, square.js, and triangle.js together. We've also moved our submodules inside a subdirectory inside the modules directory called shapes. So the module structure in this example is:
modules/
  canvas.js
  shapes.js
  shapes/
    circle.js
    square.js
    triangle.js

In each of the submodules, the export is of the same form, e.g.
jsexport { Square };

Next up comes the aggregation part. Inside shapes.js, we include the following lines:
jsexport { Square } from "./shapes/square.js";
export { Triangle } from "./shapes/triangle.js";
export { Circle } from "./shapes/circle.js";

These grab the exports from the individual submodules and effectively make them available from the shapes.js module.

Note:
The exports referenced in shapes.js basically get redirected through the file and don't really exist there, so you won't be able to write any useful related code inside the same file.

So now in the main.js file, we can get access to all three module classes by replacing
jsimport { Square } from "./modules/square.js";
import { Circle } from "./modules/circle.js";
import { Triangle } from "./modules/triangle.js";

with the following single line:
jsimport { Square, Circle, Triangle } from "./modules/shapes.js";
Dynamic module loadingA recent addition to JavaScript modules functionality is dynamic module loading. This allows you to dynamically load modules only when they are needed, rather than having to load everything up front. This has some obvious performance advantages; let's read on and see how it works.
This new functionality allows you to call import() as a function, passing it the path to the module as a parameter. It returns a Promise, which fulfills with a module object (see Creating a module object) giving you access to that object's exports. For example:
jsimport("./modules/myModule.js").then((module) => {
  // Do something with the module.
});


Note:
Dynamic import is permitted in the browser main thread, and in shared and dedicated workers.
However import() will throw if called in a service worker or worklet.


Let's look at an example. In the dynamic-module-imports directory we've got another example based on our classes example. This time however we are not drawing anything on the canvas when the example loads. Instead, we include three buttons — "Circle", "Square", and "Triangle" — that, when pressed, dynamically load the required module and then use it to draw the associated shape.
In this example we've only made changes to our index.html and main.js files — the module exports remain the same as before.
Over in main.js we've grabbed a reference to each button using a document.querySelector() call, for example:
jsconst squareBtn = document.querySelector(".square");

We then attach an event listener to each button so that when pressed, the relevant module is dynamically loaded and used to draw the shape:
jssquareBtn.addEventListener("click", () => {
  import("./modules/square.js").then((Module) => {
    const square1 = new Module.Square(
      myCanvas.ctx,
      myCanvas.listId,
      50,
      50,
      100,
      "blue",
    );
    square1.draw();
    square1.reportArea();
    square1.reportPerimeter();
  });
});

Note that, because the promise fulfillment returns a module object, the class is then made a subfeature of the object, hence we now need to access the constructor with Module. prepended to it, e.g., Module.Square( /* … */ ).
Another advantage of dynamic imports is that they are always available, even in script environments. Therefore, if you have an existing <script> tag in your HTML that doesn't have type="module", you can still reuse code distributed as modules by dynamically importing it.
html<script>
  import("./modules/square.js").then((module) => {
    // Do something with the module.
  });
  // Other code that operates on the global scope and is not
  // ready to be refactored into modules yet.
  var btn = document.querySelector(".square");
</script>
Top level awaitTop level await is a feature available within modules. This means the await keyword can be used. It allows modules to act as big asynchronous functions meaning code can be evaluated before use in parent modules, but without blocking sibling modules from loading.
Let's take a look at an example. You can find all the files and code described in this section within the top-level-await directory, which extends from the previous examples.
Firstly we'll declare our color palette in a separate colors.json file:
json{
  "yellow": "#F4D03F",
  "green": "#52BE80",
  "blue": "#5499C7",
  "red": "#CD6155",
  "orange": "#F39C12"
}

Then we'll create a module called getColors.js which uses a fetch request to load the colors.json file and return the data as an object.
js// fetch request
const colors = fetch("../data/colors.json").then((response) => response.json());

export default await colors;

Notice the last export line here.
We're using the keyword await before specifying the constant colors to export. This means any other modules which include this one will wait until colors has been downloaded and parsed before using it.
Let's include this module in our main.js file:
jsimport colors from "./modules/getColors.js";
import { Canvas } from "./modules/canvas.js";

const circleBtn = document.querySelector(".circle");

// …

We'll use colors instead of the previously used strings when calling our shape functions:
jsconst square1 = new Module.Square(
  myCanvas.ctx,
  myCanvas.listId,
  50,
  50,
  100,
  colors.blue,
);

const circle1 = new Module.Circle(
  myCanvas.ctx,
  myCanvas.listId,
  75,
  200,
  100,
  colors.green,
);

const triangle1 = new Module.Triangle(
  myCanvas.ctx,
  myCanvas.listId,
  100,
  75,
  190,
  colors.yellow,
);

This is useful because the code within main.js won't execute until the code in getColors.js has run. However it won't block other modules being loaded. For instance our canvas.js module will continue to load while colors is being fetched.Import declarations are hoistedImport declarations are hoisted. In this case, it means that the imported values are available in the module's code even before the place that declares them, and that the imported module's side effects are produced before the rest of the module's code starts running.
So for example, in main.js, importing Canvas in the middle of the code would still work:
js// …
const myCanvas = new Canvas("myCanvas", document.body, 480, 320);
myCanvas.create();
import { Canvas } from "./modules/canvas.js";
myCanvas.createReportList();
// …

Still, it is considered good practice to put all your imports at the top of the code, which makes it easier to analyze dependencies.Cyclic importsModules can import other modules, and those modules can import other modules, and so on. This forms a directed graph called the "dependency graph". In an ideal world, this graph is acyclic. In this case, the graph can be evaluated using a depth-first traversal.
However, cycles are often inevitable. Cyclic import arises if module a imports module b, but b directly or indirectly depends on a. For example:
js// -- a.js --
import { b } from "./b.js";

// -- b.js --
import { a } from "./a.js";

// Cycle:
// a.js ───> b.js
//  ^         │
//  └─────────┘

Cyclic imports don't always fail. The imported variable's value is only retrieved when the variable is actually used (hence allowing live bindings), and only if the variable remains uninitialized at that time will a ReferenceError be thrown.
js// -- a.js --
import { b } from "./b.js";

setTimeout(() => {
  console.log(b); // 1
}, 10);

export const a = 2;

// -- b.js --
import { a } from "./a.js";

setTimeout(() => {
  console.log(a); // 2
}, 10);

export const b = 1;

In this example, both a and b are used asynchronously. Therefore, at the time the module is evaluated, neither b nor a is actually read, so the rest of the code is executed as normal, and the two export declarations produce the values of a and b. Then, after the timeout, both a and b are available, so the two console.log statements also execute as normal.
If you change the code to use a synchronously, the module evaluation fails:
js// -- a.js (entry module) --
import { b } from "./b.js";

export const a = 2;

// -- b.js --
import { a } from "./a.js";

console.log(a); // ReferenceError: Cannot access 'a' before initialization
export const b = 1;

This is because when JavaScript evaluates a.js, it needs to first evaluate b.js, the dependency of a.js. However, b.js uses a, which is not yet available.
On the other hand, if you change the code to use b synchronously but a asynchronously, the module evaluation succeeds:
js// -- a.js (entry module) --
import { b } from "./b.js";

console.log(b); // 1
export const a = 2;

// -- b.js --
import { a } from "./a.js";

setTimeout(() => {
  console.log(a); // 2
}, 10);
export const b = 1;

This is because the evaluation of b.js completes normally, so the value of b is available when a.js is evaluated.
You should usually avoid cyclic imports in your project, because they make your code more error-prone. Some common cycle-elimination techniques are:

Merge the two modules into one.
Move the shared code into a third module.
Move some code from one module to the other.

However, cyclic imports can also occur if the libraries depend on each other, which is harder to fix.Authoring "isomorphic" modulesThe introduction of modules encourages the JavaScript ecosystem to distribute and reuse code in a modular fashion. However, that doesn't necessarily mean a piece of JavaScript code can run in every environment. Suppose you discovered a module that generates SHA hashes of your user's password. Can you use it in the browser front end? Can you use it on your Node.js server? The answer is: it depends.
Modules still have access to global variables, as demonstrated previously. If the module references globals like window, it can run in the browser, but will throw an error in your Node.js server, because window is not available there. Similarly, if the code requires access to process to be functional, it can only be used in Node.js.
In order to maximize the reusability of a module, it is often advised to make the code "isomorphic" — that is, exhibits the same behavior in every runtime. This is commonly achieved in three ways:


Separate your modules into "core" and "binding". For the "core", focus on pure JavaScript logic like computing the hash, without any DOM, network, filesystem access, and expose utility functions. For the "binding" part, you can read from and write to the global context. For example, the "browser binding" may choose to read the value from an input box, while the "Node binding" may read it from process.env, but values read from either place will be piped to the same core function and handled in the same way. The core can be imported in every environment and used in the same way, while only the binding, which is usually lightweight, needs to be platform-specific.


Detect whether a particular global exists before using it. For example, if you test that typeof window === "undefined", you know that you are probably in a Node.js environment, and should not read DOM.
js// myModule.js
let password;
if (typeof process !== "undefined") {
  // We are running in Node.js; read it from `process.env`
  password = process.env.PASSWORD;
} else if (typeof window !== "undefined") {
  // We are running in the browser; read it from the input box
  password = document.getElementById("password").value;
}

This is preferable if the two branches actually end up with the same behavior ("isomorphic"). If it's impossible to provide the same functionality, or if doing so involves loading significant amounts of code while a large part remains unused, better use different "bindings" instead.


Use a polyfill to provide a fallback for missing features. For example, if you want to use the fetch function, which is only supported in Node.js since v18, you can use a similar API, like the one provided by node-fetch. You can do so conditionally through dynamic imports:
js// myModule.js
if (typeof fetch === "undefined") {
  // We are running in Node.js; use node-fetch
  globalThis.fetch = (await import("node-fetch")).default;
}
// …

The globalThis variable is a global object that is available in every environment and is useful if you want to read or create global variables within modules.


These practices are not unique to modules. Still, with the trend of code reusability and modularization, you are encouraged to make your code cross-platform so that it can be enjoyed by as many people as possible. Runtimes like Node.js are also actively implementing web APIs where possible to improve interoperability with the web.TroubleshootingHere are a few tips that may help you if you are having trouble getting your modules to work. Feel free to add to the list if you discover more!

We mentioned this before, but to reiterate: .mjs files need to be loaded with a MIME-type of text/javascript (or another JavaScript-compatible MIME-type, but text/javascript is recommended), otherwise you'll get a strict MIME type checking error like "The server responded with a non-JavaScript MIME type".
If you try to load the HTML file locally (i.e., with a file:// URL), you'll run into CORS errors due to JavaScript module security requirements. You need to do your testing through a server. GitHub pages is ideal as it also serves .mjs files with the correct MIME type.
Because .mjs is a non-standard file extension, some operating systems might not recognize it, or try to replace it with something else. For example, we found that macOS was silently adding on .js to the end of .mjs files and then automatically hiding the file extension. So all of our files were actually coming out as x.mjs.js. Once we turned off automatically hiding file extensions, and trained it to accept .mjs, it was OK.
See also
JavaScript modules on v8.dev (2018)
ES modules: A cartoon deep-dive on hacks.mozilla.org (2018)
ES6 in Depth: Modules on hacks.mozilla.org (2015)
Exploring JS, Ch.16: Modules by Dr. Axel Rauschmayer

 Previous Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nAdvanced JavaScript objects Overview: Extension modules Next  
In JavaScript, most things are objects, from core JavaScript features like arrays to the browser APIs built on top of JavaScript. You can also create your own objects to encapsulate related functions and variables into efficient packages and act as handy data containers.
Having a deeper knowledge of how JavaScript objects work is useful as you build confidence with web development, start to build more complex apps, and create your own libraries. This module will help you by providing JavaScript object theory and object-oriented programming practice.PrerequisitesBefore starting this module, You should really have learnt the fundamentals of JavaScript, especially JavaScript object basics. It would also be helpful to have some familiarity with HTML and CSS.

Note:
If you are working on a computer/tablet/other devices where you are not able to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
Object prototypes

Prototypes are the mechanism by which JavaScript objects inherit features from one another, and they work differently from inheritance mechanisms in classical object-oriented programming languages. In this article, we explore how prototype chains work.

Object-oriented programming

In this article, we'll describe some of the basic principles of "classical" object-oriented programming, and look at the ways it is different from the prototype model in JavaScript.

Classes in JavaScript

JavaScript provides some features for people wanting to implement "classical" object-oriented programs, and in this article, we'll describe these features.

Object building practice

In previous articles we looked at all the essential JavaScript object theory and syntax details, giving you a solid base to start from. In this article we dive into a practical exercise, giving you some more practice in building custom JavaScript objects, which produce something fun and colorful — some colored bouncing balls.

Adding features to our bouncing balls demo Challenge

In this challenge, you are expected to use the bouncing balls demo from the previous article as a starting point, and add some new and interesting features to it.

See also
Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.\n\nAdvanced JavaScript objects Overview: Extension modules Next  
In JavaScript, most things are objects, from core JavaScript features like arrays to the browser APIs built on top of JavaScript. You can also create your own objects to encapsulate related functions and variables into efficient packages and act as handy data containers.
Having a deeper knowledge of how JavaScript objects work is useful as you build confidence with web development, start to build more complex apps, and create your own libraries. This module will help you by providing JavaScript object theory and object-oriented programming practice.PrerequisitesBefore starting this module, You should really have learnt the fundamentals of JavaScript, especially JavaScript object basics. It would also be helpful to have some familiarity with HTML and CSS.

Note:
If you are working on a computer/tablet/other devices where you are not able to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
Object prototypes

Prototypes are the mechanism by which JavaScript objects inherit features from one another, and they work differently from inheritance mechanisms in classical object-oriented programming languages. In this article, we explore how prototype chains work.

Object-oriented programming

In this article, we'll describe some of the basic principles of "classical" object-oriented programming, and look at the ways it is different from the prototype model in JavaScript.

Classes in JavaScript

JavaScript provides some features for people wanting to implement "classical" object-oriented programs, and in this article, we'll describe these features.

Object building practice

In previous articles we looked at all the essential JavaScript object theory and syntax details, giving you a solid base to start from. In this article we dive into a practical exercise, giving you some more practice in building custom JavaScript objects, which produce something fun and colorful — some colored bouncing balls.

Adding features to our bouncing balls demo Challenge

In this challenge, you are expected to use the bouncing balls demo from the previous article as a starting point, and add some new and interesting features to it.

See also
Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nAdvanced JavaScript objects Overview: Extension modules Next  
In JavaScript, most things are objects, from core JavaScript features like arrays to the browser APIs built on top of JavaScript. You can also create your own objects to encapsulate related functions and variables into efficient packages and act as handy data containers.
Having a deeper knowledge of how JavaScript objects work is useful as you build confidence with web development, start to build more complex apps, and create your own libraries. This module will help you by providing JavaScript object theory and object-oriented programming practice.PrerequisitesBefore starting this module, You should really have learnt the fundamentals of JavaScript, especially JavaScript object basics. It would also be helpful to have some familiarity with HTML and CSS.

Note:
If you are working on a computer/tablet/other devices where you are not able to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
Object prototypes

Prototypes are the mechanism by which JavaScript objects inherit features from one another, and they work differently from inheritance mechanisms in classical object-oriented programming languages. In this article, we explore how prototype chains work.

Object-oriented programming

In this article, we'll describe some of the basic principles of "classical" object-oriented programming, and look at the ways it is different from the prototype model in JavaScript.

Classes in JavaScript

JavaScript provides some features for people wanting to implement "classical" object-oriented programs, and in this article, we'll describe these features.

Object building practice

In previous articles we looked at all the essential JavaScript object theory and syntax details, giving you a solid base to start from. In this article we dive into a practical exercise, giving you some more practice in building custom JavaScript objects, which produce something fun and colorful — some colored bouncing balls.

Adding features to our bouncing balls demo Challenge

In this challenge, you are expected to use the bouncing balls demo from the previous article as a starting point, and add some new and interesting features to it.

See also
Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nAsynchronous JavaScript Overview: Extension modules Next  
In this module, we take a look at asynchronous JavaScript, why it is important, and how it can be used to effectively handle potential blocking operations, such as fetching resources from a server.PrerequisitesAsynchronous JavaScript is a fairly advanced topic, and you are advised to work through Dynamic scripting with JavaScript modules before attempting this.

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you can try out (most of) the code examples in an online coding program such as JS Bin or Glitch.
Tutorials and challenges
Introducing asynchronous JavaScript

In this article, we'll learn about synchronous and asynchronous programming, why we often need to use asynchronous techniques, and the problems related to the way asynchronous functions have historically been implemented in JavaScript.

How to use promises

Here we'll introduce promises and show how to use promise-based APIs. We'll also introduce the async and await keywords.

Implementing a promise-based API

This article will outline how to implement your own promise-based API.

Introducing workers

Workers enable you to run certain tasks in a separate thread to keep your main code responsive. In this article, we'll rewrite a long-running synchronous function to use a worker.

Sequencing animations Challenge

This challenge asks you to use promises to play a set of animations in a particular sequence.

See also
Asynchronous Programming from the fantastic Eloquent JavaScript online book by Marijn Haverbeke.

 Overview: Extension modules Next\n\nAsynchronous JavaScript Overview: Extension modules Next  
In this module, we take a look at asynchronous JavaScript, why it is important, and how it can be used to effectively handle potential blocking operations, such as fetching resources from a server.PrerequisitesAsynchronous JavaScript is a fairly advanced topic, and you are advised to work through Dynamic scripting with JavaScript modules before attempting this.

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you can try out (most of) the code examples in an online coding program such as JS Bin or Glitch.
Tutorials and challenges
Introducing asynchronous JavaScript

In this article, we'll learn about synchronous and asynchronous programming, why we often need to use asynchronous techniques, and the problems related to the way asynchronous functions have historically been implemented in JavaScript.

How to use promises

Here we'll introduce promises and show how to use promise-based APIs. We'll also introduce the async and await keywords.

Implementing a promise-based API

This article will outline how to implement your own promise-based API.

Introducing workers

Workers enable you to run certain tasks in a separate thread to keep your main code responsive. In this article, we'll rewrite a long-running synchronous function to use a worker.

Sequencing animations Challenge

This challenge asks you to use promises to play a set of animations in a particular sequence.

See also
Asynchronous Programming from the fantastic Eloquent JavaScript online book by Marijn Haverbeke.

 Overview: Extension modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nAsynchronous JavaScript Overview: Extension modules Next  
In this module, we take a look at asynchronous JavaScript, why it is important, and how it can be used to effectively handle potential blocking operations, such as fetching resources from a server.PrerequisitesAsynchronous JavaScript is a fairly advanced topic, and you are advised to work through Dynamic scripting with JavaScript modules before attempting this.

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you can try out (most of) the code examples in an online coding program such as JS Bin or Glitch.
Tutorials and challenges
Introducing asynchronous JavaScript

In this article, we'll learn about synchronous and asynchronous programming, why we often need to use asynchronous techniques, and the problems related to the way asynchronous functions have historically been implemented in JavaScript.

How to use promises

Here we'll introduce promises and show how to use promise-based APIs. We'll also introduce the async and await keywords.

Implementing a promise-based API

This article will outline how to implement your own promise-based API.

Introducing workers

Workers enable you to run certain tasks in a separate thread to keep your main code responsive. In this article, we'll rewrite a long-running synchronous function to use a worker.

Sequencing animations Challenge

This challenge asks you to use promises to play a set of animations in a particular sequence.

See also
Asynchronous Programming from the fantastic Eloquent JavaScript online book by Marijn Haverbeke.

 Overview: Extension modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nClient-side web APIs Overview: Extension modules Next  
Application Programming Interfaces (APIs) are programming features for manipulating different aspects of the browser and operating system the site is running on, or manipulating data from other websites or services. This module covers common aspects of some of the most common classes of Web APIs that we haven't previously covered in any kind of detail, providing a useful grounding for those who want to go deeper into browser API usage.PrerequisitesBefore starting this module, You should really have learnt the fundamentals of JavaScript, especially JavaScript object basics and core API coverage such as DOM scripting and Network requests.
It would also be helpful to have some familiarity with HTML and CSS.

Note:
If you are working on a device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials
Introduction to web APIs

First up, we'll start by looking at APIs from a high level — what are they, how do they work, how do you use them in your code, and how are they structured? We'll also take a look at what the different main classes of APIs are, and what kind of uses they have.

Video and audio APIs

HTML comes with elements for embedding rich media in documents — <video> and <audio> — which in turn come with their own APIs for controlling playback, seeking, etc. This article shows you how to do common tasks such as creating custom playback controls.

Drawing graphics

The browser contains some very powerful graphics programming tools, from the Scalable Vector Graphics (SVG) language, to APIs for drawing on HTML <canvas> elements, (see The Canvas API and WebGL). This article provides an introduction to the Canvas API, and further resources to allow you to learn more.

Client-side storage

Modern web browsers feature a number of different technologies that allow you to store data related to websites and retrieve it when necessary allowing you to persist data long term, save sites offline, and more. This article explains the very basics of how these work.

Third party APIs

The APIs we've covered so far are built into the browser, but not all APIs are. Many large websites and services such as Google Maps, Facebook, PayPal, etc. provide APIs allowing developers to make use of their data or services (e.g., displaying custom Google Maps on your site, or using Facebook login to log in your users). This article looks at the difference between browser APIs and 3rd party APIs and shows some typical uses of the latter.


 Overview: Extension modules Next\n\nClient-side web APIs Overview: Extension modules Next  
Application Programming Interfaces (APIs) are programming features for manipulating different aspects of the browser and operating system the site is running on, or manipulating data from other websites or services. This module covers common aspects of some of the most common classes of Web APIs that we haven't previously covered in any kind of detail, providing a useful grounding for those who want to go deeper into browser API usage.PrerequisitesBefore starting this module, You should really have learnt the fundamentals of JavaScript, especially JavaScript object basics and core API coverage such as DOM scripting and Network requests.
It would also be helpful to have some familiarity with HTML and CSS.

Note:
If you are working on a device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials
Introduction to web APIs

First up, we'll start by looking at APIs from a high level — what are they, how do they work, how do you use them in your code, and how are they structured? We'll also take a look at what the different main classes of APIs are, and what kind of uses they have.

Video and audio APIs

HTML comes with elements for embedding rich media in documents — <video> and <audio> — which in turn come with their own APIs for controlling playback, seeking, etc. This article shows you how to do common tasks such as creating custom playback controls.

Drawing graphics

The browser contains some very powerful graphics programming tools, from the Scalable Vector Graphics (SVG) language, to APIs for drawing on HTML <canvas> elements, (see The Canvas API and WebGL). This article provides an introduction to the Canvas API, and further resources to allow you to learn more.

Client-side storage

Modern web browsers feature a number of different technologies that allow you to store data related to websites and retrieve it when necessary allowing you to persist data long term, save sites offline, and more. This article explains the very basics of how these work.

Third party APIs

The APIs we've covered so far are built into the browser, but not all APIs are. Many large websites and services such as Google Maps, Facebook, PayPal, etc. provide APIs allowing developers to make use of their data or services (e.g., displaying custom Google Maps on your site, or using Facebook login to log in your users). This article looks at the difference between browser APIs and 3rd party APIs and shows some typical uses of the latter.


 Overview: Extension modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nClient-side web APIs Overview: Extension modules Next  
Application Programming Interfaces (APIs) are programming features for manipulating different aspects of the browser and operating system the site is running on, or manipulating data from other websites or services. This module covers common aspects of some of the most common classes of Web APIs that we haven't previously covered in any kind of detail, providing a useful grounding for those who want to go deeper into browser API usage.PrerequisitesBefore starting this module, You should really have learnt the fundamentals of JavaScript, especially JavaScript object basics and core API coverage such as DOM scripting and Network requests.
It would also be helpful to have some familiarity with HTML and CSS.

Note:
If you are working on a device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials
Introduction to web APIs

First up, we'll start by looking at APIs from a high level — what are they, how do they work, how do you use them in your code, and how are they structured? We'll also take a look at what the different main classes of APIs are, and what kind of uses they have.

Video and audio APIs

HTML comes with elements for embedding rich media in documents — <video> and <audio> — which in turn come with their own APIs for controlling playback, seeking, etc. This article shows you how to do common tasks such as creating custom playback controls.

Drawing graphics

The browser contains some very powerful graphics programming tools, from the Scalable Vector Graphics (SVG) language, to APIs for drawing on HTML <canvas> elements, (see The Canvas API and WebGL). This article provides an introduction to the Canvas API, and further resources to allow you to learn more.

Client-side storage

Modern web browsers feature a number of different technologies that allow you to store data related to websites and retrieve it when necessary allowing you to persist data long term, save sites offline, and more. This article explains the very basics of how these work.

Third party APIs

The APIs we've covered so far are built into the browser, but not all APIs are. Many large websites and services such as Google Maps, Facebook, PayPal, etc. provide APIs allowing developers to make use of their data or services (e.g., displaying custom Google Maps on your site, or using Facebook login to log in your users). This article looks at the difference between browser APIs and 3rd party APIs and shows some typical uses of the latter.


 Overview: Extension modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 11, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJavaScript language overviewJavaScript is a multi-paradigm, dynamic language with types and operators, standard built-in objects, and methods. Its syntax is based on the Java and C languages — many structures from those languages apply to JavaScript as well. JavaScript supports object-oriented programming with object prototypes and classes. It also supports functional programming since functions are first-class objects that can be easily created via expressions and passed around like any other object.
This page serves as a quick overview of various JavaScript language features, written for readers with background in other languages, such as C or Java.Data typesLet's start off by looking at the building blocks of any language: the types. JavaScript programs manipulate values, and those values all belong to a type. JavaScript offers seven primitive types:

Number: used for all number values (integer and floating point) except for very big integers.
BigInt: used for arbitrarily large integers.
String: used to store text.
Boolean: true and false — usually used for conditional logic.
Symbol: used for creating unique identifiers that won't collide.
Undefined: indicating that a variable has not been assigned a value.
Null: indicating a deliberate non-value.

Everything else is known as an Object. Common object types include:

Function
Array
Map
RegExp
Error

Functions aren't special data structures in JavaScript — they are just a special type of object that can be called.NumbersJavaScript has two built-in numeric types: Number and BigInt.
The Number type is a IEEE 754 64-bit double-precision floating point value, which means integers can be safely represented between -(253 − 1) and 253 − 1 without loss of precision, and floating point numbers can be stored all the way up to 1.79 × 10308. Within numbers, JavaScript does not distinguish between floating point numbers and integers.
jsconsole.log(3 / 2); // 1.5, not 1

So an apparent integer is in fact implicitly a float. Because of IEEE 754 encoding, sometimes floating point arithmetic can be imprecise.
jsconsole.log(0.1 + 0.2); // 0.30000000000000004

For operations that expect integers, such as bitwise operations, the number will be converted to a 32-bit integer.
Number literals can also have prefixes to indicate the base (binary, octal, decimal, or hexadecimal), or an exponent suffix.
jsconsole.log(0b111110111); // 503
console.log(0o767); // 503
console.log(0x1f7); // 503
console.log(5.03e2); // 503

The BigInt type is an arbitrary length integer. Its behavior is similar to C's integer types (e.g., division truncates to zero), except it can grow indefinitely. BigInts are specified with a number literal and an n suffix.
jsconsole.log(-3n / 2n); // -1n

The standard arithmetic operators are supported, including addition, subtraction, remainder arithmetic, etc. BigInts and numbers cannot be mixed in arithmetic operations.
The Math object provides standard mathematical functions and constants.
jsMath.sin(3.5);
const circumference = 2 * Math.PI * r;

There are three ways to convert a string to a number:

parseInt(), which parses the string for an integer.
parseFloat(), which parses the string for a floating-point number.
The Number() function, which parses a string as if it's a number literal and supports many different number representations.

You can also use the unary plus + as a shorthand for Number().
Number values also include NaN (short for "Not a Number") and Infinity. Many "invalid math" operations will return NaN — for example, if attempting to parse a non-numeric string, or using Math.log() on a negative value. Division by zero produces Infinity (positive or negative).
NaN is contagious: if you provide it as an operand to any mathematical operation, the result will also be NaN. NaN is the only value in JavaScript that's not equal to itself (per IEEE 754 specification).StringsStrings in JavaScript are sequences of Unicode characters. This should be welcome news to anyone who has had to deal with internationalization. More accurately, they are UTF-16 encoded.
jsconsole.log("Hello, world");
console.log("你好，世界！"); // Nearly all Unicode characters can be written literally in string literals

Strings can be written with either single or double quotes — JavaScript does not have the distinction between characters and strings. If you want to represent a single character, you just use a string consisting of that single character.
jsconsole.log("Hello"[1] === "e"); // true

To find the length of a string (in code units), access its length property.
Strings have utility methods to manipulate the string and access information about the string. Because all primitives are immutable by design, these methods return new strings.
The + operator is overloaded for strings: when one of the operands is a string, it performs string concatenation instead of number addition. A special template literal syntax allows you to write strings with embedded expressions more succinctly. Unlike Python's f-strings or C#'s interpolated strings, template literals use backticks (not single or double quotes).
jsconst age = 25;
console.log("I am " + age + " years old."); // String concatenation
console.log(`I am ${age} years old.`); // Template literal
Other typesJavaScript distinguishes between null, which indicates a deliberate non-value (and is only accessible through the null keyword), and undefined, which indicates absence of value. There are many ways to obtain undefined:

A return statement with no value (return;) implicitly returns undefined.
Accessing a nonexistent object property (obj.iDontExist) returns undefined.
A variable declaration without initialization (let x;) will implicitly initialize the variable to undefined.

JavaScript has a Boolean type, with possible values true and false — both of which are keywords. Any value can be converted to a boolean according to the following rules:

false, 0, empty strings (""), NaN, null, and undefined all become false.
All other values become true.

You can perform this conversion explicitly using the Boolean() function:
jsBoolean(""); // false
Boolean(234); // true

However, this is rarely necessary, as JavaScript will silently perform this conversion when it expects a boolean, such as in an if statement (see Control structures). For this reason, we sometimes speak of "truthy" and "falsy", meaning values that become true and false, respectively, when used in boolean contexts.
Boolean operations such as && (logical and), || (logical or), and ! (logical not) are supported; see Operators.
The Symbol type is often used to create unique identifiers. Every symbol created with the Symbol() function is guaranteed to be unique. In addition, there are registered symbols, which are shared constants, and well-known symbols, which are utilized by the language as "protocols" for certain operations. You can read more about them in the symbol reference.VariablesVariables in JavaScript are declared using one of three keywords: let, const, or var.
let allows you to declare block-level variables. The declared variable is available from the block it is enclosed in.
jslet a;
let name = "Simon";

// myLetVariable is *not* visible out here

for (let myLetVariable = 0; myLetVariable < 5; myLetVariable++) {
  // myLetVariable is only visible in here
}

// myLetVariable is *not* visible out here

const allows you to declare variables whose values are never intended to change. The variable is available from the block it is declared in.
jsconst Pi = 3.14; // Declare variable Pi
console.log(Pi); // 3.14

A variable declared with const cannot be reassigned.
jsconst Pi = 3.14;
Pi = 1; // will throw an error because you cannot change a constant variable.

const declarations only prevent reassignments — they don't prevent mutations of the variable's value, if it's an object.
jsconst obj = {};
obj.a = 1; // no error
console.log(obj); // { a: 1 }

var declarations can have surprising behaviors (for example, they are not block-scoped), and they are discouraged in modern JavaScript code.
If you declare a variable without assigning any value to it, its value is undefined. You can't declare a const variable without an initializer, because you can't change it later anyway.
let and const declared variables still occupy the entire scope they are defined in, and are in a region known as the temporal dead zone before the actual line of declaration. This has some interesting interactions with variable shadowing, which don't occur in other languages.
jsfunction foo(x, condition) {
  if (condition) {
    console.log(x);
    const x = 2;
    console.log(x);
  }
}

foo(1, true);

In most other languages, this would log "1" and "2", because before the const x = 2 line, x should still refer to the parameter x in the upper scope. In JavaScript, because each declaration occupies the entire scope, this would throw an error on the first console.log: "Cannot access 'x' before initialization". For more information, see the reference page of let.
JavaScript is dynamically typed. Types (as described in the previous section) are only associated with values, but not with variables. For let-declared variables, you can always change its type through reassignment.
jslet a = 1;
a = "foo";
OperatorsJavaScript's numeric operators include +, -, *, /, % (remainder), and ** (exponentiation). Values are assigned using =. Each binary operator also has a compound assignment counterpart such as += and -=, which extend out to x = x operator y.
jsx += 5;
x = x + 5;

You can use ++ and -- to increment and decrement respectively. These can be used as a prefix or postfix operators.
The + operator also does string concatenation:
js"hello" + " world"; // "hello world"

If you add a string to a number (or other value) everything is converted into a string first. This might trip you up:
js"3" + 4 + 5; // "345"
3 + 4 + "5"; // "75"

Adding an empty string to something is a useful way of converting it to a string itself.
Comparisons in JavaScript can be made using <, >, <= and >=, which work for both strings and numbers. For equality, the double-equals operator performs type coercion if you give it different types, with sometimes interesting results. On the other hand, the triple-equals operator does not attempt type coercion, and is usually preferred.
js123 == "123"; // true
1 == true; // true

123 === "123"; // false
1 === true; // false

The double-equals and triple-equals also have their inequality counterparts: != and !==.
JavaScript also has bitwise operators and logical operators. Notably, logical operators don't work with boolean values only — they work by the "truthiness" of the value.
jsconst a = 0 && "Hello"; // 0 because 0 is "falsy"
const b = "Hello" || "world"; // "Hello" because both "Hello" and "world" are "truthy"

The && and || operators use short-circuit logic, which means whether they will execute their second operand is dependent on the first. This is useful for checking for null objects before accessing their attributes:
jsconst name = o && o.getName();

Or for caching values (when falsy values are invalid):
jsconst name = cachedName || (cachedName = getName());

For a comprehensive list of operators, see the guide page or reference section. You may be especially interested in the operator precedence.GrammarJavaScript grammar is very similar to the C family. There are a few points worth mentioning:

Identifiers can have Unicode characters, but they cannot be one of the reserved words.
Comments are commonly // or /* */, while many other scripting languages like Perl, Python, and Bash use #.
Semicolons are optional in JavaScript — the language automatically inserts them when needed. However, there are certain caveats to watch out for, since unlike Python, semicolons are still part of the syntax.

For an in-depth look at the JavaScript grammar, see the reference page for lexical grammar.Control structuresJavaScript has a similar set of control structures to other languages in the C family. Conditional statements are supported by if and else; you can chain them together:
jslet name = "kittens";
if (name === "puppies") {
  name += " woof";
} else if (name === "kittens") {
  name += " meow";
} else {
  name += "!";
}
name === "kittens meow";

JavaScript doesn't have elif, and else if is really just an else branch comprised of a single if statement.
JavaScript has while loops and do...while loops. The first is good for basic looping; the second is for loops where you wish to ensure that the body of the loop is executed at least once:
jswhile (true) {
  // an infinite loop!
}

let input;
do {
  input = get_input();
} while (inputIsNotValid(input));

JavaScript's for loop is the same as that in C and Java: it lets you provide the control information for your loop on a single line.
jsfor (let i = 0; i < 5; i++) {
  // Will execute 5 times
}

JavaScript also contains two other prominent for loops: for...of, which iterates over iterables, most notably arrays, and for...in, which visits all enumerable properties of an object.
jsfor (const value of array) {
  // do something with value
}

for (const property in object) {
  // do something with object property
}

The switch statement can be used for multiple branches based on equality checking.
jsswitch (action) {
  case "draw":
    drawIt();
    break;
  case "eat":
    eatIt();
    break;
  default:
    doNothing();
}

Similar to C, case clauses are conceptually the same as labels, so if you don't add a break statement, execution will "fall through" to the next level. However, they are not actually jump tables — any expression can be part of the case clause, not just string or number literals, and they would be evaluated one-by-one until one equals the value being matched. Comparison takes place between the two using the === operator.
Unlike some languages like Rust, control-flow structures are statements in JavaScript, meaning you can't assign them to a variable, like const a = if (x) { 1 } else { 2 }.
JavaScript errors are handled using the try...catch statement.
jstry {
  buildMySite("./website");
} catch (e) {
  console.error("Building site failed:", e);
}

Errors can be thrown using the throw statement. Many built-in operations may throw as well.
jsfunction buildMySite(siteDirectory) {
  if (!pathExists(siteDirectory)) {
    throw new Error("Site directory does not exist");
  }
}

In general, you can't tell the type of the error you just caught, because anything can be thrown from a throw statement. However, you can usually assume it's an Error instance, as is the example above. There are some subclasses of Error built-in, like TypeError and RangeError, that you can use to provide extra semantics about the error. There's no conditional catch in JavaScript — if you only want to handle one type of error, you need to catch everything, identify the type of error using instanceof, and then rethrow the other cases.
jstry {
  buildMySite("./website");
} catch (e) {
  if (e instanceof RangeError) {
    console.error("Seems like a parameter is out of range:", e);
    console.log("Retrying...");
    buildMySite("./website");
  } else {
    // Don't know how to handle other error types; throw them so
    // something else up in the call stack may catch and handle it
    throw e;
  }
}

If an error is uncaught by any try...catch in the call stack, the program will exit.
For a comprehensive list of control flow statements, see the reference section.ObjectsJavaScript objects can be thought of as collections of key-value pairs. As such, they are similar to:

Dictionaries in Python.
Hashes in Perl and Ruby.
Hash tables in C and C++.
HashMaps in Java.
Associative arrays in PHP.

JavaScript objects are hashes. Unlike objects in statically typed languages, objects in JavaScript do not have fixed shapes — properties can be added, deleted, re-ordered, mutated, or dynamically queried at any time. Object keys are always strings or symbols — even array indices, which are canonically integers, are actually strings under the hood.
Objects are usually created using the literal syntax:
jsconst obj = {
  name: "Carrot",
  for: "Max",
  details: {
    color: "orange",
    size: 12,
  },
};

Object properties can be accessed using dot (.) or square brackets ([]). When using the dot notation, the key must be a valid identifier. Square brackets, on the other hand, allow indexing the object with a dynamic key value.
js// Dot notation
obj.name = "Simon";
const name = obj.name;

// Bracket notation
obj["name"] = "Simon";
const name = obj["name"];

// Can use a variable to define a key
const userName = prompt("what is your key?");
obj[userName] = prompt("what is its value?");

Property access can be chained together:
jsobj.details.color; // orange
obj["details"]["size"]; // 12

Objects are always references, so unless something is explicitly copying the object, mutations to an object would be visible to the outside.
jsconst obj = {};
function doSomething(o) {
  o.x = 1;
}
doSomething(obj);
console.log(obj.x); // 1

This also means two separately created objects will never be equal (!==), because they are different references. If you hold two references of the same object, mutating one would be observable through the other.
jsconst me = {};
const stillMe = me;
me.x = 1;
console.log(stillMe.x); // 1

For more on objects and prototypes, see the Object reference page. For more information on the object initializer syntax, see its reference page.
This page has omitted all details about object prototypes and inheritance because you can usually achieve inheritance with classes without touching the underlying mechanism (which you may have heard to be abstruse). To learn about them, see Inheritance and the prototype chain.ArraysArrays in JavaScript are actually a special type of object. They work very much like regular objects (numerical properties can naturally be accessed only using [] syntax) but they have one magic property called length. This is always one more than the highest index in the array.
Arrays are usually created with array literals:
jsconst a = ["dog", "cat", "hen"];
a.length; // 3

JavaScript arrays are still objects — you can assign any properties to them, including arbitrary number indices. The only "magic" is that length will be automatically updated when you set a particular index.
jsconst a = ["dog", "cat", "hen"];
a[100] = "fox";
console.log(a.length); // 101
console.log(a); // ['dog', 'cat', 'hen', empty × 97, 'fox']

The array we got above is called a sparse array because there are uninhabited slots in the middle, and will cause the engine to deoptimize it from an array to a hash table. Make sure your array is densely populated!
Out-of-bounds indexing doesn't throw. If you query a non-existent array index, you'll get a value of undefined in return:
jsconst a = ["dog", "cat", "hen"];
console.log(typeof a[90]); // undefined

Arrays can have any elements and can grow or shrink arbitrarily.
jsconst arr = [1, "foo", true];
arr.push({});
// arr = [1, "foo", true, {}]

Arrays can be iterated with the for loop, as you can in other C-like languages:
jsfor (let i = 0; i < a.length; i++) {
  // Do something with a[i]
}

Or, since arrays are iterable, you can use the for...of loop, which is synonymous to C++/Java's for (int x : arr) syntax:
jsfor (const currentValue of a) {
  // Do something with currentValue
}

Arrays come with a plethora of array methods. Many of them would iterate the array — for example, map() would apply a callback to every array element, and return a new array:
jsconst babies = ["dog", "cat", "hen"].map((name) => `baby ${name}`);
// babies = ['baby dog', 'baby cat', 'baby hen']
FunctionsAlong with objects, functions are the core component in understanding JavaScript. The most basic function declaration looks like this:
jsfunction add(x, y) {
  const total = x + y;
  return total;
}

A JavaScript function can take 0 or more parameters. The function body can contain as many statements as you like and can declare its own variables which are local to that function. The return statement can be used to return a value at any time, terminating the function. If no return statement is used (or an empty return with no value), JavaScript returns undefined.
Functions can be called with more or fewer parameters than it specifies. If you call a function without passing the parameters it expects, they will be set to undefined. If you pass more parameters than it expects, the function will ignore the extra parameters.
jsadd(); // NaN
// Equivalent to add(undefined, undefined)

add(2, 3, 4); // 5
// added the first two; 4 was ignored

There are a number of other parameter syntaxes available. For example, the rest parameter syntax allows collecting all the extra parameters passed by the caller into an array, similar to Python's *args. (Since JS doesn't have named parameters on the language level, there's no **kwargs.)
jsfunction avg(...args) {
  let sum = 0;
  for (const item of args) {
    sum += item;
  }
  return sum / args.length;
}

avg(2, 3, 4, 5); // 3.5

In the above code, the variable args holds all the values that were passed into the function.
The rest parameter will store all arguments after where it's declared, but not before. In other words, function avg(firstValue, ...args) will store the first value passed into the function in the firstValue variable and the remaining arguments in args.
If a function accepts a list of arguments and you already hold them in an array, you can use the spread syntax in the function call to spread the array as a list of elements. For instance: avg(...numbers).
We mentioned that JavaScript doesn't have named parameters. It's possible, though, to implement them using object destructuring, which allows objects to be conveniently packed and unpacked.
js// Note the { } braces: this is destructuring an object
function area({ width, height }) {
  return width * height;
}

// The { } braces here create a new object
console.log(area({ width: 2, height: 3 }));

There's also the default parameter syntax, which allows omitted parameters (or those passed as undefined) to have a default value.
jsfunction avg(firstValue, secondValue, thirdValue = 0) {
  return (firstValue + secondValue + thirdValue) / 3;
}

avg(1, 2); // 1, instead of NaN
Anonymous functionsJavaScript lets you create anonymous functions — that is, functions without names. In practice, anonymous functions are typically used as arguments to other functions, immediately assigned to a variable that can be used to invoke the function, or returned from another function.
js// Note that there's no function name before the parentheses
const avg = function (...args) {
  let sum = 0;
  for (const item of args) {
    sum += item;
  }
  return sum / args.length;
};

That makes the anonymous function invocable by calling avg() with some arguments — that is, it's semantically equivalent to declaring the function using the function avg() {} declaration syntax.
There's another way to define anonymous functions — using an arrow function expression.
js// Note that there's no function name before the parentheses
const avg = (...args) => {
  let sum = 0;
  for (const item of args) {
    sum += item;
  }
  return sum / args.length;
};

// You can omit the `return` when simply returning an expression
const sum = (a, b, c) => a + b + c;

Arrow functions are not semantically equivalent to function expressions — for more information, see its reference page.
There's another way that anonymous functions can be useful: it can be simultaneously declared and invoked in a single expression, called an Immediately invoked function expression (IIFE):
js(function () {
  // …
})();

For use-cases of IIFEs, you can read emulating private methods with closures.Recursive functionsJavaScript allows you to call functions recursively. This is particularly useful for dealing with tree structures, such as those found in the browser DOM.
jsfunction countChars(elm) {
  if (elm.nodeType === 3) {
    // TEXT_NODE
    return elm.nodeValue.length;
  }
  let count = 0;
  for (let i = 0, child; (child = elm.childNodes[i]); i++) {
    count += countChars(child);
  }
  return count;
}

Function expressions can be named as well, which allows them to be recursive.
jsconst charsInBody = (function counter(elm) {
  if (elm.nodeType === 3) {
    // TEXT_NODE
    return elm.nodeValue.length;
  }
  let count = 0;
  for (let i = 0, child; (child = elm.childNodes[i]); i++) {
    count += counter(child);
  }
  return count;
})(document.body);

The name provided to a function expression as above is only available to the function's own scope. This allows more optimizations to be done by the engine and results in more readable code. The name also shows up in the debugger and some stack traces, which can save you time when debugging.
If you are used to functional programming, beware of the performance implications of recursion in JavaScript. Although the language specification specifies tail-call optimization, only JavaScriptCore (used by Safari) has implemented it, due to the difficulty of recovering stack traces and debuggability. For deep recursion, consider using iteration instead to avoid stack overflow.Functions are first-class objectsJavaScript functions are first-class objects. This means that they can be assigned to variables, passed as arguments to other functions, and returned from other functions. In addition, JavaScript supports closures out-of-the-box without explicit capturing, allowing you to conveniently apply functional programming styles.
js// Function returning function
const add = (x) => (y) => x + y;
// Function accepting function
const babies = ["dog", "cat", "hen"].map((name) => `baby ${name}`);

Note that JavaScript functions are themselves objects — like everything else in JavaScript — and you can add or change properties on them just like we've seen earlier in the Objects section.Inner functionsJavaScript function declarations are allowed inside other functions. An important detail of nested functions in JavaScript is that they can access variables in their parent function's scope:
jsfunction parentFunc() {
  const a = 1;

  function nestedFunc() {
    const b = 4; // parentFunc can't use this
    return a + b;
  }
  return nestedFunc(); // 5
}

This provides a great deal of utility in writing more maintainable code. If a called function relies on one or two other functions that are not useful to any other part of your code, you can nest those utility functions inside it. This keeps the number of functions that are in the global scope down.
This is also a great counter to the lure of global variables. When writing complex code, it is often tempting to use global variables to share values between multiple functions, which leads to code that is hard to maintain. Nested functions can share variables in their parent, so you can use that mechanism to couple functions together without polluting your global namespace.ClassesJavaScript offers the class syntax that's very similar to languages like Java.
jsclass Person {
  constructor(name) {
    this.name = name;
  }
  sayHello() {
    return `Hello, I'm ${this.name}!`;
  }
}

const p = new Person("Maria");
console.log(p.sayHello());

JavaScript classes are just functions that must be instantiated with the new operator. Every time a class is instantiated, it returns an object containing the methods and properties that the class specified. Classes don't enforce any code organization — for example, you can have functions returning classes, or you can have multiple classes per file. Here's an example of how ad hoc the creation of a class can be: it's just an expression returned from an arrow function. This pattern is called a mixin.
jsconst withAuthentication = (cls) =>
  class extends cls {
    authenticate() {
      // …
    }
  };

class Admin extends withAuthentication(Person) {
  // …
}

Static properties are created by prepending static. Private properties are created by prepending a hash # (not private). The hash is an integral part of the property name. (Think about # as _ in Python.) Unlike most other languages, there's absolutely no way to read a private property outside the class body — not even in derived classes.
For a detailed guide on various class features, you can read the guide page.Asynchronous programmingJavaScript is single-threaded by nature. There's no paralleling; only concurrency. Asynchronous programming is powered by an event loop, which allows a set of tasks to be queued and polled for completion.
There are three idiomatic ways to write asynchronous code in JavaScript:

Callback-based (such as setTimeout())
Promise-based
async/await, which is a syntactic sugar for Promises

For example, here's what a file-read operation might look like in JavaScript:
js// Callback-based
fs.readFile(filename, (err, content) => {
  // This callback is invoked when the file is read, which could be after a while
  if (err) {
    throw err;
  }
  console.log(content);
});
// Code here will be executed while the file is waiting to be read

// Promise-based
fs.readFile(filename)
  .then((content) => {
    // What to do when the file is read
    console.log(content);
  })
  .catch((err) => {
    throw err;
  });
// Code here will be executed while the file is waiting to be read

// Async/await
async function readFile(filename) {
  const content = await fs.readFile(filename);
  console.log(content);
}

The core language doesn't specify any asynchronous programming features, but it's crucial when interacting with the external environment — from asking user permissions, to fetching data, to reading files. Keeping the potentially long-running operations async ensures that other processes can still run while this one waits — for example, the browser will not freeze while waiting for the user to click a button to grant permission.
If you have an async value, it's not possible to get its value synchronously. For example, if you have a promise, you can only access the eventual result via the then() method. Similarly, await can only be used in an async context, which is usually an async function or a module. Promises are never blocking — only the logic depending on the promise's result will be deferred; everything else continues to execute in the meantime. If you are a functional programmer, you may recognize promises as monads which can be mapped with then() (however, they are not proper monads because they auto-flatten; i.e., you can't have a Promise<Promise<T>>).
In fact, the single-threaded model has made Node.js a popular choice for server-side programming due to its non-blocking IO, making handling a large number of database or file-system requests very performant. However, CPU-bound (computationally intensive) tasks that are pure JavaScript will still block the main thread. To achieve real paralleling, you may need to use workers.
To learn more about asynchronous programming, you can read about using promises or follow the asynchronous JavaScript tutorial.ModulesJavaScript also specifies a module system supported by most runtimes. A module is usually a file, identified by its file path or URL. You can use the import and export statements to exchange data between modules:
jsimport { foo } from "./foo.js";

// Unexported variables are local to the module
const b = 2;

export const a = 1;

Unlike Haskell, Python, Java, etc., JavaScript module resolution is entirely host-defined — it's usually based on URLs or file paths, so relative file paths "just work" and are relative to the current module's path instead of some project root path.
However, the JavaScript language doesn't offer standard library modules — all core functionalities are powered by global variables like Math and Intl instead. This is due to the long history of JavaScript lacking a module system, and the fact that opting into the module system involves some changes to the runtime setup.
Different runtimes may use different module systems. For example, Node.js uses the package manager npm and is mostly file-system based, while Deno and browsers are fully URL-based and modules can be resolved from HTTP URLs.
For more information, see the modules guide page.Language and runtimeThroughout this page, we've constantly mentioned that certain features are language-level while others are runtime-level.
JavaScript is a general-purpose scripting language. The core language specification focuses on pure computational logic. It doesn't deal with any input/output — in fact, without extra runtime-level APIs (most notably console.log()), a JavaScript program's behavior is entirely unobservable.
A runtime, or a host, is something that feeds data to the JavaScript engine (the interpreter), provides extra global properties, and provides hooks for the engine to interact with the outside world. Module resolution, reading data, printing messages, sending network requests, etc. are all runtime-level operations. Since its inception, JavaScript has been adopted in various environments, such as browsers (which provide APIs like DOM), Node.js (which provides APIs like file system access), etc. JavaScript has been successfully integrated in web (which was its primary purpose), mobile apps, desktop apps, server-side apps, serverless, embedded systems, and more. While you learn about JavaScript core features, it's also important to understand host-provided features in order to put the knowledge to use. For example, you can read about all web platform APIs, which are implemented by browsers, and sometimes non-browsers.Further explorationThis page offers a very basic insight into how various JavaScript features compare with other languages. If you want to learn more about the language itself and the nuances of each feature, you can read the JavaScript guide and the JavaScript reference.
There are some essential parts of the language that we have omitted due to space and complexity, but you can explore on your own:

Inheritance and the prototype chain
Closures
Regular expressions
Iteration\n\nJavaScript language overviewJavaScript is a multi-paradigm, dynamic language with types and operators, standard built-in objects, and methods. Its syntax is based on the Java and C languages — many structures from those languages apply to JavaScript as well. JavaScript supports object-oriented programming with object prototypes and classes. It also supports functional programming since functions are first-class objects that can be easily created via expressions and passed around like any other object.
This page serves as a quick overview of various JavaScript language features, written for readers with background in other languages, such as C or Java.Data typesLet's start off by looking at the building blocks of any language: the types. JavaScript programs manipulate values, and those values all belong to a type. JavaScript offers seven primitive types:

Number: used for all number values (integer and floating point) except for very big integers.
BigInt: used for arbitrarily large integers.
String: used to store text.
Boolean: true and false — usually used for conditional logic.
Symbol: used for creating unique identifiers that won't collide.
Undefined: indicating that a variable has not been assigned a value.
Null: indicating a deliberate non-value.

Everything else is known as an Object. Common object types include:

Function
Array
Map
RegExp
Error

Functions aren't special data structures in JavaScript — they are just a special type of object that can be called.NumbersJavaScript has two built-in numeric types: Number and BigInt.
The Number type is a IEEE 754 64-bit double-precision floating point value, which means integers can be safely represented between -(253 − 1) and 253 − 1 without loss of precision, and floating point numbers can be stored all the way up to 1.79 × 10308. Within numbers, JavaScript does not distinguish between floating point numbers and integers.
jsconsole.log(3 / 2); // 1.5, not 1

So an apparent integer is in fact implicitly a float. Because of IEEE 754 encoding, sometimes floating point arithmetic can be imprecise.
jsconsole.log(0.1 + 0.2); // 0.30000000000000004

For operations that expect integers, such as bitwise operations, the number will be converted to a 32-bit integer.
Number literals can also have prefixes to indicate the base (binary, octal, decimal, or hexadecimal), or an exponent suffix.
jsconsole.log(0b111110111); // 503
console.log(0o767); // 503
console.log(0x1f7); // 503
console.log(5.03e2); // 503

The BigInt type is an arbitrary length integer. Its behavior is similar to C's integer types (e.g., division truncates to zero), except it can grow indefinitely. BigInts are specified with a number literal and an n suffix.
jsconsole.log(-3n / 2n); // -1n

The standard arithmetic operators are supported, including addition, subtraction, remainder arithmetic, etc. BigInts and numbers cannot be mixed in arithmetic operations.
The Math object provides standard mathematical functions and constants.
jsMath.sin(3.5);
const circumference = 2 * Math.PI * r;

There are three ways to convert a string to a number:

parseInt(), which parses the string for an integer.
parseFloat(), which parses the string for a floating-point number.
The Number() function, which parses a string as if it's a number literal and supports many different number representations.

You can also use the unary plus + as a shorthand for Number().
Number values also include NaN (short for "Not a Number") and Infinity. Many "invalid math" operations will return NaN — for example, if attempting to parse a non-numeric string, or using Math.log() on a negative value. Division by zero produces Infinity (positive or negative).
NaN is contagious: if you provide it as an operand to any mathematical operation, the result will also be NaN. NaN is the only value in JavaScript that's not equal to itself (per IEEE 754 specification).StringsStrings in JavaScript are sequences of Unicode characters. This should be welcome news to anyone who has had to deal with internationalization. More accurately, they are UTF-16 encoded.
jsconsole.log("Hello, world");
console.log("你好，世界！"); // Nearly all Unicode characters can be written literally in string literals

Strings can be written with either single or double quotes — JavaScript does not have the distinction between characters and strings. If you want to represent a single character, you just use a string consisting of that single character.
jsconsole.log("Hello"[1] === "e"); // true

To find the length of a string (in code units), access its length property.
Strings have utility methods to manipulate the string and access information about the string. Because all primitives are immutable by design, these methods return new strings.
The + operator is overloaded for strings: when one of the operands is a string, it performs string concatenation instead of number addition. A special template literal syntax allows you to write strings with embedded expressions more succinctly. Unlike Python's f-strings or C#'s interpolated strings, template literals use backticks (not single or double quotes).
jsconst age = 25;
console.log("I am " + age + " years old."); // String concatenation
console.log(`I am ${age} years old.`); // Template literal
Other typesJavaScript distinguishes between null, which indicates a deliberate non-value (and is only accessible through the null keyword), and undefined, which indicates absence of value. There are many ways to obtain undefined:

A return statement with no value (return;) implicitly returns undefined.
Accessing a nonexistent object property (obj.iDontExist) returns undefined.
A variable declaration without initialization (let x;) will implicitly initialize the variable to undefined.

JavaScript has a Boolean type, with possible values true and false — both of which are keywords. Any value can be converted to a boolean according to the following rules:

false, 0, empty strings (""), NaN, null, and undefined all become false.
All other values become true.

You can perform this conversion explicitly using the Boolean() function:
jsBoolean(""); // false
Boolean(234); // true

However, this is rarely necessary, as JavaScript will silently perform this conversion when it expects a boolean, such as in an if statement (see Control structures). For this reason, we sometimes speak of "truthy" and "falsy", meaning values that become true and false, respectively, when used in boolean contexts.
Boolean operations such as && (logical and), || (logical or), and ! (logical not) are supported; see Operators.
The Symbol type is often used to create unique identifiers. Every symbol created with the Symbol() function is guaranteed to be unique. In addition, there are registered symbols, which are shared constants, and well-known symbols, which are utilized by the language as "protocols" for certain operations. You can read more about them in the symbol reference.VariablesVariables in JavaScript are declared using one of three keywords: let, const, or var.
let allows you to declare block-level variables. The declared variable is available from the block it is enclosed in.
jslet a;
let name = "Simon";

// myLetVariable is *not* visible out here

for (let myLetVariable = 0; myLetVariable < 5; myLetVariable++) {
  // myLetVariable is only visible in here
}

// myLetVariable is *not* visible out here

const allows you to declare variables whose values are never intended to change. The variable is available from the block it is declared in.
jsconst Pi = 3.14; // Declare variable Pi
console.log(Pi); // 3.14

A variable declared with const cannot be reassigned.
jsconst Pi = 3.14;
Pi = 1; // will throw an error because you cannot change a constant variable.

const declarations only prevent reassignments — they don't prevent mutations of the variable's value, if it's an object.
jsconst obj = {};
obj.a = 1; // no error
console.log(obj); // { a: 1 }

var declarations can have surprising behaviors (for example, they are not block-scoped), and they are discouraged in modern JavaScript code.
If you declare a variable without assigning any value to it, its value is undefined. You can't declare a const variable without an initializer, because you can't change it later anyway.
let and const declared variables still occupy the entire scope they are defined in, and are in a region known as the temporal dead zone before the actual line of declaration. This has some interesting interactions with variable shadowing, which don't occur in other languages.
jsfunction foo(x, condition) {
  if (condition) {
    console.log(x);
    const x = 2;
    console.log(x);
  }
}

foo(1, true);

In most other languages, this would log "1" and "2", because before the const x = 2 line, x should still refer to the parameter x in the upper scope. In JavaScript, because each declaration occupies the entire scope, this would throw an error on the first console.log: "Cannot access 'x' before initialization". For more information, see the reference page of let.
JavaScript is dynamically typed. Types (as described in the previous section) are only associated with values, but not with variables. For let-declared variables, you can always change its type through reassignment.
jslet a = 1;
a = "foo";
OperatorsJavaScript's numeric operators include +, -, *, /, % (remainder), and ** (exponentiation). Values are assigned using =. Each binary operator also has a compound assignment counterpart such as += and -=, which extend out to x = x operator y.
jsx += 5;
x = x + 5;

You can use ++ and -- to increment and decrement respectively. These can be used as a prefix or postfix operators.
The + operator also does string concatenation:
js"hello" + " world"; // "hello world"

If you add a string to a number (or other value) everything is converted into a string first. This might trip you up:
js"3" + 4 + 5; // "345"
3 + 4 + "5"; // "75"

Adding an empty string to something is a useful way of converting it to a string itself.
Comparisons in JavaScript can be made using <, >, <= and >=, which work for both strings and numbers. For equality, the double-equals operator performs type coercion if you give it different types, with sometimes interesting results. On the other hand, the triple-equals operator does not attempt type coercion, and is usually preferred.
js123 == "123"; // true
1 == true; // true

123 === "123"; // false
1 === true; // false

The double-equals and triple-equals also have their inequality counterparts: != and !==.
JavaScript also has bitwise operators and logical operators. Notably, logical operators don't work with boolean values only — they work by the "truthiness" of the value.
jsconst a = 0 && "Hello"; // 0 because 0 is "falsy"
const b = "Hello" || "world"; // "Hello" because both "Hello" and "world" are "truthy"

The && and || operators use short-circuit logic, which means whether they will execute their second operand is dependent on the first. This is useful for checking for null objects before accessing their attributes:
jsconst name = o && o.getName();

Or for caching values (when falsy values are invalid):
jsconst name = cachedName || (cachedName = getName());

For a comprehensive list of operators, see the guide page or reference section. You may be especially interested in the operator precedence.GrammarJavaScript grammar is very similar to the C family. There are a few points worth mentioning:

Identifiers can have Unicode characters, but they cannot be one of the reserved words.
Comments are commonly // or /* */, while many other scripting languages like Perl, Python, and Bash use #.
Semicolons are optional in JavaScript — the language automatically inserts them when needed. However, there are certain caveats to watch out for, since unlike Python, semicolons are still part of the syntax.

For an in-depth look at the JavaScript grammar, see the reference page for lexical grammar.Control structuresJavaScript has a similar set of control structures to other languages in the C family. Conditional statements are supported by if and else; you can chain them together:
jslet name = "kittens";
if (name === "puppies") {
  name += " woof";
} else if (name === "kittens") {
  name += " meow";
} else {
  name += "!";
}
name === "kittens meow";

JavaScript doesn't have elif, and else if is really just an else branch comprised of a single if statement.
JavaScript has while loops and do...while loops. The first is good for basic looping; the second is for loops where you wish to ensure that the body of the loop is executed at least once:
jswhile (true) {
  // an infinite loop!
}

let input;
do {
  input = get_input();
} while (inputIsNotValid(input));

JavaScript's for loop is the same as that in C and Java: it lets you provide the control information for your loop on a single line.
jsfor (let i = 0; i < 5; i++) {
  // Will execute 5 times
}

JavaScript also contains two other prominent for loops: for...of, which iterates over iterables, most notably arrays, and for...in, which visits all enumerable properties of an object.
jsfor (const value of array) {
  // do something with value
}

for (const property in object) {
  // do something with object property
}

The switch statement can be used for multiple branches based on equality checking.
jsswitch (action) {
  case "draw":
    drawIt();
    break;
  case "eat":
    eatIt();
    break;
  default:
    doNothing();
}

Similar to C, case clauses are conceptually the same as labels, so if you don't add a break statement, execution will "fall through" to the next level. However, they are not actually jump tables — any expression can be part of the case clause, not just string or number literals, and they would be evaluated one-by-one until one equals the value being matched. Comparison takes place between the two using the === operator.
Unlike some languages like Rust, control-flow structures are statements in JavaScript, meaning you can't assign them to a variable, like const a = if (x) { 1 } else { 2 }.
JavaScript errors are handled using the try...catch statement.
jstry {
  buildMySite("./website");
} catch (e) {
  console.error("Building site failed:", e);
}

Errors can be thrown using the throw statement. Many built-in operations may throw as well.
jsfunction buildMySite(siteDirectory) {
  if (!pathExists(siteDirectory)) {
    throw new Error("Site directory does not exist");
  }
}

In general, you can't tell the type of the error you just caught, because anything can be thrown from a throw statement. However, you can usually assume it's an Error instance, as is the example above. There are some subclasses of Error built-in, like TypeError and RangeError, that you can use to provide extra semantics about the error. There's no conditional catch in JavaScript — if you only want to handle one type of error, you need to catch everything, identify the type of error using instanceof, and then rethrow the other cases.
jstry {
  buildMySite("./website");
} catch (e) {
  if (e instanceof RangeError) {
    console.error("Seems like a parameter is out of range:", e);
    console.log("Retrying...");
    buildMySite("./website");
  } else {
    // Don't know how to handle other error types; throw them so
    // something else up in the call stack may catch and handle it
    throw e;
  }
}

If an error is uncaught by any try...catch in the call stack, the program will exit.
For a comprehensive list of control flow statements, see the reference section.ObjectsJavaScript objects can be thought of as collections of key-value pairs. As such, they are similar to:

Dictionaries in Python.
Hashes in Perl and Ruby.
Hash tables in C and C++.
HashMaps in Java.
Associative arrays in PHP.

JavaScript objects are hashes. Unlike objects in statically typed languages, objects in JavaScript do not have fixed shapes — properties can be added, deleted, re-ordered, mutated, or dynamically queried at any time. Object keys are always strings or symbols — even array indices, which are canonically integers, are actually strings under the hood.
Objects are usually created using the literal syntax:
jsconst obj = {
  name: "Carrot",
  for: "Max",
  details: {
    color: "orange",
    size: 12,
  },
};

Object properties can be accessed using dot (.) or square brackets ([]). When using the dot notation, the key must be a valid identifier. Square brackets, on the other hand, allow indexing the object with a dynamic key value.
js// Dot notation
obj.name = "Simon";
const name = obj.name;

// Bracket notation
obj["name"] = "Simon";
const name = obj["name"];

// Can use a variable to define a key
const userName = prompt("what is your key?");
obj[userName] = prompt("what is its value?");

Property access can be chained together:
jsobj.details.color; // orange
obj["details"]["size"]; // 12

Objects are always references, so unless something is explicitly copying the object, mutations to an object would be visible to the outside.
jsconst obj = {};
function doSomething(o) {
  o.x = 1;
}
doSomething(obj);
console.log(obj.x); // 1

This also means two separately created objects will never be equal (!==), because they are different references. If you hold two references of the same object, mutating one would be observable through the other.
jsconst me = {};
const stillMe = me;
me.x = 1;
console.log(stillMe.x); // 1

For more on objects and prototypes, see the Object reference page. For more information on the object initializer syntax, see its reference page.
This page has omitted all details about object prototypes and inheritance because you can usually achieve inheritance with classes without touching the underlying mechanism (which you may have heard to be abstruse). To learn about them, see Inheritance and the prototype chain.ArraysArrays in JavaScript are actually a special type of object. They work very much like regular objects (numerical properties can naturally be accessed only using [] syntax) but they have one magic property called length. This is always one more than the highest index in the array.
Arrays are usually created with array literals:
jsconst a = ["dog", "cat", "hen"];
a.length; // 3

JavaScript arrays are still objects — you can assign any properties to them, including arbitrary number indices. The only "magic" is that length will be automatically updated when you set a particular index.
jsconst a = ["dog", "cat", "hen"];
a[100] = "fox";
console.log(a.length); // 101
console.log(a); // ['dog', 'cat', 'hen', empty × 97, 'fox']

The array we got above is called a sparse array because there are uninhabited slots in the middle, and will cause the engine to deoptimize it from an array to a hash table. Make sure your array is densely populated!
Out-of-bounds indexing doesn't throw. If you query a non-existent array index, you'll get a value of undefined in return:
jsconst a = ["dog", "cat", "hen"];
console.log(typeof a[90]); // undefined

Arrays can have any elements and can grow or shrink arbitrarily.
jsconst arr = [1, "foo", true];
arr.push({});
// arr = [1, "foo", true, {}]

Arrays can be iterated with the for loop, as you can in other C-like languages:
jsfor (let i = 0; i < a.length; i++) {
  // Do something with a[i]
}

Or, since arrays are iterable, you can use the for...of loop, which is synonymous to C++/Java's for (int x : arr) syntax:
jsfor (const currentValue of a) {
  // Do something with currentValue
}

Arrays come with a plethora of array methods. Many of them would iterate the array — for example, map() would apply a callback to every array element, and return a new array:
jsconst babies = ["dog", "cat", "hen"].map((name) => `baby ${name}`);
// babies = ['baby dog', 'baby cat', 'baby hen']
FunctionsAlong with objects, functions are the core component in understanding JavaScript. The most basic function declaration looks like this:
jsfunction add(x, y) {
  const total = x + y;
  return total;
}

A JavaScript function can take 0 or more parameters. The function body can contain as many statements as you like and can declare its own variables which are local to that function. The return statement can be used to return a value at any time, terminating the function. If no return statement is used (or an empty return with no value), JavaScript returns undefined.
Functions can be called with more or fewer parameters than it specifies. If you call a function without passing the parameters it expects, they will be set to undefined. If you pass more parameters than it expects, the function will ignore the extra parameters.
jsadd(); // NaN
// Equivalent to add(undefined, undefined)

add(2, 3, 4); // 5
// added the first two; 4 was ignored

There are a number of other parameter syntaxes available. For example, the rest parameter syntax allows collecting all the extra parameters passed by the caller into an array, similar to Python's *args. (Since JS doesn't have named parameters on the language level, there's no **kwargs.)
jsfunction avg(...args) {
  let sum = 0;
  for (const item of args) {
    sum += item;
  }
  return sum / args.length;
}

avg(2, 3, 4, 5); // 3.5

In the above code, the variable args holds all the values that were passed into the function.
The rest parameter will store all arguments after where it's declared, but not before. In other words, function avg(firstValue, ...args) will store the first value passed into the function in the firstValue variable and the remaining arguments in args.
If a function accepts a list of arguments and you already hold them in an array, you can use the spread syntax in the function call to spread the array as a list of elements. For instance: avg(...numbers).
We mentioned that JavaScript doesn't have named parameters. It's possible, though, to implement them using object destructuring, which allows objects to be conveniently packed and unpacked.
js// Note the { } braces: this is destructuring an object
function area({ width, height }) {
  return width * height;
}

// The { } braces here create a new object
console.log(area({ width: 2, height: 3 }));

There's also the default parameter syntax, which allows omitted parameters (or those passed as undefined) to have a default value.
jsfunction avg(firstValue, secondValue, thirdValue = 0) {
  return (firstValue + secondValue + thirdValue) / 3;
}

avg(1, 2); // 1, instead of NaN
Anonymous functionsJavaScript lets you create anonymous functions — that is, functions without names. In practice, anonymous functions are typically used as arguments to other functions, immediately assigned to a variable that can be used to invoke the function, or returned from another function.
js// Note that there's no function name before the parentheses
const avg = function (...args) {
  let sum = 0;
  for (const item of args) {
    sum += item;
  }
  return sum / args.length;
};

That makes the anonymous function invocable by calling avg() with some arguments — that is, it's semantically equivalent to declaring the function using the function avg() {} declaration syntax.
There's another way to define anonymous functions — using an arrow function expression.
js// Note that there's no function name before the parentheses
const avg = (...args) => {
  let sum = 0;
  for (const item of args) {
    sum += item;
  }
  return sum / args.length;
};

// You can omit the `return` when simply returning an expression
const sum = (a, b, c) => a + b + c;

Arrow functions are not semantically equivalent to function expressions — for more information, see its reference page.
There's another way that anonymous functions can be useful: it can be simultaneously declared and invoked in a single expression, called an Immediately invoked function expression (IIFE):
js(function () {
  // …
})();

For use-cases of IIFEs, you can read emulating private methods with closures.Recursive functionsJavaScript allows you to call functions recursively. This is particularly useful for dealing with tree structures, such as those found in the browser DOM.
jsfunction countChars(elm) {
  if (elm.nodeType === 3) {
    // TEXT_NODE
    return elm.nodeValue.length;
  }
  let count = 0;
  for (let i = 0, child; (child = elm.childNodes[i]); i++) {
    count += countChars(child);
  }
  return count;
}

Function expressions can be named as well, which allows them to be recursive.
jsconst charsInBody = (function counter(elm) {
  if (elm.nodeType === 3) {
    // TEXT_NODE
    return elm.nodeValue.length;
  }
  let count = 0;
  for (let i = 0, child; (child = elm.childNodes[i]); i++) {
    count += counter(child);
  }
  return count;
})(document.body);

The name provided to a function expression as above is only available to the function's own scope. This allows more optimizations to be done by the engine and results in more readable code. The name also shows up in the debugger and some stack traces, which can save you time when debugging.
If you are used to functional programming, beware of the performance implications of recursion in JavaScript. Although the language specification specifies tail-call optimization, only JavaScriptCore (used by Safari) has implemented it, due to the difficulty of recovering stack traces and debuggability. For deep recursion, consider using iteration instead to avoid stack overflow.Functions are first-class objectsJavaScript functions are first-class objects. This means that they can be assigned to variables, passed as arguments to other functions, and returned from other functions. In addition, JavaScript supports closures out-of-the-box without explicit capturing, allowing you to conveniently apply functional programming styles.
js// Function returning function
const add = (x) => (y) => x + y;
// Function accepting function
const babies = ["dog", "cat", "hen"].map((name) => `baby ${name}`);

Note that JavaScript functions are themselves objects — like everything else in JavaScript — and you can add or change properties on them just like we've seen earlier in the Objects section.Inner functionsJavaScript function declarations are allowed inside other functions. An important detail of nested functions in JavaScript is that they can access variables in their parent function's scope:
jsfunction parentFunc() {
  const a = 1;

  function nestedFunc() {
    const b = 4; // parentFunc can't use this
    return a + b;
  }
  return nestedFunc(); // 5
}

This provides a great deal of utility in writing more maintainable code. If a called function relies on one or two other functions that are not useful to any other part of your code, you can nest those utility functions inside it. This keeps the number of functions that are in the global scope down.
This is also a great counter to the lure of global variables. When writing complex code, it is often tempting to use global variables to share values between multiple functions, which leads to code that is hard to maintain. Nested functions can share variables in their parent, so you can use that mechanism to couple functions together without polluting your global namespace.ClassesJavaScript offers the class syntax that's very similar to languages like Java.
jsclass Person {
  constructor(name) {
    this.name = name;
  }
  sayHello() {
    return `Hello, I'm ${this.name}!`;
  }
}

const p = new Person("Maria");
console.log(p.sayHello());

JavaScript classes are just functions that must be instantiated with the new operator. Every time a class is instantiated, it returns an object containing the methods and properties that the class specified. Classes don't enforce any code organization — for example, you can have functions returning classes, or you can have multiple classes per file. Here's an example of how ad hoc the creation of a class can be: it's just an expression returned from an arrow function. This pattern is called a mixin.
jsconst withAuthentication = (cls) =>
  class extends cls {
    authenticate() {
      // …
    }
  };

class Admin extends withAuthentication(Person) {
  // …
}

Static properties are created by prepending static. Private properties are created by prepending a hash # (not private). The hash is an integral part of the property name. (Think about # as _ in Python.) Unlike most other languages, there's absolutely no way to read a private property outside the class body — not even in derived classes.
For a detailed guide on various class features, you can read the guide page.Asynchronous programmingJavaScript is single-threaded by nature. There's no paralleling; only concurrency. Asynchronous programming is powered by an event loop, which allows a set of tasks to be queued and polled for completion.
There are three idiomatic ways to write asynchronous code in JavaScript:

Callback-based (such as setTimeout())
Promise-based
async/await, which is a syntactic sugar for Promises

For example, here's what a file-read operation might look like in JavaScript:
js// Callback-based
fs.readFile(filename, (err, content) => {
  // This callback is invoked when the file is read, which could be after a while
  if (err) {
    throw err;
  }
  console.log(content);
});
// Code here will be executed while the file is waiting to be read

// Promise-based
fs.readFile(filename)
  .then((content) => {
    // What to do when the file is read
    console.log(content);
  })
  .catch((err) => {
    throw err;
  });
// Code here will be executed while the file is waiting to be read

// Async/await
async function readFile(filename) {
  const content = await fs.readFile(filename);
  console.log(content);
}

The core language doesn't specify any asynchronous programming features, but it's crucial when interacting with the external environment — from asking user permissions, to fetching data, to reading files. Keeping the potentially long-running operations async ensures that other processes can still run while this one waits — for example, the browser will not freeze while waiting for the user to click a button to grant permission.
If you have an async value, it's not possible to get its value synchronously. For example, if you have a promise, you can only access the eventual result via the then() method. Similarly, await can only be used in an async context, which is usually an async function or a module. Promises are never blocking — only the logic depending on the promise's result will be deferred; everything else continues to execute in the meantime. If you are a functional programmer, you may recognize promises as monads which can be mapped with then() (however, they are not proper monads because they auto-flatten; i.e., you can't have a Promise<Promise<T>>).
In fact, the single-threaded model has made Node.js a popular choice for server-side programming due to its non-blocking IO, making handling a large number of database or file-system requests very performant. However, CPU-bound (computationally intensive) tasks that are pure JavaScript will still block the main thread. To achieve real paralleling, you may need to use workers.
To learn more about asynchronous programming, you can read about using promises or follow the asynchronous JavaScript tutorial.ModulesJavaScript also specifies a module system supported by most runtimes. A module is usually a file, identified by its file path or URL. You can use the import and export statements to exchange data between modules:
jsimport { foo } from "./foo.js";

// Unexported variables are local to the module
const b = 2;

export const a = 1;

Unlike Haskell, Python, Java, etc., JavaScript module resolution is entirely host-defined — it's usually based on URLs or file paths, so relative file paths "just work" and are relative to the current module's path instead of some project root path.
However, the JavaScript language doesn't offer standard library modules — all core functionalities are powered by global variables like Math and Intl instead. This is due to the long history of JavaScript lacking a module system, and the fact that opting into the module system involves some changes to the runtime setup.
Different runtimes may use different module systems. For example, Node.js uses the package manager npm and is mostly file-system based, while Deno and browsers are fully URL-based and modules can be resolved from HTTP URLs.
For more information, see the modules guide page.Language and runtimeThroughout this page, we've constantly mentioned that certain features are language-level while others are runtime-level.
JavaScript is a general-purpose scripting language. The core language specification focuses on pure computational logic. It doesn't deal with any input/output — in fact, without extra runtime-level APIs (most notably console.log()), a JavaScript program's behavior is entirely unobservable.
A runtime, or a host, is something that feeds data to the JavaScript engine (the interpreter), provides extra global properties, and provides hooks for the engine to interact with the outside world. Module resolution, reading data, printing messages, sending network requests, etc. are all runtime-level operations. Since its inception, JavaScript has been adopted in various environments, such as browsers (which provide APIs like DOM), Node.js (which provides APIs like file system access), etc. JavaScript has been successfully integrated in web (which was its primary purpose), mobile apps, desktop apps, server-side apps, serverless, embedded systems, and more. While you learn about JavaScript core features, it's also important to understand host-provided features in order to put the knowledge to use. For example, you can read about all web platform APIs, which are implemented by browsers, and sometimes non-browsers.Further explorationThis page offers a very basic insight into how various JavaScript features compare with other languages. If you want to learn more about the language itself and the nuances of each feature, you can read the JavaScript guide and the JavaScript reference.
There are some essential parts of the language that we have omitted due to space and complexity, but you can explore on your own:

Inheritance and the prototype chain
Closures
Regular expressions
Iteration
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJavaScript language overviewJavaScript is a multi-paradigm, dynamic language with types and operators, standard built-in objects, and methods. Its syntax is based on the Java and C languages — many structures from those languages apply to JavaScript as well. JavaScript supports object-oriented programming with object prototypes and classes. It also supports functional programming since functions are first-class objects that can be easily created via expressions and passed around like any other object.
This page serves as a quick overview of various JavaScript language features, written for readers with background in other languages, such as C or Java.Data typesLet's start off by looking at the building blocks of any language: the types. JavaScript programs manipulate values, and those values all belong to a type. JavaScript offers seven primitive types:

Number: used for all number values (integer and floating point) except for very big integers.
BigInt: used for arbitrarily large integers.
String: used to store text.
Boolean: true and false — usually used for conditional logic.
Symbol: used for creating unique identifiers that won't collide.
Undefined: indicating that a variable has not been assigned a value.
Null: indicating a deliberate non-value.

Everything else is known as an Object. Common object types include:

Function
Array
Map
RegExp
Error

Functions aren't special data structures in JavaScript — they are just a special type of object that can be called.NumbersJavaScript has two built-in numeric types: Number and BigInt.
The Number type is a IEEE 754 64-bit double-precision floating point value, which means integers can be safely represented between -(253 − 1) and 253 − 1 without loss of precision, and floating point numbers can be stored all the way up to 1.79 × 10308. Within numbers, JavaScript does not distinguish between floating point numbers and integers.
jsconsole.log(3 / 2); // 1.5, not 1

So an apparent integer is in fact implicitly a float. Because of IEEE 754 encoding, sometimes floating point arithmetic can be imprecise.
jsconsole.log(0.1 + 0.2); // 0.30000000000000004

For operations that expect integers, such as bitwise operations, the number will be converted to a 32-bit integer.
Number literals can also have prefixes to indicate the base (binary, octal, decimal, or hexadecimal), or an exponent suffix.
jsconsole.log(0b111110111); // 503
console.log(0o767); // 503
console.log(0x1f7); // 503
console.log(5.03e2); // 503

The BigInt type is an arbitrary length integer. Its behavior is similar to C's integer types (e.g., division truncates to zero), except it can grow indefinitely. BigInts are specified with a number literal and an n suffix.
jsconsole.log(-3n / 2n); // -1n

The standard arithmetic operators are supported, including addition, subtraction, remainder arithmetic, etc. BigInts and numbers cannot be mixed in arithmetic operations.
The Math object provides standard mathematical functions and constants.
jsMath.sin(3.5);
const circumference = 2 * Math.PI * r;

There are three ways to convert a string to a number:

parseInt(), which parses the string for an integer.
parseFloat(), which parses the string for a floating-point number.
The Number() function, which parses a string as if it's a number literal and supports many different number representations.

You can also use the unary plus + as a shorthand for Number().
Number values also include NaN (short for "Not a Number") and Infinity. Many "invalid math" operations will return NaN — for example, if attempting to parse a non-numeric string, or using Math.log() on a negative value. Division by zero produces Infinity (positive or negative).
NaN is contagious: if you provide it as an operand to any mathematical operation, the result will also be NaN. NaN is the only value in JavaScript that's not equal to itself (per IEEE 754 specification).StringsStrings in JavaScript are sequences of Unicode characters. This should be welcome news to anyone who has had to deal with internationalization. More accurately, they are UTF-16 encoded.
jsconsole.log("Hello, world");
console.log("你好，世界！"); // Nearly all Unicode characters can be written literally in string literals

Strings can be written with either single or double quotes — JavaScript does not have the distinction between characters and strings. If you want to represent a single character, you just use a string consisting of that single character.
jsconsole.log("Hello"[1] === "e"); // true

To find the length of a string (in code units), access its length property.
Strings have utility methods to manipulate the string and access information about the string. Because all primitives are immutable by design, these methods return new strings.
The + operator is overloaded for strings: when one of the operands is a string, it performs string concatenation instead of number addition. A special template literal syntax allows you to write strings with embedded expressions more succinctly. Unlike Python's f-strings or C#'s interpolated strings, template literals use backticks (not single or double quotes).
jsconst age = 25;
console.log("I am " + age + " years old."); // String concatenation
console.log(`I am ${age} years old.`); // Template literal
Other typesJavaScript distinguishes between null, which indicates a deliberate non-value (and is only accessible through the null keyword), and undefined, which indicates absence of value. There are many ways to obtain undefined:

A return statement with no value (return;) implicitly returns undefined.
Accessing a nonexistent object property (obj.iDontExist) returns undefined.
A variable declaration without initialization (let x;) will implicitly initialize the variable to undefined.

JavaScript has a Boolean type, with possible values true and false — both of which are keywords. Any value can be converted to a boolean according to the following rules:

false, 0, empty strings (""), NaN, null, and undefined all become false.
All other values become true.

You can perform this conversion explicitly using the Boolean() function:
jsBoolean(""); // false
Boolean(234); // true

However, this is rarely necessary, as JavaScript will silently perform this conversion when it expects a boolean, such as in an if statement (see Control structures). For this reason, we sometimes speak of "truthy" and "falsy", meaning values that become true and false, respectively, when used in boolean contexts.
Boolean operations such as && (logical and), || (logical or), and ! (logical not) are supported; see Operators.
The Symbol type is often used to create unique identifiers. Every symbol created with the Symbol() function is guaranteed to be unique. In addition, there are registered symbols, which are shared constants, and well-known symbols, which are utilized by the language as "protocols" for certain operations. You can read more about them in the symbol reference.VariablesVariables in JavaScript are declared using one of three keywords: let, const, or var.
let allows you to declare block-level variables. The declared variable is available from the block it is enclosed in.
jslet a;
let name = "Simon";

// myLetVariable is *not* visible out here

for (let myLetVariable = 0; myLetVariable < 5; myLetVariable++) {
  // myLetVariable is only visible in here
}

// myLetVariable is *not* visible out here

const allows you to declare variables whose values are never intended to change. The variable is available from the block it is declared in.
jsconst Pi = 3.14; // Declare variable Pi
console.log(Pi); // 3.14

A variable declared with const cannot be reassigned.
jsconst Pi = 3.14;
Pi = 1; // will throw an error because you cannot change a constant variable.

const declarations only prevent reassignments — they don't prevent mutations of the variable's value, if it's an object.
jsconst obj = {};
obj.a = 1; // no error
console.log(obj); // { a: 1 }

var declarations can have surprising behaviors (for example, they are not block-scoped), and they are discouraged in modern JavaScript code.
If you declare a variable without assigning any value to it, its value is undefined. You can't declare a const variable without an initializer, because you can't change it later anyway.
let and const declared variables still occupy the entire scope they are defined in, and are in a region known as the temporal dead zone before the actual line of declaration. This has some interesting interactions with variable shadowing, which don't occur in other languages.
jsfunction foo(x, condition) {
  if (condition) {
    console.log(x);
    const x = 2;
    console.log(x);
  }
}

foo(1, true);

In most other languages, this would log "1" and "2", because before the const x = 2 line, x should still refer to the parameter x in the upper scope. In JavaScript, because each declaration occupies the entire scope, this would throw an error on the first console.log: "Cannot access 'x' before initialization". For more information, see the reference page of let.
JavaScript is dynamically typed. Types (as described in the previous section) are only associated with values, but not with variables. For let-declared variables, you can always change its type through reassignment.
jslet a = 1;
a = "foo";
OperatorsJavaScript's numeric operators include +, -, *, /, % (remainder), and ** (exponentiation). Values are assigned using =. Each binary operator also has a compound assignment counterpart such as += and -=, which extend out to x = x operator y.
jsx += 5;
x = x + 5;

You can use ++ and -- to increment and decrement respectively. These can be used as a prefix or postfix operators.
The + operator also does string concatenation:
js"hello" + " world"; // "hello world"

If you add a string to a number (or other value) everything is converted into a string first. This might trip you up:
js"3" + 4 + 5; // "345"
3 + 4 + "5"; // "75"

Adding an empty string to something is a useful way of converting it to a string itself.
Comparisons in JavaScript can be made using <, >, <= and >=, which work for both strings and numbers. For equality, the double-equals operator performs type coercion if you give it different types, with sometimes interesting results. On the other hand, the triple-equals operator does not attempt type coercion, and is usually preferred.
js123 == "123"; // true
1 == true; // true

123 === "123"; // false
1 === true; // false

The double-equals and triple-equals also have their inequality counterparts: != and !==.
JavaScript also has bitwise operators and logical operators. Notably, logical operators don't work with boolean values only — they work by the "truthiness" of the value.
jsconst a = 0 && "Hello"; // 0 because 0 is "falsy"
const b = "Hello" || "world"; // "Hello" because both "Hello" and "world" are "truthy"

The && and || operators use short-circuit logic, which means whether they will execute their second operand is dependent on the first. This is useful for checking for null objects before accessing their attributes:
jsconst name = o && o.getName();

Or for caching values (when falsy values are invalid):
jsconst name = cachedName || (cachedName = getName());

For a comprehensive list of operators, see the guide page or reference section. You may be especially interested in the operator precedence.GrammarJavaScript grammar is very similar to the C family. There are a few points worth mentioning:

Identifiers can have Unicode characters, but they cannot be one of the reserved words.
Comments are commonly // or /* */, while many other scripting languages like Perl, Python, and Bash use #.
Semicolons are optional in JavaScript — the language automatically inserts them when needed. However, there are certain caveats to watch out for, since unlike Python, semicolons are still part of the syntax.

For an in-depth look at the JavaScript grammar, see the reference page for lexical grammar.Control structuresJavaScript has a similar set of control structures to other languages in the C family. Conditional statements are supported by if and else; you can chain them together:
jslet name = "kittens";
if (name === "puppies") {
  name += " woof";
} else if (name === "kittens") {
  name += " meow";
} else {
  name += "!";
}
name === "kittens meow";

JavaScript doesn't have elif, and else if is really just an else branch comprised of a single if statement.
JavaScript has while loops and do...while loops. The first is good for basic looping; the second is for loops where you wish to ensure that the body of the loop is executed at least once:
jswhile (true) {
  // an infinite loop!
}

let input;
do {
  input = get_input();
} while (inputIsNotValid(input));

JavaScript's for loop is the same as that in C and Java: it lets you provide the control information for your loop on a single line.
jsfor (let i = 0; i < 5; i++) {
  // Will execute 5 times
}

JavaScript also contains two other prominent for loops: for...of, which iterates over iterables, most notably arrays, and for...in, which visits all enumerable properties of an object.
jsfor (const value of array) {
  // do something with value
}

for (const property in object) {
  // do something with object property
}

The switch statement can be used for multiple branches based on equality checking.
jsswitch (action) {
  case "draw":
    drawIt();
    break;
  case "eat":
    eatIt();
    break;
  default:
    doNothing();
}

Similar to C, case clauses are conceptually the same as labels, so if you don't add a break statement, execution will "fall through" to the next level. However, they are not actually jump tables — any expression can be part of the case clause, not just string or number literals, and they would be evaluated one-by-one until one equals the value being matched. Comparison takes place between the two using the === operator.
Unlike some languages like Rust, control-flow structures are statements in JavaScript, meaning you can't assign them to a variable, like const a = if (x) { 1 } else { 2 }.
JavaScript errors are handled using the try...catch statement.
jstry {
  buildMySite("./website");
} catch (e) {
  console.error("Building site failed:", e);
}

Errors can be thrown using the throw statement. Many built-in operations may throw as well.
jsfunction buildMySite(siteDirectory) {
  if (!pathExists(siteDirectory)) {
    throw new Error("Site directory does not exist");
  }
}

In general, you can't tell the type of the error you just caught, because anything can be thrown from a throw statement. However, you can usually assume it's an Error instance, as is the example above. There are some subclasses of Error built-in, like TypeError and RangeError, that you can use to provide extra semantics about the error. There's no conditional catch in JavaScript — if you only want to handle one type of error, you need to catch everything, identify the type of error using instanceof, and then rethrow the other cases.
jstry {
  buildMySite("./website");
} catch (e) {
  if (e instanceof RangeError) {
    console.error("Seems like a parameter is out of range:", e);
    console.log("Retrying...");
    buildMySite("./website");
  } else {
    // Don't know how to handle other error types; throw them so
    // something else up in the call stack may catch and handle it
    throw e;
  }
}

If an error is uncaught by any try...catch in the call stack, the program will exit.
For a comprehensive list of control flow statements, see the reference section.ObjectsJavaScript objects can be thought of as collections of key-value pairs. As such, they are similar to:

Dictionaries in Python.
Hashes in Perl and Ruby.
Hash tables in C and C++.
HashMaps in Java.
Associative arrays in PHP.

JavaScript objects are hashes. Unlike objects in statically typed languages, objects in JavaScript do not have fixed shapes — properties can be added, deleted, re-ordered, mutated, or dynamically queried at any time. Object keys are always strings or symbols — even array indices, which are canonically integers, are actually strings under the hood.
Objects are usually created using the literal syntax:
jsconst obj = {
  name: "Carrot",
  for: "Max",
  details: {
    color: "orange",
    size: 12,
  },
};

Object properties can be accessed using dot (.) or square brackets ([]). When using the dot notation, the key must be a valid identifier. Square brackets, on the other hand, allow indexing the object with a dynamic key value.
js// Dot notation
obj.name = "Simon";
const name = obj.name;

// Bracket notation
obj["name"] = "Simon";
const name = obj["name"];

// Can use a variable to define a key
const userName = prompt("what is your key?");
obj[userName] = prompt("what is its value?");

Property access can be chained together:
jsobj.details.color; // orange
obj["details"]["size"]; // 12

Objects are always references, so unless something is explicitly copying the object, mutations to an object would be visible to the outside.
jsconst obj = {};
function doSomething(o) {
  o.x = 1;
}
doSomething(obj);
console.log(obj.x); // 1

This also means two separately created objects will never be equal (!==), because they are different references. If you hold two references of the same object, mutating one would be observable through the other.
jsconst me = {};
const stillMe = me;
me.x = 1;
console.log(stillMe.x); // 1

For more on objects and prototypes, see the Object reference page. For more information on the object initializer syntax, see its reference page.
This page has omitted all details about object prototypes and inheritance because you can usually achieve inheritance with classes without touching the underlying mechanism (which you may have heard to be abstruse). To learn about them, see Inheritance and the prototype chain.ArraysArrays in JavaScript are actually a special type of object. They work very much like regular objects (numerical properties can naturally be accessed only using [] syntax) but they have one magic property called length. This is always one more than the highest index in the array.
Arrays are usually created with array literals:
jsconst a = ["dog", "cat", "hen"];
a.length; // 3

JavaScript arrays are still objects — you can assign any properties to them, including arbitrary number indices. The only "magic" is that length will be automatically updated when you set a particular index.
jsconst a = ["dog", "cat", "hen"];
a[100] = "fox";
console.log(a.length); // 101
console.log(a); // ['dog', 'cat', 'hen', empty × 97, 'fox']

The array we got above is called a sparse array because there are uninhabited slots in the middle, and will cause the engine to deoptimize it from an array to a hash table. Make sure your array is densely populated!
Out-of-bounds indexing doesn't throw. If you query a non-existent array index, you'll get a value of undefined in return:
jsconst a = ["dog", "cat", "hen"];
console.log(typeof a[90]); // undefined

Arrays can have any elements and can grow or shrink arbitrarily.
jsconst arr = [1, "foo", true];
arr.push({});
// arr = [1, "foo", true, {}]

Arrays can be iterated with the for loop, as you can in other C-like languages:
jsfor (let i = 0; i < a.length; i++) {
  // Do something with a[i]
}

Or, since arrays are iterable, you can use the for...of loop, which is synonymous to C++/Java's for (int x : arr) syntax:
jsfor (const currentValue of a) {
  // Do something with currentValue
}

Arrays come with a plethora of array methods. Many of them would iterate the array — for example, map() would apply a callback to every array element, and return a new array:
jsconst babies = ["dog", "cat", "hen"].map((name) => `baby ${name}`);
// babies = ['baby dog', 'baby cat', 'baby hen']
FunctionsAlong with objects, functions are the core component in understanding JavaScript. The most basic function declaration looks like this:
jsfunction add(x, y) {
  const total = x + y;
  return total;
}

A JavaScript function can take 0 or more parameters. The function body can contain as many statements as you like and can declare its own variables which are local to that function. The return statement can be used to return a value at any time, terminating the function. If no return statement is used (or an empty return with no value), JavaScript returns undefined.
Functions can be called with more or fewer parameters than it specifies. If you call a function without passing the parameters it expects, they will be set to undefined. If you pass more parameters than it expects, the function will ignore the extra parameters.
jsadd(); // NaN
// Equivalent to add(undefined, undefined)

add(2, 3, 4); // 5
// added the first two; 4 was ignored

There are a number of other parameter syntaxes available. For example, the rest parameter syntax allows collecting all the extra parameters passed by the caller into an array, similar to Python's *args. (Since JS doesn't have named parameters on the language level, there's no **kwargs.)
jsfunction avg(...args) {
  let sum = 0;
  for (const item of args) {
    sum += item;
  }
  return sum / args.length;
}

avg(2, 3, 4, 5); // 3.5

In the above code, the variable args holds all the values that were passed into the function.
The rest parameter will store all arguments after where it's declared, but not before. In other words, function avg(firstValue, ...args) will store the first value passed into the function in the firstValue variable and the remaining arguments in args.
If a function accepts a list of arguments and you already hold them in an array, you can use the spread syntax in the function call to spread the array as a list of elements. For instance: avg(...numbers).
We mentioned that JavaScript doesn't have named parameters. It's possible, though, to implement them using object destructuring, which allows objects to be conveniently packed and unpacked.
js// Note the { } braces: this is destructuring an object
function area({ width, height }) {
  return width * height;
}

// The { } braces here create a new object
console.log(area({ width: 2, height: 3 }));

There's also the default parameter syntax, which allows omitted parameters (or those passed as undefined) to have a default value.
jsfunction avg(firstValue, secondValue, thirdValue = 0) {
  return (firstValue + secondValue + thirdValue) / 3;
}

avg(1, 2); // 1, instead of NaN
Anonymous functionsJavaScript lets you create anonymous functions — that is, functions without names. In practice, anonymous functions are typically used as arguments to other functions, immediately assigned to a variable that can be used to invoke the function, or returned from another function.
js// Note that there's no function name before the parentheses
const avg = function (...args) {
  let sum = 0;
  for (const item of args) {
    sum += item;
  }
  return sum / args.length;
};

That makes the anonymous function invocable by calling avg() with some arguments — that is, it's semantically equivalent to declaring the function using the function avg() {} declaration syntax.
There's another way to define anonymous functions — using an arrow function expression.
js// Note that there's no function name before the parentheses
const avg = (...args) => {
  let sum = 0;
  for (const item of args) {
    sum += item;
  }
  return sum / args.length;
};

// You can omit the `return` when simply returning an expression
const sum = (a, b, c) => a + b + c;

Arrow functions are not semantically equivalent to function expressions — for more information, see its reference page.
There's another way that anonymous functions can be useful: it can be simultaneously declared and invoked in a single expression, called an Immediately invoked function expression (IIFE):
js(function () {
  // …
})();

For use-cases of IIFEs, you can read emulating private methods with closures.Recursive functionsJavaScript allows you to call functions recursively. This is particularly useful for dealing with tree structures, such as those found in the browser DOM.
jsfunction countChars(elm) {
  if (elm.nodeType === 3) {
    // TEXT_NODE
    return elm.nodeValue.length;
  }
  let count = 0;
  for (let i = 0, child; (child = elm.childNodes[i]); i++) {
    count += countChars(child);
  }
  return count;
}

Function expressions can be named as well, which allows them to be recursive.
jsconst charsInBody = (function counter(elm) {
  if (elm.nodeType === 3) {
    // TEXT_NODE
    return elm.nodeValue.length;
  }
  let count = 0;
  for (let i = 0, child; (child = elm.childNodes[i]); i++) {
    count += counter(child);
  }
  return count;
})(document.body);

The name provided to a function expression as above is only available to the function's own scope. This allows more optimizations to be done by the engine and results in more readable code. The name also shows up in the debugger and some stack traces, which can save you time when debugging.
If you are used to functional programming, beware of the performance implications of recursion in JavaScript. Although the language specification specifies tail-call optimization, only JavaScriptCore (used by Safari) has implemented it, due to the difficulty of recovering stack traces and debuggability. For deep recursion, consider using iteration instead to avoid stack overflow.Functions are first-class objectsJavaScript functions are first-class objects. This means that they can be assigned to variables, passed as arguments to other functions, and returned from other functions. In addition, JavaScript supports closures out-of-the-box without explicit capturing, allowing you to conveniently apply functional programming styles.
js// Function returning function
const add = (x) => (y) => x + y;
// Function accepting function
const babies = ["dog", "cat", "hen"].map((name) => `baby ${name}`);

Note that JavaScript functions are themselves objects — like everything else in JavaScript — and you can add or change properties on them just like we've seen earlier in the Objects section.Inner functionsJavaScript function declarations are allowed inside other functions. An important detail of nested functions in JavaScript is that they can access variables in their parent function's scope:
jsfunction parentFunc() {
  const a = 1;

  function nestedFunc() {
    const b = 4; // parentFunc can't use this
    return a + b;
  }
  return nestedFunc(); // 5
}

This provides a great deal of utility in writing more maintainable code. If a called function relies on one or two other functions that are not useful to any other part of your code, you can nest those utility functions inside it. This keeps the number of functions that are in the global scope down.
This is also a great counter to the lure of global variables. When writing complex code, it is often tempting to use global variables to share values between multiple functions, which leads to code that is hard to maintain. Nested functions can share variables in their parent, so you can use that mechanism to couple functions together without polluting your global namespace.ClassesJavaScript offers the class syntax that's very similar to languages like Java.
jsclass Person {
  constructor(name) {
    this.name = name;
  }
  sayHello() {
    return `Hello, I'm ${this.name}!`;
  }
}

const p = new Person("Maria");
console.log(p.sayHello());

JavaScript classes are just functions that must be instantiated with the new operator. Every time a class is instantiated, it returns an object containing the methods and properties that the class specified. Classes don't enforce any code organization — for example, you can have functions returning classes, or you can have multiple classes per file. Here's an example of how ad hoc the creation of a class can be: it's just an expression returned from an arrow function. This pattern is called a mixin.
jsconst withAuthentication = (cls) =>
  class extends cls {
    authenticate() {
      // …
    }
  };

class Admin extends withAuthentication(Person) {
  // …
}

Static properties are created by prepending static. Private properties are created by prepending a hash # (not private). The hash is an integral part of the property name. (Think about # as _ in Python.) Unlike most other languages, there's absolutely no way to read a private property outside the class body — not even in derived classes.
For a detailed guide on various class features, you can read the guide page.Asynchronous programmingJavaScript is single-threaded by nature. There's no paralleling; only concurrency. Asynchronous programming is powered by an event loop, which allows a set of tasks to be queued and polled for completion.
There are three idiomatic ways to write asynchronous code in JavaScript:

Callback-based (such as setTimeout())
Promise-based
async/await, which is a syntactic sugar for Promises

For example, here's what a file-read operation might look like in JavaScript:
js// Callback-based
fs.readFile(filename, (err, content) => {
  // This callback is invoked when the file is read, which could be after a while
  if (err) {
    throw err;
  }
  console.log(content);
});
// Code here will be executed while the file is waiting to be read

// Promise-based
fs.readFile(filename)
  .then((content) => {
    // What to do when the file is read
    console.log(content);
  })
  .catch((err) => {
    throw err;
  });
// Code here will be executed while the file is waiting to be read

// Async/await
async function readFile(filename) {
  const content = await fs.readFile(filename);
  console.log(content);
}

The core language doesn't specify any asynchronous programming features, but it's crucial when interacting with the external environment — from asking user permissions, to fetching data, to reading files. Keeping the potentially long-running operations async ensures that other processes can still run while this one waits — for example, the browser will not freeze while waiting for the user to click a button to grant permission.
If you have an async value, it's not possible to get its value synchronously. For example, if you have a promise, you can only access the eventual result via the then() method. Similarly, await can only be used in an async context, which is usually an async function or a module. Promises are never blocking — only the logic depending on the promise's result will be deferred; everything else continues to execute in the meantime. If you are a functional programmer, you may recognize promises as monads which can be mapped with then() (however, they are not proper monads because they auto-flatten; i.e., you can't have a Promise<Promise<T>>).
In fact, the single-threaded model has made Node.js a popular choice for server-side programming due to its non-blocking IO, making handling a large number of database or file-system requests very performant. However, CPU-bound (computationally intensive) tasks that are pure JavaScript will still block the main thread. To achieve real paralleling, you may need to use workers.
To learn more about asynchronous programming, you can read about using promises or follow the asynchronous JavaScript tutorial.ModulesJavaScript also specifies a module system supported by most runtimes. A module is usually a file, identified by its file path or URL. You can use the import and export statements to exchange data between modules:
jsimport { foo } from "./foo.js";

// Unexported variables are local to the module
const b = 2;

export const a = 1;

Unlike Haskell, Python, Java, etc., JavaScript module resolution is entirely host-defined — it's usually based on URLs or file paths, so relative file paths "just work" and are relative to the current module's path instead of some project root path.
However, the JavaScript language doesn't offer standard library modules — all core functionalities are powered by global variables like Math and Intl instead. This is due to the long history of JavaScript lacking a module system, and the fact that opting into the module system involves some changes to the runtime setup.
Different runtimes may use different module systems. For example, Node.js uses the package manager npm and is mostly file-system based, while Deno and browsers are fully URL-based and modules can be resolved from HTTP URLs.
For more information, see the modules guide page.Language and runtimeThroughout this page, we've constantly mentioned that certain features are language-level while others are runtime-level.
JavaScript is a general-purpose scripting language. The core language specification focuses on pure computational logic. It doesn't deal with any input/output — in fact, without extra runtime-level APIs (most notably console.log()), a JavaScript program's behavior is entirely unobservable.
A runtime, or a host, is something that feeds data to the JavaScript engine (the interpreter), provides extra global properties, and provides hooks for the engine to interact with the outside world. Module resolution, reading data, printing messages, sending network requests, etc. are all runtime-level operations. Since its inception, JavaScript has been adopted in various environments, such as browsers (which provide APIs like DOM), Node.js (which provides APIs like file system access), etc. JavaScript has been successfully integrated in web (which was its primary purpose), mobile apps, desktop apps, server-side apps, serverless, embedded systems, and more. While you learn about JavaScript core features, it's also important to understand host-provided features in order to put the knowledge to use. For example, you can read about all web platform APIs, which are implemented by browsers, and sometimes non-browsers.Further explorationThis page offers a very basic insight into how various JavaScript features compare with other languages. If you want to learn more about the language itself and the nuances of each feature, you can read the JavaScript guide and the JavaScript reference.
There are some essential parts of the language that we have omitted due to space and complexity, but you can explore on your own:

Inheritance and the prototype chain
Closures
Regular expressions
Iteration
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJavaScript data types and data structuresProgramming languages all have built-in data structures, but these often differ from one language to another. This article attempts to list the built-in data structures available in JavaScript and what properties they have. These can be used to build other data structures.
The language overview offers a similar summary of the common data types, but with more comparisons to other languages.Dynamic and weak typingJavaScript is a dynamic language with dynamic types. Variables in JavaScript are not directly associated with any particular value type, and any variable can be assigned (and re-assigned) values of all types:
jslet foo = 42; // foo is now a number
foo = "bar"; // foo is now a string
foo = true; // foo is now a boolean

JavaScript is also a weakly typed language, which means it allows implicit type conversion when an operation involves mismatched types, instead of throwing type errors.
jsconst foo = 42; // foo is a number
const result = foo + "1"; // JavaScript coerces foo to a string, so it can be concatenated with the other operand
console.log(result); // 421

Implicit coercions are very convenient, but can create subtle bugs when conversions happen where they are not expected, or where they are expected to happen in the other direction (for example, string to number instead of number to string). For symbols and BigInts, JavaScript has intentionally disallowed certain implicit type conversions.Primitive valuesAll types except Object define immutable values represented directly at the lowest level of the language. We refer to values of these types as primitive values.
All primitive types, except null, can be tested by the typeof operator. typeof null returns "object", so one has to use === null to test for null.
All primitive types, except null and undefined, have their corresponding object wrapper types, which provide useful methods for working with the primitive values. For example, the Number object provides methods like toExponential(). When a property is accessed on a primitive value, JavaScript automatically wraps the value into the corresponding wrapper object and accesses the property on the object instead. However, accessing a property on null or undefined throws a TypeError exception, which necessitates the introduction of the optional chaining operator.



Type
typeof return value
Object wrapper




Null
"object"
N/A


Undefined
"undefined"
N/A


Boolean
"boolean"
Boolean


Number
"number"
Number


BigInt
"bigint"
BigInt


String
"string"
String


Symbol
"symbol"
Symbol



The object wrapper classes' reference pages contain more information about the methods and properties available for each type, as well as detailed descriptions for the semantics of the primitive types themselves.Null typeThe Null type is inhabited by exactly one value: null.Undefined typeThe Undefined type is inhabited by exactly one value: undefined.
Conceptually, undefined indicates the absence of a value, while null indicates the absence of an object (which could also make up an excuse for typeof null === "object"). The language usually defaults to undefined when something is devoid of a value:

A return statement with no value (return;) implicitly returns undefined.
Accessing a nonexistent object property (obj.iDontExist) returns undefined.
A variable declaration without initialization (let x;) implicitly initializes the variable to undefined.
Many methods, such as Array.prototype.find() and Map.prototype.get(), return undefined when no element is found.

null is used much less often in the core language. The most important place is the end of the prototype chain — subsequently, methods that interact with prototypes, such as Object.getPrototypeOf(), Object.create(), etc., accept or return null instead of undefined.
null is a keyword, but undefined is a normal identifier that happens to be a global property. In practice, the difference is minor, since undefined should not be redefined or shadowed.Boolean typeThe Boolean type represents a logical entity and is inhabited by two values: true and false.
Boolean values are usually used for conditional operations, including ternary operators, if...else, while, etc.Number typeThe Number type is a double-precision 64-bit binary format IEEE 754 value. It is capable of storing positive floating-point numbers between 2-1074 (Number.MIN_VALUE) and 21023 × (2 - 2-52) (Number.MAX_VALUE) as well as negative floating-point numbers of the same magnitude, but it can only safely store integers in the range -(253 − 1) (Number.MIN_SAFE_INTEGER) to 253 − 1 (Number.MAX_SAFE_INTEGER). Outside this range, JavaScript can no longer safely represent integers; they will instead be represented by a double-precision floating point approximation. You can check if a number is within the range of safe integers using Number.isSafeInteger().
Values outside the representable range are automatically converted:

Positive values greater than Number.MAX_VALUE are converted to +Infinity.
Positive values smaller than Number.MIN_VALUE are converted to +0.
Negative values smaller than -Number.MAX_VALUE are converted to -Infinity.
Negative values greater than -Number.MIN_VALUE are converted to -0.

+Infinity and -Infinity behave similarly to mathematical infinity, but with some slight differences; see Number.POSITIVE_INFINITY and Number.NEGATIVE_INFINITY for details.
The Number type has only one value with multiple representations: 0 is represented as both -0 and +0 (where 0 is an alias for +0). In practice, there is almost no difference between the different representations; for example, +0 === -0 is true. However, you are able to notice this when you divide by zero:
jsconsole.log(42 / +0); // Infinity
console.log(42 / -0); // -Infinity

NaN ("Not a Number") is a special kind of number value that's typically encountered when the result of an arithmetic operation cannot be expressed as a number. It is also the only value in JavaScript that is not equal to itself.
Although a number is conceptually a "mathematical value" and is always implicitly floating-point-encoded, JavaScript provides bitwise operators. When applying bitwise operators, the number is first converted to a 32-bit integer.

Note:
Although bitwise operators can be used to represent several Boolean values within a single number using bit masking, this is usually considered a bad practice. JavaScript offers other means to represent a set of Booleans (like an array of Booleans, or an object with Boolean values assigned to named properties). Bit masking also tends to make the code more difficult to read, understand, and maintain.

It may be necessary to use such techniques in very constrained environments, like when trying to cope with the limitations of local storage, or in extreme cases (such as when each bit over the network counts). This technique should only be considered when it is the last measure that can be taken to optimize size.BigInt typeThe BigInt type is a numeric primitive in JavaScript that can represent integers with arbitrary magnitude. With BigInts, you can safely store and operate on large integers even beyond the safe integer limit (Number.MAX_SAFE_INTEGER) for Numbers.
A BigInt is created by appending n to the end of an integer or by calling the BigInt() function.
This example demonstrates where incrementing the Number.MAX_SAFE_INTEGER returns the expected result:
js// BigInt
const x = BigInt(Number.MAX_SAFE_INTEGER); // 9007199254740991n
x + 1n === x + 2n; // false because 9007199254740992n and 9007199254740993n are unequal

// Number
Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2; // true because both are 9007199254740992

You can use most operators to work with BigInts, including +, *, -, **, and % — the only forbidden one is >>>. A BigInt is not strictly equal to a Number with the same mathematical value, but it is loosely so.
BigInt values are neither always more precise nor always less precise than numbers, since BigInts cannot represent fractional numbers, but can represent big integers more accurately. Neither type entails the other, and they are not mutually substitutable. A TypeError is thrown if BigInt values are mixed with regular numbers in arithmetic expressions, or if they are implicitly converted to each other.String typeThe String type represents textual data and is encoded as a sequence of 16-bit unsigned integer values representing UTF-16 code units. Each element in the string occupies a position in the string. The first element is at index 0, the next at index 1, and so on. The length of a string is the number of UTF-16 code units in it, which may not correspond to the actual number of Unicode characters; see the String reference page for more details.
JavaScript strings are immutable. This means that once a string is created, it is not possible to modify it. String methods create new strings based on the content of the current string — for example:

A substring of the original using substring().
A concatenation of two strings using the concatenation operator (+) or concat().

Beware of "stringly-typing" your code!
It can be tempting to use strings to represent complex data. Doing this comes with short-term benefits:

It is easy to build complex strings with concatenation.
Strings are easy to debug (what you see printed is always what is in the string).
Strings are the common denominator of a lot of APIs (input fields, local storage values, fetch() responses when using Response.text(), etc.) and it can be tempting to only work with strings.

With conventions, it is possible to represent any data structure in a string. This does not make it a good idea. For instance, with a separator, one could emulate a list (while a JavaScript array would be more suitable). Unfortunately, when the separator is used in one of the "list" elements, then, the list is broken. An escape character can be chosen, etc. All of this requires conventions and creates an unnecessary maintenance burden.
Use strings for textual data. When representing complex data, parse strings, and use the appropriate abstraction.Symbol typeA Symbol is a unique and immutable primitive value and may be used as the key of an Object property (see below). In some programming languages, Symbols are called "atoms". The purpose of symbols is to create unique property keys that are guaranteed not to clash with keys from other code.ObjectsIn computer science, an object is a value in memory which is possibly referenced by an identifier. In JavaScript, objects are the only mutable values. Functions are, in fact, also objects with the additional capability of being callable.PropertiesIn JavaScript, objects can be seen as a collection of properties. With the object literal syntax, a limited set of properties are initialized; then properties can be added and removed. Object properties are equivalent to key-value pairs. Property keys are either strings or symbols. When other types (such as numbers) are used to index objects, the values are implicitly converted to strings. Property values can be values of any type, including other objects, which enables building complex data structures.
There are two types of object properties: The data property and the accessor property. Each property has corresponding attributes. Each attribute is accessed internally by the JavaScript engine, but you can set them through Object.defineProperty(), or read them through Object.getOwnPropertyDescriptor(). You can read more about the various nuances on the Object.defineProperty() page.
Data property
Data properties associate a key with a value. It can be described by the following attributes:

value

The value retrieved by a get access of the property. Can be any JavaScript value.

writable

A boolean value indicating if the property can be changed with an assignment.

enumerable

A boolean value indicating if the property can be enumerated by a for...in loop. See also Enumerability and ownership of properties for how enumerability interacts with other functions and syntaxes.

configurable

A boolean value indicating if the property can be deleted, can be changed to an accessor property, and can have its attributes changed.


Accessor property
Associates a key with one of two accessor functions (get and set) to retrieve or store a value.

Note:
It's important to recognize it's accessor property — not accessor method. We can give a JavaScript object class-like accessors by using a function as a value — but that doesn't make the object a class.

An accessor property has the following attributes:

get

A function called with an empty argument list to retrieve the property value whenever a get access to the value is performed. See also getters. May be undefined.

set

A function called with an argument that contains the assigned value. Executed whenever a specified property is attempted to be changed. See also setters. May be undefined.

enumerable

A boolean value indicating if the property can be enumerated by a for...in loop. See also Enumerability and ownership of properties for how enumerability interacts with other functions and syntaxes.

configurable

A boolean value indicating if the property can be deleted, can be changed to a data property, and can have its attributes changed.


The prototype of an object points to another object or to null — it's conceptually a hidden property of the object, commonly represented as [[Prototype]]. Properties of the object's [[Prototype]] can also be accessed on the object itself.
Objects are ad-hoc key-value pairs, so they are often used as maps. However, there can be ergonomics, security, and performance issues. Use a Map for storing arbitrary data instead. The Map reference contains a more detailed discussion of the pros & cons between plain objects and maps for storing key-value associations.DatesJavaScript provides two sets of APIs for representing dates: the legacy Date object and the modern Temporal object. Date has many undesirable design choices and should be avoided in new code if possible.Indexed collections: Arrays and typed ArraysArrays are regular objects for which there is a particular relationship between integer-keyed properties and the length property.
Additionally, arrays inherit from Array.prototype, which provides a handful of convenient methods to manipulate arrays. For example, indexOf() searches a value in the array and push() appends an element to the array. This makes Arrays a perfect candidate to represent ordered lists.
Typed Arrays present an array-like view of an underlying binary data buffer, and offer many methods that have similar semantics to the array counterparts. "Typed array" is an umbrella term for a range of data structures, including Int8Array, Float32Array, etc. Check the typed array page for more information. Typed arrays are often used in conjunction with ArrayBuffer and DataView.Keyed collections: Maps, Sets, WeakMaps, WeakSetsThese data structures take object references as keys. Set and WeakSet represent a collection of unique values, while Map and WeakMap represent a collection of key-value associations.
You could implement Maps and Sets yourself. However, since objects cannot be compared (in the sense of < "less than", for instance), neither does the engine expose its hash function for objects, look-up performance would necessarily be linear. Native implementations of them (including WeakMaps) can have look-up performance that is approximately logarithmic to constant time.
Usually, to bind data to a DOM node, one could set properties directly on the object, or use data-* attributes. This has the downside that the data is available to any script running in the same context. Maps and WeakMaps make it easy to privately bind data to an object.
WeakMap and WeakSet only allow garbage-collectable values as keys, which are either objects or non-registered symbols, and the keys may be collected even when they remain in the collection. They are specifically used for memory usage optimization.Structured data: JSONJSON (JavaScript Object Notation) is a lightweight data-interchange format, derived from JavaScript, but used by many programming languages. JSON builds universal data structures that can be transferred between different environments and even across languages. See JSON for more details.More objects in the standard libraryJavaScript has a standard library of built-in objects. Read the reference to find out more about the built-in objects.Type coercionAs mentioned above, JavaScript is a weakly typed language. This means that you can often use a value of one type where another type is expected, and the language will convert it to the right type for you. To do so, JavaScript defines a handful of coercion rules.Primitive coercionThe primitive coercion process is used where a primitive value is expected, but there's no strong preference for what the actual type should be. This is usually when a string, a number, or a BigInt are equally acceptable. For example:

The Date() constructor, when it receives one argument that's not a Date instance — strings represent date strings, while numbers represent timestamps.
The + operator — if one operand is a string, string concatenation is performed; otherwise, numeric addition is performed.
The == operator — if one operand is a primitive while the other is an object, the object is converted to a primitive value with no preferred type.

This operation does not do any conversion if the value is already a primitive. Objects are converted to primitives by calling its [Symbol.toPrimitive]() (with "default" as hint), valueOf(), and toString() methods, in that order. Note that primitive conversion calls valueOf() before toString(), which is similar to the behavior of number coercion but different from string coercion.
The [Symbol.toPrimitive]() method, if present, must return a primitive — returning an object results in a TypeError. For valueOf() and toString(), if one returns an object, the return value is ignored and the other's return value is used instead; if neither is present, or neither returns a primitive, a TypeError is thrown. For example, in the following code:
jsconsole.log({} + []); // "[object Object]"

Neither {} nor [] have a [Symbol.toPrimitive]() method. Both {} and [] inherit valueOf() from Object.prototype.valueOf, which returns the object itself. Since the return value is an object, it is ignored. Therefore, toString() is called instead. {}.toString() returns "[object Object]", while [].toString() returns "", so the result is their concatenation: "[object Object]".
The [Symbol.toPrimitive]() method always takes precedence when doing conversion to any primitive type. Primitive conversion generally behaves like number conversion, because valueOf() is called in priority; however, objects with custom [Symbol.toPrimitive]() methods can choose to return any primitive. Date and Symbol objects are the only built-in objects that override the [Symbol.toPrimitive]() method. Date.prototype[Symbol.toPrimitive]() treats the "default" hint as if it's "string", while Symbol.prototype[Symbol.toPrimitive]() ignores the hint and always returns a symbol.Numeric coercionThere are two numeric types: Number and BigInt. Sometimes the language specifically expects a number or a BigInt (such as Array.prototype.slice(), where the index must be a number); other times, it may tolerate either and perform different operations depending on the operand's type. For strict coercion processes that do not allow implicit conversion from the other type, see number coercion and BigInt coercion.
Numeric coercion is nearly the same as number coercion, except that BigInts are returned as-is instead of causing a TypeError. Numeric coercion is used by all arithmetic operators, since they are overloaded for both numbers and BigInts. The only exception is unary plus, which always does number coercion.Other coercionsAll data types, except Null, Undefined, and Symbol, have their respective coercion process. See string coercion, boolean coercion, and object coercion for more details.
As you may have noticed, there are three distinct paths through which objects may be converted to primitives:

Primitive coercion: [Symbol.toPrimitive]("default") → valueOf() → toString()
Numeric coercion, number coercion, BigInt coercion: [Symbol.toPrimitive]("number") → valueOf() → toString()
String coercion: [Symbol.toPrimitive]("string") → toString() → valueOf()

In all cases, [Symbol.toPrimitive](), if present, must be callable and return a primitive, while valueOf or toString will be ignored if they are not callable or return an object. At the end of the process, if successful, the result is guaranteed to be a primitive. The resulting primitive is then subject to further coercions depending on the context.See also
JavaScript Data Structures and Algorithms by Oleksii Trekhleb
Computer Science in JavaScript by Nicholas C. Zakas\n\nJavaScript data types and data structuresProgramming languages all have built-in data structures, but these often differ from one language to another. This article attempts to list the built-in data structures available in JavaScript and what properties they have. These can be used to build other data structures.
The language overview offers a similar summary of the common data types, but with more comparisons to other languages.Dynamic and weak typingJavaScript is a dynamic language with dynamic types. Variables in JavaScript are not directly associated with any particular value type, and any variable can be assigned (and re-assigned) values of all types:
jslet foo = 42; // foo is now a number
foo = "bar"; // foo is now a string
foo = true; // foo is now a boolean

JavaScript is also a weakly typed language, which means it allows implicit type conversion when an operation involves mismatched types, instead of throwing type errors.
jsconst foo = 42; // foo is a number
const result = foo + "1"; // JavaScript coerces foo to a string, so it can be concatenated with the other operand
console.log(result); // 421

Implicit coercions are very convenient, but can create subtle bugs when conversions happen where they are not expected, or where they are expected to happen in the other direction (for example, string to number instead of number to string). For symbols and BigInts, JavaScript has intentionally disallowed certain implicit type conversions.Primitive valuesAll types except Object define immutable values represented directly at the lowest level of the language. We refer to values of these types as primitive values.
All primitive types, except null, can be tested by the typeof operator. typeof null returns "object", so one has to use === null to test for null.
All primitive types, except null and undefined, have their corresponding object wrapper types, which provide useful methods for working with the primitive values. For example, the Number object provides methods like toExponential(). When a property is accessed on a primitive value, JavaScript automatically wraps the value into the corresponding wrapper object and accesses the property on the object instead. However, accessing a property on null or undefined throws a TypeError exception, which necessitates the introduction of the optional chaining operator.



Type
typeof return value
Object wrapper




Null
"object"
N/A


Undefined
"undefined"
N/A


Boolean
"boolean"
Boolean


Number
"number"
Number


BigInt
"bigint"
BigInt


String
"string"
String


Symbol
"symbol"
Symbol



The object wrapper classes' reference pages contain more information about the methods and properties available for each type, as well as detailed descriptions for the semantics of the primitive types themselves.Null typeThe Null type is inhabited by exactly one value: null.Undefined typeThe Undefined type is inhabited by exactly one value: undefined.
Conceptually, undefined indicates the absence of a value, while null indicates the absence of an object (which could also make up an excuse for typeof null === "object"). The language usually defaults to undefined when something is devoid of a value:

A return statement with no value (return;) implicitly returns undefined.
Accessing a nonexistent object property (obj.iDontExist) returns undefined.
A variable declaration without initialization (let x;) implicitly initializes the variable to undefined.
Many methods, such as Array.prototype.find() and Map.prototype.get(), return undefined when no element is found.

null is used much less often in the core language. The most important place is the end of the prototype chain — subsequently, methods that interact with prototypes, such as Object.getPrototypeOf(), Object.create(), etc., accept or return null instead of undefined.
null is a keyword, but undefined is a normal identifier that happens to be a global property. In practice, the difference is minor, since undefined should not be redefined or shadowed.Boolean typeThe Boolean type represents a logical entity and is inhabited by two values: true and false.
Boolean values are usually used for conditional operations, including ternary operators, if...else, while, etc.Number typeThe Number type is a double-precision 64-bit binary format IEEE 754 value. It is capable of storing positive floating-point numbers between 2-1074 (Number.MIN_VALUE) and 21023 × (2 - 2-52) (Number.MAX_VALUE) as well as negative floating-point numbers of the same magnitude, but it can only safely store integers in the range -(253 − 1) (Number.MIN_SAFE_INTEGER) to 253 − 1 (Number.MAX_SAFE_INTEGER). Outside this range, JavaScript can no longer safely represent integers; they will instead be represented by a double-precision floating point approximation. You can check if a number is within the range of safe integers using Number.isSafeInteger().
Values outside the representable range are automatically converted:

Positive values greater than Number.MAX_VALUE are converted to +Infinity.
Positive values smaller than Number.MIN_VALUE are converted to +0.
Negative values smaller than -Number.MAX_VALUE are converted to -Infinity.
Negative values greater than -Number.MIN_VALUE are converted to -0.

+Infinity and -Infinity behave similarly to mathematical infinity, but with some slight differences; see Number.POSITIVE_INFINITY and Number.NEGATIVE_INFINITY for details.
The Number type has only one value with multiple representations: 0 is represented as both -0 and +0 (where 0 is an alias for +0). In practice, there is almost no difference between the different representations; for example, +0 === -0 is true. However, you are able to notice this when you divide by zero:
jsconsole.log(42 / +0); // Infinity
console.log(42 / -0); // -Infinity

NaN ("Not a Number") is a special kind of number value that's typically encountered when the result of an arithmetic operation cannot be expressed as a number. It is also the only value in JavaScript that is not equal to itself.
Although a number is conceptually a "mathematical value" and is always implicitly floating-point-encoded, JavaScript provides bitwise operators. When applying bitwise operators, the number is first converted to a 32-bit integer.

Note:
Although bitwise operators can be used to represent several Boolean values within a single number using bit masking, this is usually considered a bad practice. JavaScript offers other means to represent a set of Booleans (like an array of Booleans, or an object with Boolean values assigned to named properties). Bit masking also tends to make the code more difficult to read, understand, and maintain.

It may be necessary to use such techniques in very constrained environments, like when trying to cope with the limitations of local storage, or in extreme cases (such as when each bit over the network counts). This technique should only be considered when it is the last measure that can be taken to optimize size.BigInt typeThe BigInt type is a numeric primitive in JavaScript that can represent integers with arbitrary magnitude. With BigInts, you can safely store and operate on large integers even beyond the safe integer limit (Number.MAX_SAFE_INTEGER) for Numbers.
A BigInt is created by appending n to the end of an integer or by calling the BigInt() function.
This example demonstrates where incrementing the Number.MAX_SAFE_INTEGER returns the expected result:
js// BigInt
const x = BigInt(Number.MAX_SAFE_INTEGER); // 9007199254740991n
x + 1n === x + 2n; // false because 9007199254740992n and 9007199254740993n are unequal

// Number
Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2; // true because both are 9007199254740992

You can use most operators to work with BigInts, including +, *, -, **, and % — the only forbidden one is >>>. A BigInt is not strictly equal to a Number with the same mathematical value, but it is loosely so.
BigInt values are neither always more precise nor always less precise than numbers, since BigInts cannot represent fractional numbers, but can represent big integers more accurately. Neither type entails the other, and they are not mutually substitutable. A TypeError is thrown if BigInt values are mixed with regular numbers in arithmetic expressions, or if they are implicitly converted to each other.String typeThe String type represents textual data and is encoded as a sequence of 16-bit unsigned integer values representing UTF-16 code units. Each element in the string occupies a position in the string. The first element is at index 0, the next at index 1, and so on. The length of a string is the number of UTF-16 code units in it, which may not correspond to the actual number of Unicode characters; see the String reference page for more details.
JavaScript strings are immutable. This means that once a string is created, it is not possible to modify it. String methods create new strings based on the content of the current string — for example:

A substring of the original using substring().
A concatenation of two strings using the concatenation operator (+) or concat().

Beware of "stringly-typing" your code!
It can be tempting to use strings to represent complex data. Doing this comes with short-term benefits:

It is easy to build complex strings with concatenation.
Strings are easy to debug (what you see printed is always what is in the string).
Strings are the common denominator of a lot of APIs (input fields, local storage values, fetch() responses when using Response.text(), etc.) and it can be tempting to only work with strings.

With conventions, it is possible to represent any data structure in a string. This does not make it a good idea. For instance, with a separator, one could emulate a list (while a JavaScript array would be more suitable). Unfortunately, when the separator is used in one of the "list" elements, then, the list is broken. An escape character can be chosen, etc. All of this requires conventions and creates an unnecessary maintenance burden.
Use strings for textual data. When representing complex data, parse strings, and use the appropriate abstraction.Symbol typeA Symbol is a unique and immutable primitive value and may be used as the key of an Object property (see below). In some programming languages, Symbols are called "atoms". The purpose of symbols is to create unique property keys that are guaranteed not to clash with keys from other code.ObjectsIn computer science, an object is a value in memory which is possibly referenced by an identifier. In JavaScript, objects are the only mutable values. Functions are, in fact, also objects with the additional capability of being callable.PropertiesIn JavaScript, objects can be seen as a collection of properties. With the object literal syntax, a limited set of properties are initialized; then properties can be added and removed. Object properties are equivalent to key-value pairs. Property keys are either strings or symbols. When other types (such as numbers) are used to index objects, the values are implicitly converted to strings. Property values can be values of any type, including other objects, which enables building complex data structures.
There are two types of object properties: The data property and the accessor property. Each property has corresponding attributes. Each attribute is accessed internally by the JavaScript engine, but you can set them through Object.defineProperty(), or read them through Object.getOwnPropertyDescriptor(). You can read more about the various nuances on the Object.defineProperty() page.
Data property
Data properties associate a key with a value. It can be described by the following attributes:

value

The value retrieved by a get access of the property. Can be any JavaScript value.

writable

A boolean value indicating if the property can be changed with an assignment.

enumerable

A boolean value indicating if the property can be enumerated by a for...in loop. See also Enumerability and ownership of properties for how enumerability interacts with other functions and syntaxes.

configurable

A boolean value indicating if the property can be deleted, can be changed to an accessor property, and can have its attributes changed.


Accessor property
Associates a key with one of two accessor functions (get and set) to retrieve or store a value.

Note:
It's important to recognize it's accessor property — not accessor method. We can give a JavaScript object class-like accessors by using a function as a value — but that doesn't make the object a class.

An accessor property has the following attributes:

get

A function called with an empty argument list to retrieve the property value whenever a get access to the value is performed. See also getters. May be undefined.

set

A function called with an argument that contains the assigned value. Executed whenever a specified property is attempted to be changed. See also setters. May be undefined.

enumerable

A boolean value indicating if the property can be enumerated by a for...in loop. See also Enumerability and ownership of properties for how enumerability interacts with other functions and syntaxes.

configurable

A boolean value indicating if the property can be deleted, can be changed to a data property, and can have its attributes changed.


The prototype of an object points to another object or to null — it's conceptually a hidden property of the object, commonly represented as [[Prototype]]. Properties of the object's [[Prototype]] can also be accessed on the object itself.
Objects are ad-hoc key-value pairs, so they are often used as maps. However, there can be ergonomics, security, and performance issues. Use a Map for storing arbitrary data instead. The Map reference contains a more detailed discussion of the pros & cons between plain objects and maps for storing key-value associations.DatesJavaScript provides two sets of APIs for representing dates: the legacy Date object and the modern Temporal object. Date has many undesirable design choices and should be avoided in new code if possible.Indexed collections: Arrays and typed ArraysArrays are regular objects for which there is a particular relationship between integer-keyed properties and the length property.
Additionally, arrays inherit from Array.prototype, which provides a handful of convenient methods to manipulate arrays. For example, indexOf() searches a value in the array and push() appends an element to the array. This makes Arrays a perfect candidate to represent ordered lists.
Typed Arrays present an array-like view of an underlying binary data buffer, and offer many methods that have similar semantics to the array counterparts. "Typed array" is an umbrella term for a range of data structures, including Int8Array, Float32Array, etc. Check the typed array page for more information. Typed arrays are often used in conjunction with ArrayBuffer and DataView.Keyed collections: Maps, Sets, WeakMaps, WeakSetsThese data structures take object references as keys. Set and WeakSet represent a collection of unique values, while Map and WeakMap represent a collection of key-value associations.
You could implement Maps and Sets yourself. However, since objects cannot be compared (in the sense of < "less than", for instance), neither does the engine expose its hash function for objects, look-up performance would necessarily be linear. Native implementations of them (including WeakMaps) can have look-up performance that is approximately logarithmic to constant time.
Usually, to bind data to a DOM node, one could set properties directly on the object, or use data-* attributes. This has the downside that the data is available to any script running in the same context. Maps and WeakMaps make it easy to privately bind data to an object.
WeakMap and WeakSet only allow garbage-collectable values as keys, which are either objects or non-registered symbols, and the keys may be collected even when they remain in the collection. They are specifically used for memory usage optimization.Structured data: JSONJSON (JavaScript Object Notation) is a lightweight data-interchange format, derived from JavaScript, but used by many programming languages. JSON builds universal data structures that can be transferred between different environments and even across languages. See JSON for more details.More objects in the standard libraryJavaScript has a standard library of built-in objects. Read the reference to find out more about the built-in objects.Type coercionAs mentioned above, JavaScript is a weakly typed language. This means that you can often use a value of one type where another type is expected, and the language will convert it to the right type for you. To do so, JavaScript defines a handful of coercion rules.Primitive coercionThe primitive coercion process is used where a primitive value is expected, but there's no strong preference for what the actual type should be. This is usually when a string, a number, or a BigInt are equally acceptable. For example:

The Date() constructor, when it receives one argument that's not a Date instance — strings represent date strings, while numbers represent timestamps.
The + operator — if one operand is a string, string concatenation is performed; otherwise, numeric addition is performed.
The == operator — if one operand is a primitive while the other is an object, the object is converted to a primitive value with no preferred type.

This operation does not do any conversion if the value is already a primitive. Objects are converted to primitives by calling its [Symbol.toPrimitive]() (with "default" as hint), valueOf(), and toString() methods, in that order. Note that primitive conversion calls valueOf() before toString(), which is similar to the behavior of number coercion but different from string coercion.
The [Symbol.toPrimitive]() method, if present, must return a primitive — returning an object results in a TypeError. For valueOf() and toString(), if one returns an object, the return value is ignored and the other's return value is used instead; if neither is present, or neither returns a primitive, a TypeError is thrown. For example, in the following code:
jsconsole.log({} + []); // "[object Object]"

Neither {} nor [] have a [Symbol.toPrimitive]() method. Both {} and [] inherit valueOf() from Object.prototype.valueOf, which returns the object itself. Since the return value is an object, it is ignored. Therefore, toString() is called instead. {}.toString() returns "[object Object]", while [].toString() returns "", so the result is their concatenation: "[object Object]".
The [Symbol.toPrimitive]() method always takes precedence when doing conversion to any primitive type. Primitive conversion generally behaves like number conversion, because valueOf() is called in priority; however, objects with custom [Symbol.toPrimitive]() methods can choose to return any primitive. Date and Symbol objects are the only built-in objects that override the [Symbol.toPrimitive]() method. Date.prototype[Symbol.toPrimitive]() treats the "default" hint as if it's "string", while Symbol.prototype[Symbol.toPrimitive]() ignores the hint and always returns a symbol.Numeric coercionThere are two numeric types: Number and BigInt. Sometimes the language specifically expects a number or a BigInt (such as Array.prototype.slice(), where the index must be a number); other times, it may tolerate either and perform different operations depending on the operand's type. For strict coercion processes that do not allow implicit conversion from the other type, see number coercion and BigInt coercion.
Numeric coercion is nearly the same as number coercion, except that BigInts are returned as-is instead of causing a TypeError. Numeric coercion is used by all arithmetic operators, since they are overloaded for both numbers and BigInts. The only exception is unary plus, which always does number coercion.Other coercionsAll data types, except Null, Undefined, and Symbol, have their respective coercion process. See string coercion, boolean coercion, and object coercion for more details.
As you may have noticed, there are three distinct paths through which objects may be converted to primitives:

Primitive coercion: [Symbol.toPrimitive]("default") → valueOf() → toString()
Numeric coercion, number coercion, BigInt coercion: [Symbol.toPrimitive]("number") → valueOf() → toString()
String coercion: [Symbol.toPrimitive]("string") → toString() → valueOf()

In all cases, [Symbol.toPrimitive](), if present, must be callable and return a primitive, while valueOf or toString will be ignored if they are not callable or return an object. At the end of the process, if successful, the result is guaranteed to be a primitive. The resulting primitive is then subject to further coercions depending on the context.See also
JavaScript Data Structures and Algorithms by Oleksii Trekhleb
Computer Science in JavaScript by Nicholas C. Zakas
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJavaScript data types and data structuresProgramming languages all have built-in data structures, but these often differ from one language to another. This article attempts to list the built-in data structures available in JavaScript and what properties they have. These can be used to build other data structures.
The language overview offers a similar summary of the common data types, but with more comparisons to other languages.Dynamic and weak typingJavaScript is a dynamic language with dynamic types. Variables in JavaScript are not directly associated with any particular value type, and any variable can be assigned (and re-assigned) values of all types:
jslet foo = 42; // foo is now a number
foo = "bar"; // foo is now a string
foo = true; // foo is now a boolean

JavaScript is also a weakly typed language, which means it allows implicit type conversion when an operation involves mismatched types, instead of throwing type errors.
jsconst foo = 42; // foo is a number
const result = foo + "1"; // JavaScript coerces foo to a string, so it can be concatenated with the other operand
console.log(result); // 421

Implicit coercions are very convenient, but can create subtle bugs when conversions happen where they are not expected, or where they are expected to happen in the other direction (for example, string to number instead of number to string). For symbols and BigInts, JavaScript has intentionally disallowed certain implicit type conversions.Primitive valuesAll types except Object define immutable values represented directly at the lowest level of the language. We refer to values of these types as primitive values.
All primitive types, except null, can be tested by the typeof operator. typeof null returns "object", so one has to use === null to test for null.
All primitive types, except null and undefined, have their corresponding object wrapper types, which provide useful methods for working with the primitive values. For example, the Number object provides methods like toExponential(). When a property is accessed on a primitive value, JavaScript automatically wraps the value into the corresponding wrapper object and accesses the property on the object instead. However, accessing a property on null or undefined throws a TypeError exception, which necessitates the introduction of the optional chaining operator.



Type
typeof return value
Object wrapper




Null
"object"
N/A


Undefined
"undefined"
N/A


Boolean
"boolean"
Boolean


Number
"number"
Number


BigInt
"bigint"
BigInt


String
"string"
String


Symbol
"symbol"
Symbol



The object wrapper classes' reference pages contain more information about the methods and properties available for each type, as well as detailed descriptions for the semantics of the primitive types themselves.Null typeThe Null type is inhabited by exactly one value: null.Undefined typeThe Undefined type is inhabited by exactly one value: undefined.
Conceptually, undefined indicates the absence of a value, while null indicates the absence of an object (which could also make up an excuse for typeof null === "object"). The language usually defaults to undefined when something is devoid of a value:

A return statement with no value (return;) implicitly returns undefined.
Accessing a nonexistent object property (obj.iDontExist) returns undefined.
A variable declaration without initialization (let x;) implicitly initializes the variable to undefined.
Many methods, such as Array.prototype.find() and Map.prototype.get(), return undefined when no element is found.

null is used much less often in the core language. The most important place is the end of the prototype chain — subsequently, methods that interact with prototypes, such as Object.getPrototypeOf(), Object.create(), etc., accept or return null instead of undefined.
null is a keyword, but undefined is a normal identifier that happens to be a global property. In practice, the difference is minor, since undefined should not be redefined or shadowed.Boolean typeThe Boolean type represents a logical entity and is inhabited by two values: true and false.
Boolean values are usually used for conditional operations, including ternary operators, if...else, while, etc.Number typeThe Number type is a double-precision 64-bit binary format IEEE 754 value. It is capable of storing positive floating-point numbers between 2-1074 (Number.MIN_VALUE) and 21023 × (2 - 2-52) (Number.MAX_VALUE) as well as negative floating-point numbers of the same magnitude, but it can only safely store integers in the range -(253 − 1) (Number.MIN_SAFE_INTEGER) to 253 − 1 (Number.MAX_SAFE_INTEGER). Outside this range, JavaScript can no longer safely represent integers; they will instead be represented by a double-precision floating point approximation. You can check if a number is within the range of safe integers using Number.isSafeInteger().
Values outside the representable range are automatically converted:

Positive values greater than Number.MAX_VALUE are converted to +Infinity.
Positive values smaller than Number.MIN_VALUE are converted to +0.
Negative values smaller than -Number.MAX_VALUE are converted to -Infinity.
Negative values greater than -Number.MIN_VALUE are converted to -0.

+Infinity and -Infinity behave similarly to mathematical infinity, but with some slight differences; see Number.POSITIVE_INFINITY and Number.NEGATIVE_INFINITY for details.
The Number type has only one value with multiple representations: 0 is represented as both -0 and +0 (where 0 is an alias for +0). In practice, there is almost no difference between the different representations; for example, +0 === -0 is true. However, you are able to notice this when you divide by zero:
jsconsole.log(42 / +0); // Infinity
console.log(42 / -0); // -Infinity

NaN ("Not a Number") is a special kind of number value that's typically encountered when the result of an arithmetic operation cannot be expressed as a number. It is also the only value in JavaScript that is not equal to itself.
Although a number is conceptually a "mathematical value" and is always implicitly floating-point-encoded, JavaScript provides bitwise operators. When applying bitwise operators, the number is first converted to a 32-bit integer.

Note:
Although bitwise operators can be used to represent several Boolean values within a single number using bit masking, this is usually considered a bad practice. JavaScript offers other means to represent a set of Booleans (like an array of Booleans, or an object with Boolean values assigned to named properties). Bit masking also tends to make the code more difficult to read, understand, and maintain.

It may be necessary to use such techniques in very constrained environments, like when trying to cope with the limitations of local storage, or in extreme cases (such as when each bit over the network counts). This technique should only be considered when it is the last measure that can be taken to optimize size.BigInt typeThe BigInt type is a numeric primitive in JavaScript that can represent integers with arbitrary magnitude. With BigInts, you can safely store and operate on large integers even beyond the safe integer limit (Number.MAX_SAFE_INTEGER) for Numbers.
A BigInt is created by appending n to the end of an integer or by calling the BigInt() function.
This example demonstrates where incrementing the Number.MAX_SAFE_INTEGER returns the expected result:
js// BigInt
const x = BigInt(Number.MAX_SAFE_INTEGER); // 9007199254740991n
x + 1n === x + 2n; // false because 9007199254740992n and 9007199254740993n are unequal

// Number
Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2; // true because both are 9007199254740992

You can use most operators to work with BigInts, including +, *, -, **, and % — the only forbidden one is >>>. A BigInt is not strictly equal to a Number with the same mathematical value, but it is loosely so.
BigInt values are neither always more precise nor always less precise than numbers, since BigInts cannot represent fractional numbers, but can represent big integers more accurately. Neither type entails the other, and they are not mutually substitutable. A TypeError is thrown if BigInt values are mixed with regular numbers in arithmetic expressions, or if they are implicitly converted to each other.String typeThe String type represents textual data and is encoded as a sequence of 16-bit unsigned integer values representing UTF-16 code units. Each element in the string occupies a position in the string. The first element is at index 0, the next at index 1, and so on. The length of a string is the number of UTF-16 code units in it, which may not correspond to the actual number of Unicode characters; see the String reference page for more details.
JavaScript strings are immutable. This means that once a string is created, it is not possible to modify it. String methods create new strings based on the content of the current string — for example:

A substring of the original using substring().
A concatenation of two strings using the concatenation operator (+) or concat().

Beware of "stringly-typing" your code!
It can be tempting to use strings to represent complex data. Doing this comes with short-term benefits:

It is easy to build complex strings with concatenation.
Strings are easy to debug (what you see printed is always what is in the string).
Strings are the common denominator of a lot of APIs (input fields, local storage values, fetch() responses when using Response.text(), etc.) and it can be tempting to only work with strings.

With conventions, it is possible to represent any data structure in a string. This does not make it a good idea. For instance, with a separator, one could emulate a list (while a JavaScript array would be more suitable). Unfortunately, when the separator is used in one of the "list" elements, then, the list is broken. An escape character can be chosen, etc. All of this requires conventions and creates an unnecessary maintenance burden.
Use strings for textual data. When representing complex data, parse strings, and use the appropriate abstraction.Symbol typeA Symbol is a unique and immutable primitive value and may be used as the key of an Object property (see below). In some programming languages, Symbols are called "atoms". The purpose of symbols is to create unique property keys that are guaranteed not to clash with keys from other code.ObjectsIn computer science, an object is a value in memory which is possibly referenced by an identifier. In JavaScript, objects are the only mutable values. Functions are, in fact, also objects with the additional capability of being callable.PropertiesIn JavaScript, objects can be seen as a collection of properties. With the object literal syntax, a limited set of properties are initialized; then properties can be added and removed. Object properties are equivalent to key-value pairs. Property keys are either strings or symbols. When other types (such as numbers) are used to index objects, the values are implicitly converted to strings. Property values can be values of any type, including other objects, which enables building complex data structures.
There are two types of object properties: The data property and the accessor property. Each property has corresponding attributes. Each attribute is accessed internally by the JavaScript engine, but you can set them through Object.defineProperty(), or read them through Object.getOwnPropertyDescriptor(). You can read more about the various nuances on the Object.defineProperty() page.
Data property
Data properties associate a key with a value. It can be described by the following attributes:

value

The value retrieved by a get access of the property. Can be any JavaScript value.

writable

A boolean value indicating if the property can be changed with an assignment.

enumerable

A boolean value indicating if the property can be enumerated by a for...in loop. See also Enumerability and ownership of properties for how enumerability interacts with other functions and syntaxes.

configurable

A boolean value indicating if the property can be deleted, can be changed to an accessor property, and can have its attributes changed.


Accessor property
Associates a key with one of two accessor functions (get and set) to retrieve or store a value.

Note:
It's important to recognize it's accessor property — not accessor method. We can give a JavaScript object class-like accessors by using a function as a value — but that doesn't make the object a class.

An accessor property has the following attributes:

get

A function called with an empty argument list to retrieve the property value whenever a get access to the value is performed. See also getters. May be undefined.

set

A function called with an argument that contains the assigned value. Executed whenever a specified property is attempted to be changed. See also setters. May be undefined.

enumerable

A boolean value indicating if the property can be enumerated by a for...in loop. See also Enumerability and ownership of properties for how enumerability interacts with other functions and syntaxes.

configurable

A boolean value indicating if the property can be deleted, can be changed to a data property, and can have its attributes changed.


The prototype of an object points to another object or to null — it's conceptually a hidden property of the object, commonly represented as [[Prototype]]. Properties of the object's [[Prototype]] can also be accessed on the object itself.
Objects are ad-hoc key-value pairs, so they are often used as maps. However, there can be ergonomics, security, and performance issues. Use a Map for storing arbitrary data instead. The Map reference contains a more detailed discussion of the pros & cons between plain objects and maps for storing key-value associations.DatesJavaScript provides two sets of APIs for representing dates: the legacy Date object and the modern Temporal object. Date has many undesirable design choices and should be avoided in new code if possible.Indexed collections: Arrays and typed ArraysArrays are regular objects for which there is a particular relationship between integer-keyed properties and the length property.
Additionally, arrays inherit from Array.prototype, which provides a handful of convenient methods to manipulate arrays. For example, indexOf() searches a value in the array and push() appends an element to the array. This makes Arrays a perfect candidate to represent ordered lists.
Typed Arrays present an array-like view of an underlying binary data buffer, and offer many methods that have similar semantics to the array counterparts. "Typed array" is an umbrella term for a range of data structures, including Int8Array, Float32Array, etc. Check the typed array page for more information. Typed arrays are often used in conjunction with ArrayBuffer and DataView.Keyed collections: Maps, Sets, WeakMaps, WeakSetsThese data structures take object references as keys. Set and WeakSet represent a collection of unique values, while Map and WeakMap represent a collection of key-value associations.
You could implement Maps and Sets yourself. However, since objects cannot be compared (in the sense of < "less than", for instance), neither does the engine expose its hash function for objects, look-up performance would necessarily be linear. Native implementations of them (including WeakMaps) can have look-up performance that is approximately logarithmic to constant time.
Usually, to bind data to a DOM node, one could set properties directly on the object, or use data-* attributes. This has the downside that the data is available to any script running in the same context. Maps and WeakMaps make it easy to privately bind data to an object.
WeakMap and WeakSet only allow garbage-collectable values as keys, which are either objects or non-registered symbols, and the keys may be collected even when they remain in the collection. They are specifically used for memory usage optimization.Structured data: JSONJSON (JavaScript Object Notation) is a lightweight data-interchange format, derived from JavaScript, but used by many programming languages. JSON builds universal data structures that can be transferred between different environments and even across languages. See JSON for more details.More objects in the standard libraryJavaScript has a standard library of built-in objects. Read the reference to find out more about the built-in objects.Type coercionAs mentioned above, JavaScript is a weakly typed language. This means that you can often use a value of one type where another type is expected, and the language will convert it to the right type for you. To do so, JavaScript defines a handful of coercion rules.Primitive coercionThe primitive coercion process is used where a primitive value is expected, but there's no strong preference for what the actual type should be. This is usually when a string, a number, or a BigInt are equally acceptable. For example:

The Date() constructor, when it receives one argument that's not a Date instance — strings represent date strings, while numbers represent timestamps.
The + operator — if one operand is a string, string concatenation is performed; otherwise, numeric addition is performed.
The == operator — if one operand is a primitive while the other is an object, the object is converted to a primitive value with no preferred type.

This operation does not do any conversion if the value is already a primitive. Objects are converted to primitives by calling its [Symbol.toPrimitive]() (with "default" as hint), valueOf(), and toString() methods, in that order. Note that primitive conversion calls valueOf() before toString(), which is similar to the behavior of number coercion but different from string coercion.
The [Symbol.toPrimitive]() method, if present, must return a primitive — returning an object results in a TypeError. For valueOf() and toString(), if one returns an object, the return value is ignored and the other's return value is used instead; if neither is present, or neither returns a primitive, a TypeError is thrown. For example, in the following code:
jsconsole.log({} + []); // "[object Object]"

Neither {} nor [] have a [Symbol.toPrimitive]() method. Both {} and [] inherit valueOf() from Object.prototype.valueOf, which returns the object itself. Since the return value is an object, it is ignored. Therefore, toString() is called instead. {}.toString() returns "[object Object]", while [].toString() returns "", so the result is their concatenation: "[object Object]".
The [Symbol.toPrimitive]() method always takes precedence when doing conversion to any primitive type. Primitive conversion generally behaves like number conversion, because valueOf() is called in priority; however, objects with custom [Symbol.toPrimitive]() methods can choose to return any primitive. Date and Symbol objects are the only built-in objects that override the [Symbol.toPrimitive]() method. Date.prototype[Symbol.toPrimitive]() treats the "default" hint as if it's "string", while Symbol.prototype[Symbol.toPrimitive]() ignores the hint and always returns a symbol.Numeric coercionThere are two numeric types: Number and BigInt. Sometimes the language specifically expects a number or a BigInt (such as Array.prototype.slice(), where the index must be a number); other times, it may tolerate either and perform different operations depending on the operand's type. For strict coercion processes that do not allow implicit conversion from the other type, see number coercion and BigInt coercion.
Numeric coercion is nearly the same as number coercion, except that BigInts are returned as-is instead of causing a TypeError. Numeric coercion is used by all arithmetic operators, since they are overloaded for both numbers and BigInts. The only exception is unary plus, which always does number coercion.Other coercionsAll data types, except Null, Undefined, and Symbol, have their respective coercion process. See string coercion, boolean coercion, and object coercion for more details.
As you may have noticed, there are three distinct paths through which objects may be converted to primitives:

Primitive coercion: [Symbol.toPrimitive]("default") → valueOf() → toString()
Numeric coercion, number coercion, BigInt coercion: [Symbol.toPrimitive]("number") → valueOf() → toString()
String coercion: [Symbol.toPrimitive]("string") → toString() → valueOf()

In all cases, [Symbol.toPrimitive](), if present, must be callable and return a primitive, while valueOf or toString will be ignored if they are not callable or return an object. At the end of the process, if successful, the result is guaranteed to be a primitive. The resulting primitive is then subject to further coercions depending on the context.See also
JavaScript Data Structures and Algorithms by Oleksii Trekhleb
Computer Science in JavaScript by Nicholas C. Zakas
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nEquality comparisons and samenessJavaScript provides three different value-comparison operations:

=== — strict equality (triple equals)
== — loose equality (double equals)
Object.is()

Which operation you choose depends on what sort of comparison you are looking to perform. Briefly:

Double equals (==) will perform a type conversion when comparing two things, and will handle NaN, -0, and +0 specially to conform to IEEE 754 (so NaN != NaN, and -0 == +0);
Triple equals (===) will do the same comparison as double equals (including the special handling for NaN, -0, and +0) but without type conversion; if the types differ, false is returned.
Object.is() does no type conversion and no special handling for NaN, -0, and +0 (giving it the same behavior as === except on those special numeric values).

They correspond to three of four equality algorithms in JavaScript:

IsLooselyEqual: ==
IsStrictlyEqual: ===
SameValue: Object.is()
SameValueZero: used by many built-in operations

Note that the distinction between these all have to do with their handling of primitives; none of them compares whether the parameters are conceptually similar in structure. For any non-primitive objects x and y which have the same structure but are distinct objects themselves, all of the above forms will evaluate to false.Strict equality using ===Strict equality compares two values for equality. Neither value is implicitly converted to some other value before being compared. If the values have different types, the values are considered unequal. If the values have the same type, are not numbers, and have the same value, they're considered equal. Finally, if both values are numbers, they're considered equal if they're both not NaN and are the same value, or if one is +0 and one is -0.
jsconst num = 0;
const obj = new String("0");
const str = "0";

console.log(num === num); // true
console.log(obj === obj); // true
console.log(str === str); // true

console.log(num === obj); // false
console.log(num === str); // false
console.log(obj === str); // false
console.log(null === undefined); // false
console.log(obj === null); // false
console.log(obj === undefined); // false

Strict equality is almost always the correct comparison operation to use. For all values except numbers, it uses the obvious semantics: a value is only equal to itself. For numbers it uses slightly different semantics to gloss over two different edge cases. The first is that floating point zero is either positively or negatively signed. This is useful in representing certain mathematical solutions, but as most situations don't care about the difference between +0 and -0, strict equality treats them as the same value. The second is that floating point includes the concept of a not-a-number value, NaN, to represent the solution to certain ill-defined mathematical problems: negative infinity added to positive infinity, for example. Strict equality treats NaN as unequal to every other value — including itself. (The only case in which (x !== x) is true is when x is NaN.)
Besides ===, strict equality is also used by array index-finding methods including Array.prototype.indexOf(), Array.prototype.lastIndexOf(), TypedArray.prototype.indexOf(), TypedArray.prototype.lastIndexOf(), and case-matching. This means you cannot use indexOf(NaN) to find the index of a NaN value in an array, or use NaN as a case value in a switch statement and make it match anything.
jsconsole.log([NaN].indexOf(NaN)); // -1
switch (NaN) {
  case NaN:
    console.log("Surprise"); // Nothing is logged
}
Loose equality using ==Loose equality is symmetric: A == B always has identical semantics to B == A for any values of A and B (except for the order of applied conversions). The behavior for performing loose equality using == is as follows:

If the operands have the same type, they are compared as follows:

Object: return true only if both operands reference the same object.
String: return true only if both operands have the same characters in the same order.
Number: return true only if both operands have the same value. +0 and -0 are treated as the same value. If either operand is NaN, return false; so NaN is never equal to NaN.
Boolean: return true only if operands are both true or both false.
BigInt: return true only if both operands have the same value.
Symbol: return true only if both operands reference the same symbol.


If one of the operands is null or undefined, the other must also be null or undefined to return true. Otherwise return false.
If one of the operands is an object and the other is a primitive, convert the object to a primitive.
At this step, both operands are converted to primitives (one of String, Number, Boolean, Symbol, and BigInt). The rest of the conversion is done case-by-case.

If they are of the same type, compare them using step 1.
If one of the operands is a Symbol but the other is not, return false.
If one of the operands is a Boolean but the other is not, convert the boolean to a number: true is converted to 1, and false is converted to 0. Then compare the two operands loosely again.
Number to String: convert the string to a number. Conversion failure results in NaN, which will guarantee the equality to be false.
Number to BigInt: compare by their mathematical value. If the number is ±Infinity or NaN, return false.
String to BigInt: convert the string to a BigInt using the same algorithm as the BigInt() constructor. If conversion fails, return false.



Traditionally, and according to ECMAScript, all primitives and objects are loosely unequal to undefined and null. But most browsers permit a very narrow class of objects (specifically, the document.all object for any page), in some contexts, to act as if they emulate the value undefined. Loose equality is one such context: null == A and undefined == A evaluate to true if, and only if, A is an object that emulates undefined. In all other cases an object is never loosely equal to undefined or null.
In most cases, using loose equality is discouraged. The result of a comparison using strict equality is easier to predict, and may evaluate more quickly due to the lack of type coercion.
The following example demonstrates loose equality comparisons involving the number primitive 0, the bigint primitive 0n, the string primitive '0', and an object whose toString() value is '0'.
jsconst num = 0;
const big = 0n;
const str = "0";
const obj = new String("0");

console.log(num == str); // true
console.log(big == num); // true
console.log(str == big); // true

console.log(num == obj); // true
console.log(big == obj); // true
console.log(str == obj); // true

Loose equality is only used by the == operator.Same-value equality using Object.is()Same-value equality determines whether two values are functionally identical in all contexts. (This use case demonstrates an instance of the Liskov substitution principle.) One instance occurs when an attempt is made to mutate an immutable property:
js// Add an immutable NEGATIVE_ZERO property to the Number constructor.
Object.defineProperty(Number, "NEGATIVE_ZERO", {
  value: -0,
  writable: false,
  configurable: false,
  enumerable: false,
});

function attemptMutation(v) {
  Object.defineProperty(Number, "NEGATIVE_ZERO", { value: v });
}

Object.defineProperty will throw an exception when attempting to change an immutable property, but it does nothing if no actual change is requested. If v is -0, no change has been requested, and no error will be thrown. Internally, when an immutable property is redefined, the newly-specified value is compared against the current value using same-value equality.
Same-value equality is provided by the Object.is method. It's used almost everywhere in the language where a value of equivalent identity is expected.Same-value-zero equalitySimilar to same-value equality, but +0 and -0 are considered equal.
Same-value-zero equality is not exposed as a JavaScript API, but can be implemented with custom code:
jsfunction sameValueZero(x, y) {
  if (typeof x === "number" && typeof y === "number") {
    // x and y are equal (may be -0 and 0) or they are both NaN
    return x === y || (x !== x && y !== y);
  }
  return x === y;
}

Same-value-zero only differs from strict equality by treating NaN as equivalent, and only differs from same-value equality by treating -0 as equivalent to 0. This makes it usually have the most sensible behavior during searching, especially when working with NaN. It's used by Array.prototype.includes(), TypedArray.prototype.includes(), as well as Map and Set methods for comparing key equality.Comparing equality methodsPeople often compare double equals and triple equals by saying one is an "enhanced" version of the other. For example, double equals could be said as an extended version of triple equals, because the former does everything that the latter does, but with type conversion on its operands — for example, 6 == "6". Alternatively, it can be claimed that double equals is the baseline, and triple equals is an enhanced version, because it requires the two operands to be the same type, so it adds an extra constraint.
However, this way of thinking implies that the equality comparisons form a one-dimensional "spectrum" where "totally strict" lies on one end and "totally loose" lies on the other. This model falls short with Object.is, because it isn't "looser" than double equals or "stricter" than triple equals, nor does it fit somewhere in between (i.e., being both stricter than double equals, but looser than triple equals). We can see from the sameness comparisons table below that this is due to the way that Object.is handles NaN. Notice that if Object.is(NaN, NaN) evaluated to false, we could say that it fits on the loose/strict spectrum as an even stricter form of triple equals, one that distinguishes between -0 and +0. The NaN handling means this is untrue, however. Unfortunately, Object.is has to be thought of in terms of its specific characteristics, rather than its looseness or strictness with regard to the equality operators.



x
y
==
===
Object.is
SameValueZero




undefined
undefined
✅ true
✅ true
✅ true
✅ true


null
null
✅ true
✅ true
✅ true
✅ true


true
true
✅ true
✅ true
✅ true
✅ true


false
false
✅ true
✅ true
✅ true
✅ true


'foo'
'foo'
✅ true
✅ true
✅ true
✅ true


0
0
✅ true
✅ true
✅ true
✅ true


+0
-0
✅ true
✅ true
❌ false
✅ true


+0
0
✅ true
✅ true
✅ true
✅ true


-0
0
✅ true
✅ true
❌ false
✅ true


0n
-0n
✅ true
✅ true
✅ true
✅ true


0
false
✅ true
❌ false
❌ false
❌ false


""
false
✅ true
❌ false
❌ false
❌ false


""
0
✅ true
❌ false
❌ false
❌ false


'0'
0
✅ true
❌ false
❌ false
❌ false


'17'
17
✅ true
❌ false
❌ false
❌ false


[1, 2]
'1,2'
✅ true
❌ false
❌ false
❌ false


new String('foo')
'foo'
✅ true
❌ false
❌ false
❌ false


null
undefined
✅ true
❌ false
❌ false
❌ false


null
false
❌ false
❌ false
❌ false
❌ false


undefined
false
❌ false
❌ false
❌ false
❌ false


{ foo: 'bar' }
{ foo: 'bar' }
❌ false
❌ false
❌ false
❌ false


new String('foo')
new String('foo')
❌ false
❌ false
❌ false
❌ false


0
null
❌ false
❌ false
❌ false
❌ false


0
NaN
❌ false
❌ false
❌ false
❌ false


'foo'
NaN
❌ false
❌ false
❌ false
❌ false


NaN
NaN
❌ false
❌ false
✅ true
✅ true


When to use Object.is() versus triple equalsIn general, the only time Object.is's special behavior towards zeros is likely to be of interest is in the pursuit of certain meta-programming schemes, especially regarding property descriptors, when it is desirable for your work to mirror some of the characteristics of Object.defineProperty. If your use case does not require this, it is suggested to avoid Object.is and use === instead. Even if your requirements involve having comparisons between two NaN values evaluate to true, generally it is easier to special-case the NaN checks (using the isNaN method available from previous versions of ECMAScript) than it is to work out how surrounding computations might affect the sign of any zeros you encounter in your comparison.
Here's a non-exhaustive list of built-in methods and operators that might cause a distinction between -0 and +0 to manifest itself in your code:

- (unary negation)

Consider the following example:
jsconst stoppingForce = obj.mass * -obj.velocity;

If obj.velocity is 0 (or computes to 0), a -0 is introduced at that place and propagates out into stoppingForce.

Math.atan2, Math.ceil, Math.pow, Math.round

In some cases, it's possible for a -0 to be introduced into an expression as a return value of these methods even when no -0 exists as one of the parameters. For example, using Math.pow to raise -Infinity to the power of any negative, odd exponent evaluates to -0. Refer to the documentation for the individual methods.

Math.floor, Math.max, Math.min, Math.sin, Math.sqrt, Math.tan

It's possible to get a -0 return value out of these methods in some cases where a -0 exists as one of the parameters. E.g., Math.min(-0, +0) evaluates to -0. Refer to the documentation for the individual methods.

~, <<, >>

Each of these operators uses the ToInt32 algorithm internally. Since there is only one representation for 0 in the internal 32-bit integer type, -0 will not survive a round trip after an inverse operation. E.g., both Object.is(~~(-0), -0) and Object.is(-0 << 2 >> 2, -0) evaluate to false.


Relying on Object.is when the signedness of zeros is not taken into account can be hazardous. Of course, when the intent is to distinguish between -0 and +0, it does exactly what's desired.Caveat: Object.is() and NaNThe Object.is specification treats all instances of NaN as the same object. However, since typed arrays are available, we can have distinct floating point representations of NaN which don't behave identically in all contexts. For example:
jsconst f2b = (x) => new Uint8Array(new Float64Array([x]).buffer);
const b2f = (x) => new Float64Array(x.buffer)[0];
// Get a byte representation of NaN
const n = f2b(NaN);
// Change the first bit, which is the sign bit and doesn't matter for NaN
n[0] = 1;
const nan2 = b2f(n);
console.log(nan2); // NaN
console.log(Object.is(nan2, NaN)); // true
console.log(f2b(NaN)); // Uint8Array(8) [0, 0, 0, 0, 0, 0, 248, 127]
console.log(f2b(nan2)); // Uint8Array(8) [1, 0, 0, 0, 0, 0, 248, 127]
See also
JS Comparison Table by dorey\n\nEquality comparisons and samenessJavaScript provides three different value-comparison operations:

=== — strict equality (triple equals)
== — loose equality (double equals)
Object.is()

Which operation you choose depends on what sort of comparison you are looking to perform. Briefly:

Double equals (==) will perform a type conversion when comparing two things, and will handle NaN, -0, and +0 specially to conform to IEEE 754 (so NaN != NaN, and -0 == +0);
Triple equals (===) will do the same comparison as double equals (including the special handling for NaN, -0, and +0) but without type conversion; if the types differ, false is returned.
Object.is() does no type conversion and no special handling for NaN, -0, and +0 (giving it the same behavior as === except on those special numeric values).

They correspond to three of four equality algorithms in JavaScript:

IsLooselyEqual: ==
IsStrictlyEqual: ===
SameValue: Object.is()
SameValueZero: used by many built-in operations

Note that the distinction between these all have to do with their handling of primitives; none of them compares whether the parameters are conceptually similar in structure. For any non-primitive objects x and y which have the same structure but are distinct objects themselves, all of the above forms will evaluate to false.Strict equality using ===Strict equality compares two values for equality. Neither value is implicitly converted to some other value before being compared. If the values have different types, the values are considered unequal. If the values have the same type, are not numbers, and have the same value, they're considered equal. Finally, if both values are numbers, they're considered equal if they're both not NaN and are the same value, or if one is +0 and one is -0.
jsconst num = 0;
const obj = new String("0");
const str = "0";

console.log(num === num); // true
console.log(obj === obj); // true
console.log(str === str); // true

console.log(num === obj); // false
console.log(num === str); // false
console.log(obj === str); // false
console.log(null === undefined); // false
console.log(obj === null); // false
console.log(obj === undefined); // false

Strict equality is almost always the correct comparison operation to use. For all values except numbers, it uses the obvious semantics: a value is only equal to itself. For numbers it uses slightly different semantics to gloss over two different edge cases. The first is that floating point zero is either positively or negatively signed. This is useful in representing certain mathematical solutions, but as most situations don't care about the difference between +0 and -0, strict equality treats them as the same value. The second is that floating point includes the concept of a not-a-number value, NaN, to represent the solution to certain ill-defined mathematical problems: negative infinity added to positive infinity, for example. Strict equality treats NaN as unequal to every other value — including itself. (The only case in which (x !== x) is true is when x is NaN.)
Besides ===, strict equality is also used by array index-finding methods including Array.prototype.indexOf(), Array.prototype.lastIndexOf(), TypedArray.prototype.indexOf(), TypedArray.prototype.lastIndexOf(), and case-matching. This means you cannot use indexOf(NaN) to find the index of a NaN value in an array, or use NaN as a case value in a switch statement and make it match anything.
jsconsole.log([NaN].indexOf(NaN)); // -1
switch (NaN) {
  case NaN:
    console.log("Surprise"); // Nothing is logged
}
Loose equality using ==Loose equality is symmetric: A == B always has identical semantics to B == A for any values of A and B (except for the order of applied conversions). The behavior for performing loose equality using == is as follows:

If the operands have the same type, they are compared as follows:

Object: return true only if both operands reference the same object.
String: return true only if both operands have the same characters in the same order.
Number: return true only if both operands have the same value. +0 and -0 are treated as the same value. If either operand is NaN, return false; so NaN is never equal to NaN.
Boolean: return true only if operands are both true or both false.
BigInt: return true only if both operands have the same value.
Symbol: return true only if both operands reference the same symbol.


If one of the operands is null or undefined, the other must also be null or undefined to return true. Otherwise return false.
If one of the operands is an object and the other is a primitive, convert the object to a primitive.
At this step, both operands are converted to primitives (one of String, Number, Boolean, Symbol, and BigInt). The rest of the conversion is done case-by-case.

If they are of the same type, compare them using step 1.
If one of the operands is a Symbol but the other is not, return false.
If one of the operands is a Boolean but the other is not, convert the boolean to a number: true is converted to 1, and false is converted to 0. Then compare the two operands loosely again.
Number to String: convert the string to a number. Conversion failure results in NaN, which will guarantee the equality to be false.
Number to BigInt: compare by their mathematical value. If the number is ±Infinity or NaN, return false.
String to BigInt: convert the string to a BigInt using the same algorithm as the BigInt() constructor. If conversion fails, return false.



Traditionally, and according to ECMAScript, all primitives and objects are loosely unequal to undefined and null. But most browsers permit a very narrow class of objects (specifically, the document.all object for any page), in some contexts, to act as if they emulate the value undefined. Loose equality is one such context: null == A and undefined == A evaluate to true if, and only if, A is an object that emulates undefined. In all other cases an object is never loosely equal to undefined or null.
In most cases, using loose equality is discouraged. The result of a comparison using strict equality is easier to predict, and may evaluate more quickly due to the lack of type coercion.
The following example demonstrates loose equality comparisons involving the number primitive 0, the bigint primitive 0n, the string primitive '0', and an object whose toString() value is '0'.
jsconst num = 0;
const big = 0n;
const str = "0";
const obj = new String("0");

console.log(num == str); // true
console.log(big == num); // true
console.log(str == big); // true

console.log(num == obj); // true
console.log(big == obj); // true
console.log(str == obj); // true

Loose equality is only used by the == operator.Same-value equality using Object.is()Same-value equality determines whether two values are functionally identical in all contexts. (This use case demonstrates an instance of the Liskov substitution principle.) One instance occurs when an attempt is made to mutate an immutable property:
js// Add an immutable NEGATIVE_ZERO property to the Number constructor.
Object.defineProperty(Number, "NEGATIVE_ZERO", {
  value: -0,
  writable: false,
  configurable: false,
  enumerable: false,
});

function attemptMutation(v) {
  Object.defineProperty(Number, "NEGATIVE_ZERO", { value: v });
}

Object.defineProperty will throw an exception when attempting to change an immutable property, but it does nothing if no actual change is requested. If v is -0, no change has been requested, and no error will be thrown. Internally, when an immutable property is redefined, the newly-specified value is compared against the current value using same-value equality.
Same-value equality is provided by the Object.is method. It's used almost everywhere in the language where a value of equivalent identity is expected.Same-value-zero equalitySimilar to same-value equality, but +0 and -0 are considered equal.
Same-value-zero equality is not exposed as a JavaScript API, but can be implemented with custom code:
jsfunction sameValueZero(x, y) {
  if (typeof x === "number" && typeof y === "number") {
    // x and y are equal (may be -0 and 0) or they are both NaN
    return x === y || (x !== x && y !== y);
  }
  return x === y;
}

Same-value-zero only differs from strict equality by treating NaN as equivalent, and only differs from same-value equality by treating -0 as equivalent to 0. This makes it usually have the most sensible behavior during searching, especially when working with NaN. It's used by Array.prototype.includes(), TypedArray.prototype.includes(), as well as Map and Set methods for comparing key equality.Comparing equality methodsPeople often compare double equals and triple equals by saying one is an "enhanced" version of the other. For example, double equals could be said as an extended version of triple equals, because the former does everything that the latter does, but with type conversion on its operands — for example, 6 == "6". Alternatively, it can be claimed that double equals is the baseline, and triple equals is an enhanced version, because it requires the two operands to be the same type, so it adds an extra constraint.
However, this way of thinking implies that the equality comparisons form a one-dimensional "spectrum" where "totally strict" lies on one end and "totally loose" lies on the other. This model falls short with Object.is, because it isn't "looser" than double equals or "stricter" than triple equals, nor does it fit somewhere in between (i.e., being both stricter than double equals, but looser than triple equals). We can see from the sameness comparisons table below that this is due to the way that Object.is handles NaN. Notice that if Object.is(NaN, NaN) evaluated to false, we could say that it fits on the loose/strict spectrum as an even stricter form of triple equals, one that distinguishes between -0 and +0. The NaN handling means this is untrue, however. Unfortunately, Object.is has to be thought of in terms of its specific characteristics, rather than its looseness or strictness with regard to the equality operators.



x
y
==
===
Object.is
SameValueZero




undefined
undefined
✅ true
✅ true
✅ true
✅ true


null
null
✅ true
✅ true
✅ true
✅ true


true
true
✅ true
✅ true
✅ true
✅ true


false
false
✅ true
✅ true
✅ true
✅ true


'foo'
'foo'
✅ true
✅ true
✅ true
✅ true


0
0
✅ true
✅ true
✅ true
✅ true


+0
-0
✅ true
✅ true
❌ false
✅ true


+0
0
✅ true
✅ true
✅ true
✅ true


-0
0
✅ true
✅ true
❌ false
✅ true


0n
-0n
✅ true
✅ true
✅ true
✅ true


0
false
✅ true
❌ false
❌ false
❌ false


""
false
✅ true
❌ false
❌ false
❌ false


""
0
✅ true
❌ false
❌ false
❌ false


'0'
0
✅ true
❌ false
❌ false
❌ false


'17'
17
✅ true
❌ false
❌ false
❌ false


[1, 2]
'1,2'
✅ true
❌ false
❌ false
❌ false


new String('foo')
'foo'
✅ true
❌ false
❌ false
❌ false


null
undefined
✅ true
❌ false
❌ false
❌ false


null
false
❌ false
❌ false
❌ false
❌ false


undefined
false
❌ false
❌ false
❌ false
❌ false


{ foo: 'bar' }
{ foo: 'bar' }
❌ false
❌ false
❌ false
❌ false


new String('foo')
new String('foo')
❌ false
❌ false
❌ false
❌ false


0
null
❌ false
❌ false
❌ false
❌ false


0
NaN
❌ false
❌ false
❌ false
❌ false


'foo'
NaN
❌ false
❌ false
❌ false
❌ false


NaN
NaN
❌ false
❌ false
✅ true
✅ true


When to use Object.is() versus triple equalsIn general, the only time Object.is's special behavior towards zeros is likely to be of interest is in the pursuit of certain meta-programming schemes, especially regarding property descriptors, when it is desirable for your work to mirror some of the characteristics of Object.defineProperty. If your use case does not require this, it is suggested to avoid Object.is and use === instead. Even if your requirements involve having comparisons between two NaN values evaluate to true, generally it is easier to special-case the NaN checks (using the isNaN method available from previous versions of ECMAScript) than it is to work out how surrounding computations might affect the sign of any zeros you encounter in your comparison.
Here's a non-exhaustive list of built-in methods and operators that might cause a distinction between -0 and +0 to manifest itself in your code:

- (unary negation)

Consider the following example:
jsconst stoppingForce = obj.mass * -obj.velocity;

If obj.velocity is 0 (or computes to 0), a -0 is introduced at that place and propagates out into stoppingForce.

Math.atan2, Math.ceil, Math.pow, Math.round

In some cases, it's possible for a -0 to be introduced into an expression as a return value of these methods even when no -0 exists as one of the parameters. For example, using Math.pow to raise -Infinity to the power of any negative, odd exponent evaluates to -0. Refer to the documentation for the individual methods.

Math.floor, Math.max, Math.min, Math.sin, Math.sqrt, Math.tan

It's possible to get a -0 return value out of these methods in some cases where a -0 exists as one of the parameters. E.g., Math.min(-0, +0) evaluates to -0. Refer to the documentation for the individual methods.

~, <<, >>

Each of these operators uses the ToInt32 algorithm internally. Since there is only one representation for 0 in the internal 32-bit integer type, -0 will not survive a round trip after an inverse operation. E.g., both Object.is(~~(-0), -0) and Object.is(-0 << 2 >> 2, -0) evaluate to false.


Relying on Object.is when the signedness of zeros is not taken into account can be hazardous. Of course, when the intent is to distinguish between -0 and +0, it does exactly what's desired.Caveat: Object.is() and NaNThe Object.is specification treats all instances of NaN as the same object. However, since typed arrays are available, we can have distinct floating point representations of NaN which don't behave identically in all contexts. For example:
jsconst f2b = (x) => new Uint8Array(new Float64Array([x]).buffer);
const b2f = (x) => new Float64Array(x.buffer)[0];
// Get a byte representation of NaN
const n = f2b(NaN);
// Change the first bit, which is the sign bit and doesn't matter for NaN
n[0] = 1;
const nan2 = b2f(n);
console.log(nan2); // NaN
console.log(Object.is(nan2, NaN)); // true
console.log(f2b(NaN)); // Uint8Array(8) [0, 0, 0, 0, 0, 0, 248, 127]
console.log(f2b(nan2)); // Uint8Array(8) [1, 0, 0, 0, 0, 0, 248, 127]
See also
JS Comparison Table by dorey
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nEquality comparisons and samenessJavaScript provides three different value-comparison operations:

=== — strict equality (triple equals)
== — loose equality (double equals)
Object.is()

Which operation you choose depends on what sort of comparison you are looking to perform. Briefly:

Double equals (==) will perform a type conversion when comparing two things, and will handle NaN, -0, and +0 specially to conform to IEEE 754 (so NaN != NaN, and -0 == +0);
Triple equals (===) will do the same comparison as double equals (including the special handling for NaN, -0, and +0) but without type conversion; if the types differ, false is returned.
Object.is() does no type conversion and no special handling for NaN, -0, and +0 (giving it the same behavior as === except on those special numeric values).

They correspond to three of four equality algorithms in JavaScript:

IsLooselyEqual: ==
IsStrictlyEqual: ===
SameValue: Object.is()
SameValueZero: used by many built-in operations

Note that the distinction between these all have to do with their handling of primitives; none of them compares whether the parameters are conceptually similar in structure. For any non-primitive objects x and y which have the same structure but are distinct objects themselves, all of the above forms will evaluate to false.Strict equality using ===Strict equality compares two values for equality. Neither value is implicitly converted to some other value before being compared. If the values have different types, the values are considered unequal. If the values have the same type, are not numbers, and have the same value, they're considered equal. Finally, if both values are numbers, they're considered equal if they're both not NaN and are the same value, or if one is +0 and one is -0.
jsconst num = 0;
const obj = new String("0");
const str = "0";

console.log(num === num); // true
console.log(obj === obj); // true
console.log(str === str); // true

console.log(num === obj); // false
console.log(num === str); // false
console.log(obj === str); // false
console.log(null === undefined); // false
console.log(obj === null); // false
console.log(obj === undefined); // false

Strict equality is almost always the correct comparison operation to use. For all values except numbers, it uses the obvious semantics: a value is only equal to itself. For numbers it uses slightly different semantics to gloss over two different edge cases. The first is that floating point zero is either positively or negatively signed. This is useful in representing certain mathematical solutions, but as most situations don't care about the difference between +0 and -0, strict equality treats them as the same value. The second is that floating point includes the concept of a not-a-number value, NaN, to represent the solution to certain ill-defined mathematical problems: negative infinity added to positive infinity, for example. Strict equality treats NaN as unequal to every other value — including itself. (The only case in which (x !== x) is true is when x is NaN.)
Besides ===, strict equality is also used by array index-finding methods including Array.prototype.indexOf(), Array.prototype.lastIndexOf(), TypedArray.prototype.indexOf(), TypedArray.prototype.lastIndexOf(), and case-matching. This means you cannot use indexOf(NaN) to find the index of a NaN value in an array, or use NaN as a case value in a switch statement and make it match anything.
jsconsole.log([NaN].indexOf(NaN)); // -1
switch (NaN) {
  case NaN:
    console.log("Surprise"); // Nothing is logged
}
Loose equality using ==Loose equality is symmetric: A == B always has identical semantics to B == A for any values of A and B (except for the order of applied conversions). The behavior for performing loose equality using == is as follows:

If the operands have the same type, they are compared as follows:

Object: return true only if both operands reference the same object.
String: return true only if both operands have the same characters in the same order.
Number: return true only if both operands have the same value. +0 and -0 are treated as the same value. If either operand is NaN, return false; so NaN is never equal to NaN.
Boolean: return true only if operands are both true or both false.
BigInt: return true only if both operands have the same value.
Symbol: return true only if both operands reference the same symbol.


If one of the operands is null or undefined, the other must also be null or undefined to return true. Otherwise return false.
If one of the operands is an object and the other is a primitive, convert the object to a primitive.
At this step, both operands are converted to primitives (one of String, Number, Boolean, Symbol, and BigInt). The rest of the conversion is done case-by-case.

If they are of the same type, compare them using step 1.
If one of the operands is a Symbol but the other is not, return false.
If one of the operands is a Boolean but the other is not, convert the boolean to a number: true is converted to 1, and false is converted to 0. Then compare the two operands loosely again.
Number to String: convert the string to a number. Conversion failure results in NaN, which will guarantee the equality to be false.
Number to BigInt: compare by their mathematical value. If the number is ±Infinity or NaN, return false.
String to BigInt: convert the string to a BigInt using the same algorithm as the BigInt() constructor. If conversion fails, return false.



Traditionally, and according to ECMAScript, all primitives and objects are loosely unequal to undefined and null. But most browsers permit a very narrow class of objects (specifically, the document.all object for any page), in some contexts, to act as if they emulate the value undefined. Loose equality is one such context: null == A and undefined == A evaluate to true if, and only if, A is an object that emulates undefined. In all other cases an object is never loosely equal to undefined or null.
In most cases, using loose equality is discouraged. The result of a comparison using strict equality is easier to predict, and may evaluate more quickly due to the lack of type coercion.
The following example demonstrates loose equality comparisons involving the number primitive 0, the bigint primitive 0n, the string primitive '0', and an object whose toString() value is '0'.
jsconst num = 0;
const big = 0n;
const str = "0";
const obj = new String("0");

console.log(num == str); // true
console.log(big == num); // true
console.log(str == big); // true

console.log(num == obj); // true
console.log(big == obj); // true
console.log(str == obj); // true

Loose equality is only used by the == operator.Same-value equality using Object.is()Same-value equality determines whether two values are functionally identical in all contexts. (This use case demonstrates an instance of the Liskov substitution principle.) One instance occurs when an attempt is made to mutate an immutable property:
js// Add an immutable NEGATIVE_ZERO property to the Number constructor.
Object.defineProperty(Number, "NEGATIVE_ZERO", {
  value: -0,
  writable: false,
  configurable: false,
  enumerable: false,
});

function attemptMutation(v) {
  Object.defineProperty(Number, "NEGATIVE_ZERO", { value: v });
}

Object.defineProperty will throw an exception when attempting to change an immutable property, but it does nothing if no actual change is requested. If v is -0, no change has been requested, and no error will be thrown. Internally, when an immutable property is redefined, the newly-specified value is compared against the current value using same-value equality.
Same-value equality is provided by the Object.is method. It's used almost everywhere in the language where a value of equivalent identity is expected.Same-value-zero equalitySimilar to same-value equality, but +0 and -0 are considered equal.
Same-value-zero equality is not exposed as a JavaScript API, but can be implemented with custom code:
jsfunction sameValueZero(x, y) {
  if (typeof x === "number" && typeof y === "number") {
    // x and y are equal (may be -0 and 0) or they are both NaN
    return x === y || (x !== x && y !== y);
  }
  return x === y;
}

Same-value-zero only differs from strict equality by treating NaN as equivalent, and only differs from same-value equality by treating -0 as equivalent to 0. This makes it usually have the most sensible behavior during searching, especially when working with NaN. It's used by Array.prototype.includes(), TypedArray.prototype.includes(), as well as Map and Set methods for comparing key equality.Comparing equality methodsPeople often compare double equals and triple equals by saying one is an "enhanced" version of the other. For example, double equals could be said as an extended version of triple equals, because the former does everything that the latter does, but with type conversion on its operands — for example, 6 == "6". Alternatively, it can be claimed that double equals is the baseline, and triple equals is an enhanced version, because it requires the two operands to be the same type, so it adds an extra constraint.
However, this way of thinking implies that the equality comparisons form a one-dimensional "spectrum" where "totally strict" lies on one end and "totally loose" lies on the other. This model falls short with Object.is, because it isn't "looser" than double equals or "stricter" than triple equals, nor does it fit somewhere in between (i.e., being both stricter than double equals, but looser than triple equals). We can see from the sameness comparisons table below that this is due to the way that Object.is handles NaN. Notice that if Object.is(NaN, NaN) evaluated to false, we could say that it fits on the loose/strict spectrum as an even stricter form of triple equals, one that distinguishes between -0 and +0. The NaN handling means this is untrue, however. Unfortunately, Object.is has to be thought of in terms of its specific characteristics, rather than its looseness or strictness with regard to the equality operators.



x
y
==
===
Object.is
SameValueZero




undefined
undefined
✅ true
✅ true
✅ true
✅ true


null
null
✅ true
✅ true
✅ true
✅ true


true
true
✅ true
✅ true
✅ true
✅ true


false
false
✅ true
✅ true
✅ true
✅ true


'foo'
'foo'
✅ true
✅ true
✅ true
✅ true


0
0
✅ true
✅ true
✅ true
✅ true


+0
-0
✅ true
✅ true
❌ false
✅ true


+0
0
✅ true
✅ true
✅ true
✅ true


-0
0
✅ true
✅ true
❌ false
✅ true


0n
-0n
✅ true
✅ true
✅ true
✅ true


0
false
✅ true
❌ false
❌ false
❌ false


""
false
✅ true
❌ false
❌ false
❌ false


""
0
✅ true
❌ false
❌ false
❌ false


'0'
0
✅ true
❌ false
❌ false
❌ false


'17'
17
✅ true
❌ false
❌ false
❌ false


[1, 2]
'1,2'
✅ true
❌ false
❌ false
❌ false


new String('foo')
'foo'
✅ true
❌ false
❌ false
❌ false


null
undefined
✅ true
❌ false
❌ false
❌ false


null
false
❌ false
❌ false
❌ false
❌ false


undefined
false
❌ false
❌ false
❌ false
❌ false


{ foo: 'bar' }
{ foo: 'bar' }
❌ false
❌ false
❌ false
❌ false


new String('foo')
new String('foo')
❌ false
❌ false
❌ false
❌ false


0
null
❌ false
❌ false
❌ false
❌ false


0
NaN
❌ false
❌ false
❌ false
❌ false


'foo'
NaN
❌ false
❌ false
❌ false
❌ false


NaN
NaN
❌ false
❌ false
✅ true
✅ true


When to use Object.is() versus triple equalsIn general, the only time Object.is's special behavior towards zeros is likely to be of interest is in the pursuit of certain meta-programming schemes, especially regarding property descriptors, when it is desirable for your work to mirror some of the characteristics of Object.defineProperty. If your use case does not require this, it is suggested to avoid Object.is and use === instead. Even if your requirements involve having comparisons between two NaN values evaluate to true, generally it is easier to special-case the NaN checks (using the isNaN method available from previous versions of ECMAScript) than it is to work out how surrounding computations might affect the sign of any zeros you encounter in your comparison.
Here's a non-exhaustive list of built-in methods and operators that might cause a distinction between -0 and +0 to manifest itself in your code:

- (unary negation)

Consider the following example:
jsconst stoppingForce = obj.mass * -obj.velocity;

If obj.velocity is 0 (or computes to 0), a -0 is introduced at that place and propagates out into stoppingForce.

Math.atan2, Math.ceil, Math.pow, Math.round

In some cases, it's possible for a -0 to be introduced into an expression as a return value of these methods even when no -0 exists as one of the parameters. For example, using Math.pow to raise -Infinity to the power of any negative, odd exponent evaluates to -0. Refer to the documentation for the individual methods.

Math.floor, Math.max, Math.min, Math.sin, Math.sqrt, Math.tan

It's possible to get a -0 return value out of these methods in some cases where a -0 exists as one of the parameters. E.g., Math.min(-0, +0) evaluates to -0. Refer to the documentation for the individual methods.

~, <<, >>

Each of these operators uses the ToInt32 algorithm internally. Since there is only one representation for 0 in the internal 32-bit integer type, -0 will not survive a round trip after an inverse operation. E.g., both Object.is(~~(-0), -0) and Object.is(-0 << 2 >> 2, -0) evaluate to false.


Relying on Object.is when the signedness of zeros is not taken into account can be hazardous. Of course, when the intent is to distinguish between -0 and +0, it does exactly what's desired.Caveat: Object.is() and NaNThe Object.is specification treats all instances of NaN as the same object. However, since typed arrays are available, we can have distinct floating point representations of NaN which don't behave identically in all contexts. For example:
jsconst f2b = (x) => new Uint8Array(new Float64Array([x]).buffer);
const b2f = (x) => new Float64Array(x.buffer)[0];
// Get a byte representation of NaN
const n = f2b(NaN);
// Change the first bit, which is the sign bit and doesn't matter for NaN
n[0] = 1;
const nan2 = b2f(n);
console.log(nan2); // NaN
console.log(Object.is(nan2, NaN)); // true
console.log(f2b(NaN)); // Uint8Array(8) [0, 0, 0, 0, 0, 0, 248, 127]
console.log(f2b(nan2)); // Uint8Array(8) [1, 0, 0, 0, 0, 0, 248, 127]
See also
JS Comparison Table by dorey
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nEnumerability and ownership of propertiesEvery property in JavaScript objects can be classified by three factors:

Enumerable or non-enumerable;
String or symbol;
Own property or inherited property from the prototype chain.

Enumerable properties are those properties whose internal enumerable flag is set to true, which is the default for properties created via simple assignment or via a property initializer. Properties defined via Object.defineProperty and such are not enumerable by default. Most iteration means (such as for...in loops and Object.keys) only visit enumerable keys.
Ownership of properties is determined by whether the property belongs to the object directly and not to its prototype chain.
All properties, enumerable or not, string or symbol, own or inherited, can be accessed with dot notation or bracket notation. In this section, we will focus on the means provided by JavaScript to visit a group of object properties one-by-one.Querying object propertiesThere are four built-in ways to query a property of an object. They all support both string and symbol keys. The following table summarizes when each method returns true.




Enumerable, own
Enumerable, inherited
Non-enumerable, own
Non-enumerable, inherited




propertyIsEnumerable()
true ✅
false ❌
false ❌
false ❌


hasOwnProperty()
true ✅
false ❌
true ✅
false ❌


Object.hasOwn()
true ✅
false ❌
true ✅
false ❌


in
true ✅
true ✅
true ✅
true ✅


Traversing object propertiesThere are many methods in JavaScript that traverse a group of properties of an object. Sometimes, these properties are returned as an array; sometimes, they are iterated one-by-one in a loop; sometimes, they are used for constructing or mutating another object. The following table summarizes when a property may be visited.
Methods that only visit string properties or only symbol properties will have an extra note. ✅ means a property of this type will be visited; ❌ means it will not.




Enumerable, own
Enumerable, inherited
Non-enumerable, own
Non-enumerable, inherited




Object.keysObject.valuesObject.entries
✅(strings)
❌
❌
❌


Object.getOwnPropertyNames
✅(strings)
❌
✅(strings)
❌


Object.getOwnPropertySymbols
✅(symbols)
❌
✅(symbols)
❌


Object.getOwnPropertyDescriptors
✅
❌
✅
❌


Reflect.ownKeys
✅
❌
✅
❌


for...in
✅(strings)
✅(strings)
❌
❌


Object.assign(After the first parameter)
✅
❌
❌
❌


Object spread
✅
❌
❌
❌


Obtaining properties by enumerability/ownershipNote that this is not the most efficient algorithm for all cases, but useful for a quick demonstration.

Detection can occur by SimplePropertyRetriever.theGetMethodYouWant(obj).includes(prop)
Iteration can occur by SimplePropertyRetriever.theGetMethodYouWant(obj).forEach((value, prop) => {}); (or use filter(), map(), etc.)

jsconst SimplePropertyRetriever = {
  getOwnEnumProps(obj) {
    return this._getPropertyNames(obj, true, false, this._enumerable);
    // Or could use for...in filtered with Object.hasOwn or just this: return Object.keys(obj);
  },
  getOwnNonEnumProps(obj) {
    return this._getPropertyNames(obj, true, false, this._notEnumerable);
  },
  getOwnProps(obj) {
    return this._getPropertyNames(
      obj,
      true,
      false,
      this._enumerableAndNotEnumerable,
    );
    // Or just use: return Object.getOwnPropertyNames(obj);
  },
  getPrototypeEnumProps(obj) {
    return this._getPropertyNames(obj, false, true, this._enumerable);
  },
  getPrototypeNonEnumProps(obj) {
    return this._getPropertyNames(obj, false, true, this._notEnumerable);
  },
  getPrototypeProps(obj) {
    return this._getPropertyNames(
      obj,
      false,
      true,
      this._enumerableAndNotEnumerable,
    );
  },
  getOwnAndPrototypeEnumProps(obj) {
    return this._getPropertyNames(obj, true, true, this._enumerable);
    // Or could use unfiltered for...in
  },
  getOwnAndPrototypeNonEnumProps(obj) {
    return this._getPropertyNames(obj, true, true, this._notEnumerable);
  },
  getOwnAndPrototypeEnumAndNonEnumProps(obj) {
    return this._getPropertyNames(
      obj,
      true,
      true,
      this._enumerableAndNotEnumerable,
    );
  },
  // Private static property checker callbacks
  _enumerable(obj, prop) {
    return Object.prototype.propertyIsEnumerable.call(obj, prop);
  },
  _notEnumerable(obj, prop) {
    return !Object.prototype.propertyIsEnumerable.call(obj, prop);
  },
  _enumerableAndNotEnumerable(obj, prop) {
    return true;
  },
  // Inspired by http://stackoverflow.com/a/8024294/271577
  _getPropertyNames(obj, iterateSelf, iteratePrototype, shouldInclude) {
    const props = [];
    do {
      if (iterateSelf) {
        Object.getOwnPropertyNames(obj).forEach((prop) => {
          if (props.indexOf(prop) === -1 && shouldInclude(obj, prop)) {
            props.push(prop);
          }
        });
      }
      if (!iteratePrototype) {
        break;
      }
      iterateSelf = true;
      obj = Object.getPrototypeOf(obj);
    } while (obj);
    return props;
  },
};
See also
in
for...in
Object.prototype.hasOwnProperty()
Object.prototype.propertyIsEnumerable()
Object.getOwnPropertyNames()
Object.getOwnPropertySymbols()
Object.keys()
Object.getOwnPropertyDescriptors()
Object.hasOwn()
Reflect.ownKeys()\n\nEnumerability and ownership of propertiesEvery property in JavaScript objects can be classified by three factors:

Enumerable or non-enumerable;
String or symbol;
Own property or inherited property from the prototype chain.

Enumerable properties are those properties whose internal enumerable flag is set to true, which is the default for properties created via simple assignment or via a property initializer. Properties defined via Object.defineProperty and such are not enumerable by default. Most iteration means (such as for...in loops and Object.keys) only visit enumerable keys.
Ownership of properties is determined by whether the property belongs to the object directly and not to its prototype chain.
All properties, enumerable or not, string or symbol, own or inherited, can be accessed with dot notation or bracket notation. In this section, we will focus on the means provided by JavaScript to visit a group of object properties one-by-one.Querying object propertiesThere are four built-in ways to query a property of an object. They all support both string and symbol keys. The following table summarizes when each method returns true.




Enumerable, own
Enumerable, inherited
Non-enumerable, own
Non-enumerable, inherited




propertyIsEnumerable()
true ✅
false ❌
false ❌
false ❌


hasOwnProperty()
true ✅
false ❌
true ✅
false ❌


Object.hasOwn()
true ✅
false ❌
true ✅
false ❌


in
true ✅
true ✅
true ✅
true ✅


Traversing object propertiesThere are many methods in JavaScript that traverse a group of properties of an object. Sometimes, these properties are returned as an array; sometimes, they are iterated one-by-one in a loop; sometimes, they are used for constructing or mutating another object. The following table summarizes when a property may be visited.
Methods that only visit string properties or only symbol properties will have an extra note. ✅ means a property of this type will be visited; ❌ means it will not.




Enumerable, own
Enumerable, inherited
Non-enumerable, own
Non-enumerable, inherited




Object.keysObject.valuesObject.entries
✅(strings)
❌
❌
❌


Object.getOwnPropertyNames
✅(strings)
❌
✅(strings)
❌


Object.getOwnPropertySymbols
✅(symbols)
❌
✅(symbols)
❌


Object.getOwnPropertyDescriptors
✅
❌
✅
❌


Reflect.ownKeys
✅
❌
✅
❌


for...in
✅(strings)
✅(strings)
❌
❌


Object.assign(After the first parameter)
✅
❌
❌
❌


Object spread
✅
❌
❌
❌


Obtaining properties by enumerability/ownershipNote that this is not the most efficient algorithm for all cases, but useful for a quick demonstration.

Detection can occur by SimplePropertyRetriever.theGetMethodYouWant(obj).includes(prop)
Iteration can occur by SimplePropertyRetriever.theGetMethodYouWant(obj).forEach((value, prop) => {}); (or use filter(), map(), etc.)

jsconst SimplePropertyRetriever = {
  getOwnEnumProps(obj) {
    return this._getPropertyNames(obj, true, false, this._enumerable);
    // Or could use for...in filtered with Object.hasOwn or just this: return Object.keys(obj);
  },
  getOwnNonEnumProps(obj) {
    return this._getPropertyNames(obj, true, false, this._notEnumerable);
  },
  getOwnProps(obj) {
    return this._getPropertyNames(
      obj,
      true,
      false,
      this._enumerableAndNotEnumerable,
    );
    // Or just use: return Object.getOwnPropertyNames(obj);
  },
  getPrototypeEnumProps(obj) {
    return this._getPropertyNames(obj, false, true, this._enumerable);
  },
  getPrototypeNonEnumProps(obj) {
    return this._getPropertyNames(obj, false, true, this._notEnumerable);
  },
  getPrototypeProps(obj) {
    return this._getPropertyNames(
      obj,
      false,
      true,
      this._enumerableAndNotEnumerable,
    );
  },
  getOwnAndPrototypeEnumProps(obj) {
    return this._getPropertyNames(obj, true, true, this._enumerable);
    // Or could use unfiltered for...in
  },
  getOwnAndPrototypeNonEnumProps(obj) {
    return this._getPropertyNames(obj, true, true, this._notEnumerable);
  },
  getOwnAndPrototypeEnumAndNonEnumProps(obj) {
    return this._getPropertyNames(
      obj,
      true,
      true,
      this._enumerableAndNotEnumerable,
    );
  },
  // Private static property checker callbacks
  _enumerable(obj, prop) {
    return Object.prototype.propertyIsEnumerable.call(obj, prop);
  },
  _notEnumerable(obj, prop) {
    return !Object.prototype.propertyIsEnumerable.call(obj, prop);
  },
  _enumerableAndNotEnumerable(obj, prop) {
    return true;
  },
  // Inspired by http://stackoverflow.com/a/8024294/271577
  _getPropertyNames(obj, iterateSelf, iteratePrototype, shouldInclude) {
    const props = [];
    do {
      if (iterateSelf) {
        Object.getOwnPropertyNames(obj).forEach((prop) => {
          if (props.indexOf(prop) === -1 && shouldInclude(obj, prop)) {
            props.push(prop);
          }
        });
      }
      if (!iteratePrototype) {
        break;
      }
      iterateSelf = true;
      obj = Object.getPrototypeOf(obj);
    } while (obj);
    return props;
  },
};
See also
in
for...in
Object.prototype.hasOwnProperty()
Object.prototype.propertyIsEnumerable()
Object.getOwnPropertyNames()
Object.getOwnPropertySymbols()
Object.keys()
Object.getOwnPropertyDescriptors()
Object.hasOwn()
Reflect.ownKeys()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nEnumerability and ownership of propertiesEvery property in JavaScript objects can be classified by three factors:

Enumerable or non-enumerable;
String or symbol;
Own property or inherited property from the prototype chain.

Enumerable properties are those properties whose internal enumerable flag is set to true, which is the default for properties created via simple assignment or via a property initializer. Properties defined via Object.defineProperty and such are not enumerable by default. Most iteration means (such as for...in loops and Object.keys) only visit enumerable keys.
Ownership of properties is determined by whether the property belongs to the object directly and not to its prototype chain.
All properties, enumerable or not, string or symbol, own or inherited, can be accessed with dot notation or bracket notation. In this section, we will focus on the means provided by JavaScript to visit a group of object properties one-by-one.Querying object propertiesThere are four built-in ways to query a property of an object. They all support both string and symbol keys. The following table summarizes when each method returns true.




Enumerable, own
Enumerable, inherited
Non-enumerable, own
Non-enumerable, inherited




propertyIsEnumerable()
true ✅
false ❌
false ❌
false ❌


hasOwnProperty()
true ✅
false ❌
true ✅
false ❌


Object.hasOwn()
true ✅
false ❌
true ✅
false ❌


in
true ✅
true ✅
true ✅
true ✅


Traversing object propertiesThere are many methods in JavaScript that traverse a group of properties of an object. Sometimes, these properties are returned as an array; sometimes, they are iterated one-by-one in a loop; sometimes, they are used for constructing or mutating another object. The following table summarizes when a property may be visited.
Methods that only visit string properties or only symbol properties will have an extra note. ✅ means a property of this type will be visited; ❌ means it will not.




Enumerable, own
Enumerable, inherited
Non-enumerable, own
Non-enumerable, inherited




Object.keysObject.valuesObject.entries
✅(strings)
❌
❌
❌


Object.getOwnPropertyNames
✅(strings)
❌
✅(strings)
❌


Object.getOwnPropertySymbols
✅(symbols)
❌
✅(symbols)
❌


Object.getOwnPropertyDescriptors
✅
❌
✅
❌


Reflect.ownKeys
✅
❌
✅
❌


for...in
✅(strings)
✅(strings)
❌
❌


Object.assign(After the first parameter)
✅
❌
❌
❌


Object spread
✅
❌
❌
❌


Obtaining properties by enumerability/ownershipNote that this is not the most efficient algorithm for all cases, but useful for a quick demonstration.

Detection can occur by SimplePropertyRetriever.theGetMethodYouWant(obj).includes(prop)
Iteration can occur by SimplePropertyRetriever.theGetMethodYouWant(obj).forEach((value, prop) => {}); (or use filter(), map(), etc.)

jsconst SimplePropertyRetriever = {
  getOwnEnumProps(obj) {
    return this._getPropertyNames(obj, true, false, this._enumerable);
    // Or could use for...in filtered with Object.hasOwn or just this: return Object.keys(obj);
  },
  getOwnNonEnumProps(obj) {
    return this._getPropertyNames(obj, true, false, this._notEnumerable);
  },
  getOwnProps(obj) {
    return this._getPropertyNames(
      obj,
      true,
      false,
      this._enumerableAndNotEnumerable,
    );
    // Or just use: return Object.getOwnPropertyNames(obj);
  },
  getPrototypeEnumProps(obj) {
    return this._getPropertyNames(obj, false, true, this._enumerable);
  },
  getPrototypeNonEnumProps(obj) {
    return this._getPropertyNames(obj, false, true, this._notEnumerable);
  },
  getPrototypeProps(obj) {
    return this._getPropertyNames(
      obj,
      false,
      true,
      this._enumerableAndNotEnumerable,
    );
  },
  getOwnAndPrototypeEnumProps(obj) {
    return this._getPropertyNames(obj, true, true, this._enumerable);
    // Or could use unfiltered for...in
  },
  getOwnAndPrototypeNonEnumProps(obj) {
    return this._getPropertyNames(obj, true, true, this._notEnumerable);
  },
  getOwnAndPrototypeEnumAndNonEnumProps(obj) {
    return this._getPropertyNames(
      obj,
      true,
      true,
      this._enumerableAndNotEnumerable,
    );
  },
  // Private static property checker callbacks
  _enumerable(obj, prop) {
    return Object.prototype.propertyIsEnumerable.call(obj, prop);
  },
  _notEnumerable(obj, prop) {
    return !Object.prototype.propertyIsEnumerable.call(obj, prop);
  },
  _enumerableAndNotEnumerable(obj, prop) {
    return true;
  },
  // Inspired by http://stackoverflow.com/a/8024294/271577
  _getPropertyNames(obj, iterateSelf, iteratePrototype, shouldInclude) {
    const props = [];
    do {
      if (iterateSelf) {
        Object.getOwnPropertyNames(obj).forEach((prop) => {
          if (props.indexOf(prop) === -1 && shouldInclude(obj, prop)) {
            props.push(prop);
          }
        });
      }
      if (!iteratePrototype) {
        break;
      }
      iterateSelf = true;
      obj = Object.getPrototypeOf(obj);
    } while (obj);
    return props;
  },
};
See also
in
for...in
Object.prototype.hasOwnProperty()
Object.prototype.propertyIsEnumerable()
Object.getOwnPropertyNames()
Object.getOwnPropertySymbols()
Object.keys()
Object.getOwnPropertyDescriptors()
Object.hasOwn()
Reflect.ownKeys()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nClosuresA closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). In other words, a closure gives a function access to its outer scope. In JavaScript, closures are created every time a function is created, at function creation time.Lexical scopingConsider the following example code:
jsfunction init() {
  var name = "Mozilla"; // name is a local variable created by init
  function displayName() {
    // displayName() is the inner function, that forms a closure
    console.log(name); // use variable declared in the parent function
  }
  displayName();
}
init();

init() creates a local variable called name and a function called displayName(). The displayName() function is an inner function that is defined inside init() and is available only within the body of the init() function. Note that the displayName() function has no local variables of its own. However, since inner functions have access to the variables of outer scopes, displayName() can access the variable name declared in the parent function, init().
Run the code using this JSFiddle link and notice that the console.log() statement within the displayName() function successfully displays the value of the name variable, which is declared in its parent function. This is an example of lexical scoping, which describes how a parser resolves variable names when functions are nested. The word lexical refers to the fact that lexical scoping uses the location where a variable is declared within the source code to determine where that variable is available. Nested functions have access to variables declared in their outer scope.Scoping with let and constTraditionally (before ES6), JavaScript variables only had two kinds of scopes: function scope and global scope. Variables declared with var are either function-scoped or global-scoped, depending on whether they are declared within a function or outside a function. This can be tricky, because blocks with curly braces do not create scopes:
jsif (Math.random() > 0.5) {
  var x = 1;
} else {
  var x = 2;
}
console.log(x);

For people from other languages (e.g., C, Java) where blocks create scopes, the above code should throw an error on the console.log line, because we are outside the scope of x in either block. However, because blocks don't create scopes for var, the var statements here actually create a global variable. There is also a practical example introduced below that illustrates how this can cause actual bugs when combined with closures.
In ES6, JavaScript introduced the let and const declarations, which, among other things like temporal dead zones, allow you to create block-scoped variables.
jsif (Math.random() > 0.5) {
  const x = 1;
} else {
  const x = 2;
}
console.log(x); // ReferenceError: x is not defined

In essence, blocks are finally treated as scopes in ES6, but only if you declare variables with let or const. In addition, ES6 introduced modules, which introduced another kind of scope. Closures are able to capture variables in all these scopes, which we will introduce later.ClosureConsider the following code example:
jsfunction makeFunc() {
  const name = "Mozilla";
  function displayName() {
    console.log(name);
  }
  return displayName;
}

const myFunc = makeFunc();
myFunc();

Running this code has exactly the same effect as the previous example of the init() function above. What's different (and interesting) is that the displayName() inner function is returned from the outer function before being executed.
At first glance, it might seem unintuitive that this code still works. In some programming languages, the local variables within a function exist for just the duration of that function's execution. Once makeFunc() finishes executing, you might expect that the name variable would no longer be accessible. However, because the code still works as expected, this is obviously not the case in JavaScript.
The reason is that functions in JavaScript form closures. A closure is the combination of a function and the lexical environment within which that function was declared. This environment consists of any variables that were in-scope at the time the closure was created. In this case, myFunc is a reference to the instance of the function displayName that is created when makeFunc is run. The instance of displayName maintains a reference to its lexical environment, within which the variable name exists. For this reason, when myFunc is invoked, the variable name remains available for use, and "Mozilla" is passed to console.log.
Here's a slightly more interesting example—a makeAdder function:
jsfunction makeAdder(x) {
  return function (y) {
    return x + y;
  };
}

const add5 = makeAdder(5);
const add10 = makeAdder(10);

console.log(add5(2)); // 7
console.log(add10(2)); // 12

In this example, we have defined a function makeAdder(x), that takes a single argument x, and returns a new function. The function it returns takes a single argument y, and returns the sum of x and y.
In essence, makeAdder is a function factory. It creates functions that can add a specific value to their argument. In the above example, the function factory creates two new functions—one that adds five to its argument, and one that adds 10.
add5 and add10 both form closures. They share the same function body definition, but store different lexical environments. In add5's lexical environment, x is 5, while in the lexical environment for add10, x is 10.Practical closuresClosures are useful because they let you associate data (the lexical environment) with a function that operates on that data. This has obvious parallels to object-oriented programming, where objects allow you to associate data (the object's properties) with one or more methods.
Consequently, you can use a closure anywhere that you might normally use an object with only a single method.
Situations where you might want to do this are particularly common on the web. Much of the code written in front-end JavaScript is event-based. You define some behavior, and then attach it to an event that is triggered by the user (such as a click or a keypress). The code is attached as a callback (a single function that is executed in response to the event).
For instance, suppose we want to add buttons to a page to adjust the text size. One way of doing this is to specify the font-size of the body element (in pixels), and then set the size of the other elements on the page (such as headers) using the relative em unit:
cssbody {
  font-family: Helvetica, Arial, sans-serif;
  font-size: 12px;
}

h1 {
  font-size: 1.5em;
}

h2 {
  font-size: 1.2em;
}

Such interactive text size buttons can change the font-size property of the body element, and the adjustments are picked up by other elements on the page thanks to the relative units.
Here's the JavaScript:
jsfunction makeSizer(size) {
  return function () {
    document.body.style.fontSize = `${size}px`;
  };
}

const size12 = makeSizer(12);
const size14 = makeSizer(14);
const size16 = makeSizer(16);

size12, size14, and size16 are now functions that resize the body text to 12, 14, and 16 pixels, respectively. You can attach them to buttons as demonstrated in the following code example.
jsdocument.getElementById("size-12").onclick = size12;
document.getElementById("size-14").onclick = size14;
document.getElementById("size-16").onclick = size16;

html<button id="size-12">12</button>
<button id="size-14">14</button>
<button id="size-16">16</button>

Run the code using JSFiddle.Emulating private methods with closuresLanguages such as Java allow you to declare methods as private, meaning that they can be called only by other methods in the same class.
JavaScript, prior to classes, didn't have a native way of declaring private methods, but it was possible to emulate private methods using closures. Private methods aren't just useful for restricting access to code. They also provide a powerful way of managing your global namespace.
The following code illustrates how to use closures to define public functions that can access private functions and variables. Note that these closures follow the Module Design Pattern.
jsconst counter = (function () {
  let privateCounter = 0;
  function changeBy(val) {
    privateCounter += val;
  }

  return {
    increment() {
      changeBy(1);
    },

    decrement() {
      changeBy(-1);
    },

    value() {
      return privateCounter;
    },
  };
})();

console.log(counter.value()); // 0.

counter.increment();
counter.increment();
console.log(counter.value()); // 2.

counter.decrement();
console.log(counter.value()); // 1.

In previous examples, each closure had its own lexical environment. Here though, there is a single lexical environment that is shared by the three functions: counter.increment, counter.decrement, and counter.value.
The shared lexical environment is created in the body of an anonymous function, which is executed as soon as it has been defined (also known as an IIFE). The lexical environment contains two private items: a variable called privateCounter, and a function called changeBy. You can't access either of these private members from outside the anonymous function. Instead, you indirectly access them using the three public functions that are returned from the anonymous wrapper.
Those three public functions form closures that share the same lexical environment. Thanks to JavaScript's lexical scoping, they each have access to the privateCounter variable and the changeBy function.
jsconst makeCounter = function () {
  let privateCounter = 0;
  function changeBy(val) {
    privateCounter += val;
  }
  return {
    increment() {
      changeBy(1);
    },

    decrement() {
      changeBy(-1);
    },

    value() {
      return privateCounter;
    },
  };
};

const counter1 = makeCounter();
const counter2 = makeCounter();

console.log(counter1.value()); // 0.

counter1.increment();
counter1.increment();
console.log(counter1.value()); // 2.

counter1.decrement();
console.log(counter1.value()); // 1.
console.log(counter2.value()); // 0.

Notice how the two counters maintain their independence from one another. Each closure references a different version of the privateCounter variable through its own closure. Each time one of the counters is called, its lexical environment changes by changing the value of this variable. Changes to the variable value in one closure don't affect the value in the other closure.

Note:
Using closures in this way provides benefits that are normally associated with object-oriented programming. In particular, data hiding and encapsulation.
Closure scope chainA nested function's access to the outer function's scope includes the enclosing scope of the outer function—effectively creating a chain of function scopes. To demonstrate, consider the following example code.
js// global scope
const e = 10;
function sum(a) {
  return function (b) {
    return function (c) {
      // outer functions scope
      return function (d) {
        // local scope
        return a + b + c + d + e;
      };
    };
  };
}

console.log(sum(1)(2)(3)(4)); // 20

You can also write without anonymous functions:
js// global scope
const e = 10;
function sum(a) {
  return function sum2(b) {
    return function sum3(c) {
      // outer functions scope
      return function sum4(d) {
        // local scope
        return a + b + c + d + e;
      };
    };
  };
}

const sum2 = sum(1);
const sum3 = sum2(2);
const sum4 = sum3(3);
const result = sum4(4);
console.log(result); // 20

In the example above, there's a series of nested functions, all of which have access to the outer functions' scope. In this context, we can say that closures have access to all outer scopes.
Closures can capture variables in block scopes and module scopes as well. For example, the following creates a closure over the block-scoped variable y:
jsfunction outer() {
  let getY;
  {
    const y = 6;
    getY = () => y;
  }
  console.log(typeof y); // undefined
  console.log(getY()); // 6
}

outer();

Closures over modules can be more interesting.
js// myModule.js
let x = 5;
export const getX = () => x;
export const setX = (val) => {
  x = val;
};

Here, the module exports a pair of getter-setter functions, which close over the module-scoped variable x. Even when x is not directly accessible from other modules, it can be read and written with the functions.
jsimport { getX, setX } from "./myModule.js";

console.log(getX()); // 5
setX(6);
console.log(getX()); // 6

Closures can close over imported values as well, which are regarded as live bindings, because when the original value changes, the imported one changes accordingly.
js// myModule.js
export let x = 1;
export const setX = (val) => {
  x = val;
};

js// closureCreator.js
import { x } from "./myModule.js";

export const getX = () => x; // Close over an imported live binding

jsimport { getX } from "./closureCreator.js";
import { setX } from "./myModule.js";

console.log(getX()); // 1
setX(2);
console.log(getX()); // 2
Creating closures in loops: A common mistakePrior to the introduction of the let keyword, a common problem with closures occurred when you created them inside a loop. To demonstrate, consider the following example code.
html<p id="help">Helpful notes will appear here</p>
<p>Email: <input type="text" id="email" name="email" /></p>
<p>Name: <input type="text" id="name" name="name" /></p>
<p>Age: <input type="text" id="age" name="age" /></p>

jsfunction showHelp(help) {
  document.getElementById("help").textContent = help;
}

function setupHelp() {
  var helpText = [
    { id: "email", help: "Your email address" },
    { id: "name", help: "Your full name" },
    { id: "age", help: "Your age (you must be over 16)" },
  ];

  for (var i = 0; i < helpText.length; i++) {
    // Culprit is the use of `var` on this line
    var item = helpText[i];
    document.getElementById(item.id).onfocus = function () {
      showHelp(item.help);
    };
  }
}

setupHelp();

Try running the code in JSFiddle.
The helpText array defines three helpful hints, each associated with the ID of an input field in the document. The loop cycles through these definitions, hooking up an onfocus event to each one that shows the associated help method.
If you try this code out, you'll see that it doesn't work as expected. No matter what field you focus on, the message about your age will be displayed.
The reason for this is that the functions assigned to onfocus form closures; they consist of the function definition and the captured environment from the setupHelp function's scope. Three closures have been created by the loop, but each one shares the same single lexical environment, which has a variable with changing values (item). This is because the variable item is declared with var and thus has function scope due to hoisting. The value of item.help is determined when the onfocus callbacks are executed. Because the loop has already run its course by that time, the item variable object (shared by all three closures) has been left pointing to the last entry in the helpText list.
One solution in this case is to use more closures: in particular, to use a function factory as described earlier:
jsfunction showHelp(help) {
  document.getElementById("help").textContent = help;
}

function makeHelpCallback(help) {
  return function () {
    showHelp(help);
  };
}

function setupHelp() {
  var helpText = [
    { id: "email", help: "Your email address" },
    { id: "name", help: "Your full name" },
    { id: "age", help: "Your age (you must be over 16)" },
  ];

  for (var i = 0; i < helpText.length; i++) {
    var item = helpText[i];
    document.getElementById(item.id).onfocus = makeHelpCallback(item.help);
  }
}

setupHelp();

Run the code using this JSFiddle link.
This works as expected. Rather than the callbacks all sharing a single lexical environment, the makeHelpCallback function creates a new lexical environment for each callback, in which help refers to the corresponding string from the helpText array.
One other way to write the above using anonymous closures is:
jsfunction showHelp(help) {
  document.getElementById("help").textContent = help;
}

function setupHelp() {
  var helpText = [
    { id: "email", help: "Your email address" },
    { id: "name", help: "Your full name" },
    { id: "age", help: "Your age (you must be over 16)" },
  ];

  for (var i = 0; i < helpText.length; i++) {
    (function () {
      var item = helpText[i];
      document.getElementById(item.id).onfocus = function () {
        showHelp(item.help);
      };
    })(); // Immediate event listener attachment with the current value of item (preserved until iteration).
  }
}

setupHelp();

If you don't want to use more closures, you can use the let or const keyword:
jsfunction showHelp(help) {
  document.getElementById("help").textContent = help;
}

function setupHelp() {
  const helpText = [
    { id: "email", help: "Your email address" },
    { id: "name", help: "Your full name" },
    { id: "age", help: "Your age (you must be over 16)" },
  ];

  for (let i = 0; i < helpText.length; i++) {
    const item = helpText[i];
    document.getElementById(item.id).onfocus = () => {
      showHelp(item.help);
    };
  }
}

setupHelp();

This example uses const instead of var, so every closure binds the block-scoped variable, meaning that no additional closures are required.
Another alternative could be to use forEach() to iterate over the helpText array and attach a listener to each <input>, as shown:
jsfunction showHelp(help) {
  document.getElementById("help").textContent = help;
}

function setupHelp() {
  var helpText = [
    { id: "email", help: "Your email address" },
    { id: "name", help: "Your full name" },
    { id: "age", help: "Your age (you must be over 16)" },
  ];

  helpText.forEach(function (text) {
    document.getElementById(text.id).onfocus = function () {
      showHelp(text.help);
    };
  });
}

setupHelp();
Performance considerationsAs mentioned previously, each function instance manages its own scope and closure. Therefore, it is unwise to unnecessarily create functions within other functions if closures are not needed for a particular task, as it will negatively affect script performance both in terms of processing speed and memory consumption.
For instance, when creating a new object/class, methods should normally be associated to the object's prototype rather than defined into the object constructor. The reason is that whenever the constructor is called, the methods would get reassigned (that is, for every object creation).
Consider the following case:
jsfunction MyObject(name, message) {
  this.name = name.toString();
  this.message = message.toString();
  this.getName = function () {
    return this.name;
  };

  this.getMessage = function () {
    return this.message;
  };
}

Because the previous code does not take advantage of the benefits of using closures in this particular instance, we could instead rewrite it to avoid using closures as follows:
jsfunction MyObject(name, message) {
  this.name = name.toString();
  this.message = message.toString();
}
MyObject.prototype = {
  getName() {
    return this.name;
  },
  getMessage() {
    return this.message;
  },
};

However, redefining the prototype is not recommended. The following example instead appends to the existing prototype:
jsfunction MyObject(name, message) {
  this.name = name.toString();
  this.message = message.toString();
}
MyObject.prototype.getName = function () {
  return this.name;
};
MyObject.prototype.getMessage = function () {
  return this.message;
};

In the two previous examples, the inherited prototype can be shared by all objects and the method definitions need not occur at every object creation. See Inheritance and the prototype chain for more.\n\nClosuresA closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). In other words, a closure gives a function access to its outer scope. In JavaScript, closures are created every time a function is created, at function creation time.Lexical scopingConsider the following example code:
jsfunction init() {
  var name = "Mozilla"; // name is a local variable created by init
  function displayName() {
    // displayName() is the inner function, that forms a closure
    console.log(name); // use variable declared in the parent function
  }
  displayName();
}
init();

init() creates a local variable called name and a function called displayName(). The displayName() function is an inner function that is defined inside init() and is available only within the body of the init() function. Note that the displayName() function has no local variables of its own. However, since inner functions have access to the variables of outer scopes, displayName() can access the variable name declared in the parent function, init().
Run the code using this JSFiddle link and notice that the console.log() statement within the displayName() function successfully displays the value of the name variable, which is declared in its parent function. This is an example of lexical scoping, which describes how a parser resolves variable names when functions are nested. The word lexical refers to the fact that lexical scoping uses the location where a variable is declared within the source code to determine where that variable is available. Nested functions have access to variables declared in their outer scope.Scoping with let and constTraditionally (before ES6), JavaScript variables only had two kinds of scopes: function scope and global scope. Variables declared with var are either function-scoped or global-scoped, depending on whether they are declared within a function or outside a function. This can be tricky, because blocks with curly braces do not create scopes:
jsif (Math.random() > 0.5) {
  var x = 1;
} else {
  var x = 2;
}
console.log(x);

For people from other languages (e.g., C, Java) where blocks create scopes, the above code should throw an error on the console.log line, because we are outside the scope of x in either block. However, because blocks don't create scopes for var, the var statements here actually create a global variable. There is also a practical example introduced below that illustrates how this can cause actual bugs when combined with closures.
In ES6, JavaScript introduced the let and const declarations, which, among other things like temporal dead zones, allow you to create block-scoped variables.
jsif (Math.random() > 0.5) {
  const x = 1;
} else {
  const x = 2;
}
console.log(x); // ReferenceError: x is not defined

In essence, blocks are finally treated as scopes in ES6, but only if you declare variables with let or const. In addition, ES6 introduced modules, which introduced another kind of scope. Closures are able to capture variables in all these scopes, which we will introduce later.ClosureConsider the following code example:
jsfunction makeFunc() {
  const name = "Mozilla";
  function displayName() {
    console.log(name);
  }
  return displayName;
}

const myFunc = makeFunc();
myFunc();

Running this code has exactly the same effect as the previous example of the init() function above. What's different (and interesting) is that the displayName() inner function is returned from the outer function before being executed.
At first glance, it might seem unintuitive that this code still works. In some programming languages, the local variables within a function exist for just the duration of that function's execution. Once makeFunc() finishes executing, you might expect that the name variable would no longer be accessible. However, because the code still works as expected, this is obviously not the case in JavaScript.
The reason is that functions in JavaScript form closures. A closure is the combination of a function and the lexical environment within which that function was declared. This environment consists of any variables that were in-scope at the time the closure was created. In this case, myFunc is a reference to the instance of the function displayName that is created when makeFunc is run. The instance of displayName maintains a reference to its lexical environment, within which the variable name exists. For this reason, when myFunc is invoked, the variable name remains available for use, and "Mozilla" is passed to console.log.
Here's a slightly more interesting example—a makeAdder function:
jsfunction makeAdder(x) {
  return function (y) {
    return x + y;
  };
}

const add5 = makeAdder(5);
const add10 = makeAdder(10);

console.log(add5(2)); // 7
console.log(add10(2)); // 12

In this example, we have defined a function makeAdder(x), that takes a single argument x, and returns a new function. The function it returns takes a single argument y, and returns the sum of x and y.
In essence, makeAdder is a function factory. It creates functions that can add a specific value to their argument. In the above example, the function factory creates two new functions—one that adds five to its argument, and one that adds 10.
add5 and add10 both form closures. They share the same function body definition, but store different lexical environments. In add5's lexical environment, x is 5, while in the lexical environment for add10, x is 10.Practical closuresClosures are useful because they let you associate data (the lexical environment) with a function that operates on that data. This has obvious parallels to object-oriented programming, where objects allow you to associate data (the object's properties) with one or more methods.
Consequently, you can use a closure anywhere that you might normally use an object with only a single method.
Situations where you might want to do this are particularly common on the web. Much of the code written in front-end JavaScript is event-based. You define some behavior, and then attach it to an event that is triggered by the user (such as a click or a keypress). The code is attached as a callback (a single function that is executed in response to the event).
For instance, suppose we want to add buttons to a page to adjust the text size. One way of doing this is to specify the font-size of the body element (in pixels), and then set the size of the other elements on the page (such as headers) using the relative em unit:
cssbody {
  font-family: Helvetica, Arial, sans-serif;
  font-size: 12px;
}

h1 {
  font-size: 1.5em;
}

h2 {
  font-size: 1.2em;
}

Such interactive text size buttons can change the font-size property of the body element, and the adjustments are picked up by other elements on the page thanks to the relative units.
Here's the JavaScript:
jsfunction makeSizer(size) {
  return function () {
    document.body.style.fontSize = `${size}px`;
  };
}

const size12 = makeSizer(12);
const size14 = makeSizer(14);
const size16 = makeSizer(16);

size12, size14, and size16 are now functions that resize the body text to 12, 14, and 16 pixels, respectively. You can attach them to buttons as demonstrated in the following code example.
jsdocument.getElementById("size-12").onclick = size12;
document.getElementById("size-14").onclick = size14;
document.getElementById("size-16").onclick = size16;

html<button id="size-12">12</button>
<button id="size-14">14</button>
<button id="size-16">16</button>

Run the code using JSFiddle.Emulating private methods with closuresLanguages such as Java allow you to declare methods as private, meaning that they can be called only by other methods in the same class.
JavaScript, prior to classes, didn't have a native way of declaring private methods, but it was possible to emulate private methods using closures. Private methods aren't just useful for restricting access to code. They also provide a powerful way of managing your global namespace.
The following code illustrates how to use closures to define public functions that can access private functions and variables. Note that these closures follow the Module Design Pattern.
jsconst counter = (function () {
  let privateCounter = 0;
  function changeBy(val) {
    privateCounter += val;
  }

  return {
    increment() {
      changeBy(1);
    },

    decrement() {
      changeBy(-1);
    },

    value() {
      return privateCounter;
    },
  };
})();

console.log(counter.value()); // 0.

counter.increment();
counter.increment();
console.log(counter.value()); // 2.

counter.decrement();
console.log(counter.value()); // 1.

In previous examples, each closure had its own lexical environment. Here though, there is a single lexical environment that is shared by the three functions: counter.increment, counter.decrement, and counter.value.
The shared lexical environment is created in the body of an anonymous function, which is executed as soon as it has been defined (also known as an IIFE). The lexical environment contains two private items: a variable called privateCounter, and a function called changeBy. You can't access either of these private members from outside the anonymous function. Instead, you indirectly access them using the three public functions that are returned from the anonymous wrapper.
Those three public functions form closures that share the same lexical environment. Thanks to JavaScript's lexical scoping, they each have access to the privateCounter variable and the changeBy function.
jsconst makeCounter = function () {
  let privateCounter = 0;
  function changeBy(val) {
    privateCounter += val;
  }
  return {
    increment() {
      changeBy(1);
    },

    decrement() {
      changeBy(-1);
    },

    value() {
      return privateCounter;
    },
  };
};

const counter1 = makeCounter();
const counter2 = makeCounter();

console.log(counter1.value()); // 0.

counter1.increment();
counter1.increment();
console.log(counter1.value()); // 2.

counter1.decrement();
console.log(counter1.value()); // 1.
console.log(counter2.value()); // 0.

Notice how the two counters maintain their independence from one another. Each closure references a different version of the privateCounter variable through its own closure. Each time one of the counters is called, its lexical environment changes by changing the value of this variable. Changes to the variable value in one closure don't affect the value in the other closure.

Note:
Using closures in this way provides benefits that are normally associated with object-oriented programming. In particular, data hiding and encapsulation.
Closure scope chainA nested function's access to the outer function's scope includes the enclosing scope of the outer function—effectively creating a chain of function scopes. To demonstrate, consider the following example code.
js// global scope
const e = 10;
function sum(a) {
  return function (b) {
    return function (c) {
      // outer functions scope
      return function (d) {
        // local scope
        return a + b + c + d + e;
      };
    };
  };
}

console.log(sum(1)(2)(3)(4)); // 20

You can also write without anonymous functions:
js// global scope
const e = 10;
function sum(a) {
  return function sum2(b) {
    return function sum3(c) {
      // outer functions scope
      return function sum4(d) {
        // local scope
        return a + b + c + d + e;
      };
    };
  };
}

const sum2 = sum(1);
const sum3 = sum2(2);
const sum4 = sum3(3);
const result = sum4(4);
console.log(result); // 20

In the example above, there's a series of nested functions, all of which have access to the outer functions' scope. In this context, we can say that closures have access to all outer scopes.
Closures can capture variables in block scopes and module scopes as well. For example, the following creates a closure over the block-scoped variable y:
jsfunction outer() {
  let getY;
  {
    const y = 6;
    getY = () => y;
  }
  console.log(typeof y); // undefined
  console.log(getY()); // 6
}

outer();

Closures over modules can be more interesting.
js// myModule.js
let x = 5;
export const getX = () => x;
export const setX = (val) => {
  x = val;
};

Here, the module exports a pair of getter-setter functions, which close over the module-scoped variable x. Even when x is not directly accessible from other modules, it can be read and written with the functions.
jsimport { getX, setX } from "./myModule.js";

console.log(getX()); // 5
setX(6);
console.log(getX()); // 6

Closures can close over imported values as well, which are regarded as live bindings, because when the original value changes, the imported one changes accordingly.
js// myModule.js
export let x = 1;
export const setX = (val) => {
  x = val;
};

js// closureCreator.js
import { x } from "./myModule.js";

export const getX = () => x; // Close over an imported live binding

jsimport { getX } from "./closureCreator.js";
import { setX } from "./myModule.js";

console.log(getX()); // 1
setX(2);
console.log(getX()); // 2
Creating closures in loops: A common mistakePrior to the introduction of the let keyword, a common problem with closures occurred when you created them inside a loop. To demonstrate, consider the following example code.
html<p id="help">Helpful notes will appear here</p>
<p>Email: <input type="text" id="email" name="email" /></p>
<p>Name: <input type="text" id="name" name="name" /></p>
<p>Age: <input type="text" id="age" name="age" /></p>

jsfunction showHelp(help) {
  document.getElementById("help").textContent = help;
}

function setupHelp() {
  var helpText = [
    { id: "email", help: "Your email address" },
    { id: "name", help: "Your full name" },
    { id: "age", help: "Your age (you must be over 16)" },
  ];

  for (var i = 0; i < helpText.length; i++) {
    // Culprit is the use of `var` on this line
    var item = helpText[i];
    document.getElementById(item.id).onfocus = function () {
      showHelp(item.help);
    };
  }
}

setupHelp();

Try running the code in JSFiddle.
The helpText array defines three helpful hints, each associated with the ID of an input field in the document. The loop cycles through these definitions, hooking up an onfocus event to each one that shows the associated help method.
If you try this code out, you'll see that it doesn't work as expected. No matter what field you focus on, the message about your age will be displayed.
The reason for this is that the functions assigned to onfocus form closures; they consist of the function definition and the captured environment from the setupHelp function's scope. Three closures have been created by the loop, but each one shares the same single lexical environment, which has a variable with changing values (item). This is because the variable item is declared with var and thus has function scope due to hoisting. The value of item.help is determined when the onfocus callbacks are executed. Because the loop has already run its course by that time, the item variable object (shared by all three closures) has been left pointing to the last entry in the helpText list.
One solution in this case is to use more closures: in particular, to use a function factory as described earlier:
jsfunction showHelp(help) {
  document.getElementById("help").textContent = help;
}

function makeHelpCallback(help) {
  return function () {
    showHelp(help);
  };
}

function setupHelp() {
  var helpText = [
    { id: "email", help: "Your email address" },
    { id: "name", help: "Your full name" },
    { id: "age", help: "Your age (you must be over 16)" },
  ];

  for (var i = 0; i < helpText.length; i++) {
    var item = helpText[i];
    document.getElementById(item.id).onfocus = makeHelpCallback(item.help);
  }
}

setupHelp();

Run the code using this JSFiddle link.
This works as expected. Rather than the callbacks all sharing a single lexical environment, the makeHelpCallback function creates a new lexical environment for each callback, in which help refers to the corresponding string from the helpText array.
One other way to write the above using anonymous closures is:
jsfunction showHelp(help) {
  document.getElementById("help").textContent = help;
}

function setupHelp() {
  var helpText = [
    { id: "email", help: "Your email address" },
    { id: "name", help: "Your full name" },
    { id: "age", help: "Your age (you must be over 16)" },
  ];

  for (var i = 0; i < helpText.length; i++) {
    (function () {
      var item = helpText[i];
      document.getElementById(item.id).onfocus = function () {
        showHelp(item.help);
      };
    })(); // Immediate event listener attachment with the current value of item (preserved until iteration).
  }
}

setupHelp();

If you don't want to use more closures, you can use the let or const keyword:
jsfunction showHelp(help) {
  document.getElementById("help").textContent = help;
}

function setupHelp() {
  const helpText = [
    { id: "email", help: "Your email address" },
    { id: "name", help: "Your full name" },
    { id: "age", help: "Your age (you must be over 16)" },
  ];

  for (let i = 0; i < helpText.length; i++) {
    const item = helpText[i];
    document.getElementById(item.id).onfocus = () => {
      showHelp(item.help);
    };
  }
}

setupHelp();

This example uses const instead of var, so every closure binds the block-scoped variable, meaning that no additional closures are required.
Another alternative could be to use forEach() to iterate over the helpText array and attach a listener to each <input>, as shown:
jsfunction showHelp(help) {
  document.getElementById("help").textContent = help;
}

function setupHelp() {
  var helpText = [
    { id: "email", help: "Your email address" },
    { id: "name", help: "Your full name" },
    { id: "age", help: "Your age (you must be over 16)" },
  ];

  helpText.forEach(function (text) {
    document.getElementById(text.id).onfocus = function () {
      showHelp(text.help);
    };
  });
}

setupHelp();
Performance considerationsAs mentioned previously, each function instance manages its own scope and closure. Therefore, it is unwise to unnecessarily create functions within other functions if closures are not needed for a particular task, as it will negatively affect script performance both in terms of processing speed and memory consumption.
For instance, when creating a new object/class, methods should normally be associated to the object's prototype rather than defined into the object constructor. The reason is that whenever the constructor is called, the methods would get reassigned (that is, for every object creation).
Consider the following case:
jsfunction MyObject(name, message) {
  this.name = name.toString();
  this.message = message.toString();
  this.getName = function () {
    return this.name;
  };

  this.getMessage = function () {
    return this.message;
  };
}

Because the previous code does not take advantage of the benefits of using closures in this particular instance, we could instead rewrite it to avoid using closures as follows:
jsfunction MyObject(name, message) {
  this.name = name.toString();
  this.message = message.toString();
}
MyObject.prototype = {
  getName() {
    return this.name;
  },
  getMessage() {
    return this.message;
  },
};

However, redefining the prototype is not recommended. The following example instead appends to the existing prototype:
jsfunction MyObject(name, message) {
  this.name = name.toString();
  this.message = message.toString();
}
MyObject.prototype.getName = function () {
  return this.name;
};
MyObject.prototype.getMessage = function () {
  return this.message;
};

In the two previous examples, the inherited prototype can be shared by all objects and the method definitions need not occur at every object creation. See Inheritance and the prototype chain for more.Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nClosuresA closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). In other words, a closure gives a function access to its outer scope. In JavaScript, closures are created every time a function is created, at function creation time.Lexical scopingConsider the following example code:
jsfunction init() {
  var name = "Mozilla"; // name is a local variable created by init
  function displayName() {
    // displayName() is the inner function, that forms a closure
    console.log(name); // use variable declared in the parent function
  }
  displayName();
}
init();

init() creates a local variable called name and a function called displayName(). The displayName() function is an inner function that is defined inside init() and is available only within the body of the init() function. Note that the displayName() function has no local variables of its own. However, since inner functions have access to the variables of outer scopes, displayName() can access the variable name declared in the parent function, init().
Run the code using this JSFiddle link and notice that the console.log() statement within the displayName() function successfully displays the value of the name variable, which is declared in its parent function. This is an example of lexical scoping, which describes how a parser resolves variable names when functions are nested. The word lexical refers to the fact that lexical scoping uses the location where a variable is declared within the source code to determine where that variable is available. Nested functions have access to variables declared in their outer scope.Scoping with let and constTraditionally (before ES6), JavaScript variables only had two kinds of scopes: function scope and global scope. Variables declared with var are either function-scoped or global-scoped, depending on whether they are declared within a function or outside a function. This can be tricky, because blocks with curly braces do not create scopes:
jsif (Math.random() > 0.5) {
  var x = 1;
} else {
  var x = 2;
}
console.log(x);

For people from other languages (e.g., C, Java) where blocks create scopes, the above code should throw an error on the console.log line, because we are outside the scope of x in either block. However, because blocks don't create scopes for var, the var statements here actually create a global variable. There is also a practical example introduced below that illustrates how this can cause actual bugs when combined with closures.
In ES6, JavaScript introduced the let and const declarations, which, among other things like temporal dead zones, allow you to create block-scoped variables.
jsif (Math.random() > 0.5) {
  const x = 1;
} else {
  const x = 2;
}
console.log(x); // ReferenceError: x is not defined

In essence, blocks are finally treated as scopes in ES6, but only if you declare variables with let or const. In addition, ES6 introduced modules, which introduced another kind of scope. Closures are able to capture variables in all these scopes, which we will introduce later.ClosureConsider the following code example:
jsfunction makeFunc() {
  const name = "Mozilla";
  function displayName() {
    console.log(name);
  }
  return displayName;
}

const myFunc = makeFunc();
myFunc();

Running this code has exactly the same effect as the previous example of the init() function above. What's different (and interesting) is that the displayName() inner function is returned from the outer function before being executed.
At first glance, it might seem unintuitive that this code still works. In some programming languages, the local variables within a function exist for just the duration of that function's execution. Once makeFunc() finishes executing, you might expect that the name variable would no longer be accessible. However, because the code still works as expected, this is obviously not the case in JavaScript.
The reason is that functions in JavaScript form closures. A closure is the combination of a function and the lexical environment within which that function was declared. This environment consists of any variables that were in-scope at the time the closure was created. In this case, myFunc is a reference to the instance of the function displayName that is created when makeFunc is run. The instance of displayName maintains a reference to its lexical environment, within which the variable name exists. For this reason, when myFunc is invoked, the variable name remains available for use, and "Mozilla" is passed to console.log.
Here's a slightly more interesting example—a makeAdder function:
jsfunction makeAdder(x) {
  return function (y) {
    return x + y;
  };
}

const add5 = makeAdder(5);
const add10 = makeAdder(10);

console.log(add5(2)); // 7
console.log(add10(2)); // 12

In this example, we have defined a function makeAdder(x), that takes a single argument x, and returns a new function. The function it returns takes a single argument y, and returns the sum of x and y.
In essence, makeAdder is a function factory. It creates functions that can add a specific value to their argument. In the above example, the function factory creates two new functions—one that adds five to its argument, and one that adds 10.
add5 and add10 both form closures. They share the same function body definition, but store different lexical environments. In add5's lexical environment, x is 5, while in the lexical environment for add10, x is 10.Practical closuresClosures are useful because they let you associate data (the lexical environment) with a function that operates on that data. This has obvious parallels to object-oriented programming, where objects allow you to associate data (the object's properties) with one or more methods.
Consequently, you can use a closure anywhere that you might normally use an object with only a single method.
Situations where you might want to do this are particularly common on the web. Much of the code written in front-end JavaScript is event-based. You define some behavior, and then attach it to an event that is triggered by the user (such as a click or a keypress). The code is attached as a callback (a single function that is executed in response to the event).
For instance, suppose we want to add buttons to a page to adjust the text size. One way of doing this is to specify the font-size of the body element (in pixels), and then set the size of the other elements on the page (such as headers) using the relative em unit:
cssbody {
  font-family: Helvetica, Arial, sans-serif;
  font-size: 12px;
}

h1 {
  font-size: 1.5em;
}

h2 {
  font-size: 1.2em;
}

Such interactive text size buttons can change the font-size property of the body element, and the adjustments are picked up by other elements on the page thanks to the relative units.
Here's the JavaScript:
jsfunction makeSizer(size) {
  return function () {
    document.body.style.fontSize = `${size}px`;
  };
}

const size12 = makeSizer(12);
const size14 = makeSizer(14);
const size16 = makeSizer(16);

size12, size14, and size16 are now functions that resize the body text to 12, 14, and 16 pixels, respectively. You can attach them to buttons as demonstrated in the following code example.
jsdocument.getElementById("size-12").onclick = size12;
document.getElementById("size-14").onclick = size14;
document.getElementById("size-16").onclick = size16;

html<button id="size-12">12</button>
<button id="size-14">14</button>
<button id="size-16">16</button>

Run the code using JSFiddle.Emulating private methods with closuresLanguages such as Java allow you to declare methods as private, meaning that they can be called only by other methods in the same class.
JavaScript, prior to classes, didn't have a native way of declaring private methods, but it was possible to emulate private methods using closures. Private methods aren't just useful for restricting access to code. They also provide a powerful way of managing your global namespace.
The following code illustrates how to use closures to define public functions that can access private functions and variables. Note that these closures follow the Module Design Pattern.
jsconst counter = (function () {
  let privateCounter = 0;
  function changeBy(val) {
    privateCounter += val;
  }

  return {
    increment() {
      changeBy(1);
    },

    decrement() {
      changeBy(-1);
    },

    value() {
      return privateCounter;
    },
  };
})();

console.log(counter.value()); // 0.

counter.increment();
counter.increment();
console.log(counter.value()); // 2.

counter.decrement();
console.log(counter.value()); // 1.

In previous examples, each closure had its own lexical environment. Here though, there is a single lexical environment that is shared by the three functions: counter.increment, counter.decrement, and counter.value.
The shared lexical environment is created in the body of an anonymous function, which is executed as soon as it has been defined (also known as an IIFE). The lexical environment contains two private items: a variable called privateCounter, and a function called changeBy. You can't access either of these private members from outside the anonymous function. Instead, you indirectly access them using the three public functions that are returned from the anonymous wrapper.
Those three public functions form closures that share the same lexical environment. Thanks to JavaScript's lexical scoping, they each have access to the privateCounter variable and the changeBy function.
jsconst makeCounter = function () {
  let privateCounter = 0;
  function changeBy(val) {
    privateCounter += val;
  }
  return {
    increment() {
      changeBy(1);
    },

    decrement() {
      changeBy(-1);
    },

    value() {
      return privateCounter;
    },
  };
};

const counter1 = makeCounter();
const counter2 = makeCounter();

console.log(counter1.value()); // 0.

counter1.increment();
counter1.increment();
console.log(counter1.value()); // 2.

counter1.decrement();
console.log(counter1.value()); // 1.
console.log(counter2.value()); // 0.

Notice how the two counters maintain their independence from one another. Each closure references a different version of the privateCounter variable through its own closure. Each time one of the counters is called, its lexical environment changes by changing the value of this variable. Changes to the variable value in one closure don't affect the value in the other closure.

Note:
Using closures in this way provides benefits that are normally associated with object-oriented programming. In particular, data hiding and encapsulation.
Closure scope chainA nested function's access to the outer function's scope includes the enclosing scope of the outer function—effectively creating a chain of function scopes. To demonstrate, consider the following example code.
js// global scope
const e = 10;
function sum(a) {
  return function (b) {
    return function (c) {
      // outer functions scope
      return function (d) {
        // local scope
        return a + b + c + d + e;
      };
    };
  };
}

console.log(sum(1)(2)(3)(4)); // 20

You can also write without anonymous functions:
js// global scope
const e = 10;
function sum(a) {
  return function sum2(b) {
    return function sum3(c) {
      // outer functions scope
      return function sum4(d) {
        // local scope
        return a + b + c + d + e;
      };
    };
  };
}

const sum2 = sum(1);
const sum3 = sum2(2);
const sum4 = sum3(3);
const result = sum4(4);
console.log(result); // 20

In the example above, there's a series of nested functions, all of which have access to the outer functions' scope. In this context, we can say that closures have access to all outer scopes.
Closures can capture variables in block scopes and module scopes as well. For example, the following creates a closure over the block-scoped variable y:
jsfunction outer() {
  let getY;
  {
    const y = 6;
    getY = () => y;
  }
  console.log(typeof y); // undefined
  console.log(getY()); // 6
}

outer();

Closures over modules can be more interesting.
js// myModule.js
let x = 5;
export const getX = () => x;
export const setX = (val) => {
  x = val;
};

Here, the module exports a pair of getter-setter functions, which close over the module-scoped variable x. Even when x is not directly accessible from other modules, it can be read and written with the functions.
jsimport { getX, setX } from "./myModule.js";

console.log(getX()); // 5
setX(6);
console.log(getX()); // 6

Closures can close over imported values as well, which are regarded as live bindings, because when the original value changes, the imported one changes accordingly.
js// myModule.js
export let x = 1;
export const setX = (val) => {
  x = val;
};

js// closureCreator.js
import { x } from "./myModule.js";

export const getX = () => x; // Close over an imported live binding

jsimport { getX } from "./closureCreator.js";
import { setX } from "./myModule.js";

console.log(getX()); // 1
setX(2);
console.log(getX()); // 2
Creating closures in loops: A common mistakePrior to the introduction of the let keyword, a common problem with closures occurred when you created them inside a loop. To demonstrate, consider the following example code.
html<p id="help">Helpful notes will appear here</p>
<p>Email: <input type="text" id="email" name="email" /></p>
<p>Name: <input type="text" id="name" name="name" /></p>
<p>Age: <input type="text" id="age" name="age" /></p>

jsfunction showHelp(help) {
  document.getElementById("help").textContent = help;
}

function setupHelp() {
  var helpText = [
    { id: "email", help: "Your email address" },
    { id: "name", help: "Your full name" },
    { id: "age", help: "Your age (you must be over 16)" },
  ];

  for (var i = 0; i < helpText.length; i++) {
    // Culprit is the use of `var` on this line
    var item = helpText[i];
    document.getElementById(item.id).onfocus = function () {
      showHelp(item.help);
    };
  }
}

setupHelp();

Try running the code in JSFiddle.
The helpText array defines three helpful hints, each associated with the ID of an input field in the document. The loop cycles through these definitions, hooking up an onfocus event to each one that shows the associated help method.
If you try this code out, you'll see that it doesn't work as expected. No matter what field you focus on, the message about your age will be displayed.
The reason for this is that the functions assigned to onfocus form closures; they consist of the function definition and the captured environment from the setupHelp function's scope. Three closures have been created by the loop, but each one shares the same single lexical environment, which has a variable with changing values (item). This is because the variable item is declared with var and thus has function scope due to hoisting. The value of item.help is determined when the onfocus callbacks are executed. Because the loop has already run its course by that time, the item variable object (shared by all three closures) has been left pointing to the last entry in the helpText list.
One solution in this case is to use more closures: in particular, to use a function factory as described earlier:
jsfunction showHelp(help) {
  document.getElementById("help").textContent = help;
}

function makeHelpCallback(help) {
  return function () {
    showHelp(help);
  };
}

function setupHelp() {
  var helpText = [
    { id: "email", help: "Your email address" },
    { id: "name", help: "Your full name" },
    { id: "age", help: "Your age (you must be over 16)" },
  ];

  for (var i = 0; i < helpText.length; i++) {
    var item = helpText[i];
    document.getElementById(item.id).onfocus = makeHelpCallback(item.help);
  }
}

setupHelp();

Run the code using this JSFiddle link.
This works as expected. Rather than the callbacks all sharing a single lexical environment, the makeHelpCallback function creates a new lexical environment for each callback, in which help refers to the corresponding string from the helpText array.
One other way to write the above using anonymous closures is:
jsfunction showHelp(help) {
  document.getElementById("help").textContent = help;
}

function setupHelp() {
  var helpText = [
    { id: "email", help: "Your email address" },
    { id: "name", help: "Your full name" },
    { id: "age", help: "Your age (you must be over 16)" },
  ];

  for (var i = 0; i < helpText.length; i++) {
    (function () {
      var item = helpText[i];
      document.getElementById(item.id).onfocus = function () {
        showHelp(item.help);
      };
    })(); // Immediate event listener attachment with the current value of item (preserved until iteration).
  }
}

setupHelp();

If you don't want to use more closures, you can use the let or const keyword:
jsfunction showHelp(help) {
  document.getElementById("help").textContent = help;
}

function setupHelp() {
  const helpText = [
    { id: "email", help: "Your email address" },
    { id: "name", help: "Your full name" },
    { id: "age", help: "Your age (you must be over 16)" },
  ];

  for (let i = 0; i < helpText.length; i++) {
    const item = helpText[i];
    document.getElementById(item.id).onfocus = () => {
      showHelp(item.help);
    };
  }
}

setupHelp();

This example uses const instead of var, so every closure binds the block-scoped variable, meaning that no additional closures are required.
Another alternative could be to use forEach() to iterate over the helpText array and attach a listener to each <input>, as shown:
jsfunction showHelp(help) {
  document.getElementById("help").textContent = help;
}

function setupHelp() {
  var helpText = [
    { id: "email", help: "Your email address" },
    { id: "name", help: "Your full name" },
    { id: "age", help: "Your age (you must be over 16)" },
  ];

  helpText.forEach(function (text) {
    document.getElementById(text.id).onfocus = function () {
      showHelp(text.help);
    };
  });
}

setupHelp();
Performance considerationsAs mentioned previously, each function instance manages its own scope and closure. Therefore, it is unwise to unnecessarily create functions within other functions if closures are not needed for a particular task, as it will negatively affect script performance both in terms of processing speed and memory consumption.
For instance, when creating a new object/class, methods should normally be associated to the object's prototype rather than defined into the object constructor. The reason is that whenever the constructor is called, the methods would get reassigned (that is, for every object creation).
Consider the following case:
jsfunction MyObject(name, message) {
  this.name = name.toString();
  this.message = message.toString();
  this.getName = function () {
    return this.name;
  };

  this.getMessage = function () {
    return this.message;
  };
}

Because the previous code does not take advantage of the benefits of using closures in this particular instance, we could instead rewrite it to avoid using closures as follows:
jsfunction MyObject(name, message) {
  this.name = name.toString();
  this.message = message.toString();
}
MyObject.prototype = {
  getName() {
    return this.name;
  },
  getMessage() {
    return this.message;
  },
};

However, redefining the prototype is not recommended. The following example instead appends to the existing prototype:
jsfunction MyObject(name, message) {
  this.name = name.toString();
  this.message = message.toString();
}
MyObject.prototype.getName = function () {
  return this.name;
};
MyObject.prototype.getMessage = function () {
  return this.message;
};

In the two previous examples, the inherited prototype can be shared by all objects and the method definitions need not occur at every object creation. See Inheritance and the prototype chain for more.Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nInheritance and the prototype chainIn programming, inheritance refers to passing down characteristics from a parent to a child so that a new piece of code can reuse and build upon the features of an existing one. JavaScript implements inheritance by using objects. Each object has an internal link to another object called its prototype. That prototype object has a prototype of its own, and so on until an object is reached with null as its prototype. By definition, null has no prototype and acts as the final link in this prototype chain. It is possible to mutate any member of the prototype chain or even swap out the prototype at runtime, so concepts like static dispatching do not exist in JavaScript.
JavaScript is a bit confusing for developers experienced in class-based languages (like Java or C++), as it is dynamic and does not have static types. While this confusion is often considered to be one of JavaScript's weaknesses, the prototypal inheritance model itself is, in fact, more powerful than the classic model. It is, for example, fairly trivial to build a classic model on top of a prototypal model — which is how classes are implemented.
Although classes are now widely adopted and have become a new paradigm in JavaScript, classes do not bring a new inheritance pattern. While classes abstract most of the prototypal mechanism away, understanding how prototypes work under the hood is still useful.Inheritance with the prototype chainInheriting propertiesJavaScript objects are dynamic "bags" of properties (referred to as own properties). JavaScript objects have a link to a prototype object. When trying to access a property of an object, the property will not only be sought on the object but on the prototype of the object, the prototype of the prototype, and so on until either a property with a matching name is found or the end of the prototype chain is reached.

Note:
Following the ECMAScript standard, the notation someObject.[[Prototype]] is used to designate the prototype of someObject. The [[Prototype]] internal slot can be accessed and modified with the Object.getPrototypeOf() and Object.setPrototypeOf() functions respectively. This is equivalent to the JavaScript accessor __proto__ which is non-standard but de-facto implemented by many JavaScript engines. To prevent confusion while keeping it succinct, in our notation we will avoid using obj.__proto__ but use obj.[[Prototype]] instead. This corresponds to Object.getPrototypeOf(obj).
It should not be confused with the func.prototype property of functions, which instead specifies the [[Prototype]] to be assigned to all instances of objects created by the given function when used as a constructor. We will discuss the prototype property of constructor functions in a later section.

There are several ways to specify the [[Prototype]] of an object, which are listed in a later section. For now, we will use the __proto__ syntax for illustration. It's worth noting that the { __proto__: ... } syntax is different from the obj.__proto__ accessor: the former is standard and not deprecated.
In an object literal like { a: 1, b: 2, __proto__: c }, the value c (which has to be either null or another object) will become the [[Prototype]] of the object represented by the literal, while the other keys like a and b will become the own properties of the object. This syntax reads very naturally, since [[Prototype]] is just an "internal property" of the object.
Here is what happens when trying to access a property:
jsconst o = {
  a: 1,
  b: 2,
  // __proto__ sets the [[Prototype]]. It's specified here
  // as another object literal.
  __proto__: {
    b: 3,
    c: 4,
  },
};

// o.[[Prototype]] has properties b and c.
// o.[[Prototype]].[[Prototype]] is Object.prototype (we will explain
// what that means later).
// Finally, o.[[Prototype]].[[Prototype]].[[Prototype]] is null.
// This is the end of the prototype chain, as null,
// by definition, has no [[Prototype]].
// Thus, the full prototype chain looks like:
// { a: 1, b: 2 } ---> { b: 3, c: 4 } ---> Object.prototype ---> null

console.log(o.a); // 1
// Is there an 'a' own property on o? Yes, and its value is 1.

console.log(o.b); // 2
// Is there a 'b' own property on o? Yes, and its value is 2.
// The prototype also has a 'b' property, but it's not visited.
// This is called Property Shadowing

console.log(o.c); // 4
// Is there a 'c' own property on o? No, check its prototype.
// Is there a 'c' own property on o.[[Prototype]]? Yes, its value is 4.

console.log(o.d); // undefined
// Is there a 'd' own property on o? No, check its prototype.
// Is there a 'd' own property on o.[[Prototype]]? No, check its prototype.
// o.[[Prototype]].[[Prototype]] is Object.prototype and
// there is no 'd' property by default, check its prototype.
// o.[[Prototype]].[[Prototype]].[[Prototype]] is null, stop searching,
// no property found, return undefined.

Setting a property to an object creates an own property. The only exception to the getting and setting behavior rules is when it's intercepted by a getter or setter.
Similarly, you can create longer prototype chains, and a property will be sought on all of them.
jsconst o = {
  a: 1,
  b: 2,
  // __proto__ sets the [[Prototype]]. It's specified here
  // as another object literal.
  __proto__: {
    b: 3,
    c: 4,
    __proto__: {
      d: 5,
    },
  },
};

// { a: 1, b: 2 } ---> { b: 3, c: 4 } ---> { d: 5 } ---> Object.prototype ---> null

console.log(o.d); // 5
Inheriting "methods"JavaScript does not have "methods" in the form that class-based languages define them. In JavaScript, any function can be added to an object in the form of a property. An inherited function acts just as any other property, including property shadowing as shown above (in this case, a form of method overriding).
When an inherited function is executed, the value of this points to the inheriting object, not to the prototype object where the function is an own property.
jsconst parent = {
  value: 2,
  method() {
    return this.value + 1;
  },
};

console.log(parent.method()); // 3
// When calling parent.method in this case, 'this' refers to parent

// child is an object that inherits from parent
const child = {
  __proto__: parent,
};
console.log(child.method()); // 3
// When child.method is called, 'this' refers to child.
// So when child inherits the method of parent,
// The property 'value' is sought on child. However, since child
// doesn't have an own property called 'value', the property is
// found on the [[Prototype]], which is parent.value.

child.value = 4; // assign the value 4 to the property 'value' on child.
// This shadows the 'value' property on parent.
// The child object now looks like:
// { value: 4, __proto__: { value: 2, method: [Function] } }
console.log(child.method()); // 5
// Since child now has the 'value' property, 'this.value' means
// child.value instead
ConstructorsThe power of prototypes is that we can reuse a set of properties if they should be present on every instance — especially for methods. Suppose we are to create a series of boxes, where each box is an object that contains a value which can be accessed through a getValue function. A naive implementation would be:
jsconst boxes = [
  { value: 1, getValue() { return this.value; } },
  { value: 2, getValue() { return this.value; } },
  { value: 3, getValue() { return this.value; } },
];

This is subpar, because each instance has its own function property that does the same thing, which is redundant and unnecessary. Instead, we can move getValue to the [[Prototype]] of all boxes:
jsconst boxPrototype = {
  getValue() {
    return this.value;
  },
};

const boxes = [
  { value: 1, __proto__: boxPrototype },
  { value: 2, __proto__: boxPrototype },
  { value: 3, __proto__: boxPrototype },
];

This way, all boxes' getValue method will refer to the same function, lowering memory usage. However, manually binding the __proto__ for every object creation is still very inconvenient. This is when we would use a constructor function, which automatically sets the [[Prototype]] for every object manufactured. Constructors are functions called with new.
js// A constructor function
function Box(value) {
  this.value = value;
}

// Properties all boxes created from the Box() constructor
// will have
Box.prototype.getValue = function () {
  return this.value;
};

const boxes = [new Box(1), new Box(2), new Box(3)];

We say that new Box(1) is an instance created from the Box constructor function. Box.prototype is not much different from the boxPrototype object we created previously — it's just a plain object. Every instance created from a constructor function will automatically have the constructor's prototype property as its [[Prototype]] — that is, Object.getPrototypeOf(new Box()) === Box.prototype. Constructor.prototype by default has one own property: constructor, which references the constructor function itself — that is, Box.prototype.constructor === Box. This allows one to access the original constructor from any instance.

Note:
If a non-primitive is returned from the constructor function, that value will become the result of the new expression. In this case the [[Prototype]] may not be correctly bound — but this should not happen much in practice.

The above constructor function can be rewritten in classes as:
jsclass Box {
  constructor(value) {
    this.value = value;
  }

  // Methods are created on Box.prototype
  getValue() {
    return this.value;
  }
}

Classes are syntax sugar over constructor functions, which means you can still manipulate Box.prototype to change the behavior of all instances. However, because classes are designed to be an abstraction over the underlying prototype mechanism, we will use the more-lightweight constructor function syntax for this tutorial to fully demonstrate how prototypes work.
Because Box.prototype references the same object as the [[Prototype]] of all instances, we can change the behavior of all instances by mutating Box.prototype.
jsfunction Box(value) {
  this.value = value;
}
Box.prototype.getValue = function () {
  return this.value;
};
const box = new Box(1);

// Mutate Box.prototype after an instance has already been created
Box.prototype.getValue = function () {
  return this.value + 1;
};
box.getValue(); // 2

A corollary is, re-assigning Constructor.prototype (Constructor.prototype = ...) is a bad idea for two reasons:

The [[Prototype]] of instances created before the reassignment is now referencing a different object from the [[Prototype]] of instances created after the reassignment — mutating one's [[Prototype]] no longer mutates the other.
Unless you manually re-set the constructor property, the constructor function can no longer be traced from instance.constructor, which may break user expectation. Some built-in operations will read the constructor property as well, and if it is not set, they may not work as expected.

Constructor.prototype is only useful when constructing instances. It has nothing to do with Constructor.[[Prototype]], which is the constructor function's own prototype, which is Function.prototype — that is, Object.getPrototypeOf(Constructor) === Function.prototype.Implicit constructors of literalsSome literal syntaxes in JavaScript create instances that implicitly set the [[Prototype]]. For example:
js// Object literals (without the `__proto__` key) automatically
// have `Object.prototype` as their `[[Prototype]]`
const object = { a: 1 };
Object.getPrototypeOf(object) === Object.prototype; // true

// Array literals automatically have `Array.prototype` as their `[[Prototype]]`
const array = [1, 2, 3];
Object.getPrototypeOf(array) === Array.prototype; // true

// RegExp literals automatically have `RegExp.prototype` as their `[[Prototype]]`
const regexp = /abc/;
Object.getPrototypeOf(regexp) === RegExp.prototype; // true

We can "de-sugar" them into their constructor form.
jsconst array = new Array(1, 2, 3);
const regexp = new RegExp("abc");

For example, "array methods" like map() are simply methods defined on Array.prototype, which is why they are automatically available on all array instances.

Warning:
There is one misfeature that used to be prevalent — extending Object.prototype or one of the other built-in prototypes. An example of this misfeature is, defining Array.prototype.myMethod = function () {...} and then using myMethod on all array instances.
This misfeature is called monkey patching. Doing monkey patching risks forward compatibility, because if the language adds this method in the future but with a different signature, your code will break. It has led to incidents like the SmooshGate, and can be a great nuisance for the language to advance since JavaScript tries to "not break the web".
The only good reason for extending a built-in prototype is to backport the features of newer JavaScript engines, like Array.prototype.forEach.

It may be interesting to note that due to historical reasons, some built-in constructors' prototype property are instances themselves. For example, Number.prototype is a number 0, Array.prototype is an empty array, and RegExp.prototype is /(?:)/.
jsNumber.prototype + 1; // 1
Array.prototype.map((x) => x + 1); // []
String.prototype + "a"; // "a"
RegExp.prototype.source; // "(?:)"
Function.prototype(); // Function.prototype is a no-op function by itself

However, this is not the case for user-defined constructors, nor for modern constructors like Map.
jsMap.prototype.get(1);
// Uncaught TypeError: get method called on incompatible Map.prototype
Building longer inheritance chainsThe Constructor.prototype property will become the [[Prototype]] of the constructor's instances, as-is — including Constructor.prototype's own [[Prototype]]. By default, Constructor.prototype is a plain object — that is, Object.getPrototypeOf(Constructor.prototype) === Object.prototype. The only exception is Object.prototype itself, whose [[Prototype]] is null — that is, Object.getPrototypeOf(Object.prototype) === null. Therefore, a typical constructor will build the following prototype chain:
jsfunction Constructor() {}

const obj = new Constructor();
// obj ---> Constructor.prototype ---> Object.prototype ---> null

To build longer prototype chains, we can set the [[Prototype]] of Constructor.prototype via the Object.setPrototypeOf() function.
jsfunction Base() {}
function Derived() {}
// Set the `[[Prototype]]` of `Derived.prototype`
// to `Base.prototype`
Object.setPrototypeOf(Derived.prototype, Base.prototype);

const obj = new Derived();
// obj ---> Derived.prototype ---> Base.prototype ---> Object.prototype ---> null

In class terms, this is equivalent to using the extends syntax.
jsclass Base {}
class Derived extends Base {}

const obj = new Derived();
// obj ---> Derived.prototype ---> Base.prototype ---> Object.prototype ---> null

You may also see some legacy code using Object.create() to build the inheritance chain. However, because this reassigns the prototype property and removes the constructor property, it can be more error-prone, while performance gains may not be apparent if the constructors haven't created any instances yet.
jsfunction Base() {}
function Derived() {}
// Re-assigns `Derived.prototype` to a new object
// with `Base.prototype` as its `[[Prototype]]`
// DON'T DO THIS — use Object.setPrototypeOf to mutate it instead
Derived.prototype = Object.create(Base.prototype);
Inspecting prototypes: a deeper diveLet's look at what happens behind the scenes in a bit more detail.
In JavaScript, as mentioned above, functions are able to have properties. All functions have a special property named prototype. Please note that the code below is free-standing (it is safe to assume there is no other JavaScript on the webpage other than the below code). For the best learning experience, it is highly recommended that you open a console, navigate to the "console" tab, copy-and-paste in the below JavaScript code, and run it by pressing the Enter/Return key. (The console is included in most web browser's Developer Tools. More information is available for Firefox Developer Tools, Chrome DevTools, and Edge DevTools.)
jsfunction doSomething() {}
console.log(doSomething.prototype);
// It does not matter how you declare the function; a
// function in JavaScript will always have a default
// prototype property — with one exception: an arrow
// function doesn't have a default prototype property:
const doSomethingFromArrowFunction = () => {};
console.log(doSomethingFromArrowFunction.prototype);

As seen above, doSomething() has a default prototype property, as demonstrated by the console. After running this code, the console should have displayed an object that looks similar to this.
{
  constructor: ƒ doSomething(),
  [[Prototype]]: {
    constructor: ƒ Object(),
    hasOwnProperty: ƒ hasOwnProperty(),
    isPrototypeOf: ƒ isPrototypeOf(),
    propertyIsEnumerable: ƒ propertyIsEnumerable(),
    toLocaleString: ƒ toLocaleString(),
    toString: ƒ toString(),
    valueOf: ƒ valueOf()
  }
}


Note:
The Chrome console uses [[Prototype]] to denote the object's prototype, following the spec's terms; Firefox uses <prototype>. For consistency we will use [[Prototype]].

We can add properties to the prototype of doSomething(), as shown below.
jsfunction doSomething() {}
doSomething.prototype.foo = "bar";
console.log(doSomething.prototype);

This results in:
{
  foo: "bar",
  constructor: ƒ doSomething(),
  [[Prototype]]: {
    constructor: ƒ Object(),
    hasOwnProperty: ƒ hasOwnProperty(),
    isPrototypeOf: ƒ isPrototypeOf(),
    propertyIsEnumerable: ƒ propertyIsEnumerable(),
    toLocaleString: ƒ toLocaleString(),
    toString: ƒ toString(),
    valueOf: ƒ valueOf()
  }
}

We can now use the new operator to create an instance of doSomething() based on this prototype. To use the new operator, call the function normally except prefix it with new. Calling a function with the new operator returns an object that is an instance of the function. Properties can then be added onto this object.
Try the following code:
jsfunction doSomething() {}
doSomething.prototype.foo = "bar"; // add a property onto the prototype
const doSomeInstancing = new doSomething();
doSomeInstancing.prop = "some value"; // add a property onto the object
console.log(doSomeInstancing);

This results in an output similar to the following:
{
  prop: "some value",
  [[Prototype]]: {
    foo: "bar",
    constructor: ƒ doSomething(),
    [[Prototype]]: {
      constructor: ƒ Object(),
      hasOwnProperty: ƒ hasOwnProperty(),
      isPrototypeOf: ƒ isPrototypeOf(),
      propertyIsEnumerable: ƒ propertyIsEnumerable(),
      toLocaleString: ƒ toLocaleString(),
      toString: ƒ toString(),
      valueOf: ƒ valueOf()
    }
  }
}

As seen above, the [[Prototype]] of doSomeInstancing is doSomething.prototype. But, what does this do? When you access a property of doSomeInstancing, the runtime first looks to see if doSomeInstancing has that property.
If doSomeInstancing does not have the property, then the runtime looks for the property in doSomeInstancing.[[Prototype]] (a.k.a. doSomething.prototype). If doSomeInstancing.[[Prototype]] has the property being looked for, then that property on doSomeInstancing.[[Prototype]] is used.
Otherwise, if doSomeInstancing.[[Prototype]] does not have the property, then doSomeInstancing.[[Prototype]].[[Prototype]] is checked for the property. By default, the [[Prototype]] of any function's prototype property is Object.prototype. So, doSomeInstancing.[[Prototype]].[[Prototype]] (a.k.a. doSomething.prototype.[[Prototype]] (a.k.a. Object.prototype)) is then looked through for the property being searched for.
If the property is not found in doSomeInstancing.[[Prototype]].[[Prototype]], then doSomeInstancing.[[Prototype]].[[Prototype]].[[Prototype]] is looked through. However, there is a problem: doSomeInstancing.[[Prototype]].[[Prototype]].[[Prototype]] does not exist, because Object.prototype.[[Prototype]] is null. Then, and only then, after the entire prototype chain of [[Prototype]]'s is looked through, the runtime asserts that the property does not exist and conclude that the value at the property is undefined.
Let's try entering some more code into the console:
jsfunction doSomething() {}
doSomething.prototype.foo = "bar";
const doSomeInstancing = new doSomething();
doSomeInstancing.prop = "some value";
console.log("doSomeInstancing.prop:     ", doSomeInstancing.prop);
console.log("doSomeInstancing.foo:      ", doSomeInstancing.foo);
console.log("doSomething.prop:          ", doSomething.prop);
console.log("doSomething.foo:           ", doSomething.foo);
console.log("doSomething.prototype.prop:", doSomething.prototype.prop);
console.log("doSomething.prototype.foo: ", doSomething.prototype.foo);

This results in the following:
doSomeInstancing.prop:      some value
doSomeInstancing.foo:       bar
doSomething.prop:           undefined
doSomething.foo:            undefined
doSomething.prototype.prop: undefined
doSomething.prototype.foo:  bar
Different ways of creating and mutating prototype chainsWe have encountered many ways to create objects and change their prototype chains. We will systematically summarize the different ways, comparing each approach's pros and cons.Objects created with syntax constructsjsconst o = { a: 1 };
// The newly created object o has Object.prototype as its [[Prototype]]
// Object.prototype has null as its [[Prototype]].
// o ---> Object.prototype ---> null

const b = ["yo", "sup", "?"];
// Arrays inherit from Array.prototype
// (which has methods indexOf, forEach, etc.)
// The prototype chain looks like:
// b ---> Array.prototype ---> Object.prototype ---> null

function f() {
  return 2;
}
// Functions inherit from Function.prototype
// (which has methods call, bind, etc.)
// f ---> Function.prototype ---> Object.prototype ---> null

const p = { b: 2, __proto__: o };
// It is possible to point the newly created object's [[Prototype]] to
// another object via the __proto__ literal property. (Not to be confused
// with Object.prototype.__proto__ accessors)
// p ---> o ---> Object.prototype ---> null

When using the __proto__ key in object initializers, pointing the __proto__ key to something that is not an object only fails silently without throwing an exception. Contrary to the Object.prototype.__proto__ setter, __proto__ in object literal initializers is standardized and optimized, and can even be more performant than Object.create. Declaring extra own properties on the object at creation is more ergonomic than Object.create.With constructor functionsjsfunction Graph() {
  this.vertices = [];
  this.edges = [];
}

Graph.prototype.addVertex = function (v) {
  this.vertices.push(v);
};

const g = new Graph();
// g is an object with own properties 'vertices' and 'edges'.
// g.[[Prototype]] is the value of Graph.prototype when new Graph() is executed.

Constructor functions have been available since very early JavaScript. Therefore, it is very fast, very standard, and very JIT-optimizable. However, it's also hard to "do properly" because methods added this way are enumerable by default, which is inconsistent with the class syntax or how built-in methods behave. Doing longer inheritance chains is also error-prone, as previously demonstrated.With Object.create()Calling Object.create() creates a new object. The [[Prototype]] of this object is the first argument of the function:
jsconst a = { a: 1 };
// a ---> Object.prototype ---> null

const b = Object.create(a);
// b ---> a ---> Object.prototype ---> null
console.log(b.a); // 1 (inherited)

const c = Object.create(b);
// c ---> b ---> a ---> Object.prototype ---> null

const d = Object.create(null);
// d ---> null (d is an object that has null directly as its prototype)
console.log(d.hasOwnProperty);
// undefined, because d doesn't inherit from Object.prototype

Similar to the __proto__ key in object initializers, Object.create() allows directly setting the prototype of an object at creation time, which permits the runtime to further optimize the object. It also allows the creation of objects with null prototype, using Object.create(null). The second parameter of Object.create() allows you to precisely specify the attributes of each property in the new object, which can be a double-edged sword:

It allows you to create non-enumerable properties, etc., during object creation, which is not possible with object literals.
It is much more verbose and error-prone than object literals.
It may be slower than object literals, especially when creating many properties.
With classesjsclass Rectangle {
  constructor(height, width) {
    this.name = "Rectangle";
    this.height = height;
    this.width = width;
  }
}

class FilledRectangle extends Rectangle {
  constructor(height, width, color) {
    super(height, width);
    this.name = "Filled rectangle";
    this.color = color;
  }
}

const filledRectangle = new FilledRectangle(5, 10, "blue");
// filledRectangle ---> FilledRectangle.prototype ---> Rectangle.prototype ---> Object.prototype ---> null

Classes offer the highest readability and maintainability when defining complex inheritance structures. Private properties are a feature with no trivial replacement in prototypal inheritance. However, classes are less optimized than traditional constructor functions and are not supported in older environments.With Object.setPrototypeOf()While all methods above will set the prototype chain at object creation time, Object.setPrototypeOf() allows mutating the [[Prototype]] internal property of an existing object. It can even force a prototype on a prototype-less object created with Object.create(null) or remove the prototype of an object by setting it to null.
jsconst obj = { a: 1 };
const anotherObj = { b: 2 };
Object.setPrototypeOf(obj, anotherObj);
// obj ---> anotherObj ---> Object.prototype ---> null

However, you should set the prototype during creation if possible, because setting the prototype dynamically disrupts all optimizations that engines have made to the prototype chain. It might cause some engines to recompile your code for de-optimization, to make it work according to the specs.With the __proto__ accessorAll objects inherit the Object.prototype.__proto__ setter, which can be used to set the [[Prototype]] of an existing object (if the __proto__ key is not overridden on the object).

Warning: Object.prototype.__proto__ accessors are non-standard and deprecated. You should almost always use Object.setPrototypeOf instead.

jsconst obj = {};
// DON'T USE THIS: for example only.
obj.__proto__ = { barProp: "bar val" };
obj.__proto__.__proto__ = { fooProp: "foo val" };
console.log(obj.fooProp);
console.log(obj.barProp);

Compared to Object.setPrototypeOf, setting __proto__ to something that is not an object fails silently without throwing an exception. It also has slightly better browser support. However, it is non-standard and deprecated. You should almost always use Object.setPrototypeOf instead.PerformanceThe lookup time for properties that are high up on the prototype chain can have a negative impact on the performance, and this may be significant in the code where performance is critical. Additionally, trying to access nonexistent properties will always traverse the full prototype chain.
Also, when iterating over the properties of an object, every enumerable property that is on the prototype chain will be enumerated. To check whether an object has a property defined on itself and not somewhere on its prototype chain, it is necessary to use the hasOwnProperty or Object.hasOwn methods. All objects, except those with null as [[Prototype]], inherit hasOwnProperty from Object.prototype — unless it has been overridden further down the prototype chain. To give you a concrete example, let's take the above graph example code to illustrate it:
jsfunction Graph() {
  this.vertices = [];
  this.edges = [];
}

Graph.prototype.addVertex = function (v) {
  this.vertices.push(v);
};

const g = new Graph();
// g ---> Graph.prototype ---> Object.prototype ---> null

g.hasOwnProperty("vertices"); // true
Object.hasOwn(g, "vertices"); // true

g.hasOwnProperty("nope"); // false
Object.hasOwn(g, "nope"); // false

g.hasOwnProperty("addVertex"); // false
Object.hasOwn(g, "addVertex"); // false

Object.getPrototypeOf(g).hasOwnProperty("addVertex"); // true

Note: It is not enough to check whether a property is undefined. The property might very well exist, but its value just happens to be set to undefined.ConclusionJavaScript may be a bit confusing for developers coming from Java or C++, as it's all dynamic, all runtime, and it has no static types at all. Everything is either an object (instance) or a function (constructor), and even functions themselves are instances of the Function constructor. Even the "classes" as syntax constructs are just constructor functions at runtime.
All constructor functions in JavaScript have a special property called prototype, which works with the new operator. The reference to the prototype object is copied to the internal [[Prototype]] property of the new instance. For example, when you do const a1 = new A(), JavaScript (after creating the object in memory and before running function A() with this defined to it) sets a1.[[Prototype]] = A.prototype. When you then access properties of the instance, JavaScript first checks whether they exist on that object directly, and if not, it looks in [[Prototype]]. [[Prototype]] is looked at recursively, i.e., a1.doSomething, Object.getPrototypeOf(a1).doSomething, Object.getPrototypeOf(Object.getPrototypeOf(a1)).doSomething etc., until it's found or Object.getPrototypeOf returns null. This means that all properties defined on prototype are effectively shared by all instances, and you can even later change parts of prototype and have the changes appear in all existing instances.
If, in the example above, you do const a1 = new A(); const a2 = new A();, then a1.doSomething would actually refer to Object.getPrototypeOf(a1).doSomething — which is the same as the A.prototype.doSomething you defined, i.e., Object.getPrototypeOf(a1).doSomething === Object.getPrototypeOf(a2).doSomething === A.prototype.doSomething.
It is essential to understand the prototypal inheritance model before writing complex code that makes use of it. Also, be aware of the length of the prototype chains in your code and break them up if necessary to avoid possible performance problems. Further, the native prototypes should never be extended unless it is for the sake of compatibility with newer JavaScript features.\n\nInheritance and the prototype chainIn programming, inheritance refers to passing down characteristics from a parent to a child so that a new piece of code can reuse and build upon the features of an existing one. JavaScript implements inheritance by using objects. Each object has an internal link to another object called its prototype. That prototype object has a prototype of its own, and so on until an object is reached with null as its prototype. By definition, null has no prototype and acts as the final link in this prototype chain. It is possible to mutate any member of the prototype chain or even swap out the prototype at runtime, so concepts like static dispatching do not exist in JavaScript.
JavaScript is a bit confusing for developers experienced in class-based languages (like Java or C++), as it is dynamic and does not have static types. While this confusion is often considered to be one of JavaScript's weaknesses, the prototypal inheritance model itself is, in fact, more powerful than the classic model. It is, for example, fairly trivial to build a classic model on top of a prototypal model — which is how classes are implemented.
Although classes are now widely adopted and have become a new paradigm in JavaScript, classes do not bring a new inheritance pattern. While classes abstract most of the prototypal mechanism away, understanding how prototypes work under the hood is still useful.Inheritance with the prototype chainInheriting propertiesJavaScript objects are dynamic "bags" of properties (referred to as own properties). JavaScript objects have a link to a prototype object. When trying to access a property of an object, the property will not only be sought on the object but on the prototype of the object, the prototype of the prototype, and so on until either a property with a matching name is found or the end of the prototype chain is reached.

Note:
Following the ECMAScript standard, the notation someObject.[[Prototype]] is used to designate the prototype of someObject. The [[Prototype]] internal slot can be accessed and modified with the Object.getPrototypeOf() and Object.setPrototypeOf() functions respectively. This is equivalent to the JavaScript accessor __proto__ which is non-standard but de-facto implemented by many JavaScript engines. To prevent confusion while keeping it succinct, in our notation we will avoid using obj.__proto__ but use obj.[[Prototype]] instead. This corresponds to Object.getPrototypeOf(obj).
It should not be confused with the func.prototype property of functions, which instead specifies the [[Prototype]] to be assigned to all instances of objects created by the given function when used as a constructor. We will discuss the prototype property of constructor functions in a later section.

There are several ways to specify the [[Prototype]] of an object, which are listed in a later section. For now, we will use the __proto__ syntax for illustration. It's worth noting that the { __proto__: ... } syntax is different from the obj.__proto__ accessor: the former is standard and not deprecated.
In an object literal like { a: 1, b: 2, __proto__: c }, the value c (which has to be either null or another object) will become the [[Prototype]] of the object represented by the literal, while the other keys like a and b will become the own properties of the object. This syntax reads very naturally, since [[Prototype]] is just an "internal property" of the object.
Here is what happens when trying to access a property:
jsconst o = {
  a: 1,
  b: 2,
  // __proto__ sets the [[Prototype]]. It's specified here
  // as another object literal.
  __proto__: {
    b: 3,
    c: 4,
  },
};

// o.[[Prototype]] has properties b and c.
// o.[[Prototype]].[[Prototype]] is Object.prototype (we will explain
// what that means later).
// Finally, o.[[Prototype]].[[Prototype]].[[Prototype]] is null.
// This is the end of the prototype chain, as null,
// by definition, has no [[Prototype]].
// Thus, the full prototype chain looks like:
// { a: 1, b: 2 } ---> { b: 3, c: 4 } ---> Object.prototype ---> null

console.log(o.a); // 1
// Is there an 'a' own property on o? Yes, and its value is 1.

console.log(o.b); // 2
// Is there a 'b' own property on o? Yes, and its value is 2.
// The prototype also has a 'b' property, but it's not visited.
// This is called Property Shadowing

console.log(o.c); // 4
// Is there a 'c' own property on o? No, check its prototype.
// Is there a 'c' own property on o.[[Prototype]]? Yes, its value is 4.

console.log(o.d); // undefined
// Is there a 'd' own property on o? No, check its prototype.
// Is there a 'd' own property on o.[[Prototype]]? No, check its prototype.
// o.[[Prototype]].[[Prototype]] is Object.prototype and
// there is no 'd' property by default, check its prototype.
// o.[[Prototype]].[[Prototype]].[[Prototype]] is null, stop searching,
// no property found, return undefined.

Setting a property to an object creates an own property. The only exception to the getting and setting behavior rules is when it's intercepted by a getter or setter.
Similarly, you can create longer prototype chains, and a property will be sought on all of them.
jsconst o = {
  a: 1,
  b: 2,
  // __proto__ sets the [[Prototype]]. It's specified here
  // as another object literal.
  __proto__: {
    b: 3,
    c: 4,
    __proto__: {
      d: 5,
    },
  },
};

// { a: 1, b: 2 } ---> { b: 3, c: 4 } ---> { d: 5 } ---> Object.prototype ---> null

console.log(o.d); // 5
Inheriting "methods"JavaScript does not have "methods" in the form that class-based languages define them. In JavaScript, any function can be added to an object in the form of a property. An inherited function acts just as any other property, including property shadowing as shown above (in this case, a form of method overriding).
When an inherited function is executed, the value of this points to the inheriting object, not to the prototype object where the function is an own property.
jsconst parent = {
  value: 2,
  method() {
    return this.value + 1;
  },
};

console.log(parent.method()); // 3
// When calling parent.method in this case, 'this' refers to parent

// child is an object that inherits from parent
const child = {
  __proto__: parent,
};
console.log(child.method()); // 3
// When child.method is called, 'this' refers to child.
// So when child inherits the method of parent,
// The property 'value' is sought on child. However, since child
// doesn't have an own property called 'value', the property is
// found on the [[Prototype]], which is parent.value.

child.value = 4; // assign the value 4 to the property 'value' on child.
// This shadows the 'value' property on parent.
// The child object now looks like:
// { value: 4, __proto__: { value: 2, method: [Function] } }
console.log(child.method()); // 5
// Since child now has the 'value' property, 'this.value' means
// child.value instead
ConstructorsThe power of prototypes is that we can reuse a set of properties if they should be present on every instance — especially for methods. Suppose we are to create a series of boxes, where each box is an object that contains a value which can be accessed through a getValue function. A naive implementation would be:
jsconst boxes = [
  { value: 1, getValue() { return this.value; } },
  { value: 2, getValue() { return this.value; } },
  { value: 3, getValue() { return this.value; } },
];

This is subpar, because each instance has its own function property that does the same thing, which is redundant and unnecessary. Instead, we can move getValue to the [[Prototype]] of all boxes:
jsconst boxPrototype = {
  getValue() {
    return this.value;
  },
};

const boxes = [
  { value: 1, __proto__: boxPrototype },
  { value: 2, __proto__: boxPrototype },
  { value: 3, __proto__: boxPrototype },
];

This way, all boxes' getValue method will refer to the same function, lowering memory usage. However, manually binding the __proto__ for every object creation is still very inconvenient. This is when we would use a constructor function, which automatically sets the [[Prototype]] for every object manufactured. Constructors are functions called with new.
js// A constructor function
function Box(value) {
  this.value = value;
}

// Properties all boxes created from the Box() constructor
// will have
Box.prototype.getValue = function () {
  return this.value;
};

const boxes = [new Box(1), new Box(2), new Box(3)];

We say that new Box(1) is an instance created from the Box constructor function. Box.prototype is not much different from the boxPrototype object we created previously — it's just a plain object. Every instance created from a constructor function will automatically have the constructor's prototype property as its [[Prototype]] — that is, Object.getPrototypeOf(new Box()) === Box.prototype. Constructor.prototype by default has one own property: constructor, which references the constructor function itself — that is, Box.prototype.constructor === Box. This allows one to access the original constructor from any instance.

Note:
If a non-primitive is returned from the constructor function, that value will become the result of the new expression. In this case the [[Prototype]] may not be correctly bound — but this should not happen much in practice.

The above constructor function can be rewritten in classes as:
jsclass Box {
  constructor(value) {
    this.value = value;
  }

  // Methods are created on Box.prototype
  getValue() {
    return this.value;
  }
}

Classes are syntax sugar over constructor functions, which means you can still manipulate Box.prototype to change the behavior of all instances. However, because classes are designed to be an abstraction over the underlying prototype mechanism, we will use the more-lightweight constructor function syntax for this tutorial to fully demonstrate how prototypes work.
Because Box.prototype references the same object as the [[Prototype]] of all instances, we can change the behavior of all instances by mutating Box.prototype.
jsfunction Box(value) {
  this.value = value;
}
Box.prototype.getValue = function () {
  return this.value;
};
const box = new Box(1);

// Mutate Box.prototype after an instance has already been created
Box.prototype.getValue = function () {
  return this.value + 1;
};
box.getValue(); // 2

A corollary is, re-assigning Constructor.prototype (Constructor.prototype = ...) is a bad idea for two reasons:

The [[Prototype]] of instances created before the reassignment is now referencing a different object from the [[Prototype]] of instances created after the reassignment — mutating one's [[Prototype]] no longer mutates the other.
Unless you manually re-set the constructor property, the constructor function can no longer be traced from instance.constructor, which may break user expectation. Some built-in operations will read the constructor property as well, and if it is not set, they may not work as expected.

Constructor.prototype is only useful when constructing instances. It has nothing to do with Constructor.[[Prototype]], which is the constructor function's own prototype, which is Function.prototype — that is, Object.getPrototypeOf(Constructor) === Function.prototype.Implicit constructors of literalsSome literal syntaxes in JavaScript create instances that implicitly set the [[Prototype]]. For example:
js// Object literals (without the `__proto__` key) automatically
// have `Object.prototype` as their `[[Prototype]]`
const object = { a: 1 };
Object.getPrototypeOf(object) === Object.prototype; // true

// Array literals automatically have `Array.prototype` as their `[[Prototype]]`
const array = [1, 2, 3];
Object.getPrototypeOf(array) === Array.prototype; // true

// RegExp literals automatically have `RegExp.prototype` as their `[[Prototype]]`
const regexp = /abc/;
Object.getPrototypeOf(regexp) === RegExp.prototype; // true

We can "de-sugar" them into their constructor form.
jsconst array = new Array(1, 2, 3);
const regexp = new RegExp("abc");

For example, "array methods" like map() are simply methods defined on Array.prototype, which is why they are automatically available on all array instances.

Warning:
There is one misfeature that used to be prevalent — extending Object.prototype or one of the other built-in prototypes. An example of this misfeature is, defining Array.prototype.myMethod = function () {...} and then using myMethod on all array instances.
This misfeature is called monkey patching. Doing monkey patching risks forward compatibility, because if the language adds this method in the future but with a different signature, your code will break. It has led to incidents like the SmooshGate, and can be a great nuisance for the language to advance since JavaScript tries to "not break the web".
The only good reason for extending a built-in prototype is to backport the features of newer JavaScript engines, like Array.prototype.forEach.

It may be interesting to note that due to historical reasons, some built-in constructors' prototype property are instances themselves. For example, Number.prototype is a number 0, Array.prototype is an empty array, and RegExp.prototype is /(?:)/.
jsNumber.prototype + 1; // 1
Array.prototype.map((x) => x + 1); // []
String.prototype + "a"; // "a"
RegExp.prototype.source; // "(?:)"
Function.prototype(); // Function.prototype is a no-op function by itself

However, this is not the case for user-defined constructors, nor for modern constructors like Map.
jsMap.prototype.get(1);
// Uncaught TypeError: get method called on incompatible Map.prototype
Building longer inheritance chainsThe Constructor.prototype property will become the [[Prototype]] of the constructor's instances, as-is — including Constructor.prototype's own [[Prototype]]. By default, Constructor.prototype is a plain object — that is, Object.getPrototypeOf(Constructor.prototype) === Object.prototype. The only exception is Object.prototype itself, whose [[Prototype]] is null — that is, Object.getPrototypeOf(Object.prototype) === null. Therefore, a typical constructor will build the following prototype chain:
jsfunction Constructor() {}

const obj = new Constructor();
// obj ---> Constructor.prototype ---> Object.prototype ---> null

To build longer prototype chains, we can set the [[Prototype]] of Constructor.prototype via the Object.setPrototypeOf() function.
jsfunction Base() {}
function Derived() {}
// Set the `[[Prototype]]` of `Derived.prototype`
// to `Base.prototype`
Object.setPrototypeOf(Derived.prototype, Base.prototype);

const obj = new Derived();
// obj ---> Derived.prototype ---> Base.prototype ---> Object.prototype ---> null

In class terms, this is equivalent to using the extends syntax.
jsclass Base {}
class Derived extends Base {}

const obj = new Derived();
// obj ---> Derived.prototype ---> Base.prototype ---> Object.prototype ---> null

You may also see some legacy code using Object.create() to build the inheritance chain. However, because this reassigns the prototype property and removes the constructor property, it can be more error-prone, while performance gains may not be apparent if the constructors haven't created any instances yet.
jsfunction Base() {}
function Derived() {}
// Re-assigns `Derived.prototype` to a new object
// with `Base.prototype` as its `[[Prototype]]`
// DON'T DO THIS — use Object.setPrototypeOf to mutate it instead
Derived.prototype = Object.create(Base.prototype);
Inspecting prototypes: a deeper diveLet's look at what happens behind the scenes in a bit more detail.
In JavaScript, as mentioned above, functions are able to have properties. All functions have a special property named prototype. Please note that the code below is free-standing (it is safe to assume there is no other JavaScript on the webpage other than the below code). For the best learning experience, it is highly recommended that you open a console, navigate to the "console" tab, copy-and-paste in the below JavaScript code, and run it by pressing the Enter/Return key. (The console is included in most web browser's Developer Tools. More information is available for Firefox Developer Tools, Chrome DevTools, and Edge DevTools.)
jsfunction doSomething() {}
console.log(doSomething.prototype);
// It does not matter how you declare the function; a
// function in JavaScript will always have a default
// prototype property — with one exception: an arrow
// function doesn't have a default prototype property:
const doSomethingFromArrowFunction = () => {};
console.log(doSomethingFromArrowFunction.prototype);

As seen above, doSomething() has a default prototype property, as demonstrated by the console. After running this code, the console should have displayed an object that looks similar to this.
{
  constructor: ƒ doSomething(),
  [[Prototype]]: {
    constructor: ƒ Object(),
    hasOwnProperty: ƒ hasOwnProperty(),
    isPrototypeOf: ƒ isPrototypeOf(),
    propertyIsEnumerable: ƒ propertyIsEnumerable(),
    toLocaleString: ƒ toLocaleString(),
    toString: ƒ toString(),
    valueOf: ƒ valueOf()
  }
}


Note:
The Chrome console uses [[Prototype]] to denote the object's prototype, following the spec's terms; Firefox uses <prototype>. For consistency we will use [[Prototype]].

We can add properties to the prototype of doSomething(), as shown below.
jsfunction doSomething() {}
doSomething.prototype.foo = "bar";
console.log(doSomething.prototype);

This results in:
{
  foo: "bar",
  constructor: ƒ doSomething(),
  [[Prototype]]: {
    constructor: ƒ Object(),
    hasOwnProperty: ƒ hasOwnProperty(),
    isPrototypeOf: ƒ isPrototypeOf(),
    propertyIsEnumerable: ƒ propertyIsEnumerable(),
    toLocaleString: ƒ toLocaleString(),
    toString: ƒ toString(),
    valueOf: ƒ valueOf()
  }
}

We can now use the new operator to create an instance of doSomething() based on this prototype. To use the new operator, call the function normally except prefix it with new. Calling a function with the new operator returns an object that is an instance of the function. Properties can then be added onto this object.
Try the following code:
jsfunction doSomething() {}
doSomething.prototype.foo = "bar"; // add a property onto the prototype
const doSomeInstancing = new doSomething();
doSomeInstancing.prop = "some value"; // add a property onto the object
console.log(doSomeInstancing);

This results in an output similar to the following:
{
  prop: "some value",
  [[Prototype]]: {
    foo: "bar",
    constructor: ƒ doSomething(),
    [[Prototype]]: {
      constructor: ƒ Object(),
      hasOwnProperty: ƒ hasOwnProperty(),
      isPrototypeOf: ƒ isPrototypeOf(),
      propertyIsEnumerable: ƒ propertyIsEnumerable(),
      toLocaleString: ƒ toLocaleString(),
      toString: ƒ toString(),
      valueOf: ƒ valueOf()
    }
  }
}

As seen above, the [[Prototype]] of doSomeInstancing is doSomething.prototype. But, what does this do? When you access a property of doSomeInstancing, the runtime first looks to see if doSomeInstancing has that property.
If doSomeInstancing does not have the property, then the runtime looks for the property in doSomeInstancing.[[Prototype]] (a.k.a. doSomething.prototype). If doSomeInstancing.[[Prototype]] has the property being looked for, then that property on doSomeInstancing.[[Prototype]] is used.
Otherwise, if doSomeInstancing.[[Prototype]] does not have the property, then doSomeInstancing.[[Prototype]].[[Prototype]] is checked for the property. By default, the [[Prototype]] of any function's prototype property is Object.prototype. So, doSomeInstancing.[[Prototype]].[[Prototype]] (a.k.a. doSomething.prototype.[[Prototype]] (a.k.a. Object.prototype)) is then looked through for the property being searched for.
If the property is not found in doSomeInstancing.[[Prototype]].[[Prototype]], then doSomeInstancing.[[Prototype]].[[Prototype]].[[Prototype]] is looked through. However, there is a problem: doSomeInstancing.[[Prototype]].[[Prototype]].[[Prototype]] does not exist, because Object.prototype.[[Prototype]] is null. Then, and only then, after the entire prototype chain of [[Prototype]]'s is looked through, the runtime asserts that the property does not exist and conclude that the value at the property is undefined.
Let's try entering some more code into the console:
jsfunction doSomething() {}
doSomething.prototype.foo = "bar";
const doSomeInstancing = new doSomething();
doSomeInstancing.prop = "some value";
console.log("doSomeInstancing.prop:     ", doSomeInstancing.prop);
console.log("doSomeInstancing.foo:      ", doSomeInstancing.foo);
console.log("doSomething.prop:          ", doSomething.prop);
console.log("doSomething.foo:           ", doSomething.foo);
console.log("doSomething.prototype.prop:", doSomething.prototype.prop);
console.log("doSomething.prototype.foo: ", doSomething.prototype.foo);

This results in the following:
doSomeInstancing.prop:      some value
doSomeInstancing.foo:       bar
doSomething.prop:           undefined
doSomething.foo:            undefined
doSomething.prototype.prop: undefined
doSomething.prototype.foo:  bar
Different ways of creating and mutating prototype chainsWe have encountered many ways to create objects and change their prototype chains. We will systematically summarize the different ways, comparing each approach's pros and cons.Objects created with syntax constructsjsconst o = { a: 1 };
// The newly created object o has Object.prototype as its [[Prototype]]
// Object.prototype has null as its [[Prototype]].
// o ---> Object.prototype ---> null

const b = ["yo", "sup", "?"];
// Arrays inherit from Array.prototype
// (which has methods indexOf, forEach, etc.)
// The prototype chain looks like:
// b ---> Array.prototype ---> Object.prototype ---> null

function f() {
  return 2;
}
// Functions inherit from Function.prototype
// (which has methods call, bind, etc.)
// f ---> Function.prototype ---> Object.prototype ---> null

const p = { b: 2, __proto__: o };
// It is possible to point the newly created object's [[Prototype]] to
// another object via the __proto__ literal property. (Not to be confused
// with Object.prototype.__proto__ accessors)
// p ---> o ---> Object.prototype ---> null

When using the __proto__ key in object initializers, pointing the __proto__ key to something that is not an object only fails silently without throwing an exception. Contrary to the Object.prototype.__proto__ setter, __proto__ in object literal initializers is standardized and optimized, and can even be more performant than Object.create. Declaring extra own properties on the object at creation is more ergonomic than Object.create.With constructor functionsjsfunction Graph() {
  this.vertices = [];
  this.edges = [];
}

Graph.prototype.addVertex = function (v) {
  this.vertices.push(v);
};

const g = new Graph();
// g is an object with own properties 'vertices' and 'edges'.
// g.[[Prototype]] is the value of Graph.prototype when new Graph() is executed.

Constructor functions have been available since very early JavaScript. Therefore, it is very fast, very standard, and very JIT-optimizable. However, it's also hard to "do properly" because methods added this way are enumerable by default, which is inconsistent with the class syntax or how built-in methods behave. Doing longer inheritance chains is also error-prone, as previously demonstrated.With Object.create()Calling Object.create() creates a new object. The [[Prototype]] of this object is the first argument of the function:
jsconst a = { a: 1 };
// a ---> Object.prototype ---> null

const b = Object.create(a);
// b ---> a ---> Object.prototype ---> null
console.log(b.a); // 1 (inherited)

const c = Object.create(b);
// c ---> b ---> a ---> Object.prototype ---> null

const d = Object.create(null);
// d ---> null (d is an object that has null directly as its prototype)
console.log(d.hasOwnProperty);
// undefined, because d doesn't inherit from Object.prototype

Similar to the __proto__ key in object initializers, Object.create() allows directly setting the prototype of an object at creation time, which permits the runtime to further optimize the object. It also allows the creation of objects with null prototype, using Object.create(null). The second parameter of Object.create() allows you to precisely specify the attributes of each property in the new object, which can be a double-edged sword:

It allows you to create non-enumerable properties, etc., during object creation, which is not possible with object literals.
It is much more verbose and error-prone than object literals.
It may be slower than object literals, especially when creating many properties.
With classesjsclass Rectangle {
  constructor(height, width) {
    this.name = "Rectangle";
    this.height = height;
    this.width = width;
  }
}

class FilledRectangle extends Rectangle {
  constructor(height, width, color) {
    super(height, width);
    this.name = "Filled rectangle";
    this.color = color;
  }
}

const filledRectangle = new FilledRectangle(5, 10, "blue");
// filledRectangle ---> FilledRectangle.prototype ---> Rectangle.prototype ---> Object.prototype ---> null

Classes offer the highest readability and maintainability when defining complex inheritance structures. Private properties are a feature with no trivial replacement in prototypal inheritance. However, classes are less optimized than traditional constructor functions and are not supported in older environments.With Object.setPrototypeOf()While all methods above will set the prototype chain at object creation time, Object.setPrototypeOf() allows mutating the [[Prototype]] internal property of an existing object. It can even force a prototype on a prototype-less object created with Object.create(null) or remove the prototype of an object by setting it to null.
jsconst obj = { a: 1 };
const anotherObj = { b: 2 };
Object.setPrototypeOf(obj, anotherObj);
// obj ---> anotherObj ---> Object.prototype ---> null

However, you should set the prototype during creation if possible, because setting the prototype dynamically disrupts all optimizations that engines have made to the prototype chain. It might cause some engines to recompile your code for de-optimization, to make it work according to the specs.With the __proto__ accessorAll objects inherit the Object.prototype.__proto__ setter, which can be used to set the [[Prototype]] of an existing object (if the __proto__ key is not overridden on the object).

Warning: Object.prototype.__proto__ accessors are non-standard and deprecated. You should almost always use Object.setPrototypeOf instead.

jsconst obj = {};
// DON'T USE THIS: for example only.
obj.__proto__ = { barProp: "bar val" };
obj.__proto__.__proto__ = { fooProp: "foo val" };
console.log(obj.fooProp);
console.log(obj.barProp);

Compared to Object.setPrototypeOf, setting __proto__ to something that is not an object fails silently without throwing an exception. It also has slightly better browser support. However, it is non-standard and deprecated. You should almost always use Object.setPrototypeOf instead.PerformanceThe lookup time for properties that are high up on the prototype chain can have a negative impact on the performance, and this may be significant in the code where performance is critical. Additionally, trying to access nonexistent properties will always traverse the full prototype chain.
Also, when iterating over the properties of an object, every enumerable property that is on the prototype chain will be enumerated. To check whether an object has a property defined on itself and not somewhere on its prototype chain, it is necessary to use the hasOwnProperty or Object.hasOwn methods. All objects, except those with null as [[Prototype]], inherit hasOwnProperty from Object.prototype — unless it has been overridden further down the prototype chain. To give you a concrete example, let's take the above graph example code to illustrate it:
jsfunction Graph() {
  this.vertices = [];
  this.edges = [];
}

Graph.prototype.addVertex = function (v) {
  this.vertices.push(v);
};

const g = new Graph();
// g ---> Graph.prototype ---> Object.prototype ---> null

g.hasOwnProperty("vertices"); // true
Object.hasOwn(g, "vertices"); // true

g.hasOwnProperty("nope"); // false
Object.hasOwn(g, "nope"); // false

g.hasOwnProperty("addVertex"); // false
Object.hasOwn(g, "addVertex"); // false

Object.getPrototypeOf(g).hasOwnProperty("addVertex"); // true

Note: It is not enough to check whether a property is undefined. The property might very well exist, but its value just happens to be set to undefined.ConclusionJavaScript may be a bit confusing for developers coming from Java or C++, as it's all dynamic, all runtime, and it has no static types at all. Everything is either an object (instance) or a function (constructor), and even functions themselves are instances of the Function constructor. Even the "classes" as syntax constructs are just constructor functions at runtime.
All constructor functions in JavaScript have a special property called prototype, which works with the new operator. The reference to the prototype object is copied to the internal [[Prototype]] property of the new instance. For example, when you do const a1 = new A(), JavaScript (after creating the object in memory and before running function A() with this defined to it) sets a1.[[Prototype]] = A.prototype. When you then access properties of the instance, JavaScript first checks whether they exist on that object directly, and if not, it looks in [[Prototype]]. [[Prototype]] is looked at recursively, i.e., a1.doSomething, Object.getPrototypeOf(a1).doSomething, Object.getPrototypeOf(Object.getPrototypeOf(a1)).doSomething etc., until it's found or Object.getPrototypeOf returns null. This means that all properties defined on prototype are effectively shared by all instances, and you can even later change parts of prototype and have the changes appear in all existing instances.
If, in the example above, you do const a1 = new A(); const a2 = new A();, then a1.doSomething would actually refer to Object.getPrototypeOf(a1).doSomething — which is the same as the A.prototype.doSomething you defined, i.e., Object.getPrototypeOf(a1).doSomething === Object.getPrototypeOf(a2).doSomething === A.prototype.doSomething.
It is essential to understand the prototypal inheritance model before writing complex code that makes use of it. Also, be aware of the length of the prototype chains in your code and break them up if necessary to avoid possible performance problems. Further, the native prototypes should never be extended unless it is for the sake of compatibility with newer JavaScript features.Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nInheritance and the prototype chainIn programming, inheritance refers to passing down characteristics from a parent to a child so that a new piece of code can reuse and build upon the features of an existing one. JavaScript implements inheritance by using objects. Each object has an internal link to another object called its prototype. That prototype object has a prototype of its own, and so on until an object is reached with null as its prototype. By definition, null has no prototype and acts as the final link in this prototype chain. It is possible to mutate any member of the prototype chain or even swap out the prototype at runtime, so concepts like static dispatching do not exist in JavaScript.
JavaScript is a bit confusing for developers experienced in class-based languages (like Java or C++), as it is dynamic and does not have static types. While this confusion is often considered to be one of JavaScript's weaknesses, the prototypal inheritance model itself is, in fact, more powerful than the classic model. It is, for example, fairly trivial to build a classic model on top of a prototypal model — which is how classes are implemented.
Although classes are now widely adopted and have become a new paradigm in JavaScript, classes do not bring a new inheritance pattern. While classes abstract most of the prototypal mechanism away, understanding how prototypes work under the hood is still useful.Inheritance with the prototype chainInheriting propertiesJavaScript objects are dynamic "bags" of properties (referred to as own properties). JavaScript objects have a link to a prototype object. When trying to access a property of an object, the property will not only be sought on the object but on the prototype of the object, the prototype of the prototype, and so on until either a property with a matching name is found or the end of the prototype chain is reached.

Note:
Following the ECMAScript standard, the notation someObject.[[Prototype]] is used to designate the prototype of someObject. The [[Prototype]] internal slot can be accessed and modified with the Object.getPrototypeOf() and Object.setPrototypeOf() functions respectively. This is equivalent to the JavaScript accessor __proto__ which is non-standard but de-facto implemented by many JavaScript engines. To prevent confusion while keeping it succinct, in our notation we will avoid using obj.__proto__ but use obj.[[Prototype]] instead. This corresponds to Object.getPrototypeOf(obj).
It should not be confused with the func.prototype property of functions, which instead specifies the [[Prototype]] to be assigned to all instances of objects created by the given function when used as a constructor. We will discuss the prototype property of constructor functions in a later section.

There are several ways to specify the [[Prototype]] of an object, which are listed in a later section. For now, we will use the __proto__ syntax for illustration. It's worth noting that the { __proto__: ... } syntax is different from the obj.__proto__ accessor: the former is standard and not deprecated.
In an object literal like { a: 1, b: 2, __proto__: c }, the value c (which has to be either null or another object) will become the [[Prototype]] of the object represented by the literal, while the other keys like a and b will become the own properties of the object. This syntax reads very naturally, since [[Prototype]] is just an "internal property" of the object.
Here is what happens when trying to access a property:
jsconst o = {
  a: 1,
  b: 2,
  // __proto__ sets the [[Prototype]]. It's specified here
  // as another object literal.
  __proto__: {
    b: 3,
    c: 4,
  },
};

// o.[[Prototype]] has properties b and c.
// o.[[Prototype]].[[Prototype]] is Object.prototype (we will explain
// what that means later).
// Finally, o.[[Prototype]].[[Prototype]].[[Prototype]] is null.
// This is the end of the prototype chain, as null,
// by definition, has no [[Prototype]].
// Thus, the full prototype chain looks like:
// { a: 1, b: 2 } ---> { b: 3, c: 4 } ---> Object.prototype ---> null

console.log(o.a); // 1
// Is there an 'a' own property on o? Yes, and its value is 1.

console.log(o.b); // 2
// Is there a 'b' own property on o? Yes, and its value is 2.
// The prototype also has a 'b' property, but it's not visited.
// This is called Property Shadowing

console.log(o.c); // 4
// Is there a 'c' own property on o? No, check its prototype.
// Is there a 'c' own property on o.[[Prototype]]? Yes, its value is 4.

console.log(o.d); // undefined
// Is there a 'd' own property on o? No, check its prototype.
// Is there a 'd' own property on o.[[Prototype]]? No, check its prototype.
// o.[[Prototype]].[[Prototype]] is Object.prototype and
// there is no 'd' property by default, check its prototype.
// o.[[Prototype]].[[Prototype]].[[Prototype]] is null, stop searching,
// no property found, return undefined.

Setting a property to an object creates an own property. The only exception to the getting and setting behavior rules is when it's intercepted by a getter or setter.
Similarly, you can create longer prototype chains, and a property will be sought on all of them.
jsconst o = {
  a: 1,
  b: 2,
  // __proto__ sets the [[Prototype]]. It's specified here
  // as another object literal.
  __proto__: {
    b: 3,
    c: 4,
    __proto__: {
      d: 5,
    },
  },
};

// { a: 1, b: 2 } ---> { b: 3, c: 4 } ---> { d: 5 } ---> Object.prototype ---> null

console.log(o.d); // 5
Inheriting "methods"JavaScript does not have "methods" in the form that class-based languages define them. In JavaScript, any function can be added to an object in the form of a property. An inherited function acts just as any other property, including property shadowing as shown above (in this case, a form of method overriding).
When an inherited function is executed, the value of this points to the inheriting object, not to the prototype object where the function is an own property.
jsconst parent = {
  value: 2,
  method() {
    return this.value + 1;
  },
};

console.log(parent.method()); // 3
// When calling parent.method in this case, 'this' refers to parent

// child is an object that inherits from parent
const child = {
  __proto__: parent,
};
console.log(child.method()); // 3
// When child.method is called, 'this' refers to child.
// So when child inherits the method of parent,
// The property 'value' is sought on child. However, since child
// doesn't have an own property called 'value', the property is
// found on the [[Prototype]], which is parent.value.

child.value = 4; // assign the value 4 to the property 'value' on child.
// This shadows the 'value' property on parent.
// The child object now looks like:
// { value: 4, __proto__: { value: 2, method: [Function] } }
console.log(child.method()); // 5
// Since child now has the 'value' property, 'this.value' means
// child.value instead
ConstructorsThe power of prototypes is that we can reuse a set of properties if they should be present on every instance — especially for methods. Suppose we are to create a series of boxes, where each box is an object that contains a value which can be accessed through a getValue function. A naive implementation would be:
jsconst boxes = [
  { value: 1, getValue() { return this.value; } },
  { value: 2, getValue() { return this.value; } },
  { value: 3, getValue() { return this.value; } },
];

This is subpar, because each instance has its own function property that does the same thing, which is redundant and unnecessary. Instead, we can move getValue to the [[Prototype]] of all boxes:
jsconst boxPrototype = {
  getValue() {
    return this.value;
  },
};

const boxes = [
  { value: 1, __proto__: boxPrototype },
  { value: 2, __proto__: boxPrototype },
  { value: 3, __proto__: boxPrototype },
];

This way, all boxes' getValue method will refer to the same function, lowering memory usage. However, manually binding the __proto__ for every object creation is still very inconvenient. This is when we would use a constructor function, which automatically sets the [[Prototype]] for every object manufactured. Constructors are functions called with new.
js// A constructor function
function Box(value) {
  this.value = value;
}

// Properties all boxes created from the Box() constructor
// will have
Box.prototype.getValue = function () {
  return this.value;
};

const boxes = [new Box(1), new Box(2), new Box(3)];

We say that new Box(1) is an instance created from the Box constructor function. Box.prototype is not much different from the boxPrototype object we created previously — it's just a plain object. Every instance created from a constructor function will automatically have the constructor's prototype property as its [[Prototype]] — that is, Object.getPrototypeOf(new Box()) === Box.prototype. Constructor.prototype by default has one own property: constructor, which references the constructor function itself — that is, Box.prototype.constructor === Box. This allows one to access the original constructor from any instance.

Note:
If a non-primitive is returned from the constructor function, that value will become the result of the new expression. In this case the [[Prototype]] may not be correctly bound — but this should not happen much in practice.

The above constructor function can be rewritten in classes as:
jsclass Box {
  constructor(value) {
    this.value = value;
  }

  // Methods are created on Box.prototype
  getValue() {
    return this.value;
  }
}

Classes are syntax sugar over constructor functions, which means you can still manipulate Box.prototype to change the behavior of all instances. However, because classes are designed to be an abstraction over the underlying prototype mechanism, we will use the more-lightweight constructor function syntax for this tutorial to fully demonstrate how prototypes work.
Because Box.prototype references the same object as the [[Prototype]] of all instances, we can change the behavior of all instances by mutating Box.prototype.
jsfunction Box(value) {
  this.value = value;
}
Box.prototype.getValue = function () {
  return this.value;
};
const box = new Box(1);

// Mutate Box.prototype after an instance has already been created
Box.prototype.getValue = function () {
  return this.value + 1;
};
box.getValue(); // 2

A corollary is, re-assigning Constructor.prototype (Constructor.prototype = ...) is a bad idea for two reasons:

The [[Prototype]] of instances created before the reassignment is now referencing a different object from the [[Prototype]] of instances created after the reassignment — mutating one's [[Prototype]] no longer mutates the other.
Unless you manually re-set the constructor property, the constructor function can no longer be traced from instance.constructor, which may break user expectation. Some built-in operations will read the constructor property as well, and if it is not set, they may not work as expected.

Constructor.prototype is only useful when constructing instances. It has nothing to do with Constructor.[[Prototype]], which is the constructor function's own prototype, which is Function.prototype — that is, Object.getPrototypeOf(Constructor) === Function.prototype.Implicit constructors of literalsSome literal syntaxes in JavaScript create instances that implicitly set the [[Prototype]]. For example:
js// Object literals (without the `__proto__` key) automatically
// have `Object.prototype` as their `[[Prototype]]`
const object = { a: 1 };
Object.getPrototypeOf(object) === Object.prototype; // true

// Array literals automatically have `Array.prototype` as their `[[Prototype]]`
const array = [1, 2, 3];
Object.getPrototypeOf(array) === Array.prototype; // true

// RegExp literals automatically have `RegExp.prototype` as their `[[Prototype]]`
const regexp = /abc/;
Object.getPrototypeOf(regexp) === RegExp.prototype; // true

We can "de-sugar" them into their constructor form.
jsconst array = new Array(1, 2, 3);
const regexp = new RegExp("abc");

For example, "array methods" like map() are simply methods defined on Array.prototype, which is why they are automatically available on all array instances.

Warning:
There is one misfeature that used to be prevalent — extending Object.prototype or one of the other built-in prototypes. An example of this misfeature is, defining Array.prototype.myMethod = function () {...} and then using myMethod on all array instances.
This misfeature is called monkey patching. Doing monkey patching risks forward compatibility, because if the language adds this method in the future but with a different signature, your code will break. It has led to incidents like the SmooshGate, and can be a great nuisance for the language to advance since JavaScript tries to "not break the web".
The only good reason for extending a built-in prototype is to backport the features of newer JavaScript engines, like Array.prototype.forEach.

It may be interesting to note that due to historical reasons, some built-in constructors' prototype property are instances themselves. For example, Number.prototype is a number 0, Array.prototype is an empty array, and RegExp.prototype is /(?:)/.
jsNumber.prototype + 1; // 1
Array.prototype.map((x) => x + 1); // []
String.prototype + "a"; // "a"
RegExp.prototype.source; // "(?:)"
Function.prototype(); // Function.prototype is a no-op function by itself

However, this is not the case for user-defined constructors, nor for modern constructors like Map.
jsMap.prototype.get(1);
// Uncaught TypeError: get method called on incompatible Map.prototype
Building longer inheritance chainsThe Constructor.prototype property will become the [[Prototype]] of the constructor's instances, as-is — including Constructor.prototype's own [[Prototype]]. By default, Constructor.prototype is a plain object — that is, Object.getPrototypeOf(Constructor.prototype) === Object.prototype. The only exception is Object.prototype itself, whose [[Prototype]] is null — that is, Object.getPrototypeOf(Object.prototype) === null. Therefore, a typical constructor will build the following prototype chain:
jsfunction Constructor() {}

const obj = new Constructor();
// obj ---> Constructor.prototype ---> Object.prototype ---> null

To build longer prototype chains, we can set the [[Prototype]] of Constructor.prototype via the Object.setPrototypeOf() function.
jsfunction Base() {}
function Derived() {}
// Set the `[[Prototype]]` of `Derived.prototype`
// to `Base.prototype`
Object.setPrototypeOf(Derived.prototype, Base.prototype);

const obj = new Derived();
// obj ---> Derived.prototype ---> Base.prototype ---> Object.prototype ---> null

In class terms, this is equivalent to using the extends syntax.
jsclass Base {}
class Derived extends Base {}

const obj = new Derived();
// obj ---> Derived.prototype ---> Base.prototype ---> Object.prototype ---> null

You may also see some legacy code using Object.create() to build the inheritance chain. However, because this reassigns the prototype property and removes the constructor property, it can be more error-prone, while performance gains may not be apparent if the constructors haven't created any instances yet.
jsfunction Base() {}
function Derived() {}
// Re-assigns `Derived.prototype` to a new object
// with `Base.prototype` as its `[[Prototype]]`
// DON'T DO THIS — use Object.setPrototypeOf to mutate it instead
Derived.prototype = Object.create(Base.prototype);
Inspecting prototypes: a deeper diveLet's look at what happens behind the scenes in a bit more detail.
In JavaScript, as mentioned above, functions are able to have properties. All functions have a special property named prototype. Please note that the code below is free-standing (it is safe to assume there is no other JavaScript on the webpage other than the below code). For the best learning experience, it is highly recommended that you open a console, navigate to the "console" tab, copy-and-paste in the below JavaScript code, and run it by pressing the Enter/Return key. (The console is included in most web browser's Developer Tools. More information is available for Firefox Developer Tools, Chrome DevTools, and Edge DevTools.)
jsfunction doSomething() {}
console.log(doSomething.prototype);
// It does not matter how you declare the function; a
// function in JavaScript will always have a default
// prototype property — with one exception: an arrow
// function doesn't have a default prototype property:
const doSomethingFromArrowFunction = () => {};
console.log(doSomethingFromArrowFunction.prototype);

As seen above, doSomething() has a default prototype property, as demonstrated by the console. After running this code, the console should have displayed an object that looks similar to this.
{
  constructor: ƒ doSomething(),
  [[Prototype]]: {
    constructor: ƒ Object(),
    hasOwnProperty: ƒ hasOwnProperty(),
    isPrototypeOf: ƒ isPrototypeOf(),
    propertyIsEnumerable: ƒ propertyIsEnumerable(),
    toLocaleString: ƒ toLocaleString(),
    toString: ƒ toString(),
    valueOf: ƒ valueOf()
  }
}


Note:
The Chrome console uses [[Prototype]] to denote the object's prototype, following the spec's terms; Firefox uses <prototype>. For consistency we will use [[Prototype]].

We can add properties to the prototype of doSomething(), as shown below.
jsfunction doSomething() {}
doSomething.prototype.foo = "bar";
console.log(doSomething.prototype);

This results in:
{
  foo: "bar",
  constructor: ƒ doSomething(),
  [[Prototype]]: {
    constructor: ƒ Object(),
    hasOwnProperty: ƒ hasOwnProperty(),
    isPrototypeOf: ƒ isPrototypeOf(),
    propertyIsEnumerable: ƒ propertyIsEnumerable(),
    toLocaleString: ƒ toLocaleString(),
    toString: ƒ toString(),
    valueOf: ƒ valueOf()
  }
}

We can now use the new operator to create an instance of doSomething() based on this prototype. To use the new operator, call the function normally except prefix it with new. Calling a function with the new operator returns an object that is an instance of the function. Properties can then be added onto this object.
Try the following code:
jsfunction doSomething() {}
doSomething.prototype.foo = "bar"; // add a property onto the prototype
const doSomeInstancing = new doSomething();
doSomeInstancing.prop = "some value"; // add a property onto the object
console.log(doSomeInstancing);

This results in an output similar to the following:
{
  prop: "some value",
  [[Prototype]]: {
    foo: "bar",
    constructor: ƒ doSomething(),
    [[Prototype]]: {
      constructor: ƒ Object(),
      hasOwnProperty: ƒ hasOwnProperty(),
      isPrototypeOf: ƒ isPrototypeOf(),
      propertyIsEnumerable: ƒ propertyIsEnumerable(),
      toLocaleString: ƒ toLocaleString(),
      toString: ƒ toString(),
      valueOf: ƒ valueOf()
    }
  }
}

As seen above, the [[Prototype]] of doSomeInstancing is doSomething.prototype. But, what does this do? When you access a property of doSomeInstancing, the runtime first looks to see if doSomeInstancing has that property.
If doSomeInstancing does not have the property, then the runtime looks for the property in doSomeInstancing.[[Prototype]] (a.k.a. doSomething.prototype). If doSomeInstancing.[[Prototype]] has the property being looked for, then that property on doSomeInstancing.[[Prototype]] is used.
Otherwise, if doSomeInstancing.[[Prototype]] does not have the property, then doSomeInstancing.[[Prototype]].[[Prototype]] is checked for the property. By default, the [[Prototype]] of any function's prototype property is Object.prototype. So, doSomeInstancing.[[Prototype]].[[Prototype]] (a.k.a. doSomething.prototype.[[Prototype]] (a.k.a. Object.prototype)) is then looked through for the property being searched for.
If the property is not found in doSomeInstancing.[[Prototype]].[[Prototype]], then doSomeInstancing.[[Prototype]].[[Prototype]].[[Prototype]] is looked through. However, there is a problem: doSomeInstancing.[[Prototype]].[[Prototype]].[[Prototype]] does not exist, because Object.prototype.[[Prototype]] is null. Then, and only then, after the entire prototype chain of [[Prototype]]'s is looked through, the runtime asserts that the property does not exist and conclude that the value at the property is undefined.
Let's try entering some more code into the console:
jsfunction doSomething() {}
doSomething.prototype.foo = "bar";
const doSomeInstancing = new doSomething();
doSomeInstancing.prop = "some value";
console.log("doSomeInstancing.prop:     ", doSomeInstancing.prop);
console.log("doSomeInstancing.foo:      ", doSomeInstancing.foo);
console.log("doSomething.prop:          ", doSomething.prop);
console.log("doSomething.foo:           ", doSomething.foo);
console.log("doSomething.prototype.prop:", doSomething.prototype.prop);
console.log("doSomething.prototype.foo: ", doSomething.prototype.foo);

This results in the following:
doSomeInstancing.prop:      some value
doSomeInstancing.foo:       bar
doSomething.prop:           undefined
doSomething.foo:            undefined
doSomething.prototype.prop: undefined
doSomething.prototype.foo:  bar
Different ways of creating and mutating prototype chainsWe have encountered many ways to create objects and change their prototype chains. We will systematically summarize the different ways, comparing each approach's pros and cons.Objects created with syntax constructsjsconst o = { a: 1 };
// The newly created object o has Object.prototype as its [[Prototype]]
// Object.prototype has null as its [[Prototype]].
// o ---> Object.prototype ---> null

const b = ["yo", "sup", "?"];
// Arrays inherit from Array.prototype
// (which has methods indexOf, forEach, etc.)
// The prototype chain looks like:
// b ---> Array.prototype ---> Object.prototype ---> null

function f() {
  return 2;
}
// Functions inherit from Function.prototype
// (which has methods call, bind, etc.)
// f ---> Function.prototype ---> Object.prototype ---> null

const p = { b: 2, __proto__: o };
// It is possible to point the newly created object's [[Prototype]] to
// another object via the __proto__ literal property. (Not to be confused
// with Object.prototype.__proto__ accessors)
// p ---> o ---> Object.prototype ---> null

When using the __proto__ key in object initializers, pointing the __proto__ key to something that is not an object only fails silently without throwing an exception. Contrary to the Object.prototype.__proto__ setter, __proto__ in object literal initializers is standardized and optimized, and can even be more performant than Object.create. Declaring extra own properties on the object at creation is more ergonomic than Object.create.With constructor functionsjsfunction Graph() {
  this.vertices = [];
  this.edges = [];
}

Graph.prototype.addVertex = function (v) {
  this.vertices.push(v);
};

const g = new Graph();
// g is an object with own properties 'vertices' and 'edges'.
// g.[[Prototype]] is the value of Graph.prototype when new Graph() is executed.

Constructor functions have been available since very early JavaScript. Therefore, it is very fast, very standard, and very JIT-optimizable. However, it's also hard to "do properly" because methods added this way are enumerable by default, which is inconsistent with the class syntax or how built-in methods behave. Doing longer inheritance chains is also error-prone, as previously demonstrated.With Object.create()Calling Object.create() creates a new object. The [[Prototype]] of this object is the first argument of the function:
jsconst a = { a: 1 };
// a ---> Object.prototype ---> null

const b = Object.create(a);
// b ---> a ---> Object.prototype ---> null
console.log(b.a); // 1 (inherited)

const c = Object.create(b);
// c ---> b ---> a ---> Object.prototype ---> null

const d = Object.create(null);
// d ---> null (d is an object that has null directly as its prototype)
console.log(d.hasOwnProperty);
// undefined, because d doesn't inherit from Object.prototype

Similar to the __proto__ key in object initializers, Object.create() allows directly setting the prototype of an object at creation time, which permits the runtime to further optimize the object. It also allows the creation of objects with null prototype, using Object.create(null). The second parameter of Object.create() allows you to precisely specify the attributes of each property in the new object, which can be a double-edged sword:

It allows you to create non-enumerable properties, etc., during object creation, which is not possible with object literals.
It is much more verbose and error-prone than object literals.
It may be slower than object literals, especially when creating many properties.
With classesjsclass Rectangle {
  constructor(height, width) {
    this.name = "Rectangle";
    this.height = height;
    this.width = width;
  }
}

class FilledRectangle extends Rectangle {
  constructor(height, width, color) {
    super(height, width);
    this.name = "Filled rectangle";
    this.color = color;
  }
}

const filledRectangle = new FilledRectangle(5, 10, "blue");
// filledRectangle ---> FilledRectangle.prototype ---> Rectangle.prototype ---> Object.prototype ---> null

Classes offer the highest readability and maintainability when defining complex inheritance structures. Private properties are a feature with no trivial replacement in prototypal inheritance. However, classes are less optimized than traditional constructor functions and are not supported in older environments.With Object.setPrototypeOf()While all methods above will set the prototype chain at object creation time, Object.setPrototypeOf() allows mutating the [[Prototype]] internal property of an existing object. It can even force a prototype on a prototype-less object created with Object.create(null) or remove the prototype of an object by setting it to null.
jsconst obj = { a: 1 };
const anotherObj = { b: 2 };
Object.setPrototypeOf(obj, anotherObj);
// obj ---> anotherObj ---> Object.prototype ---> null

However, you should set the prototype during creation if possible, because setting the prototype dynamically disrupts all optimizations that engines have made to the prototype chain. It might cause some engines to recompile your code for de-optimization, to make it work according to the specs.With the __proto__ accessorAll objects inherit the Object.prototype.__proto__ setter, which can be used to set the [[Prototype]] of an existing object (if the __proto__ key is not overridden on the object).

Warning: Object.prototype.__proto__ accessors are non-standard and deprecated. You should almost always use Object.setPrototypeOf instead.

jsconst obj = {};
// DON'T USE THIS: for example only.
obj.__proto__ = { barProp: "bar val" };
obj.__proto__.__proto__ = { fooProp: "foo val" };
console.log(obj.fooProp);
console.log(obj.barProp);

Compared to Object.setPrototypeOf, setting __proto__ to something that is not an object fails silently without throwing an exception. It also has slightly better browser support. However, it is non-standard and deprecated. You should almost always use Object.setPrototypeOf instead.PerformanceThe lookup time for properties that are high up on the prototype chain can have a negative impact on the performance, and this may be significant in the code where performance is critical. Additionally, trying to access nonexistent properties will always traverse the full prototype chain.
Also, when iterating over the properties of an object, every enumerable property that is on the prototype chain will be enumerated. To check whether an object has a property defined on itself and not somewhere on its prototype chain, it is necessary to use the hasOwnProperty or Object.hasOwn methods. All objects, except those with null as [[Prototype]], inherit hasOwnProperty from Object.prototype — unless it has been overridden further down the prototype chain. To give you a concrete example, let's take the above graph example code to illustrate it:
jsfunction Graph() {
  this.vertices = [];
  this.edges = [];
}

Graph.prototype.addVertex = function (v) {
  this.vertices.push(v);
};

const g = new Graph();
// g ---> Graph.prototype ---> Object.prototype ---> null

g.hasOwnProperty("vertices"); // true
Object.hasOwn(g, "vertices"); // true

g.hasOwnProperty("nope"); // false
Object.hasOwn(g, "nope"); // false

g.hasOwnProperty("addVertex"); // false
Object.hasOwn(g, "addVertex"); // false

Object.getPrototypeOf(g).hasOwnProperty("addVertex"); // true

Note: It is not enough to check whether a property is undefined. The property might very well exist, but its value just happens to be set to undefined.ConclusionJavaScript may be a bit confusing for developers coming from Java or C++, as it's all dynamic, all runtime, and it has no static types at all. Everything is either an object (instance) or a function (constructor), and even functions themselves are instances of the Function constructor. Even the "classes" as syntax constructs are just constructor functions at runtime.
All constructor functions in JavaScript have a special property called prototype, which works with the new operator. The reference to the prototype object is copied to the internal [[Prototype]] property of the new instance. For example, when you do const a1 = new A(), JavaScript (after creating the object in memory and before running function A() with this defined to it) sets a1.[[Prototype]] = A.prototype. When you then access properties of the instance, JavaScript first checks whether they exist on that object directly, and if not, it looks in [[Prototype]]. [[Prototype]] is looked at recursively, i.e., a1.doSomething, Object.getPrototypeOf(a1).doSomething, Object.getPrototypeOf(Object.getPrototypeOf(a1)).doSomething etc., until it's found or Object.getPrototypeOf returns null. This means that all properties defined on prototype are effectively shared by all instances, and you can even later change parts of prototype and have the changes appear in all existing instances.
If, in the example above, you do const a1 = new A(); const a2 = new A();, then a1.doSomething would actually refer to Object.getPrototypeOf(a1).doSomething — which is the same as the A.prototype.doSomething you defined, i.e., Object.getPrototypeOf(a1).doSomething === Object.getPrototypeOf(a2).doSomething === A.prototype.doSomething.
It is essential to understand the prototypal inheritance model before writing complex code that makes use of it. Also, be aware of the length of the prototype chains in your code and break them up if necessary to avoid possible performance problems. Further, the native prototypes should never be extended unless it is for the sake of compatibility with newer JavaScript features.Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nMemory managementLow-level languages like C, have manual memory management primitives such as malloc() and free(). In contrast, JavaScript automatically allocates memory when objects are created and frees it when they are not used anymore (garbage collection). This automaticity is a potential source of confusion: it can give developers the false impression that they don't need to worry about memory management.Memory life cycleRegardless of the programming language, the memory life cycle is pretty much always the same:

Allocate the memory you need
Use the allocated memory (read, write)
Release the allocated memory when it is not needed anymore

The second part is explicit in all languages. The first and last parts are explicit in low-level languages but are mostly implicit in high-level languages like JavaScript.Allocation in JavaScriptValue initialization
In order to not bother the programmer with allocations, JavaScript will automatically allocate memory when values are initially declared.
jsconst n = 123; // allocates memory for a number
const s = "string"; // allocates memory for a string

const o = {
  a: 1,
  b: null,
}; // allocates memory for an object and contained values

// (like object) allocates memory for the array and
// contained values
const a = [1, null, "str2"];

function f(a) {
  return a + 2;
} // allocates a function (which is a callable object)

// function expressions also allocate an object
someElement.addEventListener(
  "click",
  () => {
    someElement.style.backgroundColor = "blue";
  },
  false,
);

Allocation via function calls
Some function calls result in object allocation.
jsconst d = new Date(); // allocates a Date object

const e = document.createElement("div"); // allocates a DOM element

Some methods allocate new values or objects:
jsconst s = "string";
const s2 = s.substr(0, 3); // s2 is a new string
// Since strings are immutable values,
// JavaScript may decide to not allocate memory,
// but just store the [0, 3] range.

const a = ["yeah yeah", "no no"];
const a2 = ["generation", "no no"];
const a3 = a.concat(a2);
// new array with 4 elements being
// the concatenation of a and a2 elements.
Using valuesUsing values basically means reading and writing in allocated memory. This can be done by reading or writing the value of a variable or an object property or even passing an argument to a function.Release when the memory is not needed anymoreThe majority of memory management issues occur at this phase. The most difficult aspect of this stage is determining when the allocated memory is no longer needed.
Low-level languages require the developer to manually determine at which point in the program the allocated memory is no longer needed and to release it.
Some high-level languages, such as JavaScript, utilize a form of automatic memory management known as garbage collection (GC). The purpose of a garbage collector is to monitor memory allocation and determine when a block of allocated memory is no longer needed and reclaim it. This automatic process is an approximation since the general problem of determining whether or not a specific piece of memory is still needed is undecidable.Garbage collectionAs stated above, the general problem of automatically finding whether some memory "is not needed anymore" is undecidable. As a consequence, garbage collectors implement a restriction of a solution to the general problem. This section will explain the concepts that are necessary for understanding the main garbage collection algorithms and their respective limitations.ReferencesThe main concept that garbage collection algorithms rely on is the concept of reference. Within the context of memory management, an object is said to reference another object if the former has access to the latter (either implicitly or explicitly). For instance, a JavaScript object has a reference to its prototype (implicit reference) and to its properties values (explicit reference).
In this context, the notion of an "object" is extended to something broader than regular JavaScript objects and also contain function scopes (or the global lexical scope).Reference-counting garbage collection
Note:
No modern JavaScript engine uses reference-counting for garbage collection anymore.

This is the most naïve garbage collection algorithm. This algorithm reduces the problem from determining whether or not an object is still needed to determining if an object still has any other objects referencing it. An object is said to be "garbage", or collectible if there are zero references pointing to it.
For example:
jslet x = {
  a: {
    b: 2,
  },
};
// 2 objects are created. One is referenced by the other as one of its properties.
// The other is referenced by virtue of being assigned to the 'x' variable.
// Obviously, none can be garbage-collected.

let y = x;
// The 'y' variable is the second thing that has a reference to the object.

x = 1;
// Now, the object that was originally in 'x' has a unique reference
// embodied by the 'y' variable.

let z = y.a;
// Reference to 'a' property of the object.
// This object now has 2 references: one as a property,
// the other as the 'z' variable.

y = "mozilla";
// The object that was originally in 'x' has now zero
// references to it. It can be garbage-collected.
// However its 'a' property is still referenced by
// the 'z' variable, so it cannot be freed.

z = null;
// The 'a' property of the object originally in x
// has zero references to it. It can be garbage collected.

There is a limitation when it comes to circular references. In the following example, two objects are created with properties that reference one another, thus creating a cycle. They will go out of scope after the function call has completed. At that point they become unneeded and their allocated memory should be reclaimed. However, the reference-counting algorithm will not consider them reclaimable since each of the two objects has at least one reference pointing to them, resulting in neither of them being marked for garbage collection. Circular references are a common cause of memory leaks.
jsfunction f() {
  const x = {};
  const y = {};
  x.a = y; // x references y
  y.a = x; // y references x

  return "azerty";
}

f();
Mark-and-sweep algorithmThis algorithm reduces the definition of "an object is no longer needed" to "an object is unreachable".
This algorithm assumes the knowledge of a set of objects called roots. In JavaScript, the root is the global object. Periodically, the garbage collector will start from these roots, find all objects that are referenced from these roots, then all objects referenced from these, etc. Starting from the roots, the garbage collector will thus find all reachable objects and collect all non-reachable objects.
This algorithm is an improvement over the previous one since an object having zero references is effectively unreachable. The opposite does not hold true as we have seen with circular references.
Currently, all modern engines ship a mark-and-sweep garbage collector. All improvements made in the field of JavaScript garbage collection (generational/incremental/concurrent/parallel garbage collection) over the last few years are implementation improvements of this algorithm, but not improvements over the garbage collection algorithm itself nor its reduction of the definition of when "an object is no longer needed".
The immediate benefit of this approach is that cycles are no longer a problem. In the first example above, after the function call returns, the two objects are no longer referenced by any resource that is reachable from the global object. Consequently, they will be found unreachable by the garbage collector and have their allocated memory reclaimed.
However, the inability to manually control garbage collection remains. There are times when it would be convenient to manually decide when and what memory is released. In order to release the memory of an object, it needs to be made explicitly unreachable. It is also not possible to programmatically trigger garbage collection in JavaScript — and will likely never be within the core language, although engines may expose APIs behind opt-in flags.Configuring an engine's memory modelJavaScript engines typically offer flags that expose the memory model. For example, Node.js offers additional options and tools that expose the underlying V8 mechanisms for configuring and debugging memory issues. This configuration may not be available in browsers, and even less so for web pages (via HTTP headers, etc.).
The max amount of available heap memory can be increased with a flag:
bashnode --max-old-space-size=6000 index.js

We can also expose the garbage collector for debugging memory issues using a flag and the Chrome Debugger:
bashnode --expose-gc --inspect index.js
Data structures aiding memory managementAlthough JavaScript does not directly expose the garbage collector API, the language offers several data structures that indirectly observe garbage collection and can be used to manage memory usage.WeakMaps and WeakSetsWeakMap and WeakSet are data structures whose APIs closely mirror their non-weak counterparts: Map and Set. WeakMap allows you to maintain a collection of key-value pairs, while WeakSet allows you to maintain a collection of unique values, both with performant addition, deletion, and querying.
WeakMap and WeakSet got the name from the concept of weakly held values. If x is weakly held by y, it means that although you can access the value of x via y, the mark-and-sweep algorithm won't consider x as reachable if nothing else strongly holds to it. Most data structures, except the ones discussed here, strongly holds to the objects passed in so that you can retrieve them at any time. The keys of WeakMap and WeakSet can be garbage-collected (for WeakMap objects, the values would then be eligible for garbage collection as well) as long as nothing else in the program is referencing the key. This is ensured by two characteristics:

WeakMap and WeakSet can only store objects or symbols. This is because only objects are garbage collected — primitive values can always be forged (that is, 1 === 1 but {} !== {}), making them stay in the collection forever. Registered symbols (like Symbol.for("key")) can also be forged and thus not garbage collectable, but symbols created with Symbol("key") are garbage collectable. Well-known symbols like Symbol.iterator come in a fixed set and are unique throughout the lifetime of the program, similar to intrinsic objects such as Array.prototype, so they are also allowed as keys.
WeakMap and WeakSet are not iterable. This prevents you from using Array.from(map.keys()).length to observe the liveliness of objects, or get hold of an arbitrary key which should otherwise be eligible for garbage collection. (Garbage collection should be as invisible as possible.)

In typical explanations of WeakMap and WeakSet (such as the one above), it's often implied that the key is garbage-collected first, freeing the value for garbage collection as well. However, consider the case of the value referencing the key:
jsconst wm = new WeakMap();
const key = {};
wm.set(key, { key });
// Now `key` cannot be garbage collected,
// because the value holds a reference to the key,
// and the value is strongly held in the map!

If key is stored as an actual reference, it would create a cyclic reference and make both the key and value ineligible for garbage collection, even when nothing else references key — because if key is garbage collected, it means that at some particular instant, value.key would point to a non-existent address, which is not legal. To fix this, the entries of WeakMap and WeakSet aren't actual references, but ephemerons, an enhancement to the mark-and-sweep mechanism. Barros et al. offers a good summary of the algorithm (page 4). To quote a paragraph:

Ephemerons are a refinement of weak pairs where neither the key nor the value can be classified as weak or strong. The connectivity of the key determines the connectivity of the value, but the connectivity of the value does not affect the connectivity of the key. […] when the garbage collection offers support to ephemerons, it occurs in three phases instead of two (mark and sweep).

As a rough mental model, think of a WeakMap as the following implementation:

Warning:
This is not a polyfill nor is anywhere close to how it's implemented in the engine (which hooks into the garbage collection mechanism).

jsclass MyWeakMap {
  #marker = Symbol("MyWeakMapData");
  get(key) {
    return key[this.#marker];
  }
  set(key, value) {
    key[this.#marker] = value;
  }
  has(key) {
    return this.#marker in key;
  }
  delete(key) {
    delete key[this.#marker];
  }
}

As you can see, the MyWeakMap never actually holds a collection of keys. It simply adds metadata to each object being passed in. The object is then garbage-collectable via mark-and-sweep. Therefore, it's not possible to iterate over the keys in a WeakMap, nor clear the WeakMap (as that also relies on the knowledge of the entire key collection).
For more information on their APIs, see the keyed collections guide.WeakRefs and FinalizationRegistry
Note: WeakRef and FinalizationRegistry offer direct introspection into the garbage collection machinery. Avoid using them where possible because the runtime semantics are almost completely unguaranteed.

All variables with an object as value are references to that object. However, such references are strong — their existence would prevent the garbage collector from marking the object as eligible for collection. A WeakRef is a weak reference to an object that allows the object to be garbage collected, while still retaining the ability to read the object's content during its lifetime.
One use case for WeakRef is a cache system which maps string URLs to large objects. We cannot use a WeakMap for this purpose, because WeakMap objects have their keys weakly held, but not their values — if you access a key, you would always deterministically get the value (since having access to the key means it's still alive). Here, we are okay to get undefined for a key (if the corresponding value is no longer alive) since we can just re-compute it, but we don't want unreachable objects to stay in the cache. In this case, we can use a normal Map, but with each value being a WeakRef of the object instead of the actual object value.
jsfunction cached(getter) {
  // A Map from string URLs to WeakRefs of results
  const cache = new Map();
  return async (key) => {
    if (cache.has(key)) {
      const dereferencedValue = cache.get(key).deref();
      if (dereferencedValue !== undefined) {
        return dereferencedValue;
      }
    }
    const value = await getter(key);
    cache.set(key, new WeakRef(value));
    return value;
  };
}

const getImage = cached((url) => fetch(url).then((res) => res.blob()));

FinalizationRegistry provides an even stronger mechanism to observe garbage collection. It allows you to register objects and be notified when they are garbage collected. For example, for the cache system exemplified above, even when the blobs themselves are free for collection, the WeakRef objects that hold them are not — and over time, the Map may accumulate a lot of useless entries. Using a FinalizationRegistry allows one to perform cleanup in this case.
jsfunction cached(getter) {
  // A Map from string URLs to WeakRefs of results
  const cache = new Map();
  // Every time after a value is garbage collected, the callback is
  // called with the key in the cache as argument, allowing us to remove
  // the cache entry
  const registry = new FinalizationRegistry((key) => {
    // Note: it's important to test that the WeakRef is indeed empty.
    // Otherwise, the callback may be called after a new object has been
    // added with this key, and that new, alive object gets deleted
    if (!cache.get(key)?.deref()) {
      cache.delete(key);
    }
  });
  return async (key) => {
    if (cache.has(key)) {
      return cache.get(key).deref();
    }
    const value = await getter(key);
    cache.set(key, new WeakRef(value));
    registry.register(value, key);
    return value;
  };
}

const getImage = cached((url) => fetch(url).then((res) => res.blob()));

Due to performance and security concerns, there is no guarantee of when the callback will be called, or if it will be called at all. It should only be used for cleanup — and non-critical cleanup. There are other ways for more deterministic resource management, such as try...finally, which will always execute the finally block. WeakRef and FinalizationRegistry exist solely for optimization of memory usage in long-running programs.
For more information on the API of WeakRef and FinalizationRegistry, see their reference pages.\n\nMemory managementLow-level languages like C, have manual memory management primitives such as malloc() and free(). In contrast, JavaScript automatically allocates memory when objects are created and frees it when they are not used anymore (garbage collection). This automaticity is a potential source of confusion: it can give developers the false impression that they don't need to worry about memory management.Memory life cycleRegardless of the programming language, the memory life cycle is pretty much always the same:

Allocate the memory you need
Use the allocated memory (read, write)
Release the allocated memory when it is not needed anymore

The second part is explicit in all languages. The first and last parts are explicit in low-level languages but are mostly implicit in high-level languages like JavaScript.Allocation in JavaScriptValue initialization
In order to not bother the programmer with allocations, JavaScript will automatically allocate memory when values are initially declared.
jsconst n = 123; // allocates memory for a number
const s = "string"; // allocates memory for a string

const o = {
  a: 1,
  b: null,
}; // allocates memory for an object and contained values

// (like object) allocates memory for the array and
// contained values
const a = [1, null, "str2"];

function f(a) {
  return a + 2;
} // allocates a function (which is a callable object)

// function expressions also allocate an object
someElement.addEventListener(
  "click",
  () => {
    someElement.style.backgroundColor = "blue";
  },
  false,
);

Allocation via function calls
Some function calls result in object allocation.
jsconst d = new Date(); // allocates a Date object

const e = document.createElement("div"); // allocates a DOM element

Some methods allocate new values or objects:
jsconst s = "string";
const s2 = s.substr(0, 3); // s2 is a new string
// Since strings are immutable values,
// JavaScript may decide to not allocate memory,
// but just store the [0, 3] range.

const a = ["yeah yeah", "no no"];
const a2 = ["generation", "no no"];
const a3 = a.concat(a2);
// new array with 4 elements being
// the concatenation of a and a2 elements.
Using valuesUsing values basically means reading and writing in allocated memory. This can be done by reading or writing the value of a variable or an object property or even passing an argument to a function.Release when the memory is not needed anymoreThe majority of memory management issues occur at this phase. The most difficult aspect of this stage is determining when the allocated memory is no longer needed.
Low-level languages require the developer to manually determine at which point in the program the allocated memory is no longer needed and to release it.
Some high-level languages, such as JavaScript, utilize a form of automatic memory management known as garbage collection (GC). The purpose of a garbage collector is to monitor memory allocation and determine when a block of allocated memory is no longer needed and reclaim it. This automatic process is an approximation since the general problem of determining whether or not a specific piece of memory is still needed is undecidable.Garbage collectionAs stated above, the general problem of automatically finding whether some memory "is not needed anymore" is undecidable. As a consequence, garbage collectors implement a restriction of a solution to the general problem. This section will explain the concepts that are necessary for understanding the main garbage collection algorithms and their respective limitations.ReferencesThe main concept that garbage collection algorithms rely on is the concept of reference. Within the context of memory management, an object is said to reference another object if the former has access to the latter (either implicitly or explicitly). For instance, a JavaScript object has a reference to its prototype (implicit reference) and to its properties values (explicit reference).
In this context, the notion of an "object" is extended to something broader than regular JavaScript objects and also contain function scopes (or the global lexical scope).Reference-counting garbage collection
Note:
No modern JavaScript engine uses reference-counting for garbage collection anymore.

This is the most naïve garbage collection algorithm. This algorithm reduces the problem from determining whether or not an object is still needed to determining if an object still has any other objects referencing it. An object is said to be "garbage", or collectible if there are zero references pointing to it.
For example:
jslet x = {
  a: {
    b: 2,
  },
};
// 2 objects are created. One is referenced by the other as one of its properties.
// The other is referenced by virtue of being assigned to the 'x' variable.
// Obviously, none can be garbage-collected.

let y = x;
// The 'y' variable is the second thing that has a reference to the object.

x = 1;
// Now, the object that was originally in 'x' has a unique reference
// embodied by the 'y' variable.

let z = y.a;
// Reference to 'a' property of the object.
// This object now has 2 references: one as a property,
// the other as the 'z' variable.

y = "mozilla";
// The object that was originally in 'x' has now zero
// references to it. It can be garbage-collected.
// However its 'a' property is still referenced by
// the 'z' variable, so it cannot be freed.

z = null;
// The 'a' property of the object originally in x
// has zero references to it. It can be garbage collected.

There is a limitation when it comes to circular references. In the following example, two objects are created with properties that reference one another, thus creating a cycle. They will go out of scope after the function call has completed. At that point they become unneeded and their allocated memory should be reclaimed. However, the reference-counting algorithm will not consider them reclaimable since each of the two objects has at least one reference pointing to them, resulting in neither of them being marked for garbage collection. Circular references are a common cause of memory leaks.
jsfunction f() {
  const x = {};
  const y = {};
  x.a = y; // x references y
  y.a = x; // y references x

  return "azerty";
}

f();
Mark-and-sweep algorithmThis algorithm reduces the definition of "an object is no longer needed" to "an object is unreachable".
This algorithm assumes the knowledge of a set of objects called roots. In JavaScript, the root is the global object. Periodically, the garbage collector will start from these roots, find all objects that are referenced from these roots, then all objects referenced from these, etc. Starting from the roots, the garbage collector will thus find all reachable objects and collect all non-reachable objects.
This algorithm is an improvement over the previous one since an object having zero references is effectively unreachable. The opposite does not hold true as we have seen with circular references.
Currently, all modern engines ship a mark-and-sweep garbage collector. All improvements made in the field of JavaScript garbage collection (generational/incremental/concurrent/parallel garbage collection) over the last few years are implementation improvements of this algorithm, but not improvements over the garbage collection algorithm itself nor its reduction of the definition of when "an object is no longer needed".
The immediate benefit of this approach is that cycles are no longer a problem. In the first example above, after the function call returns, the two objects are no longer referenced by any resource that is reachable from the global object. Consequently, they will be found unreachable by the garbage collector and have their allocated memory reclaimed.
However, the inability to manually control garbage collection remains. There are times when it would be convenient to manually decide when and what memory is released. In order to release the memory of an object, it needs to be made explicitly unreachable. It is also not possible to programmatically trigger garbage collection in JavaScript — and will likely never be within the core language, although engines may expose APIs behind opt-in flags.Configuring an engine's memory modelJavaScript engines typically offer flags that expose the memory model. For example, Node.js offers additional options and tools that expose the underlying V8 mechanisms for configuring and debugging memory issues. This configuration may not be available in browsers, and even less so for web pages (via HTTP headers, etc.).
The max amount of available heap memory can be increased with a flag:
bashnode --max-old-space-size=6000 index.js

We can also expose the garbage collector for debugging memory issues using a flag and the Chrome Debugger:
bashnode --expose-gc --inspect index.js
Data structures aiding memory managementAlthough JavaScript does not directly expose the garbage collector API, the language offers several data structures that indirectly observe garbage collection and can be used to manage memory usage.WeakMaps and WeakSetsWeakMap and WeakSet are data structures whose APIs closely mirror their non-weak counterparts: Map and Set. WeakMap allows you to maintain a collection of key-value pairs, while WeakSet allows you to maintain a collection of unique values, both with performant addition, deletion, and querying.
WeakMap and WeakSet got the name from the concept of weakly held values. If x is weakly held by y, it means that although you can access the value of x via y, the mark-and-sweep algorithm won't consider x as reachable if nothing else strongly holds to it. Most data structures, except the ones discussed here, strongly holds to the objects passed in so that you can retrieve them at any time. The keys of WeakMap and WeakSet can be garbage-collected (for WeakMap objects, the values would then be eligible for garbage collection as well) as long as nothing else in the program is referencing the key. This is ensured by two characteristics:

WeakMap and WeakSet can only store objects or symbols. This is because only objects are garbage collected — primitive values can always be forged (that is, 1 === 1 but {} !== {}), making them stay in the collection forever. Registered symbols (like Symbol.for("key")) can also be forged and thus not garbage collectable, but symbols created with Symbol("key") are garbage collectable. Well-known symbols like Symbol.iterator come in a fixed set and are unique throughout the lifetime of the program, similar to intrinsic objects such as Array.prototype, so they are also allowed as keys.
WeakMap and WeakSet are not iterable. This prevents you from using Array.from(map.keys()).length to observe the liveliness of objects, or get hold of an arbitrary key which should otherwise be eligible for garbage collection. (Garbage collection should be as invisible as possible.)

In typical explanations of WeakMap and WeakSet (such as the one above), it's often implied that the key is garbage-collected first, freeing the value for garbage collection as well. However, consider the case of the value referencing the key:
jsconst wm = new WeakMap();
const key = {};
wm.set(key, { key });
// Now `key` cannot be garbage collected,
// because the value holds a reference to the key,
// and the value is strongly held in the map!

If key is stored as an actual reference, it would create a cyclic reference and make both the key and value ineligible for garbage collection, even when nothing else references key — because if key is garbage collected, it means that at some particular instant, value.key would point to a non-existent address, which is not legal. To fix this, the entries of WeakMap and WeakSet aren't actual references, but ephemerons, an enhancement to the mark-and-sweep mechanism. Barros et al. offers a good summary of the algorithm (page 4). To quote a paragraph:

Ephemerons are a refinement of weak pairs where neither the key nor the value can be classified as weak or strong. The connectivity of the key determines the connectivity of the value, but the connectivity of the value does not affect the connectivity of the key. […] when the garbage collection offers support to ephemerons, it occurs in three phases instead of two (mark and sweep).

As a rough mental model, think of a WeakMap as the following implementation:

Warning:
This is not a polyfill nor is anywhere close to how it's implemented in the engine (which hooks into the garbage collection mechanism).

jsclass MyWeakMap {
  #marker = Symbol("MyWeakMapData");
  get(key) {
    return key[this.#marker];
  }
  set(key, value) {
    key[this.#marker] = value;
  }
  has(key) {
    return this.#marker in key;
  }
  delete(key) {
    delete key[this.#marker];
  }
}

As you can see, the MyWeakMap never actually holds a collection of keys. It simply adds metadata to each object being passed in. The object is then garbage-collectable via mark-and-sweep. Therefore, it's not possible to iterate over the keys in a WeakMap, nor clear the WeakMap (as that also relies on the knowledge of the entire key collection).
For more information on their APIs, see the keyed collections guide.WeakRefs and FinalizationRegistry
Note: WeakRef and FinalizationRegistry offer direct introspection into the garbage collection machinery. Avoid using them where possible because the runtime semantics are almost completely unguaranteed.

All variables with an object as value are references to that object. However, such references are strong — their existence would prevent the garbage collector from marking the object as eligible for collection. A WeakRef is a weak reference to an object that allows the object to be garbage collected, while still retaining the ability to read the object's content during its lifetime.
One use case for WeakRef is a cache system which maps string URLs to large objects. We cannot use a WeakMap for this purpose, because WeakMap objects have their keys weakly held, but not their values — if you access a key, you would always deterministically get the value (since having access to the key means it's still alive). Here, we are okay to get undefined for a key (if the corresponding value is no longer alive) since we can just re-compute it, but we don't want unreachable objects to stay in the cache. In this case, we can use a normal Map, but with each value being a WeakRef of the object instead of the actual object value.
jsfunction cached(getter) {
  // A Map from string URLs to WeakRefs of results
  const cache = new Map();
  return async (key) => {
    if (cache.has(key)) {
      const dereferencedValue = cache.get(key).deref();
      if (dereferencedValue !== undefined) {
        return dereferencedValue;
      }
    }
    const value = await getter(key);
    cache.set(key, new WeakRef(value));
    return value;
  };
}

const getImage = cached((url) => fetch(url).then((res) => res.blob()));

FinalizationRegistry provides an even stronger mechanism to observe garbage collection. It allows you to register objects and be notified when they are garbage collected. For example, for the cache system exemplified above, even when the blobs themselves are free for collection, the WeakRef objects that hold them are not — and over time, the Map may accumulate a lot of useless entries. Using a FinalizationRegistry allows one to perform cleanup in this case.
jsfunction cached(getter) {
  // A Map from string URLs to WeakRefs of results
  const cache = new Map();
  // Every time after a value is garbage collected, the callback is
  // called with the key in the cache as argument, allowing us to remove
  // the cache entry
  const registry = new FinalizationRegistry((key) => {
    // Note: it's important to test that the WeakRef is indeed empty.
    // Otherwise, the callback may be called after a new object has been
    // added with this key, and that new, alive object gets deleted
    if (!cache.get(key)?.deref()) {
      cache.delete(key);
    }
  });
  return async (key) => {
    if (cache.has(key)) {
      return cache.get(key).deref();
    }
    const value = await getter(key);
    cache.set(key, new WeakRef(value));
    registry.register(value, key);
    return value;
  };
}

const getImage = cached((url) => fetch(url).then((res) => res.blob()));

Due to performance and security concerns, there is no guarantee of when the callback will be called, or if it will be called at all. It should only be used for cleanup — and non-critical cleanup. There are other ways for more deterministic resource management, such as try...finally, which will always execute the finally block. WeakRef and FinalizationRegistry exist solely for optimization of memory usage in long-running programs.
For more information on the API of WeakRef and FinalizationRegistry, see their reference pages.Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nMemory managementLow-level languages like C, have manual memory management primitives such as malloc() and free(). In contrast, JavaScript automatically allocates memory when objects are created and frees it when they are not used anymore (garbage collection). This automaticity is a potential source of confusion: it can give developers the false impression that they don't need to worry about memory management.Memory life cycleRegardless of the programming language, the memory life cycle is pretty much always the same:

Allocate the memory you need
Use the allocated memory (read, write)
Release the allocated memory when it is not needed anymore

The second part is explicit in all languages. The first and last parts are explicit in low-level languages but are mostly implicit in high-level languages like JavaScript.Allocation in JavaScriptValue initialization
In order to not bother the programmer with allocations, JavaScript will automatically allocate memory when values are initially declared.
jsconst n = 123; // allocates memory for a number
const s = "string"; // allocates memory for a string

const o = {
  a: 1,
  b: null,
}; // allocates memory for an object and contained values

// (like object) allocates memory for the array and
// contained values
const a = [1, null, "str2"];

function f(a) {
  return a + 2;
} // allocates a function (which is a callable object)

// function expressions also allocate an object
someElement.addEventListener(
  "click",
  () => {
    someElement.style.backgroundColor = "blue";
  },
  false,
);

Allocation via function calls
Some function calls result in object allocation.
jsconst d = new Date(); // allocates a Date object

const e = document.createElement("div"); // allocates a DOM element

Some methods allocate new values or objects:
jsconst s = "string";
const s2 = s.substr(0, 3); // s2 is a new string
// Since strings are immutable values,
// JavaScript may decide to not allocate memory,
// but just store the [0, 3] range.

const a = ["yeah yeah", "no no"];
const a2 = ["generation", "no no"];
const a3 = a.concat(a2);
// new array with 4 elements being
// the concatenation of a and a2 elements.
Using valuesUsing values basically means reading and writing in allocated memory. This can be done by reading or writing the value of a variable or an object property or even passing an argument to a function.Release when the memory is not needed anymoreThe majority of memory management issues occur at this phase. The most difficult aspect of this stage is determining when the allocated memory is no longer needed.
Low-level languages require the developer to manually determine at which point in the program the allocated memory is no longer needed and to release it.
Some high-level languages, such as JavaScript, utilize a form of automatic memory management known as garbage collection (GC). The purpose of a garbage collector is to monitor memory allocation and determine when a block of allocated memory is no longer needed and reclaim it. This automatic process is an approximation since the general problem of determining whether or not a specific piece of memory is still needed is undecidable.Garbage collectionAs stated above, the general problem of automatically finding whether some memory "is not needed anymore" is undecidable. As a consequence, garbage collectors implement a restriction of a solution to the general problem. This section will explain the concepts that are necessary for understanding the main garbage collection algorithms and their respective limitations.ReferencesThe main concept that garbage collection algorithms rely on is the concept of reference. Within the context of memory management, an object is said to reference another object if the former has access to the latter (either implicitly or explicitly). For instance, a JavaScript object has a reference to its prototype (implicit reference) and to its properties values (explicit reference).
In this context, the notion of an "object" is extended to something broader than regular JavaScript objects and also contain function scopes (or the global lexical scope).Reference-counting garbage collection
Note:
No modern JavaScript engine uses reference-counting for garbage collection anymore.

This is the most naïve garbage collection algorithm. This algorithm reduces the problem from determining whether or not an object is still needed to determining if an object still has any other objects referencing it. An object is said to be "garbage", or collectible if there are zero references pointing to it.
For example:
jslet x = {
  a: {
    b: 2,
  },
};
// 2 objects are created. One is referenced by the other as one of its properties.
// The other is referenced by virtue of being assigned to the 'x' variable.
// Obviously, none can be garbage-collected.

let y = x;
// The 'y' variable is the second thing that has a reference to the object.

x = 1;
// Now, the object that was originally in 'x' has a unique reference
// embodied by the 'y' variable.

let z = y.a;
// Reference to 'a' property of the object.
// This object now has 2 references: one as a property,
// the other as the 'z' variable.

y = "mozilla";
// The object that was originally in 'x' has now zero
// references to it. It can be garbage-collected.
// However its 'a' property is still referenced by
// the 'z' variable, so it cannot be freed.

z = null;
// The 'a' property of the object originally in x
// has zero references to it. It can be garbage collected.

There is a limitation when it comes to circular references. In the following example, two objects are created with properties that reference one another, thus creating a cycle. They will go out of scope after the function call has completed. At that point they become unneeded and their allocated memory should be reclaimed. However, the reference-counting algorithm will not consider them reclaimable since each of the two objects has at least one reference pointing to them, resulting in neither of them being marked for garbage collection. Circular references are a common cause of memory leaks.
jsfunction f() {
  const x = {};
  const y = {};
  x.a = y; // x references y
  y.a = x; // y references x

  return "azerty";
}

f();
Mark-and-sweep algorithmThis algorithm reduces the definition of "an object is no longer needed" to "an object is unreachable".
This algorithm assumes the knowledge of a set of objects called roots. In JavaScript, the root is the global object. Periodically, the garbage collector will start from these roots, find all objects that are referenced from these roots, then all objects referenced from these, etc. Starting from the roots, the garbage collector will thus find all reachable objects and collect all non-reachable objects.
This algorithm is an improvement over the previous one since an object having zero references is effectively unreachable. The opposite does not hold true as we have seen with circular references.
Currently, all modern engines ship a mark-and-sweep garbage collector. All improvements made in the field of JavaScript garbage collection (generational/incremental/concurrent/parallel garbage collection) over the last few years are implementation improvements of this algorithm, but not improvements over the garbage collection algorithm itself nor its reduction of the definition of when "an object is no longer needed".
The immediate benefit of this approach is that cycles are no longer a problem. In the first example above, after the function call returns, the two objects are no longer referenced by any resource that is reachable from the global object. Consequently, they will be found unreachable by the garbage collector and have their allocated memory reclaimed.
However, the inability to manually control garbage collection remains. There are times when it would be convenient to manually decide when and what memory is released. In order to release the memory of an object, it needs to be made explicitly unreachable. It is also not possible to programmatically trigger garbage collection in JavaScript — and will likely never be within the core language, although engines may expose APIs behind opt-in flags.Configuring an engine's memory modelJavaScript engines typically offer flags that expose the memory model. For example, Node.js offers additional options and tools that expose the underlying V8 mechanisms for configuring and debugging memory issues. This configuration may not be available in browsers, and even less so for web pages (via HTTP headers, etc.).
The max amount of available heap memory can be increased with a flag:
bashnode --max-old-space-size=6000 index.js

We can also expose the garbage collector for debugging memory issues using a flag and the Chrome Debugger:
bashnode --expose-gc --inspect index.js
Data structures aiding memory managementAlthough JavaScript does not directly expose the garbage collector API, the language offers several data structures that indirectly observe garbage collection and can be used to manage memory usage.WeakMaps and WeakSetsWeakMap and WeakSet are data structures whose APIs closely mirror their non-weak counterparts: Map and Set. WeakMap allows you to maintain a collection of key-value pairs, while WeakSet allows you to maintain a collection of unique values, both with performant addition, deletion, and querying.
WeakMap and WeakSet got the name from the concept of weakly held values. If x is weakly held by y, it means that although you can access the value of x via y, the mark-and-sweep algorithm won't consider x as reachable if nothing else strongly holds to it. Most data structures, except the ones discussed here, strongly holds to the objects passed in so that you can retrieve them at any time. The keys of WeakMap and WeakSet can be garbage-collected (for WeakMap objects, the values would then be eligible for garbage collection as well) as long as nothing else in the program is referencing the key. This is ensured by two characteristics:

WeakMap and WeakSet can only store objects or symbols. This is because only objects are garbage collected — primitive values can always be forged (that is, 1 === 1 but {} !== {}), making them stay in the collection forever. Registered symbols (like Symbol.for("key")) can also be forged and thus not garbage collectable, but symbols created with Symbol("key") are garbage collectable. Well-known symbols like Symbol.iterator come in a fixed set and are unique throughout the lifetime of the program, similar to intrinsic objects such as Array.prototype, so they are also allowed as keys.
WeakMap and WeakSet are not iterable. This prevents you from using Array.from(map.keys()).length to observe the liveliness of objects, or get hold of an arbitrary key which should otherwise be eligible for garbage collection. (Garbage collection should be as invisible as possible.)

In typical explanations of WeakMap and WeakSet (such as the one above), it's often implied that the key is garbage-collected first, freeing the value for garbage collection as well. However, consider the case of the value referencing the key:
jsconst wm = new WeakMap();
const key = {};
wm.set(key, { key });
// Now `key` cannot be garbage collected,
// because the value holds a reference to the key,
// and the value is strongly held in the map!

If key is stored as an actual reference, it would create a cyclic reference and make both the key and value ineligible for garbage collection, even when nothing else references key — because if key is garbage collected, it means that at some particular instant, value.key would point to a non-existent address, which is not legal. To fix this, the entries of WeakMap and WeakSet aren't actual references, but ephemerons, an enhancement to the mark-and-sweep mechanism. Barros et al. offers a good summary of the algorithm (page 4). To quote a paragraph:

Ephemerons are a refinement of weak pairs where neither the key nor the value can be classified as weak or strong. The connectivity of the key determines the connectivity of the value, but the connectivity of the value does not affect the connectivity of the key. […] when the garbage collection offers support to ephemerons, it occurs in three phases instead of two (mark and sweep).

As a rough mental model, think of a WeakMap as the following implementation:

Warning:
This is not a polyfill nor is anywhere close to how it's implemented in the engine (which hooks into the garbage collection mechanism).

jsclass MyWeakMap {
  #marker = Symbol("MyWeakMapData");
  get(key) {
    return key[this.#marker];
  }
  set(key, value) {
    key[this.#marker] = value;
  }
  has(key) {
    return this.#marker in key;
  }
  delete(key) {
    delete key[this.#marker];
  }
}

As you can see, the MyWeakMap never actually holds a collection of keys. It simply adds metadata to each object being passed in. The object is then garbage-collectable via mark-and-sweep. Therefore, it's not possible to iterate over the keys in a WeakMap, nor clear the WeakMap (as that also relies on the knowledge of the entire key collection).
For more information on their APIs, see the keyed collections guide.WeakRefs and FinalizationRegistry
Note: WeakRef and FinalizationRegistry offer direct introspection into the garbage collection machinery. Avoid using them where possible because the runtime semantics are almost completely unguaranteed.

All variables with an object as value are references to that object. However, such references are strong — their existence would prevent the garbage collector from marking the object as eligible for collection. A WeakRef is a weak reference to an object that allows the object to be garbage collected, while still retaining the ability to read the object's content during its lifetime.
One use case for WeakRef is a cache system which maps string URLs to large objects. We cannot use a WeakMap for this purpose, because WeakMap objects have their keys weakly held, but not their values — if you access a key, you would always deterministically get the value (since having access to the key means it's still alive). Here, we are okay to get undefined for a key (if the corresponding value is no longer alive) since we can just re-compute it, but we don't want unreachable objects to stay in the cache. In this case, we can use a normal Map, but with each value being a WeakRef of the object instead of the actual object value.
jsfunction cached(getter) {
  // A Map from string URLs to WeakRefs of results
  const cache = new Map();
  return async (key) => {
    if (cache.has(key)) {
      const dereferencedValue = cache.get(key).deref();
      if (dereferencedValue !== undefined) {
        return dereferencedValue;
      }
    }
    const value = await getter(key);
    cache.set(key, new WeakRef(value));
    return value;
  };
}

const getImage = cached((url) => fetch(url).then((res) => res.blob()));

FinalizationRegistry provides an even stronger mechanism to observe garbage collection. It allows you to register objects and be notified when they are garbage collected. For example, for the cache system exemplified above, even when the blobs themselves are free for collection, the WeakRef objects that hold them are not — and over time, the Map may accumulate a lot of useless entries. Using a FinalizationRegistry allows one to perform cleanup in this case.
jsfunction cached(getter) {
  // A Map from string URLs to WeakRefs of results
  const cache = new Map();
  // Every time after a value is garbage collected, the callback is
  // called with the key in the cache as argument, allowing us to remove
  // the cache entry
  const registry = new FinalizationRegistry((key) => {
    // Note: it's important to test that the WeakRef is indeed empty.
    // Otherwise, the callback may be called after a new object has been
    // added with this key, and that new, alive object gets deleted
    if (!cache.get(key)?.deref()) {
      cache.delete(key);
    }
  });
  return async (key) => {
    if (cache.has(key)) {
      return cache.get(key).deref();
    }
    const value = await getter(key);
    cache.set(key, new WeakRef(value));
    registry.register(value, key);
    return value;
  };
}

const getImage = cached((url) => fetch(url).then((res) => res.blob()));

Due to performance and security concerns, there is no guarantee of when the callback will be called, or if it will be called at all. It should only be used for cleanup — and non-critical cleanup. There are other ways for more deterministic resource management, such as try...finally, which will always execute the finally block. WeakRef and FinalizationRegistry exist solely for optimization of memory usage in long-running programs.
For more information on the API of WeakRef and FinalizationRegistry, see their reference pages.Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nStandard built-in objectsThis chapter documents all of JavaScript's standard, built-in objects, including their methods and properties.
The term "global objects" (or standard built-in objects) here is not to be confused with the global object. Here, "global objects" refer to objects in the global scope.
The global object itself can be accessed using the this operator in the global scope. In fact, the global scope consists of the properties of the global object, including inherited properties, if any.
Other objects in the global scope are either created by the user script or provided by the host application. The host objects available in browser contexts are documented in the API reference.
For more information about the distinction between the DOM and core JavaScript, see JavaScript technologies overview.Standard objects by categoryValue propertiesThese global properties return a simple value. They have no properties or methods.

globalThis
Infinity
NaN
undefined
Function propertiesThese global functions—functions which are called globally, rather than on an object—directly return their results to the caller.

eval()
isFinite()
isNaN()
parseFloat()
parseInt()
decodeURI()
decodeURIComponent()
encodeURI()
encodeURIComponent()
escape() 
Deprecated

unescape() 
Deprecated

Fundamental objectsThese objects represent fundamental language constructs.

Object
Function
Boolean
Symbol
Error objectsError objects are a special type of fundamental object. They include the basic Error type, as well as several specialized error types.

Error
AggregateError
EvalError
RangeError
ReferenceError
SyntaxError
TypeError
URIError
InternalError 
Non-standard

Numbers and datesThese are the base objects representing numbers, dates, and mathematical calculations.

Number
BigInt
Math
Date
Temporal
Text processingThese objects represent strings and support manipulating them.

String
RegExp
Indexed collectionsThese objects represent collections of data which are ordered by an index value. This includes (typed) arrays and array-like constructs.

Array
TypedArray
Int8Array
Uint8Array
Uint8ClampedArray
Int16Array
Uint16Array
Int32Array
Uint32Array
BigInt64Array
BigUint64Array
Float16Array
Float32Array
Float64Array
Keyed collectionsThese objects represent collections which use keys. The iterable collections (Map and Set) contain elements which are easily iterated in the order of insertion.

Map
Set
WeakMap
WeakSet
Structured dataThese objects represent and interact with structured data buffers and data coded using JavaScript Object Notation (JSON).

ArrayBuffer
SharedArrayBuffer
DataView
Atomics
JSON
Managing memoryThese objects interact with the garbage collection mechanism.

WeakRef
FinalizationRegistry
Control abstraction objectsControl abstractions can help to structure code, especially async code (without using deeply nested callbacks, for example).

Iterator
AsyncIterator
Promise
GeneratorFunction
AsyncGeneratorFunction
Generator
AsyncGenerator
AsyncFunction
Reflection
Reflect
Proxy
InternationalizationAdditions to the ECMAScript core for language-sensitive functionalities.

Intl
Intl.Collator
Intl.DateTimeFormat
Intl.DisplayNames
Intl.DurationFormat
Intl.ListFormat
Intl.Locale
Intl.NumberFormat
Intl.PluralRules
Intl.RelativeTimeFormat
Intl.Segmenter\n\nStandard built-in objectsThis chapter documents all of JavaScript's standard, built-in objects, including their methods and properties.
The term "global objects" (or standard built-in objects) here is not to be confused with the global object. Here, "global objects" refer to objects in the global scope.
The global object itself can be accessed using the this operator in the global scope. In fact, the global scope consists of the properties of the global object, including inherited properties, if any.
Other objects in the global scope are either created by the user script or provided by the host application. The host objects available in browser contexts are documented in the API reference.
For more information about the distinction between the DOM and core JavaScript, see JavaScript technologies overview.Standard objects by categoryValue propertiesThese global properties return a simple value. They have no properties or methods.

globalThis
Infinity
NaN
undefined
Function propertiesThese global functions—functions which are called globally, rather than on an object—directly return their results to the caller.

eval()
isFinite()
isNaN()
parseFloat()
parseInt()
decodeURI()
decodeURIComponent()
encodeURI()
encodeURIComponent()
escape() 
Deprecated

unescape() 
Deprecated

Fundamental objectsThese objects represent fundamental language constructs.

Object
Function
Boolean
Symbol
Error objectsError objects are a special type of fundamental object. They include the basic Error type, as well as several specialized error types.

Error
AggregateError
EvalError
RangeError
ReferenceError
SyntaxError
TypeError
URIError
InternalError 
Non-standard

Numbers and datesThese are the base objects representing numbers, dates, and mathematical calculations.

Number
BigInt
Math
Date
Temporal
Text processingThese objects represent strings and support manipulating them.

String
RegExp
Indexed collectionsThese objects represent collections of data which are ordered by an index value. This includes (typed) arrays and array-like constructs.

Array
TypedArray
Int8Array
Uint8Array
Uint8ClampedArray
Int16Array
Uint16Array
Int32Array
Uint32Array
BigInt64Array
BigUint64Array
Float16Array
Float32Array
Float64Array
Keyed collectionsThese objects represent collections which use keys. The iterable collections (Map and Set) contain elements which are easily iterated in the order of insertion.

Map
Set
WeakMap
WeakSet
Structured dataThese objects represent and interact with structured data buffers and data coded using JavaScript Object Notation (JSON).

ArrayBuffer
SharedArrayBuffer
DataView
Atomics
JSON
Managing memoryThese objects interact with the garbage collection mechanism.

WeakRef
FinalizationRegistry
Control abstraction objectsControl abstractions can help to structure code, especially async code (without using deeply nested callbacks, for example).

Iterator
AsyncIterator
Promise
GeneratorFunction
AsyncGeneratorFunction
Generator
AsyncGenerator
AsyncFunction
Reflection
Reflect
Proxy
InternationalizationAdditions to the ECMAScript core for language-sensitive functionalities.

Intl
Intl.Collator
Intl.DateTimeFormat
Intl.DisplayNames
Intl.DurationFormat
Intl.ListFormat
Intl.Locale
Intl.NumberFormat
Intl.PluralRules
Intl.RelativeTimeFormat
Intl.Segmenter
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 12, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nStandard built-in objectsThis chapter documents all of JavaScript's standard, built-in objects, including their methods and properties.
The term "global objects" (or standard built-in objects) here is not to be confused with the global object. Here, "global objects" refer to objects in the global scope.
The global object itself can be accessed using the this operator in the global scope. In fact, the global scope consists of the properties of the global object, including inherited properties, if any.
Other objects in the global scope are either created by the user script or provided by the host application. The host objects available in browser contexts are documented in the API reference.
For more information about the distinction between the DOM and core JavaScript, see JavaScript technologies overview.Standard objects by categoryValue propertiesThese global properties return a simple value. They have no properties or methods.

globalThis
Infinity
NaN
undefined
Function propertiesThese global functions—functions which are called globally, rather than on an object—directly return their results to the caller.

eval()
isFinite()
isNaN()
parseFloat()
parseInt()
decodeURI()
decodeURIComponent()
encodeURI()
encodeURIComponent()
escape() 
Deprecated

unescape() 
Deprecated

Fundamental objectsThese objects represent fundamental language constructs.

Object
Function
Boolean
Symbol
Error objectsError objects are a special type of fundamental object. They include the basic Error type, as well as several specialized error types.

Error
AggregateError
EvalError
RangeError
ReferenceError
SyntaxError
TypeError
URIError
InternalError 
Non-standard

Numbers and datesThese are the base objects representing numbers, dates, and mathematical calculations.

Number
BigInt
Math
Date
Temporal
Text processingThese objects represent strings and support manipulating them.

String
RegExp
Indexed collectionsThese objects represent collections of data which are ordered by an index value. This includes (typed) arrays and array-like constructs.

Array
TypedArray
Int8Array
Uint8Array
Uint8ClampedArray
Int16Array
Uint16Array
Int32Array
Uint32Array
BigInt64Array
BigUint64Array
Float16Array
Float32Array
Float64Array
Keyed collectionsThese objects represent collections which use keys. The iterable collections (Map and Set) contain elements which are easily iterated in the order of insertion.

Map
Set
WeakMap
WeakSet
Structured dataThese objects represent and interact with structured data buffers and data coded using JavaScript Object Notation (JSON).

ArrayBuffer
SharedArrayBuffer
DataView
Atomics
JSON
Managing memoryThese objects interact with the garbage collection mechanism.

WeakRef
FinalizationRegistry
Control abstraction objectsControl abstractions can help to structure code, especially async code (without using deeply nested callbacks, for example).

Iterator
AsyncIterator
Promise
GeneratorFunction
AsyncGeneratorFunction
Generator
AsyncGenerator
AsyncFunction
Reflection
Reflect
Proxy
InternationalizationAdditions to the ECMAScript core for language-sensitive functionalities.

Intl
Intl.Collator
Intl.DateTimeFormat
Intl.DisplayNames
Intl.DurationFormat
Intl.ListFormat
Intl.Locale
Intl.NumberFormat
Intl.PluralRules
Intl.RelativeTimeFormat
Intl.Segmenter
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 12, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nAggregateErrorBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2020.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe AggregateError object represents an error when several errors need to be wrapped in a single error. It is thrown when multiple errors need to be reported by an operation, for example by Promise.any(), when all promises passed to it reject.
AggregateError is a subclass of Error.Constructor
AggregateError()

Creates a new AggregateError object.

Instance propertiesAlso inherits instance properties from its parent Error.
These properties are defined on AggregateError.prototype and shared by all AggregateError instances.

AggregateError.prototype.constructor

The constructor function that created the instance object. For AggregateError instances, the initial value is the AggregateError constructor.

AggregateError.prototype.name

Represents the name for the type of error. For AggregateError.prototype.name, the initial value is "AggregateError".


These properties are own properties of each AggregateError instance.

errors

An array representing the errors that were aggregated.

Instance methodsInherits instance methods from its parent Error.ExamplesCatching an AggregateErrorjsPromise.any([Promise.reject(new Error("some error"))]).catch((e) => {
  console.log(e instanceof AggregateError); // true
  console.log(e.message); // "All Promises rejected"
  console.log(e.name); // "AggregateError"
  console.log(e.errors); // [ Error: "some error" ]
});
Creating an AggregateErrorjstry {
  throw new AggregateError([new Error("some error")], "Hello");
} catch (e) {
  console.log(e instanceof AggregateError); // true
  console.log(e.message); // "Hello"
  console.log(e.name); // "AggregateError"
  console.log(e.errors); // [ Error: "some error" ]
}
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-aggregate-error-objectsBrowser compatibilitySee also
Polyfill of AggregateError in core-js
es-shims polyfill of AggregateError
Error
Promise.any\n\nAggregateErrorBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2020.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe AggregateError object represents an error when several errors need to be wrapped in a single error. It is thrown when multiple errors need to be reported by an operation, for example by Promise.any(), when all promises passed to it reject.
AggregateError is a subclass of Error.Constructor
AggregateError()

Creates a new AggregateError object.

Instance propertiesAlso inherits instance properties from its parent Error.
These properties are defined on AggregateError.prototype and shared by all AggregateError instances.

AggregateError.prototype.constructor

The constructor function that created the instance object. For AggregateError instances, the initial value is the AggregateError constructor.

AggregateError.prototype.name

Represents the name for the type of error. For AggregateError.prototype.name, the initial value is "AggregateError".


These properties are own properties of each AggregateError instance.

errors

An array representing the errors that were aggregated.

Instance methodsInherits instance methods from its parent Error.ExamplesCatching an AggregateErrorjsPromise.any([Promise.reject(new Error("some error"))]).catch((e) => {
  console.log(e instanceof AggregateError); // true
  console.log(e.message); // "All Promises rejected"
  console.log(e.name); // "AggregateError"
  console.log(e.errors); // [ Error: "some error" ]
});
Creating an AggregateErrorjstry {
  throw new AggregateError([new Error("some error")], "Hello");
} catch (e) {
  console.log(e instanceof AggregateError); // true
  console.log(e.message); // "Hello"
  console.log(e.name); // "AggregateError"
  console.log(e.errors); // [ Error: "some error" ]
}
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-aggregate-error-objectsBrowser compatibilitySee also
Polyfill of AggregateError in core-js
es-shims polyfill of AggregateError
Error
Promise.any
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 5, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nAggregateErrorBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2020.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe AggregateError object represents an error when several errors need to be wrapped in a single error. It is thrown when multiple errors need to be reported by an operation, for example by Promise.any(), when all promises passed to it reject.
AggregateError is a subclass of Error.Constructor
AggregateError()

Creates a new AggregateError object.

Instance propertiesAlso inherits instance properties from its parent Error.
These properties are defined on AggregateError.prototype and shared by all AggregateError instances.

AggregateError.prototype.constructor

The constructor function that created the instance object. For AggregateError instances, the initial value is the AggregateError constructor.

AggregateError.prototype.name

Represents the name for the type of error. For AggregateError.prototype.name, the initial value is "AggregateError".


These properties are own properties of each AggregateError instance.

errors

An array representing the errors that were aggregated.

Instance methodsInherits instance methods from its parent Error.ExamplesCatching an AggregateErrorjsPromise.any([Promise.reject(new Error("some error"))]).catch((e) => {
  console.log(e instanceof AggregateError); // true
  console.log(e.message); // "All Promises rejected"
  console.log(e.name); // "AggregateError"
  console.log(e.errors); // [ Error: "some error" ]
});
Creating an AggregateErrorjstry {
  throw new AggregateError([new Error("some error")], "Hello");
} catch (e) {
  console.log(e instanceof AggregateError); // true
  console.log(e.message); // "Hello"
  console.log(e.name); // "AggregateError"
  console.log(e.errors); // [ Error: "some error" ]
}
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-aggregate-error-objectsBrowser compatibilitySee also
Polyfill of AggregateError in core-js
es-shims polyfill of AggregateError
Error
Promise.any
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 5, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nArrayBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Array object, as with arrays in other programming languages, enables storing a collection of multiple items under a single variable name, and has members for performing common array operations.DescriptionIn JavaScript, arrays aren't primitives but are instead Array objects with the following core characteristics:

JavaScript arrays are resizable and can contain a mix of different data types. (When those characteristics are undesirable, use typed arrays instead.)
JavaScript arrays are not associative arrays and so, array elements cannot be accessed using arbitrary strings as indexes, but must be accessed using nonnegative integers (or their respective string form) as indexes.
JavaScript arrays are zero-indexed: the first element of an array is at index 0, the second is at index 1, and so on — and the last element is at the value of the array's length property minus 1.
JavaScript array-copy operations create shallow copies. (All standard built-in copy operations with any JavaScript objects create shallow copies, rather than deep copies).
Array indicesArray objects cannot use arbitrary strings as element indexes (as in an associative array) but must use nonnegative integers (or their respective string form). Setting or accessing via non-integers will not set or retrieve an element from the array list itself, but will set or access a variable associated with that array's object property collection. The array's object properties and list of array elements are separate, and the array's traversal and mutation operations cannot be applied to these named properties.
Array elements are object properties in the same way that toString is a property (to be specific, however, toString() is a method). Nevertheless, trying to access an element of an array as follows throws a syntax error because the property name is not valid:
jsarr.0; // a syntax error

JavaScript syntax requires properties beginning with a digit to be accessed using bracket notation instead of dot notation. It's also possible to quote the array indices (e.g., years['2'] instead of years[2]), although usually not necessary.
The 2 in years[2] is coerced into a string by the JavaScript engine through an implicit toString conversion. As a result, '2' and '02' would refer to two different slots on the years object, and the following example could be true:
jsconsole.log(years["2"] !== years["02"]);

Only years['2'] is an actual array index. years['02'] is an arbitrary string property that will not be visited in array iteration.Relationship between length and numerical propertiesA JavaScript array's length property and numerical properties are connected.
Several of the built-in array methods (e.g., join(), slice(), indexOf(), etc.) take into account the value of an array's length property when they're called.
Other methods (e.g., push(), splice(), etc.) also result in updates to an array's length property.
jsconst fruits = [];
fruits.push("banana", "apple", "peach");
console.log(fruits.length); // 3

When setting a property on a JavaScript array when the property is a valid array index and that index is outside the current bounds of the array, the engine will update the array's length property accordingly:
jsfruits[5] = "mango";
console.log(fruits[5]); // 'mango'
console.log(Object.keys(fruits)); // ['0', '1', '2', '5']
console.log(fruits.length); // 6

Increasing the length extends the array by adding empty slots without creating any new elements — not even undefined.
jsfruits.length = 10;
console.log(fruits); // ['banana', 'apple', 'peach', empty x 2, 'mango', empty x 4]
console.log(Object.keys(fruits)); // ['0', '1', '2', '5']
console.log(fruits.length); // 10
console.log(fruits[8]); // undefined

Decreasing the length property does, however, delete elements.
jsfruits.length = 2;
console.log(Object.keys(fruits)); // ['0', '1']
console.log(fruits.length); // 2

This is explained further on the length page.Array methods and empty slotsArray methods have different behaviors when encountering empty slots in sparse arrays. In general, older methods (e.g., forEach) treat empty slots differently from indices that contain undefined.
Methods that have special treatment for empty slots include the following: concat(), copyWithin(), every(), filter(), flat(), flatMap(), forEach(), indexOf(), lastIndexOf(), map(), reduce(), reduceRight(), reverse(), slice(), some(), sort(), and splice(). Iteration methods such as forEach don't visit empty slots at all. Other methods, such as concat, copyWithin, etc., preserve empty slots when doing the copying, so in the end the array is still sparse.
jsconst colors = ["red", "yellow", "blue"];
colors[5] = "purple";
colors.forEach((item, index) => {
  console.log(`${index}: ${item}`);
});
// Output:
// 0: red
// 1: yellow
// 2: blue
// 5: purple

colors.reverse(); // ['purple', empty × 2, 'blue', 'yellow', 'red']

Newer methods (e.g., keys) do not treat empty slots specially and treat them as if they contain undefined. Methods that conflate empty slots with undefined elements include the following: entries(), fill(), find(), findIndex(), findLast(), findLastIndex(), includes(), join(), keys(), toLocaleString(), toReversed(), toSorted(), toSpliced(), values(), and with().
jsconst colors = ["red", "yellow", "blue"];
colors[5] = "purple";
const iterator = colors.keys();
for (const key of iterator) {
  console.log(`${key}: ${colors[key]}`);
}
// Output
// 0: red
// 1: yellow
// 2: blue
// 3: undefined
// 4: undefined
// 5: purple

const newColors = colors.toReversed(); // ['purple', undefined, undefined, 'blue', 'yellow', 'red']
Copying methods and mutating methodsSome methods do not mutate the existing array that the method was called on, but instead return a new array. They do so by first constructing a new array and then populating it with elements. The copy always happens shallowly — the method never copies anything beyond the initially created array. Elements of the original array(s) are copied into the new array as follows:

Objects: the object reference is copied into the new array. Both the original and new array refer to the same object. That is, if a referenced object is modified, the changes are visible to both the new and original arrays.
Primitive types such as strings, numbers and booleans (not String, Number, and Boolean objects): their values are copied into the new array.

Other methods mutate the array that the method was called on, in which case their return value differs depending on the method: sometimes a reference to the same array, sometimes the length of the new array.
The following methods create new arrays by accessing this.constructor[Symbol.species] to determine the constructor to use: concat(), filter(), flat(), flatMap(), map(), slice(), and splice() (to construct the array of removed elements that's returned).
The following methods always create new arrays with the Array base constructor: toReversed(), toSorted(), toSpliced(), and with().
The following table lists the methods that mutate the original array, and the corresponding non-mutating alternative:



Mutating method
Non-mutating alternative




copyWithin()
No one-method alternative


fill()
No one-method alternative


pop()
slice(0, -1)


push(v1, v2)
concat([v1, v2])


reverse()
toReversed()


shift()
slice(1)


sort()
toSorted()


splice()
toSpliced()


unshift(v1, v2)
toSpliced(0, 0, v1, v2)



An easy way to change a mutating method into a non-mutating alternative is to use the spread syntax or slice() to create a copy first:
jsarr.copyWithin(0, 1, 2); // mutates arr
const arr2 = arr.slice().copyWithin(0, 1, 2); // does not mutate arr
const arr3 = [...arr].copyWithin(0, 1, 2); // does not mutate arr
Iterative methodsMany array methods take a callback function as an argument. The callback function is called sequentially and at most once for each element in the array, and the return value of the callback function is used to determine the return value of the method. They all share the same signature:
jsmethod(callbackFn, thisArg)

Where callbackFn takes three arguments:

element

The current element being processed in the array.

index

The index of the current element being processed in the array.

array

The array that the method was called upon.


What callbackFn is expected to return depends on the array method that was called.
The thisArg argument (defaults to undefined) will be used as the this value when calling callbackFn. The this value ultimately observable by callbackFn is determined according to the usual rules: if callbackFn is non-strict, primitive this values are wrapped into objects, and undefined/null is substituted with globalThis. The thisArg argument is irrelevant for any callbackFn defined with an arrow function, as arrow functions don't have their own this binding.
The array argument passed to callbackFn is most useful if you want to read another index during iteration, because you may not always have an existing variable that refers to the current array. You should generally not mutate the array during iteration (see mutating initial array in iterative methods), but you can also use this argument to do so. The array argument is not the array that is being built, in the case of methods like map(), filter(), and flatMap() — there is no way to access the array being built from the callback function.
All iterative methods are copying and generic, although they behave differently with empty slots.
The following methods are iterative: every(), filter(), find(), findIndex(), findLast(), findLastIndex(), flatMap(), forEach(), map(), and some().
In particular, every(), find(), findIndex(), findLast(), findLastIndex(), and some() do not always invoke callbackFn on every element — they stop iteration as soon as the return value is determined.
The reduce() and reduceRight() methods also take a callback function and run it at most once for each element in the array, but they have slightly different signatures from typical iterative methods (for example, they don't accept thisArg).
The sort() method also takes a callback function, but it is not an iterative method. It mutates the array in-place, doesn't accept thisArg, and may invoke the callback multiple times on an index.
Iterative methods iterate the array like the following (with a lot of technical details omitted):
jsfunction method(callbackFn, thisArg) {
  const length = this.length;
  for (let i = 0; i < length; i++) {
    if (i in this) {
      const result = callbackFn.call(thisArg, this[i], i, this);
      // Do something with result; maybe return early
    }
  }
}

Note the following:

Not all methods do the i in this test. The find, findIndex, findLast, and findLastIndex methods do not, but other methods do.
The length is memorized before the loop starts. This affects how insertions and deletions during iteration are handled (see mutating initial array in iterative methods).
The method doesn't memorize the array contents, so if any index is modified during iteration, the new value might be observed.
The code above iterates the array in ascending order of index. Some methods iterate in descending order of index (for (let i = length - 1; i >= 0; i--)): reduceRight(), findLast(), and findLastIndex().
reduce and reduceRight have slightly different signatures and do not always start at the first/last element.
Generic array methodsArray methods are always generic — they don't access any internal data of the array object. They only access the array elements through the length property and the indexed elements. This means that they can be called on array-like objects as well.
jsconst arrayLike = {
  0: "a",
  1: "b",
  length: 2,
};
console.log(Array.prototype.join.call(arrayLike, "+")); // 'a+b'

Normalization of the length property
The length property is converted to an integer and then clamped to the range between 0 and 253 - 1. NaN becomes 0, so even when length is not present or is undefined, it behaves as if it has value 0.
The language avoids setting length to an unsafe integer. All built-in methods will throw a TypeError if length will be set to a number greater than 253 - 1. However, because the length property of arrays throws an error if it's set to greater than 232 - 1, the safe integer threshold is usually not reached unless the method is called on a non-array object.
jsArray.prototype.flat.call({}); // []

Some array methods set the length property of the array object. They always set the value after normalization, so length always ends as an integer.
jsconst a = { length: 0.7 };
Array.prototype.push.call(a);
console.log(a.length); // 0

Array-like objects
The term array-like object refers to any object that doesn't throw during the length conversion process described above. In practice, such object is expected to actually have a length property and to have indexed elements in the range 0 to length - 1. (If it doesn't have all indices, it will be functionally equivalent to a sparse array.) Any integer index less than zero or greater than length - 1 is ignored when an array method operates on an array-like object.
Many DOM objects are array-like — for example, NodeList and HTMLCollection. The arguments object is also array-like. You can call array methods on them even if they don't have these methods themselves.
jsfunction f() {
  console.log(Array.prototype.join.call(arguments, "+"));
}

f("a", "b"); // 'a+b'
Constructor
Array()

Creates a new Array object.

Static properties
Array[Symbol.species]

Returns the Array constructor.

Static methods
Array.from()

Creates a new Array instance from an iterable or array-like object.

Array.fromAsync()

Creates a new Array instance from an async iterable, iterable, or array-like object.

Array.isArray()

Returns true if the argument is an array, or false otherwise.

Array.of()

Creates a new Array instance with a variable number of arguments, regardless of number or type of the arguments.

Instance propertiesThese properties are defined on Array.prototype and shared by all Array instances.

Array.prototype.constructor

The constructor function that created the instance object. For Array instances, the initial value is the Array constructor.

Array.prototype[Symbol.unscopables]

Contains property names that were not included in the ECMAScript standard prior to the ES2015 version and that are ignored for with statement-binding purposes.


These properties are own properties of each Array instance.

length

Reflects the number of elements in an array.

Instance methods
Array.prototype.at()

Returns the array item at the given index. Accepts negative integers, which count back from the last item.

Array.prototype.concat()

Returns a new array that is the calling array joined with other array(s) and/or value(s).

Array.prototype.copyWithin()

Copies a sequence of array elements within an array.

Array.prototype.entries()

Returns a new array iterator object that contains the key/value pairs for each index in an array.

Array.prototype.every()

Returns true if every element in the calling array satisfies the testing function.

Array.prototype.fill()

Fills all the elements of an array from a start index to an end index with a static value.

Array.prototype.filter()

Returns a new array containing all elements of the calling array for which the provided filtering function returns true.

Array.prototype.find()

Returns the value of the first element in the array that satisfies the provided testing function, or undefined if no appropriate element is found.

Array.prototype.findIndex()

Returns the index of the first element in the array that satisfies the provided testing function, or -1 if no appropriate element was found.

Array.prototype.findLast()

Returns the value of the last element in the array that satisfies the provided testing function, or undefined if no appropriate element is found.

Array.prototype.findLastIndex()

Returns the index of the last element in the array that satisfies the provided testing function, or -1 if no appropriate element was found.

Array.prototype.flat()

Returns a new array with all sub-array elements concatenated into it recursively up to the specified depth.

Array.prototype.flatMap()

Returns a new array formed by applying a given callback function to each element of the calling array, and then flattening the result by one level.

Array.prototype.forEach()

Calls a function for each element in the calling array.

Array.prototype.includes()

Determines whether the calling array contains a value, returning true or false as appropriate.

Array.prototype.indexOf()

Returns the first (least) index at which a given element can be found in the calling array.

Array.prototype.join()

Joins all elements of an array into a string.

Array.prototype.keys()

Returns a new array iterator that contains the keys for each index in the calling array.

Array.prototype.lastIndexOf()

Returns the last (greatest) index at which a given element can be found in the calling array, or -1 if none is found.

Array.prototype.map()

Returns a new array containing the results of invoking a function on every element in the calling array.

Array.prototype.pop()

Removes the last element from an array and returns that element.

Array.prototype.push()

Adds one or more elements to the end of an array, and returns the new length of the array.

Array.prototype.reduce()

Executes a user-supplied "reducer" callback function on each element of the array (from left to right), to reduce it to a single value.

Array.prototype.reduceRight()

Executes a user-supplied "reducer" callback function on each element of the array (from right to left), to reduce it to a single value.

Array.prototype.reverse()

Reverses the order of the elements of an array in place. (First becomes the last, last becomes first.)

Array.prototype.shift()

Removes the first element from an array and returns that element.

Array.prototype.slice()

Extracts a section of the calling array and returns a new array.

Array.prototype.some()

Returns true if at least one element in the calling array satisfies the provided testing function.

Array.prototype.sort()

Sorts the elements of an array in place and returns the array.

Array.prototype.splice()

Adds and/or removes elements from an array.

Array.prototype.toLocaleString()

Returns a localized string representing the calling array and its elements. Overrides the Object.prototype.toLocaleString() method.

Array.prototype.toReversed()

Returns a new array with the elements in reversed order, without modifying the original array.

Array.prototype.toSorted()

Returns a new array with the elements sorted in ascending order, without modifying the original array.

Array.prototype.toSpliced()

Returns a new array with some elements removed and/or replaced at a given index, without modifying the original array.

Array.prototype.toString()

Returns a string representing the calling array and its elements. Overrides the Object.prototype.toString() method.

Array.prototype.unshift()

Adds one or more elements to the front of an array, and returns the new length of the array.

Array.prototype.values()

Returns a new array iterator object that contains the values for each index in the array.

Array.prototype.with()

Returns a new array with the element at the given index replaced with the given value, without modifying the original array.

Array.prototype[Symbol.iterator]()

An alias for the values() method by default.

ExamplesThis section provides some examples of common array operations in JavaScript.

Note:
If you're not yet familiar with array basics, consider first reading JavaScript First Steps: Arrays, which explains what arrays are, and includes other examples of common array operations.
Create an arrayThis example shows three ways to create new array: first using array literal notation, then using the Array() constructor, and finally using String.prototype.split() to build the array from a string.
js// 'fruits' array created using array literal notation.
const fruits = ["Apple", "Banana"];
console.log(fruits.length);
// 2

// 'fruits2' array created using the Array() constructor.
const fruits2 = new Array("Apple", "Banana");
console.log(fruits2.length);
// 2

// 'fruits3' array created using String.prototype.split().
const fruits3 = "Apple, Banana".split(", ");
console.log(fruits3.length);
// 2
Create a string from an arrayThis example uses the join() method to create a string from the fruits array.
jsconst fruits = ["Apple", "Banana"];
const fruitsString = fruits.join(", ");
console.log(fruitsString);
// "Apple, Banana"
Access an array item by its indexThis example shows how to access items in the fruits array by specifying the index number of their position in the array.
jsconst fruits = ["Apple", "Banana"];

// The index of an array's first element is always 0.
fruits[0]; // Apple

// The index of an array's second element is always 1.
fruits[1]; // Banana

// The index of an array's last element is always one
// less than the length of the array.
fruits[fruits.length - 1]; // Banana

// Using an index number larger than the array's length
// returns 'undefined'.
fruits[99]; // undefined
Find the index of an item in an arrayThis example uses the indexOf() method to find the position (index) of the string "Banana" in the fruits array.
jsconst fruits = ["Apple", "Banana"];
console.log(fruits.indexOf("Banana"));
// 1
Check if an array contains a certain itemThis example shows two ways to check if the fruits array contains "Banana" and "Cherry": first with the includes() method, and then with the indexOf() method to test for an index value that's not -1.
jsconst fruits = ["Apple", "Banana"];

fruits.includes("Banana"); // true
fruits.includes("Cherry"); // false

// If indexOf() doesn't return -1, the array contains the given item.
fruits.indexOf("Banana") !== -1; // true
fruits.indexOf("Cherry") !== -1; // false
Append an item to an arrayThis example uses the push() method to append a new string to the fruits array.
jsconst fruits = ["Apple", "Banana"];
const newLength = fruits.push("Orange");
console.log(fruits);
// ["Apple", "Banana", "Orange"]
console.log(newLength);
// 3
Remove the last item from an arrayThis example uses the pop() method to remove the last item from the fruits array.
jsconst fruits = ["Apple", "Banana", "Orange"];
const removedItem = fruits.pop();
console.log(fruits);
// ["Apple", "Banana"]
console.log(removedItem);
// Orange


Note: pop() can only be used to remove the last item from an array. To remove multiple items from the end of an array, see the next example.
Remove multiple items from the end of an arrayThis example uses the splice() method to remove the last 3 items from the fruits array.
jsconst fruits = ["Apple", "Banana", "Strawberry", "Mango", "Cherry"];
const start = -3;
const removedItems = fruits.splice(start);
console.log(fruits);
// ["Apple", "Banana"]
console.log(removedItems);
// ["Strawberry", "Mango", "Cherry"]
Truncate an array down to just its first N itemsThis example uses the splice() method to truncate the fruits array down to just its first 2 items.
jsconst fruits = ["Apple", "Banana", "Strawberry", "Mango", "Cherry"];
const start = 2;
const removedItems = fruits.splice(start);
console.log(fruits);
// ["Apple", "Banana"]
console.log(removedItems);
// ["Strawberry", "Mango", "Cherry"]
Remove the first item from an arrayThis example uses the shift() method to remove the first item from the fruits array.
jsconst fruits = ["Apple", "Banana"];
const removedItem = fruits.shift();
console.log(fruits);
// ["Banana"]
console.log(removedItem);
// Apple


Note: shift() can only be used to remove the first item from an array. To remove multiple items from the beginning of an array, see the next example.
Remove multiple items from the beginning of an arrayThis example uses the splice() method to remove the first 3 items from the fruits array.
jsconst fruits = ["Apple", "Strawberry", "Cherry", "Banana", "Mango"];
const start = 0;
const deleteCount = 3;
const removedItems = fruits.splice(start, deleteCount);
console.log(fruits);
// ["Banana", "Mango"]
console.log(removedItems);
// ["Apple", "Strawberry", "Cherry"]
Add a new first item to an arrayThis example uses the unshift() method to add, at index 0, a new item to the fruits array — making it the new first item in the array.
jsconst fruits = ["Banana", "Mango"];
const newLength = fruits.unshift("Strawberry");
console.log(fruits);
// ["Strawberry", "Banana", "Mango"]
console.log(newLength);
// 3
Remove a single item by indexThis example uses the splice() method to remove the string "Banana" from the fruits array — by specifying the index position of "Banana".
jsconst fruits = ["Strawberry", "Banana", "Mango"];
const start = fruits.indexOf("Banana");
const deleteCount = 1;
const removedItems = fruits.splice(start, deleteCount);
console.log(fruits);
// ["Strawberry", "Mango"]
console.log(removedItems);
// ["Banana"]
Remove multiple items by indexThis example uses the splice() method to remove the strings "Banana" and "Strawberry" from the fruits array — by specifying the index position of "Banana", along with a count of the number of total items to remove.
jsconst fruits = ["Apple", "Banana", "Strawberry", "Mango"];
const start = 1;
const deleteCount = 2;
const removedItems = fruits.splice(start, deleteCount);
console.log(fruits);
// ["Apple", "Mango"]
console.log(removedItems);
// ["Banana", "Strawberry"]
Replace multiple items in an arrayThis example uses the splice() method to replace the last 2 items in the fruits array with new items.
jsconst fruits = ["Apple", "Banana", "Strawberry"];
const start = -2;
const deleteCount = 2;
const removedItems = fruits.splice(start, deleteCount, "Mango", "Cherry");
console.log(fruits);
// ["Apple", "Mango", "Cherry"]
console.log(removedItems);
// ["Banana", "Strawberry"]
Iterate over an arrayThis example uses a for...of loop to iterate over the fruits array, logging each item to the console.
jsconst fruits = ["Apple", "Mango", "Cherry"];
for (const fruit of fruits) {
  console.log(fruit);
}
// Apple
// Mango
// Cherry

But for...of is just one of many ways to iterate over any array; for more ways, see Loops and iteration, and see the documentation for the every(), filter(), flatMap(), map(), reduce(), and reduceRight() methods — and see the next example, which uses the forEach() method.Call a function on each element in an arrayThis example uses the forEach() method to call a function on each element in the fruits array; the function causes each item to be logged to the console, along with the item's index number.
jsconst fruits = ["Apple", "Mango", "Cherry"];
fruits.forEach((item, index, array) => {
  console.log(item, index);
});
// Apple 0
// Mango 1
// Cherry 2
Merge multiple arrays togetherThis example uses the concat() method to merge the fruits array with a moreFruits array, to produce a new combinedFruits array. Notice that fruits and moreFruits remain unchanged.
jsconst fruits = ["Apple", "Banana", "Strawberry"];
const moreFruits = ["Mango", "Cherry"];
const combinedFruits = fruits.concat(moreFruits);
console.log(combinedFruits);
// ["Apple", "Banana", "Strawberry", "Mango", "Cherry"]

// The 'fruits' array remains unchanged.
console.log(fruits);
// ["Apple", "Banana", "Strawberry"]

// The 'moreFruits' array also remains unchanged.
console.log(moreFruits);
// ["Mango", "Cherry"]
Copy an arrayThis example shows three ways to create a new array from the existing fruits array: first by using spread syntax, then by using the from() method, and then by using the slice() method.
jsconst fruits = ["Strawberry", "Mango"];

// Create a copy using spread syntax.
const fruitsCopy = [...fruits];
// ["Strawberry", "Mango"]

// Create a copy using the from() method.
const fruitsCopy2 = Array.from(fruits);
// ["Strawberry", "Mango"]

// Create a copy using the slice() method.
const fruitsCopy3 = fruits.slice();
// ["Strawberry", "Mango"]

All built-in array-copy operations (spread syntax, Array.from(), Array.prototype.slice(), and Array.prototype.concat()) create shallow copies. If you instead want a deep copy of an array, you can use JSON.stringify() to convert the array to a JSON string, and then JSON.parse() to convert the string back into a new array that's completely independent from the original array.
jsconst fruitsDeepCopy = JSON.parse(JSON.stringify(fruits));

You can also create deep copies using the structuredClone() method, which has the advantage of allowing transferable objects in the source to be transferred to the new copy, rather than just cloned.
Finally, it's important to understand that assigning an existing array to a new variable doesn't create a copy of either the array or its elements. Instead the new variable is just a reference, or alias, to the original array; that is, the original array's name and the new variable name are just two names for the exact same object (and so will always evaluate as strictly equivalent). Therefore, if you make any changes at all either to the value of the original array or to the value of the new variable, the other will change, too:
jsconst fruits = ["Strawberry", "Mango"];
const fruitsAlias = fruits;
// 'fruits' and 'fruitsAlias' are the same object, strictly equivalent.
fruits === fruitsAlias; // true
// Any changes to the 'fruits' array change 'fruitsAlias' too.
fruits.unshift("Apple", "Banana");
console.log(fruits);
// ['Apple', 'Banana', 'Strawberry', 'Mango']
console.log(fruitsAlias);
// ['Apple', 'Banana', 'Strawberry', 'Mango']
Creating a two-dimensional arrayThe following creates a chessboard as a two-dimensional array of strings. The first move is made by copying the 'p' in board[6][4] to board[4][4]. The old position at [6][4] is made blank.
jsconst board = [
  ["R", "N", "B", "Q", "K", "B", "N", "R"],
  ["P", "P", "P", "P", "P", "P", "P", "P"],
  [" ", " ", " ", " ", " ", " ", " ", " "],
  [" ", " ", " ", " ", " ", " ", " ", " "],
  [" ", " ", " ", " ", " ", " ", " ", " "],
  [" ", " ", " ", " ", " ", " ", " ", " "],
  ["p", "p", "p", "p", "p", "p", "p", "p"],
  ["r", "n", "b", "q", "k", "b", "n", "r"],
];

console.log(`${board.join("\n")}\n\n`);

// Move King's Pawn forward 2
board[4][4] = board[6][4];
board[6][4] = " ";
console.log(board.join("\n"));

Here is the output:
R,N,B,Q,K,B,N,R
P,P,P,P,P,P,P,P
 , , , , , , ,
 , , , , , , ,
 , , , , , , ,
 , , , , , , ,
p,p,p,p,p,p,p,p
r,n,b,q,k,b,n,r

R,N,B,Q,K,B,N,R
P,P,P,P,P,P,P,P
 , , , , , , ,
 , , , , , , ,
 , , , ,p, , ,
 , , , , , , ,
p,p,p,p, ,p,p,p
r,n,b,q,k,b,n,r
Using an array to tabulate a set of valuesjsconst values = [];
for (let x = 0; x < 10; x++) {
  values.push([2 ** x, 2 * x ** 2]);
}
console.table(values);

Results in
// The first column is the index
0  1    0
1  2    2
2  4    8
3  8    18
4  16   32
5  32   50
6  64   72
7  128  98
8  256  128
9  512  162
Creating an array using the result of a matchThe result of a match between a RegExp and a string can create a JavaScript array that has properties and elements which provide information about the match. Such an array is returned by RegExp.prototype.exec() and String.prototype.match().
For example:
js// Match one d followed by one or more b's followed by one d
// Remember matched b's and the following d
// Ignore case

const myRe = /d(b+)(d)/i;
const execResult = myRe.exec("cdbBdbsbz");

console.log(execResult.input); // 'cdbBdbsbz'
console.log(execResult.index); // 1
console.log(execResult); // [ "dbBd", "bB", "d" ]

For more information about the result of a match, see the RegExp.prototype.exec() and String.prototype.match() pages.Mutating initial array in iterative methodsIterative methods do not mutate the array on which it is called, but the function provided as callbackFn can. The key principle to remember is that only indexes between 0 and arrayLength - 1 are visited, where arrayLength is the length of the array at the time the array method was first called, but the element passed to the callback is the value at the time the index is visited. Therefore:

callbackFn will not visit any elements added beyond the array's initial length when the call to the iterative method began.
Changes to already-visited indexes do not cause callbackFn to be invoked on them again.
If an existing, yet-unvisited element of the array is changed by callbackFn, its value passed to the callbackFn will be the value at the time that element gets visited. Removed elements are not visited.


Warning:
Concurrent modifications of the kind described above frequently lead to hard-to-understand code and are generally to be avoided (except in special cases).

The following examples use the forEach method as an example, but other methods that visit indexes in ascending order work in the same way. We will first define a helper function:
jsfunction testSideEffect(effect) {
  const arr = ["e1", "e2", "e3", "e4"];
  arr.forEach((elem, index, arr) => {
    console.log(`array: [${arr.join(", ")}], index: ${index}, elem: ${elem}`);
    effect(arr, index);
  });
  console.log(`Final array: [${arr.join(", ")}]`);
}

Modification to indexes not visited yet will be visible once the index is reached:
jstestSideEffect((arr, index) => {
  if (index + 1 < arr.length) arr[index + 1] += "*";
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2*, e3, e4], index: 1, elem: e2*
// array: [e1, e2*, e3*, e4], index: 2, elem: e3*
// array: [e1, e2*, e3*, e4*], index: 3, elem: e4*
// Final array: [e1, e2*, e3*, e4*]

Modification to already visited indexes does not change iteration behavior, although the array will be different afterwards:
jstestSideEffect((arr, index) => {
  if (index > 0) arr[index - 1] += "*";
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2, e3, e4], index: 1, elem: e2
// array: [e1*, e2, e3, e4], index: 2, elem: e3
// array: [e1*, e2*, e3, e4], index: 3, elem: e4
// Final array: [e1*, e2*, e3*, e4]

Inserting n elements at unvisited indexes that are less than the initial array length will make them be visited. The last n elements in the original array that now have index greater than the initial array length will not be visited:
jstestSideEffect((arr, index) => {
  if (index === 1) arr.splice(2, 0, "new");
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2, e3, e4], index: 1, elem: e2
// array: [e1, e2, new, e3, e4], index: 2, elem: new
// array: [e1, e2, new, e3, e4], index: 3, elem: e3
// Final array: [e1, e2, new, e3, e4]
// e4 is not visited because it now has index 4

Inserting n elements with index greater than the initial array length will not make them be visited:
jstestSideEffect((arr) => arr.push("new"));
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2, e3, e4, new], index: 1, elem: e2
// array: [e1, e2, e3, e4, new, new], index: 2, elem: e3
// array: [e1, e2, e3, e4, new, new, new], index: 3, elem: e4
// Final array: [e1, e2, e3, e4, new, new, new, new]

Inserting n elements at already visited indexes will not make them be visited, but it shifts remaining elements back by n, so the current index and the n - 1 elements before it are visited again:
jstestSideEffect((arr, index) => arr.splice(index, 0, "new"));
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [new, e1, e2, e3, e4], index: 1, elem: e1
// array: [new, new, e1, e2, e3, e4], index: 2, elem: e1
// array: [new, new, new, e1, e2, e3, e4], index: 3, elem: e1
// Final array: [new, new, new, new, e1, e2, e3, e4]
// e1 keeps getting visited because it keeps getting shifted back

Deleting n elements at unvisited indexes will make them not be visited anymore. Because the array has shrunk, the last n iterations will visit out-of-bounds indexes. If the method ignores non-existent indexes (see array methods and empty slots), the last n iterations will be skipped; otherwise, they will receive undefined:
jstestSideEffect((arr, index) => {
  if (index === 1) arr.splice(2, 1);
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2, e3, e4], index: 1, elem: e2
// array: [e1, e2, e4], index: 2, elem: e4
// Final array: [e1, e2, e4]
// Does not visit index 3 because it's out-of-bounds

// Compare this with find(), which treats nonexistent indexes as undefined:
const arr2 = ["e1", "e2", "e3", "e4"];
arr2.find((elem, index, arr) => {
  console.log(`array: [${arr.join(", ")}], index: ${index}, elem: ${elem}`);
  if (index === 1) arr.splice(2, 1);
  return false;
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2, e3, e4], index: 1, elem: e2
// array: [e1, e2, e4], index: 2, elem: e4
// array: [e1, e2, e4], index: 3, elem: undefined

Deleting n elements at already visited indexes does not change the fact that they were visited before they get deleted. Because the array has shrunk, the next n elements after the current index are skipped. If the method ignores non-existent indexes, the last n iterations will be skipped; otherwise, they will receive undefined:
jstestSideEffect((arr, index) => arr.splice(index, 1));
// array: [e1, e2, e3, e4], index: 0, elem: e1
// Does not visit e2 because e2 now has index 0, which has already been visited
// array: [e2, e3, e4], index: 1, elem: e3
// Does not visit e4 because e4 now has index 1, which has already been visited
// Final array: [e2, e4]
// Index 2 is out-of-bounds, so it's not visited

// Compare this with find(), which treats nonexistent indexes as undefined:
const arr2 = ["e1", "e2", "e3", "e4"];
arr2.find((elem, index, arr) => {
  console.log(`array: [${arr.join(", ")}], index: ${index}, elem: ${elem}`);
  arr.splice(index, 1);
  return false;
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e2, e3, e4], index: 1, elem: e3
// array: [e2, e4], index: 2, elem: undefined
// array: [e2, e4], index: 3, elem: undefined

For methods that iterate in descending order of index, insertion causes elements to be skipped, and deletion causes elements to be visited multiple times. Adjust the code above yourself to see the effects.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-array-objectsBrowser compatibilitySee also
Indexed collections guide
TypedArray
ArrayBuffer\n\nArrayBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Array object, as with arrays in other programming languages, enables storing a collection of multiple items under a single variable name, and has members for performing common array operations.DescriptionIn JavaScript, arrays aren't primitives but are instead Array objects with the following core characteristics:

JavaScript arrays are resizable and can contain a mix of different data types. (When those characteristics are undesirable, use typed arrays instead.)
JavaScript arrays are not associative arrays and so, array elements cannot be accessed using arbitrary strings as indexes, but must be accessed using nonnegative integers (or their respective string form) as indexes.
JavaScript arrays are zero-indexed: the first element of an array is at index 0, the second is at index 1, and so on — and the last element is at the value of the array's length property minus 1.
JavaScript array-copy operations create shallow copies. (All standard built-in copy operations with any JavaScript objects create shallow copies, rather than deep copies).
Array indicesArray objects cannot use arbitrary strings as element indexes (as in an associative array) but must use nonnegative integers (or their respective string form). Setting or accessing via non-integers will not set or retrieve an element from the array list itself, but will set or access a variable associated with that array's object property collection. The array's object properties and list of array elements are separate, and the array's traversal and mutation operations cannot be applied to these named properties.
Array elements are object properties in the same way that toString is a property (to be specific, however, toString() is a method). Nevertheless, trying to access an element of an array as follows throws a syntax error because the property name is not valid:
jsarr.0; // a syntax error

JavaScript syntax requires properties beginning with a digit to be accessed using bracket notation instead of dot notation. It's also possible to quote the array indices (e.g., years['2'] instead of years[2]), although usually not necessary.
The 2 in years[2] is coerced into a string by the JavaScript engine through an implicit toString conversion. As a result, '2' and '02' would refer to two different slots on the years object, and the following example could be true:
jsconsole.log(years["2"] !== years["02"]);

Only years['2'] is an actual array index. years['02'] is an arbitrary string property that will not be visited in array iteration.Relationship between length and numerical propertiesA JavaScript array's length property and numerical properties are connected.
Several of the built-in array methods (e.g., join(), slice(), indexOf(), etc.) take into account the value of an array's length property when they're called.
Other methods (e.g., push(), splice(), etc.) also result in updates to an array's length property.
jsconst fruits = [];
fruits.push("banana", "apple", "peach");
console.log(fruits.length); // 3

When setting a property on a JavaScript array when the property is a valid array index and that index is outside the current bounds of the array, the engine will update the array's length property accordingly:
jsfruits[5] = "mango";
console.log(fruits[5]); // 'mango'
console.log(Object.keys(fruits)); // ['0', '1', '2', '5']
console.log(fruits.length); // 6

Increasing the length extends the array by adding empty slots without creating any new elements — not even undefined.
jsfruits.length = 10;
console.log(fruits); // ['banana', 'apple', 'peach', empty x 2, 'mango', empty x 4]
console.log(Object.keys(fruits)); // ['0', '1', '2', '5']
console.log(fruits.length); // 10
console.log(fruits[8]); // undefined

Decreasing the length property does, however, delete elements.
jsfruits.length = 2;
console.log(Object.keys(fruits)); // ['0', '1']
console.log(fruits.length); // 2

This is explained further on the length page.Array methods and empty slotsArray methods have different behaviors when encountering empty slots in sparse arrays. In general, older methods (e.g., forEach) treat empty slots differently from indices that contain undefined.
Methods that have special treatment for empty slots include the following: concat(), copyWithin(), every(), filter(), flat(), flatMap(), forEach(), indexOf(), lastIndexOf(), map(), reduce(), reduceRight(), reverse(), slice(), some(), sort(), and splice(). Iteration methods such as forEach don't visit empty slots at all. Other methods, such as concat, copyWithin, etc., preserve empty slots when doing the copying, so in the end the array is still sparse.
jsconst colors = ["red", "yellow", "blue"];
colors[5] = "purple";
colors.forEach((item, index) => {
  console.log(`${index}: ${item}`);
});
// Output:
// 0: red
// 1: yellow
// 2: blue
// 5: purple

colors.reverse(); // ['purple', empty × 2, 'blue', 'yellow', 'red']

Newer methods (e.g., keys) do not treat empty slots specially and treat them as if they contain undefined. Methods that conflate empty slots with undefined elements include the following: entries(), fill(), find(), findIndex(), findLast(), findLastIndex(), includes(), join(), keys(), toLocaleString(), toReversed(), toSorted(), toSpliced(), values(), and with().
jsconst colors = ["red", "yellow", "blue"];
colors[5] = "purple";
const iterator = colors.keys();
for (const key of iterator) {
  console.log(`${key}: ${colors[key]}`);
}
// Output
// 0: red
// 1: yellow
// 2: blue
// 3: undefined
// 4: undefined
// 5: purple

const newColors = colors.toReversed(); // ['purple', undefined, undefined, 'blue', 'yellow', 'red']
Copying methods and mutating methodsSome methods do not mutate the existing array that the method was called on, but instead return a new array. They do so by first constructing a new array and then populating it with elements. The copy always happens shallowly — the method never copies anything beyond the initially created array. Elements of the original array(s) are copied into the new array as follows:

Objects: the object reference is copied into the new array. Both the original and new array refer to the same object. That is, if a referenced object is modified, the changes are visible to both the new and original arrays.
Primitive types such as strings, numbers and booleans (not String, Number, and Boolean objects): their values are copied into the new array.

Other methods mutate the array that the method was called on, in which case their return value differs depending on the method: sometimes a reference to the same array, sometimes the length of the new array.
The following methods create new arrays by accessing this.constructor[Symbol.species] to determine the constructor to use: concat(), filter(), flat(), flatMap(), map(), slice(), and splice() (to construct the array of removed elements that's returned).
The following methods always create new arrays with the Array base constructor: toReversed(), toSorted(), toSpliced(), and with().
The following table lists the methods that mutate the original array, and the corresponding non-mutating alternative:



Mutating method
Non-mutating alternative




copyWithin()
No one-method alternative


fill()
No one-method alternative


pop()
slice(0, -1)


push(v1, v2)
concat([v1, v2])


reverse()
toReversed()


shift()
slice(1)


sort()
toSorted()


splice()
toSpliced()


unshift(v1, v2)
toSpliced(0, 0, v1, v2)



An easy way to change a mutating method into a non-mutating alternative is to use the spread syntax or slice() to create a copy first:
jsarr.copyWithin(0, 1, 2); // mutates arr
const arr2 = arr.slice().copyWithin(0, 1, 2); // does not mutate arr
const arr3 = [...arr].copyWithin(0, 1, 2); // does not mutate arr
Iterative methodsMany array methods take a callback function as an argument. The callback function is called sequentially and at most once for each element in the array, and the return value of the callback function is used to determine the return value of the method. They all share the same signature:
jsmethod(callbackFn, thisArg)

Where callbackFn takes three arguments:

element

The current element being processed in the array.

index

The index of the current element being processed in the array.

array

The array that the method was called upon.


What callbackFn is expected to return depends on the array method that was called.
The thisArg argument (defaults to undefined) will be used as the this value when calling callbackFn. The this value ultimately observable by callbackFn is determined according to the usual rules: if callbackFn is non-strict, primitive this values are wrapped into objects, and undefined/null is substituted with globalThis. The thisArg argument is irrelevant for any callbackFn defined with an arrow function, as arrow functions don't have their own this binding.
The array argument passed to callbackFn is most useful if you want to read another index during iteration, because you may not always have an existing variable that refers to the current array. You should generally not mutate the array during iteration (see mutating initial array in iterative methods), but you can also use this argument to do so. The array argument is not the array that is being built, in the case of methods like map(), filter(), and flatMap() — there is no way to access the array being built from the callback function.
All iterative methods are copying and generic, although they behave differently with empty slots.
The following methods are iterative: every(), filter(), find(), findIndex(), findLast(), findLastIndex(), flatMap(), forEach(), map(), and some().
In particular, every(), find(), findIndex(), findLast(), findLastIndex(), and some() do not always invoke callbackFn on every element — they stop iteration as soon as the return value is determined.
The reduce() and reduceRight() methods also take a callback function and run it at most once for each element in the array, but they have slightly different signatures from typical iterative methods (for example, they don't accept thisArg).
The sort() method also takes a callback function, but it is not an iterative method. It mutates the array in-place, doesn't accept thisArg, and may invoke the callback multiple times on an index.
Iterative methods iterate the array like the following (with a lot of technical details omitted):
jsfunction method(callbackFn, thisArg) {
  const length = this.length;
  for (let i = 0; i < length; i++) {
    if (i in this) {
      const result = callbackFn.call(thisArg, this[i], i, this);
      // Do something with result; maybe return early
    }
  }
}

Note the following:

Not all methods do the i in this test. The find, findIndex, findLast, and findLastIndex methods do not, but other methods do.
The length is memorized before the loop starts. This affects how insertions and deletions during iteration are handled (see mutating initial array in iterative methods).
The method doesn't memorize the array contents, so if any index is modified during iteration, the new value might be observed.
The code above iterates the array in ascending order of index. Some methods iterate in descending order of index (for (let i = length - 1; i >= 0; i--)): reduceRight(), findLast(), and findLastIndex().
reduce and reduceRight have slightly different signatures and do not always start at the first/last element.
Generic array methodsArray methods are always generic — they don't access any internal data of the array object. They only access the array elements through the length property and the indexed elements. This means that they can be called on array-like objects as well.
jsconst arrayLike = {
  0: "a",
  1: "b",
  length: 2,
};
console.log(Array.prototype.join.call(arrayLike, "+")); // 'a+b'

Normalization of the length property
The length property is converted to an integer and then clamped to the range between 0 and 253 - 1. NaN becomes 0, so even when length is not present or is undefined, it behaves as if it has value 0.
The language avoids setting length to an unsafe integer. All built-in methods will throw a TypeError if length will be set to a number greater than 253 - 1. However, because the length property of arrays throws an error if it's set to greater than 232 - 1, the safe integer threshold is usually not reached unless the method is called on a non-array object.
jsArray.prototype.flat.call({}); // []

Some array methods set the length property of the array object. They always set the value after normalization, so length always ends as an integer.
jsconst a = { length: 0.7 };
Array.prototype.push.call(a);
console.log(a.length); // 0

Array-like objects
The term array-like object refers to any object that doesn't throw during the length conversion process described above. In practice, such object is expected to actually have a length property and to have indexed elements in the range 0 to length - 1. (If it doesn't have all indices, it will be functionally equivalent to a sparse array.) Any integer index less than zero or greater than length - 1 is ignored when an array method operates on an array-like object.
Many DOM objects are array-like — for example, NodeList and HTMLCollection. The arguments object is also array-like. You can call array methods on them even if they don't have these methods themselves.
jsfunction f() {
  console.log(Array.prototype.join.call(arguments, "+"));
}

f("a", "b"); // 'a+b'
Constructor
Array()

Creates a new Array object.

Static properties
Array[Symbol.species]

Returns the Array constructor.

Static methods
Array.from()

Creates a new Array instance from an iterable or array-like object.

Array.fromAsync()

Creates a new Array instance from an async iterable, iterable, or array-like object.

Array.isArray()

Returns true if the argument is an array, or false otherwise.

Array.of()

Creates a new Array instance with a variable number of arguments, regardless of number or type of the arguments.

Instance propertiesThese properties are defined on Array.prototype and shared by all Array instances.

Array.prototype.constructor

The constructor function that created the instance object. For Array instances, the initial value is the Array constructor.

Array.prototype[Symbol.unscopables]

Contains property names that were not included in the ECMAScript standard prior to the ES2015 version and that are ignored for with statement-binding purposes.


These properties are own properties of each Array instance.

length

Reflects the number of elements in an array.

Instance methods
Array.prototype.at()

Returns the array item at the given index. Accepts negative integers, which count back from the last item.

Array.prototype.concat()

Returns a new array that is the calling array joined with other array(s) and/or value(s).

Array.prototype.copyWithin()

Copies a sequence of array elements within an array.

Array.prototype.entries()

Returns a new array iterator object that contains the key/value pairs for each index in an array.

Array.prototype.every()

Returns true if every element in the calling array satisfies the testing function.

Array.prototype.fill()

Fills all the elements of an array from a start index to an end index with a static value.

Array.prototype.filter()

Returns a new array containing all elements of the calling array for which the provided filtering function returns true.

Array.prototype.find()

Returns the value of the first element in the array that satisfies the provided testing function, or undefined if no appropriate element is found.

Array.prototype.findIndex()

Returns the index of the first element in the array that satisfies the provided testing function, or -1 if no appropriate element was found.

Array.prototype.findLast()

Returns the value of the last element in the array that satisfies the provided testing function, or undefined if no appropriate element is found.

Array.prototype.findLastIndex()

Returns the index of the last element in the array that satisfies the provided testing function, or -1 if no appropriate element was found.

Array.prototype.flat()

Returns a new array with all sub-array elements concatenated into it recursively up to the specified depth.

Array.prototype.flatMap()

Returns a new array formed by applying a given callback function to each element of the calling array, and then flattening the result by one level.

Array.prototype.forEach()

Calls a function for each element in the calling array.

Array.prototype.includes()

Determines whether the calling array contains a value, returning true or false as appropriate.

Array.prototype.indexOf()

Returns the first (least) index at which a given element can be found in the calling array.

Array.prototype.join()

Joins all elements of an array into a string.

Array.prototype.keys()

Returns a new array iterator that contains the keys for each index in the calling array.

Array.prototype.lastIndexOf()

Returns the last (greatest) index at which a given element can be found in the calling array, or -1 if none is found.

Array.prototype.map()

Returns a new array containing the results of invoking a function on every element in the calling array.

Array.prototype.pop()

Removes the last element from an array and returns that element.

Array.prototype.push()

Adds one or more elements to the end of an array, and returns the new length of the array.

Array.prototype.reduce()

Executes a user-supplied "reducer" callback function on each element of the array (from left to right), to reduce it to a single value.

Array.prototype.reduceRight()

Executes a user-supplied "reducer" callback function on each element of the array (from right to left), to reduce it to a single value.

Array.prototype.reverse()

Reverses the order of the elements of an array in place. (First becomes the last, last becomes first.)

Array.prototype.shift()

Removes the first element from an array and returns that element.

Array.prototype.slice()

Extracts a section of the calling array and returns a new array.

Array.prototype.some()

Returns true if at least one element in the calling array satisfies the provided testing function.

Array.prototype.sort()

Sorts the elements of an array in place and returns the array.

Array.prototype.splice()

Adds and/or removes elements from an array.

Array.prototype.toLocaleString()

Returns a localized string representing the calling array and its elements. Overrides the Object.prototype.toLocaleString() method.

Array.prototype.toReversed()

Returns a new array with the elements in reversed order, without modifying the original array.

Array.prototype.toSorted()

Returns a new array with the elements sorted in ascending order, without modifying the original array.

Array.prototype.toSpliced()

Returns a new array with some elements removed and/or replaced at a given index, without modifying the original array.

Array.prototype.toString()

Returns a string representing the calling array and its elements. Overrides the Object.prototype.toString() method.

Array.prototype.unshift()

Adds one or more elements to the front of an array, and returns the new length of the array.

Array.prototype.values()

Returns a new array iterator object that contains the values for each index in the array.

Array.prototype.with()

Returns a new array with the element at the given index replaced with the given value, without modifying the original array.

Array.prototype[Symbol.iterator]()

An alias for the values() method by default.

ExamplesThis section provides some examples of common array operations in JavaScript.

Note:
If you're not yet familiar with array basics, consider first reading JavaScript First Steps: Arrays, which explains what arrays are, and includes other examples of common array operations.
Create an arrayThis example shows three ways to create new array: first using array literal notation, then using the Array() constructor, and finally using String.prototype.split() to build the array from a string.
js// 'fruits' array created using array literal notation.
const fruits = ["Apple", "Banana"];
console.log(fruits.length);
// 2

// 'fruits2' array created using the Array() constructor.
const fruits2 = new Array("Apple", "Banana");
console.log(fruits2.length);
// 2

// 'fruits3' array created using String.prototype.split().
const fruits3 = "Apple, Banana".split(", ");
console.log(fruits3.length);
// 2
Create a string from an arrayThis example uses the join() method to create a string from the fruits array.
jsconst fruits = ["Apple", "Banana"];
const fruitsString = fruits.join(", ");
console.log(fruitsString);
// "Apple, Banana"
Access an array item by its indexThis example shows how to access items in the fruits array by specifying the index number of their position in the array.
jsconst fruits = ["Apple", "Banana"];

// The index of an array's first element is always 0.
fruits[0]; // Apple

// The index of an array's second element is always 1.
fruits[1]; // Banana

// The index of an array's last element is always one
// less than the length of the array.
fruits[fruits.length - 1]; // Banana

// Using an index number larger than the array's length
// returns 'undefined'.
fruits[99]; // undefined
Find the index of an item in an arrayThis example uses the indexOf() method to find the position (index) of the string "Banana" in the fruits array.
jsconst fruits = ["Apple", "Banana"];
console.log(fruits.indexOf("Banana"));
// 1
Check if an array contains a certain itemThis example shows two ways to check if the fruits array contains "Banana" and "Cherry": first with the includes() method, and then with the indexOf() method to test for an index value that's not -1.
jsconst fruits = ["Apple", "Banana"];

fruits.includes("Banana"); // true
fruits.includes("Cherry"); // false

// If indexOf() doesn't return -1, the array contains the given item.
fruits.indexOf("Banana") !== -1; // true
fruits.indexOf("Cherry") !== -1; // false
Append an item to an arrayThis example uses the push() method to append a new string to the fruits array.
jsconst fruits = ["Apple", "Banana"];
const newLength = fruits.push("Orange");
console.log(fruits);
// ["Apple", "Banana", "Orange"]
console.log(newLength);
// 3
Remove the last item from an arrayThis example uses the pop() method to remove the last item from the fruits array.
jsconst fruits = ["Apple", "Banana", "Orange"];
const removedItem = fruits.pop();
console.log(fruits);
// ["Apple", "Banana"]
console.log(removedItem);
// Orange


Note: pop() can only be used to remove the last item from an array. To remove multiple items from the end of an array, see the next example.
Remove multiple items from the end of an arrayThis example uses the splice() method to remove the last 3 items from the fruits array.
jsconst fruits = ["Apple", "Banana", "Strawberry", "Mango", "Cherry"];
const start = -3;
const removedItems = fruits.splice(start);
console.log(fruits);
// ["Apple", "Banana"]
console.log(removedItems);
// ["Strawberry", "Mango", "Cherry"]
Truncate an array down to just its first N itemsThis example uses the splice() method to truncate the fruits array down to just its first 2 items.
jsconst fruits = ["Apple", "Banana", "Strawberry", "Mango", "Cherry"];
const start = 2;
const removedItems = fruits.splice(start);
console.log(fruits);
// ["Apple", "Banana"]
console.log(removedItems);
// ["Strawberry", "Mango", "Cherry"]
Remove the first item from an arrayThis example uses the shift() method to remove the first item from the fruits array.
jsconst fruits = ["Apple", "Banana"];
const removedItem = fruits.shift();
console.log(fruits);
// ["Banana"]
console.log(removedItem);
// Apple


Note: shift() can only be used to remove the first item from an array. To remove multiple items from the beginning of an array, see the next example.
Remove multiple items from the beginning of an arrayThis example uses the splice() method to remove the first 3 items from the fruits array.
jsconst fruits = ["Apple", "Strawberry", "Cherry", "Banana", "Mango"];
const start = 0;
const deleteCount = 3;
const removedItems = fruits.splice(start, deleteCount);
console.log(fruits);
// ["Banana", "Mango"]
console.log(removedItems);
// ["Apple", "Strawberry", "Cherry"]
Add a new first item to an arrayThis example uses the unshift() method to add, at index 0, a new item to the fruits array — making it the new first item in the array.
jsconst fruits = ["Banana", "Mango"];
const newLength = fruits.unshift("Strawberry");
console.log(fruits);
// ["Strawberry", "Banana", "Mango"]
console.log(newLength);
// 3
Remove a single item by indexThis example uses the splice() method to remove the string "Banana" from the fruits array — by specifying the index position of "Banana".
jsconst fruits = ["Strawberry", "Banana", "Mango"];
const start = fruits.indexOf("Banana");
const deleteCount = 1;
const removedItems = fruits.splice(start, deleteCount);
console.log(fruits);
// ["Strawberry", "Mango"]
console.log(removedItems);
// ["Banana"]
Remove multiple items by indexThis example uses the splice() method to remove the strings "Banana" and "Strawberry" from the fruits array — by specifying the index position of "Banana", along with a count of the number of total items to remove.
jsconst fruits = ["Apple", "Banana", "Strawberry", "Mango"];
const start = 1;
const deleteCount = 2;
const removedItems = fruits.splice(start, deleteCount);
console.log(fruits);
// ["Apple", "Mango"]
console.log(removedItems);
// ["Banana", "Strawberry"]
Replace multiple items in an arrayThis example uses the splice() method to replace the last 2 items in the fruits array with new items.
jsconst fruits = ["Apple", "Banana", "Strawberry"];
const start = -2;
const deleteCount = 2;
const removedItems = fruits.splice(start, deleteCount, "Mango", "Cherry");
console.log(fruits);
// ["Apple", "Mango", "Cherry"]
console.log(removedItems);
// ["Banana", "Strawberry"]
Iterate over an arrayThis example uses a for...of loop to iterate over the fruits array, logging each item to the console.
jsconst fruits = ["Apple", "Mango", "Cherry"];
for (const fruit of fruits) {
  console.log(fruit);
}
// Apple
// Mango
// Cherry

But for...of is just one of many ways to iterate over any array; for more ways, see Loops and iteration, and see the documentation for the every(), filter(), flatMap(), map(), reduce(), and reduceRight() methods — and see the next example, which uses the forEach() method.Call a function on each element in an arrayThis example uses the forEach() method to call a function on each element in the fruits array; the function causes each item to be logged to the console, along with the item's index number.
jsconst fruits = ["Apple", "Mango", "Cherry"];
fruits.forEach((item, index, array) => {
  console.log(item, index);
});
// Apple 0
// Mango 1
// Cherry 2
Merge multiple arrays togetherThis example uses the concat() method to merge the fruits array with a moreFruits array, to produce a new combinedFruits array. Notice that fruits and moreFruits remain unchanged.
jsconst fruits = ["Apple", "Banana", "Strawberry"];
const moreFruits = ["Mango", "Cherry"];
const combinedFruits = fruits.concat(moreFruits);
console.log(combinedFruits);
// ["Apple", "Banana", "Strawberry", "Mango", "Cherry"]

// The 'fruits' array remains unchanged.
console.log(fruits);
// ["Apple", "Banana", "Strawberry"]

// The 'moreFruits' array also remains unchanged.
console.log(moreFruits);
// ["Mango", "Cherry"]
Copy an arrayThis example shows three ways to create a new array from the existing fruits array: first by using spread syntax, then by using the from() method, and then by using the slice() method.
jsconst fruits = ["Strawberry", "Mango"];

// Create a copy using spread syntax.
const fruitsCopy = [...fruits];
// ["Strawberry", "Mango"]

// Create a copy using the from() method.
const fruitsCopy2 = Array.from(fruits);
// ["Strawberry", "Mango"]

// Create a copy using the slice() method.
const fruitsCopy3 = fruits.slice();
// ["Strawberry", "Mango"]

All built-in array-copy operations (spread syntax, Array.from(), Array.prototype.slice(), and Array.prototype.concat()) create shallow copies. If you instead want a deep copy of an array, you can use JSON.stringify() to convert the array to a JSON string, and then JSON.parse() to convert the string back into a new array that's completely independent from the original array.
jsconst fruitsDeepCopy = JSON.parse(JSON.stringify(fruits));

You can also create deep copies using the structuredClone() method, which has the advantage of allowing transferable objects in the source to be transferred to the new copy, rather than just cloned.
Finally, it's important to understand that assigning an existing array to a new variable doesn't create a copy of either the array or its elements. Instead the new variable is just a reference, or alias, to the original array; that is, the original array's name and the new variable name are just two names for the exact same object (and so will always evaluate as strictly equivalent). Therefore, if you make any changes at all either to the value of the original array or to the value of the new variable, the other will change, too:
jsconst fruits = ["Strawberry", "Mango"];
const fruitsAlias = fruits;
// 'fruits' and 'fruitsAlias' are the same object, strictly equivalent.
fruits === fruitsAlias; // true
// Any changes to the 'fruits' array change 'fruitsAlias' too.
fruits.unshift("Apple", "Banana");
console.log(fruits);
// ['Apple', 'Banana', 'Strawberry', 'Mango']
console.log(fruitsAlias);
// ['Apple', 'Banana', 'Strawberry', 'Mango']
Creating a two-dimensional arrayThe following creates a chessboard as a two-dimensional array of strings. The first move is made by copying the 'p' in board[6][4] to board[4][4]. The old position at [6][4] is made blank.
jsconst board = [
  ["R", "N", "B", "Q", "K", "B", "N", "R"],
  ["P", "P", "P", "P", "P", "P", "P", "P"],
  [" ", " ", " ", " ", " ", " ", " ", " "],
  [" ", " ", " ", " ", " ", " ", " ", " "],
  [" ", " ", " ", " ", " ", " ", " ", " "],
  [" ", " ", " ", " ", " ", " ", " ", " "],
  ["p", "p", "p", "p", "p", "p", "p", "p"],
  ["r", "n", "b", "q", "k", "b", "n", "r"],
];

console.log(`${board.join("\n")}\n\n`);

// Move King's Pawn forward 2
board[4][4] = board[6][4];
board[6][4] = " ";
console.log(board.join("\n"));

Here is the output:
R,N,B,Q,K,B,N,R
P,P,P,P,P,P,P,P
 , , , , , , ,
 , , , , , , ,
 , , , , , , ,
 , , , , , , ,
p,p,p,p,p,p,p,p
r,n,b,q,k,b,n,r

R,N,B,Q,K,B,N,R
P,P,P,P,P,P,P,P
 , , , , , , ,
 , , , , , , ,
 , , , ,p, , ,
 , , , , , , ,
p,p,p,p, ,p,p,p
r,n,b,q,k,b,n,r
Using an array to tabulate a set of valuesjsconst values = [];
for (let x = 0; x < 10; x++) {
  values.push([2 ** x, 2 * x ** 2]);
}
console.table(values);

Results in
// The first column is the index
0  1    0
1  2    2
2  4    8
3  8    18
4  16   32
5  32   50
6  64   72
7  128  98
8  256  128
9  512  162
Creating an array using the result of a matchThe result of a match between a RegExp and a string can create a JavaScript array that has properties and elements which provide information about the match. Such an array is returned by RegExp.prototype.exec() and String.prototype.match().
For example:
js// Match one d followed by one or more b's followed by one d
// Remember matched b's and the following d
// Ignore case

const myRe = /d(b+)(d)/i;
const execResult = myRe.exec("cdbBdbsbz");

console.log(execResult.input); // 'cdbBdbsbz'
console.log(execResult.index); // 1
console.log(execResult); // [ "dbBd", "bB", "d" ]

For more information about the result of a match, see the RegExp.prototype.exec() and String.prototype.match() pages.Mutating initial array in iterative methodsIterative methods do not mutate the array on which it is called, but the function provided as callbackFn can. The key principle to remember is that only indexes between 0 and arrayLength - 1 are visited, where arrayLength is the length of the array at the time the array method was first called, but the element passed to the callback is the value at the time the index is visited. Therefore:

callbackFn will not visit any elements added beyond the array's initial length when the call to the iterative method began.
Changes to already-visited indexes do not cause callbackFn to be invoked on them again.
If an existing, yet-unvisited element of the array is changed by callbackFn, its value passed to the callbackFn will be the value at the time that element gets visited. Removed elements are not visited.


Warning:
Concurrent modifications of the kind described above frequently lead to hard-to-understand code and are generally to be avoided (except in special cases).

The following examples use the forEach method as an example, but other methods that visit indexes in ascending order work in the same way. We will first define a helper function:
jsfunction testSideEffect(effect) {
  const arr = ["e1", "e2", "e3", "e4"];
  arr.forEach((elem, index, arr) => {
    console.log(`array: [${arr.join(", ")}], index: ${index}, elem: ${elem}`);
    effect(arr, index);
  });
  console.log(`Final array: [${arr.join(", ")}]`);
}

Modification to indexes not visited yet will be visible once the index is reached:
jstestSideEffect((arr, index) => {
  if (index + 1 < arr.length) arr[index + 1] += "*";
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2*, e3, e4], index: 1, elem: e2*
// array: [e1, e2*, e3*, e4], index: 2, elem: e3*
// array: [e1, e2*, e3*, e4*], index: 3, elem: e4*
// Final array: [e1, e2*, e3*, e4*]

Modification to already visited indexes does not change iteration behavior, although the array will be different afterwards:
jstestSideEffect((arr, index) => {
  if (index > 0) arr[index - 1] += "*";
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2, e3, e4], index: 1, elem: e2
// array: [e1*, e2, e3, e4], index: 2, elem: e3
// array: [e1*, e2*, e3, e4], index: 3, elem: e4
// Final array: [e1*, e2*, e3*, e4]

Inserting n elements at unvisited indexes that are less than the initial array length will make them be visited. The last n elements in the original array that now have index greater than the initial array length will not be visited:
jstestSideEffect((arr, index) => {
  if (index === 1) arr.splice(2, 0, "new");
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2, e3, e4], index: 1, elem: e2
// array: [e1, e2, new, e3, e4], index: 2, elem: new
// array: [e1, e2, new, e3, e4], index: 3, elem: e3
// Final array: [e1, e2, new, e3, e4]
// e4 is not visited because it now has index 4

Inserting n elements with index greater than the initial array length will not make them be visited:
jstestSideEffect((arr) => arr.push("new"));
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2, e3, e4, new], index: 1, elem: e2
// array: [e1, e2, e3, e4, new, new], index: 2, elem: e3
// array: [e1, e2, e3, e4, new, new, new], index: 3, elem: e4
// Final array: [e1, e2, e3, e4, new, new, new, new]

Inserting n elements at already visited indexes will not make them be visited, but it shifts remaining elements back by n, so the current index and the n - 1 elements before it are visited again:
jstestSideEffect((arr, index) => arr.splice(index, 0, "new"));
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [new, e1, e2, e3, e4], index: 1, elem: e1
// array: [new, new, e1, e2, e3, e4], index: 2, elem: e1
// array: [new, new, new, e1, e2, e3, e4], index: 3, elem: e1
// Final array: [new, new, new, new, e1, e2, e3, e4]
// e1 keeps getting visited because it keeps getting shifted back

Deleting n elements at unvisited indexes will make them not be visited anymore. Because the array has shrunk, the last n iterations will visit out-of-bounds indexes. If the method ignores non-existent indexes (see array methods and empty slots), the last n iterations will be skipped; otherwise, they will receive undefined:
jstestSideEffect((arr, index) => {
  if (index === 1) arr.splice(2, 1);
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2, e3, e4], index: 1, elem: e2
// array: [e1, e2, e4], index: 2, elem: e4
// Final array: [e1, e2, e4]
// Does not visit index 3 because it's out-of-bounds

// Compare this with find(), which treats nonexistent indexes as undefined:
const arr2 = ["e1", "e2", "e3", "e4"];
arr2.find((elem, index, arr) => {
  console.log(`array: [${arr.join(", ")}], index: ${index}, elem: ${elem}`);
  if (index === 1) arr.splice(2, 1);
  return false;
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2, e3, e4], index: 1, elem: e2
// array: [e1, e2, e4], index: 2, elem: e4
// array: [e1, e2, e4], index: 3, elem: undefined

Deleting n elements at already visited indexes does not change the fact that they were visited before they get deleted. Because the array has shrunk, the next n elements after the current index are skipped. If the method ignores non-existent indexes, the last n iterations will be skipped; otherwise, they will receive undefined:
jstestSideEffect((arr, index) => arr.splice(index, 1));
// array: [e1, e2, e3, e4], index: 0, elem: e1
// Does not visit e2 because e2 now has index 0, which has already been visited
// array: [e2, e3, e4], index: 1, elem: e3
// Does not visit e4 because e4 now has index 1, which has already been visited
// Final array: [e2, e4]
// Index 2 is out-of-bounds, so it's not visited

// Compare this with find(), which treats nonexistent indexes as undefined:
const arr2 = ["e1", "e2", "e3", "e4"];
arr2.find((elem, index, arr) => {
  console.log(`array: [${arr.join(", ")}], index: ${index}, elem: ${elem}`);
  arr.splice(index, 1);
  return false;
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e2, e3, e4], index: 1, elem: e3
// array: [e2, e4], index: 2, elem: undefined
// array: [e2, e4], index: 3, elem: undefined

For methods that iterate in descending order of index, insertion causes elements to be skipped, and deletion causes elements to be visited multiple times. Adjust the code above yourself to see the effects.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-array-objectsBrowser compatibilitySee also
Indexed collections guide
TypedArray
ArrayBuffer
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nArrayBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Array object, as with arrays in other programming languages, enables storing a collection of multiple items under a single variable name, and has members for performing common array operations.DescriptionIn JavaScript, arrays aren't primitives but are instead Array objects with the following core characteristics:

JavaScript arrays are resizable and can contain a mix of different data types. (When those characteristics are undesirable, use typed arrays instead.)
JavaScript arrays are not associative arrays and so, array elements cannot be accessed using arbitrary strings as indexes, but must be accessed using nonnegative integers (or their respective string form) as indexes.
JavaScript arrays are zero-indexed: the first element of an array is at index 0, the second is at index 1, and so on — and the last element is at the value of the array's length property minus 1.
JavaScript array-copy operations create shallow copies. (All standard built-in copy operations with any JavaScript objects create shallow copies, rather than deep copies).
Array indicesArray objects cannot use arbitrary strings as element indexes (as in an associative array) but must use nonnegative integers (or their respective string form). Setting or accessing via non-integers will not set or retrieve an element from the array list itself, but will set or access a variable associated with that array's object property collection. The array's object properties and list of array elements are separate, and the array's traversal and mutation operations cannot be applied to these named properties.
Array elements are object properties in the same way that toString is a property (to be specific, however, toString() is a method). Nevertheless, trying to access an element of an array as follows throws a syntax error because the property name is not valid:
jsarr.0; // a syntax error

JavaScript syntax requires properties beginning with a digit to be accessed using bracket notation instead of dot notation. It's also possible to quote the array indices (e.g., years['2'] instead of years[2]), although usually not necessary.
The 2 in years[2] is coerced into a string by the JavaScript engine through an implicit toString conversion. As a result, '2' and '02' would refer to two different slots on the years object, and the following example could be true:
jsconsole.log(years["2"] !== years["02"]);

Only years['2'] is an actual array index. years['02'] is an arbitrary string property that will not be visited in array iteration.Relationship between length and numerical propertiesA JavaScript array's length property and numerical properties are connected.
Several of the built-in array methods (e.g., join(), slice(), indexOf(), etc.) take into account the value of an array's length property when they're called.
Other methods (e.g., push(), splice(), etc.) also result in updates to an array's length property.
jsconst fruits = [];
fruits.push("banana", "apple", "peach");
console.log(fruits.length); // 3

When setting a property on a JavaScript array when the property is a valid array index and that index is outside the current bounds of the array, the engine will update the array's length property accordingly:
jsfruits[5] = "mango";
console.log(fruits[5]); // 'mango'
console.log(Object.keys(fruits)); // ['0', '1', '2', '5']
console.log(fruits.length); // 6

Increasing the length extends the array by adding empty slots without creating any new elements — not even undefined.
jsfruits.length = 10;
console.log(fruits); // ['banana', 'apple', 'peach', empty x 2, 'mango', empty x 4]
console.log(Object.keys(fruits)); // ['0', '1', '2', '5']
console.log(fruits.length); // 10
console.log(fruits[8]); // undefined

Decreasing the length property does, however, delete elements.
jsfruits.length = 2;
console.log(Object.keys(fruits)); // ['0', '1']
console.log(fruits.length); // 2

This is explained further on the length page.Array methods and empty slotsArray methods have different behaviors when encountering empty slots in sparse arrays. In general, older methods (e.g., forEach) treat empty slots differently from indices that contain undefined.
Methods that have special treatment for empty slots include the following: concat(), copyWithin(), every(), filter(), flat(), flatMap(), forEach(), indexOf(), lastIndexOf(), map(), reduce(), reduceRight(), reverse(), slice(), some(), sort(), and splice(). Iteration methods such as forEach don't visit empty slots at all. Other methods, such as concat, copyWithin, etc., preserve empty slots when doing the copying, so in the end the array is still sparse.
jsconst colors = ["red", "yellow", "blue"];
colors[5] = "purple";
colors.forEach((item, index) => {
  console.log(`${index}: ${item}`);
});
// Output:
// 0: red
// 1: yellow
// 2: blue
// 5: purple

colors.reverse(); // ['purple', empty × 2, 'blue', 'yellow', 'red']

Newer methods (e.g., keys) do not treat empty slots specially and treat them as if they contain undefined. Methods that conflate empty slots with undefined elements include the following: entries(), fill(), find(), findIndex(), findLast(), findLastIndex(), includes(), join(), keys(), toLocaleString(), toReversed(), toSorted(), toSpliced(), values(), and with().
jsconst colors = ["red", "yellow", "blue"];
colors[5] = "purple";
const iterator = colors.keys();
for (const key of iterator) {
  console.log(`${key}: ${colors[key]}`);
}
// Output
// 0: red
// 1: yellow
// 2: blue
// 3: undefined
// 4: undefined
// 5: purple

const newColors = colors.toReversed(); // ['purple', undefined, undefined, 'blue', 'yellow', 'red']
Copying methods and mutating methodsSome methods do not mutate the existing array that the method was called on, but instead return a new array. They do so by first constructing a new array and then populating it with elements. The copy always happens shallowly — the method never copies anything beyond the initially created array. Elements of the original array(s) are copied into the new array as follows:

Objects: the object reference is copied into the new array. Both the original and new array refer to the same object. That is, if a referenced object is modified, the changes are visible to both the new and original arrays.
Primitive types such as strings, numbers and booleans (not String, Number, and Boolean objects): their values are copied into the new array.

Other methods mutate the array that the method was called on, in which case their return value differs depending on the method: sometimes a reference to the same array, sometimes the length of the new array.
The following methods create new arrays by accessing this.constructor[Symbol.species] to determine the constructor to use: concat(), filter(), flat(), flatMap(), map(), slice(), and splice() (to construct the array of removed elements that's returned).
The following methods always create new arrays with the Array base constructor: toReversed(), toSorted(), toSpliced(), and with().
The following table lists the methods that mutate the original array, and the corresponding non-mutating alternative:



Mutating method
Non-mutating alternative




copyWithin()
No one-method alternative


fill()
No one-method alternative


pop()
slice(0, -1)


push(v1, v2)
concat([v1, v2])


reverse()
toReversed()


shift()
slice(1)


sort()
toSorted()


splice()
toSpliced()


unshift(v1, v2)
toSpliced(0, 0, v1, v2)



An easy way to change a mutating method into a non-mutating alternative is to use the spread syntax or slice() to create a copy first:
jsarr.copyWithin(0, 1, 2); // mutates arr
const arr2 = arr.slice().copyWithin(0, 1, 2); // does not mutate arr
const arr3 = [...arr].copyWithin(0, 1, 2); // does not mutate arr
Iterative methodsMany array methods take a callback function as an argument. The callback function is called sequentially and at most once for each element in the array, and the return value of the callback function is used to determine the return value of the method. They all share the same signature:
jsmethod(callbackFn, thisArg)

Where callbackFn takes three arguments:

element

The current element being processed in the array.

index

The index of the current element being processed in the array.

array

The array that the method was called upon.


What callbackFn is expected to return depends on the array method that was called.
The thisArg argument (defaults to undefined) will be used as the this value when calling callbackFn. The this value ultimately observable by callbackFn is determined according to the usual rules: if callbackFn is non-strict, primitive this values are wrapped into objects, and undefined/null is substituted with globalThis. The thisArg argument is irrelevant for any callbackFn defined with an arrow function, as arrow functions don't have their own this binding.
The array argument passed to callbackFn is most useful if you want to read another index during iteration, because you may not always have an existing variable that refers to the current array. You should generally not mutate the array during iteration (see mutating initial array in iterative methods), but you can also use this argument to do so. The array argument is not the array that is being built, in the case of methods like map(), filter(), and flatMap() — there is no way to access the array being built from the callback function.
All iterative methods are copying and generic, although they behave differently with empty slots.
The following methods are iterative: every(), filter(), find(), findIndex(), findLast(), findLastIndex(), flatMap(), forEach(), map(), and some().
In particular, every(), find(), findIndex(), findLast(), findLastIndex(), and some() do not always invoke callbackFn on every element — they stop iteration as soon as the return value is determined.
The reduce() and reduceRight() methods also take a callback function and run it at most once for each element in the array, but they have slightly different signatures from typical iterative methods (for example, they don't accept thisArg).
The sort() method also takes a callback function, but it is not an iterative method. It mutates the array in-place, doesn't accept thisArg, and may invoke the callback multiple times on an index.
Iterative methods iterate the array like the following (with a lot of technical details omitted):
jsfunction method(callbackFn, thisArg) {
  const length = this.length;
  for (let i = 0; i < length; i++) {
    if (i in this) {
      const result = callbackFn.call(thisArg, this[i], i, this);
      // Do something with result; maybe return early
    }
  }
}

Note the following:

Not all methods do the i in this test. The find, findIndex, findLast, and findLastIndex methods do not, but other methods do.
The length is memorized before the loop starts. This affects how insertions and deletions during iteration are handled (see mutating initial array in iterative methods).
The method doesn't memorize the array contents, so if any index is modified during iteration, the new value might be observed.
The code above iterates the array in ascending order of index. Some methods iterate in descending order of index (for (let i = length - 1; i >= 0; i--)): reduceRight(), findLast(), and findLastIndex().
reduce and reduceRight have slightly different signatures and do not always start at the first/last element.
Generic array methodsArray methods are always generic — they don't access any internal data of the array object. They only access the array elements through the length property and the indexed elements. This means that they can be called on array-like objects as well.
jsconst arrayLike = {
  0: "a",
  1: "b",
  length: 2,
};
console.log(Array.prototype.join.call(arrayLike, "+")); // 'a+b'

Normalization of the length property
The length property is converted to an integer and then clamped to the range between 0 and 253 - 1. NaN becomes 0, so even when length is not present or is undefined, it behaves as if it has value 0.
The language avoids setting length to an unsafe integer. All built-in methods will throw a TypeError if length will be set to a number greater than 253 - 1. However, because the length property of arrays throws an error if it's set to greater than 232 - 1, the safe integer threshold is usually not reached unless the method is called on a non-array object.
jsArray.prototype.flat.call({}); // []

Some array methods set the length property of the array object. They always set the value after normalization, so length always ends as an integer.
jsconst a = { length: 0.7 };
Array.prototype.push.call(a);
console.log(a.length); // 0

Array-like objects
The term array-like object refers to any object that doesn't throw during the length conversion process described above. In practice, such object is expected to actually have a length property and to have indexed elements in the range 0 to length - 1. (If it doesn't have all indices, it will be functionally equivalent to a sparse array.) Any integer index less than zero or greater than length - 1 is ignored when an array method operates on an array-like object.
Many DOM objects are array-like — for example, NodeList and HTMLCollection. The arguments object is also array-like. You can call array methods on them even if they don't have these methods themselves.
jsfunction f() {
  console.log(Array.prototype.join.call(arguments, "+"));
}

f("a", "b"); // 'a+b'
Constructor
Array()

Creates a new Array object.

Static properties
Array[Symbol.species]

Returns the Array constructor.

Static methods
Array.from()

Creates a new Array instance from an iterable or array-like object.

Array.fromAsync()

Creates a new Array instance from an async iterable, iterable, or array-like object.

Array.isArray()

Returns true if the argument is an array, or false otherwise.

Array.of()

Creates a new Array instance with a variable number of arguments, regardless of number or type of the arguments.

Instance propertiesThese properties are defined on Array.prototype and shared by all Array instances.

Array.prototype.constructor

The constructor function that created the instance object. For Array instances, the initial value is the Array constructor.

Array.prototype[Symbol.unscopables]

Contains property names that were not included in the ECMAScript standard prior to the ES2015 version and that are ignored for with statement-binding purposes.


These properties are own properties of each Array instance.

length

Reflects the number of elements in an array.

Instance methods
Array.prototype.at()

Returns the array item at the given index. Accepts negative integers, which count back from the last item.

Array.prototype.concat()

Returns a new array that is the calling array joined with other array(s) and/or value(s).

Array.prototype.copyWithin()

Copies a sequence of array elements within an array.

Array.prototype.entries()

Returns a new array iterator object that contains the key/value pairs for each index in an array.

Array.prototype.every()

Returns true if every element in the calling array satisfies the testing function.

Array.prototype.fill()

Fills all the elements of an array from a start index to an end index with a static value.

Array.prototype.filter()

Returns a new array containing all elements of the calling array for which the provided filtering function returns true.

Array.prototype.find()

Returns the value of the first element in the array that satisfies the provided testing function, or undefined if no appropriate element is found.

Array.prototype.findIndex()

Returns the index of the first element in the array that satisfies the provided testing function, or -1 if no appropriate element was found.

Array.prototype.findLast()

Returns the value of the last element in the array that satisfies the provided testing function, or undefined if no appropriate element is found.

Array.prototype.findLastIndex()

Returns the index of the last element in the array that satisfies the provided testing function, or -1 if no appropriate element was found.

Array.prototype.flat()

Returns a new array with all sub-array elements concatenated into it recursively up to the specified depth.

Array.prototype.flatMap()

Returns a new array formed by applying a given callback function to each element of the calling array, and then flattening the result by one level.

Array.prototype.forEach()

Calls a function for each element in the calling array.

Array.prototype.includes()

Determines whether the calling array contains a value, returning true or false as appropriate.

Array.prototype.indexOf()

Returns the first (least) index at which a given element can be found in the calling array.

Array.prototype.join()

Joins all elements of an array into a string.

Array.prototype.keys()

Returns a new array iterator that contains the keys for each index in the calling array.

Array.prototype.lastIndexOf()

Returns the last (greatest) index at which a given element can be found in the calling array, or -1 if none is found.

Array.prototype.map()

Returns a new array containing the results of invoking a function on every element in the calling array.

Array.prototype.pop()

Removes the last element from an array and returns that element.

Array.prototype.push()

Adds one or more elements to the end of an array, and returns the new length of the array.

Array.prototype.reduce()

Executes a user-supplied "reducer" callback function on each element of the array (from left to right), to reduce it to a single value.

Array.prototype.reduceRight()

Executes a user-supplied "reducer" callback function on each element of the array (from right to left), to reduce it to a single value.

Array.prototype.reverse()

Reverses the order of the elements of an array in place. (First becomes the last, last becomes first.)

Array.prototype.shift()

Removes the first element from an array and returns that element.

Array.prototype.slice()

Extracts a section of the calling array and returns a new array.

Array.prototype.some()

Returns true if at least one element in the calling array satisfies the provided testing function.

Array.prototype.sort()

Sorts the elements of an array in place and returns the array.

Array.prototype.splice()

Adds and/or removes elements from an array.

Array.prototype.toLocaleString()

Returns a localized string representing the calling array and its elements. Overrides the Object.prototype.toLocaleString() method.

Array.prototype.toReversed()

Returns a new array with the elements in reversed order, without modifying the original array.

Array.prototype.toSorted()

Returns a new array with the elements sorted in ascending order, without modifying the original array.

Array.prototype.toSpliced()

Returns a new array with some elements removed and/or replaced at a given index, without modifying the original array.

Array.prototype.toString()

Returns a string representing the calling array and its elements. Overrides the Object.prototype.toString() method.

Array.prototype.unshift()

Adds one or more elements to the front of an array, and returns the new length of the array.

Array.prototype.values()

Returns a new array iterator object that contains the values for each index in the array.

Array.prototype.with()

Returns a new array with the element at the given index replaced with the given value, without modifying the original array.

Array.prototype[Symbol.iterator]()

An alias for the values() method by default.

ExamplesThis section provides some examples of common array operations in JavaScript.

Note:
If you're not yet familiar with array basics, consider first reading JavaScript First Steps: Arrays, which explains what arrays are, and includes other examples of common array operations.
Create an arrayThis example shows three ways to create new array: first using array literal notation, then using the Array() constructor, and finally using String.prototype.split() to build the array from a string.
js// 'fruits' array created using array literal notation.
const fruits = ["Apple", "Banana"];
console.log(fruits.length);
// 2

// 'fruits2' array created using the Array() constructor.
const fruits2 = new Array("Apple", "Banana");
console.log(fruits2.length);
// 2

// 'fruits3' array created using String.prototype.split().
const fruits3 = "Apple, Banana".split(", ");
console.log(fruits3.length);
// 2
Create a string from an arrayThis example uses the join() method to create a string from the fruits array.
jsconst fruits = ["Apple", "Banana"];
const fruitsString = fruits.join(", ");
console.log(fruitsString);
// "Apple, Banana"
Access an array item by its indexThis example shows how to access items in the fruits array by specifying the index number of their position in the array.
jsconst fruits = ["Apple", "Banana"];

// The index of an array's first element is always 0.
fruits[0]; // Apple

// The index of an array's second element is always 1.
fruits[1]; // Banana

// The index of an array's last element is always one
// less than the length of the array.
fruits[fruits.length - 1]; // Banana

// Using an index number larger than the array's length
// returns 'undefined'.
fruits[99]; // undefined
Find the index of an item in an arrayThis example uses the indexOf() method to find the position (index) of the string "Banana" in the fruits array.
jsconst fruits = ["Apple", "Banana"];
console.log(fruits.indexOf("Banana"));
// 1
Check if an array contains a certain itemThis example shows two ways to check if the fruits array contains "Banana" and "Cherry": first with the includes() method, and then with the indexOf() method to test for an index value that's not -1.
jsconst fruits = ["Apple", "Banana"];

fruits.includes("Banana"); // true
fruits.includes("Cherry"); // false

// If indexOf() doesn't return -1, the array contains the given item.
fruits.indexOf("Banana") !== -1; // true
fruits.indexOf("Cherry") !== -1; // false
Append an item to an arrayThis example uses the push() method to append a new string to the fruits array.
jsconst fruits = ["Apple", "Banana"];
const newLength = fruits.push("Orange");
console.log(fruits);
// ["Apple", "Banana", "Orange"]
console.log(newLength);
// 3
Remove the last item from an arrayThis example uses the pop() method to remove the last item from the fruits array.
jsconst fruits = ["Apple", "Banana", "Orange"];
const removedItem = fruits.pop();
console.log(fruits);
// ["Apple", "Banana"]
console.log(removedItem);
// Orange


Note: pop() can only be used to remove the last item from an array. To remove multiple items from the end of an array, see the next example.
Remove multiple items from the end of an arrayThis example uses the splice() method to remove the last 3 items from the fruits array.
jsconst fruits = ["Apple", "Banana", "Strawberry", "Mango", "Cherry"];
const start = -3;
const removedItems = fruits.splice(start);
console.log(fruits);
// ["Apple", "Banana"]
console.log(removedItems);
// ["Strawberry", "Mango", "Cherry"]
Truncate an array down to just its first N itemsThis example uses the splice() method to truncate the fruits array down to just its first 2 items.
jsconst fruits = ["Apple", "Banana", "Strawberry", "Mango", "Cherry"];
const start = 2;
const removedItems = fruits.splice(start);
console.log(fruits);
// ["Apple", "Banana"]
console.log(removedItems);
// ["Strawberry", "Mango", "Cherry"]
Remove the first item from an arrayThis example uses the shift() method to remove the first item from the fruits array.
jsconst fruits = ["Apple", "Banana"];
const removedItem = fruits.shift();
console.log(fruits);
// ["Banana"]
console.log(removedItem);
// Apple


Note: shift() can only be used to remove the first item from an array. To remove multiple items from the beginning of an array, see the next example.
Remove multiple items from the beginning of an arrayThis example uses the splice() method to remove the first 3 items from the fruits array.
jsconst fruits = ["Apple", "Strawberry", "Cherry", "Banana", "Mango"];
const start = 0;
const deleteCount = 3;
const removedItems = fruits.splice(start, deleteCount);
console.log(fruits);
// ["Banana", "Mango"]
console.log(removedItems);
// ["Apple", "Strawberry", "Cherry"]
Add a new first item to an arrayThis example uses the unshift() method to add, at index 0, a new item to the fruits array — making it the new first item in the array.
jsconst fruits = ["Banana", "Mango"];
const newLength = fruits.unshift("Strawberry");
console.log(fruits);
// ["Strawberry", "Banana", "Mango"]
console.log(newLength);
// 3
Remove a single item by indexThis example uses the splice() method to remove the string "Banana" from the fruits array — by specifying the index position of "Banana".
jsconst fruits = ["Strawberry", "Banana", "Mango"];
const start = fruits.indexOf("Banana");
const deleteCount = 1;
const removedItems = fruits.splice(start, deleteCount);
console.log(fruits);
// ["Strawberry", "Mango"]
console.log(removedItems);
// ["Banana"]
Remove multiple items by indexThis example uses the splice() method to remove the strings "Banana" and "Strawberry" from the fruits array — by specifying the index position of "Banana", along with a count of the number of total items to remove.
jsconst fruits = ["Apple", "Banana", "Strawberry", "Mango"];
const start = 1;
const deleteCount = 2;
const removedItems = fruits.splice(start, deleteCount);
console.log(fruits);
// ["Apple", "Mango"]
console.log(removedItems);
// ["Banana", "Strawberry"]
Replace multiple items in an arrayThis example uses the splice() method to replace the last 2 items in the fruits array with new items.
jsconst fruits = ["Apple", "Banana", "Strawberry"];
const start = -2;
const deleteCount = 2;
const removedItems = fruits.splice(start, deleteCount, "Mango", "Cherry");
console.log(fruits);
// ["Apple", "Mango", "Cherry"]
console.log(removedItems);
// ["Banana", "Strawberry"]
Iterate over an arrayThis example uses a for...of loop to iterate over the fruits array, logging each item to the console.
jsconst fruits = ["Apple", "Mango", "Cherry"];
for (const fruit of fruits) {
  console.log(fruit);
}
// Apple
// Mango
// Cherry

But for...of is just one of many ways to iterate over any array; for more ways, see Loops and iteration, and see the documentation for the every(), filter(), flatMap(), map(), reduce(), and reduceRight() methods — and see the next example, which uses the forEach() method.Call a function on each element in an arrayThis example uses the forEach() method to call a function on each element in the fruits array; the function causes each item to be logged to the console, along with the item's index number.
jsconst fruits = ["Apple", "Mango", "Cherry"];
fruits.forEach((item, index, array) => {
  console.log(item, index);
});
// Apple 0
// Mango 1
// Cherry 2
Merge multiple arrays togetherThis example uses the concat() method to merge the fruits array with a moreFruits array, to produce a new combinedFruits array. Notice that fruits and moreFruits remain unchanged.
jsconst fruits = ["Apple", "Banana", "Strawberry"];
const moreFruits = ["Mango", "Cherry"];
const combinedFruits = fruits.concat(moreFruits);
console.log(combinedFruits);
// ["Apple", "Banana", "Strawberry", "Mango", "Cherry"]

// The 'fruits' array remains unchanged.
console.log(fruits);
// ["Apple", "Banana", "Strawberry"]

// The 'moreFruits' array also remains unchanged.
console.log(moreFruits);
// ["Mango", "Cherry"]
Copy an arrayThis example shows three ways to create a new array from the existing fruits array: first by using spread syntax, then by using the from() method, and then by using the slice() method.
jsconst fruits = ["Strawberry", "Mango"];

// Create a copy using spread syntax.
const fruitsCopy = [...fruits];
// ["Strawberry", "Mango"]

// Create a copy using the from() method.
const fruitsCopy2 = Array.from(fruits);
// ["Strawberry", "Mango"]

// Create a copy using the slice() method.
const fruitsCopy3 = fruits.slice();
// ["Strawberry", "Mango"]

All built-in array-copy operations (spread syntax, Array.from(), Array.prototype.slice(), and Array.prototype.concat()) create shallow copies. If you instead want a deep copy of an array, you can use JSON.stringify() to convert the array to a JSON string, and then JSON.parse() to convert the string back into a new array that's completely independent from the original array.
jsconst fruitsDeepCopy = JSON.parse(JSON.stringify(fruits));

You can also create deep copies using the structuredClone() method, which has the advantage of allowing transferable objects in the source to be transferred to the new copy, rather than just cloned.
Finally, it's important to understand that assigning an existing array to a new variable doesn't create a copy of either the array or its elements. Instead the new variable is just a reference, or alias, to the original array; that is, the original array's name and the new variable name are just two names for the exact same object (and so will always evaluate as strictly equivalent). Therefore, if you make any changes at all either to the value of the original array or to the value of the new variable, the other will change, too:
jsconst fruits = ["Strawberry", "Mango"];
const fruitsAlias = fruits;
// 'fruits' and 'fruitsAlias' are the same object, strictly equivalent.
fruits === fruitsAlias; // true
// Any changes to the 'fruits' array change 'fruitsAlias' too.
fruits.unshift("Apple", "Banana");
console.log(fruits);
// ['Apple', 'Banana', 'Strawberry', 'Mango']
console.log(fruitsAlias);
// ['Apple', 'Banana', 'Strawberry', 'Mango']
Creating a two-dimensional arrayThe following creates a chessboard as a two-dimensional array of strings. The first move is made by copying the 'p' in board[6][4] to board[4][4]. The old position at [6][4] is made blank.
jsconst board = [
  ["R", "N", "B", "Q", "K", "B", "N", "R"],
  ["P", "P", "P", "P", "P", "P", "P", "P"],
  [" ", " ", " ", " ", " ", " ", " ", " "],
  [" ", " ", " ", " ", " ", " ", " ", " "],
  [" ", " ", " ", " ", " ", " ", " ", " "],
  [" ", " ", " ", " ", " ", " ", " ", " "],
  ["p", "p", "p", "p", "p", "p", "p", "p"],
  ["r", "n", "b", "q", "k", "b", "n", "r"],
];

console.log(`${board.join("\n")}\n\n`);

// Move King's Pawn forward 2
board[4][4] = board[6][4];
board[6][4] = " ";
console.log(board.join("\n"));

Here is the output:
R,N,B,Q,K,B,N,R
P,P,P,P,P,P,P,P
 , , , , , , ,
 , , , , , , ,
 , , , , , , ,
 , , , , , , ,
p,p,p,p,p,p,p,p
r,n,b,q,k,b,n,r

R,N,B,Q,K,B,N,R
P,P,P,P,P,P,P,P
 , , , , , , ,
 , , , , , , ,
 , , , ,p, , ,
 , , , , , , ,
p,p,p,p, ,p,p,p
r,n,b,q,k,b,n,r
Using an array to tabulate a set of valuesjsconst values = [];
for (let x = 0; x < 10; x++) {
  values.push([2 ** x, 2 * x ** 2]);
}
console.table(values);

Results in
// The first column is the index
0  1    0
1  2    2
2  4    8
3  8    18
4  16   32
5  32   50
6  64   72
7  128  98
8  256  128
9  512  162
Creating an array using the result of a matchThe result of a match between a RegExp and a string can create a JavaScript array that has properties and elements which provide information about the match. Such an array is returned by RegExp.prototype.exec() and String.prototype.match().
For example:
js// Match one d followed by one or more b's followed by one d
// Remember matched b's and the following d
// Ignore case

const myRe = /d(b+)(d)/i;
const execResult = myRe.exec("cdbBdbsbz");

console.log(execResult.input); // 'cdbBdbsbz'
console.log(execResult.index); // 1
console.log(execResult); // [ "dbBd", "bB", "d" ]

For more information about the result of a match, see the RegExp.prototype.exec() and String.prototype.match() pages.Mutating initial array in iterative methodsIterative methods do not mutate the array on which it is called, but the function provided as callbackFn can. The key principle to remember is that only indexes between 0 and arrayLength - 1 are visited, where arrayLength is the length of the array at the time the array method was first called, but the element passed to the callback is the value at the time the index is visited. Therefore:

callbackFn will not visit any elements added beyond the array's initial length when the call to the iterative method began.
Changes to already-visited indexes do not cause callbackFn to be invoked on them again.
If an existing, yet-unvisited element of the array is changed by callbackFn, its value passed to the callbackFn will be the value at the time that element gets visited. Removed elements are not visited.


Warning:
Concurrent modifications of the kind described above frequently lead to hard-to-understand code and are generally to be avoided (except in special cases).

The following examples use the forEach method as an example, but other methods that visit indexes in ascending order work in the same way. We will first define a helper function:
jsfunction testSideEffect(effect) {
  const arr = ["e1", "e2", "e3", "e4"];
  arr.forEach((elem, index, arr) => {
    console.log(`array: [${arr.join(", ")}], index: ${index}, elem: ${elem}`);
    effect(arr, index);
  });
  console.log(`Final array: [${arr.join(", ")}]`);
}

Modification to indexes not visited yet will be visible once the index is reached:
jstestSideEffect((arr, index) => {
  if (index + 1 < arr.length) arr[index + 1] += "*";
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2*, e3, e4], index: 1, elem: e2*
// array: [e1, e2*, e3*, e4], index: 2, elem: e3*
// array: [e1, e2*, e3*, e4*], index: 3, elem: e4*
// Final array: [e1, e2*, e3*, e4*]

Modification to already visited indexes does not change iteration behavior, although the array will be different afterwards:
jstestSideEffect((arr, index) => {
  if (index > 0) arr[index - 1] += "*";
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2, e3, e4], index: 1, elem: e2
// array: [e1*, e2, e3, e4], index: 2, elem: e3
// array: [e1*, e2*, e3, e4], index: 3, elem: e4
// Final array: [e1*, e2*, e3*, e4]

Inserting n elements at unvisited indexes that are less than the initial array length will make them be visited. The last n elements in the original array that now have index greater than the initial array length will not be visited:
jstestSideEffect((arr, index) => {
  if (index === 1) arr.splice(2, 0, "new");
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2, e3, e4], index: 1, elem: e2
// array: [e1, e2, new, e3, e4], index: 2, elem: new
// array: [e1, e2, new, e3, e4], index: 3, elem: e3
// Final array: [e1, e2, new, e3, e4]
// e4 is not visited because it now has index 4

Inserting n elements with index greater than the initial array length will not make them be visited:
jstestSideEffect((arr) => arr.push("new"));
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2, e3, e4, new], index: 1, elem: e2
// array: [e1, e2, e3, e4, new, new], index: 2, elem: e3
// array: [e1, e2, e3, e4, new, new, new], index: 3, elem: e4
// Final array: [e1, e2, e3, e4, new, new, new, new]

Inserting n elements at already visited indexes will not make them be visited, but it shifts remaining elements back by n, so the current index and the n - 1 elements before it are visited again:
jstestSideEffect((arr, index) => arr.splice(index, 0, "new"));
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [new, e1, e2, e3, e4], index: 1, elem: e1
// array: [new, new, e1, e2, e3, e4], index: 2, elem: e1
// array: [new, new, new, e1, e2, e3, e4], index: 3, elem: e1
// Final array: [new, new, new, new, e1, e2, e3, e4]
// e1 keeps getting visited because it keeps getting shifted back

Deleting n elements at unvisited indexes will make them not be visited anymore. Because the array has shrunk, the last n iterations will visit out-of-bounds indexes. If the method ignores non-existent indexes (see array methods and empty slots), the last n iterations will be skipped; otherwise, they will receive undefined:
jstestSideEffect((arr, index) => {
  if (index === 1) arr.splice(2, 1);
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2, e3, e4], index: 1, elem: e2
// array: [e1, e2, e4], index: 2, elem: e4
// Final array: [e1, e2, e4]
// Does not visit index 3 because it's out-of-bounds

// Compare this with find(), which treats nonexistent indexes as undefined:
const arr2 = ["e1", "e2", "e3", "e4"];
arr2.find((elem, index, arr) => {
  console.log(`array: [${arr.join(", ")}], index: ${index}, elem: ${elem}`);
  if (index === 1) arr.splice(2, 1);
  return false;
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2, e3, e4], index: 1, elem: e2
// array: [e1, e2, e4], index: 2, elem: e4
// array: [e1, e2, e4], index: 3, elem: undefined

Deleting n elements at already visited indexes does not change the fact that they were visited before they get deleted. Because the array has shrunk, the next n elements after the current index are skipped. If the method ignores non-existent indexes, the last n iterations will be skipped; otherwise, they will receive undefined:
jstestSideEffect((arr, index) => arr.splice(index, 1));
// array: [e1, e2, e3, e4], index: 0, elem: e1
// Does not visit e2 because e2 now has index 0, which has already been visited
// array: [e2, e3, e4], index: 1, elem: e3
// Does not visit e4 because e4 now has index 1, which has already been visited
// Final array: [e2, e4]
// Index 2 is out-of-bounds, so it's not visited

// Compare this with find(), which treats nonexistent indexes as undefined:
const arr2 = ["e1", "e2", "e3", "e4"];
arr2.find((elem, index, arr) => {
  console.log(`array: [${arr.join(", ")}], index: ${index}, elem: ${elem}`);
  arr.splice(index, 1);
  return false;
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e2, e3, e4], index: 1, elem: e3
// array: [e2, e4], index: 2, elem: undefined
// array: [e2, e4], index: 3, elem: undefined

For methods that iterate in descending order of index, insertion causes elements to be skipped, and deletion causes elements to be visited multiple times. Adjust the code above yourself to see the effects.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-array-objectsBrowser compatibilitySee also
Indexed collections guide
TypedArray
ArrayBuffer
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nArrayBufferBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe ArrayBuffer object is used to represent a generic raw binary data buffer.
It is an array of bytes, often referred to in other languages as a "byte array". You cannot directly manipulate the contents of an ArrayBuffer; instead, you create one of the typed array objects or a DataView object which represents the buffer in a specific format, and use that to read and write the contents of the buffer.
The ArrayBuffer() constructor creates a new ArrayBuffer of the given length in bytes. You can also get an array buffer from existing data, for example, from a Base64 string or from a local file.
ArrayBuffer is a transferable object.DescriptionResizing ArrayBuffersArrayBuffer objects can be made resizable by including the maxByteLength option when calling the ArrayBuffer() constructor. You can query whether an ArrayBuffer is resizable and what its maximum size is by accessing its resizable and maxByteLength properties, respectively. You can assign a new size to a resizable ArrayBuffer with a resize() call. New bytes are initialized to 0.
These features make resizing ArrayBuffers more efficient — otherwise, you have to make a copy of the buffer with a new size. It also gives JavaScript parity with WebAssembly in this regard (Wasm linear memory can be resized with WebAssembly.Memory.prototype.grow()).Transferring ArrayBuffersArrayBuffer objects can be transferred between different execution contexts, like Web Workers or Service Workers, using the structured clone algorithm. This is done by passing the ArrayBuffer as a transferable object in a call to Worker.postMessage() or ServiceWorker.postMessage(). In pure JavaScript, you can also transfer the ownership of memory from one ArrayBuffer to another using its transfer() or transferToFixedLength() method.
When an ArrayBuffer is transferred, its original copy becomes detached — this means it is no longer usable. At any moment, there will only be one copy of the ArrayBuffer that actually has access to the underlying memory. Detached buffers have the following behaviors:

byteLength becomes 0 (in both the buffer and the associated typed array views).
Methods, such as resize() and slice(), throw a TypeError when invoked. The associated typed array views' methods also throw a TypeError.

You can check whether an ArrayBuffer is detached by its detached property.Constructor
ArrayBuffer()

Creates a new ArrayBuffer object.

Static properties
ArrayBuffer[Symbol.species]

The constructor function that is used to create derived objects.

Static methods
ArrayBuffer.isView()

Returns true if arg is one of the ArrayBuffer views, such as typed array objects or a DataView. Returns false otherwise.

Instance propertiesThese properties are defined on ArrayBuffer.prototype and shared by all ArrayBuffer instances.

ArrayBuffer.prototype.byteLength

The size, in bytes, of the ArrayBuffer. This is established when the array is constructed and can only be changed using the ArrayBuffer.prototype.resize() method if the ArrayBuffer is resizable.

ArrayBuffer.prototype.constructor

The constructor function that created the instance object. For ArrayBuffer instances, the initial value is the ArrayBuffer constructor.

ArrayBuffer.prototype.detached

Read-only. Returns true if the ArrayBuffer has been detached (transferred), or false if not.

ArrayBuffer.prototype.maxByteLength

The read-only maximum length, in bytes, that the ArrayBuffer can be resized to. This is established when the array is constructed and cannot be changed.

ArrayBuffer.prototype.resizable

Read-only. Returns true if the ArrayBuffer can be resized, or false if not.

ArrayBuffer.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "ArrayBuffer". This property is used in Object.prototype.toString().

Instance methods
ArrayBuffer.prototype.resize()

Resizes the ArrayBuffer to the specified size, in bytes.

ArrayBuffer.prototype.slice()

Returns a new ArrayBuffer whose contents are a copy of this ArrayBuffer's bytes from begin (inclusive) up to end (exclusive). If either begin or end is negative, it refers to an index from the end of the array, as opposed to from the beginning.

ArrayBuffer.prototype.transfer()

Creates a new ArrayBuffer with the same byte content as this buffer, then detaches this buffer.

ArrayBuffer.prototype.transferToFixedLength()

Creates a new non-resizable ArrayBuffer with the same byte content as this buffer, then detaches this buffer.

ExamplesCreating an ArrayBufferIn this example, we create a 8-byte buffer with a Int32Array view referring to the buffer:
jsconst buffer = new ArrayBuffer(8);
const view = new Int32Array(buffer);
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-arraybuffer-objectsBrowser compatibilitySee also
Polyfill of ArrayBuffer in core-js
JavaScript typed arrays guide
SharedArrayBuffer
RangeError: invalid array length\n\nArrayBufferBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe ArrayBuffer object is used to represent a generic raw binary data buffer.
It is an array of bytes, often referred to in other languages as a "byte array". You cannot directly manipulate the contents of an ArrayBuffer; instead, you create one of the typed array objects or a DataView object which represents the buffer in a specific format, and use that to read and write the contents of the buffer.
The ArrayBuffer() constructor creates a new ArrayBuffer of the given length in bytes. You can also get an array buffer from existing data, for example, from a Base64 string or from a local file.
ArrayBuffer is a transferable object.DescriptionResizing ArrayBuffersArrayBuffer objects can be made resizable by including the maxByteLength option when calling the ArrayBuffer() constructor. You can query whether an ArrayBuffer is resizable and what its maximum size is by accessing its resizable and maxByteLength properties, respectively. You can assign a new size to a resizable ArrayBuffer with a resize() call. New bytes are initialized to 0.
These features make resizing ArrayBuffers more efficient — otherwise, you have to make a copy of the buffer with a new size. It also gives JavaScript parity with WebAssembly in this regard (Wasm linear memory can be resized with WebAssembly.Memory.prototype.grow()).Transferring ArrayBuffersArrayBuffer objects can be transferred between different execution contexts, like Web Workers or Service Workers, using the structured clone algorithm. This is done by passing the ArrayBuffer as a transferable object in a call to Worker.postMessage() or ServiceWorker.postMessage(). In pure JavaScript, you can also transfer the ownership of memory from one ArrayBuffer to another using its transfer() or transferToFixedLength() method.
When an ArrayBuffer is transferred, its original copy becomes detached — this means it is no longer usable. At any moment, there will only be one copy of the ArrayBuffer that actually has access to the underlying memory. Detached buffers have the following behaviors:

byteLength becomes 0 (in both the buffer and the associated typed array views).
Methods, such as resize() and slice(), throw a TypeError when invoked. The associated typed array views' methods also throw a TypeError.

You can check whether an ArrayBuffer is detached by its detached property.Constructor
ArrayBuffer()

Creates a new ArrayBuffer object.

Static properties
ArrayBuffer[Symbol.species]

The constructor function that is used to create derived objects.

Static methods
ArrayBuffer.isView()

Returns true if arg is one of the ArrayBuffer views, such as typed array objects or a DataView. Returns false otherwise.

Instance propertiesThese properties are defined on ArrayBuffer.prototype and shared by all ArrayBuffer instances.

ArrayBuffer.prototype.byteLength

The size, in bytes, of the ArrayBuffer. This is established when the array is constructed and can only be changed using the ArrayBuffer.prototype.resize() method if the ArrayBuffer is resizable.

ArrayBuffer.prototype.constructor

The constructor function that created the instance object. For ArrayBuffer instances, the initial value is the ArrayBuffer constructor.

ArrayBuffer.prototype.detached

Read-only. Returns true if the ArrayBuffer has been detached (transferred), or false if not.

ArrayBuffer.prototype.maxByteLength

The read-only maximum length, in bytes, that the ArrayBuffer can be resized to. This is established when the array is constructed and cannot be changed.

ArrayBuffer.prototype.resizable

Read-only. Returns true if the ArrayBuffer can be resized, or false if not.

ArrayBuffer.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "ArrayBuffer". This property is used in Object.prototype.toString().

Instance methods
ArrayBuffer.prototype.resize()

Resizes the ArrayBuffer to the specified size, in bytes.

ArrayBuffer.prototype.slice()

Returns a new ArrayBuffer whose contents are a copy of this ArrayBuffer's bytes from begin (inclusive) up to end (exclusive). If either begin or end is negative, it refers to an index from the end of the array, as opposed to from the beginning.

ArrayBuffer.prototype.transfer()

Creates a new ArrayBuffer with the same byte content as this buffer, then detaches this buffer.

ArrayBuffer.prototype.transferToFixedLength()

Creates a new non-resizable ArrayBuffer with the same byte content as this buffer, then detaches this buffer.

ExamplesCreating an ArrayBufferIn this example, we create a 8-byte buffer with a Int32Array view referring to the buffer:
jsconst buffer = new ArrayBuffer(8);
const view = new Int32Array(buffer);
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-arraybuffer-objectsBrowser compatibilitySee also
Polyfill of ArrayBuffer in core-js
JavaScript typed arrays guide
SharedArrayBuffer
RangeError: invalid array length
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jan 31, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nArrayBufferBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe ArrayBuffer object is used to represent a generic raw binary data buffer.
It is an array of bytes, often referred to in other languages as a "byte array". You cannot directly manipulate the contents of an ArrayBuffer; instead, you create one of the typed array objects or a DataView object which represents the buffer in a specific format, and use that to read and write the contents of the buffer.
The ArrayBuffer() constructor creates a new ArrayBuffer of the given length in bytes. You can also get an array buffer from existing data, for example, from a Base64 string or from a local file.
ArrayBuffer is a transferable object.DescriptionResizing ArrayBuffersArrayBuffer objects can be made resizable by including the maxByteLength option when calling the ArrayBuffer() constructor. You can query whether an ArrayBuffer is resizable and what its maximum size is by accessing its resizable and maxByteLength properties, respectively. You can assign a new size to a resizable ArrayBuffer with a resize() call. New bytes are initialized to 0.
These features make resizing ArrayBuffers more efficient — otherwise, you have to make a copy of the buffer with a new size. It also gives JavaScript parity with WebAssembly in this regard (Wasm linear memory can be resized with WebAssembly.Memory.prototype.grow()).Transferring ArrayBuffersArrayBuffer objects can be transferred between different execution contexts, like Web Workers or Service Workers, using the structured clone algorithm. This is done by passing the ArrayBuffer as a transferable object in a call to Worker.postMessage() or ServiceWorker.postMessage(). In pure JavaScript, you can also transfer the ownership of memory from one ArrayBuffer to another using its transfer() or transferToFixedLength() method.
When an ArrayBuffer is transferred, its original copy becomes detached — this means it is no longer usable. At any moment, there will only be one copy of the ArrayBuffer that actually has access to the underlying memory. Detached buffers have the following behaviors:

byteLength becomes 0 (in both the buffer and the associated typed array views).
Methods, such as resize() and slice(), throw a TypeError when invoked. The associated typed array views' methods also throw a TypeError.

You can check whether an ArrayBuffer is detached by its detached property.Constructor
ArrayBuffer()

Creates a new ArrayBuffer object.

Static properties
ArrayBuffer[Symbol.species]

The constructor function that is used to create derived objects.

Static methods
ArrayBuffer.isView()

Returns true if arg is one of the ArrayBuffer views, such as typed array objects or a DataView. Returns false otherwise.

Instance propertiesThese properties are defined on ArrayBuffer.prototype and shared by all ArrayBuffer instances.

ArrayBuffer.prototype.byteLength

The size, in bytes, of the ArrayBuffer. This is established when the array is constructed and can only be changed using the ArrayBuffer.prototype.resize() method if the ArrayBuffer is resizable.

ArrayBuffer.prototype.constructor

The constructor function that created the instance object. For ArrayBuffer instances, the initial value is the ArrayBuffer constructor.

ArrayBuffer.prototype.detached

Read-only. Returns true if the ArrayBuffer has been detached (transferred), or false if not.

ArrayBuffer.prototype.maxByteLength

The read-only maximum length, in bytes, that the ArrayBuffer can be resized to. This is established when the array is constructed and cannot be changed.

ArrayBuffer.prototype.resizable

Read-only. Returns true if the ArrayBuffer can be resized, or false if not.

ArrayBuffer.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "ArrayBuffer". This property is used in Object.prototype.toString().

Instance methods
ArrayBuffer.prototype.resize()

Resizes the ArrayBuffer to the specified size, in bytes.

ArrayBuffer.prototype.slice()

Returns a new ArrayBuffer whose contents are a copy of this ArrayBuffer's bytes from begin (inclusive) up to end (exclusive). If either begin or end is negative, it refers to an index from the end of the array, as opposed to from the beginning.

ArrayBuffer.prototype.transfer()

Creates a new ArrayBuffer with the same byte content as this buffer, then detaches this buffer.

ArrayBuffer.prototype.transferToFixedLength()

Creates a new non-resizable ArrayBuffer with the same byte content as this buffer, then detaches this buffer.

ExamplesCreating an ArrayBufferIn this example, we create a 8-byte buffer with a Int32Array view referring to the buffer:
jsconst buffer = new ArrayBuffer(8);
const view = new Int32Array(buffer);
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-arraybuffer-objectsBrowser compatibilitySee also
Polyfill of ArrayBuffer in core-js
JavaScript typed arrays guide
SharedArrayBuffer
RangeError: invalid array length
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jan 31, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nAsyncFunctionBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2017.Learn moreSee full compatibilityReport feedbackThe AsyncFunction object provides methods for async functions. In JavaScript, every async function is actually an AsyncFunction object.
Note that AsyncFunction is not a global object. It can be obtained with the following code:
jsconst AsyncFunction = async function () {}.constructor;

AsyncFunction is a subclass of Function.Constructor
AsyncFunction()

Creates a new AsyncFunction object.

Instance propertiesAlso inherits instance properties from its parent Function.
These properties are defined on AsyncFunction.prototype and shared by all AsyncFunction instances.

AsyncFunction.prototype.constructor

The constructor function that created the instance object. For AsyncFunction instances, the initial value is the AsyncFunction constructor.

AsyncFunction.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "AsyncFunction". This property is used in Object.prototype.toString().



Note: AsyncFunction instances do not have the prototype property.
Instance methodsInherits instance methods from its parent Function.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-async-function-objectsBrowser compatibilitySee also
async function
async function expression
Function
AsyncGeneratorFunction
GeneratorFunction
Functions\n\nAsyncFunctionBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2017.Learn moreSee full compatibilityReport feedbackThe AsyncFunction object provides methods for async functions. In JavaScript, every async function is actually an AsyncFunction object.
Note that AsyncFunction is not a global object. It can be obtained with the following code:
jsconst AsyncFunction = async function () {}.constructor;

AsyncFunction is a subclass of Function.Constructor
AsyncFunction()

Creates a new AsyncFunction object.

Instance propertiesAlso inherits instance properties from its parent Function.
These properties are defined on AsyncFunction.prototype and shared by all AsyncFunction instances.

AsyncFunction.prototype.constructor

The constructor function that created the instance object. For AsyncFunction instances, the initial value is the AsyncFunction constructor.

AsyncFunction.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "AsyncFunction". This property is used in Object.prototype.toString().



Note: AsyncFunction instances do not have the prototype property.
Instance methodsInherits instance methods from its parent Function.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-async-function-objectsBrowser compatibilitySee also
async function
async function expression
Function
AsyncGeneratorFunction
GeneratorFunction
Functions
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jul 13, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nAsyncFunctionBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2017.Learn moreSee full compatibilityReport feedbackThe AsyncFunction object provides methods for async functions. In JavaScript, every async function is actually an AsyncFunction object.
Note that AsyncFunction is not a global object. It can be obtained with the following code:
jsconst AsyncFunction = async function () {}.constructor;

AsyncFunction is a subclass of Function.Constructor
AsyncFunction()

Creates a new AsyncFunction object.

Instance propertiesAlso inherits instance properties from its parent Function.
These properties are defined on AsyncFunction.prototype and shared by all AsyncFunction instances.

AsyncFunction.prototype.constructor

The constructor function that created the instance object. For AsyncFunction instances, the initial value is the AsyncFunction constructor.

AsyncFunction.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "AsyncFunction". This property is used in Object.prototype.toString().



Note: AsyncFunction instances do not have the prototype property.
Instance methodsInherits instance methods from its parent Function.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-async-function-objectsBrowser compatibilitySee also
async function
async function expression
Function
AsyncGeneratorFunction
GeneratorFunction
Functions
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jul 13, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nAsyncGeneratorBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackThe AsyncGenerator object is returned by an async generator function and it conforms to both the async iterable protocol and the async iterator protocol.
Async generator methods always yield Promise objects.
AsyncGenerator is a subclass of the hidden AsyncIterator class.ConstructorThere's no JavaScript entity that corresponds to the AsyncGenerator constructor. Instances of AsyncGenerator must be returned from async generator functions:
jsasync function* createAsyncGenerator() {
  yield Promise.resolve(1);
  yield await Promise.resolve(2);
  yield 3;
}
const asyncGen = createAsyncGenerator();
asyncGen.next().then((res) => console.log(res.value)); // 1
asyncGen.next().then((res) => console.log(res.value)); // 2
asyncGen.next().then((res) => console.log(res.value)); // 3

There's only a hidden object which is the prototype object shared by all objects created by async generator functions. This object is often stylized as AsyncGenerator.prototype to make it look like a class, but it should be more appropriately called AsyncGeneratorFunction.prototype.prototype, because AsyncGeneratorFunction is an actual JavaScript entity. To understand the prototype chain of AsyncGenerator instances, see AsyncGeneratorFunction.prototype.prototype.Instance propertiesThese properties are defined on AsyncGenerator.prototype and shared by all AsyncGenerator instances.

AsyncGenerator.prototype.constructor

The constructor function that created the instance object. For AsyncGenerator instances, the initial value is AsyncGeneratorFunction.prototype.

Note: AsyncGenerator objects do not store a reference to the async generator function that created them.


AsyncGenerator.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "AsyncGenerator". This property is used in Object.prototype.toString().

Instance methodsAlso inherits instance methods from its parent AsyncIterator.

AsyncGenerator.prototype.next()

Returns a Promise which will be resolved with the given value yielded by the yield expression.

AsyncGenerator.prototype.return()

Acts as if a return statement is inserted in the generator's body at the current suspended position, which finishes the generator and allows the generator to perform any cleanup tasks when combined with a try...finally block.

AsyncGenerator.prototype.throw()

Acts as if a throw statement is inserted in the generator's body at the current suspended position, which informs the generator of an error condition and allows it to handle the error, or perform cleanup and close itself.

ExamplesAsync generator iterationThe following example iterates over an async generator, logging values 1–6 to the console at decreasing time intervals. Notice how each time a Promise is yielded, but it's automatically resolved within the for await...of loop.
js// An async task. Pretend it's doing something more useful
// in practice.
function delayedValue(time, value) {
  return new Promise((resolve /*, reject*/) => {
    setTimeout(() => resolve(value), time);
  });
}

async function* generate() {
  yield delayedValue(2000, 1);
  yield delayedValue(1000, 2);
  yield delayedValue(500, 3);
  yield delayedValue(250, 4);
  yield delayedValue(125, 5);
  yield delayedValue(50, 6);
  console.log("All done!");
}

async function main() {
  for await (const value of generate()) {
    console.log("value", value);
  }
}

main().catch((e) => console.error(e));
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-asyncgenerator-objectsBrowser compatibilitySee also
function*
async function*
function* expression
Generator Function
Async Generator Function
Iterators and generators guide\n\nAsyncGeneratorBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackThe AsyncGenerator object is returned by an async generator function and it conforms to both the async iterable protocol and the async iterator protocol.
Async generator methods always yield Promise objects.
AsyncGenerator is a subclass of the hidden AsyncIterator class.ConstructorThere's no JavaScript entity that corresponds to the AsyncGenerator constructor. Instances of AsyncGenerator must be returned from async generator functions:
jsasync function* createAsyncGenerator() {
  yield Promise.resolve(1);
  yield await Promise.resolve(2);
  yield 3;
}
const asyncGen = createAsyncGenerator();
asyncGen.next().then((res) => console.log(res.value)); // 1
asyncGen.next().then((res) => console.log(res.value)); // 2
asyncGen.next().then((res) => console.log(res.value)); // 3

There's only a hidden object which is the prototype object shared by all objects created by async generator functions. This object is often stylized as AsyncGenerator.prototype to make it look like a class, but it should be more appropriately called AsyncGeneratorFunction.prototype.prototype, because AsyncGeneratorFunction is an actual JavaScript entity. To understand the prototype chain of AsyncGenerator instances, see AsyncGeneratorFunction.prototype.prototype.Instance propertiesThese properties are defined on AsyncGenerator.prototype and shared by all AsyncGenerator instances.

AsyncGenerator.prototype.constructor

The constructor function that created the instance object. For AsyncGenerator instances, the initial value is AsyncGeneratorFunction.prototype.

Note: AsyncGenerator objects do not store a reference to the async generator function that created them.


AsyncGenerator.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "AsyncGenerator". This property is used in Object.prototype.toString().

Instance methodsAlso inherits instance methods from its parent AsyncIterator.

AsyncGenerator.prototype.next()

Returns a Promise which will be resolved with the given value yielded by the yield expression.

AsyncGenerator.prototype.return()

Acts as if a return statement is inserted in the generator's body at the current suspended position, which finishes the generator and allows the generator to perform any cleanup tasks when combined with a try...finally block.

AsyncGenerator.prototype.throw()

Acts as if a throw statement is inserted in the generator's body at the current suspended position, which informs the generator of an error condition and allows it to handle the error, or perform cleanup and close itself.

ExamplesAsync generator iterationThe following example iterates over an async generator, logging values 1–6 to the console at decreasing time intervals. Notice how each time a Promise is yielded, but it's automatically resolved within the for await...of loop.
js// An async task. Pretend it's doing something more useful
// in practice.
function delayedValue(time, value) {
  return new Promise((resolve /*, reject*/) => {
    setTimeout(() => resolve(value), time);
  });
}

async function* generate() {
  yield delayedValue(2000, 1);
  yield delayedValue(1000, 2);
  yield delayedValue(500, 3);
  yield delayedValue(250, 4);
  yield delayedValue(125, 5);
  yield delayedValue(50, 6);
  console.log("All done!");
}

async function main() {
  for await (const value of generate()) {
    console.log("value", value);
  }
}

main().catch((e) => console.error(e));
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-asyncgenerator-objectsBrowser compatibilitySee also
function*
async function*
function* expression
Generator Function
Async Generator Function
Iterators and generators guide
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nAsyncGeneratorBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackThe AsyncGenerator object is returned by an async generator function and it conforms to both the async iterable protocol and the async iterator protocol.
Async generator methods always yield Promise objects.
AsyncGenerator is a subclass of the hidden AsyncIterator class.ConstructorThere's no JavaScript entity that corresponds to the AsyncGenerator constructor. Instances of AsyncGenerator must be returned from async generator functions:
jsasync function* createAsyncGenerator() {
  yield Promise.resolve(1);
  yield await Promise.resolve(2);
  yield 3;
}
const asyncGen = createAsyncGenerator();
asyncGen.next().then((res) => console.log(res.value)); // 1
asyncGen.next().then((res) => console.log(res.value)); // 2
asyncGen.next().then((res) => console.log(res.value)); // 3

There's only a hidden object which is the prototype object shared by all objects created by async generator functions. This object is often stylized as AsyncGenerator.prototype to make it look like a class, but it should be more appropriately called AsyncGeneratorFunction.prototype.prototype, because AsyncGeneratorFunction is an actual JavaScript entity. To understand the prototype chain of AsyncGenerator instances, see AsyncGeneratorFunction.prototype.prototype.Instance propertiesThese properties are defined on AsyncGenerator.prototype and shared by all AsyncGenerator instances.

AsyncGenerator.prototype.constructor

The constructor function that created the instance object. For AsyncGenerator instances, the initial value is AsyncGeneratorFunction.prototype.

Note: AsyncGenerator objects do not store a reference to the async generator function that created them.


AsyncGenerator.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "AsyncGenerator". This property is used in Object.prototype.toString().

Instance methodsAlso inherits instance methods from its parent AsyncIterator.

AsyncGenerator.prototype.next()

Returns a Promise which will be resolved with the given value yielded by the yield expression.

AsyncGenerator.prototype.return()

Acts as if a return statement is inserted in the generator's body at the current suspended position, which finishes the generator and allows the generator to perform any cleanup tasks when combined with a try...finally block.

AsyncGenerator.prototype.throw()

Acts as if a throw statement is inserted in the generator's body at the current suspended position, which informs the generator of an error condition and allows it to handle the error, or perform cleanup and close itself.

ExamplesAsync generator iterationThe following example iterates over an async generator, logging values 1–6 to the console at decreasing time intervals. Notice how each time a Promise is yielded, but it's automatically resolved within the for await...of loop.
js// An async task. Pretend it's doing something more useful
// in practice.
function delayedValue(time, value) {
  return new Promise((resolve /*, reject*/) => {
    setTimeout(() => resolve(value), time);
  });
}

async function* generate() {
  yield delayedValue(2000, 1);
  yield delayedValue(1000, 2);
  yield delayedValue(500, 3);
  yield delayedValue(250, 4);
  yield delayedValue(125, 5);
  yield delayedValue(50, 6);
  console.log("All done!");
}

async function main() {
  for await (const value of generate()) {
    console.log("value", value);
  }
}

main().catch((e) => console.error(e));
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-asyncgenerator-objectsBrowser compatibilitySee also
function*
async function*
function* expression
Generator Function
Async Generator Function
Iterators and generators guide
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nAsyncGeneratorFunctionBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackThe AsyncGeneratorFunction object provides methods for async generator functions. In JavaScript, every async generator function is actually an AsyncGeneratorFunction object.
Note that AsyncGeneratorFunction is not a global object. It can be obtained with the following code:
jsconst AsyncGeneratorFunction = async function* () {}.constructor;

AsyncGeneratorFunction is a subclass of Function.Try it
const AsyncGeneratorFunction = async function* () {}.constructor;

const foo = new AsyncGeneratorFunction(`
  yield await Promise.resolve('a');
  yield await Promise.resolve('b');
  yield await Promise.resolve('c');
`);

let str = "";

async function generate() {
  for await (const val of foo()) {
    str = str + val;
  }
  console.log(str);
}

generate();
// Expected output: "abc"
Constructor
AsyncGeneratorFunction()

Creates a new AsyncGeneratorFunction object.

Instance propertiesAlso inherits instance properties from its parent Function.
These properties are defined on AsyncGeneratorFunction.prototype and shared by all AsyncGeneratorFunction instances.

AsyncGeneratorFunction.prototype.constructor

The constructor function that created the instance object. For AsyncGeneratorFunction instances, the initial value is the AsyncGeneratorFunction constructor.

AsyncGeneratorFunction.prototype.prototype

All async generator functions share the same prototype property, which is AsyncGenerator.prototype. Each async generator function created with the async function* syntax or the AsyncGeneratorFunction() constructor also has its own prototype property, whose prototype is AsyncGeneratorFunction.prototype.prototype. When the async generator function is called, its prototype property becomes the prototype of the returned async generator object.

AsyncGeneratorFunction.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "AsyncGeneratorFunction". This property is used in Object.prototype.toString().


These properties are own properties of each AsyncGeneratorFunction instance.

prototype

Used when the function is used as a constructor with the new operator. It will become the new object's prototype.

Instance methodsInherits instance methods from its parent Function.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-asyncgeneratorfunction-objectsBrowser compatibilitySee also
async function*
async function* expression
Function
AsyncFunction
GeneratorFunction
Functions\n\nAsyncGeneratorFunctionBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackThe AsyncGeneratorFunction object provides methods for async generator functions. In JavaScript, every async generator function is actually an AsyncGeneratorFunction object.
Note that AsyncGeneratorFunction is not a global object. It can be obtained with the following code:
jsconst AsyncGeneratorFunction = async function* () {}.constructor;

AsyncGeneratorFunction is a subclass of Function.Try it
const AsyncGeneratorFunction = async function* () {}.constructor;

const foo = new AsyncGeneratorFunction(`
  yield await Promise.resolve('a');
  yield await Promise.resolve('b');
  yield await Promise.resolve('c');
`);

let str = "";

async function generate() {
  for await (const val of foo()) {
    str = str + val;
  }
  console.log(str);
}

generate();
// Expected output: "abc"
Constructor
AsyncGeneratorFunction()

Creates a new AsyncGeneratorFunction object.

Instance propertiesAlso inherits instance properties from its parent Function.
These properties are defined on AsyncGeneratorFunction.prototype and shared by all AsyncGeneratorFunction instances.

AsyncGeneratorFunction.prototype.constructor

The constructor function that created the instance object. For AsyncGeneratorFunction instances, the initial value is the AsyncGeneratorFunction constructor.

AsyncGeneratorFunction.prototype.prototype

All async generator functions share the same prototype property, which is AsyncGenerator.prototype. Each async generator function created with the async function* syntax or the AsyncGeneratorFunction() constructor also has its own prototype property, whose prototype is AsyncGeneratorFunction.prototype.prototype. When the async generator function is called, its prototype property becomes the prototype of the returned async generator object.

AsyncGeneratorFunction.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "AsyncGeneratorFunction". This property is used in Object.prototype.toString().


These properties are own properties of each AsyncGeneratorFunction instance.

prototype

Used when the function is used as a constructor with the new operator. It will become the new object's prototype.

Instance methodsInherits instance methods from its parent Function.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-asyncgeneratorfunction-objectsBrowser compatibilitySee also
async function*
async function* expression
Function
AsyncFunction
GeneratorFunction
Functions
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nAsyncGeneratorFunctionBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackThe AsyncGeneratorFunction object provides methods for async generator functions. In JavaScript, every async generator function is actually an AsyncGeneratorFunction object.
Note that AsyncGeneratorFunction is not a global object. It can be obtained with the following code:
jsconst AsyncGeneratorFunction = async function* () {}.constructor;

AsyncGeneratorFunction is a subclass of Function.Try it
const AsyncGeneratorFunction = async function* () {}.constructor;

const foo = new AsyncGeneratorFunction(`
  yield await Promise.resolve('a');
  yield await Promise.resolve('b');
  yield await Promise.resolve('c');
`);

let str = "";

async function generate() {
  for await (const val of foo()) {
    str = str + val;
  }
  console.log(str);
}

generate();
// Expected output: "abc"
Constructor
AsyncGeneratorFunction()

Creates a new AsyncGeneratorFunction object.

Instance propertiesAlso inherits instance properties from its parent Function.
These properties are defined on AsyncGeneratorFunction.prototype and shared by all AsyncGeneratorFunction instances.

AsyncGeneratorFunction.prototype.constructor

The constructor function that created the instance object. For AsyncGeneratorFunction instances, the initial value is the AsyncGeneratorFunction constructor.

AsyncGeneratorFunction.prototype.prototype

All async generator functions share the same prototype property, which is AsyncGenerator.prototype. Each async generator function created with the async function* syntax or the AsyncGeneratorFunction() constructor also has its own prototype property, whose prototype is AsyncGeneratorFunction.prototype.prototype. When the async generator function is called, its prototype property becomes the prototype of the returned async generator object.

AsyncGeneratorFunction.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "AsyncGeneratorFunction". This property is used in Object.prototype.toString().


These properties are own properties of each AsyncGeneratorFunction instance.

prototype

Used when the function is used as a constructor with the new operator. It will become the new object's prototype.

Instance methodsInherits instance methods from its parent Function.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-asyncgeneratorfunction-objectsBrowser compatibilitySee also
async function*
async function* expression
Function
AsyncFunction
GeneratorFunction
Functions
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nAsyncIteratorBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackAn AsyncIterator object is an object that conforms to the async iterator protocol by providing a next() method that returns a promise fulfilling to an iterator result object. The AsyncIterator.prototype object is a hidden global object that all built-in async iterators inherit from. It provides an [Symbol.asyncIterator]() method that returns the async iterator object itself, making the async iterator also async iterable.
Note that AsyncIterator is not a global object, although it will be in the future with the async iterator helpers proposal. The AsyncIterator.prototype object shared by all built-in async iterators can be obtained with the following code:
jsconst AsyncIteratorPrototype = Object.getPrototypeOf(
  Object.getPrototypeOf(Object.getPrototypeOf((async function* () {})())),
);
DescriptionCurrently, the only built-in JavaScript async iterator is the AsyncGenerator object returned by async generator functions. There are some other built-in async iterators in web API, such as the one of a ReadableStream.
Each of these async iterators have a distinct prototype object, which defines the next() method used by the particular async iterator. All of these prototype objects inherit from AsyncIterator.prototype, which provides an [Symbol.asyncIterator]() method that returns the async iterator object itself, making the async iterator also async iterable.

Note: AsyncIterator.prototype does not implement [Symbol.iterator](), so async iterators are not sync iterable by default.
Instance methods
AsyncIterator.prototype[Symbol.asyncIterator]()

Returns the async iterator object itself. This allows async iterator objects to also be async iterable.

ExamplesUsing an async iterator as an async iterableAll built-in async iterators are also async iterable, so you can use them in a for await...of loop:
jsconst asyncIterator = (async function* () {
  yield 1;
  yield 2;
  yield 3;
})();
(async () => {
  for await (const value of asyncIterator) {
    console.log(value);
  }
})();
// Logs: 1, 2, 3
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-asynciteratorprototypeBrowser compatibilitySee also
async function*
Iteration protocols\n\nAsyncIteratorBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackAn AsyncIterator object is an object that conforms to the async iterator protocol by providing a next() method that returns a promise fulfilling to an iterator result object. The AsyncIterator.prototype object is a hidden global object that all built-in async iterators inherit from. It provides an [Symbol.asyncIterator]() method that returns the async iterator object itself, making the async iterator also async iterable.
Note that AsyncIterator is not a global object, although it will be in the future with the async iterator helpers proposal. The AsyncIterator.prototype object shared by all built-in async iterators can be obtained with the following code:
jsconst AsyncIteratorPrototype = Object.getPrototypeOf(
  Object.getPrototypeOf(Object.getPrototypeOf((async function* () {})())),
);
DescriptionCurrently, the only built-in JavaScript async iterator is the AsyncGenerator object returned by async generator functions. There are some other built-in async iterators in web API, such as the one of a ReadableStream.
Each of these async iterators have a distinct prototype object, which defines the next() method used by the particular async iterator. All of these prototype objects inherit from AsyncIterator.prototype, which provides an [Symbol.asyncIterator]() method that returns the async iterator object itself, making the async iterator also async iterable.

Note: AsyncIterator.prototype does not implement [Symbol.iterator](), so async iterators are not sync iterable by default.
Instance methods
AsyncIterator.prototype[Symbol.asyncIterator]()

Returns the async iterator object itself. This allows async iterator objects to also be async iterable.

ExamplesUsing an async iterator as an async iterableAll built-in async iterators are also async iterable, so you can use them in a for await...of loop:
jsconst asyncIterator = (async function* () {
  yield 1;
  yield 2;
  yield 3;
})();
(async () => {
  for await (const value of asyncIterator) {
    console.log(value);
  }
})();
// Logs: 1, 2, 3
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-asynciteratorprototypeBrowser compatibilitySee also
async function*
Iteration protocols
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jul 15, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nAsyncIteratorBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackAn AsyncIterator object is an object that conforms to the async iterator protocol by providing a next() method that returns a promise fulfilling to an iterator result object. The AsyncIterator.prototype object is a hidden global object that all built-in async iterators inherit from. It provides an [Symbol.asyncIterator]() method that returns the async iterator object itself, making the async iterator also async iterable.
Note that AsyncIterator is not a global object, although it will be in the future with the async iterator helpers proposal. The AsyncIterator.prototype object shared by all built-in async iterators can be obtained with the following code:
jsconst AsyncIteratorPrototype = Object.getPrototypeOf(
  Object.getPrototypeOf(Object.getPrototypeOf((async function* () {})())),
);
DescriptionCurrently, the only built-in JavaScript async iterator is the AsyncGenerator object returned by async generator functions. There are some other built-in async iterators in web API, such as the one of a ReadableStream.
Each of these async iterators have a distinct prototype object, which defines the next() method used by the particular async iterator. All of these prototype objects inherit from AsyncIterator.prototype, which provides an [Symbol.asyncIterator]() method that returns the async iterator object itself, making the async iterator also async iterable.

Note: AsyncIterator.prototype does not implement [Symbol.iterator](), so async iterators are not sync iterable by default.
Instance methods
AsyncIterator.prototype[Symbol.asyncIterator]()

Returns the async iterator object itself. This allows async iterator objects to also be async iterable.

ExamplesUsing an async iterator as an async iterableAll built-in async iterators are also async iterable, so you can use them in a for await...of loop:
jsconst asyncIterator = (async function* () {
  yield 1;
  yield 2;
  yield 3;
})();
(async () => {
  for await (const value of asyncIterator) {
    console.log(value);
  }
})();
// Logs: 1, 2, 3
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-asynciteratorprototypeBrowser compatibilitySee also
async function*
Iteration protocols
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jul 15, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nAtomicsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since December 2021.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Atomics namespace object contains static methods for carrying out atomic operations. They are used with SharedArrayBuffer and ArrayBuffer objects.DescriptionUnlike most global objects, Atomics is not a constructor. You cannot use it with the new operator or invoke the Atomics object as a function. All properties and methods of Atomics are static (just like the Math object).Atomic operationsWhen memory is shared, multiple threads can read and write the same data in memory. Atomic operations make sure that predictable values are written and read, that operations are finished before the next operation starts and that operations are not interrupted.Wait and notifyThe wait() and notify() methods are modeled on Linux futexes ("fast user-space mutex") and provide ways for waiting until a certain condition becomes true and are typically used as blocking constructs.Static properties
Atomics[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Atomics". This property is used in Object.prototype.toString().

Static methods
Atomics.add()

Adds the provided value to the existing value at the specified index of the array. Returns the old value at that index.

Atomics.and()

Computes a bitwise AND on the value at the specified index of the array with the provided value. Returns the old value at that index.

Atomics.compareExchange()

Stores a value at the specified index of the array, if it equals a value. Returns the old value.

Atomics.exchange()

Stores a value at the specified index of the array. Returns the old value.

Atomics.isLockFree()

An optimization primitive that can be used to determine whether to use locks or atomic operations. Returns true if an atomic operation on arrays of the given element size will be implemented using a hardware atomic operation (as opposed to a lock). Experts only.

Atomics.load()

Returns the value at the specified index of the array.

Atomics.notify()

Notifies agents that are waiting on the specified index of the array. Returns the number of agents that were notified.

Atomics.or()

Computes a bitwise OR on the value at the specified index of the array with the provided value. Returns the old value at that index.

Atomics.pause()

Provides a micro-wait primitive that hints to the CPU that the caller is spinning while waiting on access to a shared resource. This allows the system to reduce the resources allocated to the core (such as power) or thread, without yielding the current thread.

Atomics.store()

Stores a value at the specified index of the array. Returns the value.

Atomics.sub()

Subtracts a value at the specified index of the array. Returns the old value at that index.

Atomics.wait()

Verifies that the specified index of the array still contains a value and sleeps awaiting or times out. Returns either "ok", "not-equal", or "timed-out". If waiting is not allowed in the calling agent then it throws an exception. (Most browsers will not allow wait() on the browser's main thread.)

Atomics.waitAsync()

Waits asynchronously (i.e., without blocking, unlike Atomics.wait) on a shared memory location and returns an object representing the result of the operation.

Atomics.xor()

Computes a bitwise XOR on the value at the specified index of the array with the provided value. Returns the old value at that index.

ExamplesUsing Atomicsjsconst sab = new SharedArrayBuffer(1024);
const ta = new Uint8Array(sab);

ta[0]; // 0
ta[0] = 5; // 5

Atomics.add(ta, 0, 12); // 5
Atomics.load(ta, 0); // 17

Atomics.and(ta, 0, 1); // 17
Atomics.load(ta, 0); // 1

Atomics.compareExchange(ta, 0, 5, 12); // 1
Atomics.load(ta, 0); // 1

Atomics.exchange(ta, 0, 12); // 1
Atomics.load(ta, 0); // 12

Atomics.isLockFree(1); // true
Atomics.isLockFree(2); // true
Atomics.isLockFree(3); // false
Atomics.isLockFree(4); // true

Atomics.or(ta, 0, 1); // 12
Atomics.load(ta, 0); // 13

Atomics.store(ta, 0, 12); // 12

Atomics.sub(ta, 0, 2); // 12
Atomics.load(ta, 0); // 10

Atomics.xor(ta, 0, 1); // 10
Atomics.load(ta, 0); // 11
Waiting and notifyingGiven a shared Int32Array:
jsconst sab = new SharedArrayBuffer(1024);
const int32 = new Int32Array(sab);

A reading thread is sleeping and waiting on location 0 because the provided value matches what is stored at the provided index.
The reading thread will not move on until the writing thread has called Atomics.notify() on position 0 of the provided typed array.
Note that if, after being woken up, the value of location 0 has not been changed by the writing thread, the reading thread will not go back to sleep, but will continue on.
jsAtomics.wait(int32, 0, 0);
console.log(int32[0]); // 123

A writing thread stores a new value and notifies the waiting thread once it has written:
jsconsole.log(int32[0]); // 0;
Atomics.store(int32, 0, 123);
Atomics.notify(int32, 0, 1);
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-atomics-objectBrowser compatibilitySee also
ArrayBuffer
JavaScript typed arrays guide
Web Workers
Shared Memory – a brief tutorial in the TC39 ecmascript-sharedmem proposal
A Taste of JavaScript's New Parallel Primitives on hacks.mozilla.org (2016)\n\nAtomicsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since December 2021.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Atomics namespace object contains static methods for carrying out atomic operations. They are used with SharedArrayBuffer and ArrayBuffer objects.DescriptionUnlike most global objects, Atomics is not a constructor. You cannot use it with the new operator or invoke the Atomics object as a function. All properties and methods of Atomics are static (just like the Math object).Atomic operationsWhen memory is shared, multiple threads can read and write the same data in memory. Atomic operations make sure that predictable values are written and read, that operations are finished before the next operation starts and that operations are not interrupted.Wait and notifyThe wait() and notify() methods are modeled on Linux futexes ("fast user-space mutex") and provide ways for waiting until a certain condition becomes true and are typically used as blocking constructs.Static properties
Atomics[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Atomics". This property is used in Object.prototype.toString().

Static methods
Atomics.add()

Adds the provided value to the existing value at the specified index of the array. Returns the old value at that index.

Atomics.and()

Computes a bitwise AND on the value at the specified index of the array with the provided value. Returns the old value at that index.

Atomics.compareExchange()

Stores a value at the specified index of the array, if it equals a value. Returns the old value.

Atomics.exchange()

Stores a value at the specified index of the array. Returns the old value.

Atomics.isLockFree()

An optimization primitive that can be used to determine whether to use locks or atomic operations. Returns true if an atomic operation on arrays of the given element size will be implemented using a hardware atomic operation (as opposed to a lock). Experts only.

Atomics.load()

Returns the value at the specified index of the array.

Atomics.notify()

Notifies agents that are waiting on the specified index of the array. Returns the number of agents that were notified.

Atomics.or()

Computes a bitwise OR on the value at the specified index of the array with the provided value. Returns the old value at that index.

Atomics.pause()

Provides a micro-wait primitive that hints to the CPU that the caller is spinning while waiting on access to a shared resource. This allows the system to reduce the resources allocated to the core (such as power) or thread, without yielding the current thread.

Atomics.store()

Stores a value at the specified index of the array. Returns the value.

Atomics.sub()

Subtracts a value at the specified index of the array. Returns the old value at that index.

Atomics.wait()

Verifies that the specified index of the array still contains a value and sleeps awaiting or times out. Returns either "ok", "not-equal", or "timed-out". If waiting is not allowed in the calling agent then it throws an exception. (Most browsers will not allow wait() on the browser's main thread.)

Atomics.waitAsync()

Waits asynchronously (i.e., without blocking, unlike Atomics.wait) on a shared memory location and returns an object representing the result of the operation.

Atomics.xor()

Computes a bitwise XOR on the value at the specified index of the array with the provided value. Returns the old value at that index.

ExamplesUsing Atomicsjsconst sab = new SharedArrayBuffer(1024);
const ta = new Uint8Array(sab);

ta[0]; // 0
ta[0] = 5; // 5

Atomics.add(ta, 0, 12); // 5
Atomics.load(ta, 0); // 17

Atomics.and(ta, 0, 1); // 17
Atomics.load(ta, 0); // 1

Atomics.compareExchange(ta, 0, 5, 12); // 1
Atomics.load(ta, 0); // 1

Atomics.exchange(ta, 0, 12); // 1
Atomics.load(ta, 0); // 12

Atomics.isLockFree(1); // true
Atomics.isLockFree(2); // true
Atomics.isLockFree(3); // false
Atomics.isLockFree(4); // true

Atomics.or(ta, 0, 1); // 12
Atomics.load(ta, 0); // 13

Atomics.store(ta, 0, 12); // 12

Atomics.sub(ta, 0, 2); // 12
Atomics.load(ta, 0); // 10

Atomics.xor(ta, 0, 1); // 10
Atomics.load(ta, 0); // 11
Waiting and notifyingGiven a shared Int32Array:
jsconst sab = new SharedArrayBuffer(1024);
const int32 = new Int32Array(sab);

A reading thread is sleeping and waiting on location 0 because the provided value matches what is stored at the provided index.
The reading thread will not move on until the writing thread has called Atomics.notify() on position 0 of the provided typed array.
Note that if, after being woken up, the value of location 0 has not been changed by the writing thread, the reading thread will not go back to sleep, but will continue on.
jsAtomics.wait(int32, 0, 0);
console.log(int32[0]); // 123

A writing thread stores a new value and notifies the waiting thread once it has written:
jsconsole.log(int32[0]); // 0;
Atomics.store(int32, 0, 123);
Atomics.notify(int32, 0, 1);
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-atomics-objectBrowser compatibilitySee also
ArrayBuffer
JavaScript typed arrays guide
Web Workers
Shared Memory – a brief tutorial in the TC39 ecmascript-sharedmem proposal
A Taste of JavaScript's New Parallel Primitives on hacks.mozilla.org (2016)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nAtomicsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since December 2021.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Atomics namespace object contains static methods for carrying out atomic operations. They are used with SharedArrayBuffer and ArrayBuffer objects.DescriptionUnlike most global objects, Atomics is not a constructor. You cannot use it with the new operator or invoke the Atomics object as a function. All properties and methods of Atomics are static (just like the Math object).Atomic operationsWhen memory is shared, multiple threads can read and write the same data in memory. Atomic operations make sure that predictable values are written and read, that operations are finished before the next operation starts and that operations are not interrupted.Wait and notifyThe wait() and notify() methods are modeled on Linux futexes ("fast user-space mutex") and provide ways for waiting until a certain condition becomes true and are typically used as blocking constructs.Static properties
Atomics[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Atomics". This property is used in Object.prototype.toString().

Static methods
Atomics.add()

Adds the provided value to the existing value at the specified index of the array. Returns the old value at that index.

Atomics.and()

Computes a bitwise AND on the value at the specified index of the array with the provided value. Returns the old value at that index.

Atomics.compareExchange()

Stores a value at the specified index of the array, if it equals a value. Returns the old value.

Atomics.exchange()

Stores a value at the specified index of the array. Returns the old value.

Atomics.isLockFree()

An optimization primitive that can be used to determine whether to use locks or atomic operations. Returns true if an atomic operation on arrays of the given element size will be implemented using a hardware atomic operation (as opposed to a lock). Experts only.

Atomics.load()

Returns the value at the specified index of the array.

Atomics.notify()

Notifies agents that are waiting on the specified index of the array. Returns the number of agents that were notified.

Atomics.or()

Computes a bitwise OR on the value at the specified index of the array with the provided value. Returns the old value at that index.

Atomics.pause()

Provides a micro-wait primitive that hints to the CPU that the caller is spinning while waiting on access to a shared resource. This allows the system to reduce the resources allocated to the core (such as power) or thread, without yielding the current thread.

Atomics.store()

Stores a value at the specified index of the array. Returns the value.

Atomics.sub()

Subtracts a value at the specified index of the array. Returns the old value at that index.

Atomics.wait()

Verifies that the specified index of the array still contains a value and sleeps awaiting or times out. Returns either "ok", "not-equal", or "timed-out". If waiting is not allowed in the calling agent then it throws an exception. (Most browsers will not allow wait() on the browser's main thread.)

Atomics.waitAsync()

Waits asynchronously (i.e., without blocking, unlike Atomics.wait) on a shared memory location and returns an object representing the result of the operation.

Atomics.xor()

Computes a bitwise XOR on the value at the specified index of the array with the provided value. Returns the old value at that index.

ExamplesUsing Atomicsjsconst sab = new SharedArrayBuffer(1024);
const ta = new Uint8Array(sab);

ta[0]; // 0
ta[0] = 5; // 5

Atomics.add(ta, 0, 12); // 5
Atomics.load(ta, 0); // 17

Atomics.and(ta, 0, 1); // 17
Atomics.load(ta, 0); // 1

Atomics.compareExchange(ta, 0, 5, 12); // 1
Atomics.load(ta, 0); // 1

Atomics.exchange(ta, 0, 12); // 1
Atomics.load(ta, 0); // 12

Atomics.isLockFree(1); // true
Atomics.isLockFree(2); // true
Atomics.isLockFree(3); // false
Atomics.isLockFree(4); // true

Atomics.or(ta, 0, 1); // 12
Atomics.load(ta, 0); // 13

Atomics.store(ta, 0, 12); // 12

Atomics.sub(ta, 0, 2); // 12
Atomics.load(ta, 0); // 10

Atomics.xor(ta, 0, 1); // 10
Atomics.load(ta, 0); // 11
Waiting and notifyingGiven a shared Int32Array:
jsconst sab = new SharedArrayBuffer(1024);
const int32 = new Int32Array(sab);

A reading thread is sleeping and waiting on location 0 because the provided value matches what is stored at the provided index.
The reading thread will not move on until the writing thread has called Atomics.notify() on position 0 of the provided typed array.
Note that if, after being woken up, the value of location 0 has not been changed by the writing thread, the reading thread will not go back to sleep, but will continue on.
jsAtomics.wait(int32, 0, 0);
console.log(int32[0]); // 123

A writing thread stores a new value and notifies the waiting thread once it has written:
jsconsole.log(int32[0]); // 0;
Atomics.store(int32, 0, 123);
Atomics.notify(int32, 0, 1);
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-atomics-objectBrowser compatibilitySee also
ArrayBuffer
JavaScript typed arrays guide
Web Workers
Shared Memory – a brief tutorial in the TC39 ecmascript-sharedmem proposal
A Taste of JavaScript's New Parallel Primitives on hacks.mozilla.org (2016)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nBigIntBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2020.Learn moreSee full compatibilityReport feedbackBigInt values represent integer values which are too high or too low to be represented by the number primitive.DescriptionA BigInt value, also sometimes just called a BigInt, is a bigint primitive, created by appending n to the end of an integer literal, or by calling the BigInt() function (without the new operator) and giving it an integer value or string value.
jsconst previouslyMaxSafeInteger = 9007199254740991n;

const alsoHuge = BigInt(9007199254740991);
// 9007199254740991n

const hugeString = BigInt("9007199254740991");
// 9007199254740991n

const hugeHex = BigInt("0x1fffffffffffff");
// 9007199254740991n

const hugeOctal = BigInt("0o377777777777777777");
// 9007199254740991n

const hugeBin = BigInt(
  "0b11111111111111111111111111111111111111111111111111111",
);
// 9007199254740991n

BigInt values are similar to Number values in some ways, but also differ in a few key matters: A BigInt value cannot be used with methods in the built-in Math object and cannot be mixed with a Number value in operations; they must be coerced to the same type. Be careful coercing values back and forth, however, as the precision of a BigInt value may be lost when it is coerced to a Number value.Type informationWhen tested against typeof, a BigInt value (bigint primitive) will give "bigint":
jstypeof 1n === "bigint"; // true
typeof BigInt("1") === "bigint"; // true

A BigInt value can also be wrapped in an Object:
jstypeof Object(1n) === "object"; // true
OperatorsMost operators support BigInts, however most do not permit operands to be of mixed types — both operands must be BigInt or neither:

Arithmetic operators: +, -, *, /, %, **
Bitwise operators: >>, <<, &, |, ^, ~
Unary negation (-)
Increment/decrement: ++, --

The boolean-returning operators allow mixing numbers and BigInts as operands:

Relational operators and equality operators: >, <, >=, <=, ==, !=, ===, !==
Logical operators only rely on the truthiness of operands

A couple of operators do not support BigInt at all:

Unary plus (+) cannot be supported due to conflicting usage in asm.js, so it has been left out in order to not break asm.js.
Unsigned right shift (>>>) is the only bitwise operator that's unsupported, as every BigInt value is signed.

Special cases:

Addition (+) involving a string and a BigInt returns a string.
Division (/) truncates fractional components towards zero, since BigInt is unable to represent fractional quantities.

jsconst previousMaxSafe = BigInt(Number.MAX_SAFE_INTEGER); // 9007199254740991n
const maxPlusOne = previousMaxSafe + 1n; // 9007199254740992n
const theFuture = previousMaxSafe + 2n; // 9007199254740993n, this works now!
const prod = previousMaxSafe * 2n; // 18014398509481982n
const diff = prod - 10n; // 18014398509481972n
const mod = prod % 10n; // 2n
const bigN = 2n ** 54n; // 18014398509481984n
bigN * -1n; // -18014398509481984n
const expected = 4n / 2n; // 2n
const truncated = 5n / 2n; // 2n, not 2.5n
ComparisonsA BigInt value is not strictly equal to a Number value, but it is loosely so:
js0n === 0; // false
0n == 0; // true

A Number value and a BigInt value may be compared as usual:
js1n < 2; // true
2n > 1; // true
2 > 2; // false
2n > 2; // false
2n >= 2; // true

BigInt values and Number values may be mixed in arrays and sorted:
jsconst mixed = [4n, 6, -12n, 10, 4, 0, 0n];
// [4n, 6, -12n, 10, 4, 0, 0n]

mixed.sort(); // default sorting behavior
// [ -12n, 0, 0n, 10, 4n, 4, 6 ]

mixed.sort((a, b) => a - b);
// won't work since subtraction will not work with mixed types
// TypeError: can't convert BigInt value to Number value

// sort with an appropriate numeric comparator
mixed.sort((a, b) => (a < b ? -1 : a > b ? 1 : 0));
// [ -12n, 0, 0n, 4n, 4, 6, 10 ]

Note that comparisons with Object-wrapped BigInt values act as with other objects, only indicating equality when the same object instance is compared:
jsObject(0n) === 0n; // false
Object(0n) === Object(0n); // false

const o = Object(0n);
o === o; // true

Because coercing between Number values and BigInt values can lead to loss of precision, the following are recommended:

Only use a BigInt value when values greater than 253 are reasonably expected.
Don't coerce between BigInt values and Number values.
ConditionalsA BigInt value follows the same conversion rules as Numbers when:

it is converted to a Boolean: via the Boolean function;
when used with logical operators ||, &&, and !; or
within a conditional test like an if statement.

Namely, only 0n is falsy; everything else is truthy.
jsif (0n) {
  console.log("Hello from the if!");
} else {
  console.log("Hello from the else!");
}
// "Hello from the else!"

0n || 12n; // 12n
0n && 12n; // 0n
Boolean(0n); // false
Boolean(12n); // true
!12n; // false
!0n; // true
CryptographyThe operations supported on BigInt values are not constant-time and are thus open to timing attacks. JavaScript BigInts therefore could be dangerous for use in cryptography without mitigating factors. As a very generic example, an attacker could measure the time difference between 101n ** 65537n and 17n ** 9999n, and deduce the magnitude of secrets, such as private keys, based on the time elapsed. If you still have to use BigInts, take a look at the Timing attack FAQ for general advice regarding the issue.Use within JSONUsing JSON.stringify() with any BigInt value will raise a TypeError, as BigInt values aren't serialized in JSON by default. However, JSON.stringify() specifically leaves a backdoor for BigInt values: it would try to call the BigInt's toJSON() method. (It doesn't do so for any other primitive values.) Therefore, you can implement your own toJSON() method (which is one of the few cases where patching built-in objects is not explicitly discouraged):
jsBigInt.prototype.toJSON = function () {
  return { $bigint: this.toString() };
};

Instead of throwing, JSON.stringify() now produces a string like this:
jsconsole.log(JSON.stringify({ a: 1n }));
// {"a":{"$bigint":"1"}}

If you do not wish to patch BigInt.prototype, you can use the replacer parameter of JSON.stringify to serialize BigInt values:
jsconst replacer = (key, value) =>
  typeof value === "bigint" ? { $bigint: value.toString() } : value;

const data = {
  number: 1,
  big: 18014398509481982n,
};
const stringified = JSON.stringify(data, replacer);

console.log(stringified);
// {"number":1,"big":{"$bigint":"18014398509481982"}}

You can then use the reviver parameter of JSON.parse to handle them:
jsconst reviver = (key, value) =>
  value !== null &&
  typeof value === "object" &&
  "$bigint" in value &&
  typeof value.$bigint === "string"
    ? BigInt(value.$bigint)
    : value;

const payload = '{"number":1,"big":{"$bigint":"18014398509481982"}}';
const parsed = JSON.parse(payload, reviver);

console.log(parsed);
// { number: 1, big: 18014398509481982n }


Note:
While it's possible to make the replacer of JSON.stringify() generic and properly serialize BigInt values for all objects as shown above, the reviver of JSON.parse() has to be used with caution, because the serialization is irreversible: it's not possible to distinguish between an object that happens to have a property called $bigint and an actual BigInt.
In addition, the example above creates an entire object during replacing and reviving, which may have performance or storage implications for larger objects containing many BigInts. If you know the shape of the payload, it may be better to just serialize them as strings and revive them based on the property key's name instead.

In fact, JSON allows number literals that are arbitrarily long; they just cannot be parsed to full precision in JavaScript. If you are communicating with another program in a language that supports longer integers (such as 64-bit integers), and you want to transmit the BigInt as a JSON number instead of a JSON string, see Lossless number serialization.BigInt coercionMany built-in operations that expect BigInts first coerce their arguments to BigInts. The operation can be summarized as follows:

BigInts are returned as-is.
undefined and null throw a TypeError.
true turns into 1n; false turns into 0n.
Strings are converted by parsing them as if they contain an integer literal. Any parsing failure results in a SyntaxError. The syntax is a subset of string numeric literals, where decimal points or exponent indicators are not allowed.
Numbers throw a TypeError to prevent unintended implicit coercion causing loss of precision.
Symbols throw a TypeError.
Objects are first converted to a primitive by calling their [Symbol.toPrimitive]() (with "number" as hint), valueOf(), and toString() methods, in that order. The resulting primitive is then converted to a BigInt.

The best way to achieve nearly the same effect in JavaScript is through the BigInt() function: BigInt(x) uses the same algorithm to convert x, except that Numbers don't throw a TypeError, but are converted to BigInts if they are integers.
Note that built-in operations expecting BigInts often truncate the BigInt to a fixed width after coercion. This includes BigInt.asIntN(), BigInt.asUintN(), and methods of BigInt64Array and BigUint64Array.Constructor
BigInt()

Returns primitive values of type BigInt. Throws an error when called with new.

Static methods
BigInt.asIntN()

Clamps a BigInt value to a signed integer value, and returns that value.

BigInt.asUintN()

Clamps a BigInt value to an unsigned integer value, and returns that value.

Instance propertiesThese properties are defined on BigInt.prototype and shared by all BigInt instances.

BigInt.prototype.constructor

The constructor function that created the instance object. For BigInt instances, the initial value is the BigInt constructor.

BigInt.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "BigInt". This property is used in Object.prototype.toString(). However, because BigInt also has its own toString() method, this property is not used unless you call Object.prototype.toString.call() with a BigInt as thisArg.

Instance methods
BigInt.prototype.toLocaleString()

Returns a string with a language-sensitive representation of this BigInt value. Overrides the Object.prototype.toLocaleString() method.

BigInt.prototype.toString()

Returns a string representing this BigInt value in the specified radix (base). Overrides the Object.prototype.toString() method.

BigInt.prototype.valueOf()

Returns this BigInt value. Overrides the Object.prototype.valueOf() method.

ExamplesCalculating Primesjs// Returns true if the passed BigInt value is a prime number
function isPrime(p) {
  for (let i = 2n; i * i <= p; i++) {
    if (p % i === 0n) return false;
  }
  return true;
}

// Takes a BigInt value as an argument, returns nth prime number as a BigInt value
function nthPrime(nth) {
  let maybePrime = 2n;
  let prime = 0n;

  while (nth >= 0n) {
    if (isPrime(maybePrime)) {
      nth--;
      prime = maybePrime;
    }
    maybePrime++;
  }

  return prime;
}

nthPrime(20n);
// 73n
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-bigint-objectsBrowser compatibilitySee also
Number
Number.MAX_SAFE_INTEGER\n\nBigIntBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2020.Learn moreSee full compatibilityReport feedbackBigInt values represent integer values which are too high or too low to be represented by the number primitive.DescriptionA BigInt value, also sometimes just called a BigInt, is a bigint primitive, created by appending n to the end of an integer literal, or by calling the BigInt() function (without the new operator) and giving it an integer value or string value.
jsconst previouslyMaxSafeInteger = 9007199254740991n;

const alsoHuge = BigInt(9007199254740991);
// 9007199254740991n

const hugeString = BigInt("9007199254740991");
// 9007199254740991n

const hugeHex = BigInt("0x1fffffffffffff");
// 9007199254740991n

const hugeOctal = BigInt("0o377777777777777777");
// 9007199254740991n

const hugeBin = BigInt(
  "0b11111111111111111111111111111111111111111111111111111",
);
// 9007199254740991n

BigInt values are similar to Number values in some ways, but also differ in a few key matters: A BigInt value cannot be used with methods in the built-in Math object and cannot be mixed with a Number value in operations; they must be coerced to the same type. Be careful coercing values back and forth, however, as the precision of a BigInt value may be lost when it is coerced to a Number value.Type informationWhen tested against typeof, a BigInt value (bigint primitive) will give "bigint":
jstypeof 1n === "bigint"; // true
typeof BigInt("1") === "bigint"; // true

A BigInt value can also be wrapped in an Object:
jstypeof Object(1n) === "object"; // true
OperatorsMost operators support BigInts, however most do not permit operands to be of mixed types — both operands must be BigInt or neither:

Arithmetic operators: +, -, *, /, %, **
Bitwise operators: >>, <<, &, |, ^, ~
Unary negation (-)
Increment/decrement: ++, --

The boolean-returning operators allow mixing numbers and BigInts as operands:

Relational operators and equality operators: >, <, >=, <=, ==, !=, ===, !==
Logical operators only rely on the truthiness of operands

A couple of operators do not support BigInt at all:

Unary plus (+) cannot be supported due to conflicting usage in asm.js, so it has been left out in order to not break asm.js.
Unsigned right shift (>>>) is the only bitwise operator that's unsupported, as every BigInt value is signed.

Special cases:

Addition (+) involving a string and a BigInt returns a string.
Division (/) truncates fractional components towards zero, since BigInt is unable to represent fractional quantities.

jsconst previousMaxSafe = BigInt(Number.MAX_SAFE_INTEGER); // 9007199254740991n
const maxPlusOne = previousMaxSafe + 1n; // 9007199254740992n
const theFuture = previousMaxSafe + 2n; // 9007199254740993n, this works now!
const prod = previousMaxSafe * 2n; // 18014398509481982n
const diff = prod - 10n; // 18014398509481972n
const mod = prod % 10n; // 2n
const bigN = 2n ** 54n; // 18014398509481984n
bigN * -1n; // -18014398509481984n
const expected = 4n / 2n; // 2n
const truncated = 5n / 2n; // 2n, not 2.5n
ComparisonsA BigInt value is not strictly equal to a Number value, but it is loosely so:
js0n === 0; // false
0n == 0; // true

A Number value and a BigInt value may be compared as usual:
js1n < 2; // true
2n > 1; // true
2 > 2; // false
2n > 2; // false
2n >= 2; // true

BigInt values and Number values may be mixed in arrays and sorted:
jsconst mixed = [4n, 6, -12n, 10, 4, 0, 0n];
// [4n, 6, -12n, 10, 4, 0, 0n]

mixed.sort(); // default sorting behavior
// [ -12n, 0, 0n, 10, 4n, 4, 6 ]

mixed.sort((a, b) => a - b);
// won't work since subtraction will not work with mixed types
// TypeError: can't convert BigInt value to Number value

// sort with an appropriate numeric comparator
mixed.sort((a, b) => (a < b ? -1 : a > b ? 1 : 0));
// [ -12n, 0, 0n, 4n, 4, 6, 10 ]

Note that comparisons with Object-wrapped BigInt values act as with other objects, only indicating equality when the same object instance is compared:
jsObject(0n) === 0n; // false
Object(0n) === Object(0n); // false

const o = Object(0n);
o === o; // true

Because coercing between Number values and BigInt values can lead to loss of precision, the following are recommended:

Only use a BigInt value when values greater than 253 are reasonably expected.
Don't coerce between BigInt values and Number values.
ConditionalsA BigInt value follows the same conversion rules as Numbers when:

it is converted to a Boolean: via the Boolean function;
when used with logical operators ||, &&, and !; or
within a conditional test like an if statement.

Namely, only 0n is falsy; everything else is truthy.
jsif (0n) {
  console.log("Hello from the if!");
} else {
  console.log("Hello from the else!");
}
// "Hello from the else!"

0n || 12n; // 12n
0n && 12n; // 0n
Boolean(0n); // false
Boolean(12n); // true
!12n; // false
!0n; // true
CryptographyThe operations supported on BigInt values are not constant-time and are thus open to timing attacks. JavaScript BigInts therefore could be dangerous for use in cryptography without mitigating factors. As a very generic example, an attacker could measure the time difference between 101n ** 65537n and 17n ** 9999n, and deduce the magnitude of secrets, such as private keys, based on the time elapsed. If you still have to use BigInts, take a look at the Timing attack FAQ for general advice regarding the issue.Use within JSONUsing JSON.stringify() with any BigInt value will raise a TypeError, as BigInt values aren't serialized in JSON by default. However, JSON.stringify() specifically leaves a backdoor for BigInt values: it would try to call the BigInt's toJSON() method. (It doesn't do so for any other primitive values.) Therefore, you can implement your own toJSON() method (which is one of the few cases where patching built-in objects is not explicitly discouraged):
jsBigInt.prototype.toJSON = function () {
  return { $bigint: this.toString() };
};

Instead of throwing, JSON.stringify() now produces a string like this:
jsconsole.log(JSON.stringify({ a: 1n }));
// {"a":{"$bigint":"1"}}

If you do not wish to patch BigInt.prototype, you can use the replacer parameter of JSON.stringify to serialize BigInt values:
jsconst replacer = (key, value) =>
  typeof value === "bigint" ? { $bigint: value.toString() } : value;

const data = {
  number: 1,
  big: 18014398509481982n,
};
const stringified = JSON.stringify(data, replacer);

console.log(stringified);
// {"number":1,"big":{"$bigint":"18014398509481982"}}

You can then use the reviver parameter of JSON.parse to handle them:
jsconst reviver = (key, value) =>
  value !== null &&
  typeof value === "object" &&
  "$bigint" in value &&
  typeof value.$bigint === "string"
    ? BigInt(value.$bigint)
    : value;

const payload = '{"number":1,"big":{"$bigint":"18014398509481982"}}';
const parsed = JSON.parse(payload, reviver);

console.log(parsed);
// { number: 1, big: 18014398509481982n }


Note:
While it's possible to make the replacer of JSON.stringify() generic and properly serialize BigInt values for all objects as shown above, the reviver of JSON.parse() has to be used with caution, because the serialization is irreversible: it's not possible to distinguish between an object that happens to have a property called $bigint and an actual BigInt.
In addition, the example above creates an entire object during replacing and reviving, which may have performance or storage implications for larger objects containing many BigInts. If you know the shape of the payload, it may be better to just serialize them as strings and revive them based on the property key's name instead.

In fact, JSON allows number literals that are arbitrarily long; they just cannot be parsed to full precision in JavaScript. If you are communicating with another program in a language that supports longer integers (such as 64-bit integers), and you want to transmit the BigInt as a JSON number instead of a JSON string, see Lossless number serialization.BigInt coercionMany built-in operations that expect BigInts first coerce their arguments to BigInts. The operation can be summarized as follows:

BigInts are returned as-is.
undefined and null throw a TypeError.
true turns into 1n; false turns into 0n.
Strings are converted by parsing them as if they contain an integer literal. Any parsing failure results in a SyntaxError. The syntax is a subset of string numeric literals, where decimal points or exponent indicators are not allowed.
Numbers throw a TypeError to prevent unintended implicit coercion causing loss of precision.
Symbols throw a TypeError.
Objects are first converted to a primitive by calling their [Symbol.toPrimitive]() (with "number" as hint), valueOf(), and toString() methods, in that order. The resulting primitive is then converted to a BigInt.

The best way to achieve nearly the same effect in JavaScript is through the BigInt() function: BigInt(x) uses the same algorithm to convert x, except that Numbers don't throw a TypeError, but are converted to BigInts if they are integers.
Note that built-in operations expecting BigInts often truncate the BigInt to a fixed width after coercion. This includes BigInt.asIntN(), BigInt.asUintN(), and methods of BigInt64Array and BigUint64Array.Constructor
BigInt()

Returns primitive values of type BigInt. Throws an error when called with new.

Static methods
BigInt.asIntN()

Clamps a BigInt value to a signed integer value, and returns that value.

BigInt.asUintN()

Clamps a BigInt value to an unsigned integer value, and returns that value.

Instance propertiesThese properties are defined on BigInt.prototype and shared by all BigInt instances.

BigInt.prototype.constructor

The constructor function that created the instance object. For BigInt instances, the initial value is the BigInt constructor.

BigInt.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "BigInt". This property is used in Object.prototype.toString(). However, because BigInt also has its own toString() method, this property is not used unless you call Object.prototype.toString.call() with a BigInt as thisArg.

Instance methods
BigInt.prototype.toLocaleString()

Returns a string with a language-sensitive representation of this BigInt value. Overrides the Object.prototype.toLocaleString() method.

BigInt.prototype.toString()

Returns a string representing this BigInt value in the specified radix (base). Overrides the Object.prototype.toString() method.

BigInt.prototype.valueOf()

Returns this BigInt value. Overrides the Object.prototype.valueOf() method.

ExamplesCalculating Primesjs// Returns true if the passed BigInt value is a prime number
function isPrime(p) {
  for (let i = 2n; i * i <= p; i++) {
    if (p % i === 0n) return false;
  }
  return true;
}

// Takes a BigInt value as an argument, returns nth prime number as a BigInt value
function nthPrime(nth) {
  let maybePrime = 2n;
  let prime = 0n;

  while (nth >= 0n) {
    if (isPrime(maybePrime)) {
      nth--;
      prime = maybePrime;
    }
    maybePrime++;
  }

  return prime;
}

nthPrime(20n);
// 73n
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-bigint-objectsBrowser compatibilitySee also
Number
Number.MAX_SAFE_INTEGER
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nBigIntBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2020.Learn moreSee full compatibilityReport feedbackBigInt values represent integer values which are too high or too low to be represented by the number primitive.DescriptionA BigInt value, also sometimes just called a BigInt, is a bigint primitive, created by appending n to the end of an integer literal, or by calling the BigInt() function (without the new operator) and giving it an integer value or string value.
jsconst previouslyMaxSafeInteger = 9007199254740991n;

const alsoHuge = BigInt(9007199254740991);
// 9007199254740991n

const hugeString = BigInt("9007199254740991");
// 9007199254740991n

const hugeHex = BigInt("0x1fffffffffffff");
// 9007199254740991n

const hugeOctal = BigInt("0o377777777777777777");
// 9007199254740991n

const hugeBin = BigInt(
  "0b11111111111111111111111111111111111111111111111111111",
);
// 9007199254740991n

BigInt values are similar to Number values in some ways, but also differ in a few key matters: A BigInt value cannot be used with methods in the built-in Math object and cannot be mixed with a Number value in operations; they must be coerced to the same type. Be careful coercing values back and forth, however, as the precision of a BigInt value may be lost when it is coerced to a Number value.Type informationWhen tested against typeof, a BigInt value (bigint primitive) will give "bigint":
jstypeof 1n === "bigint"; // true
typeof BigInt("1") === "bigint"; // true

A BigInt value can also be wrapped in an Object:
jstypeof Object(1n) === "object"; // true
OperatorsMost operators support BigInts, however most do not permit operands to be of mixed types — both operands must be BigInt or neither:

Arithmetic operators: +, -, *, /, %, **
Bitwise operators: >>, <<, &, |, ^, ~
Unary negation (-)
Increment/decrement: ++, --

The boolean-returning operators allow mixing numbers and BigInts as operands:

Relational operators and equality operators: >, <, >=, <=, ==, !=, ===, !==
Logical operators only rely on the truthiness of operands

A couple of operators do not support BigInt at all:

Unary plus (+) cannot be supported due to conflicting usage in asm.js, so it has been left out in order to not break asm.js.
Unsigned right shift (>>>) is the only bitwise operator that's unsupported, as every BigInt value is signed.

Special cases:

Addition (+) involving a string and a BigInt returns a string.
Division (/) truncates fractional components towards zero, since BigInt is unable to represent fractional quantities.

jsconst previousMaxSafe = BigInt(Number.MAX_SAFE_INTEGER); // 9007199254740991n
const maxPlusOne = previousMaxSafe + 1n; // 9007199254740992n
const theFuture = previousMaxSafe + 2n; // 9007199254740993n, this works now!
const prod = previousMaxSafe * 2n; // 18014398509481982n
const diff = prod - 10n; // 18014398509481972n
const mod = prod % 10n; // 2n
const bigN = 2n ** 54n; // 18014398509481984n
bigN * -1n; // -18014398509481984n
const expected = 4n / 2n; // 2n
const truncated = 5n / 2n; // 2n, not 2.5n
ComparisonsA BigInt value is not strictly equal to a Number value, but it is loosely so:
js0n === 0; // false
0n == 0; // true

A Number value and a BigInt value may be compared as usual:
js1n < 2; // true
2n > 1; // true
2 > 2; // false
2n > 2; // false
2n >= 2; // true

BigInt values and Number values may be mixed in arrays and sorted:
jsconst mixed = [4n, 6, -12n, 10, 4, 0, 0n];
// [4n, 6, -12n, 10, 4, 0, 0n]

mixed.sort(); // default sorting behavior
// [ -12n, 0, 0n, 10, 4n, 4, 6 ]

mixed.sort((a, b) => a - b);
// won't work since subtraction will not work with mixed types
// TypeError: can't convert BigInt value to Number value

// sort with an appropriate numeric comparator
mixed.sort((a, b) => (a < b ? -1 : a > b ? 1 : 0));
// [ -12n, 0, 0n, 4n, 4, 6, 10 ]

Note that comparisons with Object-wrapped BigInt values act as with other objects, only indicating equality when the same object instance is compared:
jsObject(0n) === 0n; // false
Object(0n) === Object(0n); // false

const o = Object(0n);
o === o; // true

Because coercing between Number values and BigInt values can lead to loss of precision, the following are recommended:

Only use a BigInt value when values greater than 253 are reasonably expected.
Don't coerce between BigInt values and Number values.
ConditionalsA BigInt value follows the same conversion rules as Numbers when:

it is converted to a Boolean: via the Boolean function;
when used with logical operators ||, &&, and !; or
within a conditional test like an if statement.

Namely, only 0n is falsy; everything else is truthy.
jsif (0n) {
  console.log("Hello from the if!");
} else {
  console.log("Hello from the else!");
}
// "Hello from the else!"

0n || 12n; // 12n
0n && 12n; // 0n
Boolean(0n); // false
Boolean(12n); // true
!12n; // false
!0n; // true
CryptographyThe operations supported on BigInt values are not constant-time and are thus open to timing attacks. JavaScript BigInts therefore could be dangerous for use in cryptography without mitigating factors. As a very generic example, an attacker could measure the time difference between 101n ** 65537n and 17n ** 9999n, and deduce the magnitude of secrets, such as private keys, based on the time elapsed. If you still have to use BigInts, take a look at the Timing attack FAQ for general advice regarding the issue.Use within JSONUsing JSON.stringify() with any BigInt value will raise a TypeError, as BigInt values aren't serialized in JSON by default. However, JSON.stringify() specifically leaves a backdoor for BigInt values: it would try to call the BigInt's toJSON() method. (It doesn't do so for any other primitive values.) Therefore, you can implement your own toJSON() method (which is one of the few cases where patching built-in objects is not explicitly discouraged):
jsBigInt.prototype.toJSON = function () {
  return { $bigint: this.toString() };
};

Instead of throwing, JSON.stringify() now produces a string like this:
jsconsole.log(JSON.stringify({ a: 1n }));
// {"a":{"$bigint":"1"}}

If you do not wish to patch BigInt.prototype, you can use the replacer parameter of JSON.stringify to serialize BigInt values:
jsconst replacer = (key, value) =>
  typeof value === "bigint" ? { $bigint: value.toString() } : value;

const data = {
  number: 1,
  big: 18014398509481982n,
};
const stringified = JSON.stringify(data, replacer);

console.log(stringified);
// {"number":1,"big":{"$bigint":"18014398509481982"}}

You can then use the reviver parameter of JSON.parse to handle them:
jsconst reviver = (key, value) =>
  value !== null &&
  typeof value === "object" &&
  "$bigint" in value &&
  typeof value.$bigint === "string"
    ? BigInt(value.$bigint)
    : value;

const payload = '{"number":1,"big":{"$bigint":"18014398509481982"}}';
const parsed = JSON.parse(payload, reviver);

console.log(parsed);
// { number: 1, big: 18014398509481982n }


Note:
While it's possible to make the replacer of JSON.stringify() generic and properly serialize BigInt values for all objects as shown above, the reviver of JSON.parse() has to be used with caution, because the serialization is irreversible: it's not possible to distinguish between an object that happens to have a property called $bigint and an actual BigInt.
In addition, the example above creates an entire object during replacing and reviving, which may have performance or storage implications for larger objects containing many BigInts. If you know the shape of the payload, it may be better to just serialize them as strings and revive them based on the property key's name instead.

In fact, JSON allows number literals that are arbitrarily long; they just cannot be parsed to full precision in JavaScript. If you are communicating with another program in a language that supports longer integers (such as 64-bit integers), and you want to transmit the BigInt as a JSON number instead of a JSON string, see Lossless number serialization.BigInt coercionMany built-in operations that expect BigInts first coerce their arguments to BigInts. The operation can be summarized as follows:

BigInts are returned as-is.
undefined and null throw a TypeError.
true turns into 1n; false turns into 0n.
Strings are converted by parsing them as if they contain an integer literal. Any parsing failure results in a SyntaxError. The syntax is a subset of string numeric literals, where decimal points or exponent indicators are not allowed.
Numbers throw a TypeError to prevent unintended implicit coercion causing loss of precision.
Symbols throw a TypeError.
Objects are first converted to a primitive by calling their [Symbol.toPrimitive]() (with "number" as hint), valueOf(), and toString() methods, in that order. The resulting primitive is then converted to a BigInt.

The best way to achieve nearly the same effect in JavaScript is through the BigInt() function: BigInt(x) uses the same algorithm to convert x, except that Numbers don't throw a TypeError, but are converted to BigInts if they are integers.
Note that built-in operations expecting BigInts often truncate the BigInt to a fixed width after coercion. This includes BigInt.asIntN(), BigInt.asUintN(), and methods of BigInt64Array and BigUint64Array.Constructor
BigInt()

Returns primitive values of type BigInt. Throws an error when called with new.

Static methods
BigInt.asIntN()

Clamps a BigInt value to a signed integer value, and returns that value.

BigInt.asUintN()

Clamps a BigInt value to an unsigned integer value, and returns that value.

Instance propertiesThese properties are defined on BigInt.prototype and shared by all BigInt instances.

BigInt.prototype.constructor

The constructor function that created the instance object. For BigInt instances, the initial value is the BigInt constructor.

BigInt.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "BigInt". This property is used in Object.prototype.toString(). However, because BigInt also has its own toString() method, this property is not used unless you call Object.prototype.toString.call() with a BigInt as thisArg.

Instance methods
BigInt.prototype.toLocaleString()

Returns a string with a language-sensitive representation of this BigInt value. Overrides the Object.prototype.toLocaleString() method.

BigInt.prototype.toString()

Returns a string representing this BigInt value in the specified radix (base). Overrides the Object.prototype.toString() method.

BigInt.prototype.valueOf()

Returns this BigInt value. Overrides the Object.prototype.valueOf() method.

ExamplesCalculating Primesjs// Returns true if the passed BigInt value is a prime number
function isPrime(p) {
  for (let i = 2n; i * i <= p; i++) {
    if (p % i === 0n) return false;
  }
  return true;
}

// Takes a BigInt value as an argument, returns nth prime number as a BigInt value
function nthPrime(nth) {
  let maybePrime = 2n;
  let prime = 0n;

  while (nth >= 0n) {
    if (isPrime(maybePrime)) {
      nth--;
      prime = maybePrime;
    }
    maybePrime++;
  }

  return prime;
}

nthPrime(20n);
// 73n
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-bigint-objectsBrowser compatibilitySee also
Number
Number.MAX_SAFE_INTEGER
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nBigInt64ArrayBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2021.Learn moreSee full compatibilityReport feedbackThe BigInt64Array typed array represents an array of 64-bit signed integers in the platform byte order. If control over byte order is needed, use DataView instead. The contents are initialized to 0n unless initialization data is explicitly provided. Once established, you can reference elements in the array using the object's methods, or using standard array index syntax (that is, using bracket notation).
BigInt64Array is a subclass of the hidden TypedArray class.Try it
const buffer = new ArrayBuffer(24);
const bigint64 = new BigInt64Array(buffer);
bigint64[0] = 5886014448488689n;
bigint64[1] = 1881938909131133n;
bigint64[2] = 1898875537769492n;

bigint64[0] = 6118793953620967n;
console.log(bigint64);
// Expected Output: BigInt64Array [6118793953620967n, 1881938909131133n, 1898875537769492n]

console.log(bigint64[2]);
// Expected Output: 1898875537769492n

console.log("Array length:", bigint64.length);
// Expected Output: Array length: 3

console.log("Array byte length:", bigint64.byteLength);
// Expected Output: Array byte length: 24

console.log("Array byte offset:", bigint64.byteOffset);
// Expected Output: Array byte offset: 0

bigint64.set([100n, 200n], 1);
console.log(bigint64);
// Expected Output: BigInt64Array [6118793953620967n, 100n, 200n]
Constructor
BigInt64Array()

Creates a new BigInt64Array object.

Static propertiesAlso inherits static properties from its parent TypedArray.

BigInt64Array.BYTES_PER_ELEMENT

Returns a number value of the element size. 8 in the case of BigInt64Array.

Static methodsInherits static methods from its parent TypedArray.Instance propertiesAlso inherits instance properties from its parent TypedArray.
These properties are defined on BigInt64Array.prototype and shared by all BigInt64Array instances.

BigInt64Array.prototype.BYTES_PER_ELEMENT

Returns a number value of the element size. 8 in the case of a BigInt64Array.

BigInt64Array.prototype.constructor

The constructor function that created the instance object. For BigInt64Array instances, the initial value is the BigInt64Array constructor.

Instance methodsInherits instance methods from its parent TypedArray.ExamplesDifferent ways to create a BigInt64Arrayjs// From a length
const bigint64 = new BigInt64Array(2);
bigint64[0] = 42n;
console.log(bigint64[0]); // 42n
console.log(bigint64.length); // 2
console.log(bigint64.BYTES_PER_ELEMENT); // 8

// From an array
const x = new BigInt64Array([21n, 31n]);
console.log(x[1]); // 31n

// From another TypedArray
const y = new BigInt64Array(x);
console.log(y[0]); // 21n

// From an ArrayBuffer
const buffer = new ArrayBuffer(64);
const z = new BigInt64Array(buffer, 8, 4);
console.log(z.byteOffset); // 8

// From an iterable
const iterable = (function* () {
  yield* [1n, 2n, 3n];
})();
const bigint64FromIterable = new BigInt64Array(iterable);
console.log(bigint64FromIterable);
// BigInt64Array [1n, 2n, 3n]
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-typedarray-objectsBrowser compatibilitySee also
JavaScript typed arrays guide
TypedArray
ArrayBuffer
DataView\n\nBigInt64ArrayBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2021.Learn moreSee full compatibilityReport feedbackThe BigInt64Array typed array represents an array of 64-bit signed integers in the platform byte order. If control over byte order is needed, use DataView instead. The contents are initialized to 0n unless initialization data is explicitly provided. Once established, you can reference elements in the array using the object's methods, or using standard array index syntax (that is, using bracket notation).
BigInt64Array is a subclass of the hidden TypedArray class.Try it
const buffer = new ArrayBuffer(24);
const bigint64 = new BigInt64Array(buffer);
bigint64[0] = 5886014448488689n;
bigint64[1] = 1881938909131133n;
bigint64[2] = 1898875537769492n;

bigint64[0] = 6118793953620967n;
console.log(bigint64);
// Expected Output: BigInt64Array [6118793953620967n, 1881938909131133n, 1898875537769492n]

console.log(bigint64[2]);
// Expected Output: 1898875537769492n

console.log("Array length:", bigint64.length);
// Expected Output: Array length: 3

console.log("Array byte length:", bigint64.byteLength);
// Expected Output: Array byte length: 24

console.log("Array byte offset:", bigint64.byteOffset);
// Expected Output: Array byte offset: 0

bigint64.set([100n, 200n], 1);
console.log(bigint64);
// Expected Output: BigInt64Array [6118793953620967n, 100n, 200n]
Constructor
BigInt64Array()

Creates a new BigInt64Array object.

Static propertiesAlso inherits static properties from its parent TypedArray.

BigInt64Array.BYTES_PER_ELEMENT

Returns a number value of the element size. 8 in the case of BigInt64Array.

Static methodsInherits static methods from its parent TypedArray.Instance propertiesAlso inherits instance properties from its parent TypedArray.
These properties are defined on BigInt64Array.prototype and shared by all BigInt64Array instances.

BigInt64Array.prototype.BYTES_PER_ELEMENT

Returns a number value of the element size. 8 in the case of a BigInt64Array.

BigInt64Array.prototype.constructor

The constructor function that created the instance object. For BigInt64Array instances, the initial value is the BigInt64Array constructor.

Instance methodsInherits instance methods from its parent TypedArray.ExamplesDifferent ways to create a BigInt64Arrayjs// From a length
const bigint64 = new BigInt64Array(2);
bigint64[0] = 42n;
console.log(bigint64[0]); // 42n
console.log(bigint64.length); // 2
console.log(bigint64.BYTES_PER_ELEMENT); // 8

// From an array
const x = new BigInt64Array([21n, 31n]);
console.log(x[1]); // 31n

// From another TypedArray
const y = new BigInt64Array(x);
console.log(y[0]); // 21n

// From an ArrayBuffer
const buffer = new ArrayBuffer(64);
const z = new BigInt64Array(buffer, 8, 4);
console.log(z.byteOffset); // 8

// From an iterable
const iterable = (function* () {
  yield* [1n, 2n, 3n];
})();
const bigint64FromIterable = new BigInt64Array(iterable);
console.log(bigint64FromIterable);
// BigInt64Array [1n, 2n, 3n]
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-typedarray-objectsBrowser compatibilitySee also
JavaScript typed arrays guide
TypedArray
ArrayBuffer
DataView
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nBigInt64ArrayBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2021.Learn moreSee full compatibilityReport feedbackThe BigInt64Array typed array represents an array of 64-bit signed integers in the platform byte order. If control over byte order is needed, use DataView instead. The contents are initialized to 0n unless initialization data is explicitly provided. Once established, you can reference elements in the array using the object's methods, or using standard array index syntax (that is, using bracket notation).
BigInt64Array is a subclass of the hidden TypedArray class.Try it
const buffer = new ArrayBuffer(24);
const bigint64 = new BigInt64Array(buffer);
bigint64[0] = 5886014448488689n;
bigint64[1] = 1881938909131133n;
bigint64[2] = 1898875537769492n;

bigint64[0] = 6118793953620967n;
console.log(bigint64);
// Expected Output: BigInt64Array [6118793953620967n, 1881938909131133n, 1898875537769492n]

console.log(bigint64[2]);
// Expected Output: 1898875537769492n

console.log("Array length:", bigint64.length);
// Expected Output: Array length: 3

console.log("Array byte length:", bigint64.byteLength);
// Expected Output: Array byte length: 24

console.log("Array byte offset:", bigint64.byteOffset);
// Expected Output: Array byte offset: 0

bigint64.set([100n, 200n], 1);
console.log(bigint64);
// Expected Output: BigInt64Array [6118793953620967n, 100n, 200n]
Constructor
BigInt64Array()

Creates a new BigInt64Array object.

Static propertiesAlso inherits static properties from its parent TypedArray.

BigInt64Array.BYTES_PER_ELEMENT

Returns a number value of the element size. 8 in the case of BigInt64Array.

Static methodsInherits static methods from its parent TypedArray.Instance propertiesAlso inherits instance properties from its parent TypedArray.
These properties are defined on BigInt64Array.prototype and shared by all BigInt64Array instances.

BigInt64Array.prototype.BYTES_PER_ELEMENT

Returns a number value of the element size. 8 in the case of a BigInt64Array.

BigInt64Array.prototype.constructor

The constructor function that created the instance object. For BigInt64Array instances, the initial value is the BigInt64Array constructor.

Instance methodsInherits instance methods from its parent TypedArray.ExamplesDifferent ways to create a BigInt64Arrayjs// From a length
const bigint64 = new BigInt64Array(2);
bigint64[0] = 42n;
console.log(bigint64[0]); // 42n
console.log(bigint64.length); // 2
console.log(bigint64.BYTES_PER_ELEMENT); // 8

// From an array
const x = new BigInt64Array([21n, 31n]);
console.log(x[1]); // 31n

// From another TypedArray
const y = new BigInt64Array(x);
console.log(y[0]); // 21n

// From an ArrayBuffer
const buffer = new ArrayBuffer(64);
const z = new BigInt64Array(buffer, 8, 4);
console.log(z.byteOffset); // 8

// From an iterable
const iterable = (function* () {
  yield* [1n, 2n, 3n];
})();
const bigint64FromIterable = new BigInt64Array(iterable);
console.log(bigint64FromIterable);
// BigInt64Array [1n, 2n, 3n]
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-typedarray-objectsBrowser compatibilitySee also
JavaScript typed arrays guide
TypedArray
ArrayBuffer
DataView
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nBigUint64ArrayBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2021.Learn moreSee full compatibilityReport feedbackThe BigUint64Array typed array represents an array of 64-bit unsigned integers in the platform byte order. If control over byte order is needed, use DataView instead. The contents are initialized to 0n unless initialization data is explicitly provided. Once established, you can reference elements in the array using the object's methods, or using standard array index syntax (that is, using bracket notation).
BigUint64Array is a subclass of the hidden TypedArray class.Constructor
BigUint64Array()

Creates a new BigUint64Array object.

Static propertiesAlso inherits static properties from its parent TypedArray.

BigUint64Array.BYTES_PER_ELEMENT

Returns a number value of the element size. 8 in the case of BigUint64Array.

Static methodsInherits static methods from its parent TypedArray.Instance propertiesAlso inherits instance properties from its parent TypedArray.
These properties are defined on BigUint64Array.prototype and shared by all BigUint64Array instances.

BigUint64Array.prototype.BYTES_PER_ELEMENT

Returns a number value of the element size. 8 in the case of a BigUint64Array.

BigUint64Array.prototype.constructor

The constructor function that created the instance object. For BigUint64Array instances, the initial value is the BigUint64Array constructor.

Instance methodsInherits instance methods from its parent TypedArray.ExamplesDifferent ways to create a BigUint64Arrayjs// From a length
const biguint64 = new BigUint64Array(2);
biguint64[0] = 42n;
console.log(biguint64[0]); // 42n
console.log(biguint64.length); // 2
console.log(biguint64.BYTES_PER_ELEMENT); // 8

// From an array
const x = new BigUint64Array([21n, 31n]);
console.log(x[1]); // 31n

// From another TypedArray
const y = new BigUint64Array(x);
console.log(y[0]); // 21n

// From an ArrayBuffer
const buffer = new ArrayBuffer(64);
const z = new BigUint64Array(buffer, 8, 4);
console.log(z.byteOffset); // 8

// From an iterable
const iterable = (function* () {
  yield* [1n, 2n, 3n];
})();
const biguint64FromIterable = new BigUint64Array(iterable);
console.log(biguint64FromIterable);
// BigUint64Array [1n, 2n, 3n]
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-typedarray-objectsBrowser compatibilitySee also
JavaScript typed arrays guide
TypedArray
ArrayBuffer
DataView\n\nBigUint64ArrayBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2021.Learn moreSee full compatibilityReport feedbackThe BigUint64Array typed array represents an array of 64-bit unsigned integers in the platform byte order. If control over byte order is needed, use DataView instead. The contents are initialized to 0n unless initialization data is explicitly provided. Once established, you can reference elements in the array using the object's methods, or using standard array index syntax (that is, using bracket notation).
BigUint64Array is a subclass of the hidden TypedArray class.Constructor
BigUint64Array()

Creates a new BigUint64Array object.

Static propertiesAlso inherits static properties from its parent TypedArray.

BigUint64Array.BYTES_PER_ELEMENT

Returns a number value of the element size. 8 in the case of BigUint64Array.

Static methodsInherits static methods from its parent TypedArray.Instance propertiesAlso inherits instance properties from its parent TypedArray.
These properties are defined on BigUint64Array.prototype and shared by all BigUint64Array instances.

BigUint64Array.prototype.BYTES_PER_ELEMENT

Returns a number value of the element size. 8 in the case of a BigUint64Array.

BigUint64Array.prototype.constructor

The constructor function that created the instance object. For BigUint64Array instances, the initial value is the BigUint64Array constructor.

Instance methodsInherits instance methods from its parent TypedArray.ExamplesDifferent ways to create a BigUint64Arrayjs// From a length
const biguint64 = new BigUint64Array(2);
biguint64[0] = 42n;
console.log(biguint64[0]); // 42n
console.log(biguint64.length); // 2
console.log(biguint64.BYTES_PER_ELEMENT); // 8

// From an array
const x = new BigUint64Array([21n, 31n]);
console.log(x[1]); // 31n

// From another TypedArray
const y = new BigUint64Array(x);
console.log(y[0]); // 21n

// From an ArrayBuffer
const buffer = new ArrayBuffer(64);
const z = new BigUint64Array(buffer, 8, 4);
console.log(z.byteOffset); // 8

// From an iterable
const iterable = (function* () {
  yield* [1n, 2n, 3n];
})();
const biguint64FromIterable = new BigUint64Array(iterable);
console.log(biguint64FromIterable);
// BigUint64Array [1n, 2n, 3n]
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-typedarray-objectsBrowser compatibilitySee also
JavaScript typed arrays guide
TypedArray
ArrayBuffer
DataView
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jun 12, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nBigUint64ArrayBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2021.Learn moreSee full compatibilityReport feedbackThe BigUint64Array typed array represents an array of 64-bit unsigned integers in the platform byte order. If control over byte order is needed, use DataView instead. The contents are initialized to 0n unless initialization data is explicitly provided. Once established, you can reference elements in the array using the object's methods, or using standard array index syntax (that is, using bracket notation).
BigUint64Array is a subclass of the hidden TypedArray class.Constructor
BigUint64Array()

Creates a new BigUint64Array object.

Static propertiesAlso inherits static properties from its parent TypedArray.

BigUint64Array.BYTES_PER_ELEMENT

Returns a number value of the element size. 8 in the case of BigUint64Array.

Static methodsInherits static methods from its parent TypedArray.Instance propertiesAlso inherits instance properties from its parent TypedArray.
These properties are defined on BigUint64Array.prototype and shared by all BigUint64Array instances.

BigUint64Array.prototype.BYTES_PER_ELEMENT

Returns a number value of the element size. 8 in the case of a BigUint64Array.

BigUint64Array.prototype.constructor

The constructor function that created the instance object. For BigUint64Array instances, the initial value is the BigUint64Array constructor.

Instance methodsInherits instance methods from its parent TypedArray.ExamplesDifferent ways to create a BigUint64Arrayjs// From a length
const biguint64 = new BigUint64Array(2);
biguint64[0] = 42n;
console.log(biguint64[0]); // 42n
console.log(biguint64.length); // 2
console.log(biguint64.BYTES_PER_ELEMENT); // 8

// From an array
const x = new BigUint64Array([21n, 31n]);
console.log(x[1]); // 31n

// From another TypedArray
const y = new BigUint64Array(x);
console.log(y[0]); // 21n

// From an ArrayBuffer
const buffer = new ArrayBuffer(64);
const z = new BigUint64Array(buffer, 8, 4);
console.log(z.byteOffset); // 8

// From an iterable
const iterable = (function* () {
  yield* [1n, 2n, 3n];
})();
const biguint64FromIterable = new BigUint64Array(iterable);
console.log(biguint64FromIterable);
// BigUint64Array [1n, 2n, 3n]
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-typedarray-objectsBrowser compatibilitySee also
JavaScript typed arrays guide
TypedArray
ArrayBuffer
DataView
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jun 12, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nBooleanBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackBoolean values can be one of two values: true or false, representing the truth value of a logical proposition.DescriptionBoolean values are typically produced by relational operators, equality operators, and logical NOT (!). They can also be produced by functions that represent conditions, such as Array.isArray(). Note that binary logical operators such as && and || return the values of the operands, which may or may not be boolean values.
Boolean values are typically used in conditional testing, such as the condition for if...else and while statements, the conditional operator (? :), or the predicate return value of Array.prototype.filter().
You would rarely need to explicitly convert something to a boolean value, as JavaScript does this automatically in boolean contexts, so you can use any value as if it's a boolean, based on its truthiness. You are also encouraged to use if (condition) and if (!condition) instead of if (condition === true) or if (condition === false) in your own code so you can take advantage of this convention. However, making sure that values representing conditions are always booleans can help clarify the intent of your code.
js// Do this:
// This always returns a boolean value
const isObject = (obj) => !!obj && typeof obj === "object";

// Or this:
const isObject = (obj) => Boolean(obj) && typeof obj === "object";

// Or this:
const isObject = (obj) => obj !== null && typeof obj === "object";

// Instead of this:
// This may return falsy values that are not equal to false
const isObject = (obj) => obj && typeof obj === "object";
Boolean primitives and Boolean objectsFor converting non-boolean values to boolean, use Boolean as a function or use the double NOT operator. Do not use the Boolean() constructor with new.
jsconst good = Boolean(expression);
const good2 = !!expression;

jsconst bad = new Boolean(expression); // don't use this!

This is because all objects, including a Boolean object whose wrapped value is false, are truthy and evaluate to true in places such as conditional statements. (See also the boolean coercion section below.)
jsif (new Boolean(true)) {
  console.log("This log is printed.");
}

if (new Boolean(false)) {
  console.log("This log is ALSO printed.");
}

const myFalse = new Boolean(false); // myFalse is a Boolean object (not the primitive value false)
const g = Boolean(myFalse); // g is true
const myString = new String("Hello"); // myString is a String object
const s = Boolean(myString); // s is true


Warning:
You should rarely find yourself using Boolean as a constructor.
Boolean coercionMany built-in operations that expect booleans first coerce their arguments to booleans. The operation can be summarized as follows:

Booleans are returned as-is.
undefined turns into false.
null turns into false.
0, -0, and NaN turn into false; other numbers turn into true.
0n turns into false; other BigInts turn into true.
The empty string "" turns into false; other strings turn into true.
Symbols turn into true.
All objects become true.


Note:
A legacy behavior makes document.all return false when used as a boolean, despite it being an object. This property is legacy and non-standard and should not be used.


Note:
Unlike other type conversions like string coercion or number coercion, boolean coercion does not attempt to convert objects to primitives by calling user methods.

In other words, there are only a handful of values that get coerced to false — these are called falsy values. All other values are called truthy values. A value's truthiness is important when used with logical operators, conditional statements, or any boolean context.
There are two ways to achieve the same effect in JavaScript.

Double NOT: !!x negates x twice, which converts x to a boolean using the same algorithm as above.
The Boolean() function: Boolean(x) uses the same algorithm as above to convert x.

Note that truthiness is not the same as being loosely equal to true or false.
jsif ([]) {
  console.log("[] is truthy");
}
if ([] == false) {
  console.log("[] == false");
}
// [] is truthy
// [] == false

[] is truthy, but it's also loosely equal to false. It's truthy, because all objects are truthy. However, when comparing with false, which is a primitive, [] is also converted to a primitive, which is "" via Array.prototype.toString(). Comparing strings and booleans results in both being converted to numbers, and they both become 0, so [] == false is true. In general, falsiness and == false differ in the following cases:

NaN, undefined, and null are falsy but not loosely equal to false.
"0" (and other string literals that are not "" but get coerced to 0) is truthy but loosely equal to false.
Objects are always truthy, but their primitive representation may be loosely equal to false.

Truthy values are even more unlikely to be loosely equal to true. All values are either truthy or falsy, but most values are loosely equal to neither true nor false.Constructor
Boolean()

Creates Boolean objects. When called as a function, it returns primitive values of type Boolean.

Instance propertiesThese properties are defined on Boolean.prototype and shared by all Boolean instances.

Boolean.prototype.constructor

The constructor function that created the instance object. For Boolean instances, the initial value is the Boolean constructor.

Instance methods
Boolean.prototype.toString()

Returns a string of either true or false depending upon the value of the object. Overrides the Object.prototype.toString() method.

Boolean.prototype.valueOf()

Returns the primitive value of the Boolean object. Overrides the Object.prototype.valueOf() method.

ExamplesCreating false valuesjsconst bNoParam = Boolean();
const bZero = Boolean(0);
const bNull = Boolean(null);
const bEmptyString = Boolean("");
const bfalse = Boolean(false);
Creating true valuesjsconst btrue = Boolean(true);
const btrueString = Boolean("true");
const bfalseString = Boolean("false");
const bSuLin = Boolean("Su Lin");
const bArrayProto = Boolean([]);
const bObjProto = Boolean({});
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-boolean-objectsBrowser compatibilitySee also
Boolean
Boolean primitives
Boolean data type on Wikipedia\n\nBooleanBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackBoolean values can be one of two values: true or false, representing the truth value of a logical proposition.DescriptionBoolean values are typically produced by relational operators, equality operators, and logical NOT (!). They can also be produced by functions that represent conditions, such as Array.isArray(). Note that binary logical operators such as && and || return the values of the operands, which may or may not be boolean values.
Boolean values are typically used in conditional testing, such as the condition for if...else and while statements, the conditional operator (? :), or the predicate return value of Array.prototype.filter().
You would rarely need to explicitly convert something to a boolean value, as JavaScript does this automatically in boolean contexts, so you can use any value as if it's a boolean, based on its truthiness. You are also encouraged to use if (condition) and if (!condition) instead of if (condition === true) or if (condition === false) in your own code so you can take advantage of this convention. However, making sure that values representing conditions are always booleans can help clarify the intent of your code.
js// Do this:
// This always returns a boolean value
const isObject = (obj) => !!obj && typeof obj === "object";

// Or this:
const isObject = (obj) => Boolean(obj) && typeof obj === "object";

// Or this:
const isObject = (obj) => obj !== null && typeof obj === "object";

// Instead of this:
// This may return falsy values that are not equal to false
const isObject = (obj) => obj && typeof obj === "object";
Boolean primitives and Boolean objectsFor converting non-boolean values to boolean, use Boolean as a function or use the double NOT operator. Do not use the Boolean() constructor with new.
jsconst good = Boolean(expression);
const good2 = !!expression;

jsconst bad = new Boolean(expression); // don't use this!

This is because all objects, including a Boolean object whose wrapped value is false, are truthy and evaluate to true in places such as conditional statements. (See also the boolean coercion section below.)
jsif (new Boolean(true)) {
  console.log("This log is printed.");
}

if (new Boolean(false)) {
  console.log("This log is ALSO printed.");
}

const myFalse = new Boolean(false); // myFalse is a Boolean object (not the primitive value false)
const g = Boolean(myFalse); // g is true
const myString = new String("Hello"); // myString is a String object
const s = Boolean(myString); // s is true


Warning:
You should rarely find yourself using Boolean as a constructor.
Boolean coercionMany built-in operations that expect booleans first coerce their arguments to booleans. The operation can be summarized as follows:

Booleans are returned as-is.
undefined turns into false.
null turns into false.
0, -0, and NaN turn into false; other numbers turn into true.
0n turns into false; other BigInts turn into true.
The empty string "" turns into false; other strings turn into true.
Symbols turn into true.
All objects become true.


Note:
A legacy behavior makes document.all return false when used as a boolean, despite it being an object. This property is legacy and non-standard and should not be used.


Note:
Unlike other type conversions like string coercion or number coercion, boolean coercion does not attempt to convert objects to primitives by calling user methods.

In other words, there are only a handful of values that get coerced to false — these are called falsy values. All other values are called truthy values. A value's truthiness is important when used with logical operators, conditional statements, or any boolean context.
There are two ways to achieve the same effect in JavaScript.

Double NOT: !!x negates x twice, which converts x to a boolean using the same algorithm as above.
The Boolean() function: Boolean(x) uses the same algorithm as above to convert x.

Note that truthiness is not the same as being loosely equal to true or false.
jsif ([]) {
  console.log("[] is truthy");
}
if ([] == false) {
  console.log("[] == false");
}
// [] is truthy
// [] == false

[] is truthy, but it's also loosely equal to false. It's truthy, because all objects are truthy. However, when comparing with false, which is a primitive, [] is also converted to a primitive, which is "" via Array.prototype.toString(). Comparing strings and booleans results in both being converted to numbers, and they both become 0, so [] == false is true. In general, falsiness and == false differ in the following cases:

NaN, undefined, and null are falsy but not loosely equal to false.
"0" (and other string literals that are not "" but get coerced to 0) is truthy but loosely equal to false.
Objects are always truthy, but their primitive representation may be loosely equal to false.

Truthy values are even more unlikely to be loosely equal to true. All values are either truthy or falsy, but most values are loosely equal to neither true nor false.Constructor
Boolean()

Creates Boolean objects. When called as a function, it returns primitive values of type Boolean.

Instance propertiesThese properties are defined on Boolean.prototype and shared by all Boolean instances.

Boolean.prototype.constructor

The constructor function that created the instance object. For Boolean instances, the initial value is the Boolean constructor.

Instance methods
Boolean.prototype.toString()

Returns a string of either true or false depending upon the value of the object. Overrides the Object.prototype.toString() method.

Boolean.prototype.valueOf()

Returns the primitive value of the Boolean object. Overrides the Object.prototype.valueOf() method.

ExamplesCreating false valuesjsconst bNoParam = Boolean();
const bZero = Boolean(0);
const bNull = Boolean(null);
const bEmptyString = Boolean("");
const bfalse = Boolean(false);
Creating true valuesjsconst btrue = Boolean(true);
const btrueString = Boolean("true");
const bfalseString = Boolean("false");
const bSuLin = Boolean("Su Lin");
const bArrayProto = Boolean([]);
const bObjProto = Boolean({});
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-boolean-objectsBrowser compatibilitySee also
Boolean
Boolean primitives
Boolean data type on Wikipedia
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nBooleanBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackBoolean values can be one of two values: true or false, representing the truth value of a logical proposition.DescriptionBoolean values are typically produced by relational operators, equality operators, and logical NOT (!). They can also be produced by functions that represent conditions, such as Array.isArray(). Note that binary logical operators such as && and || return the values of the operands, which may or may not be boolean values.
Boolean values are typically used in conditional testing, such as the condition for if...else and while statements, the conditional operator (? :), or the predicate return value of Array.prototype.filter().
You would rarely need to explicitly convert something to a boolean value, as JavaScript does this automatically in boolean contexts, so you can use any value as if it's a boolean, based on its truthiness. You are also encouraged to use if (condition) and if (!condition) instead of if (condition === true) or if (condition === false) in your own code so you can take advantage of this convention. However, making sure that values representing conditions are always booleans can help clarify the intent of your code.
js// Do this:
// This always returns a boolean value
const isObject = (obj) => !!obj && typeof obj === "object";

// Or this:
const isObject = (obj) => Boolean(obj) && typeof obj === "object";

// Or this:
const isObject = (obj) => obj !== null && typeof obj === "object";

// Instead of this:
// This may return falsy values that are not equal to false
const isObject = (obj) => obj && typeof obj === "object";
Boolean primitives and Boolean objectsFor converting non-boolean values to boolean, use Boolean as a function or use the double NOT operator. Do not use the Boolean() constructor with new.
jsconst good = Boolean(expression);
const good2 = !!expression;

jsconst bad = new Boolean(expression); // don't use this!

This is because all objects, including a Boolean object whose wrapped value is false, are truthy and evaluate to true in places such as conditional statements. (See also the boolean coercion section below.)
jsif (new Boolean(true)) {
  console.log("This log is printed.");
}

if (new Boolean(false)) {
  console.log("This log is ALSO printed.");
}

const myFalse = new Boolean(false); // myFalse is a Boolean object (not the primitive value false)
const g = Boolean(myFalse); // g is true
const myString = new String("Hello"); // myString is a String object
const s = Boolean(myString); // s is true


Warning:
You should rarely find yourself using Boolean as a constructor.
Boolean coercionMany built-in operations that expect booleans first coerce their arguments to booleans. The operation can be summarized as follows:

Booleans are returned as-is.
undefined turns into false.
null turns into false.
0, -0, and NaN turn into false; other numbers turn into true.
0n turns into false; other BigInts turn into true.
The empty string "" turns into false; other strings turn into true.
Symbols turn into true.
All objects become true.


Note:
A legacy behavior makes document.all return false when used as a boolean, despite it being an object. This property is legacy and non-standard and should not be used.


Note:
Unlike other type conversions like string coercion or number coercion, boolean coercion does not attempt to convert objects to primitives by calling user methods.

In other words, there are only a handful of values that get coerced to false — these are called falsy values. All other values are called truthy values. A value's truthiness is important when used with logical operators, conditional statements, or any boolean context.
There are two ways to achieve the same effect in JavaScript.

Double NOT: !!x negates x twice, which converts x to a boolean using the same algorithm as above.
The Boolean() function: Boolean(x) uses the same algorithm as above to convert x.

Note that truthiness is not the same as being loosely equal to true or false.
jsif ([]) {
  console.log("[] is truthy");
}
if ([] == false) {
  console.log("[] == false");
}
// [] is truthy
// [] == false

[] is truthy, but it's also loosely equal to false. It's truthy, because all objects are truthy. However, when comparing with false, which is a primitive, [] is also converted to a primitive, which is "" via Array.prototype.toString(). Comparing strings and booleans results in both being converted to numbers, and they both become 0, so [] == false is true. In general, falsiness and == false differ in the following cases:

NaN, undefined, and null are falsy but not loosely equal to false.
"0" (and other string literals that are not "" but get coerced to 0) is truthy but loosely equal to false.
Objects are always truthy, but their primitive representation may be loosely equal to false.

Truthy values are even more unlikely to be loosely equal to true. All values are either truthy or falsy, but most values are loosely equal to neither true nor false.Constructor
Boolean()

Creates Boolean objects. When called as a function, it returns primitive values of type Boolean.

Instance propertiesThese properties are defined on Boolean.prototype and shared by all Boolean instances.

Boolean.prototype.constructor

The constructor function that created the instance object. For Boolean instances, the initial value is the Boolean constructor.

Instance methods
Boolean.prototype.toString()

Returns a string of either true or false depending upon the value of the object. Overrides the Object.prototype.toString() method.

Boolean.prototype.valueOf()

Returns the primitive value of the Boolean object. Overrides the Object.prototype.valueOf() method.

ExamplesCreating false valuesjsconst bNoParam = Boolean();
const bZero = Boolean(0);
const bNull = Boolean(null);
const bEmptyString = Boolean("");
const bfalse = Boolean(false);
Creating true valuesjsconst btrue = Boolean(true);
const btrueString = Boolean("true");
const bfalseString = Boolean("false");
const bSuLin = Boolean("Su Lin");
const bArrayProto = Boolean([]);
const bObjProto = Boolean({});
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-boolean-objectsBrowser compatibilitySee also
Boolean
Boolean primitives
Boolean data type on Wikipedia
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nDataViewBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe DataView view provides a low-level interface for reading and writing multiple number types in a binary ArrayBuffer, without having to care about the platform's endianness.DescriptionEndiannessMulti-byte number formats are represented in memory differently depending on machine architecture — see Endianness for an explanation. DataView accessors provide explicit control of how data is accessed, regardless of the executing computer's endianness. For example, WebAssembly memory is always little-endian, so you should use DataView instead of typed arrays to read and write multi-byte values. See WebAssembly.Memory for an example.
jsconst littleEndian = (() => {
  const buffer = new ArrayBuffer(2);
  new DataView(buffer).setInt16(0, 256, true /* littleEndian */);
  // Int16Array uses the platform's endianness.
  return new Int16Array(buffer)[0] === 256;
})();
console.log(littleEndian); // true or false


Note: DataView defaults to big-endian read and write, but most platforms use little-endian.
Constructor
DataView()

Creates a new DataView object.

Instance propertiesThese properties are defined on DataView.prototype and shared by all DataView instances.

DataView.prototype.buffer

The ArrayBuffer referenced by this view. Fixed at construction time and thus read only.

DataView.prototype.byteLength

The length (in bytes) of this view. Fixed at construction time and thus read only.

DataView.prototype.byteOffset

The offset (in bytes) of this view from the start of its ArrayBuffer. Fixed at construction time and thus read only.

DataView.prototype.constructor

The constructor function that created the instance object. For DataView instances, the initial value is the DataView constructor.

DataView.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "DataView". This property is used in Object.prototype.toString().

Instance methods
DataView.prototype.getBigInt64()

Reads 8 bytes starting at the specified byte offset of this DataView and interprets them as a 64-bit signed integer.

DataView.prototype.getBigUint64()

Reads 8 bytes starting at the specified byte offset of this DataView and interprets them as a 64-bit unsigned integer.

DataView.prototype.getFloat16()

Reads 2 bytes starting at the specified byte offset of this DataView and interprets them as a 16-bit floating point number.

DataView.prototype.getFloat32()

Reads 4 bytes starting at the specified byte offset of this DataView and interprets them as a 32-bit floating point number.

DataView.prototype.getFloat64()

Reads 8 bytes starting at the specified byte offset of this DataView and interprets them as a 64-bit floating point number.

DataView.prototype.getInt16()

Reads 2 bytes starting at the specified byte offset of this DataView and interprets them as a 16-bit signed integer.

DataView.prototype.getInt32()

Reads 4 bytes starting at the specified byte offset of this DataView and interprets them as a 32-bit signed integer.

DataView.prototype.getInt8()

Reads 1 byte at the specified byte offset of this DataView and interprets it as an 8-bit signed integer.

DataView.prototype.getUint16()

Reads 2 bytes starting at the specified byte offset of this DataView and interprets them as a 16-bit unsigned integer.

DataView.prototype.getUint32()

Reads 4 bytes starting at the specified byte offset of this DataView and interprets them as a 32-bit unsigned integer.

DataView.prototype.getUint8()

Reads 1 byte at the specified byte offset of this DataView and interprets it as an 8-bit unsigned integer.

DataView.prototype.setBigInt64()

Takes a BigInt and stores it as a 64-bit signed integer in the 8 bytes starting at the specified byte offset of this DataView.

DataView.prototype.setBigUint64()

Takes a BigInt and stores it as a 64-bit unsigned integer in the 8 bytes starting at the specified byte offset of this DataView.

DataView.prototype.setFloat16()

Takes a number and stores it as a 16-bit float in the 2 bytes starting at the specified byte offset of this DataView.

DataView.prototype.setFloat32()

Takes a number and stores it as a 32-bit float in the 4 bytes starting at the specified byte offset of this DataView.

DataView.prototype.setFloat64()

Takes a number and stores it as a 64-bit float in the 8 bytes starting at the specified byte offset of this DataView.

DataView.prototype.setInt16()

Takes a number and stores it as a 16-bit signed integer in the 2 bytes at the specified byte offset of this DataView.

DataView.prototype.setInt32()

Takes a number and stores it as a 32-bit signed integer in the 4 bytes at the specified byte offset of this DataView.

DataView.prototype.setInt8()

Takes a number and stores it as an 8-bit signed integer in the byte at the specified byte offset of this DataView.

DataView.prototype.setUint16()

Takes a number and stores it as a 16-bit unsigned integer in the 2 bytes at the specified byte offset of this DataView.

DataView.prototype.setUint32()

Takes a number and stores it as a 32-bit unsigned integer in the 4 bytes at the specified byte offset of this DataView.

DataView.prototype.setUint8()

Takes a number and stores it as an 8-bit unsigned integer in the byte at the specified byte offset of this DataView.

ExamplesUsing DataViewjsconst buffer = new ArrayBuffer(16);
const view = new DataView(buffer, 0);

view.setInt16(1, 42);
view.getInt16(1); // 42
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-dataview-objectsBrowser compatibilitySee also
Polyfill of DataView in core-js
ArrayBuffer
SharedArrayBuffer\n\nDataViewBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe DataView view provides a low-level interface for reading and writing multiple number types in a binary ArrayBuffer, without having to care about the platform's endianness.DescriptionEndiannessMulti-byte number formats are represented in memory differently depending on machine architecture — see Endianness for an explanation. DataView accessors provide explicit control of how data is accessed, regardless of the executing computer's endianness. For example, WebAssembly memory is always little-endian, so you should use DataView instead of typed arrays to read and write multi-byte values. See WebAssembly.Memory for an example.
jsconst littleEndian = (() => {
  const buffer = new ArrayBuffer(2);
  new DataView(buffer).setInt16(0, 256, true /* littleEndian */);
  // Int16Array uses the platform's endianness.
  return new Int16Array(buffer)[0] === 256;
})();
console.log(littleEndian); // true or false


Note: DataView defaults to big-endian read and write, but most platforms use little-endian.
Constructor
DataView()

Creates a new DataView object.

Instance propertiesThese properties are defined on DataView.prototype and shared by all DataView instances.

DataView.prototype.buffer

The ArrayBuffer referenced by this view. Fixed at construction time and thus read only.

DataView.prototype.byteLength

The length (in bytes) of this view. Fixed at construction time and thus read only.

DataView.prototype.byteOffset

The offset (in bytes) of this view from the start of its ArrayBuffer. Fixed at construction time and thus read only.

DataView.prototype.constructor

The constructor function that created the instance object. For DataView instances, the initial value is the DataView constructor.

DataView.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "DataView". This property is used in Object.prototype.toString().

Instance methods
DataView.prototype.getBigInt64()

Reads 8 bytes starting at the specified byte offset of this DataView and interprets them as a 64-bit signed integer.

DataView.prototype.getBigUint64()

Reads 8 bytes starting at the specified byte offset of this DataView and interprets them as a 64-bit unsigned integer.

DataView.prototype.getFloat16()

Reads 2 bytes starting at the specified byte offset of this DataView and interprets them as a 16-bit floating point number.

DataView.prototype.getFloat32()

Reads 4 bytes starting at the specified byte offset of this DataView and interprets them as a 32-bit floating point number.

DataView.prototype.getFloat64()

Reads 8 bytes starting at the specified byte offset of this DataView and interprets them as a 64-bit floating point number.

DataView.prototype.getInt16()

Reads 2 bytes starting at the specified byte offset of this DataView and interprets them as a 16-bit signed integer.

DataView.prototype.getInt32()

Reads 4 bytes starting at the specified byte offset of this DataView and interprets them as a 32-bit signed integer.

DataView.prototype.getInt8()

Reads 1 byte at the specified byte offset of this DataView and interprets it as an 8-bit signed integer.

DataView.prototype.getUint16()

Reads 2 bytes starting at the specified byte offset of this DataView and interprets them as a 16-bit unsigned integer.

DataView.prototype.getUint32()

Reads 4 bytes starting at the specified byte offset of this DataView and interprets them as a 32-bit unsigned integer.

DataView.prototype.getUint8()

Reads 1 byte at the specified byte offset of this DataView and interprets it as an 8-bit unsigned integer.

DataView.prototype.setBigInt64()

Takes a BigInt and stores it as a 64-bit signed integer in the 8 bytes starting at the specified byte offset of this DataView.

DataView.prototype.setBigUint64()

Takes a BigInt and stores it as a 64-bit unsigned integer in the 8 bytes starting at the specified byte offset of this DataView.

DataView.prototype.setFloat16()

Takes a number and stores it as a 16-bit float in the 2 bytes starting at the specified byte offset of this DataView.

DataView.prototype.setFloat32()

Takes a number and stores it as a 32-bit float in the 4 bytes starting at the specified byte offset of this DataView.

DataView.prototype.setFloat64()

Takes a number and stores it as a 64-bit float in the 8 bytes starting at the specified byte offset of this DataView.

DataView.prototype.setInt16()

Takes a number and stores it as a 16-bit signed integer in the 2 bytes at the specified byte offset of this DataView.

DataView.prototype.setInt32()

Takes a number and stores it as a 32-bit signed integer in the 4 bytes at the specified byte offset of this DataView.

DataView.prototype.setInt8()

Takes a number and stores it as an 8-bit signed integer in the byte at the specified byte offset of this DataView.

DataView.prototype.setUint16()

Takes a number and stores it as a 16-bit unsigned integer in the 2 bytes at the specified byte offset of this DataView.

DataView.prototype.setUint32()

Takes a number and stores it as a 32-bit unsigned integer in the 4 bytes at the specified byte offset of this DataView.

DataView.prototype.setUint8()

Takes a number and stores it as an 8-bit unsigned integer in the byte at the specified byte offset of this DataView.

ExamplesUsing DataViewjsconst buffer = new ArrayBuffer(16);
const view = new DataView(buffer, 0);

view.setInt16(1, 42);
view.getInt16(1); // 42
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-dataview-objectsBrowser compatibilitySee also
Polyfill of DataView in core-js
ArrayBuffer
SharedArrayBuffer
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jan 31, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nDataViewBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe DataView view provides a low-level interface for reading and writing multiple number types in a binary ArrayBuffer, without having to care about the platform's endianness.DescriptionEndiannessMulti-byte number formats are represented in memory differently depending on machine architecture — see Endianness for an explanation. DataView accessors provide explicit control of how data is accessed, regardless of the executing computer's endianness. For example, WebAssembly memory is always little-endian, so you should use DataView instead of typed arrays to read and write multi-byte values. See WebAssembly.Memory for an example.
jsconst littleEndian = (() => {
  const buffer = new ArrayBuffer(2);
  new DataView(buffer).setInt16(0, 256, true /* littleEndian */);
  // Int16Array uses the platform's endianness.
  return new Int16Array(buffer)[0] === 256;
})();
console.log(littleEndian); // true or false


Note: DataView defaults to big-endian read and write, but most platforms use little-endian.
Constructor
DataView()

Creates a new DataView object.

Instance propertiesThese properties are defined on DataView.prototype and shared by all DataView instances.

DataView.prototype.buffer

The ArrayBuffer referenced by this view. Fixed at construction time and thus read only.

DataView.prototype.byteLength

The length (in bytes) of this view. Fixed at construction time and thus read only.

DataView.prototype.byteOffset

The offset (in bytes) of this view from the start of its ArrayBuffer. Fixed at construction time and thus read only.

DataView.prototype.constructor

The constructor function that created the instance object. For DataView instances, the initial value is the DataView constructor.

DataView.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "DataView". This property is used in Object.prototype.toString().

Instance methods
DataView.prototype.getBigInt64()

Reads 8 bytes starting at the specified byte offset of this DataView and interprets them as a 64-bit signed integer.

DataView.prototype.getBigUint64()

Reads 8 bytes starting at the specified byte offset of this DataView and interprets them as a 64-bit unsigned integer.

DataView.prototype.getFloat16()

Reads 2 bytes starting at the specified byte offset of this DataView and interprets them as a 16-bit floating point number.

DataView.prototype.getFloat32()

Reads 4 bytes starting at the specified byte offset of this DataView and interprets them as a 32-bit floating point number.

DataView.prototype.getFloat64()

Reads 8 bytes starting at the specified byte offset of this DataView and interprets them as a 64-bit floating point number.

DataView.prototype.getInt16()

Reads 2 bytes starting at the specified byte offset of this DataView and interprets them as a 16-bit signed integer.

DataView.prototype.getInt32()

Reads 4 bytes starting at the specified byte offset of this DataView and interprets them as a 32-bit signed integer.

DataView.prototype.getInt8()

Reads 1 byte at the specified byte offset of this DataView and interprets it as an 8-bit signed integer.

DataView.prototype.getUint16()

Reads 2 bytes starting at the specified byte offset of this DataView and interprets them as a 16-bit unsigned integer.

DataView.prototype.getUint32()

Reads 4 bytes starting at the specified byte offset of this DataView and interprets them as a 32-bit unsigned integer.

DataView.prototype.getUint8()

Reads 1 byte at the specified byte offset of this DataView and interprets it as an 8-bit unsigned integer.

DataView.prototype.setBigInt64()

Takes a BigInt and stores it as a 64-bit signed integer in the 8 bytes starting at the specified byte offset of this DataView.

DataView.prototype.setBigUint64()

Takes a BigInt and stores it as a 64-bit unsigned integer in the 8 bytes starting at the specified byte offset of this DataView.

DataView.prototype.setFloat16()

Takes a number and stores it as a 16-bit float in the 2 bytes starting at the specified byte offset of this DataView.

DataView.prototype.setFloat32()

Takes a number and stores it as a 32-bit float in the 4 bytes starting at the specified byte offset of this DataView.

DataView.prototype.setFloat64()

Takes a number and stores it as a 64-bit float in the 8 bytes starting at the specified byte offset of this DataView.

DataView.prototype.setInt16()

Takes a number and stores it as a 16-bit signed integer in the 2 bytes at the specified byte offset of this DataView.

DataView.prototype.setInt32()

Takes a number and stores it as a 32-bit signed integer in the 4 bytes at the specified byte offset of this DataView.

DataView.prototype.setInt8()

Takes a number and stores it as an 8-bit signed integer in the byte at the specified byte offset of this DataView.

DataView.prototype.setUint16()

Takes a number and stores it as a 16-bit unsigned integer in the 2 bytes at the specified byte offset of this DataView.

DataView.prototype.setUint32()

Takes a number and stores it as a 32-bit unsigned integer in the 4 bytes at the specified byte offset of this DataView.

DataView.prototype.setUint8()

Takes a number and stores it as an 8-bit unsigned integer in the byte at the specified byte offset of this DataView.

ExamplesUsing DataViewjsconst buffer = new ArrayBuffer(16);
const view = new DataView(buffer, 0);

view.setInt16(1, 42);
view.getInt16(1); // 42
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-dataview-objectsBrowser compatibilitySee also
Polyfill of DataView in core-js
ArrayBuffer
SharedArrayBuffer
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jan 31, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nDateBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackJavaScript Date objects represent a single moment in time in a platform-independent format. Date objects encapsulate an integral number that represents milliseconds since the midnight at the beginning of January 1, 1970, UTC (the epoch).

Note:
With the introduction of the Temporal API, the Date object is considered a legacy feature. Consider using Temporal for new code and migrate existing code over to it if possible (check the browser compatibility. We will be writing a usage guide soon!
DescriptionThe epoch, timestamps, and invalid dateA JavaScript date is fundamentally specified as the time in milliseconds that has elapsed since the epoch, which is defined as the midnight at the beginning of January 1, 1970, UTC (equivalent to the UNIX epoch). This timestamp is timezone-agnostic and uniquely defines an instant in history.

Note:
While the time value at the heart of a Date object is UTC, the basic methods to fetch the date and time or its components all work in the local (i.e., host system) time zone and offset.

The maximum timestamp representable by a Date object is slightly smaller than the maximum safe integer (Number.MAX_SAFE_INTEGER, which is 9,007,199,254,740,991). A Date object can represent a maximum of ±8,640,000,000,000,000 milliseconds, or ±100,000,000 (one hundred million) days, relative to the epoch. This is the range from April 20, 271821 BC to September 13, 275760 AD. Any attempt to represent a time outside this range results in the Date object holding a timestamp value of NaN, which is an "Invalid Date".
jsconsole.log(new Date(8.64e15).toString()); // "Sat Sep 13 275760 00:00:00 GMT+0000 (Coordinated Universal Time)"
console.log(new Date(8.64e15 + 1).toString()); // "Invalid Date"

There are various methods that allow you to interact with the timestamp stored in the date:

You can interact with the timestamp value directly using the getTime() and setTime() methods.
The valueOf() and [Symbol.toPrimitive]() (when passed "number") methods — which are automatically called in number coercion — return the timestamp, causing Date objects to behave like their timestamps when used in number contexts.
All static methods (Date.now(), Date.parse(), and Date.UTC()) return timestamps instead of Date objects.
The Date() constructor can be called with a timestamp as the only argument.
Date components and time zonesA date is represented internally as a single number, the timestamp. When interacting with it, the timestamp needs to be interpreted as a structured date-and-time representation. There are always two ways to interpret a timestamp: as a local time or as a Coordinated Universal Time (UTC), the global standard time defined by the World Time Standard. The local timezone is not stored in the date object, but is determined by the host environment (user's device).

Note:
UTC should not be confused with the Greenwich Mean Time (GMT), because they are not always equal — this is explained in more detail in the linked Wikipedia page.

For example, the timestamp 0 represents a unique instant in history, but it can be interpreted in two ways:

As a UTC time, it is midnight at the beginning of January 1, 1970, UTC,
As a local time in New York (UTC-5), it is 19:00:00 on December 31, 1969.

The getTimezoneOffset() method returns the difference between UTC and the local time in minutes. Note that the timezone offset does not only depend on the current timezone, but also on the time represented by the Date object, because of daylight saving time and historical changes. In essence, the timezone offset is the offset from UTC time, at the time represented by the Date object and at the location of the host environment.
There are two groups of Date methods: one group gets and sets various date components by interpreting the timestamp as a local time, while the other uses UTC.

  
    
      Component
      Local
      UTC
    
    
      Get
      Set
      Get
      Set
    
  
  
    
      Year
      getFullYear()
      setFullYear()
      getUTCFullYear()
      setUTCFullYear()
    
    
      Month
      getMonth()
      setMonth()
      getUTCMonth()
      setUTCMonth()
    
    
      Date (of month)
      getDate()
      setDate()
      getUTCDate()
      setUTCDate()
    
    
      Hours
      getHours()
      setHours()
      getUTCHours()
      setUTCHours()
    
    
      Minutes
      getMinutes()
      setMinutes()
      getUTCMinutes()
      setUTCMinutes()
    
    
      Seconds
      getSeconds()
      setSeconds()
      getUTCSeconds()
      setUTCSeconds()
    
    
      Milliseconds
      getMilliseconds()
      setMilliseconds()
      getUTCMilliseconds()
      setUTCMilliseconds()
    
    
      Day (of week)
      getDay()
      N/A
      getUTCDay()
      N/A
    
  

The Date() constructor can be called with two or more arguments, in which case they are interpreted as the year, month, day, hour, minute, second, and millisecond, respectively, in local time. Date.UTC() works similarly, but it interprets the components as UTC time and also accepts a single argument representing the year.

Note:
Some methods, including the Date() constructor, Date.UTC(), and the deprecated getYear()/setYear() methods, interpret a two-digit year as a year in the 1900s. For example, new Date(99, 5, 24) is interpreted as June 24, 1999, not June 24, 99. See Interpretation of two-digit years for more information.

When a segment overflows or underflows its expected range, it usually "carries over to" or "borrows from" the higher segment. For example, if the month is set to 12 (months are zero-based, so December is 11), it become the January of the next year. If the day of month is set to 0, it becomes the last day of the previous month. This also applies to dates specified with the date time string format.Date time string formatThere are many ways to format a date as a string. The JavaScript specification only specifies one format to be universally supported: the date time string format, a simplification of the ISO 8601 calendar date extended format. The format is as follows:
YYYY-MM-DDTHH:mm:ss.sssZ


YYYY is the year, with four digits (0000 to 9999), or as an expanded year of + or - followed by six digits. The sign is required for expanded years. -000000 is explicitly disallowed as a valid year.
MM is the month, with two digits (01 to 12). Defaults to 01.
DD is the day of the month, with two digits (01 to 31). Defaults to 01.
T is a literal character, which indicates the beginning of the time part of the string. The T is required when specifying the time part.
HH is the hour, with two digits (00 to 23). As a special case, 24:00:00 is allowed, and is interpreted as midnight at the beginning of the next day. Defaults to 00.
mm is the minute, with two digits (00 to 59). Defaults to 00.
ss is the second, with two digits (00 to 59). Defaults to 00.
sss is the millisecond, with three digits (000 to 999). Defaults to 000.
Z is the timezone offset, which can either be the literal character Z (indicating UTC), or + or - followed by HH:mm, the offset in hours and minutes from UTC.

Various components can be omitted, so the following are all valid:

Date-only form: YYYY, YYYY-MM, YYYY-MM-DD
Date-time form: one of the above date-only forms, followed by T, followed by HH:mm, HH:mm:ss, or HH:mm:ss.sss. Each combination can be followed by a time zone offset.

For example, "2011-10-10" (date-only form), "2011-10-10T14:48:00" (date-time form), or "2011-10-10T14:48:00.000+09:00" (date-time form with milliseconds and time zone) are all valid date time strings.
When the time zone offset is absent, date-only forms are interpreted as a UTC time and date-time forms are interpreted as a local time. The interpretation as a UTC time is due to a historical spec error that was not consistent with ISO 8601 but could not be changed due to web compatibility. See Broken Parser – A Web Reality Issue.
Date.parse() and the Date() constructor both accept strings in the date time string format as input. Furthermore, implementations are allowed to support other date formats when the input fails to match this format.
The toISOString() method returns a string representation of the date in the date time string format, with the time zone offset always set to Z (UTC).

Note:
You are encouraged to make sure your input conforms to the date time string format above for maximum compatibility, because support for other formats is not guaranteed. However, there are some formats that are supported in all major implementations — like RFC 2822 format — in which case their usage can be acceptable. Always conduct cross-browser tests to ensure your code works in all target browsers. A library can help if many different formats are to be accommodated.

Non-standard strings can be parsed in any way as desired by the implementation, including the time zone — most implementations use the local time zone by default. Implementations are not required to return invalid date for out-of-bounds date components, although they usually do. A string may have in-bounds date components (with the bounds defined above), but does not represent a date in reality (for example, "February 30"). Implementations behave inconsistently in this case. The Date.parse() page offers more examples about these non-standard cases.Other ways to format a date
toISOString() returns a string in the format 1970-01-01T00:00:00.000Z (the date time string format introduced above, which is simplified ISO 8601). toJSON() calls toISOString() and returns the result.
toString() returns a string in the format Thu Jan 01 1970 00:00:00 GMT+0000 (Coordinated Universal Time), while toDateString() and toTimeString() return the date and time parts of the string, respectively. [Symbol.toPrimitive]() (when passed "string" or "default") calls toString() and returns the result.
toUTCString() returns a string in the format Thu, 01 Jan 1970 00:00:00 GMT (generalized RFC 7231).
toLocaleDateString(), toLocaleTimeString(), and toLocaleString() use locale-specific date and time formats, usually provided by the Intl API.

See the Formats of toString method return values section for examples.Constructor
Date()

When called as a constructor, returns a new Date object. When called as a function, returns a string representation of the current date and time.

Static methods
Date.now()

Returns the numeric value corresponding to the current time—the number of milliseconds since January 1, 1970 00:00:00 UTC, with leap seconds ignored.

Date.parse()

Parses a string representation of a date and returns the number of milliseconds since January 1, 1970 00:00:00 UTC, with leap seconds ignored.

Date.UTC()

Accepts the same parameters as the longest form of the constructor (i.e., 2 to 7) and returns the number of milliseconds since January 1, 1970 00:00:00 UTC, with leap seconds ignored.

Instance propertiesThese properties are defined on Date.prototype and shared by all Date instances.

Date.prototype.constructor

The constructor function that created the instance object. For Date instances, the initial value is the Date constructor.

Instance methods
Date.prototype.getDate()

Returns the day of the month (1 – 31) for the specified date according to local time.

Date.prototype.getDay()

Returns the day of the week (0 – 6) for the specified date according to local time.

Date.prototype.getFullYear()

Returns the year (4 digits for 4-digit years) of the specified date according to local time.

Date.prototype.getHours()

Returns the hour (0 – 23) in the specified date according to local time.

Date.prototype.getMilliseconds()

Returns the milliseconds (0 – 999) in the specified date according to local time.

Date.prototype.getMinutes()

Returns the minutes (0 – 59) in the specified date according to local time.

Date.prototype.getMonth()

Returns the month (0 – 11) in the specified date according to local time.

Date.prototype.getSeconds()

Returns the seconds (0 – 59) in the specified date according to local time.

Date.prototype.getTime()

Returns the numeric value of the specified date as the number of milliseconds since January 1, 1970 00:00:00 UTC. (Negative values are returned for prior times.)

Date.prototype.getTimezoneOffset()

Returns the time-zone offset in minutes for the current locale.

Date.prototype.getUTCDate()

Returns the day (date) of the month (1 – 31) in the specified date according to universal time.

Date.prototype.getUTCDay()

Returns the day of the week (0 – 6) in the specified date according to universal time.

Date.prototype.getUTCFullYear()

Returns the year (4 digits for 4-digit years) in the specified date according to universal time.

Date.prototype.getUTCHours()

Returns the hours (0 – 23) in the specified date according to universal time.

Date.prototype.getUTCMilliseconds()

Returns the milliseconds (0 – 999) in the specified date according to universal time.

Date.prototype.getUTCMinutes()

Returns the minutes (0 – 59) in the specified date according to universal time.

Date.prototype.getUTCMonth()

Returns the month (0 – 11) in the specified date according to universal time.

Date.prototype.getUTCSeconds()

Returns the seconds (0 – 59) in the specified date according to universal time.

Date.prototype.getYear() 
Deprecated


Returns the year (usually 2–3 digits) in the specified date according to local time. Use getFullYear() instead.

Date.prototype.setDate()

Sets the day of the month for a specified date according to local time.

Date.prototype.setFullYear()

Sets the full year (e.g., 4 digits for 4-digit years) for a specified date according to local time.

Date.prototype.setHours()

Sets the hours for a specified date according to local time.

Date.prototype.setMilliseconds()

Sets the milliseconds for a specified date according to local time.

Date.prototype.setMinutes()

Sets the minutes for a specified date according to local time.

Date.prototype.setMonth()

Sets the month for a specified date according to local time.

Date.prototype.setSeconds()

Sets the seconds for a specified date according to local time.

Date.prototype.setTime()

Sets the Date object to the time represented by the number of milliseconds since January 1, 1970 00:00:00 UTC. Use negative numbers for times prior.

Date.prototype.setUTCDate()

Sets the day of the month for a specified date according to universal time.

Date.prototype.setUTCFullYear()

Sets the full year (e.g., 4 digits for 4-digit years) for a specified date according to universal time.

Date.prototype.setUTCHours()

Sets the hour for a specified date according to universal time.

Date.prototype.setUTCMilliseconds()

Sets the milliseconds for a specified date according to universal time.

Date.prototype.setUTCMinutes()

Sets the minutes for a specified date according to universal time.

Date.prototype.setUTCMonth()

Sets the month for a specified date according to universal time.

Date.prototype.setUTCSeconds()

Sets the seconds for a specified date according to universal time.

Date.prototype.setYear() 
Deprecated


Sets the year (usually 2–3 digits) for a specified date according to local time. Use setFullYear() instead.

Date.prototype.toDateString()

Returns the "date" portion of the Date as a human-readable string like 'Thu Apr 12 2018'.

Date.prototype.toISOString()

Converts a date to a string following the ISO 8601 Extended Format.

Date.prototype.toJSON()

Returns a string representing the Date using toISOString(). Intended to be implicitly called by JSON.stringify().

Date.prototype.toLocaleDateString()

Returns a string with a locality sensitive representation of the date portion of this date based on system settings.

Date.prototype.toLocaleString()

Returns a string with a locality-sensitive representation of this date. Overrides the Object.prototype.toLocaleString() method.

Date.prototype.toLocaleTimeString()

Returns a string with a locality-sensitive representation of the time portion of this date, based on system settings.

Date.prototype.toString()

Returns a string representing the specified Date object. Overrides the Object.prototype.toString() method.

Date.prototype.toTemporalInstant() 
Experimental


Returns a new Temporal.Instant object with the same epochMilliseconds value as this date's timestamp.

Date.prototype.toTimeString()

Returns the "time" portion of the Date as a human-readable string.

Date.prototype.toUTCString()

Converts a date to a string using the UTC timezone.

Date.prototype.valueOf()

Returns the primitive value of a Date object. Overrides the Object.prototype.valueOf() method.

Date.prototype[Symbol.toPrimitive]()

Converts this Date object to a primitive value.

ExamplesSeveral ways to create a Date objectThe following examples show several ways to create JavaScript dates:

Note:
Creating a date from a string has a lot of behavior inconsistencies. See date time string format for caveats on using different formats.

jsconst today = new Date();
const birthday = new Date("December 17, 1995 03:24:00"); // DISCOURAGED: may not work in all runtimes
const birthday2 = new Date("1995-12-17T03:24:00"); // This is standardized and will work reliably
const birthday3 = new Date(1995, 11, 17); // the month is 0-indexed
const birthday4 = new Date(1995, 11, 17, 3, 24, 0);
const birthday5 = new Date(628021800000); // passing epoch timestamp
Formats of toString method return valuesjsconst date = new Date("2020-05-12T23:50:21.817Z");
date.toString(); // Tue May 12 2020 18:50:21 GMT-0500 (Central Daylight Time)
date.toDateString(); // Tue May 12 2020
date.toTimeString(); // 18:50:21 GMT-0500 (Central Daylight Time)
date[Symbol.toPrimitive]("string"); // Tue May 12 2020 18:50:21 GMT-0500 (Central Daylight Time)

date.toISOString(); // 2020-05-12T23:50:21.817Z
date.toJSON(); // 2020-05-12T23:50:21.817Z

date.toUTCString(); // Tue, 12 May 2020 23:50:21 GMT

date.toLocaleString(); // 5/12/2020, 6:50:21 PM
date.toLocaleDateString(); // 5/12/2020
date.toLocaleTimeString(); // 6:50:21 PM
To get Date, Month and Year or Timejsconst date = new Date("2000-01-17T16:45:30");
const [month, day, year] = [
  date.getMonth(),
  date.getDate(),
  date.getFullYear(),
];
// [0, 17, 2000] as month are 0-indexed
const [hour, minutes, seconds] = [
  date.getHours(),
  date.getMinutes(),
  date.getSeconds(),
];
// [16, 45, 30]
Interpretation of two-digit yearsnew Date() exhibits legacy undesirable, inconsistent behavior with two-digit year values; specifically, when a new Date() call is given a two-digit year value, that year value does not get treated as a literal year and used as-is but instead gets interpreted as a relative offset — in some cases as an offset from the year 1900, but in other cases, as an offset from the year 2000.
jslet date = new Date(98, 1); // Sun Feb 01 1998 00:00:00 GMT+0000 (GMT)
date = new Date(22, 1); // Wed Feb 01 1922 00:00:00 GMT+0000 (GMT)
date = new Date("2/1/22"); // Tue Feb 01 2022 00:00:00 GMT+0000 (GMT)

// Legacy method; always interprets two-digit year values as relative to 1900
date.setYear(98);
date.toString(); // Sun Feb 01 1998 00:00:00 GMT+0000 (GMT)
date.setYear(22);
date.toString(); // Wed Feb 01 1922 00:00:00 GMT+0000 (GMT)

So, to create and get dates between the years 0 and 99, instead use the preferred setFullYear() and getFullYear() methods:.
js// Preferred method; never interprets any value as being a relative offset,
// but instead uses the year value as-is
date.setFullYear(98);
date.getFullYear(); // 98 (not 1998)
date.setFullYear(22);
date.getFullYear(); // 22 (not 1922, not 2022)
Calculating elapsed timeThe following examples show how to determine the elapsed time between two JavaScript dates in milliseconds.
Due to the differing lengths of days (due to daylight saving changeover), months, and years, expressing elapsed time in units greater than hours, minutes, and seconds requires addressing a number of issues, and should be thoroughly researched before being attempted.
js// Using Date objects
const start = Date.now();

// The event to time goes here:
doSomethingForALongTime();
const end = Date.now();
const elapsed = end - start; // elapsed time in milliseconds

js// Using built-in methods
const start = new Date();

// The event to time goes here:
doSomethingForALongTime();
const end = new Date();
const elapsed = end.getTime() - start.getTime(); // elapsed time in milliseconds

js// To test a function and get back its return
function printElapsedTime(testFn) {
  const startTime = Date.now();
  const result = testFn();
  const endTime = Date.now();

  console.log(`Elapsed time: ${String(endTime - startTime)} milliseconds`);
  return result;
}

const yourFunctionReturn = printElapsedTime(yourFunction);


Note:
In browsers that support the Performance API's high-resolution time feature, Performance.now() can provide more reliable and precise measurements of elapsed time than Date.now().
Get the number of seconds since the ECMAScript Epochjsconst seconds = Math.floor(Date.now() / 1000);

In this case, it's important to return only an integer—so a simple division won't do. It's also important to only return actually elapsed seconds. (That's why this code uses Math.floor(), and not Math.round().)SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-date-objectsBrowser compatibilitySee also
Date()\n\nDateBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackJavaScript Date objects represent a single moment in time in a platform-independent format. Date objects encapsulate an integral number that represents milliseconds since the midnight at the beginning of January 1, 1970, UTC (the epoch).

Note:
With the introduction of the Temporal API, the Date object is considered a legacy feature. Consider using Temporal for new code and migrate existing code over to it if possible (check the browser compatibility. We will be writing a usage guide soon!
DescriptionThe epoch, timestamps, and invalid dateA JavaScript date is fundamentally specified as the time in milliseconds that has elapsed since the epoch, which is defined as the midnight at the beginning of January 1, 1970, UTC (equivalent to the UNIX epoch). This timestamp is timezone-agnostic and uniquely defines an instant in history.

Note:
While the time value at the heart of a Date object is UTC, the basic methods to fetch the date and time or its components all work in the local (i.e., host system) time zone and offset.

The maximum timestamp representable by a Date object is slightly smaller than the maximum safe integer (Number.MAX_SAFE_INTEGER, which is 9,007,199,254,740,991). A Date object can represent a maximum of ±8,640,000,000,000,000 milliseconds, or ±100,000,000 (one hundred million) days, relative to the epoch. This is the range from April 20, 271821 BC to September 13, 275760 AD. Any attempt to represent a time outside this range results in the Date object holding a timestamp value of NaN, which is an "Invalid Date".
jsconsole.log(new Date(8.64e15).toString()); // "Sat Sep 13 275760 00:00:00 GMT+0000 (Coordinated Universal Time)"
console.log(new Date(8.64e15 + 1).toString()); // "Invalid Date"

There are various methods that allow you to interact with the timestamp stored in the date:

You can interact with the timestamp value directly using the getTime() and setTime() methods.
The valueOf() and [Symbol.toPrimitive]() (when passed "number") methods — which are automatically called in number coercion — return the timestamp, causing Date objects to behave like their timestamps when used in number contexts.
All static methods (Date.now(), Date.parse(), and Date.UTC()) return timestamps instead of Date objects.
The Date() constructor can be called with a timestamp as the only argument.
Date components and time zonesA date is represented internally as a single number, the timestamp. When interacting with it, the timestamp needs to be interpreted as a structured date-and-time representation. There are always two ways to interpret a timestamp: as a local time or as a Coordinated Universal Time (UTC), the global standard time defined by the World Time Standard. The local timezone is not stored in the date object, but is determined by the host environment (user's device).

Note:
UTC should not be confused with the Greenwich Mean Time (GMT), because they are not always equal — this is explained in more detail in the linked Wikipedia page.

For example, the timestamp 0 represents a unique instant in history, but it can be interpreted in two ways:

As a UTC time, it is midnight at the beginning of January 1, 1970, UTC,
As a local time in New York (UTC-5), it is 19:00:00 on December 31, 1969.

The getTimezoneOffset() method returns the difference between UTC and the local time in minutes. Note that the timezone offset does not only depend on the current timezone, but also on the time represented by the Date object, because of daylight saving time and historical changes. In essence, the timezone offset is the offset from UTC time, at the time represented by the Date object and at the location of the host environment.
There are two groups of Date methods: one group gets and sets various date components by interpreting the timestamp as a local time, while the other uses UTC.

  
    
      Component
      Local
      UTC
    
    
      Get
      Set
      Get
      Set
    
  
  
    
      Year
      getFullYear()
      setFullYear()
      getUTCFullYear()
      setUTCFullYear()
    
    
      Month
      getMonth()
      setMonth()
      getUTCMonth()
      setUTCMonth()
    
    
      Date (of month)
      getDate()
      setDate()
      getUTCDate()
      setUTCDate()
    
    
      Hours
      getHours()
      setHours()
      getUTCHours()
      setUTCHours()
    
    
      Minutes
      getMinutes()
      setMinutes()
      getUTCMinutes()
      setUTCMinutes()
    
    
      Seconds
      getSeconds()
      setSeconds()
      getUTCSeconds()
      setUTCSeconds()
    
    
      Milliseconds
      getMilliseconds()
      setMilliseconds()
      getUTCMilliseconds()
      setUTCMilliseconds()
    
    
      Day (of week)
      getDay()
      N/A
      getUTCDay()
      N/A
    
  

The Date() constructor can be called with two or more arguments, in which case they are interpreted as the year, month, day, hour, minute, second, and millisecond, respectively, in local time. Date.UTC() works similarly, but it interprets the components as UTC time and also accepts a single argument representing the year.

Note:
Some methods, including the Date() constructor, Date.UTC(), and the deprecated getYear()/setYear() methods, interpret a two-digit year as a year in the 1900s. For example, new Date(99, 5, 24) is interpreted as June 24, 1999, not June 24, 99. See Interpretation of two-digit years for more information.

When a segment overflows or underflows its expected range, it usually "carries over to" or "borrows from" the higher segment. For example, if the month is set to 12 (months are zero-based, so December is 11), it become the January of the next year. If the day of month is set to 0, it becomes the last day of the previous month. This also applies to dates specified with the date time string format.Date time string formatThere are many ways to format a date as a string. The JavaScript specification only specifies one format to be universally supported: the date time string format, a simplification of the ISO 8601 calendar date extended format. The format is as follows:
YYYY-MM-DDTHH:mm:ss.sssZ


YYYY is the year, with four digits (0000 to 9999), or as an expanded year of + or - followed by six digits. The sign is required for expanded years. -000000 is explicitly disallowed as a valid year.
MM is the month, with two digits (01 to 12). Defaults to 01.
DD is the day of the month, with two digits (01 to 31). Defaults to 01.
T is a literal character, which indicates the beginning of the time part of the string. The T is required when specifying the time part.
HH is the hour, with two digits (00 to 23). As a special case, 24:00:00 is allowed, and is interpreted as midnight at the beginning of the next day. Defaults to 00.
mm is the minute, with two digits (00 to 59). Defaults to 00.
ss is the second, with two digits (00 to 59). Defaults to 00.
sss is the millisecond, with three digits (000 to 999). Defaults to 000.
Z is the timezone offset, which can either be the literal character Z (indicating UTC), or + or - followed by HH:mm, the offset in hours and minutes from UTC.

Various components can be omitted, so the following are all valid:

Date-only form: YYYY, YYYY-MM, YYYY-MM-DD
Date-time form: one of the above date-only forms, followed by T, followed by HH:mm, HH:mm:ss, or HH:mm:ss.sss. Each combination can be followed by a time zone offset.

For example, "2011-10-10" (date-only form), "2011-10-10T14:48:00" (date-time form), or "2011-10-10T14:48:00.000+09:00" (date-time form with milliseconds and time zone) are all valid date time strings.
When the time zone offset is absent, date-only forms are interpreted as a UTC time and date-time forms are interpreted as a local time. The interpretation as a UTC time is due to a historical spec error that was not consistent with ISO 8601 but could not be changed due to web compatibility. See Broken Parser – A Web Reality Issue.
Date.parse() and the Date() constructor both accept strings in the date time string format as input. Furthermore, implementations are allowed to support other date formats when the input fails to match this format.
The toISOString() method returns a string representation of the date in the date time string format, with the time zone offset always set to Z (UTC).

Note:
You are encouraged to make sure your input conforms to the date time string format above for maximum compatibility, because support for other formats is not guaranteed. However, there are some formats that are supported in all major implementations — like RFC 2822 format — in which case their usage can be acceptable. Always conduct cross-browser tests to ensure your code works in all target browsers. A library can help if many different formats are to be accommodated.

Non-standard strings can be parsed in any way as desired by the implementation, including the time zone — most implementations use the local time zone by default. Implementations are not required to return invalid date for out-of-bounds date components, although they usually do. A string may have in-bounds date components (with the bounds defined above), but does not represent a date in reality (for example, "February 30"). Implementations behave inconsistently in this case. The Date.parse() page offers more examples about these non-standard cases.Other ways to format a date
toISOString() returns a string in the format 1970-01-01T00:00:00.000Z (the date time string format introduced above, which is simplified ISO 8601). toJSON() calls toISOString() and returns the result.
toString() returns a string in the format Thu Jan 01 1970 00:00:00 GMT+0000 (Coordinated Universal Time), while toDateString() and toTimeString() return the date and time parts of the string, respectively. [Symbol.toPrimitive]() (when passed "string" or "default") calls toString() and returns the result.
toUTCString() returns a string in the format Thu, 01 Jan 1970 00:00:00 GMT (generalized RFC 7231).
toLocaleDateString(), toLocaleTimeString(), and toLocaleString() use locale-specific date and time formats, usually provided by the Intl API.

See the Formats of toString method return values section for examples.Constructor
Date()

When called as a constructor, returns a new Date object. When called as a function, returns a string representation of the current date and time.

Static methods
Date.now()

Returns the numeric value corresponding to the current time—the number of milliseconds since January 1, 1970 00:00:00 UTC, with leap seconds ignored.

Date.parse()

Parses a string representation of a date and returns the number of milliseconds since January 1, 1970 00:00:00 UTC, with leap seconds ignored.

Date.UTC()

Accepts the same parameters as the longest form of the constructor (i.e., 2 to 7) and returns the number of milliseconds since January 1, 1970 00:00:00 UTC, with leap seconds ignored.

Instance propertiesThese properties are defined on Date.prototype and shared by all Date instances.

Date.prototype.constructor

The constructor function that created the instance object. For Date instances, the initial value is the Date constructor.

Instance methods
Date.prototype.getDate()

Returns the day of the month (1 – 31) for the specified date according to local time.

Date.prototype.getDay()

Returns the day of the week (0 – 6) for the specified date according to local time.

Date.prototype.getFullYear()

Returns the year (4 digits for 4-digit years) of the specified date according to local time.

Date.prototype.getHours()

Returns the hour (0 – 23) in the specified date according to local time.

Date.prototype.getMilliseconds()

Returns the milliseconds (0 – 999) in the specified date according to local time.

Date.prototype.getMinutes()

Returns the minutes (0 – 59) in the specified date according to local time.

Date.prototype.getMonth()

Returns the month (0 – 11) in the specified date according to local time.

Date.prototype.getSeconds()

Returns the seconds (0 – 59) in the specified date according to local time.

Date.prototype.getTime()

Returns the numeric value of the specified date as the number of milliseconds since January 1, 1970 00:00:00 UTC. (Negative values are returned for prior times.)

Date.prototype.getTimezoneOffset()

Returns the time-zone offset in minutes for the current locale.

Date.prototype.getUTCDate()

Returns the day (date) of the month (1 – 31) in the specified date according to universal time.

Date.prototype.getUTCDay()

Returns the day of the week (0 – 6) in the specified date according to universal time.

Date.prototype.getUTCFullYear()

Returns the year (4 digits for 4-digit years) in the specified date according to universal time.

Date.prototype.getUTCHours()

Returns the hours (0 – 23) in the specified date according to universal time.

Date.prototype.getUTCMilliseconds()

Returns the milliseconds (0 – 999) in the specified date according to universal time.

Date.prototype.getUTCMinutes()

Returns the minutes (0 – 59) in the specified date according to universal time.

Date.prototype.getUTCMonth()

Returns the month (0 – 11) in the specified date according to universal time.

Date.prototype.getUTCSeconds()

Returns the seconds (0 – 59) in the specified date according to universal time.

Date.prototype.getYear() 
Deprecated


Returns the year (usually 2–3 digits) in the specified date according to local time. Use getFullYear() instead.

Date.prototype.setDate()

Sets the day of the month for a specified date according to local time.

Date.prototype.setFullYear()

Sets the full year (e.g., 4 digits for 4-digit years) for a specified date according to local time.

Date.prototype.setHours()

Sets the hours for a specified date according to local time.

Date.prototype.setMilliseconds()

Sets the milliseconds for a specified date according to local time.

Date.prototype.setMinutes()

Sets the minutes for a specified date according to local time.

Date.prototype.setMonth()

Sets the month for a specified date according to local time.

Date.prototype.setSeconds()

Sets the seconds for a specified date according to local time.

Date.prototype.setTime()

Sets the Date object to the time represented by the number of milliseconds since January 1, 1970 00:00:00 UTC. Use negative numbers for times prior.

Date.prototype.setUTCDate()

Sets the day of the month for a specified date according to universal time.

Date.prototype.setUTCFullYear()

Sets the full year (e.g., 4 digits for 4-digit years) for a specified date according to universal time.

Date.prototype.setUTCHours()

Sets the hour for a specified date according to universal time.

Date.prototype.setUTCMilliseconds()

Sets the milliseconds for a specified date according to universal time.

Date.prototype.setUTCMinutes()

Sets the minutes for a specified date according to universal time.

Date.prototype.setUTCMonth()

Sets the month for a specified date according to universal time.

Date.prototype.setUTCSeconds()

Sets the seconds for a specified date according to universal time.

Date.prototype.setYear() 
Deprecated


Sets the year (usually 2–3 digits) for a specified date according to local time. Use setFullYear() instead.

Date.prototype.toDateString()

Returns the "date" portion of the Date as a human-readable string like 'Thu Apr 12 2018'.

Date.prototype.toISOString()

Converts a date to a string following the ISO 8601 Extended Format.

Date.prototype.toJSON()

Returns a string representing the Date using toISOString(). Intended to be implicitly called by JSON.stringify().

Date.prototype.toLocaleDateString()

Returns a string with a locality sensitive representation of the date portion of this date based on system settings.

Date.prototype.toLocaleString()

Returns a string with a locality-sensitive representation of this date. Overrides the Object.prototype.toLocaleString() method.

Date.prototype.toLocaleTimeString()

Returns a string with a locality-sensitive representation of the time portion of this date, based on system settings.

Date.prototype.toString()

Returns a string representing the specified Date object. Overrides the Object.prototype.toString() method.

Date.prototype.toTemporalInstant() 
Experimental


Returns a new Temporal.Instant object with the same epochMilliseconds value as this date's timestamp.

Date.prototype.toTimeString()

Returns the "time" portion of the Date as a human-readable string.

Date.prototype.toUTCString()

Converts a date to a string using the UTC timezone.

Date.prototype.valueOf()

Returns the primitive value of a Date object. Overrides the Object.prototype.valueOf() method.

Date.prototype[Symbol.toPrimitive]()

Converts this Date object to a primitive value.

ExamplesSeveral ways to create a Date objectThe following examples show several ways to create JavaScript dates:

Note:
Creating a date from a string has a lot of behavior inconsistencies. See date time string format for caveats on using different formats.

jsconst today = new Date();
const birthday = new Date("December 17, 1995 03:24:00"); // DISCOURAGED: may not work in all runtimes
const birthday2 = new Date("1995-12-17T03:24:00"); // This is standardized and will work reliably
const birthday3 = new Date(1995, 11, 17); // the month is 0-indexed
const birthday4 = new Date(1995, 11, 17, 3, 24, 0);
const birthday5 = new Date(628021800000); // passing epoch timestamp
Formats of toString method return valuesjsconst date = new Date("2020-05-12T23:50:21.817Z");
date.toString(); // Tue May 12 2020 18:50:21 GMT-0500 (Central Daylight Time)
date.toDateString(); // Tue May 12 2020
date.toTimeString(); // 18:50:21 GMT-0500 (Central Daylight Time)
date[Symbol.toPrimitive]("string"); // Tue May 12 2020 18:50:21 GMT-0500 (Central Daylight Time)

date.toISOString(); // 2020-05-12T23:50:21.817Z
date.toJSON(); // 2020-05-12T23:50:21.817Z

date.toUTCString(); // Tue, 12 May 2020 23:50:21 GMT

date.toLocaleString(); // 5/12/2020, 6:50:21 PM
date.toLocaleDateString(); // 5/12/2020
date.toLocaleTimeString(); // 6:50:21 PM
To get Date, Month and Year or Timejsconst date = new Date("2000-01-17T16:45:30");
const [month, day, year] = [
  date.getMonth(),
  date.getDate(),
  date.getFullYear(),
];
// [0, 17, 2000] as month are 0-indexed
const [hour, minutes, seconds] = [
  date.getHours(),
  date.getMinutes(),
  date.getSeconds(),
];
// [16, 45, 30]
Interpretation of two-digit yearsnew Date() exhibits legacy undesirable, inconsistent behavior with two-digit year values; specifically, when a new Date() call is given a two-digit year value, that year value does not get treated as a literal year and used as-is but instead gets interpreted as a relative offset — in some cases as an offset from the year 1900, but in other cases, as an offset from the year 2000.
jslet date = new Date(98, 1); // Sun Feb 01 1998 00:00:00 GMT+0000 (GMT)
date = new Date(22, 1); // Wed Feb 01 1922 00:00:00 GMT+0000 (GMT)
date = new Date("2/1/22"); // Tue Feb 01 2022 00:00:00 GMT+0000 (GMT)

// Legacy method; always interprets two-digit year values as relative to 1900
date.setYear(98);
date.toString(); // Sun Feb 01 1998 00:00:00 GMT+0000 (GMT)
date.setYear(22);
date.toString(); // Wed Feb 01 1922 00:00:00 GMT+0000 (GMT)

So, to create and get dates between the years 0 and 99, instead use the preferred setFullYear() and getFullYear() methods:.
js// Preferred method; never interprets any value as being a relative offset,
// but instead uses the year value as-is
date.setFullYear(98);
date.getFullYear(); // 98 (not 1998)
date.setFullYear(22);
date.getFullYear(); // 22 (not 1922, not 2022)
Calculating elapsed timeThe following examples show how to determine the elapsed time between two JavaScript dates in milliseconds.
Due to the differing lengths of days (due to daylight saving changeover), months, and years, expressing elapsed time in units greater than hours, minutes, and seconds requires addressing a number of issues, and should be thoroughly researched before being attempted.
js// Using Date objects
const start = Date.now();

// The event to time goes here:
doSomethingForALongTime();
const end = Date.now();
const elapsed = end - start; // elapsed time in milliseconds

js// Using built-in methods
const start = new Date();

// The event to time goes here:
doSomethingForALongTime();
const end = new Date();
const elapsed = end.getTime() - start.getTime(); // elapsed time in milliseconds

js// To test a function and get back its return
function printElapsedTime(testFn) {
  const startTime = Date.now();
  const result = testFn();
  const endTime = Date.now();

  console.log(`Elapsed time: ${String(endTime - startTime)} milliseconds`);
  return result;
}

const yourFunctionReturn = printElapsedTime(yourFunction);


Note:
In browsers that support the Performance API's high-resolution time feature, Performance.now() can provide more reliable and precise measurements of elapsed time than Date.now().
Get the number of seconds since the ECMAScript Epochjsconst seconds = Math.floor(Date.now() / 1000);

In this case, it's important to return only an integer—so a simple division won't do. It's also important to only return actually elapsed seconds. (That's why this code uses Math.floor(), and not Math.round().)SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-date-objectsBrowser compatibilitySee also
Date()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nDateBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackJavaScript Date objects represent a single moment in time in a platform-independent format. Date objects encapsulate an integral number that represents milliseconds since the midnight at the beginning of January 1, 1970, UTC (the epoch).

Note:
With the introduction of the Temporal API, the Date object is considered a legacy feature. Consider using Temporal for new code and migrate existing code over to it if possible (check the browser compatibility. We will be writing a usage guide soon!
DescriptionThe epoch, timestamps, and invalid dateA JavaScript date is fundamentally specified as the time in milliseconds that has elapsed since the epoch, which is defined as the midnight at the beginning of January 1, 1970, UTC (equivalent to the UNIX epoch). This timestamp is timezone-agnostic and uniquely defines an instant in history.

Note:
While the time value at the heart of a Date object is UTC, the basic methods to fetch the date and time or its components all work in the local (i.e., host system) time zone and offset.

The maximum timestamp representable by a Date object is slightly smaller than the maximum safe integer (Number.MAX_SAFE_INTEGER, which is 9,007,199,254,740,991). A Date object can represent a maximum of ±8,640,000,000,000,000 milliseconds, or ±100,000,000 (one hundred million) days, relative to the epoch. This is the range from April 20, 271821 BC to September 13, 275760 AD. Any attempt to represent a time outside this range results in the Date object holding a timestamp value of NaN, which is an "Invalid Date".
jsconsole.log(new Date(8.64e15).toString()); // "Sat Sep 13 275760 00:00:00 GMT+0000 (Coordinated Universal Time)"
console.log(new Date(8.64e15 + 1).toString()); // "Invalid Date"

There are various methods that allow you to interact with the timestamp stored in the date:

You can interact with the timestamp value directly using the getTime() and setTime() methods.
The valueOf() and [Symbol.toPrimitive]() (when passed "number") methods — which are automatically called in number coercion — return the timestamp, causing Date objects to behave like their timestamps when used in number contexts.
All static methods (Date.now(), Date.parse(), and Date.UTC()) return timestamps instead of Date objects.
The Date() constructor can be called with a timestamp as the only argument.
Date components and time zonesA date is represented internally as a single number, the timestamp. When interacting with it, the timestamp needs to be interpreted as a structured date-and-time representation. There are always two ways to interpret a timestamp: as a local time or as a Coordinated Universal Time (UTC), the global standard time defined by the World Time Standard. The local timezone is not stored in the date object, but is determined by the host environment (user's device).

Note:
UTC should not be confused with the Greenwich Mean Time (GMT), because they are not always equal — this is explained in more detail in the linked Wikipedia page.

For example, the timestamp 0 represents a unique instant in history, but it can be interpreted in two ways:

As a UTC time, it is midnight at the beginning of January 1, 1970, UTC,
As a local time in New York (UTC-5), it is 19:00:00 on December 31, 1969.

The getTimezoneOffset() method returns the difference between UTC and the local time in minutes. Note that the timezone offset does not only depend on the current timezone, but also on the time represented by the Date object, because of daylight saving time and historical changes. In essence, the timezone offset is the offset from UTC time, at the time represented by the Date object and at the location of the host environment.
There are two groups of Date methods: one group gets and sets various date components by interpreting the timestamp as a local time, while the other uses UTC.

  
    
      Component
      Local
      UTC
    
    
      Get
      Set
      Get
      Set
    
  
  
    
      Year
      getFullYear()
      setFullYear()
      getUTCFullYear()
      setUTCFullYear()
    
    
      Month
      getMonth()
      setMonth()
      getUTCMonth()
      setUTCMonth()
    
    
      Date (of month)
      getDate()
      setDate()
      getUTCDate()
      setUTCDate()
    
    
      Hours
      getHours()
      setHours()
      getUTCHours()
      setUTCHours()
    
    
      Minutes
      getMinutes()
      setMinutes()
      getUTCMinutes()
      setUTCMinutes()
    
    
      Seconds
      getSeconds()
      setSeconds()
      getUTCSeconds()
      setUTCSeconds()
    
    
      Milliseconds
      getMilliseconds()
      setMilliseconds()
      getUTCMilliseconds()
      setUTCMilliseconds()
    
    
      Day (of week)
      getDay()
      N/A
      getUTCDay()
      N/A
    
  

The Date() constructor can be called with two or more arguments, in which case they are interpreted as the year, month, day, hour, minute, second, and millisecond, respectively, in local time. Date.UTC() works similarly, but it interprets the components as UTC time and also accepts a single argument representing the year.

Note:
Some methods, including the Date() constructor, Date.UTC(), and the deprecated getYear()/setYear() methods, interpret a two-digit year as a year in the 1900s. For example, new Date(99, 5, 24) is interpreted as June 24, 1999, not June 24, 99. See Interpretation of two-digit years for more information.

When a segment overflows or underflows its expected range, it usually "carries over to" or "borrows from" the higher segment. For example, if the month is set to 12 (months are zero-based, so December is 11), it become the January of the next year. If the day of month is set to 0, it becomes the last day of the previous month. This also applies to dates specified with the date time string format.Date time string formatThere are many ways to format a date as a string. The JavaScript specification only specifies one format to be universally supported: the date time string format, a simplification of the ISO 8601 calendar date extended format. The format is as follows:
YYYY-MM-DDTHH:mm:ss.sssZ


YYYY is the year, with four digits (0000 to 9999), or as an expanded year of + or - followed by six digits. The sign is required for expanded years. -000000 is explicitly disallowed as a valid year.
MM is the month, with two digits (01 to 12). Defaults to 01.
DD is the day of the month, with two digits (01 to 31). Defaults to 01.
T is a literal character, which indicates the beginning of the time part of the string. The T is required when specifying the time part.
HH is the hour, with two digits (00 to 23). As a special case, 24:00:00 is allowed, and is interpreted as midnight at the beginning of the next day. Defaults to 00.
mm is the minute, with two digits (00 to 59). Defaults to 00.
ss is the second, with two digits (00 to 59). Defaults to 00.
sss is the millisecond, with three digits (000 to 999). Defaults to 000.
Z is the timezone offset, which can either be the literal character Z (indicating UTC), or + or - followed by HH:mm, the offset in hours and minutes from UTC.

Various components can be omitted, so the following are all valid:

Date-only form: YYYY, YYYY-MM, YYYY-MM-DD
Date-time form: one of the above date-only forms, followed by T, followed by HH:mm, HH:mm:ss, or HH:mm:ss.sss. Each combination can be followed by a time zone offset.

For example, "2011-10-10" (date-only form), "2011-10-10T14:48:00" (date-time form), or "2011-10-10T14:48:00.000+09:00" (date-time form with milliseconds and time zone) are all valid date time strings.
When the time zone offset is absent, date-only forms are interpreted as a UTC time and date-time forms are interpreted as a local time. The interpretation as a UTC time is due to a historical spec error that was not consistent with ISO 8601 but could not be changed due to web compatibility. See Broken Parser – A Web Reality Issue.
Date.parse() and the Date() constructor both accept strings in the date time string format as input. Furthermore, implementations are allowed to support other date formats when the input fails to match this format.
The toISOString() method returns a string representation of the date in the date time string format, with the time zone offset always set to Z (UTC).

Note:
You are encouraged to make sure your input conforms to the date time string format above for maximum compatibility, because support for other formats is not guaranteed. However, there are some formats that are supported in all major implementations — like RFC 2822 format — in which case their usage can be acceptable. Always conduct cross-browser tests to ensure your code works in all target browsers. A library can help if many different formats are to be accommodated.

Non-standard strings can be parsed in any way as desired by the implementation, including the time zone — most implementations use the local time zone by default. Implementations are not required to return invalid date for out-of-bounds date components, although they usually do. A string may have in-bounds date components (with the bounds defined above), but does not represent a date in reality (for example, "February 30"). Implementations behave inconsistently in this case. The Date.parse() page offers more examples about these non-standard cases.Other ways to format a date
toISOString() returns a string in the format 1970-01-01T00:00:00.000Z (the date time string format introduced above, which is simplified ISO 8601). toJSON() calls toISOString() and returns the result.
toString() returns a string in the format Thu Jan 01 1970 00:00:00 GMT+0000 (Coordinated Universal Time), while toDateString() and toTimeString() return the date and time parts of the string, respectively. [Symbol.toPrimitive]() (when passed "string" or "default") calls toString() and returns the result.
toUTCString() returns a string in the format Thu, 01 Jan 1970 00:00:00 GMT (generalized RFC 7231).
toLocaleDateString(), toLocaleTimeString(), and toLocaleString() use locale-specific date and time formats, usually provided by the Intl API.

See the Formats of toString method return values section for examples.Constructor
Date()

When called as a constructor, returns a new Date object. When called as a function, returns a string representation of the current date and time.

Static methods
Date.now()

Returns the numeric value corresponding to the current time—the number of milliseconds since January 1, 1970 00:00:00 UTC, with leap seconds ignored.

Date.parse()

Parses a string representation of a date and returns the number of milliseconds since January 1, 1970 00:00:00 UTC, with leap seconds ignored.

Date.UTC()

Accepts the same parameters as the longest form of the constructor (i.e., 2 to 7) and returns the number of milliseconds since January 1, 1970 00:00:00 UTC, with leap seconds ignored.

Instance propertiesThese properties are defined on Date.prototype and shared by all Date instances.

Date.prototype.constructor

The constructor function that created the instance object. For Date instances, the initial value is the Date constructor.

Instance methods
Date.prototype.getDate()

Returns the day of the month (1 – 31) for the specified date according to local time.

Date.prototype.getDay()

Returns the day of the week (0 – 6) for the specified date according to local time.

Date.prototype.getFullYear()

Returns the year (4 digits for 4-digit years) of the specified date according to local time.

Date.prototype.getHours()

Returns the hour (0 – 23) in the specified date according to local time.

Date.prototype.getMilliseconds()

Returns the milliseconds (0 – 999) in the specified date according to local time.

Date.prototype.getMinutes()

Returns the minutes (0 – 59) in the specified date according to local time.

Date.prototype.getMonth()

Returns the month (0 – 11) in the specified date according to local time.

Date.prototype.getSeconds()

Returns the seconds (0 – 59) in the specified date according to local time.

Date.prototype.getTime()

Returns the numeric value of the specified date as the number of milliseconds since January 1, 1970 00:00:00 UTC. (Negative values are returned for prior times.)

Date.prototype.getTimezoneOffset()

Returns the time-zone offset in minutes for the current locale.

Date.prototype.getUTCDate()

Returns the day (date) of the month (1 – 31) in the specified date according to universal time.

Date.prototype.getUTCDay()

Returns the day of the week (0 – 6) in the specified date according to universal time.

Date.prototype.getUTCFullYear()

Returns the year (4 digits for 4-digit years) in the specified date according to universal time.

Date.prototype.getUTCHours()

Returns the hours (0 – 23) in the specified date according to universal time.

Date.prototype.getUTCMilliseconds()

Returns the milliseconds (0 – 999) in the specified date according to universal time.

Date.prototype.getUTCMinutes()

Returns the minutes (0 – 59) in the specified date according to universal time.

Date.prototype.getUTCMonth()

Returns the month (0 – 11) in the specified date according to universal time.

Date.prototype.getUTCSeconds()

Returns the seconds (0 – 59) in the specified date according to universal time.

Date.prototype.getYear() 
Deprecated


Returns the year (usually 2–3 digits) in the specified date according to local time. Use getFullYear() instead.

Date.prototype.setDate()

Sets the day of the month for a specified date according to local time.

Date.prototype.setFullYear()

Sets the full year (e.g., 4 digits for 4-digit years) for a specified date according to local time.

Date.prototype.setHours()

Sets the hours for a specified date according to local time.

Date.prototype.setMilliseconds()

Sets the milliseconds for a specified date according to local time.

Date.prototype.setMinutes()

Sets the minutes for a specified date according to local time.

Date.prototype.setMonth()

Sets the month for a specified date according to local time.

Date.prototype.setSeconds()

Sets the seconds for a specified date according to local time.

Date.prototype.setTime()

Sets the Date object to the time represented by the number of milliseconds since January 1, 1970 00:00:00 UTC. Use negative numbers for times prior.

Date.prototype.setUTCDate()

Sets the day of the month for a specified date according to universal time.

Date.prototype.setUTCFullYear()

Sets the full year (e.g., 4 digits for 4-digit years) for a specified date according to universal time.

Date.prototype.setUTCHours()

Sets the hour for a specified date according to universal time.

Date.prototype.setUTCMilliseconds()

Sets the milliseconds for a specified date according to universal time.

Date.prototype.setUTCMinutes()

Sets the minutes for a specified date according to universal time.

Date.prototype.setUTCMonth()

Sets the month for a specified date according to universal time.

Date.prototype.setUTCSeconds()

Sets the seconds for a specified date according to universal time.

Date.prototype.setYear() 
Deprecated


Sets the year (usually 2–3 digits) for a specified date according to local time. Use setFullYear() instead.

Date.prototype.toDateString()

Returns the "date" portion of the Date as a human-readable string like 'Thu Apr 12 2018'.

Date.prototype.toISOString()

Converts a date to a string following the ISO 8601 Extended Format.

Date.prototype.toJSON()

Returns a string representing the Date using toISOString(). Intended to be implicitly called by JSON.stringify().

Date.prototype.toLocaleDateString()

Returns a string with a locality sensitive representation of the date portion of this date based on system settings.

Date.prototype.toLocaleString()

Returns a string with a locality-sensitive representation of this date. Overrides the Object.prototype.toLocaleString() method.

Date.prototype.toLocaleTimeString()

Returns a string with a locality-sensitive representation of the time portion of this date, based on system settings.

Date.prototype.toString()

Returns a string representing the specified Date object. Overrides the Object.prototype.toString() method.

Date.prototype.toTemporalInstant() 
Experimental


Returns a new Temporal.Instant object with the same epochMilliseconds value as this date's timestamp.

Date.prototype.toTimeString()

Returns the "time" portion of the Date as a human-readable string.

Date.prototype.toUTCString()

Converts a date to a string using the UTC timezone.

Date.prototype.valueOf()

Returns the primitive value of a Date object. Overrides the Object.prototype.valueOf() method.

Date.prototype[Symbol.toPrimitive]()

Converts this Date object to a primitive value.

ExamplesSeveral ways to create a Date objectThe following examples show several ways to create JavaScript dates:

Note:
Creating a date from a string has a lot of behavior inconsistencies. See date time string format for caveats on using different formats.

jsconst today = new Date();
const birthday = new Date("December 17, 1995 03:24:00"); // DISCOURAGED: may not work in all runtimes
const birthday2 = new Date("1995-12-17T03:24:00"); // This is standardized and will work reliably
const birthday3 = new Date(1995, 11, 17); // the month is 0-indexed
const birthday4 = new Date(1995, 11, 17, 3, 24, 0);
const birthday5 = new Date(628021800000); // passing epoch timestamp
Formats of toString method return valuesjsconst date = new Date("2020-05-12T23:50:21.817Z");
date.toString(); // Tue May 12 2020 18:50:21 GMT-0500 (Central Daylight Time)
date.toDateString(); // Tue May 12 2020
date.toTimeString(); // 18:50:21 GMT-0500 (Central Daylight Time)
date[Symbol.toPrimitive]("string"); // Tue May 12 2020 18:50:21 GMT-0500 (Central Daylight Time)

date.toISOString(); // 2020-05-12T23:50:21.817Z
date.toJSON(); // 2020-05-12T23:50:21.817Z

date.toUTCString(); // Tue, 12 May 2020 23:50:21 GMT

date.toLocaleString(); // 5/12/2020, 6:50:21 PM
date.toLocaleDateString(); // 5/12/2020
date.toLocaleTimeString(); // 6:50:21 PM
To get Date, Month and Year or Timejsconst date = new Date("2000-01-17T16:45:30");
const [month, day, year] = [
  date.getMonth(),
  date.getDate(),
  date.getFullYear(),
];
// [0, 17, 2000] as month are 0-indexed
const [hour, minutes, seconds] = [
  date.getHours(),
  date.getMinutes(),
  date.getSeconds(),
];
// [16, 45, 30]
Interpretation of two-digit yearsnew Date() exhibits legacy undesirable, inconsistent behavior with two-digit year values; specifically, when a new Date() call is given a two-digit year value, that year value does not get treated as a literal year and used as-is but instead gets interpreted as a relative offset — in some cases as an offset from the year 1900, but in other cases, as an offset from the year 2000.
jslet date = new Date(98, 1); // Sun Feb 01 1998 00:00:00 GMT+0000 (GMT)
date = new Date(22, 1); // Wed Feb 01 1922 00:00:00 GMT+0000 (GMT)
date = new Date("2/1/22"); // Tue Feb 01 2022 00:00:00 GMT+0000 (GMT)

// Legacy method; always interprets two-digit year values as relative to 1900
date.setYear(98);
date.toString(); // Sun Feb 01 1998 00:00:00 GMT+0000 (GMT)
date.setYear(22);
date.toString(); // Wed Feb 01 1922 00:00:00 GMT+0000 (GMT)

So, to create and get dates between the years 0 and 99, instead use the preferred setFullYear() and getFullYear() methods:.
js// Preferred method; never interprets any value as being a relative offset,
// but instead uses the year value as-is
date.setFullYear(98);
date.getFullYear(); // 98 (not 1998)
date.setFullYear(22);
date.getFullYear(); // 22 (not 1922, not 2022)
Calculating elapsed timeThe following examples show how to determine the elapsed time between two JavaScript dates in milliseconds.
Due to the differing lengths of days (due to daylight saving changeover), months, and years, expressing elapsed time in units greater than hours, minutes, and seconds requires addressing a number of issues, and should be thoroughly researched before being attempted.
js// Using Date objects
const start = Date.now();

// The event to time goes here:
doSomethingForALongTime();
const end = Date.now();
const elapsed = end - start; // elapsed time in milliseconds

js// Using built-in methods
const start = new Date();

// The event to time goes here:
doSomethingForALongTime();
const end = new Date();
const elapsed = end.getTime() - start.getTime(); // elapsed time in milliseconds

js// To test a function and get back its return
function printElapsedTime(testFn) {
  const startTime = Date.now();
  const result = testFn();
  const endTime = Date.now();

  console.log(`Elapsed time: ${String(endTime - startTime)} milliseconds`);
  return result;
}

const yourFunctionReturn = printElapsedTime(yourFunction);


Note:
In browsers that support the Performance API's high-resolution time feature, Performance.now() can provide more reliable and precise measurements of elapsed time than Date.now().
Get the number of seconds since the ECMAScript Epochjsconst seconds = Math.floor(Date.now() / 1000);

In this case, it's important to return only an integer—so a simple division won't do. It's also important to only return actually elapsed seconds. (That's why this code uses Math.floor(), and not Math.round().)SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-date-objectsBrowser compatibilitySee also
Date()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\ndecodeURI()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe decodeURI() function decodes a Uniform Resource Identifier (URI) previously created by encodeURI() or a similar routine.Try it
const uri = "https://mozilla.org/?x=шеллы";
const encoded = encodeURI(uri);
console.log(encoded);
// Expected output: "https://mozilla.org/?x=%D1%88%D0%B5%D0%BB%D0%BB%D1%8B"

try {
  console.log(decodeURI(encoded));
  // Expected output: "https://mozilla.org/?x=шеллы"
} catch (e) {
  // Catches a malformed URI
  console.error(e);
}
SyntaxjsdecodeURI(encodedURI)
Parameters
encodedURI

A complete, encoded Uniform Resource Identifier.

Return valueA new string representing the unencoded version of the given encoded Uniform Resource Identifier (URI).Exceptions
URIError

Thrown if encodedURI contains a % not followed by two hexadecimal digits, or if the escape sequence does not encode a valid UTF-8 character.

DescriptiondecodeURI() is a function property of the global object.
The decodeURI() function decodes the URI by treating each escape sequence in the form %XX as one UTF-8 code unit (one byte). In UTF-8, the number of leading 1 bits in the first byte, which may be 0 (for 1-byte ASCII characters), 2, 3, or 4, indicates the number of bytes in the character. So by reading the first escape sequence, decodeURI() can determine how many more escape sequences to consume. If decodeURI() fails to find the expected number of sequences, or if the escape sequences don't encode a valid UTF-8 character, a URIError is thrown.
decodeURI() decodes all escape sequences, but if the escape sequence encodes one of the following characters, the escape sequence is preserved in the output string (because they are part of the URI syntax):
; / ? : @ & = + $ , #
ExamplesDecoding a Cyrillic URLjsdecodeURI(
  "https://developer.mozilla.org/ru/docs/JavaScript_%D1%88%D0%B5%D0%BB%D0%BB%D1%8B",
);
// "https://developer.mozilla.org/ru/docs/JavaScript_шеллы"
decodeURI() vs. decodeURIComponent()decodeURI() assumes the input is a full URI, so it does not decode characters that are part of the URI syntax.
jsdecodeURI(
  "https://developer.mozilla.org/docs/JavaScript%3A%20a_scripting_language",
);
// "https://developer.mozilla.org/docs/JavaScript%3A a_scripting_language"

decodeURIComponent(
  "https://developer.mozilla.org/docs/JavaScript%3A%20a_scripting_language",
);
// "https://developer.mozilla.org/docs/JavaScript: a_scripting_language"
Catching errorsjstry {
  const a = decodeURI("%E0%A4%A");
} catch (e) {
  console.error(e);
}

// URIError: malformed URI sequence
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-decodeuri-encodeduriBrowser compatibilitySee also
decodeURIComponent()
encodeURI()
encodeURIComponent()\n\ndecodeURI()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe decodeURI() function decodes a Uniform Resource Identifier (URI) previously created by encodeURI() or a similar routine.Try it
const uri = "https://mozilla.org/?x=шеллы";
const encoded = encodeURI(uri);
console.log(encoded);
// Expected output: "https://mozilla.org/?x=%D1%88%D0%B5%D0%BB%D0%BB%D1%8B"

try {
  console.log(decodeURI(encoded));
  // Expected output: "https://mozilla.org/?x=шеллы"
} catch (e) {
  // Catches a malformed URI
  console.error(e);
}
SyntaxjsdecodeURI(encodedURI)
Parameters
encodedURI

A complete, encoded Uniform Resource Identifier.

Return valueA new string representing the unencoded version of the given encoded Uniform Resource Identifier (URI).Exceptions
URIError

Thrown if encodedURI contains a % not followed by two hexadecimal digits, or if the escape sequence does not encode a valid UTF-8 character.

DescriptiondecodeURI() is a function property of the global object.
The decodeURI() function decodes the URI by treating each escape sequence in the form %XX as one UTF-8 code unit (one byte). In UTF-8, the number of leading 1 bits in the first byte, which may be 0 (for 1-byte ASCII characters), 2, 3, or 4, indicates the number of bytes in the character. So by reading the first escape sequence, decodeURI() can determine how many more escape sequences to consume. If decodeURI() fails to find the expected number of sequences, or if the escape sequences don't encode a valid UTF-8 character, a URIError is thrown.
decodeURI() decodes all escape sequences, but if the escape sequence encodes one of the following characters, the escape sequence is preserved in the output string (because they are part of the URI syntax):
; / ? : @ & = + $ , #
ExamplesDecoding a Cyrillic URLjsdecodeURI(
  "https://developer.mozilla.org/ru/docs/JavaScript_%D1%88%D0%B5%D0%BB%D0%BB%D1%8B",
);
// "https://developer.mozilla.org/ru/docs/JavaScript_шеллы"
decodeURI() vs. decodeURIComponent()decodeURI() assumes the input is a full URI, so it does not decode characters that are part of the URI syntax.
jsdecodeURI(
  "https://developer.mozilla.org/docs/JavaScript%3A%20a_scripting_language",
);
// "https://developer.mozilla.org/docs/JavaScript%3A a_scripting_language"

decodeURIComponent(
  "https://developer.mozilla.org/docs/JavaScript%3A%20a_scripting_language",
);
// "https://developer.mozilla.org/docs/JavaScript: a_scripting_language"
Catching errorsjstry {
  const a = decodeURI("%E0%A4%A");
} catch (e) {
  console.error(e);
}

// URIError: malformed URI sequence
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-decodeuri-encodeduriBrowser compatibilitySee also
decodeURIComponent()
encodeURI()
encodeURIComponent()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\ndecodeURI()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe decodeURI() function decodes a Uniform Resource Identifier (URI) previously created by encodeURI() or a similar routine.Try it
const uri = "https://mozilla.org/?x=шеллы";
const encoded = encodeURI(uri);
console.log(encoded);
// Expected output: "https://mozilla.org/?x=%D1%88%D0%B5%D0%BB%D0%BB%D1%8B"

try {
  console.log(decodeURI(encoded));
  // Expected output: "https://mozilla.org/?x=шеллы"
} catch (e) {
  // Catches a malformed URI
  console.error(e);
}
SyntaxjsdecodeURI(encodedURI)
Parameters
encodedURI

A complete, encoded Uniform Resource Identifier.

Return valueA new string representing the unencoded version of the given encoded Uniform Resource Identifier (URI).Exceptions
URIError

Thrown if encodedURI contains a % not followed by two hexadecimal digits, or if the escape sequence does not encode a valid UTF-8 character.

DescriptiondecodeURI() is a function property of the global object.
The decodeURI() function decodes the URI by treating each escape sequence in the form %XX as one UTF-8 code unit (one byte). In UTF-8, the number of leading 1 bits in the first byte, which may be 0 (for 1-byte ASCII characters), 2, 3, or 4, indicates the number of bytes in the character. So by reading the first escape sequence, decodeURI() can determine how many more escape sequences to consume. If decodeURI() fails to find the expected number of sequences, or if the escape sequences don't encode a valid UTF-8 character, a URIError is thrown.
decodeURI() decodes all escape sequences, but if the escape sequence encodes one of the following characters, the escape sequence is preserved in the output string (because they are part of the URI syntax):
; / ? : @ & = + $ , #
ExamplesDecoding a Cyrillic URLjsdecodeURI(
  "https://developer.mozilla.org/ru/docs/JavaScript_%D1%88%D0%B5%D0%BB%D0%BB%D1%8B",
);
// "https://developer.mozilla.org/ru/docs/JavaScript_шеллы"
decodeURI() vs. decodeURIComponent()decodeURI() assumes the input is a full URI, so it does not decode characters that are part of the URI syntax.
jsdecodeURI(
  "https://developer.mozilla.org/docs/JavaScript%3A%20a_scripting_language",
);
// "https://developer.mozilla.org/docs/JavaScript%3A a_scripting_language"

decodeURIComponent(
  "https://developer.mozilla.org/docs/JavaScript%3A%20a_scripting_language",
);
// "https://developer.mozilla.org/docs/JavaScript: a_scripting_language"
Catching errorsjstry {
  const a = decodeURI("%E0%A4%A");
} catch (e) {
  console.error(e);
}

// URIError: malformed URI sequence
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-decodeuri-encodeduriBrowser compatibilitySee also
decodeURIComponent()
encodeURI()
encodeURIComponent()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\ndecodeURIComponent()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe decodeURIComponent() function decodes a Uniform Resource Identifier (URI) component previously created by encodeURIComponent() or by a similar routine.Try it
function containsEncodedComponents(x) {
  // ie ?,=,&,/ etc
  return decodeURI(x) !== decodeURIComponent(x);
}

console.log(containsEncodedComponents("%3Fx%3Dtest")); // ?x=test
// Expected output: true

console.log(containsEncodedComponents("%D1%88%D0%B5%D0%BB%D0%BB%D1%8B")); // шеллы
// Expected output: false
SyntaxjsdecodeURIComponent(encodedURI)
Parameters
encodedURI

An encoded component of a Uniform Resource Identifier.

Return valueA new string representing the decoded version of the given encoded Uniform Resource Identifier (URI) component.Exceptions
URIError

Thrown if encodedURI contains a % not followed by two hexadecimal digits, or if the escape sequence does not encode a valid UTF-8 character.

DescriptiondecodeURIComponent() is a function property of the global object.
decodeURIComponent() uses the same decoding algorithm as described in decodeURI(). It decodes all escape sequences, including those that are not created by encodeURIComponent, like -.!~*'().ExamplesDecoding a Cyrillic URL componentjsdecodeURIComponent("JavaScript_%D1%88%D0%B5%D0%BB%D0%BB%D1%8B");
// "JavaScript_шеллы"
Catching errorsjstry {
  const a = decodeURIComponent("%E0%A4%A");
} catch (e) {
  console.error(e);
}

// URIError: malformed URI sequence
Decoding query parameters from a URLdecodeURIComponent() cannot be used directly to parse query parameters from a URL. It needs a bit of preparation.
jsfunction decodeQueryParam(p) {
  return decodeURIComponent(p.replace(/\+/g, " "));
}

decodeQueryParam("search+query%20%28correct%29");
// 'search query (correct)'
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-decodeuricomponent-encodeduricomponentBrowser compatibilitySee also
decodeURI
encodeURI
encodeURIComponent\n\ndecodeURIComponent()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe decodeURIComponent() function decodes a Uniform Resource Identifier (URI) component previously created by encodeURIComponent() or by a similar routine.Try it
function containsEncodedComponents(x) {
  // ie ?,=,&,/ etc
  return decodeURI(x) !== decodeURIComponent(x);
}

console.log(containsEncodedComponents("%3Fx%3Dtest")); // ?x=test
// Expected output: true

console.log(containsEncodedComponents("%D1%88%D0%B5%D0%BB%D0%BB%D1%8B")); // шеллы
// Expected output: false
SyntaxjsdecodeURIComponent(encodedURI)
Parameters
encodedURI

An encoded component of a Uniform Resource Identifier.

Return valueA new string representing the decoded version of the given encoded Uniform Resource Identifier (URI) component.Exceptions
URIError

Thrown if encodedURI contains a % not followed by two hexadecimal digits, or if the escape sequence does not encode a valid UTF-8 character.

DescriptiondecodeURIComponent() is a function property of the global object.
decodeURIComponent() uses the same decoding algorithm as described in decodeURI(). It decodes all escape sequences, including those that are not created by encodeURIComponent, like -.!~*'().ExamplesDecoding a Cyrillic URL componentjsdecodeURIComponent("JavaScript_%D1%88%D0%B5%D0%BB%D0%BB%D1%8B");
// "JavaScript_шеллы"
Catching errorsjstry {
  const a = decodeURIComponent("%E0%A4%A");
} catch (e) {
  console.error(e);
}

// URIError: malformed URI sequence
Decoding query parameters from a URLdecodeURIComponent() cannot be used directly to parse query parameters from a URL. It needs a bit of preparation.
jsfunction decodeQueryParam(p) {
  return decodeURIComponent(p.replace(/\+/g, " "));
}

decodeQueryParam("search+query%20%28correct%29");
// 'search query (correct)'
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-decodeuricomponent-encodeduricomponentBrowser compatibilitySee also
decodeURI
encodeURI
encodeURIComponent
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\ndecodeURIComponent()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe decodeURIComponent() function decodes a Uniform Resource Identifier (URI) component previously created by encodeURIComponent() or by a similar routine.Try it
function containsEncodedComponents(x) {
  // ie ?,=,&,/ etc
  return decodeURI(x) !== decodeURIComponent(x);
}

console.log(containsEncodedComponents("%3Fx%3Dtest")); // ?x=test
// Expected output: true

console.log(containsEncodedComponents("%D1%88%D0%B5%D0%BB%D0%BB%D1%8B")); // шеллы
// Expected output: false
SyntaxjsdecodeURIComponent(encodedURI)
Parameters
encodedURI

An encoded component of a Uniform Resource Identifier.

Return valueA new string representing the decoded version of the given encoded Uniform Resource Identifier (URI) component.Exceptions
URIError

Thrown if encodedURI contains a % not followed by two hexadecimal digits, or if the escape sequence does not encode a valid UTF-8 character.

DescriptiondecodeURIComponent() is a function property of the global object.
decodeURIComponent() uses the same decoding algorithm as described in decodeURI(). It decodes all escape sequences, including those that are not created by encodeURIComponent, like -.!~*'().ExamplesDecoding a Cyrillic URL componentjsdecodeURIComponent("JavaScript_%D1%88%D0%B5%D0%BB%D0%BB%D1%8B");
// "JavaScript_шеллы"
Catching errorsjstry {
  const a = decodeURIComponent("%E0%A4%A");
} catch (e) {
  console.error(e);
}

// URIError: malformed URI sequence
Decoding query parameters from a URLdecodeURIComponent() cannot be used directly to parse query parameters from a URL. It needs a bit of preparation.
jsfunction decodeQueryParam(p) {
  return decodeURIComponent(p.replace(/\+/g, " "));
}

decodeQueryParam("search+query%20%28correct%29");
// 'search query (correct)'
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-decodeuricomponent-encodeduricomponentBrowser compatibilitySee also
decodeURI
encodeURI
encodeURIComponent
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nencodeURI()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe encodeURI() function encodes a URI by replacing each instance of certain characters by one, two, three, or four escape sequences representing the UTF-8 encoding of the character (will only be four escape sequences for characters composed of two surrogate characters). Compared to encodeURIComponent(), this function encodes fewer characters, preserving those that are part of the URI syntax.Try it
const uri = "https://mozilla.org/?x=шеллы";
const encoded = encodeURI(uri);
console.log(encoded);
// Expected output: "https://mozilla.org/?x=%D1%88%D0%B5%D0%BB%D0%BB%D1%8B"

try {
  console.log(decodeURI(encoded));
  // Expected output: "https://mozilla.org/?x=шеллы"
} catch (e) {
  // Catches a malformed URI
  console.error(e);
}
SyntaxjsencodeURI(uri)
Parameters
uri

A string to be encoded as a URI.

Return valueA new string representing the provided string encoded as a URI.Exceptions
URIError

Thrown if uri contains a lone surrogate.

DescriptionencodeURI() is a function property of the global object.
The encodeURI() function escapes characters by UTF-8 code units, with each octet encoded in the format %XX, left-padded with 0 if necessary. Because lone surrogates in UTF-16 do not encode any valid Unicode character, they cause encodeURI() to throw a URIError.
encodeURI() escapes all characters except:
A–Z a–z 0–9 - _ . ! ~ * ' ( )

; / ? : @ & = + $ , #

The characters on the second line are characters that may be part of the URI syntax, and are only escaped by encodeURIComponent(). Both encodeURI() and encodeURIComponent() do not encode the characters -.!~*'(), known as "unreserved marks", which do not have a reserved purpose but are allowed in a URI "as is". (See RFC2396)
The encodeURI() function does not encode characters that have special meaning (reserved characters) for a URI. The following example shows all the parts that a URI can possibly contain. Note how certain characters are used to signify special meaning:
urlhttp://username:password@www.example.com:80/path/to/file.php?foo=316&bar=this+has+spaces#anchor

encodeURI, as the name implies, is used to encode a URL as a whole, assuming it is already well-formed. If you want to dynamically assemble string values into a URL, you probably want to use encodeURIComponent() on each dynamic segment instead, to avoid URL syntax characters in unwanted places.
jsconst name = "Ben & Jerry's";

// This is bad:
const link = encodeURI(`https://example.com/?choice=${name}`); // "https://example.com/?choice=Ben%20&%20Jerry's"
console.log([...new URL(link).searchParams]); // [['choice', 'Ben '], [" Jerry's", '']

// Instead:
const link = encodeURI(
  `https://example.com/?choice=${encodeURIComponent(name)}`,
);
// "https://example.com/?choice=Ben%2520%2526%2520Jerry's"
console.log([...new URL(link).searchParams]); // [['choice', "Ben%20%26%20Jerry's"]]
ExamplesencodeURI() vs. encodeURIComponent()encodeURI() differs from encodeURIComponent() as follows:
jsconst set1 = ";/?:@&=+$,#"; // Reserved Characters
const set2 = "-.!~*'()"; // Unreserved Marks
const set3 = "ABC abc 123"; // Alphanumeric Characters + Space

console.log(encodeURI(set1)); // ;/?:@&=+$,#
console.log(encodeURI(set2)); // -.!~*'()
console.log(encodeURI(set3)); // ABC%20abc%20123 (the space gets encoded as %20)

console.log(encodeURIComponent(set1)); // %3B%2C%2F%3F%3A%40%26%3D%2B%24%23
console.log(encodeURIComponent(set2)); // -.!~*'()
console.log(encodeURIComponent(set3)); // ABC%20abc%20123 (the space gets encoded as %20)
Encoding a lone surrogate throwsA URIError will be thrown if one attempts to encode a surrogate which is not part of a high-low pair. For example:
js// High-low pair OK
encodeURI("\uD800\uDFFF"); // "%F0%90%8F%BF"

// Lone high-surrogate code unit throws "URIError: malformed URI sequence"
encodeURI("\uD800");

// Lone low-surrogate code unit throws "URIError: malformed URI sequence"
encodeURI("\uDFFF");

You can use String.prototype.toWellFormed(), which replaces lone surrogates with the Unicode replacement character (U+FFFD), to avoid this error. You can also use String.prototype.isWellFormed() to check if a string contains lone surrogates before passing it to encodeURI().Encoding for RFC3986The more recent RFC3986 makes square brackets reserved (for IPv6) and thus not encoded when forming something which could be part of a URL (such as a host). It also reserves !, ', (, ), and *, even though these characters have no formalized URI delimiting uses. The following function encodes a string for RFC3986-compliant URL format.
jsfunction encodeRFC3986URI(str) {
  return encodeURI(str)
    .replace(/%5B/g, "[")
    .replace(/%5D/g, "]")
    .replace(
      /[!'()*]/g,
      (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`,
    );
}
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-encodeuri-uriBrowser compatibilitySee also
decodeURI()
encodeURIComponent()
decodeURIComponent()\n\nencodeURI()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe encodeURI() function encodes a URI by replacing each instance of certain characters by one, two, three, or four escape sequences representing the UTF-8 encoding of the character (will only be four escape sequences for characters composed of two surrogate characters). Compared to encodeURIComponent(), this function encodes fewer characters, preserving those that are part of the URI syntax.Try it
const uri = "https://mozilla.org/?x=шеллы";
const encoded = encodeURI(uri);
console.log(encoded);
// Expected output: "https://mozilla.org/?x=%D1%88%D0%B5%D0%BB%D0%BB%D1%8B"

try {
  console.log(decodeURI(encoded));
  // Expected output: "https://mozilla.org/?x=шеллы"
} catch (e) {
  // Catches a malformed URI
  console.error(e);
}
SyntaxjsencodeURI(uri)
Parameters
uri

A string to be encoded as a URI.

Return valueA new string representing the provided string encoded as a URI.Exceptions
URIError

Thrown if uri contains a lone surrogate.

DescriptionencodeURI() is a function property of the global object.
The encodeURI() function escapes characters by UTF-8 code units, with each octet encoded in the format %XX, left-padded with 0 if necessary. Because lone surrogates in UTF-16 do not encode any valid Unicode character, they cause encodeURI() to throw a URIError.
encodeURI() escapes all characters except:
A–Z a–z 0–9 - _ . ! ~ * ' ( )

; / ? : @ & = + $ , #

The characters on the second line are characters that may be part of the URI syntax, and are only escaped by encodeURIComponent(). Both encodeURI() and encodeURIComponent() do not encode the characters -.!~*'(), known as "unreserved marks", which do not have a reserved purpose but are allowed in a URI "as is". (See RFC2396)
The encodeURI() function does not encode characters that have special meaning (reserved characters) for a URI. The following example shows all the parts that a URI can possibly contain. Note how certain characters are used to signify special meaning:
urlhttp://username:password@www.example.com:80/path/to/file.php?foo=316&bar=this+has+spaces#anchor

encodeURI, as the name implies, is used to encode a URL as a whole, assuming it is already well-formed. If you want to dynamically assemble string values into a URL, you probably want to use encodeURIComponent() on each dynamic segment instead, to avoid URL syntax characters in unwanted places.
jsconst name = "Ben & Jerry's";

// This is bad:
const link = encodeURI(`https://example.com/?choice=${name}`); // "https://example.com/?choice=Ben%20&%20Jerry's"
console.log([...new URL(link).searchParams]); // [['choice', 'Ben '], [" Jerry's", '']

// Instead:
const link = encodeURI(
  `https://example.com/?choice=${encodeURIComponent(name)}`,
);
// "https://example.com/?choice=Ben%2520%2526%2520Jerry's"
console.log([...new URL(link).searchParams]); // [['choice', "Ben%20%26%20Jerry's"]]
ExamplesencodeURI() vs. encodeURIComponent()encodeURI() differs from encodeURIComponent() as follows:
jsconst set1 = ";/?:@&=+$,#"; // Reserved Characters
const set2 = "-.!~*'()"; // Unreserved Marks
const set3 = "ABC abc 123"; // Alphanumeric Characters + Space

console.log(encodeURI(set1)); // ;/?:@&=+$,#
console.log(encodeURI(set2)); // -.!~*'()
console.log(encodeURI(set3)); // ABC%20abc%20123 (the space gets encoded as %20)

console.log(encodeURIComponent(set1)); // %3B%2C%2F%3F%3A%40%26%3D%2B%24%23
console.log(encodeURIComponent(set2)); // -.!~*'()
console.log(encodeURIComponent(set3)); // ABC%20abc%20123 (the space gets encoded as %20)
Encoding a lone surrogate throwsA URIError will be thrown if one attempts to encode a surrogate which is not part of a high-low pair. For example:
js// High-low pair OK
encodeURI("\uD800\uDFFF"); // "%F0%90%8F%BF"

// Lone high-surrogate code unit throws "URIError: malformed URI sequence"
encodeURI("\uD800");

// Lone low-surrogate code unit throws "URIError: malformed URI sequence"
encodeURI("\uDFFF");

You can use String.prototype.toWellFormed(), which replaces lone surrogates with the Unicode replacement character (U+FFFD), to avoid this error. You can also use String.prototype.isWellFormed() to check if a string contains lone surrogates before passing it to encodeURI().Encoding for RFC3986The more recent RFC3986 makes square brackets reserved (for IPv6) and thus not encoded when forming something which could be part of a URL (such as a host). It also reserves !, ', (, ), and *, even though these characters have no formalized URI delimiting uses. The following function encodes a string for RFC3986-compliant URL format.
jsfunction encodeRFC3986URI(str) {
  return encodeURI(str)
    .replace(/%5B/g, "[")
    .replace(/%5D/g, "]")
    .replace(
      /[!'()*]/g,
      (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`,
    );
}
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-encodeuri-uriBrowser compatibilitySee also
decodeURI()
encodeURIComponent()
decodeURIComponent()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nencodeURI()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe encodeURI() function encodes a URI by replacing each instance of certain characters by one, two, three, or four escape sequences representing the UTF-8 encoding of the character (will only be four escape sequences for characters composed of two surrogate characters). Compared to encodeURIComponent(), this function encodes fewer characters, preserving those that are part of the URI syntax.Try it
const uri = "https://mozilla.org/?x=шеллы";
const encoded = encodeURI(uri);
console.log(encoded);
// Expected output: "https://mozilla.org/?x=%D1%88%D0%B5%D0%BB%D0%BB%D1%8B"

try {
  console.log(decodeURI(encoded));
  // Expected output: "https://mozilla.org/?x=шеллы"
} catch (e) {
  // Catches a malformed URI
  console.error(e);
}
SyntaxjsencodeURI(uri)
Parameters
uri

A string to be encoded as a URI.

Return valueA new string representing the provided string encoded as a URI.Exceptions
URIError

Thrown if uri contains a lone surrogate.

DescriptionencodeURI() is a function property of the global object.
The encodeURI() function escapes characters by UTF-8 code units, with each octet encoded in the format %XX, left-padded with 0 if necessary. Because lone surrogates in UTF-16 do not encode any valid Unicode character, they cause encodeURI() to throw a URIError.
encodeURI() escapes all characters except:
A–Z a–z 0–9 - _ . ! ~ * ' ( )

; / ? : @ & = + $ , #

The characters on the second line are characters that may be part of the URI syntax, and are only escaped by encodeURIComponent(). Both encodeURI() and encodeURIComponent() do not encode the characters -.!~*'(), known as "unreserved marks", which do not have a reserved purpose but are allowed in a URI "as is". (See RFC2396)
The encodeURI() function does not encode characters that have special meaning (reserved characters) for a URI. The following example shows all the parts that a URI can possibly contain. Note how certain characters are used to signify special meaning:
urlhttp://username:password@www.example.com:80/path/to/file.php?foo=316&bar=this+has+spaces#anchor

encodeURI, as the name implies, is used to encode a URL as a whole, assuming it is already well-formed. If you want to dynamically assemble string values into a URL, you probably want to use encodeURIComponent() on each dynamic segment instead, to avoid URL syntax characters in unwanted places.
jsconst name = "Ben & Jerry's";

// This is bad:
const link = encodeURI(`https://example.com/?choice=${name}`); // "https://example.com/?choice=Ben%20&%20Jerry's"
console.log([...new URL(link).searchParams]); // [['choice', 'Ben '], [" Jerry's", '']

// Instead:
const link = encodeURI(
  `https://example.com/?choice=${encodeURIComponent(name)}`,
);
// "https://example.com/?choice=Ben%2520%2526%2520Jerry's"
console.log([...new URL(link).searchParams]); // [['choice', "Ben%20%26%20Jerry's"]]
ExamplesencodeURI() vs. encodeURIComponent()encodeURI() differs from encodeURIComponent() as follows:
jsconst set1 = ";/?:@&=+$,#"; // Reserved Characters
const set2 = "-.!~*'()"; // Unreserved Marks
const set3 = "ABC abc 123"; // Alphanumeric Characters + Space

console.log(encodeURI(set1)); // ;/?:@&=+$,#
console.log(encodeURI(set2)); // -.!~*'()
console.log(encodeURI(set3)); // ABC%20abc%20123 (the space gets encoded as %20)

console.log(encodeURIComponent(set1)); // %3B%2C%2F%3F%3A%40%26%3D%2B%24%23
console.log(encodeURIComponent(set2)); // -.!~*'()
console.log(encodeURIComponent(set3)); // ABC%20abc%20123 (the space gets encoded as %20)
Encoding a lone surrogate throwsA URIError will be thrown if one attempts to encode a surrogate which is not part of a high-low pair. For example:
js// High-low pair OK
encodeURI("\uD800\uDFFF"); // "%F0%90%8F%BF"

// Lone high-surrogate code unit throws "URIError: malformed URI sequence"
encodeURI("\uD800");

// Lone low-surrogate code unit throws "URIError: malformed URI sequence"
encodeURI("\uDFFF");

You can use String.prototype.toWellFormed(), which replaces lone surrogates with the Unicode replacement character (U+FFFD), to avoid this error. You can also use String.prototype.isWellFormed() to check if a string contains lone surrogates before passing it to encodeURI().Encoding for RFC3986The more recent RFC3986 makes square brackets reserved (for IPv6) and thus not encoded when forming something which could be part of a URL (such as a host). It also reserves !, ', (, ), and *, even though these characters have no formalized URI delimiting uses. The following function encodes a string for RFC3986-compliant URL format.
jsfunction encodeRFC3986URI(str) {
  return encodeURI(str)
    .replace(/%5B/g, "[")
    .replace(/%5D/g, "]")
    .replace(
      /[!'()*]/g,
      (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`,
    );
}
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-encodeuri-uriBrowser compatibilitySee also
decodeURI()
encodeURIComponent()
decodeURIComponent()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nencodeURIComponent()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe encodeURIComponent() function encodes a URI by replacing each instance of certain characters by one, two, three, or four escape sequences representing the UTF-8 encoding of the character (will only be four escape sequences for characters composed of two surrogate characters). Compared to encodeURI(), this function encodes more characters, including those that are part of the URI syntax.Try it
// Encodes characters such as ?,=,/,&,:
console.log(`?x=${encodeURIComponent("test?")}`);
// Expected output: "?x=test%3F"

console.log(`?x=${encodeURIComponent("шеллы")}`);
// Expected output: "?x=%D1%88%D0%B5%D0%BB%D0%BB%D1%8B"
SyntaxjsencodeURIComponent(uriComponent)
Parameters
uriComponent

A string to be encoded as a URI component (a path, query string, fragment, etc.). Other values are converted to strings.

Return valueA new string representing the provided uriComponent encoded as a URI component.Exceptions
URIError

Thrown if uriComponent contains a lone surrogate.

DescriptionencodeURIComponent() is a function property of the global object.
encodeURIComponent() uses the same encoding algorithm as described in encodeURI(). It escapes all characters except:
A–Z a–z 0–9 - _ . ! ~ * ' ( )

Compared to encodeURI(), encodeURIComponent() escapes a larger set of characters. Use encodeURIComponent() on user-entered fields from forms sent to the server — this will encode & symbols that may inadvertently be generated during data entry for character references or other characters that require encoding/decoding. For example, if a user writes Jack & Jill, without encodeURIComponent(), the ampersand could be interpreted on the server as the start of a new field and jeopardize the integrity of the data.
For application/x-www-form-urlencoded, spaces are to be replaced by +, so one may wish to follow a encodeURIComponent() replacement with an additional replacement of %20 with +.ExamplesEncoding for Content-Disposition and Link headersThe following example provides the special encoding required within UTF-8 Content-Disposition and Link server response header parameters (e.g., UTF-8 filenames):
jsconst fileName = "my file(2).txt";
const header = `Content-Disposition: attachment; filename*=UTF-8''${encodeRFC5987ValueChars(
  fileName,
)}`;

console.log(header);
// "Content-Disposition: attachment; filename*=UTF-8''my%20file%282%29.txt"

function encodeRFC5987ValueChars(str) {
  return (
    encodeURIComponent(str)
      // The following creates the sequences %27 %28 %29 %2A (Note that
      // the valid encoding of "*" is %2A, which necessitates calling
      // toUpperCase() to properly encode). Although RFC3986 reserves "!",
      // RFC5987 does not, so we do not need to escape it.
      .replace(
        /['()*]/g,
        (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`,
      )
      // The following are not required for percent-encoding per RFC5987,
      // so we can allow for a little better readability over the wire: |`^
      .replace(/%(7C|60|5E)/g, (str, hex) =>
        String.fromCharCode(parseInt(hex, 16)),
      )
  );
}
Encoding for RFC3986The more recent RFC3986 reserves !, ', (, ), and *, even though these characters have no formalized URI delimiting uses. The following function encodes a string for RFC3986-compliant URL component format. It also encodes [ and ], which are part of the IPv6 URI syntax. An RFC3986-compliant encodeURI implementation should not escape them, which is demonstrated in the encodeURI() example.
jsfunction encodeRFC3986URIComponent(str) {
  return encodeURIComponent(str).replace(
    /[!'()*]/g,
    (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`,
  );
}
Encoding a lone surrogate throwsA URIError will be thrown if one attempts to encode a surrogate which is not part of a high-low pair. For example:
js// High-low pair OK
encodeURIComponent("\uD800\uDFFF"); // "%F0%90%8F%BF"

// Lone high-surrogate code unit throws "URIError: malformed URI sequence"
encodeURIComponent("\uD800");

// Lone high-surrogate code unit throws "URIError: malformed URI sequence"
encodeURIComponent("\uDFFF");

You can use String.prototype.toWellFormed(), which replaces lone surrogates with the Unicode replacement character (U+FFFD), to avoid this error. You can also use String.prototype.isWellFormed() to check if a string contains lone surrogates before passing it to encodeURIComponent().SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-encodeuricomponent-uricomponentBrowser compatibilitySee also
decodeURI()
encodeURI()
decodeURIComponent()\n\nencodeURIComponent()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe encodeURIComponent() function encodes a URI by replacing each instance of certain characters by one, two, three, or four escape sequences representing the UTF-8 encoding of the character (will only be four escape sequences for characters composed of two surrogate characters). Compared to encodeURI(), this function encodes more characters, including those that are part of the URI syntax.Try it
// Encodes characters such as ?,=,/,&,:
console.log(`?x=${encodeURIComponent("test?")}`);
// Expected output: "?x=test%3F"

console.log(`?x=${encodeURIComponent("шеллы")}`);
// Expected output: "?x=%D1%88%D0%B5%D0%BB%D0%BB%D1%8B"
SyntaxjsencodeURIComponent(uriComponent)
Parameters
uriComponent

A string to be encoded as a URI component (a path, query string, fragment, etc.). Other values are converted to strings.

Return valueA new string representing the provided uriComponent encoded as a URI component.Exceptions
URIError

Thrown if uriComponent contains a lone surrogate.

DescriptionencodeURIComponent() is a function property of the global object.
encodeURIComponent() uses the same encoding algorithm as described in encodeURI(). It escapes all characters except:
A–Z a–z 0–9 - _ . ! ~ * ' ( )

Compared to encodeURI(), encodeURIComponent() escapes a larger set of characters. Use encodeURIComponent() on user-entered fields from forms sent to the server — this will encode & symbols that may inadvertently be generated during data entry for character references or other characters that require encoding/decoding. For example, if a user writes Jack & Jill, without encodeURIComponent(), the ampersand could be interpreted on the server as the start of a new field and jeopardize the integrity of the data.
For application/x-www-form-urlencoded, spaces are to be replaced by +, so one may wish to follow a encodeURIComponent() replacement with an additional replacement of %20 with +.ExamplesEncoding for Content-Disposition and Link headersThe following example provides the special encoding required within UTF-8 Content-Disposition and Link server response header parameters (e.g., UTF-8 filenames):
jsconst fileName = "my file(2).txt";
const header = `Content-Disposition: attachment; filename*=UTF-8''${encodeRFC5987ValueChars(
  fileName,
)}`;

console.log(header);
// "Content-Disposition: attachment; filename*=UTF-8''my%20file%282%29.txt"

function encodeRFC5987ValueChars(str) {
  return (
    encodeURIComponent(str)
      // The following creates the sequences %27 %28 %29 %2A (Note that
      // the valid encoding of "*" is %2A, which necessitates calling
      // toUpperCase() to properly encode). Although RFC3986 reserves "!",
      // RFC5987 does not, so we do not need to escape it.
      .replace(
        /['()*]/g,
        (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`,
      )
      // The following are not required for percent-encoding per RFC5987,
      // so we can allow for a little better readability over the wire: |`^
      .replace(/%(7C|60|5E)/g, (str, hex) =>
        String.fromCharCode(parseInt(hex, 16)),
      )
  );
}
Encoding for RFC3986The more recent RFC3986 reserves !, ', (, ), and *, even though these characters have no formalized URI delimiting uses. The following function encodes a string for RFC3986-compliant URL component format. It also encodes [ and ], which are part of the IPv6 URI syntax. An RFC3986-compliant encodeURI implementation should not escape them, which is demonstrated in the encodeURI() example.
jsfunction encodeRFC3986URIComponent(str) {
  return encodeURIComponent(str).replace(
    /[!'()*]/g,
    (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`,
  );
}
Encoding a lone surrogate throwsA URIError will be thrown if one attempts to encode a surrogate which is not part of a high-low pair. For example:
js// High-low pair OK
encodeURIComponent("\uD800\uDFFF"); // "%F0%90%8F%BF"

// Lone high-surrogate code unit throws "URIError: malformed URI sequence"
encodeURIComponent("\uD800");

// Lone high-surrogate code unit throws "URIError: malformed URI sequence"
encodeURIComponent("\uDFFF");

You can use String.prototype.toWellFormed(), which replaces lone surrogates with the Unicode replacement character (U+FFFD), to avoid this error. You can also use String.prototype.isWellFormed() to check if a string contains lone surrogates before passing it to encodeURIComponent().SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-encodeuricomponent-uricomponentBrowser compatibilitySee also
decodeURI()
encodeURI()
decodeURIComponent()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 22, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nencodeURIComponent()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe encodeURIComponent() function encodes a URI by replacing each instance of certain characters by one, two, three, or four escape sequences representing the UTF-8 encoding of the character (will only be four escape sequences for characters composed of two surrogate characters). Compared to encodeURI(), this function encodes more characters, including those that are part of the URI syntax.Try it
// Encodes characters such as ?,=,/,&,:
console.log(`?x=${encodeURIComponent("test?")}`);
// Expected output: "?x=test%3F"

console.log(`?x=${encodeURIComponent("шеллы")}`);
// Expected output: "?x=%D1%88%D0%B5%D0%BB%D0%BB%D1%8B"
SyntaxjsencodeURIComponent(uriComponent)
Parameters
uriComponent

A string to be encoded as a URI component (a path, query string, fragment, etc.). Other values are converted to strings.

Return valueA new string representing the provided uriComponent encoded as a URI component.Exceptions
URIError

Thrown if uriComponent contains a lone surrogate.

DescriptionencodeURIComponent() is a function property of the global object.
encodeURIComponent() uses the same encoding algorithm as described in encodeURI(). It escapes all characters except:
A–Z a–z 0–9 - _ . ! ~ * ' ( )

Compared to encodeURI(), encodeURIComponent() escapes a larger set of characters. Use encodeURIComponent() on user-entered fields from forms sent to the server — this will encode & symbols that may inadvertently be generated during data entry for character references or other characters that require encoding/decoding. For example, if a user writes Jack & Jill, without encodeURIComponent(), the ampersand could be interpreted on the server as the start of a new field and jeopardize the integrity of the data.
For application/x-www-form-urlencoded, spaces are to be replaced by +, so one may wish to follow a encodeURIComponent() replacement with an additional replacement of %20 with +.ExamplesEncoding for Content-Disposition and Link headersThe following example provides the special encoding required within UTF-8 Content-Disposition and Link server response header parameters (e.g., UTF-8 filenames):
jsconst fileName = "my file(2).txt";
const header = `Content-Disposition: attachment; filename*=UTF-8''${encodeRFC5987ValueChars(
  fileName,
)}`;

console.log(header);
// "Content-Disposition: attachment; filename*=UTF-8''my%20file%282%29.txt"

function encodeRFC5987ValueChars(str) {
  return (
    encodeURIComponent(str)
      // The following creates the sequences %27 %28 %29 %2A (Note that
      // the valid encoding of "*" is %2A, which necessitates calling
      // toUpperCase() to properly encode). Although RFC3986 reserves "!",
      // RFC5987 does not, so we do not need to escape it.
      .replace(
        /['()*]/g,
        (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`,
      )
      // The following are not required for percent-encoding per RFC5987,
      // so we can allow for a little better readability over the wire: |`^
      .replace(/%(7C|60|5E)/g, (str, hex) =>
        String.fromCharCode(parseInt(hex, 16)),
      )
  );
}
Encoding for RFC3986The more recent RFC3986 reserves !, ', (, ), and *, even though these characters have no formalized URI delimiting uses. The following function encodes a string for RFC3986-compliant URL component format. It also encodes [ and ], which are part of the IPv6 URI syntax. An RFC3986-compliant encodeURI implementation should not escape them, which is demonstrated in the encodeURI() example.
jsfunction encodeRFC3986URIComponent(str) {
  return encodeURIComponent(str).replace(
    /[!'()*]/g,
    (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`,
  );
}
Encoding a lone surrogate throwsA URIError will be thrown if one attempts to encode a surrogate which is not part of a high-low pair. For example:
js// High-low pair OK
encodeURIComponent("\uD800\uDFFF"); // "%F0%90%8F%BF"

// Lone high-surrogate code unit throws "URIError: malformed URI sequence"
encodeURIComponent("\uD800");

// Lone high-surrogate code unit throws "URIError: malformed URI sequence"
encodeURIComponent("\uDFFF");

You can use String.prototype.toWellFormed(), which replaces lone surrogates with the Unicode replacement character (U+FFFD), to avoid this error. You can also use String.prototype.isWellFormed() to check if a string contains lone surrogates before passing it to encodeURIComponent().SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-encodeuricomponent-uricomponentBrowser compatibilitySee also
decodeURI()
encodeURI()
decodeURIComponent()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 22, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nErrorBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackError objects are thrown when runtime errors occur. The Error object can also be used as a base object for user-defined exceptions. See below for standard built-in error types.DescriptionRuntime errors result in new Error objects being created and thrown.
Error is a serializable object, so it can be cloned with structuredClone() or copied between Workers using postMessage().Error typesBesides the generic Error constructor, there are other core error constructors in JavaScript. For client-side exceptions, see Exception handling statements.

EvalError

Creates an instance representing an error that occurs regarding the global function eval().

RangeError

Creates an instance representing an error that occurs when a numeric variable or parameter is outside its valid range.

ReferenceError

Creates an instance representing an error that occurs when de-referencing an invalid reference.

SyntaxError

Creates an instance representing a syntax error.

TypeError

Creates an instance representing an error that occurs when a variable or parameter is not of a valid type.

URIError

Creates an instance representing an error that occurs when encodeURI() or decodeURI() are passed invalid parameters.

AggregateError

Creates an instance representing several errors wrapped in a single error when multiple errors need to be reported by an operation, for example by Promise.any().

InternalError 
Non-standard


Creates an instance representing an error that occurs when an internal error in the JavaScript engine is thrown. E.g. "too much recursion".

Constructor
Error()

Creates a new Error object.

Static properties
Error.stackTraceLimit 
Non-standard


A non-standard numerical property that limits how many stack frames to include in an error stack trace.

Static methods
Error.captureStackTrace()

A non-standard function that creates the stack property on the provided object.

Error.isError()

Returns true if the argument is an error, or false otherwise.

Error.prepareStackTrace() 
Non-standard
 Optional

A non-standard function that, if provided by user code, is called by the JavaScript engine for thrown exceptions, allowing the user to provide custom formatting for stack traces. See the V8 Stack Trace API docs.

Instance propertiesThese properties are defined on Error.prototype and shared by all Error instances.

Error.prototype.constructor

The constructor function that created the instance object. For Error instances, the initial value is the Error constructor.

Error.prototype.name

Represents the name for the type of error. For Error.prototype.name, the initial value is "Error". Subclasses like TypeError and SyntaxError provide their own name properties.

Error.prototype.stack 
Non-standard


A non-standard property for a stack trace.


These properties are own properties of each Error instance.

cause

Error cause indicating the reason why the current error is thrown — usually another caught error. For user-created Error objects, this is the value provided as the cause property of the constructor's second argument.

columnNumber 
Non-standard


A non-standard Mozilla property for the column number in the line that raised this error.

fileName 
Non-standard


A non-standard Mozilla property for the path to the file that raised this error.

lineNumber 
Non-standard


A non-standard Mozilla property for the line number in the file that raised this error.

message

Error message. For user-created Error objects, this is the string provided as the constructor's first argument.

Instance methods
Error.prototype.toString()

Returns a string representing the specified object. Overrides the Object.prototype.toString() method.

ExamplesThrowing a generic errorUsually you create an Error object with the intention of raising it using the throw keyword.
You can handle the error using the try...catch construct:
jstry {
  throw new Error("Whoops!");
} catch (e) {
  console.error(`${e.name}: ${e.message}`);
}
Handling a specific error typeYou can choose to handle only specific error types by testing the error type with the instanceof keyword:
jstry {
  foo.bar();
} catch (e) {
  if (e instanceof EvalError) {
    console.error(`${e.name}: ${e.message}`);
  } else if (e instanceof RangeError) {
    console.error(`${e.name}: ${e.message}`);
  }
  // etc.
  else {
    // If none of our cases matched leave the Error unhandled
    throw e;
  }
}
Differentiate between similar errorsSometimes a block of code can fail for reasons that require different handling, but which throw very similar errors (i.e., with the same type and message).
If you don't have control over the original errors that are thrown, one option is to catch them and throw new Error objects that have more specific messages.
The original error should be passed to the new Error in the constructor's options parameter as its cause property. This ensures that the original error and stack trace are available to higher-level try/catch blocks.
The example below shows this for two methods that would otherwise fail with similar errors (doFailSomeWay() and doFailAnotherWay()):
jsfunction doWork() {
  try {
    doFailSomeWay();
  } catch (err) {
    throw new Error("Failed in some way", { cause: err });
  }
  try {
    doFailAnotherWay();
  } catch (err) {
    throw new Error("Failed in another way", { cause: err });
  }
}

try {
  doWork();
} catch (err) {
  switch (err.message) {
    case "Failed in some way":
      handleFailSomeWay(err.cause);
      break;
    case "Failed in another way":
      handleFailAnotherWay(err.cause);
      break;
  }
}


Note:
If you are making a library, you should prefer to use error cause to discriminate between different errors emitted — rather than asking your consumers to parse the error message. See the error cause page for an example.

Custom error types can also use the cause property, provided the subclasses' constructor passes the options parameter when calling super(). The Error() base class constructor will read options.cause and define the cause property on the new error instance.
jsclass MyError extends Error {
  constructor(message, options) {
    // Need to pass `options` as the second parameter to install the "cause" property.
    super(message, options);
  }
}

console.log(new MyError("test", { cause: new Error("cause") }).cause);
// Error: cause
Custom error typesYou might want to define your own error types deriving from Error to be able to throw new MyError() and use instanceof MyError to check the kind of error in the exception handler. This results in cleaner and more consistent error handling code.
See "What's a good way to extend Error in JavaScript?" on Stack Overflow for an in-depth discussion.

Warning:
Builtin subclassing cannot be reliably transpiled to pre-ES6 code, because there's no way to construct the base class with a particular new.target without Reflect.construct(). You need additional configuration or manually call Object.setPrototypeOf(this, CustomError.prototype) at the end of the constructor; otherwise, the constructed instance will not be a CustomError instance. See the TypeScript FAQ for more information.


Note:
Some browsers include the CustomError constructor in the stack trace when using ES2015 classes.

jsclass CustomError extends Error {
  constructor(foo = "bar", ...params) {
    // Pass remaining arguments (including vendor specific ones) to parent constructor
    super(...params);

    // Maintains proper stack trace for where our error was thrown (non-standard)
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, CustomError);
    }

    this.name = "CustomError";
    // Custom debugging information
    this.foo = foo;
    this.date = new Date();
  }
}

try {
  throw new CustomError("baz", "bazMessage");
} catch (e) {
  console.error(e.name); // CustomError
  console.error(e.foo); // baz
  console.error(e.message); // bazMessage
  console.error(e.stack); // stack trace
}
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-error-objectsBrowser compatibilitySee also
Polyfill of Error with cause support in core-js
es-shims polyfill of Error cause
throw
try...catch
Stack trace API in the V8 docs\n\nErrorBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackError objects are thrown when runtime errors occur. The Error object can also be used as a base object for user-defined exceptions. See below for standard built-in error types.DescriptionRuntime errors result in new Error objects being created and thrown.
Error is a serializable object, so it can be cloned with structuredClone() or copied between Workers using postMessage().Error typesBesides the generic Error constructor, there are other core error constructors in JavaScript. For client-side exceptions, see Exception handling statements.

EvalError

Creates an instance representing an error that occurs regarding the global function eval().

RangeError

Creates an instance representing an error that occurs when a numeric variable or parameter is outside its valid range.

ReferenceError

Creates an instance representing an error that occurs when de-referencing an invalid reference.

SyntaxError

Creates an instance representing a syntax error.

TypeError

Creates an instance representing an error that occurs when a variable or parameter is not of a valid type.

URIError

Creates an instance representing an error that occurs when encodeURI() or decodeURI() are passed invalid parameters.

AggregateError

Creates an instance representing several errors wrapped in a single error when multiple errors need to be reported by an operation, for example by Promise.any().

InternalError 
Non-standard


Creates an instance representing an error that occurs when an internal error in the JavaScript engine is thrown. E.g. "too much recursion".

Constructor
Error()

Creates a new Error object.

Static properties
Error.stackTraceLimit 
Non-standard


A non-standard numerical property that limits how many stack frames to include in an error stack trace.

Static methods
Error.captureStackTrace()

A non-standard function that creates the stack property on the provided object.

Error.isError()

Returns true if the argument is an error, or false otherwise.

Error.prepareStackTrace() 
Non-standard
 Optional

A non-standard function that, if provided by user code, is called by the JavaScript engine for thrown exceptions, allowing the user to provide custom formatting for stack traces. See the V8 Stack Trace API docs.

Instance propertiesThese properties are defined on Error.prototype and shared by all Error instances.

Error.prototype.constructor

The constructor function that created the instance object. For Error instances, the initial value is the Error constructor.

Error.prototype.name

Represents the name for the type of error. For Error.prototype.name, the initial value is "Error". Subclasses like TypeError and SyntaxError provide their own name properties.

Error.prototype.stack 
Non-standard


A non-standard property for a stack trace.


These properties are own properties of each Error instance.

cause

Error cause indicating the reason why the current error is thrown — usually another caught error. For user-created Error objects, this is the value provided as the cause property of the constructor's second argument.

columnNumber 
Non-standard


A non-standard Mozilla property for the column number in the line that raised this error.

fileName 
Non-standard


A non-standard Mozilla property for the path to the file that raised this error.

lineNumber 
Non-standard


A non-standard Mozilla property for the line number in the file that raised this error.

message

Error message. For user-created Error objects, this is the string provided as the constructor's first argument.

Instance methods
Error.prototype.toString()

Returns a string representing the specified object. Overrides the Object.prototype.toString() method.

ExamplesThrowing a generic errorUsually you create an Error object with the intention of raising it using the throw keyword.
You can handle the error using the try...catch construct:
jstry {
  throw new Error("Whoops!");
} catch (e) {
  console.error(`${e.name}: ${e.message}`);
}
Handling a specific error typeYou can choose to handle only specific error types by testing the error type with the instanceof keyword:
jstry {
  foo.bar();
} catch (e) {
  if (e instanceof EvalError) {
    console.error(`${e.name}: ${e.message}`);
  } else if (e instanceof RangeError) {
    console.error(`${e.name}: ${e.message}`);
  }
  // etc.
  else {
    // If none of our cases matched leave the Error unhandled
    throw e;
  }
}
Differentiate between similar errorsSometimes a block of code can fail for reasons that require different handling, but which throw very similar errors (i.e., with the same type and message).
If you don't have control over the original errors that are thrown, one option is to catch them and throw new Error objects that have more specific messages.
The original error should be passed to the new Error in the constructor's options parameter as its cause property. This ensures that the original error and stack trace are available to higher-level try/catch blocks.
The example below shows this for two methods that would otherwise fail with similar errors (doFailSomeWay() and doFailAnotherWay()):
jsfunction doWork() {
  try {
    doFailSomeWay();
  } catch (err) {
    throw new Error("Failed in some way", { cause: err });
  }
  try {
    doFailAnotherWay();
  } catch (err) {
    throw new Error("Failed in another way", { cause: err });
  }
}

try {
  doWork();
} catch (err) {
  switch (err.message) {
    case "Failed in some way":
      handleFailSomeWay(err.cause);
      break;
    case "Failed in another way":
      handleFailAnotherWay(err.cause);
      break;
  }
}


Note:
If you are making a library, you should prefer to use error cause to discriminate between different errors emitted — rather than asking your consumers to parse the error message. See the error cause page for an example.

Custom error types can also use the cause property, provided the subclasses' constructor passes the options parameter when calling super(). The Error() base class constructor will read options.cause and define the cause property on the new error instance.
jsclass MyError extends Error {
  constructor(message, options) {
    // Need to pass `options` as the second parameter to install the "cause" property.
    super(message, options);
  }
}

console.log(new MyError("test", { cause: new Error("cause") }).cause);
// Error: cause
Custom error typesYou might want to define your own error types deriving from Error to be able to throw new MyError() and use instanceof MyError to check the kind of error in the exception handler. This results in cleaner and more consistent error handling code.
See "What's a good way to extend Error in JavaScript?" on Stack Overflow for an in-depth discussion.

Warning:
Builtin subclassing cannot be reliably transpiled to pre-ES6 code, because there's no way to construct the base class with a particular new.target without Reflect.construct(). You need additional configuration or manually call Object.setPrototypeOf(this, CustomError.prototype) at the end of the constructor; otherwise, the constructed instance will not be a CustomError instance. See the TypeScript FAQ for more information.


Note:
Some browsers include the CustomError constructor in the stack trace when using ES2015 classes.

jsclass CustomError extends Error {
  constructor(foo = "bar", ...params) {
    // Pass remaining arguments (including vendor specific ones) to parent constructor
    super(...params);

    // Maintains proper stack trace for where our error was thrown (non-standard)
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, CustomError);
    }

    this.name = "CustomError";
    // Custom debugging information
    this.foo = foo;
    this.date = new Date();
  }
}

try {
  throw new CustomError("baz", "bazMessage");
} catch (e) {
  console.error(e.name); // CustomError
  console.error(e.foo); // baz
  console.error(e.message); // bazMessage
  console.error(e.stack); // stack trace
}
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-error-objectsBrowser compatibilitySee also
Polyfill of Error with cause support in core-js
es-shims polyfill of Error cause
throw
try...catch
Stack trace API in the V8 docs
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 9, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nErrorBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackError objects are thrown when runtime errors occur. The Error object can also be used as a base object for user-defined exceptions. See below for standard built-in error types.DescriptionRuntime errors result in new Error objects being created and thrown.
Error is a serializable object, so it can be cloned with structuredClone() or copied between Workers using postMessage().Error typesBesides the generic Error constructor, there are other core error constructors in JavaScript. For client-side exceptions, see Exception handling statements.

EvalError

Creates an instance representing an error that occurs regarding the global function eval().

RangeError

Creates an instance representing an error that occurs when a numeric variable or parameter is outside its valid range.

ReferenceError

Creates an instance representing an error that occurs when de-referencing an invalid reference.

SyntaxError

Creates an instance representing a syntax error.

TypeError

Creates an instance representing an error that occurs when a variable or parameter is not of a valid type.

URIError

Creates an instance representing an error that occurs when encodeURI() or decodeURI() are passed invalid parameters.

AggregateError

Creates an instance representing several errors wrapped in a single error when multiple errors need to be reported by an operation, for example by Promise.any().

InternalError 
Non-standard


Creates an instance representing an error that occurs when an internal error in the JavaScript engine is thrown. E.g. "too much recursion".

Constructor
Error()

Creates a new Error object.

Static properties
Error.stackTraceLimit 
Non-standard


A non-standard numerical property that limits how many stack frames to include in an error stack trace.

Static methods
Error.captureStackTrace()

A non-standard function that creates the stack property on the provided object.

Error.isError()

Returns true if the argument is an error, or false otherwise.

Error.prepareStackTrace() 
Non-standard
 Optional

A non-standard function that, if provided by user code, is called by the JavaScript engine for thrown exceptions, allowing the user to provide custom formatting for stack traces. See the V8 Stack Trace API docs.

Instance propertiesThese properties are defined on Error.prototype and shared by all Error instances.

Error.prototype.constructor

The constructor function that created the instance object. For Error instances, the initial value is the Error constructor.

Error.prototype.name

Represents the name for the type of error. For Error.prototype.name, the initial value is "Error". Subclasses like TypeError and SyntaxError provide their own name properties.

Error.prototype.stack 
Non-standard


A non-standard property for a stack trace.


These properties are own properties of each Error instance.

cause

Error cause indicating the reason why the current error is thrown — usually another caught error. For user-created Error objects, this is the value provided as the cause property of the constructor's second argument.

columnNumber 
Non-standard


A non-standard Mozilla property for the column number in the line that raised this error.

fileName 
Non-standard


A non-standard Mozilla property for the path to the file that raised this error.

lineNumber 
Non-standard


A non-standard Mozilla property for the line number in the file that raised this error.

message

Error message. For user-created Error objects, this is the string provided as the constructor's first argument.

Instance methods
Error.prototype.toString()

Returns a string representing the specified object. Overrides the Object.prototype.toString() method.

ExamplesThrowing a generic errorUsually you create an Error object with the intention of raising it using the throw keyword.
You can handle the error using the try...catch construct:
jstry {
  throw new Error("Whoops!");
} catch (e) {
  console.error(`${e.name}: ${e.message}`);
}
Handling a specific error typeYou can choose to handle only specific error types by testing the error type with the instanceof keyword:
jstry {
  foo.bar();
} catch (e) {
  if (e instanceof EvalError) {
    console.error(`${e.name}: ${e.message}`);
  } else if (e instanceof RangeError) {
    console.error(`${e.name}: ${e.message}`);
  }
  // etc.
  else {
    // If none of our cases matched leave the Error unhandled
    throw e;
  }
}
Differentiate between similar errorsSometimes a block of code can fail for reasons that require different handling, but which throw very similar errors (i.e., with the same type and message).
If you don't have control over the original errors that are thrown, one option is to catch them and throw new Error objects that have more specific messages.
The original error should be passed to the new Error in the constructor's options parameter as its cause property. This ensures that the original error and stack trace are available to higher-level try/catch blocks.
The example below shows this for two methods that would otherwise fail with similar errors (doFailSomeWay() and doFailAnotherWay()):
jsfunction doWork() {
  try {
    doFailSomeWay();
  } catch (err) {
    throw new Error("Failed in some way", { cause: err });
  }
  try {
    doFailAnotherWay();
  } catch (err) {
    throw new Error("Failed in another way", { cause: err });
  }
}

try {
  doWork();
} catch (err) {
  switch (err.message) {
    case "Failed in some way":
      handleFailSomeWay(err.cause);
      break;
    case "Failed in another way":
      handleFailAnotherWay(err.cause);
      break;
  }
}


Note:
If you are making a library, you should prefer to use error cause to discriminate between different errors emitted — rather than asking your consumers to parse the error message. See the error cause page for an example.

Custom error types can also use the cause property, provided the subclasses' constructor passes the options parameter when calling super(). The Error() base class constructor will read options.cause and define the cause property on the new error instance.
jsclass MyError extends Error {
  constructor(message, options) {
    // Need to pass `options` as the second parameter to install the "cause" property.
    super(message, options);
  }
}

console.log(new MyError("test", { cause: new Error("cause") }).cause);
// Error: cause
Custom error typesYou might want to define your own error types deriving from Error to be able to throw new MyError() and use instanceof MyError to check the kind of error in the exception handler. This results in cleaner and more consistent error handling code.
See "What's a good way to extend Error in JavaScript?" on Stack Overflow for an in-depth discussion.

Warning:
Builtin subclassing cannot be reliably transpiled to pre-ES6 code, because there's no way to construct the base class with a particular new.target without Reflect.construct(). You need additional configuration or manually call Object.setPrototypeOf(this, CustomError.prototype) at the end of the constructor; otherwise, the constructed instance will not be a CustomError instance. See the TypeScript FAQ for more information.


Note:
Some browsers include the CustomError constructor in the stack trace when using ES2015 classes.

jsclass CustomError extends Error {
  constructor(foo = "bar", ...params) {
    // Pass remaining arguments (including vendor specific ones) to parent constructor
    super(...params);

    // Maintains proper stack trace for where our error was thrown (non-standard)
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, CustomError);
    }

    this.name = "CustomError";
    // Custom debugging information
    this.foo = foo;
    this.date = new Date();
  }
}

try {
  throw new CustomError("baz", "bazMessage");
} catch (e) {
  console.error(e.name); // CustomError
  console.error(e.foo); // baz
  console.error(e.message); // bazMessage
  console.error(e.stack); // stack trace
}
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-error-objectsBrowser compatibilitySee also
Polyfill of Error with cause support in core-js
es-shims polyfill of Error cause
throw
try...catch
Stack trace API in the V8 docs
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 9, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nescape()Deprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time.

Note: escape() is a non-standard function implemented by browsers and was only standardized for cross-engine compatibility. It is not required to be implemented by all JavaScript engines and may not work everywhere. Use encodeURIComponent() or encodeURI() if possible.

The escape() function computes a new string in which certain characters have been replaced by hexadecimal escape sequences.Syntaxjsescape(str)
Parameters
str

A string to be encoded.

Return valueA new string in which certain characters have been escaped.Descriptionescape() is a function property of the global object.
The escape() function replaces all characters with escape sequences, with the exception of ASCII word characters (A–Z, a–z, 0–9, _) and @\*_+-./. Characters are escaped by UTF-16 code units. If the code unit's value is less than 256, it is represented by a two-digit hexadecimal number in the format %XX, left-padded with 0 if necessary. Otherwise, it is represented by a four-digit hexadecimal number in the format %uXXXX, left-padded with 0 if necessary.

Note:
This function was used mostly for percent-encoding and is partly based on the escape format in RFC 1738. The escape format is not an escape sequence in string literals. You can replace %XX with \xXX and %uXXXX with \uXXXX to get a string containing actual string-literal escape sequences.
ExamplesUsing escape()jsescape("abc123"); // "abc123"
escape("äöü"); // "%E4%F6%FC"
escape("ć"); // "%u0107"

// special characters
escape("@*_+-./"); // "@*_+-./"
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-escape-stringBrowser compatibilitySee also
Polyfill of escape in core-js
encodeURI
encodeURIComponent
unescape\n\nescape()Deprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time.

Note: escape() is a non-standard function implemented by browsers and was only standardized for cross-engine compatibility. It is not required to be implemented by all JavaScript engines and may not work everywhere. Use encodeURIComponent() or encodeURI() if possible.

The escape() function computes a new string in which certain characters have been replaced by hexadecimal escape sequences.Syntaxjsescape(str)
Parameters
str

A string to be encoded.

Return valueA new string in which certain characters have been escaped.Descriptionescape() is a function property of the global object.
The escape() function replaces all characters with escape sequences, with the exception of ASCII word characters (A–Z, a–z, 0–9, _) and @\*_+-./. Characters are escaped by UTF-16 code units. If the code unit's value is less than 256, it is represented by a two-digit hexadecimal number in the format %XX, left-padded with 0 if necessary. Otherwise, it is represented by a four-digit hexadecimal number in the format %uXXXX, left-padded with 0 if necessary.

Note:
This function was used mostly for percent-encoding and is partly based on the escape format in RFC 1738. The escape format is not an escape sequence in string literals. You can replace %XX with \xXX and %uXXXX with \uXXXX to get a string containing actual string-literal escape sequences.
ExamplesUsing escape()jsescape("abc123"); // "abc123"
escape("äöü"); // "%E4%F6%FC"
escape("ć"); // "%u0107"

// special characters
escape("@*_+-./"); // "@*_+-./"
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-escape-stringBrowser compatibilitySee also
Polyfill of escape in core-js
encodeURI
encodeURIComponent
unescape
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jul 25, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nescape()Deprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time.

Note: escape() is a non-standard function implemented by browsers and was only standardized for cross-engine compatibility. It is not required to be implemented by all JavaScript engines and may not work everywhere. Use encodeURIComponent() or encodeURI() if possible.

The escape() function computes a new string in which certain characters have been replaced by hexadecimal escape sequences.Syntaxjsescape(str)
Parameters
str

A string to be encoded.

Return valueA new string in which certain characters have been escaped.Descriptionescape() is a function property of the global object.
The escape() function replaces all characters with escape sequences, with the exception of ASCII word characters (A–Z, a–z, 0–9, _) and @\*_+-./. Characters are escaped by UTF-16 code units. If the code unit's value is less than 256, it is represented by a two-digit hexadecimal number in the format %XX, left-padded with 0 if necessary. Otherwise, it is represented by a four-digit hexadecimal number in the format %uXXXX, left-padded with 0 if necessary.

Note:
This function was used mostly for percent-encoding and is partly based on the escape format in RFC 1738. The escape format is not an escape sequence in string literals. You can replace %XX with \xXX and %uXXXX with \uXXXX to get a string containing actual string-literal escape sequences.
ExamplesUsing escape()jsescape("abc123"); // "abc123"
escape("äöü"); // "%E4%F6%FC"
escape("ć"); // "%u0107"

// special characters
escape("@*_+-./"); // "@*_+-./"
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-escape-stringBrowser compatibilitySee also
Polyfill of escape in core-js
encodeURI
encodeURIComponent
unescape
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jul 25, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\neval()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedback
Warning:
Executing JavaScript from a string is an enormous security risk. It is far too easy for a bad actor to run arbitrary code when you use eval(). See Never use direct eval()!, below.

The eval() function evaluates JavaScript code represented as a string and returns its completion value. The source is parsed as a script.Try it
console.log(eval("2 + 2"));
// Expected output: 4

console.log(eval(new String("2 + 2")));
// Expected output: 2 + 2

console.log(eval("2 + 2") === eval("4"));
// Expected output: true

console.log(eval("2 + 2") === eval(new String("2 + 2")));
// Expected output: false
Syntaxjseval(script)
Parameters
script

A string representing a JavaScript expression, statement, or sequence of statements. The expression can include variables and properties of existing objects. It will be parsed as a script, so import declarations (which can only exist in modules) are not allowed.

Return valueThe completion value of evaluating the given code. If the completion value is empty, undefined is returned. If script is not a string primitive, eval() returns the argument unchanged.ExceptionsThrows any exception that occurs during evaluation of the code, including SyntaxError if script fails to be parsed as a script.Descriptioneval() is a function property of the global object.
The argument of the eval() function is a string. It will evaluate the source string as a script body, which means both statements and expressions are allowed. It returns the completion value of the code. For expressions, it's the value the expression evaluates to. Many statements and declarations have completion values as well, but the result may be surprising (for example, the completion value of an assignment is the assigned value, but the completion value of let is undefined), so it's recommended to not rely on statements' completion values.
In strict mode, declaring a variable named eval or re-assigning eval is a SyntaxError.
js"use strict";

const eval = 1; // SyntaxError: Unexpected eval or arguments in strict mode

If the argument of eval() is not a string, eval() returns the argument unchanged. In the following example, passing a String object instead of a primitive causes eval() to return the String object rather than evaluating the string.
jseval(new String("2 + 2")); // returns a String object containing "2 + 2"
eval("2 + 2"); // returns 4

To work around the issue in a generic fashion, you can coerce the argument to a string yourself before passing it to eval().
jsconst expression = new String("2 + 2");
eval(String(expression)); // returns 4
Direct and indirect evalThere are two modes of eval() calls: direct eval and indirect eval. Direct eval, as the name implies, refers to directly calling the global eval function with eval(...). Everything else, including invoking it via an aliased variable, via a member access or other expression, or through the optional chaining ?. operator, is indirect.
js// Direct call
eval("x + y");

// Indirect call using the comma operator to return eval
(0, eval)("x + y");

// Indirect call through optional chaining
eval?.("x + y");

// Indirect call using a variable to store and return eval
const myEval = eval;
myEval("x + y");

// Indirect call through member access
const obj = { eval };
obj.eval("x + y");

Indirect eval can be seen as if the code is evaluated within a separate <script> tag. This means:


Indirect eval works in the global scope rather than the local scope, and the code being evaluated doesn't have access to local variables within the scope where it's being called.
jsfunction test() {
  const x = 2;
  const y = 4;
  // Direct call, uses local scope
  console.log(eval("x + y")); // Result is 6
  // Indirect call, uses global scope
  console.log(eval?.("x + y")); // Throws because x is not defined in global scope
}



Indirect eval does not inherit the strictness of the surrounding context, and is only in strict mode if the source string itself has a "use strict" directive.
jsfunction nonStrictContext() {
  eval?.(`with (Math) console.log(PI);`);
}
function strictContext() {
  "use strict";
  eval?.(`with (Math) console.log(PI);`);
}
function strictContextStrictEval() {
  "use strict";
  eval?.(`"use strict"; with (Math) console.log(PI);`);
}
nonStrictContext(); // Logs 3.141592653589793
strictContext(); // Logs 3.141592653589793
strictContextStrictEval(); // Uncaught SyntaxError: Strict mode code may not include a with statement

On the other hand, direct eval inherits the strictness of the invoking context.
jsfunction nonStrictContext() {
  eval(`with (Math) console.log(PI);`);
}
function strictContext() {
  "use strict";
  eval(`with (Math) console.log(PI);`);
}
function strictContextStrictEval() {
  "use strict";
  eval(`"use strict"; with (Math) console.log(PI);`);
}
nonStrictContext(); // Logs 3.141592653589793
strictContext(); // Uncaught SyntaxError: Strict mode code may not include a with statement
strictContextStrictEval(); // Uncaught SyntaxError: Strict mode code may not include a with statement



var-declared variables and function declarations would go into the surrounding scope if the source string is not interpreted in strict mode — for indirect eval, they become global variables. If it's a direct eval in a strict mode context, or if the eval source string itself is in strict mode, then var and function declarations do not "leak" into the surrounding scope.
js// Neither context nor source string is strict,
// so var creates a variable in the surrounding scope
eval("var a = 1;");
console.log(a); // 1
// Context is not strict, but eval source is strict,
// so b is scoped to the evaluated script
eval("'use strict'; var b = 1;");
console.log(b); // ReferenceError: b is not defined

function strictContext() {
  "use strict";
  // Context is strict, but this is indirect and the source
  // string is not strict, so c is still global
  eval?.("var c = 1;");
  // Direct eval in a strict context, so d is scoped
  eval("var d = 1;");
}
strictContext();
console.log(c); // 1
console.log(d); // ReferenceError: d is not defined

let and const declarations within the evaluated string are always scoped to that script.


Direct eval may have access to additional contextual expressions. For example, in a function's body, one can use new.target:
jsfunction Ctor() {
  eval("console.log(new.target)");
}
new Ctor(); // [Function: Ctor]


Never use direct eval()!Using direct eval() suffers from multiple problems:

eval() executes the code it's passed with the privileges of the caller. If you run eval() with a string that could be affected by a malicious party, you may end up running malicious code on the user's machine with the permissions of your webpage / extension. More importantly, allowing third-party code to access the scope in which eval() was invoked (if it's a direct eval) can lead to possible attacks that reads or changes local variables.
eval() is slower than the alternatives, since it has to invoke the JavaScript interpreter, while many other constructs are optimized by modern JS engines.
Modern JavaScript interpreters convert JavaScript to machine code. This means that any concept of variable naming gets obliterated. Thus, any use of eval() will force the browser to do long expensive variable name lookups to figure out where the variable exists in the machine code and set its value. Additionally, new things can be introduced to that variable through eval(), such as changing the type of that variable, forcing the browser to re-evaluate all of the generated machine code to compensate.
Minifiers give up on any minification if the scope is transitively depended on by eval(), because otherwise eval() cannot read the correct variable at runtime.

There are many cases where the use of eval() or related methods can be optimized or avoided altogether.
Using indirect eval()
Consider this code:
jsfunction looseJsonParse(obj) {
  return eval(`(${obj})`);
}
console.log(looseJsonParse("{ a: 4 - 1, b: function () {}, c: new Map() }"));

Simply using indirect eval and forcing strict mode can make the code much better:
jsfunction looseJsonParse(obj) {
  return eval?.(`"use strict";(${obj})`);
}
console.log(looseJsonParse("{ a: 4 - 1, b: function () {}, c: new Map() }"));

The two code snippets above may seem to work the same way, but they do not; the first one using direct eval suffers from multiple problems.


It is a great deal slower, due to more scope inspections. Notice c: new Map() in the evaluated string. In the indirect eval version, the object is being evaluated in the global scope, so it is safe for the interpreter to assume that Map refers to the global Map() constructor instead of a local variable called Map. However, in the code using direct eval, the interpreter cannot assume this. For example, in the following code, Map in the evaluated string doesn't refer to window.Map().
jsfunction looseJsonParse(obj) {
  class Map {}
  return eval(`(${obj})`);
}
console.log(looseJsonParse(`{ a: 4 - 1, b: function () {}, c: new Map() }`));

Thus, in the eval() version of the code, the browser is forced to make the expensive lookup call to check to see if there are any local variables called Map().


If not using strict mode, var declarations within the eval() source becomes variables in the surrounding scope. This leads to hard-to-debug issues if the string is acquired from external input, especially if there's an existing variable with the same name.


Direct eval can read and mutate bindings in the surrounding scope, which may lead to external input corrupting local data.


When using direct eval, especially when the eval source cannot be proven to be in strict mode, the engine — and build tools — have to disable all optimizations related to inlining, because the eval() source can depend on any variable name in its surrounding scope.


However, using indirect eval() does not allow passing extra bindings other than existing global variables for the evaluated source to read. If you need to specify additional variables that the evaluated source should have access to, consider using the Function() constructor.
Using the Function() constructor
The Function() constructor is very similar to the indirect eval example above: it also evaluates the JavaScript source passed to it in the global scope without reading or mutating any local bindings, and therefore allows engines to do more optimizations than direct eval().
The difference between eval() and Function() is that the source string passed to Function() is parsed as a function body, not as a script. There are a few nuances — for example, you can use return statements at the top level of a function body, but not in a script.
The Function() constructor is useful if you wish to create local bindings within your eval source, by passing the variables as parameter bindings.
jsfunction add(a, b) {
  return a + b;
}
function runCodeWithAddFunction(obj) {
  return Function("add", `"use strict";return (${obj});`)(add);
}
console.log(runCodeWithAddFunction("add(5, 7)")); // 12

Both eval() and Function() implicitly evaluate arbitrary code, and are forbidden in strict CSP settings. There are also additional safer (and faster!) alternatives to eval() or Function() for common use-cases.
Using bracket accessors
You should not use eval() to access properties dynamically. Consider the following example where the property of the object to be accessed is not known until the code is executed. This can be done with eval():
jsconst obj = { a: 20, b: 30 };
const propName = getPropName(); // returns "a" or "b"

const result = eval(`obj.${propName}`);

However, eval() is not necessary here — in fact, it's more error-prone, because if propName is not a valid identifier, it leads to a syntax error. Moreover, if getPropName is not a function you control, this may lead to execution of arbitrary code. Instead, use the property accessors, which are much faster and safer:
jsconst obj = { a: 20, b: 30 };
const propName = getPropName(); // returns "a" or "b"
const result = obj[propName]; // obj["a"] is the same as obj.a

You can even use this method to access descendant properties. Using eval(), this would look like:
jsconst obj = { a: { b: { c: 0 } } };
const propPath = getPropPath(); // suppose it returns "a.b.c"

const result = eval(`obj.${propPath}`); // 0

Avoiding eval() here could be done by splitting the property path and looping through the different properties:
jsfunction getDescendantProp(obj, desc) {
  const arr = desc.split(".");
  while (arr.length) {
    obj = obj[arr.shift()];
  }
  return obj;
}

const obj = { a: { b: { c: 0 } } };
const propPath = getPropPath(); // suppose it returns "a.b.c"
const result = getDescendantProp(obj, propPath); // 0

Setting a property that way works similarly:
jsfunction setDescendantProp(obj, desc, value) {
  const arr = desc.split(".");
  while (arr.length > 1) {
    obj = obj[arr.shift()];
  }
  return (obj[arr[0]] = value);
}

const obj = { a: { b: { c: 0 } } };
const propPath = getPropPath(); // suppose it returns "a.b.c"
const result = setDescendantProp(obj, propPath, 1); // obj.a.b.c is now 1

However, beware that using bracket accessors with unconstrained input is not safe either — it may lead to object injection attacks.
Using callbacks
JavaScript has first-class functions, which means you can pass functions as arguments to other APIs, store them in variables and objects' properties, and so on. Many DOM APIs are designed with this in mind, so you can (and should) write:
js// Instead of setTimeout("…", 1000) use:
setTimeout(() => {
  // …
}, 1000);

// Instead of elt.setAttribute("onclick", "…") use:
elt.addEventListener("click", () => {
  // …
});

Closures are also helpful as a way to create parameterized functions without concatenating strings.
Using JSON
If the string you're calling eval() on contains data (for example, an array: "[1, 2, 3]"), as opposed to code, you should consider switching to JSON, which allows the string to use a subset of JavaScript syntax to represent data.
Note that since JSON syntax is limited compared to JavaScript syntax, many valid JavaScript literals will not parse as JSON. For example, trailing commas are not allowed in JSON, and property names (keys) in object literals must be enclosed in quotes. Be sure to use a JSON serializer to generate strings that will be later parsed as JSON.
Passing carefully constrained data instead of arbitrary code is a good idea in general. For example, an extension designed to scrape contents of web-pages could have the scraping rules defined in XPath instead of JavaScript code.ExamplesUsing eval()In the following code, both of the statements containing eval() return 42.
The first evaluates the string "x + y + 1"; the second evaluates the string
"42".
jsconst x = 2;
const y = 39;
const z = "42";
eval("x + y + 1"); // 42
eval(z); // 42
eval() returns the completion value of statementseval() returns the completion value of statements. For if, it would be the last expression or statement evaluated.
jsconst str = "if (a) { 1 + 1 } else { 1 + 2 }";
let a = true;
let b = eval(str);

console.log(`b is: ${b}`); // b is: 2

a = false;
b = eval(str);

console.log(`b is: ${b}`); // b is: 3

The following example uses eval() to evaluate the string str. This string consists of JavaScript statements that assign z a value of 42 if x is five, and assign 0 to z otherwise. When the second statement is executed, eval() will cause these statements to be performed, and it will also evaluate the set of statements and return the value that is assigned to z, because the completion value of an assignment is the assigned value.
jsconst x = 5;
const str = `if (x === 5) {
  console.log("z is 42");
  z = 42;
} else {
  z = 0;
}`;

console.log("z is ", eval(str)); // z is 42  z is 42

If you assign multiple values then the last value is returned.
jslet x = 5;
const str = `if (x === 5) {
  console.log("z is 42");
  z = 42;
  x = 420;
} else {
  z = 0;
}`;

console.log("x is", eval(str)); // z is 42  x is 420
eval() as a string defining function requires "(" and ")" as prefix and suffixjs// This is a function declaration
const fctStr1 = "function a() {}";
// This is a function expression
const fctStr2 = "(function b() {})";
const fct1 = eval(fctStr1); // return undefined, but `a` is available as a global function now
const fct2 = eval(fctStr2); // return the function `b`
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-eval-xBrowser compatibilitySee also
Property accessors
WebExtensions: Using eval in content scripts\n\neval()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedback
Warning:
Executing JavaScript from a string is an enormous security risk. It is far too easy for a bad actor to run arbitrary code when you use eval(). See Never use direct eval()!, below.

The eval() function evaluates JavaScript code represented as a string and returns its completion value. The source is parsed as a script.Try it
console.log(eval("2 + 2"));
// Expected output: 4

console.log(eval(new String("2 + 2")));
// Expected output: 2 + 2

console.log(eval("2 + 2") === eval("4"));
// Expected output: true

console.log(eval("2 + 2") === eval(new String("2 + 2")));
// Expected output: false
Syntaxjseval(script)
Parameters
script

A string representing a JavaScript expression, statement, or sequence of statements. The expression can include variables and properties of existing objects. It will be parsed as a script, so import declarations (which can only exist in modules) are not allowed.

Return valueThe completion value of evaluating the given code. If the completion value is empty, undefined is returned. If script is not a string primitive, eval() returns the argument unchanged.ExceptionsThrows any exception that occurs during evaluation of the code, including SyntaxError if script fails to be parsed as a script.Descriptioneval() is a function property of the global object.
The argument of the eval() function is a string. It will evaluate the source string as a script body, which means both statements and expressions are allowed. It returns the completion value of the code. For expressions, it's the value the expression evaluates to. Many statements and declarations have completion values as well, but the result may be surprising (for example, the completion value of an assignment is the assigned value, but the completion value of let is undefined), so it's recommended to not rely on statements' completion values.
In strict mode, declaring a variable named eval or re-assigning eval is a SyntaxError.
js"use strict";

const eval = 1; // SyntaxError: Unexpected eval or arguments in strict mode

If the argument of eval() is not a string, eval() returns the argument unchanged. In the following example, passing a String object instead of a primitive causes eval() to return the String object rather than evaluating the string.
jseval(new String("2 + 2")); // returns a String object containing "2 + 2"
eval("2 + 2"); // returns 4

To work around the issue in a generic fashion, you can coerce the argument to a string yourself before passing it to eval().
jsconst expression = new String("2 + 2");
eval(String(expression)); // returns 4
Direct and indirect evalThere are two modes of eval() calls: direct eval and indirect eval. Direct eval, as the name implies, refers to directly calling the global eval function with eval(...). Everything else, including invoking it via an aliased variable, via a member access or other expression, or through the optional chaining ?. operator, is indirect.
js// Direct call
eval("x + y");

// Indirect call using the comma operator to return eval
(0, eval)("x + y");

// Indirect call through optional chaining
eval?.("x + y");

// Indirect call using a variable to store and return eval
const myEval = eval;
myEval("x + y");

// Indirect call through member access
const obj = { eval };
obj.eval("x + y");

Indirect eval can be seen as if the code is evaluated within a separate <script> tag. This means:


Indirect eval works in the global scope rather than the local scope, and the code being evaluated doesn't have access to local variables within the scope where it's being called.
jsfunction test() {
  const x = 2;
  const y = 4;
  // Direct call, uses local scope
  console.log(eval("x + y")); // Result is 6
  // Indirect call, uses global scope
  console.log(eval?.("x + y")); // Throws because x is not defined in global scope
}



Indirect eval does not inherit the strictness of the surrounding context, and is only in strict mode if the source string itself has a "use strict" directive.
jsfunction nonStrictContext() {
  eval?.(`with (Math) console.log(PI);`);
}
function strictContext() {
  "use strict";
  eval?.(`with (Math) console.log(PI);`);
}
function strictContextStrictEval() {
  "use strict";
  eval?.(`"use strict"; with (Math) console.log(PI);`);
}
nonStrictContext(); // Logs 3.141592653589793
strictContext(); // Logs 3.141592653589793
strictContextStrictEval(); // Uncaught SyntaxError: Strict mode code may not include a with statement

On the other hand, direct eval inherits the strictness of the invoking context.
jsfunction nonStrictContext() {
  eval(`with (Math) console.log(PI);`);
}
function strictContext() {
  "use strict";
  eval(`with (Math) console.log(PI);`);
}
function strictContextStrictEval() {
  "use strict";
  eval(`"use strict"; with (Math) console.log(PI);`);
}
nonStrictContext(); // Logs 3.141592653589793
strictContext(); // Uncaught SyntaxError: Strict mode code may not include a with statement
strictContextStrictEval(); // Uncaught SyntaxError: Strict mode code may not include a with statement



var-declared variables and function declarations would go into the surrounding scope if the source string is not interpreted in strict mode — for indirect eval, they become global variables. If it's a direct eval in a strict mode context, or if the eval source string itself is in strict mode, then var and function declarations do not "leak" into the surrounding scope.
js// Neither context nor source string is strict,
// so var creates a variable in the surrounding scope
eval("var a = 1;");
console.log(a); // 1
// Context is not strict, but eval source is strict,
// so b is scoped to the evaluated script
eval("'use strict'; var b = 1;");
console.log(b); // ReferenceError: b is not defined

function strictContext() {
  "use strict";
  // Context is strict, but this is indirect and the source
  // string is not strict, so c is still global
  eval?.("var c = 1;");
  // Direct eval in a strict context, so d is scoped
  eval("var d = 1;");
}
strictContext();
console.log(c); // 1
console.log(d); // ReferenceError: d is not defined

let and const declarations within the evaluated string are always scoped to that script.


Direct eval may have access to additional contextual expressions. For example, in a function's body, one can use new.target:
jsfunction Ctor() {
  eval("console.log(new.target)");
}
new Ctor(); // [Function: Ctor]


Never use direct eval()!Using direct eval() suffers from multiple problems:

eval() executes the code it's passed with the privileges of the caller. If you run eval() with a string that could be affected by a malicious party, you may end up running malicious code on the user's machine with the permissions of your webpage / extension. More importantly, allowing third-party code to access the scope in which eval() was invoked (if it's a direct eval) can lead to possible attacks that reads or changes local variables.
eval() is slower than the alternatives, since it has to invoke the JavaScript interpreter, while many other constructs are optimized by modern JS engines.
Modern JavaScript interpreters convert JavaScript to machine code. This means that any concept of variable naming gets obliterated. Thus, any use of eval() will force the browser to do long expensive variable name lookups to figure out where the variable exists in the machine code and set its value. Additionally, new things can be introduced to that variable through eval(), such as changing the type of that variable, forcing the browser to re-evaluate all of the generated machine code to compensate.
Minifiers give up on any minification if the scope is transitively depended on by eval(), because otherwise eval() cannot read the correct variable at runtime.

There are many cases where the use of eval() or related methods can be optimized or avoided altogether.
Using indirect eval()
Consider this code:
jsfunction looseJsonParse(obj) {
  return eval(`(${obj})`);
}
console.log(looseJsonParse("{ a: 4 - 1, b: function () {}, c: new Map() }"));

Simply using indirect eval and forcing strict mode can make the code much better:
jsfunction looseJsonParse(obj) {
  return eval?.(`"use strict";(${obj})`);
}
console.log(looseJsonParse("{ a: 4 - 1, b: function () {}, c: new Map() }"));

The two code snippets above may seem to work the same way, but they do not; the first one using direct eval suffers from multiple problems.


It is a great deal slower, due to more scope inspections. Notice c: new Map() in the evaluated string. In the indirect eval version, the object is being evaluated in the global scope, so it is safe for the interpreter to assume that Map refers to the global Map() constructor instead of a local variable called Map. However, in the code using direct eval, the interpreter cannot assume this. For example, in the following code, Map in the evaluated string doesn't refer to window.Map().
jsfunction looseJsonParse(obj) {
  class Map {}
  return eval(`(${obj})`);
}
console.log(looseJsonParse(`{ a: 4 - 1, b: function () {}, c: new Map() }`));

Thus, in the eval() version of the code, the browser is forced to make the expensive lookup call to check to see if there are any local variables called Map().


If not using strict mode, var declarations within the eval() source becomes variables in the surrounding scope. This leads to hard-to-debug issues if the string is acquired from external input, especially if there's an existing variable with the same name.


Direct eval can read and mutate bindings in the surrounding scope, which may lead to external input corrupting local data.


When using direct eval, especially when the eval source cannot be proven to be in strict mode, the engine — and build tools — have to disable all optimizations related to inlining, because the eval() source can depend on any variable name in its surrounding scope.


However, using indirect eval() does not allow passing extra bindings other than existing global variables for the evaluated source to read. If you need to specify additional variables that the evaluated source should have access to, consider using the Function() constructor.
Using the Function() constructor
The Function() constructor is very similar to the indirect eval example above: it also evaluates the JavaScript source passed to it in the global scope without reading or mutating any local bindings, and therefore allows engines to do more optimizations than direct eval().
The difference between eval() and Function() is that the source string passed to Function() is parsed as a function body, not as a script. There are a few nuances — for example, you can use return statements at the top level of a function body, but not in a script.
The Function() constructor is useful if you wish to create local bindings within your eval source, by passing the variables as parameter bindings.
jsfunction add(a, b) {
  return a + b;
}
function runCodeWithAddFunction(obj) {
  return Function("add", `"use strict";return (${obj});`)(add);
}
console.log(runCodeWithAddFunction("add(5, 7)")); // 12

Both eval() and Function() implicitly evaluate arbitrary code, and are forbidden in strict CSP settings. There are also additional safer (and faster!) alternatives to eval() or Function() for common use-cases.
Using bracket accessors
You should not use eval() to access properties dynamically. Consider the following example where the property of the object to be accessed is not known until the code is executed. This can be done with eval():
jsconst obj = { a: 20, b: 30 };
const propName = getPropName(); // returns "a" or "b"

const result = eval(`obj.${propName}`);

However, eval() is not necessary here — in fact, it's more error-prone, because if propName is not a valid identifier, it leads to a syntax error. Moreover, if getPropName is not a function you control, this may lead to execution of arbitrary code. Instead, use the property accessors, which are much faster and safer:
jsconst obj = { a: 20, b: 30 };
const propName = getPropName(); // returns "a" or "b"
const result = obj[propName]; // obj["a"] is the same as obj.a

You can even use this method to access descendant properties. Using eval(), this would look like:
jsconst obj = { a: { b: { c: 0 } } };
const propPath = getPropPath(); // suppose it returns "a.b.c"

const result = eval(`obj.${propPath}`); // 0

Avoiding eval() here could be done by splitting the property path and looping through the different properties:
jsfunction getDescendantProp(obj, desc) {
  const arr = desc.split(".");
  while (arr.length) {
    obj = obj[arr.shift()];
  }
  return obj;
}

const obj = { a: { b: { c: 0 } } };
const propPath = getPropPath(); // suppose it returns "a.b.c"
const result = getDescendantProp(obj, propPath); // 0

Setting a property that way works similarly:
jsfunction setDescendantProp(obj, desc, value) {
  const arr = desc.split(".");
  while (arr.length > 1) {
    obj = obj[arr.shift()];
  }
  return (obj[arr[0]] = value);
}

const obj = { a: { b: { c: 0 } } };
const propPath = getPropPath(); // suppose it returns "a.b.c"
const result = setDescendantProp(obj, propPath, 1); // obj.a.b.c is now 1

However, beware that using bracket accessors with unconstrained input is not safe either — it may lead to object injection attacks.
Using callbacks
JavaScript has first-class functions, which means you can pass functions as arguments to other APIs, store them in variables and objects' properties, and so on. Many DOM APIs are designed with this in mind, so you can (and should) write:
js// Instead of setTimeout("…", 1000) use:
setTimeout(() => {
  // …
}, 1000);

// Instead of elt.setAttribute("onclick", "…") use:
elt.addEventListener("click", () => {
  // …
});

Closures are also helpful as a way to create parameterized functions without concatenating strings.
Using JSON
If the string you're calling eval() on contains data (for example, an array: "[1, 2, 3]"), as opposed to code, you should consider switching to JSON, which allows the string to use a subset of JavaScript syntax to represent data.
Note that since JSON syntax is limited compared to JavaScript syntax, many valid JavaScript literals will not parse as JSON. For example, trailing commas are not allowed in JSON, and property names (keys) in object literals must be enclosed in quotes. Be sure to use a JSON serializer to generate strings that will be later parsed as JSON.
Passing carefully constrained data instead of arbitrary code is a good idea in general. For example, an extension designed to scrape contents of web-pages could have the scraping rules defined in XPath instead of JavaScript code.ExamplesUsing eval()In the following code, both of the statements containing eval() return 42.
The first evaluates the string "x + y + 1"; the second evaluates the string
"42".
jsconst x = 2;
const y = 39;
const z = "42";
eval("x + y + 1"); // 42
eval(z); // 42
eval() returns the completion value of statementseval() returns the completion value of statements. For if, it would be the last expression or statement evaluated.
jsconst str = "if (a) { 1 + 1 } else { 1 + 2 }";
let a = true;
let b = eval(str);

console.log(`b is: ${b}`); // b is: 2

a = false;
b = eval(str);

console.log(`b is: ${b}`); // b is: 3

The following example uses eval() to evaluate the string str. This string consists of JavaScript statements that assign z a value of 42 if x is five, and assign 0 to z otherwise. When the second statement is executed, eval() will cause these statements to be performed, and it will also evaluate the set of statements and return the value that is assigned to z, because the completion value of an assignment is the assigned value.
jsconst x = 5;
const str = `if (x === 5) {
  console.log("z is 42");
  z = 42;
} else {
  z = 0;
}`;

console.log("z is ", eval(str)); // z is 42  z is 42

If you assign multiple values then the last value is returned.
jslet x = 5;
const str = `if (x === 5) {
  console.log("z is 42");
  z = 42;
  x = 420;
} else {
  z = 0;
}`;

console.log("x is", eval(str)); // z is 42  x is 420
eval() as a string defining function requires "(" and ")" as prefix and suffixjs// This is a function declaration
const fctStr1 = "function a() {}";
// This is a function expression
const fctStr2 = "(function b() {})";
const fct1 = eval(fctStr1); // return undefined, but `a` is available as a global function now
const fct2 = eval(fctStr2); // return the function `b`
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-eval-xBrowser compatibilitySee also
Property accessors
WebExtensions: Using eval in content scripts
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\neval()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedback
Warning:
Executing JavaScript from a string is an enormous security risk. It is far too easy for a bad actor to run arbitrary code when you use eval(). See Never use direct eval()!, below.

The eval() function evaluates JavaScript code represented as a string and returns its completion value. The source is parsed as a script.Try it
console.log(eval("2 + 2"));
// Expected output: 4

console.log(eval(new String("2 + 2")));
// Expected output: 2 + 2

console.log(eval("2 + 2") === eval("4"));
// Expected output: true

console.log(eval("2 + 2") === eval(new String("2 + 2")));
// Expected output: false
Syntaxjseval(script)
Parameters
script

A string representing a JavaScript expression, statement, or sequence of statements. The expression can include variables and properties of existing objects. It will be parsed as a script, so import declarations (which can only exist in modules) are not allowed.

Return valueThe completion value of evaluating the given code. If the completion value is empty, undefined is returned. If script is not a string primitive, eval() returns the argument unchanged.ExceptionsThrows any exception that occurs during evaluation of the code, including SyntaxError if script fails to be parsed as a script.Descriptioneval() is a function property of the global object.
The argument of the eval() function is a string. It will evaluate the source string as a script body, which means both statements and expressions are allowed. It returns the completion value of the code. For expressions, it's the value the expression evaluates to. Many statements and declarations have completion values as well, but the result may be surprising (for example, the completion value of an assignment is the assigned value, but the completion value of let is undefined), so it's recommended to not rely on statements' completion values.
In strict mode, declaring a variable named eval or re-assigning eval is a SyntaxError.
js"use strict";

const eval = 1; // SyntaxError: Unexpected eval or arguments in strict mode

If the argument of eval() is not a string, eval() returns the argument unchanged. In the following example, passing a String object instead of a primitive causes eval() to return the String object rather than evaluating the string.
jseval(new String("2 + 2")); // returns a String object containing "2 + 2"
eval("2 + 2"); // returns 4

To work around the issue in a generic fashion, you can coerce the argument to a string yourself before passing it to eval().
jsconst expression = new String("2 + 2");
eval(String(expression)); // returns 4
Direct and indirect evalThere are two modes of eval() calls: direct eval and indirect eval. Direct eval, as the name implies, refers to directly calling the global eval function with eval(...). Everything else, including invoking it via an aliased variable, via a member access or other expression, or through the optional chaining ?. operator, is indirect.
js// Direct call
eval("x + y");

// Indirect call using the comma operator to return eval
(0, eval)("x + y");

// Indirect call through optional chaining
eval?.("x + y");

// Indirect call using a variable to store and return eval
const myEval = eval;
myEval("x + y");

// Indirect call through member access
const obj = { eval };
obj.eval("x + y");

Indirect eval can be seen as if the code is evaluated within a separate <script> tag. This means:


Indirect eval works in the global scope rather than the local scope, and the code being evaluated doesn't have access to local variables within the scope where it's being called.
jsfunction test() {
  const x = 2;
  const y = 4;
  // Direct call, uses local scope
  console.log(eval("x + y")); // Result is 6
  // Indirect call, uses global scope
  console.log(eval?.("x + y")); // Throws because x is not defined in global scope
}



Indirect eval does not inherit the strictness of the surrounding context, and is only in strict mode if the source string itself has a "use strict" directive.
jsfunction nonStrictContext() {
  eval?.(`with (Math) console.log(PI);`);
}
function strictContext() {
  "use strict";
  eval?.(`with (Math) console.log(PI);`);
}
function strictContextStrictEval() {
  "use strict";
  eval?.(`"use strict"; with (Math) console.log(PI);`);
}
nonStrictContext(); // Logs 3.141592653589793
strictContext(); // Logs 3.141592653589793
strictContextStrictEval(); // Uncaught SyntaxError: Strict mode code may not include a with statement

On the other hand, direct eval inherits the strictness of the invoking context.
jsfunction nonStrictContext() {
  eval(`with (Math) console.log(PI);`);
}
function strictContext() {
  "use strict";
  eval(`with (Math) console.log(PI);`);
}
function strictContextStrictEval() {
  "use strict";
  eval(`"use strict"; with (Math) console.log(PI);`);
}
nonStrictContext(); // Logs 3.141592653589793
strictContext(); // Uncaught SyntaxError: Strict mode code may not include a with statement
strictContextStrictEval(); // Uncaught SyntaxError: Strict mode code may not include a with statement



var-declared variables and function declarations would go into the surrounding scope if the source string is not interpreted in strict mode — for indirect eval, they become global variables. If it's a direct eval in a strict mode context, or if the eval source string itself is in strict mode, then var and function declarations do not "leak" into the surrounding scope.
js// Neither context nor source string is strict,
// so var creates a variable in the surrounding scope
eval("var a = 1;");
console.log(a); // 1
// Context is not strict, but eval source is strict,
// so b is scoped to the evaluated script
eval("'use strict'; var b = 1;");
console.log(b); // ReferenceError: b is not defined

function strictContext() {
  "use strict";
  // Context is strict, but this is indirect and the source
  // string is not strict, so c is still global
  eval?.("var c = 1;");
  // Direct eval in a strict context, so d is scoped
  eval("var d = 1;");
}
strictContext();
console.log(c); // 1
console.log(d); // ReferenceError: d is not defined

let and const declarations within the evaluated string are always scoped to that script.


Direct eval may have access to additional contextual expressions. For example, in a function's body, one can use new.target:
jsfunction Ctor() {
  eval("console.log(new.target)");
}
new Ctor(); // [Function: Ctor]


Never use direct eval()!Using direct eval() suffers from multiple problems:

eval() executes the code it's passed with the privileges of the caller. If you run eval() with a string that could be affected by a malicious party, you may end up running malicious code on the user's machine with the permissions of your webpage / extension. More importantly, allowing third-party code to access the scope in which eval() was invoked (if it's a direct eval) can lead to possible attacks that reads or changes local variables.
eval() is slower than the alternatives, since it has to invoke the JavaScript interpreter, while many other constructs are optimized by modern JS engines.
Modern JavaScript interpreters convert JavaScript to machine code. This means that any concept of variable naming gets obliterated. Thus, any use of eval() will force the browser to do long expensive variable name lookups to figure out where the variable exists in the machine code and set its value. Additionally, new things can be introduced to that variable through eval(), such as changing the type of that variable, forcing the browser to re-evaluate all of the generated machine code to compensate.
Minifiers give up on any minification if the scope is transitively depended on by eval(), because otherwise eval() cannot read the correct variable at runtime.

There are many cases where the use of eval() or related methods can be optimized or avoided altogether.
Using indirect eval()
Consider this code:
jsfunction looseJsonParse(obj) {
  return eval(`(${obj})`);
}
console.log(looseJsonParse("{ a: 4 - 1, b: function () {}, c: new Map() }"));

Simply using indirect eval and forcing strict mode can make the code much better:
jsfunction looseJsonParse(obj) {
  return eval?.(`"use strict";(${obj})`);
}
console.log(looseJsonParse("{ a: 4 - 1, b: function () {}, c: new Map() }"));

The two code snippets above may seem to work the same way, but they do not; the first one using direct eval suffers from multiple problems.


It is a great deal slower, due to more scope inspections. Notice c: new Map() in the evaluated string. In the indirect eval version, the object is being evaluated in the global scope, so it is safe for the interpreter to assume that Map refers to the global Map() constructor instead of a local variable called Map. However, in the code using direct eval, the interpreter cannot assume this. For example, in the following code, Map in the evaluated string doesn't refer to window.Map().
jsfunction looseJsonParse(obj) {
  class Map {}
  return eval(`(${obj})`);
}
console.log(looseJsonParse(`{ a: 4 - 1, b: function () {}, c: new Map() }`));

Thus, in the eval() version of the code, the browser is forced to make the expensive lookup call to check to see if there are any local variables called Map().


If not using strict mode, var declarations within the eval() source becomes variables in the surrounding scope. This leads to hard-to-debug issues if the string is acquired from external input, especially if there's an existing variable with the same name.


Direct eval can read and mutate bindings in the surrounding scope, which may lead to external input corrupting local data.


When using direct eval, especially when the eval source cannot be proven to be in strict mode, the engine — and build tools — have to disable all optimizations related to inlining, because the eval() source can depend on any variable name in its surrounding scope.


However, using indirect eval() does not allow passing extra bindings other than existing global variables for the evaluated source to read. If you need to specify additional variables that the evaluated source should have access to, consider using the Function() constructor.
Using the Function() constructor
The Function() constructor is very similar to the indirect eval example above: it also evaluates the JavaScript source passed to it in the global scope without reading or mutating any local bindings, and therefore allows engines to do more optimizations than direct eval().
The difference between eval() and Function() is that the source string passed to Function() is parsed as a function body, not as a script. There are a few nuances — for example, you can use return statements at the top level of a function body, but not in a script.
The Function() constructor is useful if you wish to create local bindings within your eval source, by passing the variables as parameter bindings.
jsfunction add(a, b) {
  return a + b;
}
function runCodeWithAddFunction(obj) {
  return Function("add", `"use strict";return (${obj});`)(add);
}
console.log(runCodeWithAddFunction("add(5, 7)")); // 12

Both eval() and Function() implicitly evaluate arbitrary code, and are forbidden in strict CSP settings. There are also additional safer (and faster!) alternatives to eval() or Function() for common use-cases.
Using bracket accessors
You should not use eval() to access properties dynamically. Consider the following example where the property of the object to be accessed is not known until the code is executed. This can be done with eval():
jsconst obj = { a: 20, b: 30 };
const propName = getPropName(); // returns "a" or "b"

const result = eval(`obj.${propName}`);

However, eval() is not necessary here — in fact, it's more error-prone, because if propName is not a valid identifier, it leads to a syntax error. Moreover, if getPropName is not a function you control, this may lead to execution of arbitrary code. Instead, use the property accessors, which are much faster and safer:
jsconst obj = { a: 20, b: 30 };
const propName = getPropName(); // returns "a" or "b"
const result = obj[propName]; // obj["a"] is the same as obj.a

You can even use this method to access descendant properties. Using eval(), this would look like:
jsconst obj = { a: { b: { c: 0 } } };
const propPath = getPropPath(); // suppose it returns "a.b.c"

const result = eval(`obj.${propPath}`); // 0

Avoiding eval() here could be done by splitting the property path and looping through the different properties:
jsfunction getDescendantProp(obj, desc) {
  const arr = desc.split(".");
  while (arr.length) {
    obj = obj[arr.shift()];
  }
  return obj;
}

const obj = { a: { b: { c: 0 } } };
const propPath = getPropPath(); // suppose it returns "a.b.c"
const result = getDescendantProp(obj, propPath); // 0

Setting a property that way works similarly:
jsfunction setDescendantProp(obj, desc, value) {
  const arr = desc.split(".");
  while (arr.length > 1) {
    obj = obj[arr.shift()];
  }
  return (obj[arr[0]] = value);
}

const obj = { a: { b: { c: 0 } } };
const propPath = getPropPath(); // suppose it returns "a.b.c"
const result = setDescendantProp(obj, propPath, 1); // obj.a.b.c is now 1

However, beware that using bracket accessors with unconstrained input is not safe either — it may lead to object injection attacks.
Using callbacks
JavaScript has first-class functions, which means you can pass functions as arguments to other APIs, store them in variables and objects' properties, and so on. Many DOM APIs are designed with this in mind, so you can (and should) write:
js// Instead of setTimeout("…", 1000) use:
setTimeout(() => {
  // …
}, 1000);

// Instead of elt.setAttribute("onclick", "…") use:
elt.addEventListener("click", () => {
  // …
});

Closures are also helpful as a way to create parameterized functions without concatenating strings.
Using JSON
If the string you're calling eval() on contains data (for example, an array: "[1, 2, 3]"), as opposed to code, you should consider switching to JSON, which allows the string to use a subset of JavaScript syntax to represent data.
Note that since JSON syntax is limited compared to JavaScript syntax, many valid JavaScript literals will not parse as JSON. For example, trailing commas are not allowed in JSON, and property names (keys) in object literals must be enclosed in quotes. Be sure to use a JSON serializer to generate strings that will be later parsed as JSON.
Passing carefully constrained data instead of arbitrary code is a good idea in general. For example, an extension designed to scrape contents of web-pages could have the scraping rules defined in XPath instead of JavaScript code.ExamplesUsing eval()In the following code, both of the statements containing eval() return 42.
The first evaluates the string "x + y + 1"; the second evaluates the string
"42".
jsconst x = 2;
const y = 39;
const z = "42";
eval("x + y + 1"); // 42
eval(z); // 42
eval() returns the completion value of statementseval() returns the completion value of statements. For if, it would be the last expression or statement evaluated.
jsconst str = "if (a) { 1 + 1 } else { 1 + 2 }";
let a = true;
let b = eval(str);

console.log(`b is: ${b}`); // b is: 2

a = false;
b = eval(str);

console.log(`b is: ${b}`); // b is: 3

The following example uses eval() to evaluate the string str. This string consists of JavaScript statements that assign z a value of 42 if x is five, and assign 0 to z otherwise. When the second statement is executed, eval() will cause these statements to be performed, and it will also evaluate the set of statements and return the value that is assigned to z, because the completion value of an assignment is the assigned value.
jsconst x = 5;
const str = `if (x === 5) {
  console.log("z is 42");
  z = 42;
} else {
  z = 0;
}`;

console.log("z is ", eval(str)); // z is 42  z is 42

If you assign multiple values then the last value is returned.
jslet x = 5;
const str = `if (x === 5) {
  console.log("z is 42");
  z = 42;
  x = 420;
} else {
  z = 0;
}`;

console.log("x is", eval(str)); // z is 42  x is 420
eval() as a string defining function requires "(" and ")" as prefix and suffixjs// This is a function declaration
const fctStr1 = "function a() {}";
// This is a function expression
const fctStr2 = "(function b() {})";
const fct1 = eval(fctStr1); // return undefined, but `a` is available as a global function now
const fct2 = eval(fctStr2); // return the function `b`
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-eval-xBrowser compatibilitySee also
Property accessors
WebExtensions: Using eval in content scripts
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nEvalErrorBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe EvalError object indicates an error regarding the global eval() function. This exception is not thrown by JavaScript anymore, however the EvalError object remains for compatibility.
EvalError is a serializable object, so it can be cloned with structuredClone() or copied between Workers using postMessage().
EvalError is a subclass of Error.Constructor
EvalError()

Creates a new EvalError object.

Instance propertiesAlso inherits instance properties from its parent Error.
These properties are defined on EvalError.prototype and shared by all EvalError instances.

EvalError.prototype.constructor

The constructor function that created the instance object. For EvalError instances, the initial value is the EvalError constructor.

EvalError.prototype.name

Represents the name for the type of error. For EvalError.prototype.name, the initial value is "EvalError".

Instance methodsInherits instance methods from its parent Error.ExamplesCreating an EvalErrorjstry {
  throw new EvalError("Hello");
} catch (e) {
  console.log(e instanceof EvalError); // true
  console.log(e.message); // "Hello"
  console.log(e.name); // "EvalError"
  console.log(e.stack); // Stack of the error
}
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-native-error-types-used-in-this-standard-evalerrorBrowser compatibilitySee also
Error
eval()\n\nEvalErrorBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe EvalError object indicates an error regarding the global eval() function. This exception is not thrown by JavaScript anymore, however the EvalError object remains for compatibility.
EvalError is a serializable object, so it can be cloned with structuredClone() or copied between Workers using postMessage().
EvalError is a subclass of Error.Constructor
EvalError()

Creates a new EvalError object.

Instance propertiesAlso inherits instance properties from its parent Error.
These properties are defined on EvalError.prototype and shared by all EvalError instances.

EvalError.prototype.constructor

The constructor function that created the instance object. For EvalError instances, the initial value is the EvalError constructor.

EvalError.prototype.name

Represents the name for the type of error. For EvalError.prototype.name, the initial value is "EvalError".

Instance methodsInherits instance methods from its parent Error.ExamplesCreating an EvalErrorjstry {
  throw new EvalError("Hello");
} catch (e) {
  console.log(e instanceof EvalError); // true
  console.log(e.message); // "Hello"
  console.log(e.name); // "EvalError"
  console.log(e.stack); // Stack of the error
}
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-native-error-types-used-in-this-standard-evalerrorBrowser compatibilitySee also
Error
eval()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Sep 26, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nEvalErrorBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe EvalError object indicates an error regarding the global eval() function. This exception is not thrown by JavaScript anymore, however the EvalError object remains for compatibility.
EvalError is a serializable object, so it can be cloned with structuredClone() or copied between Workers using postMessage().
EvalError is a subclass of Error.Constructor
EvalError()

Creates a new EvalError object.

Instance propertiesAlso inherits instance properties from its parent Error.
These properties are defined on EvalError.prototype and shared by all EvalError instances.

EvalError.prototype.constructor

The constructor function that created the instance object. For EvalError instances, the initial value is the EvalError constructor.

EvalError.prototype.name

Represents the name for the type of error. For EvalError.prototype.name, the initial value is "EvalError".

Instance methodsInherits instance methods from its parent Error.ExamplesCreating an EvalErrorjstry {
  throw new EvalError("Hello");
} catch (e) {
  console.log(e instanceof EvalError); // true
  console.log(e.message); // "Hello"
  console.log(e.name); // "EvalError"
  console.log(e.stack); // Stack of the error
}
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-native-error-types-used-in-this-standard-evalerrorBrowser compatibilitySee also
Error
eval()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Sep 26, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nFinalizationRegistryBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2021.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackA FinalizationRegistry object lets you request a callback when a value is garbage-collected.DescriptionFinalizationRegistry provides a way to request that a cleanup callback get called at some point when a value registered with the registry has been reclaimed (garbage-collected). (Cleanup callbacks are sometimes called finalizers.)

Note:
Cleanup callbacks should not be used for essential program logic. See Notes on cleanup callbacks for details.

You create the registry passing in the callback:
jsconst registry = new FinalizationRegistry((heldValue) => {
  // …
});

Then you register any value you want a cleanup callback for by calling the register method, passing in the value and a held value for it:
jsregistry.register(target, "some value");

The registry does not keep a strong reference to the value, as that would defeat the purpose (if the registry held it strongly, the value would never be reclaimed). In JavaScript, objects and non-registered symbols are garbage collectable, so they can be registered in a FinalizationRegistry object as the target or the token.
If target is reclaimed, your cleanup callback may be called at some point with the held value you provided for it ("some value" in the above). The held value can be any value you like: a primitive or an object, even undefined. If the held value is an object, the registry keeps a strong reference to it (so it can pass it to your cleanup callback later).
If you might want to unregister a registered target value later, you pass a third value, which is the unregistration token you'll use later when calling the registry's unregister function to unregister the value. The registry only keeps a weak reference to the unregister token.
It's common to use the target value itself as the unregister token, which is just fine:
jsregistry.register(target, "some value", target);
// …

// some time later, if you don't care about `target` anymore, unregister it
registry.unregister(target);

It doesn't have to be the same value, though; it can be a different one:
jsregistry.register(target, "some value", token);
// …

// some time later
registry.unregister(token);
Avoid where possibleCorrect use of FinalizationRegistry takes careful thought, and it's best avoided if possible. It's also important to avoid relying on any specific behaviors not guaranteed by the specification. When, how, and whether garbage collection occurs is down to the implementation of any given JavaScript engine. Any behavior you observe in one engine may be different in another engine, in another version of the same engine, or even in a slightly different situation with the same version of the same engine. Garbage collection is a hard problem that JavaScript engine implementers are constantly refining and improving their solutions to.
Here are some specific points included by the authors in the proposal that introduced FinalizationRegistry:

Garbage collectors are complicated. If an application or library depends on GC cleaning up a WeakRef or calling a finalizer [cleanup callback] in a timely, predictable manner, it's likely to be disappointed: the cleanup may happen much later than expected, or not at all. Sources of variability include:

One object might be garbage-collected much sooner than another object, even if they become unreachable at the same time, e.g., due to generational collection.
Garbage collection work can be split up over time using incremental and concurrent techniques.
Various runtime heuristics can be used to balance memory usage, responsiveness.
The JavaScript engine may hold references to things which look like they are unreachable (e.g., in closures, or inline caches).
Different JavaScript engines may do these things differently, or the same engine may change its algorithms across versions.
Complex factors may lead to objects being held alive for unexpected amounts of time, such as use with certain APIs.

Notes on cleanup callbacks
Developers shouldn't rely on cleanup callbacks for essential program logic. Cleanup callbacks may be useful for reducing memory usage across the course of a program, but are unlikely to be useful otherwise.
If your code has just registered a value to the registry, that target will not be reclaimed until the end of the current JavaScript job. See notes on WeakRefs for details.
A conforming JavaScript implementation, even one that does garbage collection, is not required to call cleanup callbacks. When and whether it does so is entirely down to the implementation of the JavaScript engine. When a registered object is reclaimed, any cleanup callbacks for it may be called then, or some time later, or not at all.
It's likely that major implementations will call cleanup callbacks at some point during execution, but those calls may be substantially after the related object was reclaimed. Furthermore, if there is an object registered in two registries, there is no guarantee that the two callbacks are called next to each other — one may be called and the other never called, or the other may be called much later.
There are also situations where even implementations that normally call cleanup callbacks are unlikely to call them:

When the JavaScript program shuts down entirely (for instance, closing a tab in a browser).
When the FinalizationRegistry instance itself is no longer reachable by JavaScript code.


If the target of a WeakRef is also in a FinalizationRegistry, the WeakRef's target is cleared at the same time or before any cleanup callback associated with the registry is called; if your cleanup callback calls deref on a WeakRef for the object, it will receive undefined.
Constructor
FinalizationRegistry()

Creates a new FinalizationRegistry object.

Instance propertiesThese properties are defined on FinalizationRegistry.prototype and shared by all FinalizationRegistry instances.

FinalizationRegistry.prototype.constructor

The constructor function that created the instance object. For FinalizationRegistry instances, the initial value is the FinalizationRegistry constructor.

FinalizationRegistry.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "FinalizationRegistry". This property is used in Object.prototype.toString().

Instance methods
FinalizationRegistry.prototype.register()

Registers an object with the registry in order to get a cleanup callback when/if the object is garbage-collected.

FinalizationRegistry.prototype.unregister()

Unregisters an object from the registry.

ExamplesCreating a new registryYou create the registry passing in the callback:
jsconst registry = new FinalizationRegistry((heldValue) => {
  // …
});
Registering objects for cleanupThen you register any objects you want a cleanup callback for by calling the register method, passing in the object and a held value for it:
jsregistry.register(theObject, "some value");
Callbacks never called synchronouslyNo matter how much pressure you put on the garbage collector, the cleanup callback will never be called synchronously. The object may be reclaimed synchronously, but the callback will always be called sometime after the current job finishes:
jslet counter = 0;
const registry = new FinalizationRegistry(() => {
  console.log(`Array gets garbage collected at ${counter}`);
});

registry.register(["foo"]);

(function allocateMemory() {
  // Allocate 50000 functions — a lot of memory!
  Array.from({ length: 50000 }, () => () => {});
  if (counter > 5000) return;
  counter++;
  allocateMemory();
})();

console.log("Main job ends");
// Logs:
// Main job ends
// Array gets garbage collected at 5001

However, if you allow a little break between each allocation, the callback may be called sooner:
jslet arrayCollected = false;
let counter = 0;
const registry = new FinalizationRegistry(() => {
  console.log(`Array gets garbage collected at ${counter}`);
  arrayCollected = true;
});

registry.register(["foo"]);

(function allocateMemory() {
  // Allocate 50000 functions — a lot of memory!
  Array.from({ length: 50000 }, () => () => {});
  if (counter > 5000 || arrayCollected) return;
  counter++;
  // Use setTimeout to make each allocateMemory a different job
  setTimeout(allocateMemory);
})();

console.log("Main job ends");

There's no guarantee that the callback will be called sooner or if it will be called at all, but there's a possibility that the logged message has a counter value smaller than 5000.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-finalization-registry-objectsBrowser compatibilitySee also
WeakRef
WeakSet
WeakMap\n\nFinalizationRegistryBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2021.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackA FinalizationRegistry object lets you request a callback when a value is garbage-collected.DescriptionFinalizationRegistry provides a way to request that a cleanup callback get called at some point when a value registered with the registry has been reclaimed (garbage-collected). (Cleanup callbacks are sometimes called finalizers.)

Note:
Cleanup callbacks should not be used for essential program logic. See Notes on cleanup callbacks for details.

You create the registry passing in the callback:
jsconst registry = new FinalizationRegistry((heldValue) => {
  // …
});

Then you register any value you want a cleanup callback for by calling the register method, passing in the value and a held value for it:
jsregistry.register(target, "some value");

The registry does not keep a strong reference to the value, as that would defeat the purpose (if the registry held it strongly, the value would never be reclaimed). In JavaScript, objects and non-registered symbols are garbage collectable, so they can be registered in a FinalizationRegistry object as the target or the token.
If target is reclaimed, your cleanup callback may be called at some point with the held value you provided for it ("some value" in the above). The held value can be any value you like: a primitive or an object, even undefined. If the held value is an object, the registry keeps a strong reference to it (so it can pass it to your cleanup callback later).
If you might want to unregister a registered target value later, you pass a third value, which is the unregistration token you'll use later when calling the registry's unregister function to unregister the value. The registry only keeps a weak reference to the unregister token.
It's common to use the target value itself as the unregister token, which is just fine:
jsregistry.register(target, "some value", target);
// …

// some time later, if you don't care about `target` anymore, unregister it
registry.unregister(target);

It doesn't have to be the same value, though; it can be a different one:
jsregistry.register(target, "some value", token);
// …

// some time later
registry.unregister(token);
Avoid where possibleCorrect use of FinalizationRegistry takes careful thought, and it's best avoided if possible. It's also important to avoid relying on any specific behaviors not guaranteed by the specification. When, how, and whether garbage collection occurs is down to the implementation of any given JavaScript engine. Any behavior you observe in one engine may be different in another engine, in another version of the same engine, or even in a slightly different situation with the same version of the same engine. Garbage collection is a hard problem that JavaScript engine implementers are constantly refining and improving their solutions to.
Here are some specific points included by the authors in the proposal that introduced FinalizationRegistry:

Garbage collectors are complicated. If an application or library depends on GC cleaning up a WeakRef or calling a finalizer [cleanup callback] in a timely, predictable manner, it's likely to be disappointed: the cleanup may happen much later than expected, or not at all. Sources of variability include:

One object might be garbage-collected much sooner than another object, even if they become unreachable at the same time, e.g., due to generational collection.
Garbage collection work can be split up over time using incremental and concurrent techniques.
Various runtime heuristics can be used to balance memory usage, responsiveness.
The JavaScript engine may hold references to things which look like they are unreachable (e.g., in closures, or inline caches).
Different JavaScript engines may do these things differently, or the same engine may change its algorithms across versions.
Complex factors may lead to objects being held alive for unexpected amounts of time, such as use with certain APIs.

Notes on cleanup callbacks
Developers shouldn't rely on cleanup callbacks for essential program logic. Cleanup callbacks may be useful for reducing memory usage across the course of a program, but are unlikely to be useful otherwise.
If your code has just registered a value to the registry, that target will not be reclaimed until the end of the current JavaScript job. See notes on WeakRefs for details.
A conforming JavaScript implementation, even one that does garbage collection, is not required to call cleanup callbacks. When and whether it does so is entirely down to the implementation of the JavaScript engine. When a registered object is reclaimed, any cleanup callbacks for it may be called then, or some time later, or not at all.
It's likely that major implementations will call cleanup callbacks at some point during execution, but those calls may be substantially after the related object was reclaimed. Furthermore, if there is an object registered in two registries, there is no guarantee that the two callbacks are called next to each other — one may be called and the other never called, or the other may be called much later.
There are also situations where even implementations that normally call cleanup callbacks are unlikely to call them:

When the JavaScript program shuts down entirely (for instance, closing a tab in a browser).
When the FinalizationRegistry instance itself is no longer reachable by JavaScript code.


If the target of a WeakRef is also in a FinalizationRegistry, the WeakRef's target is cleared at the same time or before any cleanup callback associated with the registry is called; if your cleanup callback calls deref on a WeakRef for the object, it will receive undefined.
Constructor
FinalizationRegistry()

Creates a new FinalizationRegistry object.

Instance propertiesThese properties are defined on FinalizationRegistry.prototype and shared by all FinalizationRegistry instances.

FinalizationRegistry.prototype.constructor

The constructor function that created the instance object. For FinalizationRegistry instances, the initial value is the FinalizationRegistry constructor.

FinalizationRegistry.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "FinalizationRegistry". This property is used in Object.prototype.toString().

Instance methods
FinalizationRegistry.prototype.register()

Registers an object with the registry in order to get a cleanup callback when/if the object is garbage-collected.

FinalizationRegistry.prototype.unregister()

Unregisters an object from the registry.

ExamplesCreating a new registryYou create the registry passing in the callback:
jsconst registry = new FinalizationRegistry((heldValue) => {
  // …
});
Registering objects for cleanupThen you register any objects you want a cleanup callback for by calling the register method, passing in the object and a held value for it:
jsregistry.register(theObject, "some value");
Callbacks never called synchronouslyNo matter how much pressure you put on the garbage collector, the cleanup callback will never be called synchronously. The object may be reclaimed synchronously, but the callback will always be called sometime after the current job finishes:
jslet counter = 0;
const registry = new FinalizationRegistry(() => {
  console.log(`Array gets garbage collected at ${counter}`);
});

registry.register(["foo"]);

(function allocateMemory() {
  // Allocate 50000 functions — a lot of memory!
  Array.from({ length: 50000 }, () => () => {});
  if (counter > 5000) return;
  counter++;
  allocateMemory();
})();

console.log("Main job ends");
// Logs:
// Main job ends
// Array gets garbage collected at 5001

However, if you allow a little break between each allocation, the callback may be called sooner:
jslet arrayCollected = false;
let counter = 0;
const registry = new FinalizationRegistry(() => {
  console.log(`Array gets garbage collected at ${counter}`);
  arrayCollected = true;
});

registry.register(["foo"]);

(function allocateMemory() {
  // Allocate 50000 functions — a lot of memory!
  Array.from({ length: 50000 }, () => () => {});
  if (counter > 5000 || arrayCollected) return;
  counter++;
  // Use setTimeout to make each allocateMemory a different job
  setTimeout(allocateMemory);
})();

console.log("Main job ends");

There's no guarantee that the callback will be called sooner or if it will be called at all, but there's a possibility that the logged message has a counter value smaller than 5000.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-finalization-registry-objectsBrowser compatibilitySee also
WeakRef
WeakSet
WeakMap
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jul 25, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nFinalizationRegistryBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2021.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackA FinalizationRegistry object lets you request a callback when a value is garbage-collected.DescriptionFinalizationRegistry provides a way to request that a cleanup callback get called at some point when a value registered with the registry has been reclaimed (garbage-collected). (Cleanup callbacks are sometimes called finalizers.)

Note:
Cleanup callbacks should not be used for essential program logic. See Notes on cleanup callbacks for details.

You create the registry passing in the callback:
jsconst registry = new FinalizationRegistry((heldValue) => {
  // …
});

Then you register any value you want a cleanup callback for by calling the register method, passing in the value and a held value for it:
jsregistry.register(target, "some value");

The registry does not keep a strong reference to the value, as that would defeat the purpose (if the registry held it strongly, the value would never be reclaimed). In JavaScript, objects and non-registered symbols are garbage collectable, so they can be registered in a FinalizationRegistry object as the target or the token.
If target is reclaimed, your cleanup callback may be called at some point with the held value you provided for it ("some value" in the above). The held value can be any value you like: a primitive or an object, even undefined. If the held value is an object, the registry keeps a strong reference to it (so it can pass it to your cleanup callback later).
If you might want to unregister a registered target value later, you pass a third value, which is the unregistration token you'll use later when calling the registry's unregister function to unregister the value. The registry only keeps a weak reference to the unregister token.
It's common to use the target value itself as the unregister token, which is just fine:
jsregistry.register(target, "some value", target);
// …

// some time later, if you don't care about `target` anymore, unregister it
registry.unregister(target);

It doesn't have to be the same value, though; it can be a different one:
jsregistry.register(target, "some value", token);
// …

// some time later
registry.unregister(token);
Avoid where possibleCorrect use of FinalizationRegistry takes careful thought, and it's best avoided if possible. It's also important to avoid relying on any specific behaviors not guaranteed by the specification. When, how, and whether garbage collection occurs is down to the implementation of any given JavaScript engine. Any behavior you observe in one engine may be different in another engine, in another version of the same engine, or even in a slightly different situation with the same version of the same engine. Garbage collection is a hard problem that JavaScript engine implementers are constantly refining and improving their solutions to.
Here are some specific points included by the authors in the proposal that introduced FinalizationRegistry:

Garbage collectors are complicated. If an application or library depends on GC cleaning up a WeakRef or calling a finalizer [cleanup callback] in a timely, predictable manner, it's likely to be disappointed: the cleanup may happen much later than expected, or not at all. Sources of variability include:

One object might be garbage-collected much sooner than another object, even if they become unreachable at the same time, e.g., due to generational collection.
Garbage collection work can be split up over time using incremental and concurrent techniques.
Various runtime heuristics can be used to balance memory usage, responsiveness.
The JavaScript engine may hold references to things which look like they are unreachable (e.g., in closures, or inline caches).
Different JavaScript engines may do these things differently, or the same engine may change its algorithms across versions.
Complex factors may lead to objects being held alive for unexpected amounts of time, such as use with certain APIs.

Notes on cleanup callbacks
Developers shouldn't rely on cleanup callbacks for essential program logic. Cleanup callbacks may be useful for reducing memory usage across the course of a program, but are unlikely to be useful otherwise.
If your code has just registered a value to the registry, that target will not be reclaimed until the end of the current JavaScript job. See notes on WeakRefs for details.
A conforming JavaScript implementation, even one that does garbage collection, is not required to call cleanup callbacks. When and whether it does so is entirely down to the implementation of the JavaScript engine. When a registered object is reclaimed, any cleanup callbacks for it may be called then, or some time later, or not at all.
It's likely that major implementations will call cleanup callbacks at some point during execution, but those calls may be substantially after the related object was reclaimed. Furthermore, if there is an object registered in two registries, there is no guarantee that the two callbacks are called next to each other — one may be called and the other never called, or the other may be called much later.
There are also situations where even implementations that normally call cleanup callbacks are unlikely to call them:

When the JavaScript program shuts down entirely (for instance, closing a tab in a browser).
When the FinalizationRegistry instance itself is no longer reachable by JavaScript code.


If the target of a WeakRef is also in a FinalizationRegistry, the WeakRef's target is cleared at the same time or before any cleanup callback associated with the registry is called; if your cleanup callback calls deref on a WeakRef for the object, it will receive undefined.
Constructor
FinalizationRegistry()

Creates a new FinalizationRegistry object.

Instance propertiesThese properties are defined on FinalizationRegistry.prototype and shared by all FinalizationRegistry instances.

FinalizationRegistry.prototype.constructor

The constructor function that created the instance object. For FinalizationRegistry instances, the initial value is the FinalizationRegistry constructor.

FinalizationRegistry.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "FinalizationRegistry". This property is used in Object.prototype.toString().

Instance methods
FinalizationRegistry.prototype.register()

Registers an object with the registry in order to get a cleanup callback when/if the object is garbage-collected.

FinalizationRegistry.prototype.unregister()

Unregisters an object from the registry.

ExamplesCreating a new registryYou create the registry passing in the callback:
jsconst registry = new FinalizationRegistry((heldValue) => {
  // …
});
Registering objects for cleanupThen you register any objects you want a cleanup callback for by calling the register method, passing in the object and a held value for it:
jsregistry.register(theObject, "some value");
Callbacks never called synchronouslyNo matter how much pressure you put on the garbage collector, the cleanup callback will never be called synchronously. The object may be reclaimed synchronously, but the callback will always be called sometime after the current job finishes:
jslet counter = 0;
const registry = new FinalizationRegistry(() => {
  console.log(`Array gets garbage collected at ${counter}`);
});

registry.register(["foo"]);

(function allocateMemory() {
  // Allocate 50000 functions — a lot of memory!
  Array.from({ length: 50000 }, () => () => {});
  if (counter > 5000) return;
  counter++;
  allocateMemory();
})();

console.log("Main job ends");
// Logs:
// Main job ends
// Array gets garbage collected at 5001

However, if you allow a little break between each allocation, the callback may be called sooner:
jslet arrayCollected = false;
let counter = 0;
const registry = new FinalizationRegistry(() => {
  console.log(`Array gets garbage collected at ${counter}`);
  arrayCollected = true;
});

registry.register(["foo"]);

(function allocateMemory() {
  // Allocate 50000 functions — a lot of memory!
  Array.from({ length: 50000 }, () => () => {});
  if (counter > 5000 || arrayCollected) return;
  counter++;
  // Use setTimeout to make each allocateMemory a different job
  setTimeout(allocateMemory);
})();

console.log("Main job ends");

There's no guarantee that the callback will be called sooner or if it will be called at all, but there's a possibility that the logged message has a counter value smaller than 5000.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-finalization-registry-objectsBrowser compatibilitySee also
WeakRef
WeakSet
WeakMap
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jul 25, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nFloat16ArrayBaseline 2025Newly availableSince April 2025, this feature works across the latest devices and browser versions. This feature might not work in older devices or browsers.Learn moreSee full compatibilityReport feedbackThe Float16Array typed array represents an array of 16-bit floating point numbers in the platform byte order. If control over byte order is needed, use DataView instead. The contents are initialized to 0 unless initialization data is explicitly provided. Once established, you can reference elements in the array using the object's methods, or using standard array index syntax (that is, using bracket notation).
Float16Array is a subclass of the hidden TypedArray class.

Note:
Float16 support is not universal, both in the JavaScript API and the underlying CPU architecture. Using it may result in slower performance on some platforms. It is intended for interacting with highly optimized and performance-sensitive systems such as float-backed canvases, WebGPU, WebGL, and deep learning models including stable diffusion.
Constructor
Float16Array()

Creates a new Float16Array object.

Static propertiesAlso inherits static properties from its parent TypedArray.

Float16Array.BYTES_PER_ELEMENT

Returns a number value of the element size. 2 in the case of Float16Array.

Static methodsInherits static methods from its parent TypedArray.Instance propertiesAlso inherits instance properties from its parent TypedArray.
These properties are defined on Float16Array.prototype and shared by all Float16Array instances.

Float16Array.prototype.BYTES_PER_ELEMENT

Returns a number value of the element size. 2 in the case of a Float16Array.

Float16Array.prototype.constructor

The constructor function that created the instance object. For Float16Array instances, the initial value is the Float16Array constructor.

Instance methodsInherits instance methods from its parent TypedArray.ExamplesDifferent ways to create a Float16Arrayjs// From a length
const float16 = new Float16Array(2);
float16[0] = 42;
console.log(float16[0]); // 42
console.log(float16.length); // 2
console.log(float16.BYTES_PER_ELEMENT); // 2

// From an array
const x = new Float16Array([21, 31]);
console.log(x[1]); // 31

// From another TypedArray
const y = new Float16Array(x);
console.log(y[0]); // 21

// From an ArrayBuffer
const buffer = new ArrayBuffer(32);
const z = new Float16Array(buffer, 4, 4);
console.log(z.byteOffset); // 4

// From an iterable
const iterable = (function* () {
  yield* [1, 2, 3];
})();
const float16FromIterable = new Float16Array(iterable);
console.log(float16FromIterable);
// Float16Array [1, 2, 3]
SpecificationsSpecificationFloat16Array # sec-float16arrayBrowser compatibilitySee also
JavaScript typed arrays guide
TypedArray
ArrayBuffer
DataView\n\nFloat16ArrayBaseline 2025Newly availableSince April 2025, this feature works across the latest devices and browser versions. This feature might not work in older devices or browsers.Learn moreSee full compatibilityReport feedbackThe Float16Array typed array represents an array of 16-bit floating point numbers in the platform byte order. If control over byte order is needed, use DataView instead. The contents are initialized to 0 unless initialization data is explicitly provided. Once established, you can reference elements in the array using the object's methods, or using standard array index syntax (that is, using bracket notation).
Float16Array is a subclass of the hidden TypedArray class.

Note:
Float16 support is not universal, both in the JavaScript API and the underlying CPU architecture. Using it may result in slower performance on some platforms. It is intended for interacting with highly optimized and performance-sensitive systems such as float-backed canvases, WebGPU, WebGL, and deep learning models including stable diffusion.
Constructor
Float16Array()

Creates a new Float16Array object.

Static propertiesAlso inherits static properties from its parent TypedArray.

Float16Array.BYTES_PER_ELEMENT

Returns a number value of the element size. 2 in the case of Float16Array.

Static methodsInherits static methods from its parent TypedArray.Instance propertiesAlso inherits instance properties from its parent TypedArray.
These properties are defined on Float16Array.prototype and shared by all Float16Array instances.

Float16Array.prototype.BYTES_PER_ELEMENT

Returns a number value of the element size. 2 in the case of a Float16Array.

Float16Array.prototype.constructor

The constructor function that created the instance object. For Float16Array instances, the initial value is the Float16Array constructor.

Instance methodsInherits instance methods from its parent TypedArray.ExamplesDifferent ways to create a Float16Arrayjs// From a length
const float16 = new Float16Array(2);
float16[0] = 42;
console.log(float16[0]); // 42
console.log(float16.length); // 2
console.log(float16.BYTES_PER_ELEMENT); // 2

// From an array
const x = new Float16Array([21, 31]);
console.log(x[1]); // 31

// From another TypedArray
const y = new Float16Array(x);
console.log(y[0]); // 21

// From an ArrayBuffer
const buffer = new ArrayBuffer(32);
const z = new Float16Array(buffer, 4, 4);
console.log(z.byteOffset); // 4

// From an iterable
const iterable = (function* () {
  yield* [1, 2, 3];
})();
const float16FromIterable = new Float16Array(iterable);
console.log(float16FromIterable);
// Float16Array [1, 2, 3]
SpecificationsSpecificationFloat16Array # sec-float16arrayBrowser compatibilitySee also
JavaScript typed arrays guide
TypedArray
ArrayBuffer
DataView
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jul 25, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nFloat16ArrayBaseline 2025Newly availableSince April 2025, this feature works across the latest devices and browser versions. This feature might not work in older devices or browsers.Learn moreSee full compatibilityReport feedbackThe Float16Array typed array represents an array of 16-bit floating point numbers in the platform byte order. If control over byte order is needed, use DataView instead. The contents are initialized to 0 unless initialization data is explicitly provided. Once established, you can reference elements in the array using the object's methods, or using standard array index syntax (that is, using bracket notation).
Float16Array is a subclass of the hidden TypedArray class.

Note:
Float16 support is not universal, both in the JavaScript API and the underlying CPU architecture. Using it may result in slower performance on some platforms. It is intended for interacting with highly optimized and performance-sensitive systems such as float-backed canvases, WebGPU, WebGL, and deep learning models including stable diffusion.
Constructor
Float16Array()

Creates a new Float16Array object.

Static propertiesAlso inherits static properties from its parent TypedArray.

Float16Array.BYTES_PER_ELEMENT

Returns a number value of the element size. 2 in the case of Float16Array.

Static methodsInherits static methods from its parent TypedArray.Instance propertiesAlso inherits instance properties from its parent TypedArray.
These properties are defined on Float16Array.prototype and shared by all Float16Array instances.

Float16Array.prototype.BYTES_PER_ELEMENT

Returns a number value of the element size. 2 in the case of a Float16Array.

Float16Array.prototype.constructor

The constructor function that created the instance object. For Float16Array instances, the initial value is the Float16Array constructor.

Instance methodsInherits instance methods from its parent TypedArray.ExamplesDifferent ways to create a Float16Arrayjs// From a length
const float16 = new Float16Array(2);
float16[0] = 42;
console.log(float16[0]); // 42
console.log(float16.length); // 2
console.log(float16.BYTES_PER_ELEMENT); // 2

// From an array
const x = new Float16Array([21, 31]);
console.log(x[1]); // 31

// From another TypedArray
const y = new Float16Array(x);
console.log(y[0]); // 21

// From an ArrayBuffer
const buffer = new ArrayBuffer(32);
const z = new Float16Array(buffer, 4, 4);
console.log(z.byteOffset); // 4

// From an iterable
const iterable = (function* () {
  yield* [1, 2, 3];
})();
const float16FromIterable = new Float16Array(iterable);
console.log(float16FromIterable);
// Float16Array [1, 2, 3]
SpecificationsSpecificationFloat16Array # sec-float16arrayBrowser compatibilitySee also
JavaScript typed arrays guide
TypedArray
ArrayBuffer
DataView
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jul 25, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nFloat32ArrayBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe Float32Array typed array represents an array of 32-bit floating point numbers in the platform byte order. If control over byte order is needed, use DataView instead. The contents are initialized to 0 unless initialization data is explicitly provided. Once established, you can reference elements in the array using the object's methods, or using standard array index syntax (that is, using bracket notation).
Float32Array is a subclass of the hidden TypedArray class.Constructor
Float32Array()

Creates a new Float32Array object.

Static propertiesAlso inherits static properties from its parent TypedArray.

Float32Array.BYTES_PER_ELEMENT

Returns a number value of the element size. 4 in the case of Float32Array.

Static methodsInherits static methods from its parent TypedArray.Instance propertiesAlso inherits instance properties from its parent TypedArray.
These properties are defined on Float32Array.prototype and shared by all Float32Array instances.

Float32Array.prototype.BYTES_PER_ELEMENT

Returns a number value of the element size. 4 in the case of a Float32Array.

Float32Array.prototype.constructor

The constructor function that created the instance object. For Float32Array instances, the initial value is the Float32Array constructor.

Instance methodsInherits instance methods from its parent TypedArray.ExamplesDifferent ways to create a Float32Arrayjs// From a length
const float32 = new Float32Array(2);
float32[0] = 42;
console.log(float32[0]); // 42
console.log(float32.length); // 2
console.log(float32.BYTES_PER_ELEMENT); // 4

// From an array
const x = new Float32Array([21, 31]);
console.log(x[1]); // 31

// From another TypedArray
const y = new Float32Array(x);
console.log(y[0]); // 21

// From an ArrayBuffer
const buffer = new ArrayBuffer(32);
const z = new Float32Array(buffer, 4, 4);
console.log(z.byteOffset); // 4

// From an iterable
const iterable = (function* () {
  yield* [1, 2, 3];
})();
const float32FromIterable = new Float32Array(iterable);
console.log(float32FromIterable);
// Float32Array [1, 2, 3]
SpecificationsSpecificationECMAScript® 2026 Language Specification # table-49Browser compatibilitySee also
Polyfill of Float32Array in core-js
JavaScript typed arrays guide
TypedArray
ArrayBuffer
DataView\n\nFloat32ArrayBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe Float32Array typed array represents an array of 32-bit floating point numbers in the platform byte order. If control over byte order is needed, use DataView instead. The contents are initialized to 0 unless initialization data is explicitly provided. Once established, you can reference elements in the array using the object's methods, or using standard array index syntax (that is, using bracket notation).
Float32Array is a subclass of the hidden TypedArray class.Constructor
Float32Array()

Creates a new Float32Array object.

Static propertiesAlso inherits static properties from its parent TypedArray.

Float32Array.BYTES_PER_ELEMENT

Returns a number value of the element size. 4 in the case of Float32Array.

Static methodsInherits static methods from its parent TypedArray.Instance propertiesAlso inherits instance properties from its parent TypedArray.
These properties are defined on Float32Array.prototype and shared by all Float32Array instances.

Float32Array.prototype.BYTES_PER_ELEMENT

Returns a number value of the element size. 4 in the case of a Float32Array.

Float32Array.prototype.constructor

The constructor function that created the instance object. For Float32Array instances, the initial value is the Float32Array constructor.

Instance methodsInherits instance methods from its parent TypedArray.ExamplesDifferent ways to create a Float32Arrayjs// From a length
const float32 = new Float32Array(2);
float32[0] = 42;
console.log(float32[0]); // 42
console.log(float32.length); // 2
console.log(float32.BYTES_PER_ELEMENT); // 4

// From an array
const x = new Float32Array([21, 31]);
console.log(x[1]); // 31

// From another TypedArray
const y = new Float32Array(x);
console.log(y[0]); // 21

// From an ArrayBuffer
const buffer = new ArrayBuffer(32);
const z = new Float32Array(buffer, 4, 4);
console.log(z.byteOffset); // 4

// From an iterable
const iterable = (function* () {
  yield* [1, 2, 3];
})();
const float32FromIterable = new Float32Array(iterable);
console.log(float32FromIterable);
// Float32Array [1, 2, 3]
SpecificationsSpecificationECMAScript® 2026 Language Specification # table-49Browser compatibilitySee also
Polyfill of Float32Array in core-js
JavaScript typed arrays guide
TypedArray
ArrayBuffer
DataView
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jun 12, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nFloat32ArrayBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe Float32Array typed array represents an array of 32-bit floating point numbers in the platform byte order. If control over byte order is needed, use DataView instead. The contents are initialized to 0 unless initialization data is explicitly provided. Once established, you can reference elements in the array using the object's methods, or using standard array index syntax (that is, using bracket notation).
Float32Array is a subclass of the hidden TypedArray class.Constructor
Float32Array()

Creates a new Float32Array object.

Static propertiesAlso inherits static properties from its parent TypedArray.

Float32Array.BYTES_PER_ELEMENT

Returns a number value of the element size. 4 in the case of Float32Array.

Static methodsInherits static methods from its parent TypedArray.Instance propertiesAlso inherits instance properties from its parent TypedArray.
These properties are defined on Float32Array.prototype and shared by all Float32Array instances.

Float32Array.prototype.BYTES_PER_ELEMENT

Returns a number value of the element size. 4 in the case of a Float32Array.

Float32Array.prototype.constructor

The constructor function that created the instance object. For Float32Array instances, the initial value is the Float32Array constructor.

Instance methodsInherits instance methods from its parent TypedArray.ExamplesDifferent ways to create a Float32Arrayjs// From a length
const float32 = new Float32Array(2);
float32[0] = 42;
console.log(float32[0]); // 42
console.log(float32.length); // 2
console.log(float32.BYTES_PER_ELEMENT); // 4

// From an array
const x = new Float32Array([21, 31]);
console.log(x[1]); // 31

// From another TypedArray
const y = new Float32Array(x);
console.log(y[0]); // 21

// From an ArrayBuffer
const buffer = new ArrayBuffer(32);
const z = new Float32Array(buffer, 4, 4);
console.log(z.byteOffset); // 4

// From an iterable
const iterable = (function* () {
  yield* [1, 2, 3];
})();
const float32FromIterable = new Float32Array(iterable);
console.log(float32FromIterable);
// Float32Array [1, 2, 3]
SpecificationsSpecificationECMAScript® 2026 Language Specification # table-49Browser compatibilitySee also
Polyfill of Float32Array in core-js
JavaScript typed arrays guide
TypedArray
ArrayBuffer
DataView
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jun 12, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nFloat64ArrayBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe Float64Array typed array represents an array of 64-bit floating point numbers in the platform byte order. If control over byte order is needed, use DataView instead. The contents are initialized to 0 unless initialization data is explicitly provided. Once established, you can reference elements in the array using the object's methods, or using standard array index syntax (that is, using bracket notation).
Float64Array is a subclass of the hidden TypedArray class.Constructor
Float64Array()

Creates a new Float64Array object.

Static propertiesAlso inherits static properties from its parent TypedArray.

Float64Array.BYTES_PER_ELEMENT

Returns a number value of the element size. 8 in the case of Float64Array.

Static methodsInherits static methods from its parent TypedArray.Instance propertiesAlso inherits instance properties from its parent TypedArray.
These properties are defined on Float64Array.prototype and shared by all Float64Array instances.

Float64Array.prototype.BYTES_PER_ELEMENT

Returns a number value of the element size. 8 in the case of a Float64Array.

Float64Array.prototype.constructor

The constructor function that created the instance object. For Float64Array instances, the initial value is the Float64Array constructor.

Instance methodsInherits instance methods from its parent TypedArray.ExamplesDifferent ways to create a Float64Arrayjs// From a length
const float64 = new Float64Array(2);
float64[0] = 42;
console.log(float64[0]); // 42
console.log(float64.length); // 2
console.log(float64.BYTES_PER_ELEMENT); // 8

// From an array
const x = new Float64Array([21, 31]);
console.log(x[1]); // 31

// From another TypedArray
const y = new Float64Array(x);
console.log(y[0]); // 21

// From an ArrayBuffer
const buffer = new ArrayBuffer(64);
const z = new Float64Array(buffer, 8, 4);
console.log(z.byteOffset); // 8

// From an iterable
const iterable = (function* () {
  yield* [1, 2, 3];
})();
const float64FromIterable = new Float64Array(iterable);
console.log(float64FromIterable);
// Float64Array [1, 2, 3]
SpecificationsSpecificationECMAScript® 2026 Language Specification # table-49Browser compatibilitySee also
Polyfill of Float64Array in core-js
JavaScript typed arrays guide
TypedArray
ArrayBuffer
DataView\n\nFloat64ArrayBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe Float64Array typed array represents an array of 64-bit floating point numbers in the platform byte order. If control over byte order is needed, use DataView instead. The contents are initialized to 0 unless initialization data is explicitly provided. Once established, you can reference elements in the array using the object's methods, or using standard array index syntax (that is, using bracket notation).
Float64Array is a subclass of the hidden TypedArray class.Constructor
Float64Array()

Creates a new Float64Array object.

Static propertiesAlso inherits static properties from its parent TypedArray.

Float64Array.BYTES_PER_ELEMENT

Returns a number value of the element size. 8 in the case of Float64Array.

Static methodsInherits static methods from its parent TypedArray.Instance propertiesAlso inherits instance properties from its parent TypedArray.
These properties are defined on Float64Array.prototype and shared by all Float64Array instances.

Float64Array.prototype.BYTES_PER_ELEMENT

Returns a number value of the element size. 8 in the case of a Float64Array.

Float64Array.prototype.constructor

The constructor function that created the instance object. For Float64Array instances, the initial value is the Float64Array constructor.

Instance methodsInherits instance methods from its parent TypedArray.ExamplesDifferent ways to create a Float64Arrayjs// From a length
const float64 = new Float64Array(2);
float64[0] = 42;
console.log(float64[0]); // 42
console.log(float64.length); // 2
console.log(float64.BYTES_PER_ELEMENT); // 8

// From an array
const x = new Float64Array([21, 31]);
console.log(x[1]); // 31

// From another TypedArray
const y = new Float64Array(x);
console.log(y[0]); // 21

// From an ArrayBuffer
const buffer = new ArrayBuffer(64);
const z = new Float64Array(buffer, 8, 4);
console.log(z.byteOffset); // 8

// From an iterable
const iterable = (function* () {
  yield* [1, 2, 3];
})();
const float64FromIterable = new Float64Array(iterable);
console.log(float64FromIterable);
// Float64Array [1, 2, 3]
SpecificationsSpecificationECMAScript® 2026 Language Specification # table-49Browser compatibilitySee also
Polyfill of Float64Array in core-js
JavaScript typed arrays guide
TypedArray
ArrayBuffer
DataView
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jun 12, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nFloat64ArrayBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe Float64Array typed array represents an array of 64-bit floating point numbers in the platform byte order. If control over byte order is needed, use DataView instead. The contents are initialized to 0 unless initialization data is explicitly provided. Once established, you can reference elements in the array using the object's methods, or using standard array index syntax (that is, using bracket notation).
Float64Array is a subclass of the hidden TypedArray class.Constructor
Float64Array()

Creates a new Float64Array object.

Static propertiesAlso inherits static properties from its parent TypedArray.

Float64Array.BYTES_PER_ELEMENT

Returns a number value of the element size. 8 in the case of Float64Array.

Static methodsInherits static methods from its parent TypedArray.Instance propertiesAlso inherits instance properties from its parent TypedArray.
These properties are defined on Float64Array.prototype and shared by all Float64Array instances.

Float64Array.prototype.BYTES_PER_ELEMENT

Returns a number value of the element size. 8 in the case of a Float64Array.

Float64Array.prototype.constructor

The constructor function that created the instance object. For Float64Array instances, the initial value is the Float64Array constructor.

Instance methodsInherits instance methods from its parent TypedArray.ExamplesDifferent ways to create a Float64Arrayjs// From a length
const float64 = new Float64Array(2);
float64[0] = 42;
console.log(float64[0]); // 42
console.log(float64.length); // 2
console.log(float64.BYTES_PER_ELEMENT); // 8

// From an array
const x = new Float64Array([21, 31]);
console.log(x[1]); // 31

// From another TypedArray
const y = new Float64Array(x);
console.log(y[0]); // 21

// From an ArrayBuffer
const buffer = new ArrayBuffer(64);
const z = new Float64Array(buffer, 8, 4);
console.log(z.byteOffset); // 8

// From an iterable
const iterable = (function* () {
  yield* [1, 2, 3];
})();
const float64FromIterable = new Float64Array(iterable);
console.log(float64FromIterable);
// Float64Array [1, 2, 3]
SpecificationsSpecificationECMAScript® 2026 Language Specification # table-49Browser compatibilitySee also
Polyfill of Float64Array in core-js
JavaScript typed arrays guide
TypedArray
ArrayBuffer
DataView
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jun 12, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nFunctionBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Function object provides methods for functions. In JavaScript, every function is actually a Function object.Constructor
Function()

Creates a new Function object. Calling the constructor directly can create functions dynamically but suffers from security and similar (but far less significant) performance issues to eval(). However, unlike eval(), the Function constructor creates functions that execute in the global scope only.

Instance propertiesThese properties are defined on Function.prototype and shared by all Function instances.

Function.prototype.arguments 
Deprecated
 
Non-standard


Represents the arguments passed to this function. For strict, arrow, async, and generator functions, accessing the arguments property throws a TypeError. Use the arguments object inside function closures instead.

Function.prototype.caller 
Deprecated
 
Non-standard


Represents the function that invoked this function. For strict, arrow, async, and generator functions, accessing the caller property throws a TypeError.

Function.prototype.constructor

The constructor function that created the instance object. For Function instances, the initial value is the Function constructor.


These properties are own properties of each Function instance.

displayName 
Non-standard
 Optional

The display name of the function.

length

Specifies the number of arguments expected by the function.

name

The name of the function.

prototype

Used when the function is used as a constructor with the new operator. It will become the new object's prototype.

Instance methods
Function.prototype.apply()

Calls a function with a given this value and optional arguments provided as an array (or an array-like object).

Function.prototype.bind()

Creates a new function that, when called, has its this keyword set to a provided value, optionally with a given sequence of arguments preceding any provided when the new function is called.

Function.prototype.call()

Calls a function with a given this value and optional arguments.

Function.prototype.toString()

Returns a string representing the source code of the function.
Overrides the Object.prototype.toString method.

Function.prototype[Symbol.hasInstance]()

Specifies the default procedure for determining if a constructor function recognizes an object as one of the constructor's instances. Called by the instanceof operator.

ExamplesDifference between Function constructor and function declarationFunctions created with the Function constructor do not create closures to their creation contexts; they always are created in the global scope. When running them, they will only be able to access their own local variables and global ones, not the ones from the scope in which the Function constructor was created. This is different from using eval() with code for a function expression.
js// Create a global property with `var`
var x = 10;

function createFunction1() {
  const x = 20;
  return new Function("return x;"); // this `x` refers to global `x`
}

function createFunction2() {
  const x = 20;
  function f() {
    return x; // this `x` refers to the local `x` above
  }
  return f;
}

const f1 = createFunction1();
console.log(f1()); // 10
const f2 = createFunction2();
console.log(f2()); // 20

While this code works in web browsers, f1() will produce a ReferenceError in Node.js, as x will not be found. This is because the top-level scope in Node is not the global scope, and x will be local to the module.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-function-objectsBrowser compatibilitySee also
function
function expression
AsyncFunction
AsyncGeneratorFunction
GeneratorFunction
Functions\n\nFunctionBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Function object provides methods for functions. In JavaScript, every function is actually a Function object.Constructor
Function()

Creates a new Function object. Calling the constructor directly can create functions dynamically but suffers from security and similar (but far less significant) performance issues to eval(). However, unlike eval(), the Function constructor creates functions that execute in the global scope only.

Instance propertiesThese properties are defined on Function.prototype and shared by all Function instances.

Function.prototype.arguments 
Deprecated
 
Non-standard


Represents the arguments passed to this function. For strict, arrow, async, and generator functions, accessing the arguments property throws a TypeError. Use the arguments object inside function closures instead.

Function.prototype.caller 
Deprecated
 
Non-standard


Represents the function that invoked this function. For strict, arrow, async, and generator functions, accessing the caller property throws a TypeError.

Function.prototype.constructor

The constructor function that created the instance object. For Function instances, the initial value is the Function constructor.


These properties are own properties of each Function instance.

displayName 
Non-standard
 Optional

The display name of the function.

length

Specifies the number of arguments expected by the function.

name

The name of the function.

prototype

Used when the function is used as a constructor with the new operator. It will become the new object's prototype.

Instance methods
Function.prototype.apply()

Calls a function with a given this value and optional arguments provided as an array (or an array-like object).

Function.prototype.bind()

Creates a new function that, when called, has its this keyword set to a provided value, optionally with a given sequence of arguments preceding any provided when the new function is called.

Function.prototype.call()

Calls a function with a given this value and optional arguments.

Function.prototype.toString()

Returns a string representing the source code of the function.
Overrides the Object.prototype.toString method.

Function.prototype[Symbol.hasInstance]()

Specifies the default procedure for determining if a constructor function recognizes an object as one of the constructor's instances. Called by the instanceof operator.

ExamplesDifference between Function constructor and function declarationFunctions created with the Function constructor do not create closures to their creation contexts; they always are created in the global scope. When running them, they will only be able to access their own local variables and global ones, not the ones from the scope in which the Function constructor was created. This is different from using eval() with code for a function expression.
js// Create a global property with `var`
var x = 10;

function createFunction1() {
  const x = 20;
  return new Function("return x;"); // this `x` refers to global `x`
}

function createFunction2() {
  const x = 20;
  function f() {
    return x; // this `x` refers to the local `x` above
  }
  return f;
}

const f1 = createFunction1();
console.log(f1()); // 10
const f2 = createFunction2();
console.log(f2()); // 20

While this code works in web browsers, f1() will produce a ReferenceError in Node.js, as x will not be found. This is because the top-level scope in Node is not the global scope, and x will be local to the module.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-function-objectsBrowser compatibilitySee also
function
function expression
AsyncFunction
AsyncGeneratorFunction
GeneratorFunction
Functions
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jul 15, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nFunctionBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Function object provides methods for functions. In JavaScript, every function is actually a Function object.Constructor
Function()

Creates a new Function object. Calling the constructor directly can create functions dynamically but suffers from security and similar (but far less significant) performance issues to eval(). However, unlike eval(), the Function constructor creates functions that execute in the global scope only.

Instance propertiesThese properties are defined on Function.prototype and shared by all Function instances.

Function.prototype.arguments 
Deprecated
 
Non-standard


Represents the arguments passed to this function. For strict, arrow, async, and generator functions, accessing the arguments property throws a TypeError. Use the arguments object inside function closures instead.

Function.prototype.caller 
Deprecated
 
Non-standard


Represents the function that invoked this function. For strict, arrow, async, and generator functions, accessing the caller property throws a TypeError.

Function.prototype.constructor

The constructor function that created the instance object. For Function instances, the initial value is the Function constructor.


These properties are own properties of each Function instance.

displayName 
Non-standard
 Optional

The display name of the function.

length

Specifies the number of arguments expected by the function.

name

The name of the function.

prototype

Used when the function is used as a constructor with the new operator. It will become the new object's prototype.

Instance methods
Function.prototype.apply()

Calls a function with a given this value and optional arguments provided as an array (or an array-like object).

Function.prototype.bind()

Creates a new function that, when called, has its this keyword set to a provided value, optionally with a given sequence of arguments preceding any provided when the new function is called.

Function.prototype.call()

Calls a function with a given this value and optional arguments.

Function.prototype.toString()

Returns a string representing the source code of the function.
Overrides the Object.prototype.toString method.

Function.prototype[Symbol.hasInstance]()

Specifies the default procedure for determining if a constructor function recognizes an object as one of the constructor's instances. Called by the instanceof operator.

ExamplesDifference between Function constructor and function declarationFunctions created with the Function constructor do not create closures to their creation contexts; they always are created in the global scope. When running them, they will only be able to access their own local variables and global ones, not the ones from the scope in which the Function constructor was created. This is different from using eval() with code for a function expression.
js// Create a global property with `var`
var x = 10;

function createFunction1() {
  const x = 20;
  return new Function("return x;"); // this `x` refers to global `x`
}

function createFunction2() {
  const x = 20;
  function f() {
    return x; // this `x` refers to the local `x` above
  }
  return f;
}

const f1 = createFunction1();
console.log(f1()); // 10
const f2 = createFunction2();
console.log(f2()); // 20

While this code works in web browsers, f1() will produce a ReferenceError in Node.js, as x will not be found. This is because the top-level scope in Node is not the global scope, and x will be local to the module.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-function-objectsBrowser compatibilitySee also
function
function expression
AsyncFunction
AsyncGeneratorFunction
GeneratorFunction
Functions
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jul 15, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nGeneratorBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2016.Learn moreSee full compatibilityReport feedbackThe Generator object is returned by a generator function and it conforms to both the iterable protocol and the iterator protocol.
Generator is a subclass of the hidden Iterator class.ConstructorThere's no JavaScript entity that corresponds to the Generator constructor. Instances of Generator must be returned from generator functions:
jsfunction* generator() {
  yield 1;
  yield 2;
  yield 3;
}

const gen = generator(); // "Generator { }"

console.log(gen.next().value); // 1
console.log(gen.next().value); // 2
console.log(gen.next().value); // 3

There's only a hidden object which is the prototype object shared by all objects created by generator functions. This object is often stylized as Generator.prototype to make it look like a class, but it should be more appropriately called GeneratorFunction.prototype.prototype, because GeneratorFunction is an actual JavaScript entity. To understand the prototype chain of Generator instances, see GeneratorFunction.prototype.prototype.Instance propertiesThese properties are defined on Generator.prototype and shared by all Generator instances.

Generator.prototype.constructor

The constructor function that created the instance object. For Generator instances, the initial value is GeneratorFunction.prototype.

Note: Generator objects do not store a reference to the generator function that created them.


Generator.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Generator". This property is used in Object.prototype.toString().

Instance methodsAlso inherits instance methods from its parent Iterator.

Generator.prototype.next()

Returns a value yielded by the yield expression.

Generator.prototype.return()

Acts as if a return statement is inserted in the generator's body at the current suspended position, which finishes the generator and allows the generator to perform any cleanup tasks when combined with a try...finally block.

Generator.prototype.throw()

Acts as if a throw statement is inserted in the generator's body at the current suspended position, which informs the generator of an error condition and allows it to handle the error, or perform cleanup and close itself.

ExamplesAn infinite iteratorWith a generator function, values are not evaluated until they are needed. Therefore a generator allows us to define a potentially infinite data structure.
jsfunction* infinite() {
  let index = 0;

  while (true) {
    yield index++;
  }
}

const generator = infinite(); // "Generator { }"

console.log(generator.next().value); // 0
console.log(generator.next().value); // 1
console.log(generator.next().value); // 2
// …
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-generator-objectsBrowser compatibilitySee also
function*
function* expression
GeneratorFunction
Iteration protocols\n\nGeneratorBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2016.Learn moreSee full compatibilityReport feedbackThe Generator object is returned by a generator function and it conforms to both the iterable protocol and the iterator protocol.
Generator is a subclass of the hidden Iterator class.ConstructorThere's no JavaScript entity that corresponds to the Generator constructor. Instances of Generator must be returned from generator functions:
jsfunction* generator() {
  yield 1;
  yield 2;
  yield 3;
}

const gen = generator(); // "Generator { }"

console.log(gen.next().value); // 1
console.log(gen.next().value); // 2
console.log(gen.next().value); // 3

There's only a hidden object which is the prototype object shared by all objects created by generator functions. This object is often stylized as Generator.prototype to make it look like a class, but it should be more appropriately called GeneratorFunction.prototype.prototype, because GeneratorFunction is an actual JavaScript entity. To understand the prototype chain of Generator instances, see GeneratorFunction.prototype.prototype.Instance propertiesThese properties are defined on Generator.prototype and shared by all Generator instances.

Generator.prototype.constructor

The constructor function that created the instance object. For Generator instances, the initial value is GeneratorFunction.prototype.

Note: Generator objects do not store a reference to the generator function that created them.


Generator.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Generator". This property is used in Object.prototype.toString().

Instance methodsAlso inherits instance methods from its parent Iterator.

Generator.prototype.next()

Returns a value yielded by the yield expression.

Generator.prototype.return()

Acts as if a return statement is inserted in the generator's body at the current suspended position, which finishes the generator and allows the generator to perform any cleanup tasks when combined with a try...finally block.

Generator.prototype.throw()

Acts as if a throw statement is inserted in the generator's body at the current suspended position, which informs the generator of an error condition and allows it to handle the error, or perform cleanup and close itself.

ExamplesAn infinite iteratorWith a generator function, values are not evaluated until they are needed. Therefore a generator allows us to define a potentially infinite data structure.
jsfunction* infinite() {
  let index = 0;

  while (true) {
    yield index++;
  }
}

const generator = infinite(); // "Generator { }"

console.log(generator.next().value); // 0
console.log(generator.next().value); // 1
console.log(generator.next().value); // 2
// …
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-generator-objectsBrowser compatibilitySee also
function*
function* expression
GeneratorFunction
Iteration protocols
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nGeneratorBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2016.Learn moreSee full compatibilityReport feedbackThe Generator object is returned by a generator function and it conforms to both the iterable protocol and the iterator protocol.
Generator is a subclass of the hidden Iterator class.ConstructorThere's no JavaScript entity that corresponds to the Generator constructor. Instances of Generator must be returned from generator functions:
jsfunction* generator() {
  yield 1;
  yield 2;
  yield 3;
}

const gen = generator(); // "Generator { }"

console.log(gen.next().value); // 1
console.log(gen.next().value); // 2
console.log(gen.next().value); // 3

There's only a hidden object which is the prototype object shared by all objects created by generator functions. This object is often stylized as Generator.prototype to make it look like a class, but it should be more appropriately called GeneratorFunction.prototype.prototype, because GeneratorFunction is an actual JavaScript entity. To understand the prototype chain of Generator instances, see GeneratorFunction.prototype.prototype.Instance propertiesThese properties are defined on Generator.prototype and shared by all Generator instances.

Generator.prototype.constructor

The constructor function that created the instance object. For Generator instances, the initial value is GeneratorFunction.prototype.

Note: Generator objects do not store a reference to the generator function that created them.


Generator.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Generator". This property is used in Object.prototype.toString().

Instance methodsAlso inherits instance methods from its parent Iterator.

Generator.prototype.next()

Returns a value yielded by the yield expression.

Generator.prototype.return()

Acts as if a return statement is inserted in the generator's body at the current suspended position, which finishes the generator and allows the generator to perform any cleanup tasks when combined with a try...finally block.

Generator.prototype.throw()

Acts as if a throw statement is inserted in the generator's body at the current suspended position, which informs the generator of an error condition and allows it to handle the error, or perform cleanup and close itself.

ExamplesAn infinite iteratorWith a generator function, values are not evaluated until they are needed. Therefore a generator allows us to define a potentially infinite data structure.
jsfunction* infinite() {
  let index = 0;

  while (true) {
    yield index++;
  }
}

const generator = infinite(); // "Generator { }"

console.log(generator.next().value); // 0
console.log(generator.next().value); // 1
console.log(generator.next().value); // 2
// …
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-generator-objectsBrowser compatibilitySee also
function*
function* expression
GeneratorFunction
Iteration protocols
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nGeneratorFunctionBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2016.Learn moreSee full compatibilityReport feedbackThe GeneratorFunction object provides methods for generator functions. In JavaScript, every generator function is actually a GeneratorFunction object.
Note that GeneratorFunction is not a global object. It can be obtained with the following code:
jsconst GeneratorFunction = function* () {}.constructor;

GeneratorFunction is a subclass of Function.Try it
const GeneratorFunction = function* () {}.constructor;

const foo = new GeneratorFunction(`
  yield 'a';
  yield 'b';
  yield 'c';
`);

let str = "";
for (const val of foo()) {
  str = str + val;
}

console.log(str);
// Expected output: "abc"
Constructor
GeneratorFunction()

Creates a new GeneratorFunction object.

Instance propertiesAlso inherits instance properties from its parent Function.
These properties are defined on GeneratorFunction.prototype and shared by all GeneratorFunction instances.

GeneratorFunction.prototype.constructor

The constructor function that created the instance object. For GeneratorFunction instances, the initial value is the GeneratorFunction constructor.

GeneratorFunction.prototype.prototype

All generator functions share the same prototype property, which is Generator.prototype. Each generator function created with the function* syntax or the GeneratorFunction() constructor also has its own prototype property, whose prototype is GeneratorFunction.prototype.prototype. When the generator function is called, its prototype property becomes the prototype of the returned generator object.

GeneratorFunction.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "GeneratorFunction". This property is used in Object.prototype.toString().


These properties are own properties of each GeneratorFunction instance.

prototype

Used when the function is used as a constructor with the new operator. It will become the new object's prototype.

Instance methodsInherits instance methods from its parent Function.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-generatorfunction-objectsBrowser compatibilitySee also
function*
function* expression
Function
AsyncFunction
AsyncGeneratorFunction
Functions\n\nGeneratorFunctionBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2016.Learn moreSee full compatibilityReport feedbackThe GeneratorFunction object provides methods for generator functions. In JavaScript, every generator function is actually a GeneratorFunction object.
Note that GeneratorFunction is not a global object. It can be obtained with the following code:
jsconst GeneratorFunction = function* () {}.constructor;

GeneratorFunction is a subclass of Function.Try it
const GeneratorFunction = function* () {}.constructor;

const foo = new GeneratorFunction(`
  yield 'a';
  yield 'b';
  yield 'c';
`);

let str = "";
for (const val of foo()) {
  str = str + val;
}

console.log(str);
// Expected output: "abc"
Constructor
GeneratorFunction()

Creates a new GeneratorFunction object.

Instance propertiesAlso inherits instance properties from its parent Function.
These properties are defined on GeneratorFunction.prototype and shared by all GeneratorFunction instances.

GeneratorFunction.prototype.constructor

The constructor function that created the instance object. For GeneratorFunction instances, the initial value is the GeneratorFunction constructor.

GeneratorFunction.prototype.prototype

All generator functions share the same prototype property, which is Generator.prototype. Each generator function created with the function* syntax or the GeneratorFunction() constructor also has its own prototype property, whose prototype is GeneratorFunction.prototype.prototype. When the generator function is called, its prototype property becomes the prototype of the returned generator object.

GeneratorFunction.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "GeneratorFunction". This property is used in Object.prototype.toString().


These properties are own properties of each GeneratorFunction instance.

prototype

Used when the function is used as a constructor with the new operator. It will become the new object's prototype.

Instance methodsInherits instance methods from its parent Function.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-generatorfunction-objectsBrowser compatibilitySee also
function*
function* expression
Function
AsyncFunction
AsyncGeneratorFunction
Functions
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nGeneratorFunctionBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2016.Learn moreSee full compatibilityReport feedbackThe GeneratorFunction object provides methods for generator functions. In JavaScript, every generator function is actually a GeneratorFunction object.
Note that GeneratorFunction is not a global object. It can be obtained with the following code:
jsconst GeneratorFunction = function* () {}.constructor;

GeneratorFunction is a subclass of Function.Try it
const GeneratorFunction = function* () {}.constructor;

const foo = new GeneratorFunction(`
  yield 'a';
  yield 'b';
  yield 'c';
`);

let str = "";
for (const val of foo()) {
  str = str + val;
}

console.log(str);
// Expected output: "abc"
Constructor
GeneratorFunction()

Creates a new GeneratorFunction object.

Instance propertiesAlso inherits instance properties from its parent Function.
These properties are defined on GeneratorFunction.prototype and shared by all GeneratorFunction instances.

GeneratorFunction.prototype.constructor

The constructor function that created the instance object. For GeneratorFunction instances, the initial value is the GeneratorFunction constructor.

GeneratorFunction.prototype.prototype

All generator functions share the same prototype property, which is Generator.prototype. Each generator function created with the function* syntax or the GeneratorFunction() constructor also has its own prototype property, whose prototype is GeneratorFunction.prototype.prototype. When the generator function is called, its prototype property becomes the prototype of the returned generator object.

GeneratorFunction.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "GeneratorFunction". This property is used in Object.prototype.toString().


These properties are own properties of each GeneratorFunction instance.

prototype

Used when the function is used as a constructor with the new operator. It will become the new object's prototype.

Instance methodsInherits instance methods from its parent Function.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-generatorfunction-objectsBrowser compatibilitySee also
function*
function* expression
Function
AsyncFunction
AsyncGeneratorFunction
Functions
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nglobalThisBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackThe globalThis global property contains the global this value, which is usually akin to the global object.Try it
function canMakeHTTPRequest() {
  return typeof globalThis.XMLHttpRequest === "function";
}

console.log(canMakeHTTPRequest());
// Expected output (in a browser): true
ValueThe global this object.
Property attributes of globalThisWritableyesEnumerablenoConfigurableyes

Note:
The globalThis property is configurable and writable so that code authors can hide it when executing untrusted code and prevent exposing the global object.
DescriptionHistorically, accessing the global object has required different syntax in different JavaScript environments. On the web you can use window, self, or frames - but in Web Workers only self will work. In Node.js none of these work, and you must instead use global. The this keyword could be used inside functions running in non–strict mode, but this will be undefined in modules and inside functions running in strict mode. You can also use Function('return this')(), but environments that disable eval(), like CSP in browsers, prevent use of Function in this way.
The globalThis property provides a standard way of accessing the global this value (and hence the global object itself) across environments. Unlike similar properties such as window and self, it's guaranteed to work in window and non-window contexts. In this way, you can access the global object in a consistent manner without having to know which environment the code is being run in. To help you remember the name, just remember that in global scope the this value is globalThis.

Note: globalThis is generally the same concept as the global object (i.e., adding properties to globalThis makes them global variables) — this is the case for browsers and Node — but hosts are allowed to provide a different value for globalThis that's unrelated to the global object.
HTML and the WindowProxyIn many engines globalThis will be a reference to the actual global object, but in web browsers, due to iframe and cross-window security considerations, it references a Proxy around the actual global object (which you can't directly access). This distinction is rarely relevant in common usage, but important to be aware of.NamingSeveral other popular name choices such as self and global were removed from consideration because of their potential to break compatibility with existing code. See the language proposal's "naming" document for more details.
globalThis is, quite literally, the global this value. It's the same value as the this value in a non-strict function called without an object. It's also the value of this in the global scope of a script.ExamplesSearch for the global across environmentsUsually, the global object does not need to be explicitly specified — its properties are automatically accessible as global variables.
jsconsole.log(window.Math === Math); // true

However, one case where one needs to explicitly access the global object is when writing to it, usually for the purpose of polyfills.
Prior to globalThis, the only reliable cross-platform way to get the global object for an environment was Function('return this')(). However, this causes CSP violations in some settings, so authors would use a piecewise definition like this (slightly adapted from the original core-js source):
jsfunction check(it) {
  // Math is known to exist as a global in every environment.
  return it && it.Math === Math && it;
}

const globalObject =
  check(typeof window === "object" && window) ||
  check(typeof self === "object" && self) ||
  check(typeof global === "object" && global) ||
  // This returns undefined when running in strict mode
  (function () {
    return this;
  })() ||
  Function("return this")();

After obtaining the global object, we can define new globals on it. For example, adding an implementation for Intl:
jsif (typeof globalObject.Intl === "undefined") {
  // No Intl in this environment; define our own on the global scope
  Object.defineProperty(globalObject, "Intl", {
    value: {
      // Our Intl implementation
    },
    enumerable: false,
    configurable: true,
    writable: true,
  });
}

With globalThis available, the additional search for the global across environments is not necessary anymore:
jsif (typeof globalThis.Intl === "undefined") {
  Object.defineProperty(globalThis, "Intl", {
    value: {
      // Our Intl implementation
    },
    enumerable: false,
    configurable: true,
    writable: true,
  });
}
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-globalthisBrowser compatibilitySee also
Polyfill of globalThis in core-js
es-shims polyfill of globalThis
this\n\nglobalThisBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackThe globalThis global property contains the global this value, which is usually akin to the global object.Try it
function canMakeHTTPRequest() {
  return typeof globalThis.XMLHttpRequest === "function";
}

console.log(canMakeHTTPRequest());
// Expected output (in a browser): true
ValueThe global this object.
Property attributes of globalThisWritableyesEnumerablenoConfigurableyes

Note:
The globalThis property is configurable and writable so that code authors can hide it when executing untrusted code and prevent exposing the global object.
DescriptionHistorically, accessing the global object has required different syntax in different JavaScript environments. On the web you can use window, self, or frames - but in Web Workers only self will work. In Node.js none of these work, and you must instead use global. The this keyword could be used inside functions running in non–strict mode, but this will be undefined in modules and inside functions running in strict mode. You can also use Function('return this')(), but environments that disable eval(), like CSP in browsers, prevent use of Function in this way.
The globalThis property provides a standard way of accessing the global this value (and hence the global object itself) across environments. Unlike similar properties such as window and self, it's guaranteed to work in window and non-window contexts. In this way, you can access the global object in a consistent manner without having to know which environment the code is being run in. To help you remember the name, just remember that in global scope the this value is globalThis.

Note: globalThis is generally the same concept as the global object (i.e., adding properties to globalThis makes them global variables) — this is the case for browsers and Node — but hosts are allowed to provide a different value for globalThis that's unrelated to the global object.
HTML and the WindowProxyIn many engines globalThis will be a reference to the actual global object, but in web browsers, due to iframe and cross-window security considerations, it references a Proxy around the actual global object (which you can't directly access). This distinction is rarely relevant in common usage, but important to be aware of.NamingSeveral other popular name choices such as self and global were removed from consideration because of their potential to break compatibility with existing code. See the language proposal's "naming" document for more details.
globalThis is, quite literally, the global this value. It's the same value as the this value in a non-strict function called without an object. It's also the value of this in the global scope of a script.ExamplesSearch for the global across environmentsUsually, the global object does not need to be explicitly specified — its properties are automatically accessible as global variables.
jsconsole.log(window.Math === Math); // true

However, one case where one needs to explicitly access the global object is when writing to it, usually for the purpose of polyfills.
Prior to globalThis, the only reliable cross-platform way to get the global object for an environment was Function('return this')(). However, this causes CSP violations in some settings, so authors would use a piecewise definition like this (slightly adapted from the original core-js source):
jsfunction check(it) {
  // Math is known to exist as a global in every environment.
  return it && it.Math === Math && it;
}

const globalObject =
  check(typeof window === "object" && window) ||
  check(typeof self === "object" && self) ||
  check(typeof global === "object" && global) ||
  // This returns undefined when running in strict mode
  (function () {
    return this;
  })() ||
  Function("return this")();

After obtaining the global object, we can define new globals on it. For example, adding an implementation for Intl:
jsif (typeof globalObject.Intl === "undefined") {
  // No Intl in this environment; define our own on the global scope
  Object.defineProperty(globalObject, "Intl", {
    value: {
      // Our Intl implementation
    },
    enumerable: false,
    configurable: true,
    writable: true,
  });
}

With globalThis available, the additional search for the global across environments is not necessary anymore:
jsif (typeof globalThis.Intl === "undefined") {
  Object.defineProperty(globalThis, "Intl", {
    value: {
      // Our Intl implementation
    },
    enumerable: false,
    configurable: true,
    writable: true,
  });
}
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-globalthisBrowser compatibilitySee also
Polyfill of globalThis in core-js
es-shims polyfill of globalThis
this
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nglobalThisBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020.Learn moreSee full compatibilityReport feedbackThe globalThis global property contains the global this value, which is usually akin to the global object.Try it
function canMakeHTTPRequest() {
  return typeof globalThis.XMLHttpRequest === "function";
}

console.log(canMakeHTTPRequest());
// Expected output (in a browser): true
ValueThe global this object.
Property attributes of globalThisWritableyesEnumerablenoConfigurableyes

Note:
The globalThis property is configurable and writable so that code authors can hide it when executing untrusted code and prevent exposing the global object.
DescriptionHistorically, accessing the global object has required different syntax in different JavaScript environments. On the web you can use window, self, or frames - but in Web Workers only self will work. In Node.js none of these work, and you must instead use global. The this keyword could be used inside functions running in non–strict mode, but this will be undefined in modules and inside functions running in strict mode. You can also use Function('return this')(), but environments that disable eval(), like CSP in browsers, prevent use of Function in this way.
The globalThis property provides a standard way of accessing the global this value (and hence the global object itself) across environments. Unlike similar properties such as window and self, it's guaranteed to work in window and non-window contexts. In this way, you can access the global object in a consistent manner without having to know which environment the code is being run in. To help you remember the name, just remember that in global scope the this value is globalThis.

Note: globalThis is generally the same concept as the global object (i.e., adding properties to globalThis makes them global variables) — this is the case for browsers and Node — but hosts are allowed to provide a different value for globalThis that's unrelated to the global object.
HTML and the WindowProxyIn many engines globalThis will be a reference to the actual global object, but in web browsers, due to iframe and cross-window security considerations, it references a Proxy around the actual global object (which you can't directly access). This distinction is rarely relevant in common usage, but important to be aware of.NamingSeveral other popular name choices such as self and global were removed from consideration because of their potential to break compatibility with existing code. See the language proposal's "naming" document for more details.
globalThis is, quite literally, the global this value. It's the same value as the this value in a non-strict function called without an object. It's also the value of this in the global scope of a script.ExamplesSearch for the global across environmentsUsually, the global object does not need to be explicitly specified — its properties are automatically accessible as global variables.
jsconsole.log(window.Math === Math); // true

However, one case where one needs to explicitly access the global object is when writing to it, usually for the purpose of polyfills.
Prior to globalThis, the only reliable cross-platform way to get the global object for an environment was Function('return this')(). However, this causes CSP violations in some settings, so authors would use a piecewise definition like this (slightly adapted from the original core-js source):
jsfunction check(it) {
  // Math is known to exist as a global in every environment.
  return it && it.Math === Math && it;
}

const globalObject =
  check(typeof window === "object" && window) ||
  check(typeof self === "object" && self) ||
  check(typeof global === "object" && global) ||
  // This returns undefined when running in strict mode
  (function () {
    return this;
  })() ||
  Function("return this")();

After obtaining the global object, we can define new globals on it. For example, adding an implementation for Intl:
jsif (typeof globalObject.Intl === "undefined") {
  // No Intl in this environment; define our own on the global scope
  Object.defineProperty(globalObject, "Intl", {
    value: {
      // Our Intl implementation
    },
    enumerable: false,
    configurable: true,
    writable: true,
  });
}

With globalThis available, the additional search for the global across environments is not necessary anymore:
jsif (typeof globalThis.Intl === "undefined") {
  Object.defineProperty(globalThis, "Intl", {
    value: {
      // Our Intl implementation
    },
    enumerable: false,
    configurable: true,
    writable: true,
  });
}
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-globalthisBrowser compatibilitySee also
Polyfill of globalThis in core-js
es-shims polyfill of globalThis
this
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nInfinityBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe Infinity global property is a numeric value representing infinity.Try it
const maxNumber = Math.pow(10, 1000); // Max positive number

if (maxNumber === Infinity) {
  console.log("Let's call it Infinity!");
  // Expected output: "Let's call it Infinity!"
}

console.log(1 / maxNumber);
// Expected output: 0
ValueThe same number value as Number.POSITIVE_INFINITY.
Property attributes of InfinityWritablenoEnumerablenoConfigurablenoDescriptionInfinity is a property of the global object. In other words, it is a variable in global scope.
The value Infinity (positive infinity) is greater than any other number.
This value behaves slightly differently than mathematical infinity; see Number.POSITIVE_INFINITY for details.ExamplesUsing Infinityjsconsole.log(Infinity); /* Infinity */
console.log(Infinity + 1); /* Infinity */
console.log(Math.pow(10, 1000)); /* Infinity */
console.log(Math.log(0)); /* -Infinity */
console.log(1 / Infinity); /* 0 */
console.log(1 / 0); /* Infinity */
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-value-properties-of-the-global-object-infinityBrowser compatibilitySee also
Number.NEGATIVE_INFINITY
Number.POSITIVE_INFINITY
Number.isFinite\n\nInfinityBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe Infinity global property is a numeric value representing infinity.Try it
const maxNumber = Math.pow(10, 1000); // Max positive number

if (maxNumber === Infinity) {
  console.log("Let's call it Infinity!");
  // Expected output: "Let's call it Infinity!"
}

console.log(1 / maxNumber);
// Expected output: 0
ValueThe same number value as Number.POSITIVE_INFINITY.
Property attributes of InfinityWritablenoEnumerablenoConfigurablenoDescriptionInfinity is a property of the global object. In other words, it is a variable in global scope.
The value Infinity (positive infinity) is greater than any other number.
This value behaves slightly differently than mathematical infinity; see Number.POSITIVE_INFINITY for details.ExamplesUsing Infinityjsconsole.log(Infinity); /* Infinity */
console.log(Infinity + 1); /* Infinity */
console.log(Math.pow(10, 1000)); /* Infinity */
console.log(Math.log(0)); /* -Infinity */
console.log(1 / Infinity); /* 0 */
console.log(1 / 0); /* Infinity */
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-value-properties-of-the-global-object-infinityBrowser compatibilitySee also
Number.NEGATIVE_INFINITY
Number.POSITIVE_INFINITY
Number.isFinite
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nInfinityBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe Infinity global property is a numeric value representing infinity.Try it
const maxNumber = Math.pow(10, 1000); // Max positive number

if (maxNumber === Infinity) {
  console.log("Let's call it Infinity!");
  // Expected output: "Let's call it Infinity!"
}

console.log(1 / maxNumber);
// Expected output: 0
ValueThe same number value as Number.POSITIVE_INFINITY.
Property attributes of InfinityWritablenoEnumerablenoConfigurablenoDescriptionInfinity is a property of the global object. In other words, it is a variable in global scope.
The value Infinity (positive infinity) is greater than any other number.
This value behaves slightly differently than mathematical infinity; see Number.POSITIVE_INFINITY for details.ExamplesUsing Infinityjsconsole.log(Infinity); /* Infinity */
console.log(Infinity + 1); /* Infinity */
console.log(Math.pow(10, 1000)); /* Infinity */
console.log(Math.log(0)); /* -Infinity */
console.log(1 / Infinity); /* 0 */
console.log(1 / 0); /* Infinity */
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-value-properties-of-the-global-object-infinityBrowser compatibilitySee also
Number.NEGATIVE_INFINITY
Number.POSITIVE_INFINITY
Number.isFinite
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nInt16ArrayBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe Int16Array typed array represents an array of 16-bit signed integers in the platform byte order. If control over byte order is needed, use DataView instead. The contents are initialized to 0 unless initialization data is explicitly provided. Once established, you can reference elements in the array using the object's methods, or using standard array index syntax (that is, using bracket notation).
Int16Array is a subclass of the hidden TypedArray class.Constructor
Int16Array()

Creates a new Int16Array object.

Static propertiesAlso inherits static properties from its parent TypedArray.

Int16Array.BYTES_PER_ELEMENT

Returns a number value of the element size. 2 in the case of Int16Array.

Static methodsInherits static methods from its parent TypedArray.Instance propertiesAlso inherits instance properties from its parent TypedArray.
These properties are defined on Int16Array.prototype and shared by all Int16Array instances.

Int16Array.prototype.BYTES_PER_ELEMENT

Returns a number value of the element size. 2 in the case of a Int16Array.

Int16Array.prototype.constructor

The constructor function that created the instance object. For Int16Array instances, the initial value is the Int16Array constructor.

Instance methodsInherits instance methods from its parent TypedArray.ExamplesDifferent ways to create an Int16Arrayjs// From a length
const int16 = new Int16Array(2);
int16[0] = 42;
console.log(int16[0]); // 42
console.log(int16.length); // 2
console.log(int16.BYTES_PER_ELEMENT); // 2

// From an array
const x = new Int16Array([21, 31]);
console.log(x[1]); // 31

// From another TypedArray
const y = new Int16Array(x);
console.log(y[0]); // 21

// From an ArrayBuffer
const buffer = new ArrayBuffer(16);
const z = new Int16Array(buffer, 2, 4);
console.log(z.byteOffset); // 2

// From an iterable
const iterable = (function* () {
  yield* [1, 2, 3];
})();
const int16FromIterable = new Int16Array(iterable);
console.log(int16FromIterable);
// Int16Array [1, 2, 3]
SpecificationsSpecificationECMAScript® 2026 Language Specification # table-49Browser compatibilitySee also
Polyfill of Int16Array in core-js
JavaScript typed arrays guide
TypedArray
ArrayBuffer
DataView\n\nInt16ArrayBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe Int16Array typed array represents an array of 16-bit signed integers in the platform byte order. If control over byte order is needed, use DataView instead. The contents are initialized to 0 unless initialization data is explicitly provided. Once established, you can reference elements in the array using the object's methods, or using standard array index syntax (that is, using bracket notation).
Int16Array is a subclass of the hidden TypedArray class.Constructor
Int16Array()

Creates a new Int16Array object.

Static propertiesAlso inherits static properties from its parent TypedArray.

Int16Array.BYTES_PER_ELEMENT

Returns a number value of the element size. 2 in the case of Int16Array.

Static methodsInherits static methods from its parent TypedArray.Instance propertiesAlso inherits instance properties from its parent TypedArray.
These properties are defined on Int16Array.prototype and shared by all Int16Array instances.

Int16Array.prototype.BYTES_PER_ELEMENT

Returns a number value of the element size. 2 in the case of a Int16Array.

Int16Array.prototype.constructor

The constructor function that created the instance object. For Int16Array instances, the initial value is the Int16Array constructor.

Instance methodsInherits instance methods from its parent TypedArray.ExamplesDifferent ways to create an Int16Arrayjs// From a length
const int16 = new Int16Array(2);
int16[0] = 42;
console.log(int16[0]); // 42
console.log(int16.length); // 2
console.log(int16.BYTES_PER_ELEMENT); // 2

// From an array
const x = new Int16Array([21, 31]);
console.log(x[1]); // 31

// From another TypedArray
const y = new Int16Array(x);
console.log(y[0]); // 21

// From an ArrayBuffer
const buffer = new ArrayBuffer(16);
const z = new Int16Array(buffer, 2, 4);
console.log(z.byteOffset); // 2

// From an iterable
const iterable = (function* () {
  yield* [1, 2, 3];
})();
const int16FromIterable = new Int16Array(iterable);
console.log(int16FromIterable);
// Int16Array [1, 2, 3]
SpecificationsSpecificationECMAScript® 2026 Language Specification # table-49Browser compatibilitySee also
Polyfill of Int16Array in core-js
JavaScript typed arrays guide
TypedArray
ArrayBuffer
DataView
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jun 12, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nInt16ArrayBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe Int16Array typed array represents an array of 16-bit signed integers in the platform byte order. If control over byte order is needed, use DataView instead. The contents are initialized to 0 unless initialization data is explicitly provided. Once established, you can reference elements in the array using the object's methods, or using standard array index syntax (that is, using bracket notation).
Int16Array is a subclass of the hidden TypedArray class.Constructor
Int16Array()

Creates a new Int16Array object.

Static propertiesAlso inherits static properties from its parent TypedArray.

Int16Array.BYTES_PER_ELEMENT

Returns a number value of the element size. 2 in the case of Int16Array.

Static methodsInherits static methods from its parent TypedArray.Instance propertiesAlso inherits instance properties from its parent TypedArray.
These properties are defined on Int16Array.prototype and shared by all Int16Array instances.

Int16Array.prototype.BYTES_PER_ELEMENT

Returns a number value of the element size. 2 in the case of a Int16Array.

Int16Array.prototype.constructor

The constructor function that created the instance object. For Int16Array instances, the initial value is the Int16Array constructor.

Instance methodsInherits instance methods from its parent TypedArray.ExamplesDifferent ways to create an Int16Arrayjs// From a length
const int16 = new Int16Array(2);
int16[0] = 42;
console.log(int16[0]); // 42
console.log(int16.length); // 2
console.log(int16.BYTES_PER_ELEMENT); // 2

// From an array
const x = new Int16Array([21, 31]);
console.log(x[1]); // 31

// From another TypedArray
const y = new Int16Array(x);
console.log(y[0]); // 21

// From an ArrayBuffer
const buffer = new ArrayBuffer(16);
const z = new Int16Array(buffer, 2, 4);
console.log(z.byteOffset); // 2

// From an iterable
const iterable = (function* () {
  yield* [1, 2, 3];
})();
const int16FromIterable = new Int16Array(iterable);
console.log(int16FromIterable);
// Int16Array [1, 2, 3]
SpecificationsSpecificationECMAScript® 2026 Language Specification # table-49Browser compatibilitySee also
Polyfill of Int16Array in core-js
JavaScript typed arrays guide
TypedArray
ArrayBuffer
DataView
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jun 12, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nInt32ArrayBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe Int32Array typed array represents an array of 32-bit signed integers in the platform byte order. If control over byte order is needed, use DataView instead. The contents are initialized to 0 unless initialization data is explicitly provided. Once established, you can reference elements in the array using the object's methods, or using standard array index syntax (that is, using bracket notation).
Int32Array is a subclass of the hidden TypedArray class.Constructor
Int32Array()

Creates a new Int32Array object.

Static propertiesAlso inherits static properties from its parent TypedArray.

Int32Array.BYTES_PER_ELEMENT

Returns a number value of the element size. 4 in the case of Int32Array.

Static methodsInherits static methods from its parent TypedArray.Instance propertiesAlso inherits instance properties from its parent TypedArray.
These properties are defined on Int32Array.prototype and shared by all Int32Array instances.

Int32Array.prototype.BYTES_PER_ELEMENT

Returns a number value of the element size. 4 in the case of a Int32Array.

Int32Array.prototype.constructor

The constructor function that created the instance object. For Int32Array instances, the initial value is the Int32Array constructor.

Instance methodsInherits instance methods from its parent TypedArray.ExamplesDifferent ways to create an Int32Arrayjs// From a length
const int32 = new Int32Array(2);
int32[0] = 42;
console.log(int32[0]); // 42
console.log(int32.length); // 2
console.log(int32.BYTES_PER_ELEMENT); // 4

// From an array
const x = new Int32Array([21, 31]);
console.log(x[1]); // 31

// From another TypedArray
const y = new Int32Array(x);
console.log(y[0]); // 21

// From an ArrayBuffer
const buffer = new ArrayBuffer(32);
const z = new Int32Array(buffer, 4, 4);
console.log(z.byteOffset); // 4

// From an iterable
const iterable = (function* () {
  yield* [1, 2, 3];
})();
const int32FromIterable = new Int32Array(iterable);
console.log(int32FromIterable);
// Int32Array [1, 2, 3]
SpecificationsSpecificationECMAScript® 2026 Language Specification # table-49Browser compatibilitySee also
Polyfill of Int32Array in core-js
JavaScript typed arrays guide
TypedArray
ArrayBuffer
DataView\n\nInt32ArrayBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe Int32Array typed array represents an array of 32-bit signed integers in the platform byte order. If control over byte order is needed, use DataView instead. The contents are initialized to 0 unless initialization data is explicitly provided. Once established, you can reference elements in the array using the object's methods, or using standard array index syntax (that is, using bracket notation).
Int32Array is a subclass of the hidden TypedArray class.Constructor
Int32Array()

Creates a new Int32Array object.

Static propertiesAlso inherits static properties from its parent TypedArray.

Int32Array.BYTES_PER_ELEMENT

Returns a number value of the element size. 4 in the case of Int32Array.

Static methodsInherits static methods from its parent TypedArray.Instance propertiesAlso inherits instance properties from its parent TypedArray.
These properties are defined on Int32Array.prototype and shared by all Int32Array instances.

Int32Array.prototype.BYTES_PER_ELEMENT

Returns a number value of the element size. 4 in the case of a Int32Array.

Int32Array.prototype.constructor

The constructor function that created the instance object. For Int32Array instances, the initial value is the Int32Array constructor.

Instance methodsInherits instance methods from its parent TypedArray.ExamplesDifferent ways to create an Int32Arrayjs// From a length
const int32 = new Int32Array(2);
int32[0] = 42;
console.log(int32[0]); // 42
console.log(int32.length); // 2
console.log(int32.BYTES_PER_ELEMENT); // 4

// From an array
const x = new Int32Array([21, 31]);
console.log(x[1]); // 31

// From another TypedArray
const y = new Int32Array(x);
console.log(y[0]); // 21

// From an ArrayBuffer
const buffer = new ArrayBuffer(32);
const z = new Int32Array(buffer, 4, 4);
console.log(z.byteOffset); // 4

// From an iterable
const iterable = (function* () {
  yield* [1, 2, 3];
})();
const int32FromIterable = new Int32Array(iterable);
console.log(int32FromIterable);
// Int32Array [1, 2, 3]
SpecificationsSpecificationECMAScript® 2026 Language Specification # table-49Browser compatibilitySee also
Polyfill of Int32Array in core-js
JavaScript typed arrays guide
TypedArray
ArrayBuffer
DataView
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jun 12, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nInt32ArrayBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe Int32Array typed array represents an array of 32-bit signed integers in the platform byte order. If control over byte order is needed, use DataView instead. The contents are initialized to 0 unless initialization data is explicitly provided. Once established, you can reference elements in the array using the object's methods, or using standard array index syntax (that is, using bracket notation).
Int32Array is a subclass of the hidden TypedArray class.Constructor
Int32Array()

Creates a new Int32Array object.

Static propertiesAlso inherits static properties from its parent TypedArray.

Int32Array.BYTES_PER_ELEMENT

Returns a number value of the element size. 4 in the case of Int32Array.

Static methodsInherits static methods from its parent TypedArray.Instance propertiesAlso inherits instance properties from its parent TypedArray.
These properties are defined on Int32Array.prototype and shared by all Int32Array instances.

Int32Array.prototype.BYTES_PER_ELEMENT

Returns a number value of the element size. 4 in the case of a Int32Array.

Int32Array.prototype.constructor

The constructor function that created the instance object. For Int32Array instances, the initial value is the Int32Array constructor.

Instance methodsInherits instance methods from its parent TypedArray.ExamplesDifferent ways to create an Int32Arrayjs// From a length
const int32 = new Int32Array(2);
int32[0] = 42;
console.log(int32[0]); // 42
console.log(int32.length); // 2
console.log(int32.BYTES_PER_ELEMENT); // 4

// From an array
const x = new Int32Array([21, 31]);
console.log(x[1]); // 31

// From another TypedArray
const y = new Int32Array(x);
console.log(y[0]); // 21

// From an ArrayBuffer
const buffer = new ArrayBuffer(32);
const z = new Int32Array(buffer, 4, 4);
console.log(z.byteOffset); // 4

// From an iterable
const iterable = (function* () {
  yield* [1, 2, 3];
})();
const int32FromIterable = new Int32Array(iterable);
console.log(int32FromIterable);
// Int32Array [1, 2, 3]
SpecificationsSpecificationECMAScript® 2026 Language Specification # table-49Browser compatibilitySee also
Polyfill of Int32Array in core-js
JavaScript typed arrays guide
TypedArray
ArrayBuffer
DataView
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jun 12, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nInt8ArrayBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe Int8Array typed array represents an array of 8-bit signed integers. The contents are initialized to 0 unless initialization data is explicitly provided. Once established, you can reference elements in the array using the object's methods, or using standard array index syntax (that is, using bracket notation).
Int8Array is a subclass of the hidden TypedArray class.Constructor
Int8Array()

Creates a new Int8Array object.

Static propertiesAlso inherits static properties from its parent TypedArray.

Int8Array.BYTES_PER_ELEMENT

Returns a number value of the element size. 1 in the case of Int8Array.

Static methodsInherits static methods from its parent TypedArray.Instance propertiesAlso inherits instance properties from its parent TypedArray.
These properties are defined on Int8Array.prototype and shared by all Int8Array instances.

Int8Array.prototype.BYTES_PER_ELEMENT

Returns a number value of the element size. 1 in the case of a Int8Array.

Int8Array.prototype.constructor

The constructor function that created the instance object. For Int8Array instances, the initial value is the Int8Array constructor.

Instance methodsInherits instance methods from its parent TypedArray.ExamplesDifferent ways to create an Int8Arrayjs// From a length
const int8 = new Int8Array(2);
int8[0] = 42;
console.log(int8[0]); // 42
console.log(int8.length); // 2
console.log(int8.BYTES_PER_ELEMENT); // 1

// From an array
const x = new Int8Array([21, 31]);
console.log(x[1]); // 31

// From another TypedArray
const y = new Int8Array(x);
console.log(y[0]); // 21

// From an ArrayBuffer
const buffer = new ArrayBuffer(8);
const z = new Int8Array(buffer, 1, 4);
console.log(z.byteOffset); // 1

// From an iterable
const iterable = (function* () {
  yield* [1, 2, 3];
})();
const int8FromIterable = new Int8Array(iterable);
console.log(int8FromIterable);
// Int8Array [1, 2, 3]
SpecificationsSpecificationECMAScript® 2026 Language Specification # table-49Browser compatibilitySee also
Polyfill of Int8Array in core-js
JavaScript typed arrays guide
TypedArray
ArrayBuffer
DataView\n\nInt8ArrayBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe Int8Array typed array represents an array of 8-bit signed integers. The contents are initialized to 0 unless initialization data is explicitly provided. Once established, you can reference elements in the array using the object's methods, or using standard array index syntax (that is, using bracket notation).
Int8Array is a subclass of the hidden TypedArray class.Constructor
Int8Array()

Creates a new Int8Array object.

Static propertiesAlso inherits static properties from its parent TypedArray.

Int8Array.BYTES_PER_ELEMENT

Returns a number value of the element size. 1 in the case of Int8Array.

Static methodsInherits static methods from its parent TypedArray.Instance propertiesAlso inherits instance properties from its parent TypedArray.
These properties are defined on Int8Array.prototype and shared by all Int8Array instances.

Int8Array.prototype.BYTES_PER_ELEMENT

Returns a number value of the element size. 1 in the case of a Int8Array.

Int8Array.prototype.constructor

The constructor function that created the instance object. For Int8Array instances, the initial value is the Int8Array constructor.

Instance methodsInherits instance methods from its parent TypedArray.ExamplesDifferent ways to create an Int8Arrayjs// From a length
const int8 = new Int8Array(2);
int8[0] = 42;
console.log(int8[0]); // 42
console.log(int8.length); // 2
console.log(int8.BYTES_PER_ELEMENT); // 1

// From an array
const x = new Int8Array([21, 31]);
console.log(x[1]); // 31

// From another TypedArray
const y = new Int8Array(x);
console.log(y[0]); // 21

// From an ArrayBuffer
const buffer = new ArrayBuffer(8);
const z = new Int8Array(buffer, 1, 4);
console.log(z.byteOffset); // 1

// From an iterable
const iterable = (function* () {
  yield* [1, 2, 3];
})();
const int8FromIterable = new Int8Array(iterable);
console.log(int8FromIterable);
// Int8Array [1, 2, 3]
SpecificationsSpecificationECMAScript® 2026 Language Specification # table-49Browser compatibilitySee also
Polyfill of Int8Array in core-js
JavaScript typed arrays guide
TypedArray
ArrayBuffer
DataView
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jun 12, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nInt8ArrayBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe Int8Array typed array represents an array of 8-bit signed integers. The contents are initialized to 0 unless initialization data is explicitly provided. Once established, you can reference elements in the array using the object's methods, or using standard array index syntax (that is, using bracket notation).
Int8Array is a subclass of the hidden TypedArray class.Constructor
Int8Array()

Creates a new Int8Array object.

Static propertiesAlso inherits static properties from its parent TypedArray.

Int8Array.BYTES_PER_ELEMENT

Returns a number value of the element size. 1 in the case of Int8Array.

Static methodsInherits static methods from its parent TypedArray.Instance propertiesAlso inherits instance properties from its parent TypedArray.
These properties are defined on Int8Array.prototype and shared by all Int8Array instances.

Int8Array.prototype.BYTES_PER_ELEMENT

Returns a number value of the element size. 1 in the case of a Int8Array.

Int8Array.prototype.constructor

The constructor function that created the instance object. For Int8Array instances, the initial value is the Int8Array constructor.

Instance methodsInherits instance methods from its parent TypedArray.ExamplesDifferent ways to create an Int8Arrayjs// From a length
const int8 = new Int8Array(2);
int8[0] = 42;
console.log(int8[0]); // 42
console.log(int8.length); // 2
console.log(int8.BYTES_PER_ELEMENT); // 1

// From an array
const x = new Int8Array([21, 31]);
console.log(x[1]); // 31

// From another TypedArray
const y = new Int8Array(x);
console.log(y[0]); // 21

// From an ArrayBuffer
const buffer = new ArrayBuffer(8);
const z = new Int8Array(buffer, 1, 4);
console.log(z.byteOffset); // 1

// From an iterable
const iterable = (function* () {
  yield* [1, 2, 3];
})();
const int8FromIterable = new Int8Array(iterable);
console.log(int8FromIterable);
// Int8Array [1, 2, 3]
SpecificationsSpecificationECMAScript® 2026 Language Specification # table-49Browser compatibilitySee also
Polyfill of Int8Array in core-js
JavaScript typed arrays guide
TypedArray
ArrayBuffer
DataView
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jun 12, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nInternalErrorNon-standard: This feature is non-standard and is not on a standards track. Do not use it on production sites facing the Web: it will not work for every user. There may also be large incompatibilities between implementations and the behavior may change in the future.
The InternalError object indicates an error that occurred internally in the JavaScript engine.
Example cases are mostly when something is too large, e.g.:

"too many switch cases",
"too many parentheses in regular expression",
"array initializer too large",
"too much recursion".

InternalError is a subclass of Error.Constructor
InternalError() 
Non-standard


Creates a new InternalError object.

Instance propertiesAlso inherits instance properties from its parent Error.
These properties are defined on InternalError.prototype and shared by all InternalError instances.

InternalError.prototype.constructor

The constructor function that created the instance object. For InternalError instances, the initial value is the InternalError constructor.

InternalError.prototype.name

Represents the name for the type of error. For InternalError.prototype.name, the initial value is "InternalError".

Instance methodsInherits instance methods from its parent Error.ExamplesToo much recursionThis recursive function runs 10 times, as per the exit condition.
jsfunction loop(x) {
  // "x >= 10" is the exit condition
  if (x >= 10) return;

  // do stuff
  loop(x + 1); // the recursive call
}
loop(0);

Setting this condition to an extremely high value, may not work:
jsfunction loop(x) {
  if (x >= 1000000000000) return;

  // do stuff
  loop(x + 1);
}
loop(0);

// InternalError: too much recursion

For more information, see InternalError: too much recursion.SpecificationsNot part of any standard.Browser compatibilitySee also
Error
InternalError: too much recursion\n\nInternalErrorNon-standard: This feature is non-standard and is not on a standards track. Do not use it on production sites facing the Web: it will not work for every user. There may also be large incompatibilities between implementations and the behavior may change in the future.
The InternalError object indicates an error that occurred internally in the JavaScript engine.
Example cases are mostly when something is too large, e.g.:

"too many switch cases",
"too many parentheses in regular expression",
"array initializer too large",
"too much recursion".

InternalError is a subclass of Error.Constructor
InternalError() 
Non-standard


Creates a new InternalError object.

Instance propertiesAlso inherits instance properties from its parent Error.
These properties are defined on InternalError.prototype and shared by all InternalError instances.

InternalError.prototype.constructor

The constructor function that created the instance object. For InternalError instances, the initial value is the InternalError constructor.

InternalError.prototype.name

Represents the name for the type of error. For InternalError.prototype.name, the initial value is "InternalError".

Instance methodsInherits instance methods from its parent Error.ExamplesToo much recursionThis recursive function runs 10 times, as per the exit condition.
jsfunction loop(x) {
  // "x >= 10" is the exit condition
  if (x >= 10) return;

  // do stuff
  loop(x + 1); // the recursive call
}
loop(0);

Setting this condition to an extremely high value, may not work:
jsfunction loop(x) {
  if (x >= 1000000000000) return;

  // do stuff
  loop(x + 1);
}
loop(0);

// InternalError: too much recursion

For more information, see InternalError: too much recursion.SpecificationsNot part of any standard.Browser compatibilitySee also
Error
InternalError: too much recursion
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nInternalErrorNon-standard: This feature is non-standard and is not on a standards track. Do not use it on production sites facing the Web: it will not work for every user. There may also be large incompatibilities between implementations and the behavior may change in the future.
The InternalError object indicates an error that occurred internally in the JavaScript engine.
Example cases are mostly when something is too large, e.g.:

"too many switch cases",
"too many parentheses in regular expression",
"array initializer too large",
"too much recursion".

InternalError is a subclass of Error.Constructor
InternalError() 
Non-standard


Creates a new InternalError object.

Instance propertiesAlso inherits instance properties from its parent Error.
These properties are defined on InternalError.prototype and shared by all InternalError instances.

InternalError.prototype.constructor

The constructor function that created the instance object. For InternalError instances, the initial value is the InternalError constructor.

InternalError.prototype.name

Represents the name for the type of error. For InternalError.prototype.name, the initial value is "InternalError".

Instance methodsInherits instance methods from its parent Error.ExamplesToo much recursionThis recursive function runs 10 times, as per the exit condition.
jsfunction loop(x) {
  // "x >= 10" is the exit condition
  if (x >= 10) return;

  // do stuff
  loop(x + 1); // the recursive call
}
loop(0);

Setting this condition to an extremely high value, may not work:
jsfunction loop(x) {
  if (x >= 1000000000000) return;

  // do stuff
  loop(x + 1);
}
loop(0);

// InternalError: too much recursion

For more information, see InternalError: too much recursion.SpecificationsNot part of any standard.Browser compatibilitySee also
Error
InternalError: too much recursion
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Sep 12, 2023 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIntlBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl namespace object contains several constructors as well as functionality common to the internationalization constructors and other language sensitive functions. Collectively, they comprise the ECMAScript Internationalization API, which provides language sensitive string comparison, number formatting, date and time formatting, and more.DescriptionUnlike most global objects, Intl is not a constructor. You cannot use it with the new operator or invoke the Intl object as a function. All properties and methods of Intl are static (just like the Math object).
The internationalization constructors as well as several language sensitive methods of other constructors (listed under See also) use a common pattern for identifying locales and determining the one they will actually use: they all accept locales and options arguments, and negotiate the requested locale(s) against the locales they support using an algorithm specified in the options.localeMatcher property.locales argumentThe locales argument is used to determine the locale used in a given operation. The JavaScript implementation examines locales, and then computes a locale it understands that comes closest to satisfying the expressed preference. locales may be:

undefined (or omitted): The implementation's default locale will be used.
A locale: A locale identifier or an Intl.Locale object that wraps a locale identifier.
A list of locales: Any other value, that will be converted into an object and then treated as an array of locales.

In the latter two cases, the actual locale used is the best-supported locale determined by locale negotiation. If a locale identifier is not a string or an object, a TypeError is thrown. If a locale identifier is a string that's syntactically invalid, a RangeError is thrown. If a locale identifier is well-formed but the implementation doesn't recognize it, it is ignored and the next locale in the list is considered, eventually falling back to the system's locale. However, you shouldn't rely on a particular locale name being ignored, because the implementation may add data for any locale in the future. For example, new Intl.DateTimeFormat("default") uses the implementation's default locale only because "default" is syntactically valid but not recognized as any locale.
A locale identifier is a string that consists of:

A language subtag with 2–3 or 5–8 letters
A script subtag with 4 letters Optional
A region subtag with either 2 letters or 3 digits Optional
One or more variant subtags (all of which must be unique), each with either 5–8 alphanumerals or a digit followed by 3 alphanumerals Optional
One or more BCP 47 extension sequences Optional
A private-use extension sequence Optional

Each subtag and sequence are separated by hyphens. Locale identifiers are case-insensitive ASCII. However, it's conventional to use title case (the first letter is capitalized, successive letters are lower case) for script subtags, upper case for region subtags, and lower case for everything else. For example:

"hi": Hindi (language)
"de-AT": German (language) as used in Austria (region)
"zh-Hans-CN": Chinese (language) written in simplified characters (script) as used in China (region)
"en-emodeng": English (language) in the "Early modern English" dialect (variant)

Subtags identifying languages, scripts, regions (including countries), and (rarely used) variants are registered in the IANA Language Subtag Registry. This registry is periodically updated over time, and implementations may not always be up to date, so don't rely too much on subtags being universally supported.
BCP 47 extension sequences consist of a single digit or letter (other than "x") and one or more two- to eight-letter or digit subtags separated by hyphens. Only one sequence is permitted for each digit or letter: "de-a-foo-a-foo" is invalid. BCP 47 extension subtags are defined in the Unicode CLDR Project. Currently only two extensions have defined semantics:


The "u" (Unicode) extension can be used to request additional customization of Intl API objects. Examples:

"de-DE-u-co-phonebk": Use the phonebook variant of the German sort order, which interprets umlauted vowels as corresponding character pairs: ä → ae, ö → oe, ü → ue.
"th-TH-u-nu-thai": Use Thai digits (๐, ๑, ๒, ๓, ๔, ๕, ๖, ๗, ๘, ๙) in number formatting.
"ja-JP-u-ca-japanese": Use the Japanese calendar in date and time formatting, so that 2013 is expressed as the year 25 of the Heisei period, or 平成 25.
"en-GB-u-ca-islamic-umalqura": use British English with the Umm al-Qura (Hijri) calendar, where the Gregorian date 14 October, 2017 is the Hijri date 24 Muharram, 1439.



The "t" (transformed) extension indicates transformed content: for example, text that was translated from another locale. No Intl functionality currently considers the "t" extension. However, this extension sometimes contains a nested locale (with no extensions): for example, the transformed extension in "de-t-en" contains the locale identifier for English. If a nested locale is present, it must be a valid locale identifier. For example, because "en-emodeng-emodeng" is invalid (because it contains a duplicate emodeng variant subtag), "de-t-en-emodeng-emodeng" is also invalid.


Finally, a private-use extension sequence using the letter "x" may appear, followed by one or more one- to eight-letter or digit subtags separated by hyphens. This allows applications to encode information for their own private use, that will be ignored by all Intl operations.options argumentThe options argument must be an object with properties that vary between constructors and functions. If the options argument is not provided or is undefined, default values are used for all properties.
One property is supported by all language sensitive constructors and functions: The localeMatcher property, whose value must be a string "lookup" or "best fit" and which selects one of the locale matching algorithms described below.Locale identification and negotiationThe list of locales specified by the locales argument, after Unicode extensions have been removed from them, is interpreted as a prioritized request from the application. The runtime compares it against the locales it has available and picks the best one available. Two matching algorithms exist: the "lookup" matcher follows the Lookup algorithm specified in BCP 47; the "best fit" matcher lets the runtime provide a locale that's at least, but possibly more, suited for the request than the result of the Lookup algorithm. If the application doesn't provide a locales argument, or the runtime doesn't have a locale that matches the request, then the runtime's default locale is used. The matcher can be selected using a property of the options argument (see below).
If the selected locale identifier had a Unicode extension sequence, that extension is now used to customize the constructed object or the behavior of the function. Each constructor or function supports only a subset of the keys defined for the Unicode extension, and the supported values often depend on the locale identifier. For example, the "co" key (collation) is only supported by Intl.Collator, and its "phonebk" value is only supported for German.Static properties
Intl.Collator

Constructor for collators, which are objects that enable language-sensitive string comparison.

Intl.DateTimeFormat

Constructor for objects that enable language-sensitive date and time formatting.

Intl.DisplayNames

Constructor for objects that enable the consistent translation of language, region and script display names.

Intl.DurationFormat

Constructor for objects that enable locale-sensitive duration formatting.

Intl.ListFormat

Constructor for objects that enable language-sensitive list formatting.

Intl.Locale

Constructor for objects that represents a Unicode locale identifier.

Intl.NumberFormat

Constructor for objects that enable language-sensitive number formatting.

Intl.PluralRules

Constructor for objects that enable plural-sensitive formatting and language-specific rules for plurals.

Intl.RelativeTimeFormat

Constructor for objects that enable language-sensitive relative time formatting.

Intl.Segmenter

Constructor for objects that enable locale-sensitive text segmentation.

Intl[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl". This property is used in Object.prototype.toString().

Static methods
Intl.getCanonicalLocales()

Returns canonical locale names.

Intl.supportedValuesOf()

Returns a sorted array containing the supported unique calendar, collation, currency, numbering systems, or unit values supported by the implementation.

ExamplesFormatting dates and numbersYou can use Intl to format dates and numbers in a form that's conventional for a specific language and region:
jsconst count = 26254.39;
const date = new Date("2012-05-24");

function log(locale) {
  console.log(
    `${new Intl.DateTimeFormat(locale).format(date)} ${new Intl.NumberFormat(
      locale,
    ).format(count)}`,
  );
}

log("en-US"); // 5/24/2012 26,254.39

log("de-DE"); // 24.5.2012 26.254,39
Using the browser's preferred languageInstead of passing a hardcoded locale name to the Intl methods, you can use the user's preferred language provided by navigator.language:
jsconst date = new Date("2012-05-24");

const formattedDate = new Intl.DateTimeFormat(navigator.language).format(date);

Alternatively, the navigator.languages property provides a sorted list of the user's preferred languages. This list can be passed directly to the Intl constructors to implement preference-based fallback selection of locales. The locale negotiation process is used to pick the most appropriate locale available:
jsconst count = 26254.39;

const formattedCount = new Intl.NumberFormat(navigator.languages).format(count);
SpecificationsSpecificationECMAScript® 2025 Internationalization API Specification # intl-objectBrowser compatibilitySee also
Keyboard.getLayoutMap()
navigator.language
navigator.languages
The ECMAScript Internationalization API by Norbert Lindenberg (2012)\n\nIntlBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl namespace object contains several constructors as well as functionality common to the internationalization constructors and other language sensitive functions. Collectively, they comprise the ECMAScript Internationalization API, which provides language sensitive string comparison, number formatting, date and time formatting, and more.DescriptionUnlike most global objects, Intl is not a constructor. You cannot use it with the new operator or invoke the Intl object as a function. All properties and methods of Intl are static (just like the Math object).
The internationalization constructors as well as several language sensitive methods of other constructors (listed under See also) use a common pattern for identifying locales and determining the one they will actually use: they all accept locales and options arguments, and negotiate the requested locale(s) against the locales they support using an algorithm specified in the options.localeMatcher property.locales argumentThe locales argument is used to determine the locale used in a given operation. The JavaScript implementation examines locales, and then computes a locale it understands that comes closest to satisfying the expressed preference. locales may be:

undefined (or omitted): The implementation's default locale will be used.
A locale: A locale identifier or an Intl.Locale object that wraps a locale identifier.
A list of locales: Any other value, that will be converted into an object and then treated as an array of locales.

In the latter two cases, the actual locale used is the best-supported locale determined by locale negotiation. If a locale identifier is not a string or an object, a TypeError is thrown. If a locale identifier is a string that's syntactically invalid, a RangeError is thrown. If a locale identifier is well-formed but the implementation doesn't recognize it, it is ignored and the next locale in the list is considered, eventually falling back to the system's locale. However, you shouldn't rely on a particular locale name being ignored, because the implementation may add data for any locale in the future. For example, new Intl.DateTimeFormat("default") uses the implementation's default locale only because "default" is syntactically valid but not recognized as any locale.
A locale identifier is a string that consists of:

A language subtag with 2–3 or 5–8 letters
A script subtag with 4 letters Optional
A region subtag with either 2 letters or 3 digits Optional
One or more variant subtags (all of which must be unique), each with either 5–8 alphanumerals or a digit followed by 3 alphanumerals Optional
One or more BCP 47 extension sequences Optional
A private-use extension sequence Optional

Each subtag and sequence are separated by hyphens. Locale identifiers are case-insensitive ASCII. However, it's conventional to use title case (the first letter is capitalized, successive letters are lower case) for script subtags, upper case for region subtags, and lower case for everything else. For example:

"hi": Hindi (language)
"de-AT": German (language) as used in Austria (region)
"zh-Hans-CN": Chinese (language) written in simplified characters (script) as used in China (region)
"en-emodeng": English (language) in the "Early modern English" dialect (variant)

Subtags identifying languages, scripts, regions (including countries), and (rarely used) variants are registered in the IANA Language Subtag Registry. This registry is periodically updated over time, and implementations may not always be up to date, so don't rely too much on subtags being universally supported.
BCP 47 extension sequences consist of a single digit or letter (other than "x") and one or more two- to eight-letter or digit subtags separated by hyphens. Only one sequence is permitted for each digit or letter: "de-a-foo-a-foo" is invalid. BCP 47 extension subtags are defined in the Unicode CLDR Project. Currently only two extensions have defined semantics:


The "u" (Unicode) extension can be used to request additional customization of Intl API objects. Examples:

"de-DE-u-co-phonebk": Use the phonebook variant of the German sort order, which interprets umlauted vowels as corresponding character pairs: ä → ae, ö → oe, ü → ue.
"th-TH-u-nu-thai": Use Thai digits (๐, ๑, ๒, ๓, ๔, ๕, ๖, ๗, ๘, ๙) in number formatting.
"ja-JP-u-ca-japanese": Use the Japanese calendar in date and time formatting, so that 2013 is expressed as the year 25 of the Heisei period, or 平成 25.
"en-GB-u-ca-islamic-umalqura": use British English with the Umm al-Qura (Hijri) calendar, where the Gregorian date 14 October, 2017 is the Hijri date 24 Muharram, 1439.



The "t" (transformed) extension indicates transformed content: for example, text that was translated from another locale. No Intl functionality currently considers the "t" extension. However, this extension sometimes contains a nested locale (with no extensions): for example, the transformed extension in "de-t-en" contains the locale identifier for English. If a nested locale is present, it must be a valid locale identifier. For example, because "en-emodeng-emodeng" is invalid (because it contains a duplicate emodeng variant subtag), "de-t-en-emodeng-emodeng" is also invalid.


Finally, a private-use extension sequence using the letter "x" may appear, followed by one or more one- to eight-letter or digit subtags separated by hyphens. This allows applications to encode information for their own private use, that will be ignored by all Intl operations.options argumentThe options argument must be an object with properties that vary between constructors and functions. If the options argument is not provided or is undefined, default values are used for all properties.
One property is supported by all language sensitive constructors and functions: The localeMatcher property, whose value must be a string "lookup" or "best fit" and which selects one of the locale matching algorithms described below.Locale identification and negotiationThe list of locales specified by the locales argument, after Unicode extensions have been removed from them, is interpreted as a prioritized request from the application. The runtime compares it against the locales it has available and picks the best one available. Two matching algorithms exist: the "lookup" matcher follows the Lookup algorithm specified in BCP 47; the "best fit" matcher lets the runtime provide a locale that's at least, but possibly more, suited for the request than the result of the Lookup algorithm. If the application doesn't provide a locales argument, or the runtime doesn't have a locale that matches the request, then the runtime's default locale is used. The matcher can be selected using a property of the options argument (see below).
If the selected locale identifier had a Unicode extension sequence, that extension is now used to customize the constructed object or the behavior of the function. Each constructor or function supports only a subset of the keys defined for the Unicode extension, and the supported values often depend on the locale identifier. For example, the "co" key (collation) is only supported by Intl.Collator, and its "phonebk" value is only supported for German.Static properties
Intl.Collator

Constructor for collators, which are objects that enable language-sensitive string comparison.

Intl.DateTimeFormat

Constructor for objects that enable language-sensitive date and time formatting.

Intl.DisplayNames

Constructor for objects that enable the consistent translation of language, region and script display names.

Intl.DurationFormat

Constructor for objects that enable locale-sensitive duration formatting.

Intl.ListFormat

Constructor for objects that enable language-sensitive list formatting.

Intl.Locale

Constructor for objects that represents a Unicode locale identifier.

Intl.NumberFormat

Constructor for objects that enable language-sensitive number formatting.

Intl.PluralRules

Constructor for objects that enable plural-sensitive formatting and language-specific rules for plurals.

Intl.RelativeTimeFormat

Constructor for objects that enable language-sensitive relative time formatting.

Intl.Segmenter

Constructor for objects that enable locale-sensitive text segmentation.

Intl[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl". This property is used in Object.prototype.toString().

Static methods
Intl.getCanonicalLocales()

Returns canonical locale names.

Intl.supportedValuesOf()

Returns a sorted array containing the supported unique calendar, collation, currency, numbering systems, or unit values supported by the implementation.

ExamplesFormatting dates and numbersYou can use Intl to format dates and numbers in a form that's conventional for a specific language and region:
jsconst count = 26254.39;
const date = new Date("2012-05-24");

function log(locale) {
  console.log(
    `${new Intl.DateTimeFormat(locale).format(date)} ${new Intl.NumberFormat(
      locale,
    ).format(count)}`,
  );
}

log("en-US"); // 5/24/2012 26,254.39

log("de-DE"); // 24.5.2012 26.254,39
Using the browser's preferred languageInstead of passing a hardcoded locale name to the Intl methods, you can use the user's preferred language provided by navigator.language:
jsconst date = new Date("2012-05-24");

const formattedDate = new Intl.DateTimeFormat(navigator.language).format(date);

Alternatively, the navigator.languages property provides a sorted list of the user's preferred languages. This list can be passed directly to the Intl constructors to implement preference-based fallback selection of locales. The locale negotiation process is used to pick the most appropriate locale available:
jsconst count = 26254.39;

const formattedCount = new Intl.NumberFormat(navigator.languages).format(count);
SpecificationsSpecificationECMAScript® 2025 Internationalization API Specification # intl-objectBrowser compatibilitySee also
Keyboard.getLayoutMap()
navigator.language
navigator.languages
The ECMAScript Internationalization API by Norbert Lindenberg (2012)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIntlBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Intl namespace object contains several constructors as well as functionality common to the internationalization constructors and other language sensitive functions. Collectively, they comprise the ECMAScript Internationalization API, which provides language sensitive string comparison, number formatting, date and time formatting, and more.DescriptionUnlike most global objects, Intl is not a constructor. You cannot use it with the new operator or invoke the Intl object as a function. All properties and methods of Intl are static (just like the Math object).
The internationalization constructors as well as several language sensitive methods of other constructors (listed under See also) use a common pattern for identifying locales and determining the one they will actually use: they all accept locales and options arguments, and negotiate the requested locale(s) against the locales they support using an algorithm specified in the options.localeMatcher property.locales argumentThe locales argument is used to determine the locale used in a given operation. The JavaScript implementation examines locales, and then computes a locale it understands that comes closest to satisfying the expressed preference. locales may be:

undefined (or omitted): The implementation's default locale will be used.
A locale: A locale identifier or an Intl.Locale object that wraps a locale identifier.
A list of locales: Any other value, that will be converted into an object and then treated as an array of locales.

In the latter two cases, the actual locale used is the best-supported locale determined by locale negotiation. If a locale identifier is not a string or an object, a TypeError is thrown. If a locale identifier is a string that's syntactically invalid, a RangeError is thrown. If a locale identifier is well-formed but the implementation doesn't recognize it, it is ignored and the next locale in the list is considered, eventually falling back to the system's locale. However, you shouldn't rely on a particular locale name being ignored, because the implementation may add data for any locale in the future. For example, new Intl.DateTimeFormat("default") uses the implementation's default locale only because "default" is syntactically valid but not recognized as any locale.
A locale identifier is a string that consists of:

A language subtag with 2–3 or 5–8 letters
A script subtag with 4 letters Optional
A region subtag with either 2 letters or 3 digits Optional
One or more variant subtags (all of which must be unique), each with either 5–8 alphanumerals or a digit followed by 3 alphanumerals Optional
One or more BCP 47 extension sequences Optional
A private-use extension sequence Optional

Each subtag and sequence are separated by hyphens. Locale identifiers are case-insensitive ASCII. However, it's conventional to use title case (the first letter is capitalized, successive letters are lower case) for script subtags, upper case for region subtags, and lower case for everything else. For example:

"hi": Hindi (language)
"de-AT": German (language) as used in Austria (region)
"zh-Hans-CN": Chinese (language) written in simplified characters (script) as used in China (region)
"en-emodeng": English (language) in the "Early modern English" dialect (variant)

Subtags identifying languages, scripts, regions (including countries), and (rarely used) variants are registered in the IANA Language Subtag Registry. This registry is periodically updated over time, and implementations may not always be up to date, so don't rely too much on subtags being universally supported.
BCP 47 extension sequences consist of a single digit or letter (other than "x") and one or more two- to eight-letter or digit subtags separated by hyphens. Only one sequence is permitted for each digit or letter: "de-a-foo-a-foo" is invalid. BCP 47 extension subtags are defined in the Unicode CLDR Project. Currently only two extensions have defined semantics:


The "u" (Unicode) extension can be used to request additional customization of Intl API objects. Examples:

"de-DE-u-co-phonebk": Use the phonebook variant of the German sort order, which interprets umlauted vowels as corresponding character pairs: ä → ae, ö → oe, ü → ue.
"th-TH-u-nu-thai": Use Thai digits (๐, ๑, ๒, ๓, ๔, ๕, ๖, ๗, ๘, ๙) in number formatting.
"ja-JP-u-ca-japanese": Use the Japanese calendar in date and time formatting, so that 2013 is expressed as the year 25 of the Heisei period, or 平成 25.
"en-GB-u-ca-islamic-umalqura": use British English with the Umm al-Qura (Hijri) calendar, where the Gregorian date 14 October, 2017 is the Hijri date 24 Muharram, 1439.



The "t" (transformed) extension indicates transformed content: for example, text that was translated from another locale. No Intl functionality currently considers the "t" extension. However, this extension sometimes contains a nested locale (with no extensions): for example, the transformed extension in "de-t-en" contains the locale identifier for English. If a nested locale is present, it must be a valid locale identifier. For example, because "en-emodeng-emodeng" is invalid (because it contains a duplicate emodeng variant subtag), "de-t-en-emodeng-emodeng" is also invalid.


Finally, a private-use extension sequence using the letter "x" may appear, followed by one or more one- to eight-letter or digit subtags separated by hyphens. This allows applications to encode information for their own private use, that will be ignored by all Intl operations.options argumentThe options argument must be an object with properties that vary between constructors and functions. If the options argument is not provided or is undefined, default values are used for all properties.
One property is supported by all language sensitive constructors and functions: The localeMatcher property, whose value must be a string "lookup" or "best fit" and which selects one of the locale matching algorithms described below.Locale identification and negotiationThe list of locales specified by the locales argument, after Unicode extensions have been removed from them, is interpreted as a prioritized request from the application. The runtime compares it against the locales it has available and picks the best one available. Two matching algorithms exist: the "lookup" matcher follows the Lookup algorithm specified in BCP 47; the "best fit" matcher lets the runtime provide a locale that's at least, but possibly more, suited for the request than the result of the Lookup algorithm. If the application doesn't provide a locales argument, or the runtime doesn't have a locale that matches the request, then the runtime's default locale is used. The matcher can be selected using a property of the options argument (see below).
If the selected locale identifier had a Unicode extension sequence, that extension is now used to customize the constructed object or the behavior of the function. Each constructor or function supports only a subset of the keys defined for the Unicode extension, and the supported values often depend on the locale identifier. For example, the "co" key (collation) is only supported by Intl.Collator, and its "phonebk" value is only supported for German.Static properties
Intl.Collator

Constructor for collators, which are objects that enable language-sensitive string comparison.

Intl.DateTimeFormat

Constructor for objects that enable language-sensitive date and time formatting.

Intl.DisplayNames

Constructor for objects that enable the consistent translation of language, region and script display names.

Intl.DurationFormat

Constructor for objects that enable locale-sensitive duration formatting.

Intl.ListFormat

Constructor for objects that enable language-sensitive list formatting.

Intl.Locale

Constructor for objects that represents a Unicode locale identifier.

Intl.NumberFormat

Constructor for objects that enable language-sensitive number formatting.

Intl.PluralRules

Constructor for objects that enable plural-sensitive formatting and language-specific rules for plurals.

Intl.RelativeTimeFormat

Constructor for objects that enable language-sensitive relative time formatting.

Intl.Segmenter

Constructor for objects that enable locale-sensitive text segmentation.

Intl[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Intl". This property is used in Object.prototype.toString().

Static methods
Intl.getCanonicalLocales()

Returns canonical locale names.

Intl.supportedValuesOf()

Returns a sorted array containing the supported unique calendar, collation, currency, numbering systems, or unit values supported by the implementation.

ExamplesFormatting dates and numbersYou can use Intl to format dates and numbers in a form that's conventional for a specific language and region:
jsconst count = 26254.39;
const date = new Date("2012-05-24");

function log(locale) {
  console.log(
    `${new Intl.DateTimeFormat(locale).format(date)} ${new Intl.NumberFormat(
      locale,
    ).format(count)}`,
  );
}

log("en-US"); // 5/24/2012 26,254.39

log("de-DE"); // 24.5.2012 26.254,39
Using the browser's preferred languageInstead of passing a hardcoded locale name to the Intl methods, you can use the user's preferred language provided by navigator.language:
jsconst date = new Date("2012-05-24");

const formattedDate = new Intl.DateTimeFormat(navigator.language).format(date);

Alternatively, the navigator.languages property provides a sorted list of the user's preferred languages. This list can be passed directly to the Intl constructors to implement preference-based fallback selection of locales. The locale negotiation process is used to pick the most appropriate locale available:
jsconst count = 26254.39;

const formattedCount = new Intl.NumberFormat(navigator.languages).format(count);
SpecificationsSpecificationECMAScript® 2025 Internationalization API Specification # intl-objectBrowser compatibilitySee also
Keyboard.getLayoutMap()
navigator.language
navigator.languages
The ECMAScript Internationalization API by Norbert Lindenberg (2012)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nisFinite()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe isFinite() function determines whether a value is finite, first converting the value to a number if necessary. A finite number is one that's not NaN or ±Infinity. Because coercion inside the isFinite() function can be surprising, you may prefer to use Number.isFinite().Try it
function div(x) {
  if (isFinite(1000 / x)) {
    return "Number is NOT Infinity.";
  }
  return "Number is Infinity!";
}

console.log(div(0));
// Expected output: "Number is Infinity!""

console.log(div(1));
// Expected output: "Number is NOT Infinity."
SyntaxjsisFinite(value)
Parameters
value

The value to be tested.

Return valuefalse if the given value is NaN, Infinity, or -Infinity after being converted to a number; otherwise, true.DescriptionisFinite() is a function property of the global object.
When the argument to the isFinite() function is not of type Number, the value is first coerced to a number, and the resulting value is then compared against NaN and ±Infinity. This is as confusing as the behavior of isNaN — for example, isFinite("1") is true.
Number.isFinite() is a more reliable way to test whether a value is a finite number value, because it returns false for any non-number input.ExamplesUsing isFinite()jsisFinite(Infinity); // false
isFinite(NaN); // false
isFinite(-Infinity); // false

isFinite(0); // true
isFinite(2e64); // true
isFinite(910); // true

// Would've been false with the more robust Number.isFinite():
isFinite(null); // true
isFinite("0"); // true
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-isfinite-numberBrowser compatibilitySee also
Number.isFinite()
Number.NaN
Number.POSITIVE_INFINITY
Number.NEGATIVE_INFINITY\n\nisFinite()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe isFinite() function determines whether a value is finite, first converting the value to a number if necessary. A finite number is one that's not NaN or ±Infinity. Because coercion inside the isFinite() function can be surprising, you may prefer to use Number.isFinite().Try it
function div(x) {
  if (isFinite(1000 / x)) {
    return "Number is NOT Infinity.";
  }
  return "Number is Infinity!";
}

console.log(div(0));
// Expected output: "Number is Infinity!""

console.log(div(1));
// Expected output: "Number is NOT Infinity."
SyntaxjsisFinite(value)
Parameters
value

The value to be tested.

Return valuefalse if the given value is NaN, Infinity, or -Infinity after being converted to a number; otherwise, true.DescriptionisFinite() is a function property of the global object.
When the argument to the isFinite() function is not of type Number, the value is first coerced to a number, and the resulting value is then compared against NaN and ±Infinity. This is as confusing as the behavior of isNaN — for example, isFinite("1") is true.
Number.isFinite() is a more reliable way to test whether a value is a finite number value, because it returns false for any non-number input.ExamplesUsing isFinite()jsisFinite(Infinity); // false
isFinite(NaN); // false
isFinite(-Infinity); // false

isFinite(0); // true
isFinite(2e64); // true
isFinite(910); // true

// Would've been false with the more robust Number.isFinite():
isFinite(null); // true
isFinite("0"); // true
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-isfinite-numberBrowser compatibilitySee also
Number.isFinite()
Number.NaN
Number.POSITIVE_INFINITY
Number.NEGATIVE_INFINITY
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nisFinite()Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe isFinite() function determines whether a value is finite, first converting the value to a number if necessary. A finite number is one that's not NaN or ±Infinity. Because coercion inside the isFinite() function can be surprising, you may prefer to use Number.isFinite().Try it
function div(x) {
  if (isFinite(1000 / x)) {
    return "Number is NOT Infinity.";
  }
  return "Number is Infinity!";
}

console.log(div(0));
// Expected output: "Number is Infinity!""

console.log(div(1));
// Expected output: "Number is NOT Infinity."
SyntaxjsisFinite(value)
Parameters
value

The value to be tested.

Return valuefalse if the given value is NaN, Infinity, or -Infinity after being converted to a number; otherwise, true.DescriptionisFinite() is a function property of the global object.
When the argument to the isFinite() function is not of type Number, the value is first coerced to a number, and the resulting value is then compared against NaN and ±Infinity. This is as confusing as the behavior of isNaN — for example, isFinite("1") is true.
Number.isFinite() is a more reliable way to test whether a value is a finite number value, because it returns false for any non-number input.ExamplesUsing isFinite()jsisFinite(Infinity); // false
isFinite(NaN); // false
isFinite(-Infinity); // false

isFinite(0); // true
isFinite(2e64); // true
isFinite(910); // true

// Would've been false with the more robust Number.isFinite():
isFinite(null); // true
isFinite("0"); // true
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-isfinite-numberBrowser compatibilitySee also
Number.isFinite()
Number.NaN
Number.POSITIVE_INFINITY
Number.NEGATIVE_INFINITY
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\n